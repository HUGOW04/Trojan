#define SQLITE_CORE 1
#define SQLITE_AMALGAMATION 1
#ifndef SQLITE_PRIVATE
# define SQLITE_PRIVATE static
#endif


#ifndef SQLITEINT_H
#define SQLITEINT_H




#ifndef SQLITE_TCLAPI
#  define SQLITE_TCLAPI
#endif


#if defined(_MSC_VER) && _MSC_VER>=1400
#  define _CRT_RAND_S
#endif





#ifndef SQLITE_MSVC_H
#define SQLITE_MSVC_H

#if defined(_MSC_VER)
#pragma warning(disable : 4054)
#pragma warning(disable : 4055)
#pragma warning(disable : 4100)
#pragma warning(disable : 4127)
#pragma warning(disable : 4130)
#pragma warning(disable : 4152)
#pragma warning(disable : 4189)
#pragma warning(disable : 4206)
#pragma warning(disable : 4210)
#pragma warning(disable : 4232)
#pragma warning(disable : 4244)
#pragma warning(disable : 4305)
#pragma warning(disable : 4306)
#pragma warning(disable : 4702)
#pragma warning(disable : 4706)
#endif 

#endif 








#if defined(__RTP__) || defined(_WRS_KERNEL)

#include <vxWorks.h>
#include <pthread.h>  
#define OS_VXWORKS 1
#define SQLITE_OS_OTHER 0
#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1
#define SQLITE_OMIT_LOAD_EXTENSION 1
#define SQLITE_ENABLE_LOCKING_STYLE 0
#define HAVE_UTIME 1
#else

#define OS_VXWORKS 0
#define HAVE_FCHOWN 1
#define HAVE_READLINK 1
#define HAVE_LSTAT 1
#endif 





#ifndef SQLITE_DISABLE_LFS
# define _LARGE_FILE       1
# ifndef _FILE_OFFSET_BITS
#   define _FILE_OFFSET_BITS 64
# endif
# define _LARGEFILE_SOURCE 1
#endif


#ifdef __GNUC__
# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)
#else
# define GCC_VERSION 0
#endif


#if defined(__GNUC__) && !defined(_GNU_SOURCE)
# define _GNU_SOURCE
#endif

#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)
# define _BSD_SOURCE
#endif


#if defined(_HAVE_MINGW_H)
# include "mingw.h"
#elif defined(_HAVE__MINGW_H)
# include "_mingw.h"
#endif


#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) && \
    defined(_WIN32) && !defined(_WIN64) && \
    defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 && \
    defined(__MSVCRT__)
# define _USE_32BIT_TIME_T
#endif





#ifndef SQLITE3_H
#define SQLITE3_H
#include <stdarg.h>     


#if 0
extern "C" {
#endif


	
#ifndef SQLITE_EXTERN
# define SQLITE_EXTERN extern
#endif
#ifndef SQLITE_API
# define SQLITE_API
#endif
#ifndef SQLITE_CDECL
# define SQLITE_CDECL
#endif
#ifndef SQLITE_APICALL
# define SQLITE_APICALL
#endif
#ifndef SQLITE_STDCALL
# define SQLITE_STDCALL SQLITE_APICALL
#endif
#ifndef SQLITE_CALLBACK
# define SQLITE_CALLBACK
#endif
#ifndef SQLITE_SYSAPI
# define SQLITE_SYSAPI
#endif

	
#define SQLITE_DEPRECATED
#define SQLITE_EXPERIMENTAL

	
#ifdef SQLITE_VERSION
# undef SQLITE_VERSION
#endif
#ifdef SQLITE_VERSION_NUMBER
# undef SQLITE_VERSION_NUMBER
#endif

	
#define SQLITE_VERSION        "3.15.2"
#define SQLITE_VERSION_NUMBER 3015002
#define SQLITE_SOURCE_ID      "2016-11-28 19:13:37 bbd85d235f7037c6a033a9690534391ffeacecc8"

	
	SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
	SQLITE_API const char *sqlite3_libversion(void);
	SQLITE_API const char *sqlite3_sourceid(void);
	SQLITE_API int sqlite3_libversion_number(void);

	
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
	SQLITE_API int sqlite3_compileoption_used(const char *zOptName);
	SQLITE_API const char *sqlite3_compileoption_get(int N);
#endif

	
	SQLITE_API int sqlite3_threadsafe(void);

	
	typedef struct sqlite3 sqlite3;

	
#ifdef SQLITE_INT64_TYPE
	typedef SQLITE_INT64_TYPE sqlite_int64;
	typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;
#elif defined(_MSC_VER) || defined(__BORLANDC__)
	typedef __int64 sqlite_int64;
	typedef unsigned __int64 sqlite_uint64;
#else
	typedef long long int sqlite_int64;
	typedef unsigned long long int sqlite_uint64;
#endif
	typedef sqlite_int64 sqlite3_int64;
	typedef sqlite_uint64 sqlite3_uint64;

	
#ifdef SQLITE_OMIT_FLOATING_POINT
# define double sqlite3_int64
#endif

	
	SQLITE_API int sqlite3_close(sqlite3*);
	SQLITE_API int sqlite3_close_v2(sqlite3*);

	
	typedef int(*sqlite3_callback)(void*, int, char**, char**);

	
	SQLITE_API int sqlite3_exec(
		sqlite3*,                                  
		const char *sql,                           
		int(*callback)(void*, int, char**, char**),  
		void *,                                    
		char **errmsg                              
	);

	
#define SQLITE_OK           0   
	
#define SQLITE_ERROR        1   
#define SQLITE_INTERNAL     2   
#define SQLITE_PERM         3   
#define SQLITE_ABORT        4   
#define SQLITE_BUSY         5   
#define SQLITE_LOCKED       6   
#define SQLITE_NOMEM        7   
#define SQLITE_READONLY     8   
#define SQLITE_INTERRUPT    9   
#define SQLITE_IOERR       10   
#define SQLITE_CORRUPT     11   
#define SQLITE_NOTFOUND    12   
#define SQLITE_FULL        13   
#define SQLITE_CANTOPEN    14   
#define SQLITE_PROTOCOL    15   
#define SQLITE_EMPTY       16   
#define SQLITE_SCHEMA      17   
#define SQLITE_TOOBIG      18   
#define SQLITE_CONSTRAINT  19   
#define SQLITE_MISMATCH    20   
#define SQLITE_MISUSE      21   
#define SQLITE_NOLFS       22   
#define SQLITE_AUTH        23   
#define SQLITE_FORMAT      24   
#define SQLITE_RANGE       25   
#define SQLITE_NOTADB      26   
#define SQLITE_NOTICE      27   
#define SQLITE_WARNING     28   
#define SQLITE_ROW         100  
#define SQLITE_DONE        101  
	

	
#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))
#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))
#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))
#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))
#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))
#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))
#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))
#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))
#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))
#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))
#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))
#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))
#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))
#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))
#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))
#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))
#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))
#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))
#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))
#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))
#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))
#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))
#define SQLITE_IOERR_DELETE_NOENT      (SQLITE_IOERR | (23<<8))
#define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))
#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))
#define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))
#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))
#define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28<<8))
#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))
#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))
#define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))
#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))
#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))
#define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3<<8))
#define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4<<8))
#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))
#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))
#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))
#define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3<<8))
#define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4<<8))
#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))
#define SQLITE_CONSTRAINT_CHECK        (SQLITE_CONSTRAINT | (1<<8))
#define SQLITE_CONSTRAINT_COMMITHOOK   (SQLITE_CONSTRAINT | (2<<8))
#define SQLITE_CONSTRAINT_FOREIGNKEY   (SQLITE_CONSTRAINT | (3<<8))
#define SQLITE_CONSTRAINT_FUNCTION     (SQLITE_CONSTRAINT | (4<<8))
#define SQLITE_CONSTRAINT_NOTNULL      (SQLITE_CONSTRAINT | (5<<8))
#define SQLITE_CONSTRAINT_PRIMARYKEY   (SQLITE_CONSTRAINT | (6<<8))
#define SQLITE_CONSTRAINT_TRIGGER      (SQLITE_CONSTRAINT | (7<<8))
#define SQLITE_CONSTRAINT_UNIQUE       (SQLITE_CONSTRAINT | (8<<8))
#define SQLITE_CONSTRAINT_VTAB         (SQLITE_CONSTRAINT | (9<<8))
#define SQLITE_CONSTRAINT_ROWID        (SQLITE_CONSTRAINT |(10<<8))
#define SQLITE_NOTICE_RECOVER_WAL      (SQLITE_NOTICE | (1<<8))
#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))
#define SQLITE_WARNING_AUTOINDEX       (SQLITE_WARNING | (1<<8))
#define SQLITE_AUTH_USER               (SQLITE_AUTH | (1<<8))
#define SQLITE_OK_LOAD_PERMANENTLY     (SQLITE_OK | (1<<8))

	
#define SQLITE_OPEN_READONLY         0x00000001  
#define SQLITE_OPEN_READWRITE        0x00000002  
#define SQLITE_OPEN_CREATE           0x00000004  
#define SQLITE_OPEN_DELETEONCLOSE    0x00000008  
#define SQLITE_OPEN_EXCLUSIVE        0x00000010  
#define SQLITE_OPEN_AUTOPROXY        0x00000020  
#define SQLITE_OPEN_URI              0x00000040  
#define SQLITE_OPEN_MEMORY           0x00000080  
#define SQLITE_OPEN_MAIN_DB          0x00000100  
#define SQLITE_OPEN_TEMP_DB          0x00000200  
#define SQLITE_OPEN_TRANSIENT_DB     0x00000400  
#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  
#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  
#define SQLITE_OPEN_SUBJOURNAL       0x00002000  
#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  
#define SQLITE_OPEN_NOMUTEX          0x00008000  
#define SQLITE_OPEN_FULLMUTEX        0x00010000  
#define SQLITE_OPEN_SHAREDCACHE      0x00020000  
#define SQLITE_OPEN_PRIVATECACHE     0x00040000  
#define SQLITE_OPEN_WAL              0x00080000  

	

	
#define SQLITE_IOCAP_ATOMIC                 0x00000001
#define SQLITE_IOCAP_ATOMIC512              0x00000002
#define SQLITE_IOCAP_ATOMIC1K               0x00000004
#define SQLITE_IOCAP_ATOMIC2K               0x00000008
#define SQLITE_IOCAP_ATOMIC4K               0x00000010
#define SQLITE_IOCAP_ATOMIC8K               0x00000020
#define SQLITE_IOCAP_ATOMIC16K              0x00000040
#define SQLITE_IOCAP_ATOMIC32K              0x00000080
#define SQLITE_IOCAP_ATOMIC64K              0x00000100
#define SQLITE_IOCAP_SAFE_APPEND            0x00000200
#define SQLITE_IOCAP_SEQUENTIAL             0x00000400
#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800
#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000
#define SQLITE_IOCAP_IMMUTABLE              0x00002000

	
#define SQLITE_LOCK_NONE          0
#define SQLITE_LOCK_SHARED        1
#define SQLITE_LOCK_RESERVED      2
#define SQLITE_LOCK_PENDING       3
#define SQLITE_LOCK_EXCLUSIVE     4

	
#define SQLITE_SYNC_NORMAL        0x00002
#define SQLITE_SYNC_FULL          0x00003
#define SQLITE_SYNC_DATAONLY      0x00010

	
	typedef struct sqlite3_file sqlite3_file;
	struct sqlite3_file {
		const struct sqlite3_io_methods *pMethods;  
	};

	
	typedef struct sqlite3_io_methods sqlite3_io_methods;
	struct sqlite3_io_methods {
		int iVersion;
		int(*xClose)(sqlite3_file*);
		int(*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
		int(*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
		int(*xTruncate)(sqlite3_file*, sqlite3_int64 size);
		int(*xSync)(sqlite3_file*, int flags);
		int(*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
		int(*xLock)(sqlite3_file*, int);
		int(*xUnlock)(sqlite3_file*, int);
		int(*xCheckReservedLock)(sqlite3_file*, int *pResOut);
		int(*xFileControl)(sqlite3_file*, int op, void *pArg);
		int(*xSectorSize)(sqlite3_file*);
		int(*xDeviceCharacteristics)(sqlite3_file*);
		
		int(*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
		int(*xShmLock)(sqlite3_file*, int offset, int n, int flags);
		void(*xShmBarrier)(sqlite3_file*);
		int(*xShmUnmap)(sqlite3_file*, int deleteFlag);
		
		int(*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
		int(*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);
		
		
	};

	
#define SQLITE_FCNTL_LOCKSTATE               1
#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2
#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3
#define SQLITE_FCNTL_LAST_ERRNO              4
#define SQLITE_FCNTL_SIZE_HINT               5
#define SQLITE_FCNTL_CHUNK_SIZE              6
#define SQLITE_FCNTL_FILE_POINTER            7
#define SQLITE_FCNTL_SYNC_OMITTED            8
#define SQLITE_FCNTL_WIN32_AV_RETRY          9
#define SQLITE_FCNTL_PERSIST_WAL            10
#define SQLITE_FCNTL_OVERWRITE              11
#define SQLITE_FCNTL_VFSNAME                12
#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13
#define SQLITE_FCNTL_PRAGMA                 14
#define SQLITE_FCNTL_BUSYHANDLER            15
#define SQLITE_FCNTL_TEMPFILENAME           16
#define SQLITE_FCNTL_MMAP_SIZE              18
#define SQLITE_FCNTL_TRACE                  19
#define SQLITE_FCNTL_HAS_MOVED              20
#define SQLITE_FCNTL_SYNC                   21
#define SQLITE_FCNTL_COMMIT_PHASETWO        22
#define SQLITE_FCNTL_WIN32_SET_HANDLE       23
#define SQLITE_FCNTL_WAL_BLOCK              24
#define SQLITE_FCNTL_ZIPVFS                 25
#define SQLITE_FCNTL_RBU                    26
#define SQLITE_FCNTL_VFS_POINTER            27
#define SQLITE_FCNTL_JOURNAL_POINTER        28
#define SQLITE_FCNTL_WIN32_GET_HANDLE       29

	
#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE
#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO


	
	typedef struct sqlite3_mutex sqlite3_mutex;

	
	typedef struct sqlite3_api_routines sqlite3_api_routines;

	
	typedef struct sqlite3_vfs sqlite3_vfs;
	typedef void(*sqlite3_syscall_ptr)(void);
	struct sqlite3_vfs {
		int iVersion;            
		int szOsFile;            
		int mxPathname;          
		sqlite3_vfs *pNext;      
		const char *zName;       
		void *pAppData;          
		int(*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
			int flags, int *pOutFlags);
		int(*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
		int(*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
		int(*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
		void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
		void(*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
		void(*(*xDlSym)(sqlite3_vfs*, void*, const char *zSymbol))(void);
		void(*xDlClose)(sqlite3_vfs*, void*);
		int(*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
		int(*xSleep)(sqlite3_vfs*, int microseconds);
		int(*xCurrentTime)(sqlite3_vfs*, double*);
		int(*xGetLastError)(sqlite3_vfs*, int, char *);
		
		int(*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);
		
		int(*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
		sqlite3_syscall_ptr(*xGetSystemCall)(sqlite3_vfs*, const char *zName);
		const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);
		
	};

	
#define SQLITE_ACCESS_EXISTS    0
#define SQLITE_ACCESS_READWRITE 1   
#define SQLITE_ACCESS_READ      2   

	
#define SQLITE_SHM_UNLOCK       1
#define SQLITE_SHM_LOCK         2
#define SQLITE_SHM_SHARED       4
#define SQLITE_SHM_EXCLUSIVE    8

	
#define SQLITE_SHM_NLOCK        8


	
	SQLITE_API int sqlite3_initialize(void);
	SQLITE_API int sqlite3_shutdown(void);
	SQLITE_API int sqlite3_os_init(void);
	SQLITE_API int sqlite3_os_end(void);

	
	SQLITE_API int sqlite3_config(int, ...);

	
	SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);

	
	typedef struct sqlite3_mem_methods sqlite3_mem_methods;
	struct sqlite3_mem_methods {
		void *(*xMalloc)(int);         
		void(*xFree)(void*);          
		void *(*xRealloc)(void*, int);  
		int(*xSize)(void*);           
		int(*xRoundup)(int);          
		int(*xInit)(void*);           
		void(*xShutdown)(void*);      
		void *pAppData;                
	};

	
#define SQLITE_CONFIG_SINGLETHREAD  1  
#define SQLITE_CONFIG_MULTITHREAD   2  
#define SQLITE_CONFIG_SERIALIZED    3  
#define SQLITE_CONFIG_MALLOC        4  
#define SQLITE_CONFIG_GETMALLOC     5  
#define SQLITE_CONFIG_SCRATCH       6  
#define SQLITE_CONFIG_PAGECACHE     7  
#define SQLITE_CONFIG_HEAP          8  
#define SQLITE_CONFIG_MEMSTATUS     9  
#define SQLITE_CONFIG_MUTEX        10  
#define SQLITE_CONFIG_GETMUTEX     11  
	
#define SQLITE_CONFIG_LOOKASIDE    13  
#define SQLITE_CONFIG_PCACHE       14  
#define SQLITE_CONFIG_GETPCACHE    15  
#define SQLITE_CONFIG_LOG          16  
#define SQLITE_CONFIG_URI          17  
#define SQLITE_CONFIG_PCACHE2      18  
#define SQLITE_CONFIG_GETPCACHE2   19  
#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20  
#define SQLITE_CONFIG_SQLLOG       21  
#define SQLITE_CONFIG_MMAP_SIZE    22  
#define SQLITE_CONFIG_WIN32_HEAPSIZE      23  
#define SQLITE_CONFIG_PCACHE_HDRSZ        24  
#define SQLITE_CONFIG_PMASZ               25  
#define SQLITE_CONFIG_STMTJRNL_SPILL      26  

	
#define SQLITE_DBCONFIG_MAINDBNAME            1000 
#define SQLITE_DBCONFIG_LOOKASIDE             1001 
#define SQLITE_DBCONFIG_ENABLE_FKEY           1002 
#define SQLITE_DBCONFIG_ENABLE_TRIGGER        1003 
#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 
#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 


	
	SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);

	
	SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);

	
	SQLITE_API int sqlite3_changes(sqlite3*);

	
	SQLITE_API int sqlite3_total_changes(sqlite3*);

	
	SQLITE_API void sqlite3_interrupt(sqlite3*);

	
	SQLITE_API int sqlite3_complete(const char *sql);
	SQLITE_API int sqlite3_complete16(const void *sql);

	
	SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*, int), void*);

	
	SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);

	
	SQLITE_API int sqlite3_get_table(
		sqlite3 *db,          
		const char *zSql,     
		char ***pazResult,    
		int *pnRow,           
		int *pnColumn,        
		char **pzErrmsg       
	);
	SQLITE_API void sqlite3_free_table(char **result);

	
	SQLITE_API char *sqlite3_mprintf(const char*, ...);
	SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
	SQLITE_API char *sqlite3_snprintf(int, char*, const char*, ...);
	SQLITE_API char *sqlite3_vsnprintf(int, char*, const char*, va_list);

	
	SQLITE_API void *sqlite3_malloc(int);
	SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);
	SQLITE_API void *sqlite3_realloc(void*, int);
	SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);
	SQLITE_API void sqlite3_free(void*);
	SQLITE_API sqlite3_uint64 sqlite3_msize(void*);

	
	SQLITE_API sqlite3_int64 sqlite3_memory_used(void);
	SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);

	
	SQLITE_API void sqlite3_randomness(int N, void *P);

	
	SQLITE_API int sqlite3_set_authorizer(
		sqlite3*,
		int(*xAuth)(void*, int, const char*, const char*, const char*, const char*),
		void *pUserData
	);

	
#define SQLITE_DENY   1   
#define SQLITE_IGNORE 2   

	
	
#define SQLITE_CREATE_INDEX          1   
#define SQLITE_CREATE_TABLE          2   
#define SQLITE_CREATE_TEMP_INDEX     3   
#define SQLITE_CREATE_TEMP_TABLE     4   
#define SQLITE_CREATE_TEMP_TRIGGER   5   
#define SQLITE_CREATE_TEMP_VIEW      6   
#define SQLITE_CREATE_TRIGGER        7   
#define SQLITE_CREATE_VIEW           8   
#define SQLITE_DELETE                9   
#define SQLITE_DROP_INDEX           10   
#define SQLITE_DROP_TABLE           11   
#define SQLITE_DROP_TEMP_INDEX      12   
#define SQLITE_DROP_TEMP_TABLE      13   
#define SQLITE_DROP_TEMP_TRIGGER    14   
#define SQLITE_DROP_TEMP_VIEW       15   
#define SQLITE_DROP_TRIGGER         16   
#define SQLITE_DROP_VIEW            17   
#define SQLITE_INSERT               18   
#define SQLITE_PRAGMA               19   
#define SQLITE_READ                 20   
#define SQLITE_SELECT               21   
#define SQLITE_TRANSACTION          22   
#define SQLITE_UPDATE               23   
#define SQLITE_ATTACH               24   
#define SQLITE_DETACH               25   
#define SQLITE_ALTER_TABLE          26   
#define SQLITE_REINDEX              27   
#define SQLITE_ANALYZE              28   
#define SQLITE_CREATE_VTABLE        29   
#define SQLITE_DROP_VTABLE          30   
#define SQLITE_FUNCTION             31   
#define SQLITE_SAVEPOINT            32   
#define SQLITE_COPY                  0   
#define SQLITE_RECURSIVE            33   

	
	SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,
		void(*xTrace)(void*, const char*), void*);
	SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,
		void(*xProfile)(void*, const char*, sqlite3_uint64), void*);

	
#define SQLITE_TRACE_STMT       0x01
#define SQLITE_TRACE_PROFILE    0x02
#define SQLITE_TRACE_ROW        0x04
#define SQLITE_TRACE_CLOSE      0x08

	
	SQLITE_API int sqlite3_trace_v2(
		sqlite3*,
		unsigned uMask,
		int(*xCallback)(unsigned, void*, void*, void*),
		void *pCtx
	);

	
	SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);

	
	SQLITE_API int sqlite3_open(
		const char *filename,   
		sqlite3 **ppDb          
	);
	SQLITE_API int sqlite3_open16(
		const void *filename,   
		sqlite3 **ppDb          
	);
	SQLITE_API int sqlite3_open_v2(
		const char *filename,   
		sqlite3 **ppDb,         
		int flags,              
		const char *zVfs        
	);

	
	SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
	SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
	SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);


	
	SQLITE_API int sqlite3_errcode(sqlite3 *db);
	SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);
	SQLITE_API const char *sqlite3_errmsg(sqlite3*);
	SQLITE_API const void *sqlite3_errmsg16(sqlite3*);
	SQLITE_API const char *sqlite3_errstr(int);

	
	typedef struct sqlite3_stmt sqlite3_stmt;

	
	SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);

	
#define SQLITE_LIMIT_LENGTH                    0
#define SQLITE_LIMIT_SQL_LENGTH                1
#define SQLITE_LIMIT_COLUMN                    2
#define SQLITE_LIMIT_EXPR_DEPTH                3
#define SQLITE_LIMIT_COMPOUND_SELECT           4
#define SQLITE_LIMIT_VDBE_OP                   5
#define SQLITE_LIMIT_FUNCTION_ARG              6
#define SQLITE_LIMIT_ATTACHED                  7
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8
#define SQLITE_LIMIT_VARIABLE_NUMBER           9
#define SQLITE_LIMIT_TRIGGER_DEPTH            10
#define SQLITE_LIMIT_WORKER_THREADS           11

	
	SQLITE_API int sqlite3_prepare(
		sqlite3 *db,            
		const char *zSql,       
		int nByte,              
		sqlite3_stmt **ppStmt,  
		const char **pzTail     
	);
	SQLITE_API int sqlite3_prepare_v2(
		sqlite3 *db,            
		const char *zSql,       
		int nByte,              
		sqlite3_stmt **ppStmt,  
		const char **pzTail     
	);
	SQLITE_API int sqlite3_prepare16(
		sqlite3 *db,            
		const void *zSql,       
		int nByte,              
		sqlite3_stmt **ppStmt,  
		const void **pzTail     
	);
	SQLITE_API int sqlite3_prepare16_v2(
		sqlite3 *db,            
		const void *zSql,       
		int nByte,              
		sqlite3_stmt **ppStmt,  
		const void **pzTail     
	);

	
	SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
	SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);

	
	SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);

	
	SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);

	
	typedef struct Mem sqlite3_value;

	
	typedef struct sqlite3_context sqlite3_context;

	
	SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
	SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
		void(*)(void*));
	SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);
	SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);
	SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
	SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);
	SQLITE_API int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int, void(*)(void*));
	SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
	SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
		void(*)(void*), unsigned char encoding);
	SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
	SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
	SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);

	
	SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);

	
	SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);

	
	SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);

	
	SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);

	
	SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);

	
	SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);
	SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);

	
	SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*, int);
	SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*, int);
	SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*, int);
	SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*, int);
	SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*, int);
	SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*, int);

	
	SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*, int);
	SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*, int);

	
	SQLITE_API int sqlite3_step(sqlite3_stmt*);

	
	SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);

	
#define SQLITE_INTEGER  1
#define SQLITE_FLOAT    2
#define SQLITE_BLOB     4
#define SQLITE_NULL     5
#ifdef SQLITE_TEXT
# undef SQLITE_TEXT
#else
# define SQLITE_TEXT     3
#endif
#define SQLITE3_TEXT     3

	
	SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
	SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
	SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
	SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
	SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
	SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
	SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
	SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
	SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
	SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);

	
	SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);

	
	SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);

	
	SQLITE_API int sqlite3_create_function(
		sqlite3 *db,
		const char *zFunctionName,
		int nArg,
		int eTextRep,
		void *pApp,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*)
	);
	SQLITE_API int sqlite3_create_function16(
		sqlite3 *db,
		const void *zFunctionName,
		int nArg,
		int eTextRep,
		void *pApp,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*)
	);
	SQLITE_API int sqlite3_create_function_v2(
		sqlite3 *db,
		const char *zFunctionName,
		int nArg,
		int eTextRep,
		void *pApp,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*),
		void(*xDestroy)(void*)
	);

	
#define SQLITE_UTF8           1    
#define SQLITE_UTF16LE        2    
#define SQLITE_UTF16BE        3    
#define SQLITE_UTF16          4    
#define SQLITE_ANY            5    
#define SQLITE_UTF16_ALIGNED  8    

	
#define SQLITE_DETERMINISTIC    0x800

	
#ifndef SQLITE_OMIT_DEPRECATED
	SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);
	SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);
	SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
	SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);
	SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);
	SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*, sqlite3_int64, int),
		void*, sqlite3_int64);
#endif

	
	SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
	SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
	SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
	SQLITE_API double sqlite3_value_double(sqlite3_value*);
	SQLITE_API int sqlite3_value_int(sqlite3_value*);
	SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
	SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
	SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
	SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
	SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
	SQLITE_API int sqlite3_value_type(sqlite3_value*);
	SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);

	
	SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);

	
	SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
	SQLITE_API void sqlite3_value_free(sqlite3_value*);

	
	SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);

	
	SQLITE_API void *sqlite3_user_data(sqlite3_context*);

	
	SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);

	
	SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);
	SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void(*)(void*));


	
	typedef void(*sqlite3_destructor_type)(void*);
#define SQLITE_STATIC      ((sqlite3_destructor_type)0)
#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)

	
	SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
	SQLITE_API void sqlite3_result_blob64(sqlite3_context*, const void*,
		sqlite3_uint64, void(*)(void*));
	SQLITE_API void sqlite3_result_double(sqlite3_context*, double);
	SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
	SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);
	SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);
	SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);
	SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);
	SQLITE_API void sqlite3_result_int(sqlite3_context*, int);
	SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
	SQLITE_API void sqlite3_result_null(sqlite3_context*);
	SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
	SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*, sqlite3_uint64,
		void(*)(void*), unsigned char encoding);
	SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
	SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int, void(*)(void*));
	SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int, void(*)(void*));
	SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
	SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
	SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);


	
	SQLITE_API void sqlite3_result_subtype(sqlite3_context*, unsigned int);

	
	SQLITE_API int sqlite3_create_collation(
		sqlite3*,
		const char *zName,
		int eTextRep,
		void *pArg,
		int(*xCompare)(void*, int, const void*, int, const void*)
	);
	SQLITE_API int sqlite3_create_collation_v2(
		sqlite3*,
		const char *zName,
		int eTextRep,
		void *pArg,
		int(*xCompare)(void*, int, const void*, int, const void*),
		void(*xDestroy)(void*)
	);
	SQLITE_API int sqlite3_create_collation16(
		sqlite3*,
		const void *zName,
		int eTextRep,
		void *pArg,
		int(*xCompare)(void*, int, const void*, int, const void*)
	);

	
	SQLITE_API int sqlite3_collation_needed(
		sqlite3*,
		void*,
		void(*)(void*, sqlite3*, int eTextRep, const char*)
	);
	SQLITE_API int sqlite3_collation_needed16(
		sqlite3*,
		void*,
		void(*)(void*, sqlite3*, int eTextRep, const void*)
	);

#ifdef SQLITE_HAS_CODEC
	
	SQLITE_API int sqlite3_key(
		sqlite3 *db,                   
		const void *pKey, int nKey     
	);
	SQLITE_API int sqlite3_key_v2(
		sqlite3 *db,                   
		const char *zDbName,           
		const void *pKey, int nKey     
	);

	
	SQLITE_API int sqlite3_rekey(
		sqlite3 *db,                   
		const void *pKey, int nKey     
	);
	SQLITE_API int sqlite3_rekey_v2(
		sqlite3 *db,                   
		const char *zDbName,           
		const void *pKey, int nKey     
	);

	
	SQLITE_API void sqlite3_activate_see(
		const char *zPassPhrase        
	);
#endif

#ifdef SQLITE_ENABLE_CEROD
	
	SQLITE_API void sqlite3_activate_cerod(
		const char *zPassPhrase        
	);
#endif

	
	SQLITE_API int sqlite3_sleep(int);

	
	SQLITE_API char *sqlite3_temp_directory;

	
	SQLITE_API char *sqlite3_data_directory;

	
	SQLITE_API int sqlite3_get_autocommit(sqlite3*);

	
	SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);

	
	SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);

	
	SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);

	
	SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);

	
	SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
	SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);

	
	SQLITE_API void *sqlite3_update_hook(
		sqlite3*,
		void(*)(void *, int, char const *, char const *, sqlite3_int64),
		void*
	);

	
	SQLITE_API int sqlite3_enable_shared_cache(int);

	
	SQLITE_API int sqlite3_release_memory(int);

	
	SQLITE_API int sqlite3_db_release_memory(sqlite3*);

	
	SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);

	
	SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);


	
	SQLITE_API int sqlite3_table_column_metadata(
		sqlite3 *db,                
		const char *zDbName,        
		const char *zTableName,     
		const char *zColumnName,    
		char const **pzDataType,    
		char const **pzCollSeq,     
		int *pNotNull,              
		int *pPrimaryKey,           
		int *pAutoinc               
	);

	
	SQLITE_API int sqlite3_load_extension(
		sqlite3 *db,          
		const char *zFile,    
		const char *zProc,    
		char **pzErrMsg       
	);

	
	SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);

	
	SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void));

	
	SQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));

	
	SQLITE_API void sqlite3_reset_auto_extension(void);

	

	
	typedef struct sqlite3_vtab sqlite3_vtab;
	typedef struct sqlite3_index_info sqlite3_index_info;
	typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
	typedef struct sqlite3_module sqlite3_module;

	
	struct sqlite3_module {
		int iVersion;
		int(*xCreate)(sqlite3*, void *pAux,
			int argc, const char *const*argv,
			sqlite3_vtab **ppVTab, char**);
		int(*xConnect)(sqlite3*, void *pAux,
			int argc, const char *const*argv,
			sqlite3_vtab **ppVTab, char**);
		int(*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
		int(*xDisconnect)(sqlite3_vtab *pVTab);
		int(*xDestroy)(sqlite3_vtab *pVTab);
		int(*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
		int(*xClose)(sqlite3_vtab_cursor*);
		int(*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
			int argc, sqlite3_value **argv);
		int(*xNext)(sqlite3_vtab_cursor*);
		int(*xEof)(sqlite3_vtab_cursor*);
		int(*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
		int(*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
		int(*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
		int(*xBegin)(sqlite3_vtab *pVTab);
		int(*xSync)(sqlite3_vtab *pVTab);
		int(*xCommit)(sqlite3_vtab *pVTab);
		int(*xRollback)(sqlite3_vtab *pVTab);
		int(*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
			void(**pxFunc)(sqlite3_context*, int, sqlite3_value**),
			void **ppArg);
		int(*xRename)(sqlite3_vtab *pVtab, const char *zNew);
		
		int(*xSavepoint)(sqlite3_vtab *pVTab, int);
		int(*xRelease)(sqlite3_vtab *pVTab, int);
		int(*xRollbackTo)(sqlite3_vtab *pVTab, int);
	};

	
	struct sqlite3_index_info {
		
		int nConstraint;           
		struct sqlite3_index_constraint {
			int iColumn;              
			unsigned char op;         
			unsigned char usable;     
			int iTermOffset;          
		} *aConstraint;            
		int nOrderBy;              
		struct sqlite3_index_orderby {
			int iColumn;              
			unsigned char desc;       
		} *aOrderBy;               
								   
		struct sqlite3_index_constraint_usage {
			int argvIndex;           
			unsigned char omit;      
		} *aConstraintUsage;
		int idxNum;                
		char *idxStr;              
		int needToFreeIdxStr;      
		int orderByConsumed;       
		double estimatedCost;           
										
		sqlite3_int64 estimatedRows;    
										
		int idxFlags;              
								   
		sqlite3_uint64 colUsed;    
	};

	
#define SQLITE_INDEX_SCAN_UNIQUE      1     

	
#define SQLITE_INDEX_CONSTRAINT_EQ      2
#define SQLITE_INDEX_CONSTRAINT_GT      4
#define SQLITE_INDEX_CONSTRAINT_LE      8
#define SQLITE_INDEX_CONSTRAINT_LT     16
#define SQLITE_INDEX_CONSTRAINT_GE     32
#define SQLITE_INDEX_CONSTRAINT_MATCH  64
#define SQLITE_INDEX_CONSTRAINT_LIKE   65
#define SQLITE_INDEX_CONSTRAINT_GLOB   66
#define SQLITE_INDEX_CONSTRAINT_REGEXP 67

	
	SQLITE_API int sqlite3_create_module(
		sqlite3 *db,               
		const char *zName,         
		const sqlite3_module *p,   
		void *pClientData          
	);
	SQLITE_API int sqlite3_create_module_v2(
		sqlite3 *db,               
		const char *zName,         
		const sqlite3_module *p,   
		void *pClientData,         
		void(*xDestroy)(void*)     
	);

	
	struct sqlite3_vtab {
		const sqlite3_module *pModule;  
		int nRef;                       
		char *zErrMsg;                  
										
	};

	
	struct sqlite3_vtab_cursor {
		sqlite3_vtab *pVtab;      
								  
	};

	
	SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);

	
	SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);

	

	
	typedef struct sqlite3_blob sqlite3_blob;

	
	SQLITE_API int sqlite3_blob_open(
		sqlite3*,
		const char *zDb,
		const char *zTable,
		const char *zColumn,
		sqlite3_int64 iRow,
		int flags,
		sqlite3_blob **ppBlob
	);

	
	SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);

	
	SQLITE_API int sqlite3_blob_close(sqlite3_blob *);

	
	SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);

	
	SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);

	
	SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);

	
	SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
	SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
	SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);

	
	SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
	SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);
	SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);
	SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);
	SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);

	
	typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
	struct sqlite3_mutex_methods {
		int(*xMutexInit)(void);
		int(*xMutexEnd)(void);
		sqlite3_mutex *(*xMutexAlloc)(int);
		void(*xMutexFree)(sqlite3_mutex *);
		void(*xMutexEnter)(sqlite3_mutex *);
		int(*xMutexTry)(sqlite3_mutex *);
		void(*xMutexLeave)(sqlite3_mutex *);
		int(*xMutexHeld)(sqlite3_mutex *);
		int(*xMutexNotheld)(sqlite3_mutex *);
	};

	
#ifndef NDEBUG
	SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
	SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
#endif

	
#define SQLITE_MUTEX_FAST             0
#define SQLITE_MUTEX_RECURSIVE        1
#define SQLITE_MUTEX_STATIC_MASTER    2
#define SQLITE_MUTEX_STATIC_MEM       3  
#define SQLITE_MUTEX_STATIC_MEM2      4  
#define SQLITE_MUTEX_STATIC_OPEN      4  
#define SQLITE_MUTEX_STATIC_PRNG      5  
#define SQLITE_MUTEX_STATIC_LRU       6  
#define SQLITE_MUTEX_STATIC_LRU2      7  
#define SQLITE_MUTEX_STATIC_PMEM      7  
#define SQLITE_MUTEX_STATIC_APP1      8  
#define SQLITE_MUTEX_STATIC_APP2      9  
#define SQLITE_MUTEX_STATIC_APP3     10  
#define SQLITE_MUTEX_STATIC_VFS1     11  
#define SQLITE_MUTEX_STATIC_VFS2     12  
#define SQLITE_MUTEX_STATIC_VFS3     13  

	
	SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);

	
	SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);

	
	SQLITE_API int sqlite3_test_control(int op, ...);

	
#define SQLITE_TESTCTRL_FIRST                    5
#define SQLITE_TESTCTRL_PRNG_SAVE                5
#define SQLITE_TESTCTRL_PRNG_RESTORE             6
#define SQLITE_TESTCTRL_PRNG_RESET               7
#define SQLITE_TESTCTRL_BITVEC_TEST              8
#define SQLITE_TESTCTRL_FAULT_INSTALL            9
#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
#define SQLITE_TESTCTRL_PENDING_BYTE            11
#define SQLITE_TESTCTRL_ASSERT                  12
#define SQLITE_TESTCTRL_ALWAYS                  13
#define SQLITE_TESTCTRL_RESERVE                 14
#define SQLITE_TESTCTRL_OPTIMIZATIONS           15
#define SQLITE_TESTCTRL_ISKEYWORD               16
#define SQLITE_TESTCTRL_SCRATCHMALLOC           17
#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18
#define SQLITE_TESTCTRL_EXPLAIN_STMT            19  
#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD    19
#define SQLITE_TESTCTRL_NEVER_CORRUPT           20
#define SQLITE_TESTCTRL_VDBE_COVERAGE           21
#define SQLITE_TESTCTRL_BYTEORDER               22
#define SQLITE_TESTCTRL_ISINIT                  23
#define SQLITE_TESTCTRL_SORTER_MMAP             24
#define SQLITE_TESTCTRL_IMPOSTER                25
#define SQLITE_TESTCTRL_LAST                    25

	
	SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
	SQLITE_API int sqlite3_status64(
		int op,
		sqlite3_int64 *pCurrent,
		sqlite3_int64 *pHighwater,
		int resetFlag
	);


	
#define SQLITE_STATUS_MEMORY_USED          0
#define SQLITE_STATUS_PAGECACHE_USED       1
#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2
#define SQLITE_STATUS_SCRATCH_USED         3
#define SQLITE_STATUS_SCRATCH_OVERFLOW     4
#define SQLITE_STATUS_MALLOC_SIZE          5
#define SQLITE_STATUS_PARSER_STACK         6
#define SQLITE_STATUS_PAGECACHE_SIZE       7
#define SQLITE_STATUS_SCRATCH_SIZE         8
#define SQLITE_STATUS_MALLOC_COUNT         9

	
	SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);

	
#define SQLITE_DBSTATUS_LOOKASIDE_USED       0
#define SQLITE_DBSTATUS_CACHE_USED           1
#define SQLITE_DBSTATUS_SCHEMA_USED          2
#define SQLITE_DBSTATUS_STMT_USED            3
#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6
#define SQLITE_DBSTATUS_CACHE_HIT            7
#define SQLITE_DBSTATUS_CACHE_MISS           8
#define SQLITE_DBSTATUS_CACHE_WRITE          9
#define SQLITE_DBSTATUS_DEFERRED_FKS        10
#define SQLITE_DBSTATUS_CACHE_USED_SHARED   11
#define SQLITE_DBSTATUS_MAX                 11   


	
	SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op, int resetFlg);

	
#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1
#define SQLITE_STMTSTATUS_SORT              2
#define SQLITE_STMTSTATUS_AUTOINDEX         3
#define SQLITE_STMTSTATUS_VM_STEP           4

	
	typedef struct sqlite3_pcache sqlite3_pcache;

	
	typedef struct sqlite3_pcache_page sqlite3_pcache_page;
	struct sqlite3_pcache_page {
		void *pBuf;        
		void *pExtra;      
	};

	
	typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
	struct sqlite3_pcache_methods2 {
		int iVersion;
		void *pArg;
		int(*xInit)(void*);
		void(*xShutdown)(void*);
		sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
		void(*xCachesize)(sqlite3_pcache*, int nCachesize);
		int(*xPagecount)(sqlite3_pcache*);
		sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
		void(*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
		void(*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,
			unsigned oldKey, unsigned newKey);
		void(*xTruncate)(sqlite3_pcache*, unsigned iLimit);
		void(*xDestroy)(sqlite3_pcache*);
		void(*xShrink)(sqlite3_pcache*);
	};

	
	typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
	struct sqlite3_pcache_methods {
		void *pArg;
		int(*xInit)(void*);
		void(*xShutdown)(void*);
		sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
		void(*xCachesize)(sqlite3_pcache*, int nCachesize);
		int(*xPagecount)(sqlite3_pcache*);
		void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
		void(*xUnpin)(sqlite3_pcache*, void*, int discard);
		void(*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
		void(*xTruncate)(sqlite3_pcache*, unsigned iLimit);
		void(*xDestroy)(sqlite3_pcache*);
	};


	
	typedef struct sqlite3_backup sqlite3_backup;

	
	SQLITE_API sqlite3_backup *sqlite3_backup_init(
		sqlite3 *pDest,                        
		const char *zDestName,                 
		sqlite3 *pSource,                      
		const char *zSourceName                
	);
	SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);
	SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);
	SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);
	SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);

	
	SQLITE_API int sqlite3_unlock_notify(
		sqlite3 *pBlocked,                          
		void(*xNotify)(void **apArg, int nArg),    
		void *pNotifyArg                            
	);


	
	SQLITE_API int sqlite3_stricmp(const char *, const char *);
	SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);

	
	SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);

	
	SQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);

	
	SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);

	
	SQLITE_API void *sqlite3_wal_hook(
		sqlite3*,
		int(*)(void *, sqlite3*, const char*, int),
		void*
	);

	
	SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);

	
	SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);

	
	SQLITE_API int sqlite3_wal_checkpoint_v2(
		sqlite3 *db,                    
		const char *zDb,                
		int eMode,                      
		int *pnLog,                     
		int *pnCkpt                     
	);

	
#define SQLITE_CHECKPOINT_PASSIVE  0  
#define SQLITE_CHECKPOINT_FULL     1  
#define SQLITE_CHECKPOINT_RESTART  2  
#define SQLITE_CHECKPOINT_TRUNCATE 3  

	
	SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);

	
#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1

	
	SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);

	
#define SQLITE_ROLLBACK 1
	
#define SQLITE_FAIL     3
	
#define SQLITE_REPLACE  5

	
#define SQLITE_SCANSTAT_NLOOP    0
#define SQLITE_SCANSTAT_NVISIT   1
#define SQLITE_SCANSTAT_EST      2
#define SQLITE_SCANSTAT_NAME     3
#define SQLITE_SCANSTAT_EXPLAIN  4
#define SQLITE_SCANSTAT_SELECTID 5

	
	SQLITE_API int sqlite3_stmt_scanstatus(
		sqlite3_stmt *pStmt,      
		int idx,                  
		int iScanStatusOp,        
		void *pOut                
	);

	
	SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);

	
	SQLITE_API int sqlite3_db_cacheflush(sqlite3*);

	
	SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_preupdate_hook(
		sqlite3 *db,
		void(*xPreUpdate)(
			void *pCtx,                   
			sqlite3 *db,                  
			int op,                       
			char const *zDb,              
			char const *zName,            
			sqlite3_int64 iKey1,          
			sqlite3_int64 iKey2           
			),
		void*
	);
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_preupdate_old(sqlite3 *, int, sqlite3_value **);
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_preupdate_count(sqlite3 *);
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_preupdate_depth(sqlite3 *);
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_preupdate_new(sqlite3 *, int, sqlite3_value **);

	
	SQLITE_API int sqlite3_system_errno(sqlite3*);

	
	typedef struct sqlite3_snapshot sqlite3_snapshot;

	
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_get(
		sqlite3 *db,
		const char *zSchema,
		sqlite3_snapshot **ppSnapshot
	);

	
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_open(
		sqlite3 *db,
		const char *zSchema,
		sqlite3_snapshot *pSnapshot
	);

	
	SQLITE_API SQLITE_EXPERIMENTAL void sqlite3_snapshot_free(sqlite3_snapshot*);

	
	SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_cmp(
		sqlite3_snapshot *p1,
		sqlite3_snapshot *p2
	);

	
#ifdef SQLITE_OMIT_FLOATING_POINT
# undef double
#endif

#if 0
}  
#endif
#endif 

   
   

#ifndef _SQLITE3RTREE_H_
#define _SQLITE3RTREE_H_


#if 0
extern "C" {
#endif

	typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;
	typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;

	
#ifdef SQLITE_RTREE_INT_ONLY
	typedef sqlite3_int64 sqlite3_rtree_dbl;
#else
	typedef double sqlite3_rtree_dbl;
#endif

	
	SQLITE_API int sqlite3_rtree_geometry_callback(
		sqlite3 *db,
		const char *zGeom,
		int(*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*, int*),
		void *pContext
	);


	
	struct sqlite3_rtree_geometry {
		void *pContext;                 
		int nParam;                     
		sqlite3_rtree_dbl *aParam;      
		void *pUser;                    
		void(*xDelUser)(void *);       
	};

	
	SQLITE_API int sqlite3_rtree_query_callback(
		sqlite3 *db,
		const char *zQueryFunc,
		int(*xQueryFunc)(sqlite3_rtree_query_info*),
		void *pContext,
		void(*xDestructor)(void*)
	);


	
	struct sqlite3_rtree_query_info {
		void *pContext;                   
		int nParam;                       
		sqlite3_rtree_dbl *aParam;        
		void *pUser;                      
		void(*xDelUser)(void*);          
		sqlite3_rtree_dbl *aCoord;        
		unsigned int *anQueue;            
		int nCoord;                       
		int iLevel;                       
		int mxLevel;                      
		sqlite3_int64 iRowid;             
		sqlite3_rtree_dbl rParentScore;   
		int eParentWithin;                
		int eWithin;                      
		sqlite3_rtree_dbl rScore;         
										  
		sqlite3_value **apSqlParam;       
	};

	
#define NOT_WITHIN       0   
#define PARTLY_WITHIN    1   
#define FULLY_WITHIN     2   


#if 0
}  
#endif

#endif  

   
   

#if !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION)
#define __SQLITESESSION_H_ 1

   
#if 0
extern "C" {
#endif


	
	typedef struct sqlite3_session sqlite3_session;

	
	typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;

	
	int sqlite3session_create(
		sqlite3 *db,                    
		const char *zDb,                
		sqlite3_session **ppSession     
	);

	
	void sqlite3session_delete(sqlite3_session *pSession);


	
	int sqlite3session_enable(sqlite3_session *pSession, int bEnable);

	
	int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect);

	
	int sqlite3session_attach(
		sqlite3_session *pSession,      
		const char *zTab                
	);

	
	void sqlite3session_table_filter(
		sqlite3_session *pSession,      
		int(*xFilter)(
			void *pCtx,                   
			const char *zTab              
			),
		void *pCtx                      
	);

	
	int sqlite3session_changeset(
		sqlite3_session *pSession,      
		int *pnChangeset,               
		void **ppChangeset              
	);

	
	int sqlite3session_diff(
		sqlite3_session *pSession,
		const char *zFromDb,
		const char *zTbl,
		char **pzErrMsg
	);


	
	int sqlite3session_patchset(
		sqlite3_session *pSession,      
		int *pnPatchset,                
		void **ppPatchset               
	);

	
	int sqlite3session_isempty(sqlite3_session *pSession);

	
	int sqlite3changeset_start(
		sqlite3_changeset_iter **pp,    
		int nChangeset,                 
		void *pChangeset                
	);


	
	int sqlite3changeset_next(sqlite3_changeset_iter *pIter);

	
	int sqlite3changeset_op(
		sqlite3_changeset_iter *pIter,  
		const char **pzTab,             
		int *pnCol,                     
		int *pOp,                       
		int *pbIndirect                 
	);

	
	int sqlite3changeset_pk(
		sqlite3_changeset_iter *pIter,  
		unsigned char **pabPK,          
		int *pnCol                      
	);

	
	int sqlite3changeset_old(
		sqlite3_changeset_iter *pIter,  
		int iVal,                       
		sqlite3_value **ppValue         
	);

	
	int sqlite3changeset_new(
		sqlite3_changeset_iter *pIter,  
		int iVal,                       
		sqlite3_value **ppValue         
	);

	
	int sqlite3changeset_conflict(
		sqlite3_changeset_iter *pIter,  
		int iVal,                       
		sqlite3_value **ppValue         
	);

	
	int sqlite3changeset_fk_conflicts(
		sqlite3_changeset_iter *pIter,  
		int *pnOut                      
	);


	
	int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter);

	
	int sqlite3changeset_invert(
		int nIn, const void *pIn,       
		int *pnOut, void **ppOut        
	);

	
	int sqlite3changeset_concat(
		int nA,                         
		void *pA,                       
		int nB,                         
		void *pB,                       
		int *pnOut,                     
		void **ppOut                    
	);


	
	typedef struct sqlite3_changegroup sqlite3_changegroup;

	
	int sqlite3changegroup_new(sqlite3_changegroup **pp);

	
	int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);

	
	int sqlite3changegroup_output(
		sqlite3_changegroup*,
		int *pnData,                    
		void **ppData                   
	);

	
	void sqlite3changegroup_delete(sqlite3_changegroup*);

	
	int sqlite3changeset_apply(
		sqlite3 *db,                    
		int nChangeset,                 
		void *pChangeset,               
		int(*xFilter)(
			void *pCtx,                   
			const char *zTab              
			),
		int(*xConflict)(
			void *pCtx,                   
			int eConflict,                
			sqlite3_changeset_iter *p     
			),
		void *pCtx                      
	);

	
#define SQLITE_CHANGESET_DATA        1
#define SQLITE_CHANGESET_NOTFOUND    2
#define SQLITE_CHANGESET_CONFLICT    3
#define SQLITE_CHANGESET_CONSTRAINT  4
#define SQLITE_CHANGESET_FOREIGN_KEY 5

	
#define SQLITE_CHANGESET_OMIT       0
#define SQLITE_CHANGESET_REPLACE    1
#define SQLITE_CHANGESET_ABORT      2

	
	int sqlite3changeset_apply_strm(
		sqlite3 *db,                    
		int(*xInput)(void *pIn, void *pData, int *pnData), 
		void *pIn,                                          
		int(*xFilter)(
			void *pCtx,                   
			const char *zTab              
			),
		int(*xConflict)(
			void *pCtx,                   
			int eConflict,                
			sqlite3_changeset_iter *p     
			),
		void *pCtx                      
	);
	int sqlite3changeset_concat_strm(
		int(*xInputA)(void *pIn, void *pData, int *pnData),
		void *pInA,
		int(*xInputB)(void *pIn, void *pData, int *pnData),
		void *pInB,
		int(*xOutput)(void *pOut, const void *pData, int nData),
		void *pOut
	);
	int sqlite3changeset_invert_strm(
		int(*xInput)(void *pIn, void *pData, int *pnData),
		void *pIn,
		int(*xOutput)(void *pOut, const void *pData, int nData),
		void *pOut
	);
	int sqlite3changeset_start_strm(
		sqlite3_changeset_iter **pp,
		int(*xInput)(void *pIn, void *pData, int *pnData),
		void *pIn
	);
	int sqlite3session_changeset_strm(
		sqlite3_session *pSession,
		int(*xOutput)(void *pOut, const void *pData, int nData),
		void *pOut
	);
	int sqlite3session_patchset_strm(
		sqlite3_session *pSession,
		int(*xOutput)(void *pOut, const void *pData, int nData),
		void *pOut
	);
	int sqlite3changegroup_add_strm(sqlite3_changegroup*,
		int(*xInput)(void *pIn, void *pData, int *pnData),
		void *pIn
	);
	int sqlite3changegroup_output_strm(sqlite3_changegroup*,
		int(*xOutput)(void *pOut, const void *pData, int nData),
		void *pOut
	);


	
#if 0
}
#endif

#endif  






#ifndef _FTS5_H
#define _FTS5_H


#if 0
extern "C" {
#endif

	

	typedef struct Fts5ExtensionApi Fts5ExtensionApi;
	typedef struct Fts5Context Fts5Context;
	typedef struct Fts5PhraseIter Fts5PhraseIter;

	typedef void(*fts5_extension_function)(
		const Fts5ExtensionApi *pApi,   
		Fts5Context *pFts,              
		sqlite3_context *pCtx,          
		int nVal,                       
		sqlite3_value **apVal           
		);

	struct Fts5PhraseIter {
		const unsigned char *a;
		const unsigned char *b;
	};

	
	struct Fts5ExtensionApi {
		int iVersion;                   

		void *(*xUserData)(Fts5Context*);

		int(*xColumnCount)(Fts5Context*);
		int(*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
		int(*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

		int(*xTokenize)(Fts5Context*,
			const char *pText, int nText, 
			void *pCtx,                   
			int(*xToken)(void*, int, const char*, int, int, int)       
			);

		int(*xPhraseCount)(Fts5Context*);
		int(*xPhraseSize)(Fts5Context*, int iPhrase);

		int(*xInstCount)(Fts5Context*, int *pnInst);
		int(*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

		sqlite3_int64(*xRowid)(Fts5Context*);
		int(*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
		int(*xColumnSize)(Fts5Context*, int iCol, int *pnToken);

		int(*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
			int(*)(const Fts5ExtensionApi*, Fts5Context*, void*)
			);
		int(*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
		void *(*xGetAuxdata)(Fts5Context*, int bClear);

		int(*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
		void(*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

		int(*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
		void(*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);
	};

	

	
	typedef struct Fts5Tokenizer Fts5Tokenizer;
	typedef struct fts5_tokenizer fts5_tokenizer;
	struct fts5_tokenizer {
		int(*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
		void(*xDelete)(Fts5Tokenizer*);
		int(*xTokenize)(Fts5Tokenizer*,
			void *pCtx,
			int flags,            
			const char *pText, int nText,
			int(*xToken)(
				void *pCtx,         
				int tflags,         
				const char *pToken, 
				int nToken,         
				int iStart,         
				int iEnd            
				)
			);
	};

	
#define FTS5_TOKENIZE_QUERY     0x0001
#define FTS5_TOKENIZE_PREFIX    0x0002
#define FTS5_TOKENIZE_DOCUMENT  0x0004
#define FTS5_TOKENIZE_AUX       0x0008

	
#define FTS5_TOKEN_COLOCATED    0x0001      

	

	
	typedef struct fts5_api fts5_api;
	struct fts5_api {
		int iVersion;                   

										
		int(*xCreateTokenizer)(
			fts5_api *pApi,
			const char *zName,
			void *pContext,
			fts5_tokenizer *pTokenizer,
			void(*xDestroy)(void*)
			);

		
		int(*xFindTokenizer)(
			fts5_api *pApi,
			const char *zName,
			void **ppContext,
			fts5_tokenizer *pTokenizer
			);

		
		int(*xCreateFunction)(
			fts5_api *pApi,
			const char *zName,
			void *pContext,
			fts5_extension_function xFunction,
			void(*xDestroy)(void*)
			);
	};

	

#if 0
}  
#endif

#endif 

   

   
   

   
#ifdef _HAVE_SQLITE_CONFIG_H
#include "config.h"
#endif

   
   
   

   
#ifndef SQLITE_MAX_LENGTH
# define SQLITE_MAX_LENGTH 1000000000
#endif

   
#ifndef SQLITE_MAX_COLUMN
# define SQLITE_MAX_COLUMN 2000
#endif

   
#ifndef SQLITE_MAX_SQL_LENGTH
# define SQLITE_MAX_SQL_LENGTH 1000000000
#endif

   
#ifndef SQLITE_MAX_EXPR_DEPTH
# define SQLITE_MAX_EXPR_DEPTH 1000
#endif

   
#ifndef SQLITE_MAX_COMPOUND_SELECT
# define SQLITE_MAX_COMPOUND_SELECT 500
#endif

   
#ifndef SQLITE_MAX_VDBE_OP
# define SQLITE_MAX_VDBE_OP 25000
#endif

   
#ifndef SQLITE_MAX_FUNCTION_ARG
# define SQLITE_MAX_FUNCTION_ARG 127
#endif

   
#ifndef SQLITE_DEFAULT_CACHE_SIZE
# define SQLITE_DEFAULT_CACHE_SIZE  -2000
#endif

   
#ifndef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT
# define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT  1000
#endif

   
#ifndef SQLITE_MAX_ATTACHED
# define SQLITE_MAX_ATTACHED 10
#endif


   
#ifndef SQLITE_MAX_VARIABLE_NUMBER
# define SQLITE_MAX_VARIABLE_NUMBER 999
#endif

   
#ifdef SQLITE_MAX_PAGE_SIZE
# undef SQLITE_MAX_PAGE_SIZE
#endif
#define SQLITE_MAX_PAGE_SIZE 65536


   
#ifndef SQLITE_DEFAULT_PAGE_SIZE
# define SQLITE_DEFAULT_PAGE_SIZE 4096
#endif
#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
# undef SQLITE_DEFAULT_PAGE_SIZE
# define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
#endif

   
#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZE
# define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192
#endif
#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
# undef SQLITE_MAX_DEFAULT_PAGE_SIZE
# define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
#endif


   
#ifndef SQLITE_MAX_PAGE_COUNT
# define SQLITE_MAX_PAGE_COUNT 1073741823
#endif

   
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH
# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
#endif

   
#ifndef SQLITE_MAX_TRIGGER_DEPTH
# define SQLITE_MAX_TRIGGER_DEPTH 1000
#endif

   
   

   
#if defined(__BORLANDC__)
#pragma warn -rch 
#pragma warn -ccc 
#pragma warn -aus 
#pragma warn -csu 
#pragma warn -spa 
#endif

   
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif

   
#if defined(__PTRDIFF_TYPE__)  
# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))
#elif !defined(__GNUC__)       
# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])
# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))
#elif defined(HAVE_STDINT_H)   
# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))
#else                          
# define SQLITE_INT_TO_PTR(X)  ((void*)(X))
# define SQLITE_PTR_TO_INT(X)  ((int)(X))
#endif

   
#if defined(__GNUC__)
#  define SQLITE_NOINLINE  __attribute__((noinline))
#elif defined(_MSC_VER) && _MSC_VER>=1310
#  define SQLITE_NOINLINE  __declspec(noinline)
#else
#  define SQLITE_NOINLINE
#endif

   
#if !defined(SQLITE_DISABLE_INTRINSIC)
#  if defined(_MSC_VER) && _MSC_VER>=1400
#    if !defined(_WIN32_WCE)
#      include <intrin.h>
#      pragma intrinsic(_byteswap_ushort)
#      pragma intrinsic(_byteswap_ulong)
#      pragma intrinsic(_ReadWriteBarrier)
#    else
#      include <cmnintrin.h>
#    endif
#  endif
#endif

   
#if !defined(SQLITE_THREADSAFE)
# if defined(THREADSAFE)
#   define SQLITE_THREADSAFE THREADSAFE
# else
#   define SQLITE_THREADSAFE 1 
# endif
#endif

   
#ifndef SQLITE_POWERSAFE_OVERWRITE
# define SQLITE_POWERSAFE_OVERWRITE 1
#endif

   
#if !defined(SQLITE_DEFAULT_MEMSTATUS)
# define SQLITE_DEFAULT_MEMSTATUS 1
#endif

   
#if defined(SQLITE_SYSTEM_MALLOC) \
  + defined(SQLITE_WIN32_MALLOC) \
  + defined(SQLITE_ZERO_MALLOC) \
  + defined(SQLITE_MEMDEBUG)>1
# error "Two or more of the following compile-time configuration options\
 are defined but at most one is allowed:\
 SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG,\
 SQLITE_ZERO_MALLOC"
#endif
#if defined(SQLITE_SYSTEM_MALLOC) \
  + defined(SQLITE_WIN32_MALLOC) \
  + defined(SQLITE_ZERO_MALLOC) \
  + defined(SQLITE_MEMDEBUG)==0
# define SQLITE_SYSTEM_MALLOC 1
#endif

   
#if !defined(SQLITE_MALLOC_SOFT_LIMIT)
# define SQLITE_MALLOC_SOFT_LIMIT 1024
#endif

   
#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)
#  define _XOPEN_SOURCE 600
#endif

   
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#if defined(NDEBUG) && defined(SQLITE_DEBUG)
# undef NDEBUG
#endif

   
#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)
# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1
#endif

   
#ifdef SQLITE_COVERAGE_TEST
SQLITE_PRIVATE   void sqlite3Coverage(int);
# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }
#else
# define testcase(X)
#endif

   
#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)
# define TESTONLY(X)  X
#else
# define TESTONLY(X)
#endif

   
#ifndef NDEBUG
# define VVA_ONLY(X)  X
#else
# define VVA_ONLY(X)
#endif

   
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
# define ALWAYS(X)      (1)
# define NEVER(X)       (0)
#elif !defined(NDEBUG)
# define ALWAYS(X)      ((X)?1:(assert(0),0))
# define NEVER(X)       ((X)?(assert(0),1):0)
#else
# define ALWAYS(X)      (X)
# define NEVER(X)       (X)
#endif

   
#if defined(SQLITE_TEST_REALLOC_STRESS)
# define ONLY_IF_REALLOC_STRESS(X)  (X)
#elif !defined(NDEBUG)
# define ONLY_IF_REALLOC_STRESS(X)  ((X)?(assert(0),1):0)
#else
# define ONLY_IF_REALLOC_STRESS(X)  (0)
#endif

   
#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \
    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)
extern int sqlite3OSTrace;
# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X
# define SQLITE_HAVE_OS_TRACE
#else
# define OSTRACE(X)
# undef  SQLITE_HAVE_OS_TRACE
#endif

   
#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \
    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)
# define SQLITE_NEED_ERR_NAME
#else
# undef  SQLITE_NEED_ERR_NAME
#endif

   
#ifdef SQLITE_OMIT_EXPLAIN
# undef SQLITE_ENABLE_EXPLAIN_COMMENTS
#endif

   
#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0)

   
#define likely(X)    (X)
#define unlikely(X)  (X)

   
   
   
#ifndef SQLITE_HASH_H
#define SQLITE_HASH_H

   
typedef struct Hash Hash;
typedef struct HashElem HashElem;


struct Hash {
	unsigned int htsize;      
	unsigned int count;       
	HashElem *first;          
	struct _ht {              
		int count;                 
		HashElem *chain;           
	} *ht;
};


struct HashElem {
	HashElem *next, *prev;       
	void *data;                  
	const char *pKey;            
};


SQLITE_PRIVATE void sqlite3HashInit(Hash*);
SQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const char *pKey, void *pData);
SQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const char *pKey);
SQLITE_PRIVATE void sqlite3HashClear(Hash*);


#define sqliteHashFirst(H)  ((H)->first)
#define sqliteHashNext(E)   ((E)->next)
#define sqliteHashData(E)   ((E)->data)






#endif 





#define TK_SEMI                             1
#define TK_EXPLAIN                          2
#define TK_QUERY                            3
#define TK_PLAN                             4
#define TK_BEGIN                            5
#define TK_TRANSACTION                      6
#define TK_DEFERRED                         7
#define TK_IMMEDIATE                        8
#define TK_EXCLUSIVE                        9
#define TK_COMMIT                          10
#define TK_END                             11
#define TK_ROLLBACK                        12
#define TK_SAVEPOINT                       13
#define TK_RELEASE                         14
#define TK_TO                              15
#define TK_TABLE                           16
#define TK_CREATE                          17
#define TK_IF                              18
#define TK_NOT                             19
#define TK_EXISTS                          20
#define TK_TEMP                            21
#define TK_LP                              22
#define TK_RP                              23
#define TK_AS                              24
#define TK_WITHOUT                         25
#define TK_COMMA                           26
#define TK_OR                              27
#define TK_AND                             28
#define TK_IS                              29
#define TK_MATCH                           30
#define TK_LIKE_KW                         31
#define TK_BETWEEN                         32
#define TK_IN                              33
#define TK_ISNULL                          34
#define TK_NOTNULL                         35
#define TK_NE                              36
#define TK_EQ                              37
#define TK_GT                              38
#define TK_LE                              39
#define TK_LT                              40
#define TK_GE                              41
#define TK_ESCAPE                          42
#define TK_BITAND                          43
#define TK_BITOR                           44
#define TK_LSHIFT                          45
#define TK_RSHIFT                          46
#define TK_PLUS                            47
#define TK_MINUS                           48
#define TK_STAR                            49
#define TK_SLASH                           50
#define TK_REM                             51
#define TK_CONCAT                          52
#define TK_COLLATE                         53
#define TK_BITNOT                          54
#define TK_ID                              55
#define TK_INDEXED                         56
#define TK_ABORT                           57
#define TK_ACTION                          58
#define TK_AFTER                           59
#define TK_ANALYZE                         60
#define TK_ASC                             61
#define TK_ATTACH                          62
#define TK_BEFORE                          63
#define TK_BY                              64
#define TK_CASCADE                         65
#define TK_CAST                            66
#define TK_COLUMNKW                        67
#define TK_CONFLICT                        68
#define TK_DATABASE                        69
#define TK_DESC                            70
#define TK_DETACH                          71
#define TK_EACH                            72
#define TK_FAIL                            73
#define TK_FOR                             74
#define TK_IGNORE                          75
#define TK_INITIALLY                       76
#define TK_INSTEAD                         77
#define TK_NO                              78
#define TK_KEY                             79
#define TK_OF                              80
#define TK_OFFSET                          81
#define TK_PRAGMA                          82
#define TK_RAISE                           83
#define TK_RECURSIVE                       84
#define TK_REPLACE                         85
#define TK_RESTRICT                        86
#define TK_ROW                             87
#define TK_TRIGGER                         88
#define TK_VACUUM                          89
#define TK_VIEW                            90
#define TK_VIRTUAL                         91
#define TK_WITH                            92
#define TK_REINDEX                         93
#define TK_RENAME                          94
#define TK_CTIME_KW                        95
#define TK_ANY                             96
#define TK_STRING                          97
#define TK_JOIN_KW                         98
#define TK_CONSTRAINT                      99
#define TK_DEFAULT                        100
#define TK_NULL                           101
#define TK_PRIMARY                        102
#define TK_UNIQUE                         103
#define TK_CHECK                          104
#define TK_REFERENCES                     105
#define TK_AUTOINCR                       106
#define TK_ON                             107
#define TK_INSERT                         108
#define TK_DELETE                         109
#define TK_UPDATE                         110
#define TK_SET                            111
#define TK_DEFERRABLE                     112
#define TK_FOREIGN                        113
#define TK_DROP                           114
#define TK_UNION                          115
#define TK_ALL                            116
#define TK_EXCEPT                         117
#define TK_INTERSECT                      118
#define TK_SELECT                         119
#define TK_VALUES                         120
#define TK_DISTINCT                       121
#define TK_DOT                            122
#define TK_FROM                           123
#define TK_JOIN                           124
#define TK_USING                          125
#define TK_ORDER                          126
#define TK_GROUP                          127
#define TK_HAVING                         128
#define TK_LIMIT                          129
#define TK_WHERE                          130
#define TK_INTO                           131
#define TK_FLOAT                          132
#define TK_BLOB                           133
#define TK_INTEGER                        134
#define TK_VARIABLE                       135
#define TK_CASE                           136
#define TK_WHEN                           137
#define TK_THEN                           138
#define TK_ELSE                           139
#define TK_INDEX                          140
#define TK_ALTER                          141
#define TK_ADD                            142
#define TK_TO_TEXT                        143
#define TK_TO_BLOB                        144
#define TK_TO_NUMERIC                     145
#define TK_TO_INT                         146
#define TK_TO_REAL                        147
#define TK_ISNOT                          148
#define TK_END_OF_FILE                    149
#define TK_UNCLOSED_STRING                150
#define TK_FUNCTION                       151
#define TK_COLUMN                         152
#define TK_AGG_FUNCTION                   153
#define TK_AGG_COLUMN                     154
#define TK_UMINUS                         155
#define TK_UPLUS                          156
#define TK_REGISTER                       157
#define TK_VECTOR                         158
#define TK_SELECT_COLUMN                  159
#define TK_ASTERISK                       160
#define TK_SPAN                           161
#define TK_SPACE                          162
#define TK_ILLEGAL                        163


#define TKFLG_MASK           0xff  


#define TKFLG_DONTFOLD       0x100  



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>


#ifdef SQLITE_OMIT_FLOATING_POINT
# define double sqlite_int64
# define float sqlite_int64
# define LONGDOUBLE_TYPE sqlite_int64
# ifndef SQLITE_BIG_DBL
#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)
# endif
# define SQLITE_OMIT_DATETIME_FUNCS 1
# define SQLITE_OMIT_TRACE 1
# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
# undef SQLITE_HAVE_ISNAN
#endif
#ifndef SQLITE_BIG_DBL
# define SQLITE_BIG_DBL (1e99)
#endif


#ifdef SQLITE_OMIT_TEMPDB
#define OMIT_TEMPDB 1
#else
#define OMIT_TEMPDB 0
#endif


#define SQLITE_MAX_FILE_FORMAT 4
#ifndef SQLITE_DEFAULT_FILE_FORMAT
# define SQLITE_DEFAULT_FILE_FORMAT 4
#endif


#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS
# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0
#endif


#ifndef SQLITE_TEMP_STORE
# define SQLITE_TEMP_STORE 1
# define SQLITE_TEMP_STORE_xc 1  
#endif


#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0
# undef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS 0
#endif
#ifndef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS 8
#endif
#ifndef SQLITE_DEFAULT_WORKER_THREADS
# define SQLITE_DEFAULT_WORKER_THREADS 0
#endif
#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADS
# undef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS
#endif


#ifndef SQLITE_DEFAULT_PCACHE_INITSZ
# define SQLITE_DEFAULT_PCACHE_INITSZ 100
#endif


#ifndef offsetof
#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))
#endif


#ifndef MIN
# define MIN(A,B) ((A)<(B)?(A):(B))
#endif
#ifndef MAX
# define MAX(A,B) ((A)>(B)?(A):(B))
#endif


#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}


#if 'A' == '\301'
# define SQLITE_EBCDIC 1
#else
# define SQLITE_ASCII 1
#endif


#ifndef UINT32_TYPE
# ifdef HAVE_UINT32_T
#  define UINT32_TYPE uint32_t
# else
#  define UINT32_TYPE unsigned int
# endif
#endif
#ifndef UINT16_TYPE
# ifdef HAVE_UINT16_T
#  define UINT16_TYPE uint16_t
# else
#  define UINT16_TYPE unsigned short int
# endif
#endif
#ifndef INT16_TYPE
# ifdef HAVE_INT16_T
#  define INT16_TYPE int16_t
# else
#  define INT16_TYPE short int
# endif
#endif
#ifndef UINT8_TYPE
# ifdef HAVE_UINT8_T
#  define UINT8_TYPE uint8_t
# else
#  define UINT8_TYPE unsigned char
# endif
#endif
#ifndef INT8_TYPE
# ifdef HAVE_INT8_T
#  define INT8_TYPE int8_t
# else
#  define INT8_TYPE signed char
# endif
#endif
#ifndef LONGDOUBLE_TYPE
# define LONGDOUBLE_TYPE long double
#endif
typedef sqlite_int64 i64;          
typedef sqlite_uint64 u64;         
typedef UINT32_TYPE u32;           
typedef UINT16_TYPE u16;           
typedef INT16_TYPE i16;            
typedef UINT8_TYPE u8;             
typedef INT8_TYPE i8;              

								   
#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)

								   
#ifdef SQLITE_64BIT_STATS
typedef u64 tRowcnt;    
#else
typedef u32 tRowcnt;    
#endif

						
typedef INT16_TYPE LogEst;


#ifndef SQLITE_PTRSIZE
# if defined(__SIZEOF_POINTER__)
#   define SQLITE_PTRSIZE __SIZEOF_POINTER__
# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)
#   define SQLITE_PTRSIZE 4
# else
#   define SQLITE_PTRSIZE 8
# endif
#endif


#if defined(HAVE_STDINT_H)
typedef uintptr_t uptr;
#elif SQLITE_PTRSIZE==4
typedef u32 uptr;
#else
typedef u64 uptr;
#endif


#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))



#if (defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
     defined(__arm__)) && !defined(SQLITE_RUNTIME_BYTEORDER)
# define SQLITE_BYTEORDER    1234
# define SQLITE_BIGENDIAN    0
# define SQLITE_LITTLEENDIAN 1
# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE
#endif
#if (defined(sparc)    || defined(__ppc__))  \
    && !defined(SQLITE_RUNTIME_BYTEORDER)
# define SQLITE_BYTEORDER    4321
# define SQLITE_BIGENDIAN    1
# define SQLITE_LITTLEENDIAN 0
# define SQLITE_UTF16NATIVE  SQLITE_UTF16BE
#endif
#if !defined(SQLITE_BYTEORDER)
# ifdef SQLITE_AMALGAMATION
const int sqlite3one = 1;
# else
extern const int sqlite3one;
# endif
# define SQLITE_BYTEORDER    0     
# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)
# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)
# define SQLITE_UTF16NATIVE  (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)
#endif


#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))
#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)


#define ROUND8(x)     (((x)+7)&~7)


#define ROUNDDOWN8(x) ((x)&~7)


#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC
# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)
#else
# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)
#endif


#if defined(__OpenBSD__) || defined(__QNXNTO__)
# undef SQLITE_MAX_MMAP_SIZE
# define SQLITE_MAX_MMAP_SIZE 0
#endif


#ifdef __APPLE__
# include <TargetConditionals.h>
#endif
#ifndef SQLITE_MAX_MMAP_SIZE
# if defined(__linux__) \
  || defined(_WIN32) \
  || (defined(__APPLE__) && defined(__MACH__)) \
  || defined(__sun) \
  || defined(__FreeBSD__) \
  || defined(__DragonFly__)
#   define SQLITE_MAX_MMAP_SIZE 0x7fff0000  
# else
#   define SQLITE_MAX_MMAP_SIZE 0
# endif
# define SQLITE_MAX_MMAP_SIZE_xc 1 
#endif


#ifndef SQLITE_DEFAULT_MMAP_SIZE
# define SQLITE_DEFAULT_MMAP_SIZE 0
# define SQLITE_DEFAULT_MMAP_SIZE_xc 1  
#endif
#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE
# undef SQLITE_DEFAULT_MMAP_SIZE
# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE
#endif


#ifdef SQLITE_ENABLE_STAT4
# undef SQLITE_ENABLE_STAT3
# define SQLITE_ENABLE_STAT3_OR_STAT4 1
#elif SQLITE_ENABLE_STAT3
# define SQLITE_ENABLE_STAT3_OR_STAT4 1
#elif SQLITE_ENABLE_STAT3_OR_STAT4
# undef SQLITE_ENABLE_STAT3_OR_STAT4
#endif


#if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_SELECTTRACE)
# define SELECTTRACE_ENABLED 1
#else
# define SELECTTRACE_ENABLED 0
#endif


typedef struct BusyHandler BusyHandler;
struct BusyHandler {
	int(*xFunc)(void *, int);  
	void *pArg;                
	int nBusy;                 
};


#define MASTER_NAME       "sqlite_master"
#define TEMP_MASTER_NAME  "sqlite_temp_master"


#define MASTER_ROOT       1


#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)


#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))


#define IsPowerOfTwo(X) (((X)&((X)-1))==0)


#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize)


#ifdef SQLITE_OMIT_WSD
#define SQLITE_WSD const
#define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))
#define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)
SQLITE_API int sqlite3_wsd_init(int N, int J);
SQLITE_API void *sqlite3_wsd_find(void *K, int L);
#else
#define SQLITE_WSD
#define GLOBAL(t,v) v
#define sqlite3GlobalConfig sqlite3Config
#endif


#define UNUSED_PARAMETER(x) (void)(x)
#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)


typedef struct AggInfo AggInfo;
typedef struct AuthContext AuthContext;
typedef struct AutoincInfo AutoincInfo;
typedef struct Bitvec Bitvec;
typedef struct CollSeq CollSeq;
typedef struct Column Column;
typedef struct Db Db;
typedef struct Schema Schema;
typedef struct Expr Expr;
typedef struct ExprList ExprList;
typedef struct ExprSpan ExprSpan;
typedef struct FKey FKey;
typedef struct FuncDestructor FuncDestructor;
typedef struct FuncDef FuncDef;
typedef struct FuncDefHash FuncDefHash;
typedef struct IdList IdList;
typedef struct Index Index;
typedef struct IndexSample IndexSample;
typedef struct KeyClass KeyClass;
typedef struct KeyInfo KeyInfo;
typedef struct Lookaside Lookaside;
typedef struct LookasideSlot LookasideSlot;
typedef struct Module Module;
typedef struct NameContext NameContext;
typedef struct Parse Parse;
typedef struct PreUpdate PreUpdate;
typedef struct PrintfArguments PrintfArguments;
typedef struct RowSet RowSet;
typedef struct Savepoint Savepoint;
typedef struct Select Select;
typedef struct SQLiteThread SQLiteThread;
typedef struct SelectDest SelectDest;
typedef struct SrcList SrcList;
typedef struct StrAccum StrAccum;
typedef struct Table Table;
typedef struct TableLock TableLock;
typedef struct Token Token;
typedef struct TreeView TreeView;
typedef struct Trigger Trigger;
typedef struct TriggerPrg TriggerPrg;
typedef struct TriggerStep TriggerStep;
typedef struct UnpackedRecord UnpackedRecord;
typedef struct VTable VTable;
typedef struct VtabCtx VtabCtx;
typedef struct Walker Walker;
typedef struct WhereInfo WhereInfo;
typedef struct With With;





#ifndef SQLITE_BTREE_H
#define SQLITE_BTREE_H


#define SQLITE_N_BTREE_META 16


#ifndef SQLITE_DEFAULT_AUTOVACUUM
#define SQLITE_DEFAULT_AUTOVACUUM 0
#endif

#define BTREE_AUTOVACUUM_NONE 0        
#define BTREE_AUTOVACUUM_FULL 1        
#define BTREE_AUTOVACUUM_INCR 2        


typedef struct Btree Btree;
typedef struct BtCursor BtCursor;
typedef struct BtShared BtShared;
typedef struct BtreePayload BtreePayload;


SQLITE_PRIVATE int sqlite3BtreeOpen(
	sqlite3_vfs *pVfs,       
	const char *zFilename,   
	sqlite3 *db,             
	Btree **ppBtree,         
	int flags,               
	int vfsFlags             
);


#define BTREE_OMIT_JOURNAL  1  
#define BTREE_MEMORY        2  
#define BTREE_SINGLE        4  
#define BTREE_UNORDERED     8  

SQLITE_PRIVATE int sqlite3BtreeClose(Btree*);
SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*, int);
SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree*, int);
#if SQLITE_MAX_MMAP_SIZE>0
SQLITE_PRIVATE   int sqlite3BtreeSetMmapLimit(Btree*, sqlite3_int64);
#endif
SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(Btree*, unsigned);
SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);
SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);
SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*, int);
SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);
SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*, int);
SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree*);
SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p);
SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);
SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);
SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*, int);
SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);
SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*, int);
SQLITE_PRIVATE int sqlite3BtreeCommit(Btree*);
SQLITE_PRIVATE int sqlite3BtreeRollback(Btree*, int, int);
SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*, int);
SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags);
SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*);
SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*);
SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree*);
SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));
SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *pBtree);
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);
#endif
SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *, int, int);

SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *);
SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *);
SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *);

SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *);


#define BTREE_INTKEY     1    
#define BTREE_BLOBKEY    2    

SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*);
SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*);
SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree*, int, int);

SQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);
SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);

SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p);


#define BTREE_FREE_PAGE_COUNT     0
#define BTREE_SCHEMA_VERSION      1
#define BTREE_FILE_FORMAT         2
#define BTREE_DEFAULT_CACHE_SIZE  3
#define BTREE_LARGEST_ROOT_PAGE   4
#define BTREE_TEXT_ENCODING       5
#define BTREE_USER_VERSION        6
#define BTREE_INCR_VACUUM         7
#define BTREE_APPLICATION_ID      8
#define BTREE_DATA_VERSION        15  


#define BTREE_HINT_RANGE 0       


#define BTREE_BULKLOAD 0x00000001  
#define BTREE_SEEK_EQ  0x00000002  


#define BTREE_WRCSR     0x00000004     
#define BTREE_FORDELETE 0x00000008     

SQLITE_PRIVATE int sqlite3BtreeCursor(
	Btree*,                              
	int iTable,                          
	int wrFlag,                          
	struct KeyInfo*,                     
	BtCursor *pCursor                    
);
SQLITE_PRIVATE int sqlite3BtreeCursorSize(void);
SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor*);
SQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor*, int, ...);
#endif

SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
	BtCursor*,
	UnpackedRecord *pUnKey,
	i64 intKey,
	int bias,
	int *pRes
);
SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor*, int*);
SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*, u8 flags);


#define BTREE_SAVEPOSITION 0x02  
#define BTREE_AUXDELETE    0x04  


struct BtreePayload {
	const void *pKey;       
	sqlite3_int64 nKey;     
	const void *pData;      
	int nData;              
	int nZero;              
};

SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,
	int bias, int seekResult);
SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes);
SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes);
SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int *pRes);
SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int *pRes);
SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreeKey(BtCursor*, u32 offset, u32 amt, void*);
SQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);
SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor*);
SQLITE_PRIVATE int sqlite3BtreeData(BtCursor*, u32 offset, u32 amt, void*);

SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);
SQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*);

#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);
SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *);
#endif
SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *);
SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);
SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);
SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *pBt);
SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void);

#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);
#endif

#ifndef SQLITE_OMIT_BTREECOUNT
SQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *, i64 *);
#endif

#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int);
SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);
#endif

#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE   int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);
#endif


#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE   void sqlite3BtreeEnter(Btree*);
SQLITE_PRIVATE   void sqlite3BtreeEnterAll(sqlite3*);
SQLITE_PRIVATE   int sqlite3BtreeSharable(Btree*);
SQLITE_PRIVATE   void sqlite3BtreeEnterCursor(BtCursor*);
SQLITE_PRIVATE   int sqlite3BtreeConnectionCount(Btree*);
#else
# define sqlite3BtreeEnter(X) 
# define sqlite3BtreeEnterAll(X)
# define sqlite3BtreeSharable(X) 0
# define sqlite3BtreeEnterCursor(X)
# define sqlite3BtreeConnectionCount(X) 1
#endif

#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE
SQLITE_PRIVATE   void sqlite3BtreeLeave(Btree*);
SQLITE_PRIVATE   void sqlite3BtreeLeaveCursor(BtCursor*);
SQLITE_PRIVATE   void sqlite3BtreeLeaveAll(sqlite3*);
#ifndef NDEBUG

SQLITE_PRIVATE   int sqlite3BtreeHoldsMutex(Btree*);
SQLITE_PRIVATE   int sqlite3BtreeHoldsAllMutexes(sqlite3*);
SQLITE_PRIVATE   int sqlite3SchemaMutexHeld(sqlite3*, int, Schema*);
#endif
#else

# define sqlite3BtreeLeave(X)
# define sqlite3BtreeLeaveCursor(X)
# define sqlite3BtreeLeaveAll(X)

# define sqlite3BtreeHoldsMutex(X) 1
# define sqlite3BtreeHoldsAllMutexes(X) 1
# define sqlite3SchemaMutexHeld(X,Y,Z) 1
#endif


#endif 






#ifndef SQLITE_VDBE_H
#define SQLITE_VDBE_H



typedef struct Vdbe Vdbe;


typedef struct Mem Mem;
typedef struct SubProgram SubProgram;


struct VdbeOp {
	u8 opcode;          
	signed char p4type; 
	u8 notUsed1;
	u8 p5;              
	int p1;             
	int p2;             
	int p3;             
	union p4union {     
		int i;                 
		void *p;               
		char *z;               
		i64 *pI64;             
		double *pReal;         
		FuncDef *pFunc;        
		sqlite3_context *pCtx; 
		CollSeq *pColl;        
		Mem *pMem;             
		VTable *pVtab;         
		KeyInfo *pKeyInfo;     
		int *ai;               
		SubProgram *pProgram;  
		Table *pTab;           
#ifdef SQLITE_ENABLE_CURSOR_HINTS
		Expr *pExpr;           
#endif
		int(*xAdvance)(BtCursor *, int *);
	} p4;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
	char *zComment;          
#endif
#ifdef VDBE_PROFILE
	u32 cnt;                 
	u64 cycles;              
#endif
#ifdef SQLITE_VDBE_COVERAGE
	int iSrcLine;            
#endif
};
typedef struct VdbeOp VdbeOp;



struct SubProgram {
	VdbeOp *aOp;                  
	int nOp;                      
	int nMem;                     
	int nCsr;                     
	void *token;                  
	SubProgram *pNext;            
};


struct VdbeOpList {
	u8 opcode;          
	signed char p1;     
	signed char p2;     
	signed char p3;     
};
typedef struct VdbeOpList VdbeOpList;


#define P4_NOTUSED    0   
#define P4_DYNAMIC  (-1)  
#define P4_STATIC   (-2)  
#define P4_COLLSEQ  (-4)  
#define P4_FUNCDEF  (-5)  
#define P4_KEYINFO  (-6)  
#define P4_EXPR     (-7)  
#define P4_MEM      (-8)  
#define P4_TRANSIENT  0   
#define P4_VTAB     (-10) 
#define P4_MPRINTF  (-11) 
#define P4_REAL     (-12) 
#define P4_INT64    (-13) 
#define P4_INT32    (-14) 
#define P4_INTARRAY (-15) 
#define P4_SUBPROGRAM  (-18) 
#define P4_ADVANCE  (-19) 
#define P4_TABLE    (-20) 
#define P4_FUNCCTX  (-21) 


#define P5_ConstraintNotNull 1
#define P5_ConstraintUnique  2
#define P5_ConstraintCheck   3
#define P5_ConstraintFK      4


#define COLNAME_NAME     0
#define COLNAME_DECLTYPE 1
#define COLNAME_DATABASE 2
#define COLNAME_TABLE    3
#define COLNAME_COLUMN   4
#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define COLNAME_N        5      
#else
# ifdef SQLITE_OMIT_DECLTYPE
#   define COLNAME_N      1      
# else
#   define COLNAME_N      2      
# endif
#endif


#define ADDR(X)  (-1-(X))






#define OP_Savepoint       0
#define OP_AutoCommit      1
#define OP_Transaction     2
#define OP_SorterNext      3
#define OP_PrevIfOpen      4
#define OP_NextIfOpen      5
#define OP_Prev            6
#define OP_Next            7
#define OP_Checkpoint      8
#define OP_JournalMode     9
#define OP_Vacuum         10
#define OP_VFilter        11 
#define OP_VUpdate        12 
#define OP_Goto           13
#define OP_Gosub          14
#define OP_InitCoroutine  15
#define OP_Yield          16
#define OP_MustBeInt      17
#define OP_Jump           18
#define OP_Not            19 
#define OP_Once           20
#define OP_If             21
#define OP_IfNot          22
#define OP_SeekLT         23 
#define OP_SeekLE         24 
#define OP_SeekGE         25 
#define OP_SeekGT         26 
#define OP_Or             27 
#define OP_And            28 
#define OP_NoConflict     29 
#define OP_NotFound       30 
#define OP_Found          31 
#define OP_SeekRowid      32 
#define OP_NotExists      33 
#define OP_IsNull         34 
#define OP_NotNull        35 
#define OP_Ne             36 
#define OP_Eq             37 
#define OP_Gt             38 
#define OP_Le             39 
#define OP_Lt             40 
#define OP_Ge             41 
#define OP_ElseNotEq      42 
#define OP_BitAnd         43 
#define OP_BitOr          44 
#define OP_ShiftLeft      45 
#define OP_ShiftRight     46 
#define OP_Add            47 
#define OP_Subtract       48 
#define OP_Multiply       49 
#define OP_Divide         50 
#define OP_Remainder      51 
#define OP_Concat         52 
#define OP_Last           53
#define OP_BitNot         54 
#define OP_SorterSort     55
#define OP_Sort           56
#define OP_Rewind         57
#define OP_IdxLE          58 
#define OP_IdxGT          59 
#define OP_IdxLT          60 
#define OP_IdxGE          61 
#define OP_RowSetRead     62 
#define OP_RowSetTest     63 
#define OP_Program        64
#define OP_FkIfZero       65 
#define OP_IfPos          66 
#define OP_IfNotZero      67 
#define OP_DecrJumpZero   68 
#define OP_IncrVacuum     69
#define OP_VNext          70
#define OP_Init           71 
#define OP_Return         72
#define OP_EndCoroutine   73
#define OP_HaltIfNull     74 
#define OP_Halt           75
#define OP_Integer        76 
#define OP_Int64          77 
#define OP_String         78 
#define OP_Null           79 
#define OP_SoftNull       80 
#define OP_Blob           81 
#define OP_Variable       82 
#define OP_Move           83 
#define OP_Copy           84 
#define OP_SCopy          85 
#define OP_IntCopy        86 
#define OP_ResultRow      87 
#define OP_CollSeq        88
#define OP_Function0      89 
#define OP_Function       90 
#define OP_AddImm         91 
#define OP_RealAffinity   92
#define OP_Cast           93 
#define OP_Permutation    94
#define OP_Compare        95 
#define OP_Column         96 
#define OP_String8        97 
#define OP_Affinity       98 
#define OP_MakeRecord     99 
#define OP_Count         100 
#define OP_ReadCookie    101
#define OP_SetCookie     102
#define OP_ReopenIdx     103 
#define OP_OpenRead      104 
#define OP_OpenWrite     105 
#define OP_OpenAutoindex 106 
#define OP_OpenEphemeral 107 
#define OP_SorterOpen    108
#define OP_SequenceTest  109 
#define OP_OpenPseudo    110 
#define OP_Close         111
#define OP_ColumnsUsed   112
#define OP_Sequence      113 
#define OP_NewRowid      114 
#define OP_Insert        115 
#define OP_InsertInt     116 
#define OP_Delete        117
#define OP_ResetCount    118
#define OP_SorterCompare 119 
#define OP_SorterData    120 
#define OP_RowKey        121 
#define OP_RowData       122 
#define OP_Rowid         123 
#define OP_NullRow       124
#define OP_SorterInsert  125
#define OP_IdxInsert     126 
#define OP_IdxDelete     127 
#define OP_Seek          128 
#define OP_IdxRowid      129 
#define OP_Destroy       130
#define OP_Clear         131
#define OP_Real          132 
#define OP_ResetSorter   133
#define OP_CreateIndex   134 
#define OP_CreateTable   135 
#define OP_ParseSchema   136
#define OP_LoadAnalysis  137
#define OP_DropTable     138
#define OP_DropIndex     139
#define OP_DropTrigger   140
#define OP_IntegrityCk   141
#define OP_RowSetAdd     142 
#define OP_Param         143
#define OP_FkCounter     144 
#define OP_MemMax        145 
#define OP_OffsetLimit   146 
#define OP_AggStep0      147 
#define OP_AggStep       148 
#define OP_AggFinal      149 
#define OP_Expire        150
#define OP_TableLock     151 
#define OP_VBegin        152
#define OP_VCreate       153
#define OP_VDestroy      154
#define OP_VOpen         155
#define OP_VColumn       156 
#define OP_VRename       157
#define OP_Pagecount     158
#define OP_MaxPgcnt      159
#define OP_CursorHint    160
#define OP_Noop          161
#define OP_Explain       162


#define OPFLG_JUMP        0x01  
#define OPFLG_IN1         0x02  
#define OPFLG_IN2         0x04  
#define OPFLG_IN3         0x08  
#define OPFLG_OUT2        0x10  
#define OPFLG_OUT3        0x20  
#define OPFLG_INITIALIZER {\
 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,\
 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01,\
 0x03, 0x03, 0x01, 0x12, 0x01, 0x03, 0x03, 0x09,\
 0x09, 0x09, 0x09, 0x26, 0x26, 0x09, 0x09, 0x09,\
 0x09, 0x09, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\
 0x0b, 0x0b, 0x01, 0x26, 0x26, 0x26, 0x26, 0x26,\
 0x26, 0x26, 0x26, 0x26, 0x26, 0x01, 0x12, 0x01,\
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x23, 0x0b,\
 0x01, 0x01, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01,\
 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10,\
 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00,\
 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00,\
 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,\
 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x04, 0x00,\
 0x00, 0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10,\
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10,\
 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,\
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,\
 0x00, 0x00, 0x00,}


#define SQLITE_MX_JUMP_OPCODE  71  





SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse*);
SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*, int, int);
SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*, int, int, int);
SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe*, int, const char*);
SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe*, int, const char*, ...);
SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*, int, int, int, int);
SQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*, int, int, int, int, const char *zP4, int);
SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(Vdbe*, int, int, int, int, const u8*, int);
SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*, int, int, int, int, int);
SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe*, int);
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
SQLITE_PRIVATE   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);
#else
# define sqlite3VdbeVerifyNoMallocRequired(A,B)
#endif
SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp, int iLineno);
SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*);
SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, u32 addr, u8);
SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, u32 addr, int P1);
SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, u32 addr, int P2);
SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, u32 addr, int P3);
SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u8 P5);
SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);
SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);
SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int);
SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3*, Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*, Parse*);
SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE   int sqlite3VdbeAssertMayAbort(Vdbe *, int);
#endif
SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe*);
SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*);
SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*);
SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, int);
SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*, Vdbe*);
SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);
SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe*, int);
#ifndef SQLITE_OMIT_TRACE
SQLITE_PRIVATE   char *sqlite3VdbeExpandSql(Vdbe*, const char*);
#endif
SQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);

SQLITE_PRIVATE void sqlite3VdbeRecordUnpack(KeyInfo*, int, const void*, UnpackedRecord*);
SQLITE_PRIVATE int sqlite3VdbeRecordCompare(int, const void*, UnpackedRecord*);
SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);
SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo *, char *, int, char **);

typedef int(*RecordCompare)(int, const void*, UnpackedRecord*);
SQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);

#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
#endif


#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
SQLITE_PRIVATE   void sqlite3VdbeComment(Vdbe*, const char*, ...);
# define VdbeComment(X)  sqlite3VdbeComment X
SQLITE_PRIVATE   void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);
# define VdbeNoopComment(X)  sqlite3VdbeNoopComment X
# ifdef SQLITE_ENABLE_MODULE_COMMENTS
#   define VdbeModuleComment(X)  sqlite3VdbeNoopComment X
# else
#   define VdbeModuleComment(X)
# endif
#else
# define VdbeComment(X)
# define VdbeNoopComment(X)
# define VdbeModuleComment(X)
#endif


#ifdef SQLITE_VDBE_COVERAGE
SQLITE_PRIVATE   void sqlite3VdbeSetLineNumber(Vdbe*, int);
# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageAlwaysTaken(v) sqlite3VdbeSetLineNumber(v,2);
# define VdbeCoverageNeverTaken(v) sqlite3VdbeSetLineNumber(v,1);
# define VDBE_OFFSET_LINENO(x) (__LINE__+x)
#else
# define VdbeCoverage(v)
# define VdbeCoverageIf(v,x)
# define VdbeCoverageAlwaysTaken(v)
# define VdbeCoverageNeverTaken(v)
# define VDBE_OFFSET_LINENO(x) 0
#endif

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_PRIVATE void sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);
#else
# define sqlite3VdbeScanStatus(a,b,c,d,e)
#endif

#endif 







#ifndef SQLITE_PAGER_H
#define SQLITE_PAGER_H


#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
#define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1
#endif


typedef u32 Pgno;


typedef struct Pager Pager;


typedef struct PgHdr DbPage;


#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1))


#define PAGER_OMIT_JOURNAL  0x0001    
#define PAGER_MEMORY        0x0002    


#define PAGER_LOCKINGMODE_QUERY      -1
#define PAGER_LOCKINGMODE_NORMAL      0
#define PAGER_LOCKINGMODE_EXCLUSIVE   1


#define PAGER_JOURNALMODE_QUERY     (-1)  
#define PAGER_JOURNALMODE_DELETE      0   
#define PAGER_JOURNALMODE_PERSIST     1   
#define PAGER_JOURNALMODE_OFF         2   
#define PAGER_JOURNALMODE_TRUNCATE    3   
#define PAGER_JOURNALMODE_MEMORY      4   
#define PAGER_JOURNALMODE_WAL         5   


#define PAGER_GET_NOCONTENT     0x01  
#define PAGER_GET_READONLY      0x02  


#define PAGER_SYNCHRONOUS_OFF       0x01  
#define PAGER_SYNCHRONOUS_NORMAL    0x02  
#define PAGER_SYNCHRONOUS_FULL      0x03  
#define PAGER_SYNCHRONOUS_EXTRA     0x04  
#define PAGER_SYNCHRONOUS_MASK      0x07  
#define PAGER_FULLFSYNC             0x08  
#define PAGER_CKPT_FULLFSYNC        0x10  
#define PAGER_CACHESPILL            0x20  
#define PAGER_FLAGS_MASK            0x38  




SQLITE_PRIVATE int sqlite3PagerOpen(
	sqlite3_vfs*,
	Pager **ppPager,
	const char*,
	int,
	int,
	int,
	void(*)(DbPage*)
);
SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager);
SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);


SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *);
SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);
#ifdef SQLITE_HAS_CODEC
SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*, Pager*);
#endif
SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);
SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);
SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);
SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);
SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);
SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*, unsigned);
SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);
SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);
SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);
SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);
SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);
SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);
SQLITE_PRIVATE int sqlite3PagerFlush(Pager*);


SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);
SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);
SQLITE_PRIVATE void sqlite3PagerRef(DbPage*);
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);
SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*);


SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);
SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);
SQLITE_PRIVATE int sqlite3PagerMovepage(Pager*, DbPage*, Pgno, int);
SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);
SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *);
SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *);


SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);
SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);
SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*, const char *zMaster, int);
SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);
SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster);
SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);
SQLITE_PRIVATE int sqlite3PagerRollback(Pager*);
SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);
SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);
SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);

#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE   int sqlite3PagerCheckpoint(Pager *pPager, int, int*, int*);
SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);
SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);
SQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);
SQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager);
SQLITE_PRIVATE   int sqlite3PagerUseWal(Pager *pPager);
# ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot);
SQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot);
# endif
#else
# define sqlite3PagerUseWal(x) 0
#endif

#ifdef SQLITE_ENABLE_ZIPVFS
SQLITE_PRIVATE   int sqlite3PagerWalFramesize(Pager *pPager);
#endif


SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);
SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE   int sqlite3PagerRefcount(Pager*);
#endif
SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);
SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager*, int);
SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*);
SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);
SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*);
SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);
SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);
SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);
SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);
SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);
SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);


SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*, Pgno);

SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);

#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_OMIT_WAL)
SQLITE_PRIVATE void *sqlite3PagerCodec(DbPage *);
#endif


#if !defined(NDEBUG) || defined(SQLITE_TEST)
SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);
SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);
#endif
#ifdef SQLITE_TEST
SQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);
SQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);
void disable_simulated_io_errors(void);
void enable_simulated_io_errors(void);
#else
# define disable_simulated_io_errors()
# define enable_simulated_io_errors()
#endif

#endif 







#ifndef _PCACHE_H_

typedef struct PgHdr PgHdr;
typedef struct PCache PCache;


struct PgHdr {
	sqlite3_pcache_page *pPage;    
	void *pData;                   
	void *pExtra;                  
	PgHdr *pDirty;                 
	Pager *pPager;                 
	Pgno pgno;                     
#ifdef SQLITE_CHECK_PAGES
	u32 pageHash;                  
#endif
	u16 flags;                     

								   
	i16 nRef;                      
	PCache *pCache;                

	PgHdr *pDirtyNext;             
	PgHdr *pDirtyPrev;             
};


#define PGHDR_CLEAN           0x001  
#define PGHDR_DIRTY           0x002  
#define PGHDR_WRITEABLE       0x004  
#define PGHDR_NEED_SYNC       0x008  
#define PGHDR_DONT_WRITE      0x010  
#define PGHDR_MMAP            0x020  

#define PGHDR_WAL_APPEND      0x040  


SQLITE_PRIVATE int sqlite3PcacheInitialize(void);
SQLITE_PRIVATE void sqlite3PcacheShutdown(void);


SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n);


SQLITE_PRIVATE int sqlite3PcacheOpen(
	int szPage,                    
	int szExtra,                   
	int bPurgeable,                
	int(*xStress)(void*, PgHdr*), 
	void *pStress,                 
	PCache *pToInit                
);


SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *, int);


SQLITE_PRIVATE int sqlite3PcacheSize(void);


SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag);
SQLITE_PRIVATE int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**);
SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage);
SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*);

SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*);         
SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*);    
SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*);    
SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*);    
SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache*);


SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno);


SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x);


SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*);


SQLITE_PRIVATE void sqlite3PcacheClose(PCache*);


SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *);


SQLITE_PRIVATE void sqlite3PcacheClear(PCache*);


SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*);


SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*);

SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*);


SQLITE_PRIVATE int sqlite3PcachePagecount(PCache*);

#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)

SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void(*xIter)(PgHdr *));
#endif

#if defined(SQLITE_DEBUG)

SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr*);
#endif


SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int);
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *);
#endif


SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *, int);


SQLITE_PRIVATE void sqlite3PcacheShrink(PCache*);

#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT

SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int);
#endif

#ifdef SQLITE_TEST
SQLITE_PRIVATE void sqlite3PcacheStats(int*, int*, int*, int*);
#endif

SQLITE_PRIVATE void sqlite3PCacheSetDefault(void);


SQLITE_PRIVATE int sqlite3HeaderSizePcache(void);
SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void);


SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache*);

#endif 






#ifndef _SQLITE_OS_H_
#define _SQLITE_OS_H_





#ifndef SQLITE_OS_SETUP_H
#define SQLITE_OS_SETUP_H


#if defined(SQLITE_OS_OTHER)
#  if SQLITE_OS_OTHER==1
#    undef SQLITE_OS_UNIX
#    define SQLITE_OS_UNIX 0
#    undef SQLITE_OS_WIN
#    define SQLITE_OS_WIN 0
#  else
#    undef SQLITE_OS_OTHER
#  endif
#endif
#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)
#  define SQLITE_OS_OTHER 0
#  ifndef SQLITE_OS_WIN
#    if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \
        defined(__MINGW32__) || defined(__BORLANDC__)
#      define SQLITE_OS_WIN 1
#      define SQLITE_OS_UNIX 0
#    else
#      define SQLITE_OS_WIN 0
#      define SQLITE_OS_UNIX 1
#    endif
#  else
#    define SQLITE_OS_UNIX 0
#  endif
#else
#  ifndef SQLITE_OS_WIN
#    define SQLITE_OS_WIN 0
#  endif
#endif

#endif 





#ifndef SET_FULLSYNC
# define SET_FULLSYNC(x,y)
#endif


#ifndef SQLITE_DEFAULT_SECTOR_SIZE
# define SQLITE_DEFAULT_SECTOR_SIZE 4096
#endif


#ifndef SQLITE_TEMP_FILE_PREFIX
# define SQLITE_TEMP_FILE_PREFIX "etilqs_"
#endif


#define NO_LOCK         0
#define SHARED_LOCK     1
#define RESERVED_LOCK   2
#define PENDING_LOCK    3
#define EXCLUSIVE_LOCK  4


#ifdef SQLITE_OMIT_WSD
# define PENDING_BYTE     (0x40000000)
#else
# define PENDING_BYTE      sqlite3PendingByte
#endif
#define RESERVED_BYTE     (PENDING_BYTE+1)
#define SHARED_FIRST      (PENDING_BYTE+2)
#define SHARED_SIZE       510


SQLITE_PRIVATE int sqlite3OsInit(void);


SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*);
SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);
SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);
SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);
SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);
SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);
SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);
SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);
SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);
SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*, int, void*);
SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*, int, void*);
#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0
SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);
SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);
SQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *, int, int, int, void volatile **);
SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);
SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);
SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);
SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);
SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *);



SQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);
SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);
SQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);
SQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);
SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);
SQLITE_PRIVATE void(*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);
SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);
#endif 
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);
SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);
SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*);
SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);


SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int, int*);
SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *);

#endif 









#if !SQLITE_THREADSAFE
# define SQLITE_MUTEX_OMIT
#endif
#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)
#  if SQLITE_OS_UNIX
#    define SQLITE_MUTEX_PTHREADS
#  elif SQLITE_OS_WIN
#    define SQLITE_MUTEX_W32
#  else
#    define SQLITE_MUTEX_NOOP
#  endif
#endif

#ifdef SQLITE_MUTEX_OMIT

#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)
#define sqlite3_mutex_free(X)
#define sqlite3_mutex_enter(X)    
#define sqlite3_mutex_try(X)      SQLITE_OK
#define sqlite3_mutex_leave(X)    
#define sqlite3_mutex_held(X)     ((void)(X),1)
#define sqlite3_mutex_notheld(X)  ((void)(X),1)
#define sqlite3MutexAlloc(X)      ((sqlite3_mutex*)8)
#define sqlite3MutexInit()        SQLITE_OK
#define sqlite3MutexEnd()
#define MUTEX_LOGIC(X)
#else
#define MUTEX_LOGIC(X)            X
#endif 





#ifdef SQLITE_EXTRA_DURABLE
# warning Use SQLITE_DEFAULT_SYNCHRONOUS = 3 instead of SQLITE_EXTRA_DURABLE
# define SQLITE_DEFAULT_SYNCHRONOUS 3
#endif


#ifndef SQLITE_DEFAULT_SYNCHRONOUS
# define SQLITE_DEFAULT_SYNCHRONOUS (PAGER_SYNCHRONOUS_FULL-1)
#endif
#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUS
# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS
#endif


struct Db {
	char *zDbSName;      
	Btree *pBt;          
	u8 safety_level;     
	u8 bSyncSet;         
	Schema *pSchema;     
};


struct Schema {
	int schema_cookie;   
	int iGeneration;     
	Hash tblHash;        
	Hash idxHash;        
	Hash trigHash;       
	Hash fkeyHash;       
	Table *pSeqTab;      
	u8 file_format;      
	u8 enc;              
	u16 schemaFlags;     
	int cache_size;      
};


#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))
#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)
#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->schemaFlags|=(P)
#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->schemaFlags&=~(P)


#define DB_SchemaLoaded    0x0001  
#define DB_UnresetViews    0x0002  
#define DB_Empty           0x0004  


#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)


struct Lookaside {
	u32 bDisable;           
	u16 sz;                 
	u8 bMalloced;           
	int nOut;               
	int mxOut;              
	int anStat[3];          
	LookasideSlot *pFree;   
	void *pStart;           
	void *pEnd;             
};
struct LookasideSlot {
	LookasideSlot *pNext;    
};


#define SQLITE_FUNC_HASH_SZ 23
struct FuncDefHash {
	FuncDef *a[SQLITE_FUNC_HASH_SZ];       
};

#ifdef SQLITE_USER_AUTHENTICATION

typedef struct sqlite3_userauth sqlite3_userauth;
struct sqlite3_userauth {
	u8 authLevel;                 
	int nAuthPW;                  
	char *zAuthPW;                
	char *zAuthUser;              
};


#define UAUTH_Unknown     0     
#define UAUTH_Fail        1     
#define UAUTH_User        2     
#define UAUTH_Admin       3     


SQLITE_PRIVATE int sqlite3UserAuthTable(const char*);
SQLITE_PRIVATE int sqlite3UserAuthCheckLogin(sqlite3*, const char*, u8*);
SQLITE_PRIVATE void sqlite3UserAuthInit(sqlite3*);
SQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*, int, sqlite3_value**);

#endif 


#ifdef SQLITE_USER_AUTHENTICATION
typedef int(*sqlite3_xauth)(void*, int, const char*, const char*, const char*,
	const char*, const char*);
#else
typedef int(*sqlite3_xauth)(void*, int, const char*, const char*, const char*,
	const char*);
#endif

#ifndef SQLITE_OMIT_DEPRECATED

#define SQLITE_TRACE_LEGACY  0x80
#else
#define SQLITE_TRACE_LEGACY  0
#endif 



struct sqlite3 {
	sqlite3_vfs *pVfs;            
	struct Vdbe *pVdbe;           
	CollSeq *pDfltColl;           
	sqlite3_mutex *mutex;         
	Db *aDb;                      
	int nDb;                      
	int flags;                    
	i64 lastRowid;                
	i64 szMmap;                   
	unsigned int openFlags;       
	int errCode;                  
	int errMask;                  
	int iSysErrno;                
	u16 dbOptFlags;               
	u8 enc;                       
	u8 autoCommit;                
	u8 temp_store;                
	u8 mallocFailed;              
	u8 bBenignMalloc;             
	u8 dfltLockMode;              
	signed char nextAutovac;      
	u8 suppressErr;               
	u8 vtabOnConflict;            
	u8 isTransactionSavepoint;    
	u8 mTrace;                    
	int nextPagesize;             
	u32 magic;                    
	int nChange;                  
	int nTotalChange;             
	int aLimit[SQLITE_N_LIMIT];   
	int nMaxSorterMmap;           
	struct sqlite3InitInfo {      
		int newTnum;                
		u8 iDb;                     
		u8 busy;                    
		u8 orphanTrigger;           
		u8 imposterTable;           
	} init;
	int nVdbeActive;              
	int nVdbeRead;                
	int nVdbeWrite;               
	int nVdbeExec;                
	int nVDestroy;                
	int nExtension;               
	void **aExtension;            
	int(*xTrace)(u32, void*, void*, void*);     
	void *pTraceArg;                          
	void(*xProfile)(void*, const char*, u64);  
	void *pProfileArg;                        
	void *pCommitArg;                 
	int(*xCommitCallback)(void*);    
	void *pRollbackArg;               
	void(*xRollbackCallback)(void*); 
	void *pUpdateArg;
	void(*xUpdateCallback)(void*, int, const char*, const char*, sqlite_int64);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
	void *pPreUpdateArg;          
	void(*xPreUpdateCallback)(   
		void*, sqlite3*, int, char const*, char const*, sqlite3_int64, sqlite3_int64
		);
	PreUpdate *pPreUpdate;        
#endif 
#ifndef SQLITE_OMIT_WAL
	int(*xWalCallback)(void *, sqlite3 *, const char *, int);
	void *pWalArg;
#endif
	void(*xCollNeeded)(void*, sqlite3*, int eTextRep, const char*);
	void(*xCollNeeded16)(void*, sqlite3*, int eTextRep, const void*);
	void *pCollNeededArg;
	sqlite3_value *pErr;          
	union {
		volatile int isInterrupted; 
		double notUsed1;            
	} u1;
	Lookaside lookaside;          
#ifndef SQLITE_OMIT_AUTHORIZATION
	sqlite3_xauth xAuth;          
	void *pAuthArg;               
#endif
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
	int(*xProgress)(void *);     
	void *pProgressArg;           
	unsigned nProgressOps;        
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
	int nVTrans;                  
	Hash aModule;                 
	VtabCtx *pVtabCtx;            
	VTable **aVTrans;             
	VTable *pDisconnect;    
#endif
	Hash aFunc;                   
	Hash aCollSeq;                
	BusyHandler busyHandler;      
	Db aDbStatic[2];              
	Savepoint *pSavepoint;        
	int busyTimeout;              
	int nSavepoint;               
	int nStatement;               
	i64 nDeferredCons;            
	i64 nDeferredImmCons;         
	int *pnBytesFreed;            
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
								  
	sqlite3 *pBlockingConnection; 
	sqlite3 *pUnlockConnection;           
	void *pUnlockArg;                     
	void(*xUnlockNotify)(void **, int);  
	sqlite3 *pNextBlocked;        
#endif
#ifdef SQLITE_USER_AUTHENTICATION
	sqlite3_userauth auth;        
#endif
};


#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)
#define ENC(db)        ((db)->enc)


#define SQLITE_VdbeTrace      0x00000001  
#define SQLITE_InternChanges  0x00000002  
#define SQLITE_FullColNames   0x00000004  
#define SQLITE_FullFSync      0x00000008  
#define SQLITE_CkptFullFSync  0x00000010  
#define SQLITE_CacheSpill     0x00000020  
#define SQLITE_ShortColNames  0x00000040  
#define SQLITE_CountRows      0x00000080  


#define SQLITE_NullCallback   0x00000100  

#define SQLITE_SqlTrace       0x00000200  
#define SQLITE_VdbeListing    0x00000400  
#define SQLITE_WriteSchema    0x00000800  
#define SQLITE_VdbeAddopTrace 0x00001000  
#define SQLITE_IgnoreChecks   0x00002000  
#define SQLITE_ReadUncommitted 0x0004000  
#define SQLITE_LegacyFileFmt  0x00008000  
#define SQLITE_RecoveryMode   0x00010000  
#define SQLITE_ReverseOrder   0x00020000  
#define SQLITE_RecTriggers    0x00040000  
#define SQLITE_ForeignKeys    0x00080000  
#define SQLITE_AutoIndex      0x00100000  
#define SQLITE_PreferBuiltin  0x00200000  
#define SQLITE_LoadExtension  0x00400000  
#define SQLITE_LoadExtFunc    0x00800000  
#define SQLITE_EnableTrigger  0x01000000  
#define SQLITE_DeferFKs       0x02000000  
#define SQLITE_QueryOnly      0x04000000  
#define SQLITE_VdbeEQP        0x08000000  
#define SQLITE_Vacuum         0x10000000  
#define SQLITE_CellSizeCk     0x20000000  
#define SQLITE_Fts3Tokenizer  0x40000000  



#define SQLITE_QueryFlattener 0x0001   
#define SQLITE_ColumnCache    0x0002   
#define SQLITE_GroupByOrder   0x0004   
#define SQLITE_FactorOutConst 0x0008   

#define SQLITE_DistinctOpt    0x0020   
#define SQLITE_CoverIdxScan   0x0040   
#define SQLITE_OrderByIdxJoin 0x0080   
#define SQLITE_SubqCoroutine  0x0100   
#define SQLITE_Transitive     0x0200   
#define SQLITE_OmitNoopJoin   0x0400   
#define SQLITE_Stat34         0x0800   
#define SQLITE_CursorHints    0x2000   
#define SQLITE_AllOpts        0xffff   


#ifndef SQLITE_OMIT_BUILTIN_TEST
#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)
#define OptimizationEnabled(db, mask)   (((db)->dbOptFlags&(mask))==0)
#else
#define OptimizationDisabled(db, mask)  0
#define OptimizationEnabled(db, mask)   1
#endif


#define ConstFactorOk(P) ((P)->okConstFactor)


#define SQLITE_MAGIC_OPEN     0xa029a697  
#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  
#define SQLITE_MAGIC_SICK     0x4b771290  
#define SQLITE_MAGIC_BUSY     0xf03b7906  
#define SQLITE_MAGIC_ERROR    0xb5357930  
#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  


struct FuncDef {
	i8 nArg;             
	u16 funcFlags;       
	void *pUserData;     
	FuncDef *pNext;      
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value**); 
	void(*xFinalize)(sqlite3_context*);                  
	const char *zName;   
	union {
		FuncDef *pHash;      
		FuncDestructor *pDestructor;   
	} u;
};


struct FuncDestructor {
	int nRef;
	void(*xDestroy)(void *);
	void *pUserData;
};


#define SQLITE_FUNC_ENCMASK  0x0003 
#define SQLITE_FUNC_LIKE     0x0004 
#define SQLITE_FUNC_CASE     0x0008 
#define SQLITE_FUNC_EPHEM    0x0010 
#define SQLITE_FUNC_NEEDCOLL 0x0020 
#define SQLITE_FUNC_LENGTH   0x0040 
#define SQLITE_FUNC_TYPEOF   0x0080 
#define SQLITE_FUNC_COUNT    0x0100 
#define SQLITE_FUNC_COALESCE 0x0200 
#define SQLITE_FUNC_UNLIKELY 0x0400 
#define SQLITE_FUNC_CONSTANT 0x0800 
#define SQLITE_FUNC_MINMAX   0x1000 
#define SQLITE_FUNC_SLOCHNG  0x2000 


#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \
  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
#define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \
  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \
  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \
  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\
   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }
#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \
  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
   pArg, 0, xFunc, 0, #zName, }
#define LIKEFUNC(zName, nArg, arg, flags) \
  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \
   (void *)arg, 0, likeFunc, 0, #zName, {0} }
#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) \
  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), \
   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}}
#define AGGREGATE2(zName, nArg, arg, nc, xStep, xFinal, extraFlags) \
  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, \
   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}}


struct Savepoint {
	char *zName;                        
	i64 nDeferredCons;                  
	i64 nDeferredImmCons;               
	Savepoint *pNext;                   
};


#define SAVEPOINT_BEGIN      0
#define SAVEPOINT_RELEASE    1
#define SAVEPOINT_ROLLBACK   2



struct Module {
	const sqlite3_module *pModule;       
	const char *zName;                   
	void *pAux;                          
	void(*xDestroy)(void *);            
	Table *pEpoTab;                      
};


struct Column {
	char *zName;     
	Expr *pDflt;     
	char *zColl;     
	u8 notNull;      
	char affinity;   
	u8 szEst;        
	u8 colFlags;     
};


#define COLFLAG_PRIMKEY  0x0001    
#define COLFLAG_HIDDEN   0x0002    
#define COLFLAG_HASTYPE  0x0004    


struct CollSeq {
	char *zName;          
	u8 enc;               
	void *pUser;          
	int(*xCmp)(void*, int, const void*, int, const void*);
	void(*xDel)(void*);  
};


#define SQLITE_SO_ASC       0  
#define SQLITE_SO_DESC      1  
#define SQLITE_SO_UNDEFINED -1 


#define SQLITE_AFF_BLOB     'A'
#define SQLITE_AFF_TEXT     'B'
#define SQLITE_AFF_NUMERIC  'C'
#define SQLITE_AFF_INTEGER  'D'
#define SQLITE_AFF_REAL     'E'

#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)


#define SQLITE_AFF_MASK     0x47


#define SQLITE_KEEPNULL     0x08  
#define SQLITE_JUMPIFNULL   0x10  
#define SQLITE_STOREP2      0x20  
#define SQLITE_NULLEQ       0x80  
#define SQLITE_NOTNULL      0x90  


struct VTable {
	sqlite3 *db;              
	Module *pMod;             
	sqlite3_vtab *pVtab;      
	int nRef;                 
	u8 bConstraint;           
	int iSavepoint;           
	VTable *pNext;            
};


struct Table {
	char *zName;         
	Column *aCol;        
	Index *pIndex;       
	Select *pSelect;     
	FKey *pFKey;         
	char *zColAff;       
	ExprList *pCheck;    
						 
	int tnum;            
	i16 iPKey;           
	i16 nCol;            
	u16 nRef;            
	LogEst nRowLogEst;   
	LogEst szTabRow;     
#ifdef SQLITE_ENABLE_COSTMULT
	LogEst costMult;     
#endif
	u8 tabFlags;         
	u8 keyConf;          
#ifndef SQLITE_OMIT_ALTERTABLE
	int addColOffset;    
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
	int nModuleArg;      
	char **azModuleArg;  
	VTable *pVTable;     
#endif
	Trigger *pTrigger;   
	Schema *pSchema;     
	Table *pNextZombie;  
};


#define TF_Readonly        0x01    
#define TF_Ephemeral       0x02    
#define TF_HasPrimaryKey   0x04    
#define TF_Autoincrement   0x08    
#define TF_Virtual         0x10    
#define TF_WithoutRowid    0x20    
#define TF_NoVisibleRowid  0x40    
#define TF_OOOHidden       0x80    



#ifndef SQLITE_OMIT_VIRTUALTABLE
#  define IsVirtual(X)      (((X)->tabFlags & TF_Virtual)!=0)
#else
#  define IsVirtual(X)      0
#endif


#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)
#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)
#  define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)
#elif !defined(SQLITE_OMIT_VIRTUALTABLE)
#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)
#  define IsOrdinaryHiddenColumn(X) 0
#else
#  define IsHiddenColumn(X)         0
#  define IsOrdinaryHiddenColumn(X) 0
#endif



#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)


struct FKey {
	Table *pFrom;     
	FKey *pNextFrom;  
	char *zTo;        
	FKey *pNextTo;    
	FKey *pPrevTo;    
	int nCol;         
					  
	u8 isDeferred;       
	u8 aAction[2];        
	Trigger *apTrigger[2];
	struct sColMap {      
		int iFrom;            
		char *zCol;           
	} aCol[1];            
};


#define OE_None     0   
#define OE_Rollback 1   
#define OE_Abort    2   
#define OE_Fail     3   
#define OE_Ignore   4   
#define OE_Replace  5   

#define OE_Restrict 6   
#define OE_SetNull  7   
#define OE_SetDflt  8   
#define OE_Cascade  9   

#define OE_Default  10  



struct KeyInfo {
	u32 nRef;           
	u8 enc;             
	u16 nField;         
	u16 nXField;        
	sqlite3 *db;        
	u8 *aSortOrder;     
	CollSeq *aColl[1];  
};


struct UnpackedRecord {
	KeyInfo *pKeyInfo;  
	Mem *aMem;          
	u16 nField;         
	i8 default_rc;      
	u8 errCode;         
	i8 r1;              
	i8 r2;              
	u8 eqSeen;          
};



struct Index {
	char *zName;             
	i16 *aiColumn;           
	LogEst *aiRowLogEst;     
	Table *pTable;           
	char *zColAff;           
	Index *pNext;            
	Schema *pSchema;         
	u8 *aSortOrder;          
	const char **azColl;     
	Expr *pPartIdxWhere;     
	ExprList *aColExpr;      
	int tnum;                
	LogEst szIdxRow;         
	u16 nKeyCol;             
	u16 nColumn;             
	u8 onError;              
	unsigned idxType : 2;      
	unsigned bUnordered : 1;   
	unsigned uniqNotNull : 1;  
	unsigned isResized : 1;    
	unsigned isCovering : 1;   
	unsigned noSkipScan : 1;   
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	int nSample;             
	int nSampleCol;          
	tRowcnt *aAvgEq;         
	IndexSample *aSample;    
	tRowcnt *aiRowEst;       
	tRowcnt nRowEst0;        
#endif
};


#define SQLITE_IDXTYPE_APPDEF      0   
#define SQLITE_IDXTYPE_UNIQUE      1   
#define SQLITE_IDXTYPE_PRIMARYKEY  2   


#define IsPrimaryKeyIndex(X)  ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)


#define IsUniqueIndex(X)      ((X)->onError!=OE_None)


#define XN_ROWID     (-1)     
#define XN_EXPR      (-2)     


struct IndexSample {
	void *p;          
	int n;            
	tRowcnt *anEq;    
	tRowcnt *anLt;    
	tRowcnt *anDLt;   
};


struct Token {
	const char *z;     
	unsigned int n;    
};


struct AggInfo {
	u8 directMode;          
	u8 useSortingIdx;       
	int sortingIdx;         
	int sortingIdxPTab;     
	int nSortingColumn;     
	int mnReg, mxReg;       
	ExprList *pGroupBy;     
	struct AggInfo_col {    
		Table *pTab;             
		int iTable;              
		int iColumn;             
		int iSorterColumn;       
		int iMem;                
		Expr *pExpr;             
	} *aCol;
	int nColumn;            
	int nAccumulator;       
	struct AggInfo_func {   
		Expr *pExpr;             
		FuncDef *pFunc;          
		int iMem;                
		int iDistinct;           
	} *aFunc;
	int nFunc;              
};


#if SQLITE_MAX_VARIABLE_NUMBER<=32767
typedef i16 ynVar;
#else
typedef int ynVar;
#endif


struct Expr {
	u8 op;                 
	char affinity;         
	u32 flags;             
	union {
		char *zToken;          
		int iValue;            
	} u;

	

	Expr *pLeft;           
	Expr *pRight;          
	union {
		ExprList *pList;     
		Select *pSelect;     
	} x;

	

#if SQLITE_MAX_EXPR_DEPTH>0
	int nHeight;           
#endif
	int iTable;            
	ynVar iColumn;         
	i16 iAgg;              
	i16 iRightJoinTable;   
	u8 op2;                
	AggInfo *pAggInfo;     
	Table *pTab;           
};


#define EP_FromJoin  0x000001 
#define EP_Agg       0x000002 
#define EP_Resolved  0x000004 
#define EP_Error     0x000008 
#define EP_Distinct  0x000010 
#define EP_VarSelect 0x000020 
#define EP_DblQuoted 0x000040 
#define EP_InfixFunc 0x000080 
#define EP_Collate   0x000100 
#define EP_Generic   0x000200 
#define EP_IntValue  0x000400 
#define EP_xIsSelect 0x000800 
#define EP_Skip      0x001000 
#define EP_Reduced   0x002000 
#define EP_TokenOnly 0x004000 
#define EP_Static    0x008000 
#define EP_MemToken  0x010000 
#define EP_NoReduce  0x020000 
#define EP_Unlikely  0x040000 
#define EP_ConstFunc 0x080000 
#define EP_CanBeNull 0x100000 
#define EP_Subquery  0x200000 
#define EP_Alias     0x400000 
#define EP_Leaf      0x800000 


#define EP_Propagate (EP_Collate|EP_Subquery) 


#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))
#define ExprSetProperty(E,P)     (E)->flags|=(P)
#define ExprClearProperty(E,P)   (E)->flags&=~(P)


#ifdef SQLITE_DEBUG
# define ExprSetVVAProperty(E,P)  (E)->flags|=(P)
#else
# define ExprSetVVAProperty(E,P)
#endif


#define EXPR_FULLSIZE           sizeof(Expr)           
#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  
#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   


#define EXPRDUP_REDUCE         0x0001  


struct ExprList {
	int nExpr;             
	struct ExprList_item { 
		Expr *pExpr;            
		char *zName;            
		char *zSpan;            
		u8 sortOrder;           
		unsigned done : 1;       
		unsigned bSpanIsTab : 1; 
		unsigned reusable : 1;   
		union {
			struct {
				u16 iOrderByCol;      
				u16 iAlias;           
			} x;
			int iConstExprReg;      
		} u;
	} *a;                  
};


struct ExprSpan {
	Expr *pExpr;          
	const char *zStart;   
	const char *zEnd;     
};


struct IdList {
	struct IdList_item {
		char *zName;      
		int idx;          
	} *a;
	int nId;         
};


#ifdef SQLITE_BITMASK_TYPE
typedef SQLITE_BITMASK_TYPE Bitmask;
#else
typedef u64 Bitmask;
#endif


#define BMS  ((int)(sizeof(Bitmask)*8))


#define MASKBIT(n)   (((Bitmask)1)<<(n))
#define MASKBIT32(n) (((unsigned int)1)<<(n))
#define ALLBITS      ((Bitmask)-1)


struct SrcList {
	int nSrc;        
	u32 nAlloc;      
	struct SrcList_item {
		Schema *pSchema;  
		char *zDatabase;  
		char *zName;      
		char *zAlias;     
		Table *pTab;      
		Select *pSelect;  
		int addrFillSub;  
		int regReturn;    
		int regResult;    
		struct {
			u8 jointype;      
			unsigned notIndexed : 1;    
			unsigned isIndexedBy : 1;   
			unsigned isTabFunc : 1;     
			unsigned isCorrelated : 1;  
			unsigned viaCoroutine : 1;  
			unsigned isRecursive : 1;   
		} fg;
#ifndef SQLITE_OMIT_EXPLAIN
		u8 iSelectId;     
#endif
		int iCursor;      
		Expr *pOn;        
		IdList *pUsing;   
		Bitmask colUsed;  
		union {
			char *zIndexedBy;    
			ExprList *pFuncArg;  
		} u1;
		Index *pIBIndex;  
	} a[1];             
};


#define JT_INNER     0x0001    
#define JT_CROSS     0x0002    
#define JT_NATURAL   0x0004    
#define JT_LEFT      0x0008    
#define JT_RIGHT     0x0010    
#define JT_OUTER     0x0020    
#define JT_ERROR     0x0040    



#define WHERE_ORDERBY_NORMAL   0x0000 
#define WHERE_ORDERBY_MIN      0x0001 
#define WHERE_ORDERBY_MAX      0x0002 
#define WHERE_ONEPASS_DESIRED  0x0004 
#define WHERE_ONEPASS_MULTIROW 0x0008 
#define WHERE_DUPLICATES_OK    0x0010 
#define WHERE_OR_SUBCLAUSE     0x0020 
#define WHERE_GROUPBY          0x0040 
#define WHERE_DISTINCTBY       0x0080 
#define WHERE_WANT_DISTINCT    0x0100 
#define WHERE_SORTBYGROUP      0x0200 
#define WHERE_SEEK_TABLE       0x0400 
#define WHERE_ORDERBY_LIMIT    0x0800 


#define WHERE_USE_LIMIT        0x4000 



#define WHERE_DISTINCT_NOOP      0  
#define WHERE_DISTINCT_UNIQUE    1  
#define WHERE_DISTINCT_ORDERED   2  
#define WHERE_DISTINCT_UNORDERED 3  


struct NameContext {
	Parse *pParse;       
	SrcList *pSrcList;   
	ExprList *pEList;    
	AggInfo *pAggInfo;   
	NameContext *pNext;  
	int nRef;            
	int nErr;            
	u16 ncFlags;         
};


#define NC_AllowAgg  0x0001  
#define NC_PartIdx   0x0002  
#define NC_IsCheck   0x0004  
#define NC_InAggFunc 0x0008  
#define NC_HasAgg    0x0010  
#define NC_IdxExpr   0x0020  
#define NC_VarSelect 0x0040  
#define NC_MinMaxAgg 0x1000  


struct Select {
	ExprList *pEList;      
	u8 op;                 
	LogEst nSelectRow;     
	u32 selFlags;          
	int iLimit, iOffset;   
#if SELECTTRACE_ENABLED
	char zSelName[12];     
#endif
	int addrOpenEphm[2];   
	SrcList *pSrc;         
	Expr *pWhere;          
	ExprList *pGroupBy;    
	Expr *pHaving;         
	ExprList *pOrderBy;    
	Select *pPrior;        
	Select *pNext;         
	Expr *pLimit;          
	Expr *pOffset;         
	With *pWith;           
};


#define SF_Distinct       0x00001  
#define SF_All            0x00002  
#define SF_Resolved       0x00004  
#define SF_Aggregate      0x00008  
#define SF_HasAgg         0x00010  
#define SF_UsesEphemeral  0x00020  
#define SF_Expanded       0x00040  
#define SF_HasTypeInfo    0x00080  
#define SF_Compound       0x00100  
#define SF_Values         0x00200  
#define SF_MultiValue     0x00400  
#define SF_NestedFrom     0x00800  
#define SF_MinMaxAgg      0x01000  
#define SF_Recursive      0x02000  
#define SF_FixedLimit     0x04000  
#define SF_MaybeConvert   0x08000  
#define SF_Converted      0x10000  
#define SF_IncludeHidden  0x20000  



#define SRT_Union        1  
#define SRT_Except       2  
#define SRT_Exists       3  
#define SRT_Discard      4  
#define SRT_Fifo         5  
#define SRT_DistFifo     6  
#define SRT_Queue        7  
#define SRT_DistQueue    8  


#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)

#define SRT_Output       9  
#define SRT_Mem         10  
#define SRT_Set         11  
#define SRT_EphemTab    12  
#define SRT_Coroutine   13  
#define SRT_Table       14  


struct SelectDest {
	u8 eDest;            
	char *zAffSdst;      
	int iSDParm;         
	int iSdst;           
	int nSdst;           
	ExprList *pOrderBy;  
};


struct AutoincInfo {
	AutoincInfo *pNext;   
	Table *pTab;          
	int iDb;              
	int regCtr;           
};


#ifndef SQLITE_N_COLCACHE
# define SQLITE_N_COLCACHE 10
#endif


struct TriggerPrg {
	Trigger *pTrigger;      
	TriggerPrg *pNext;      
	SubProgram *pProgram;   
	int orconf;             
	u32 aColmask[2];        
};


#if SQLITE_MAX_ATTACHED>30
typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED + 9) / 8];
# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)
# define DbMaskZero(M)      memset((M),0,sizeof(M))
# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))
# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)
# define DbMaskNonZero(M)   (sqlite3DbMaskAllZero(M)==0)
#else
typedef unsigned int yDbMask;
# define DbMaskTest(M,I)    (((M)&(((yDbMask)1)<<(I)))!=0)
# define DbMaskZero(M)      (M)=0
# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))
# define DbMaskAllZero(M)   (M)==0
# define DbMaskNonZero(M)   (M)!=0
#endif


struct Parse {
	sqlite3 *db;         
	char *zErrMsg;       
	Vdbe *pVdbe;         
	int rc;              
	u8 colNamesSet;      
	u8 checkSchema;      
	u8 nested;           
	u8 nTempReg;         
	u8 isMultiWrite;     
	u8 mayAbort;         
	u8 hasCompound;      
	u8 okConstFactor;    
	u8 disableLookaside; 
	u8 nColCache;        
	int nRangeReg;       
	int iRangeReg;       
	int nErr;            
	int nTab;            
	int nMem;            
	int nOpAlloc;        
	int szOpAlloc;       
	int ckBase;          
	int iSelfTab;        
	int iCacheLevel;     
	int iCacheCnt;       
	int nLabel;          
	int *aLabel;         
	ExprList *pConstExpr;
	Token constraintName;
	yDbMask writeMask;   
	yDbMask cookieMask;  
	int regRowid;        
	int regRoot;         
	int nMaxArg;         
#if SELECTTRACE_ENABLED
	int nSelect;         
	int nSelectIndent;   
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
	int nTableLock;        
	TableLock *aTableLock; 
#endif
	AutoincInfo *pAinc;  
	Parse *pToplevel;    
	Table *pTriggerTab;  
	int addrCrTab;       
	u32 nQueryLoop;      
	u32 oldmask;         
	u32 newmask;         
	u8 eTriggerOp;       
	u8 eOrconf;          
	u8 disableTriggers;  

						 

	struct yColCache {
		int iTable;           
		i16 iColumn;          
		u8 tempReg;           
		int iLevel;           
		int iReg;             
		int lru;              
	} aColCache[SQLITE_N_COLCACHE];  
	int aTempReg[8];        
	Token sNameToken;       

							

	Token sLastToken;       
	ynVar nVar;               
	int nzVar;                
	u8 iPkSortOrder;          
	u8 explain;               
#ifndef SQLITE_OMIT_VIRTUALTABLE
	u8 declareVtab;           
	int nVtabLock;            
#endif
	int nHeight;              
#ifndef SQLITE_OMIT_EXPLAIN
	int iSelectId;            
	int iNextSelectId;        
#endif
	char **azVar;             
	Vdbe *pReprepare;         
	const char *zTail;        
	Table *pNewTable;         
	Trigger *pNewTrigger;     
	const char *zAuthContext; 
#ifndef SQLITE_OMIT_VIRTUALTABLE
	Token sArg;               
	Table **apVtabLock;       
#endif
	Table *pZombieTab;        
	TriggerPrg *pTriggerPrg;  
	With *pWith;              
	With *pWithToFree;        
};


#define PARSE_HDR_SZ offsetof(Parse,aColCache) 
#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)    
#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ) 
#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)  


#ifdef SQLITE_OMIT_VIRTUALTABLE
#define IN_DECLARE_VTAB 0
#else
#define IN_DECLARE_VTAB (pParse->declareVtab)
#endif


struct AuthContext {
	const char *zAuthContext;   
	Parse *pParse;              
};


#define OPFLAG_NCHANGE       0x01    

#define OPFLAG_EPHEM         0x01    
#define OPFLAG_LASTROWID     0x02    
#define OPFLAG_ISUPDATE      0x04    
#define OPFLAG_APPEND        0x08    
#define OPFLAG_USESEEKRESULT 0x10    
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
#define OPFLAG_ISNOOP        0x40    
#endif
#define OPFLAG_LENGTHARG     0x40    
#define OPFLAG_TYPEOFARG     0x80    
#define OPFLAG_BULKCSR       0x01    
#define OPFLAG_SEEKEQ        0x02    
#define OPFLAG_FORDELETE     0x08    
#define OPFLAG_P2ISREG       0x10    
#define OPFLAG_PERMUTE       0x01    
#define OPFLAG_SAVEPOSITION  0x02    
#define OPFLAG_AUXDELETE     0x04    


struct Trigger {
	char *zName;            
	char *table;            
	u8 op;                  
	u8 tr_tm;               
	Expr *pWhen;            
	IdList *pColumns;       
	Schema *pSchema;        
	Schema *pTabSchema;     
	TriggerStep *step_list; 
	Trigger *pNext;         
};


#define TRIGGER_BEFORE  1
#define TRIGGER_AFTER   2


struct TriggerStep {
	u8 op;               
	u8 orconf;           
	Trigger *pTrig;      
	Select *pSelect;     
	char *zTarget;       
	Expr *pWhere;        
	ExprList *pExprList; 
	IdList *pIdList;     
	TriggerStep *pNext;  
	TriggerStep *pLast;  
};


typedef struct DbFixer DbFixer;
struct DbFixer {
	Parse *pParse;      
	Schema *pSchema;    
	int bVarOnly;       
	const char *zDb;    
	const char *zType;  
	const Token *pName; 
};


struct StrAccum {
	sqlite3 *db;         
	char *zBase;         
	char *zText;         
	u32  nChar;          
	u32  nAlloc;         
	u32  mxAlloc;        
	u8   accError;       
	u8   printfFlags;    
};
#define STRACCUM_NOMEM   1
#define STRACCUM_TOOBIG  2
#define SQLITE_PRINTF_INTERNAL 0x01  
#define SQLITE_PRINTF_SQLFUNC  0x02  
#define SQLITE_PRINTF_MALLOCED 0x04  

#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)



typedef struct {
	sqlite3 *db;        
	char **pzErrMsg;    
	int iDb;            
	int rc;             
} InitData;


struct Sqlite3Config {
	int bMemstat;                     
	int bCoreMutex;                   
	int bFullMutex;                   
	int bOpenUri;                     
	int bUseCis;                      
	int mxStrlen;                     
	int neverCorrupt;                 
	int szLookaside;                  
	int nLookaside;                   
	int nStmtSpill;                   
	sqlite3_mem_methods m;            
	sqlite3_mutex_methods mutex;      
	sqlite3_pcache_methods2 pcache2;  
	void *pHeap;                      
	int nHeap;                        
	int mnReq, mxReq;                 
	sqlite3_int64 szMmap;             
	sqlite3_int64 mxMmap;             
	void *pScratch;                   
	int szScratch;                    
	int nScratch;                     
	void *pPage;                      
	int szPage;                       
	int nPage;                        
	int mxParserStack;                
	int sharedCacheEnabled;           
	u32 szPma;                        
									  
	int isInit;                       
	int inProgress;                   
	int isMutexInit;                  
	int isMallocInit;                 
	int isPCacheInit;                 
	int nRefInitMutex;                
	sqlite3_mutex *pInitMutex;        
	void(*xLog)(void*, int, const char*); 
	void *pLogArg;                       
#ifdef SQLITE_ENABLE_SQLLOG
	void(*xSqllog)(void*, sqlite3*, const char*, int);
	void *pSqllogArg;
#endif
#ifdef SQLITE_VDBE_COVERAGE
	
	void(*xVdbeBranch)(void*, int iSrcLine, u8 eThis, u8 eMx);  
	void *pVdbeBranchArg;                                     
#endif
#ifndef SQLITE_OMIT_BUILTIN_TEST
	int(*xTestCallback)(int);        
#endif
	int bLocaltimeFault;              
	int iOnceResetThreshold;          
};


#define CORRUPT_DB  (sqlite3Config.neverCorrupt==0)


struct Walker {
	Parse *pParse;                            
	int(*xExprCallback)(Walker*, Expr*);     
	int(*xSelectCallback)(Walker*, Select*);  
	void(*xSelectCallback2)(Walker*, Select*);
	int walkerDepth;                          
	u8 eCode;                                 
	union {                                   
		NameContext *pNC;                          
		int n;                                     
		int iCur;                                  
		SrcList *pSrcList;                         
		struct SrcCount *pSrcCount;                
		struct CCurHint *pCCurHint;                
		int *aiCol;                                
		struct IdxCover *pIdxCover;                
	} u;
};


SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*);
SQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*);
SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*);
SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);
SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);
SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*);


#define WRC_Continue    0   
#define WRC_Prune       1   
#define WRC_Abort       2   


struct With {
	int nCte;                       
	With *pOuter;                   
	struct Cte {                    
		char *zName;                    
		ExprList *pCols;                
		Select *pSelect;                
		const char *zCteErr;            
	} a[1];
};

#ifdef SQLITE_DEBUG

struct TreeView {
	int iLevel;             
	u8  bLine[100];         
};
#endif 


#define SQLITE_SKIP_UTF8(zIn) {                        \
  if( (*(zIn++))>=0xc0 ){                              \
    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \
  }                                                    \
}


SQLITE_PRIVATE int sqlite3CorruptError(int);
SQLITE_PRIVATE int sqlite3MisuseError(int);
SQLITE_PRIVATE int sqlite3CantopenError(int);
#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)
#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)
#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE   int sqlite3NomemError(int);
SQLITE_PRIVATE   int sqlite3IoerrnomemError(int);
# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)
# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)
#else
# define SQLITE_NOMEM_BKPT SQLITE_NOMEM
# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM
#endif


#if defined(SQLITE_OMIT_VIRTUALTABLE)
# undef SQLITE_ENABLE_FTS3
# undef SQLITE_ENABLE_FTS4
#endif


#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)
# define SQLITE_ENABLE_FTS3 1
#endif


#if !defined(SQLITE_ASCII) || \
    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))
# include <ctype.h>
#endif


#ifdef SQLITE_ASCII
# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))
# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)
# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)
# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)
# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)
# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)
# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])
# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)
#else
# define sqlite3Toupper(x)   toupper((unsigned char)(x))
# define sqlite3Isspace(x)   isspace((unsigned char)(x))
# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))
# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))
# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))
# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))
# define sqlite3Tolower(x)   tolower((unsigned char)(x))
# define sqlite3Isquote(x)   ((x)=='"'||(x)=='\''||(x)=='['||(x)=='`')
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_PRIVATE int sqlite3IsIdChar(u8);
#endif


SQLITE_PRIVATE int sqlite3StrICmp(const char*, const char*);
SQLITE_PRIVATE int sqlite3Strlen30(const char*);
SQLITE_PRIVATE char *sqlite3ColumnType(Column*, char*);
#define sqlite3StrNICmp sqlite3_strnicmp

SQLITE_PRIVATE int sqlite3MallocInit(void);
SQLITE_PRIVATE void sqlite3MallocEnd(void);
SQLITE_PRIVATE void *sqlite3Malloc(u64);
SQLITE_PRIVATE void *sqlite3MallocZero(u64);
SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, u64);
SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, u64);
SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, u64);
SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*, const char*);
SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*, const char*, u64);
SQLITE_PRIVATE void *sqlite3Realloc(void*, u64);
SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);
SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64);
SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);
SQLITE_PRIVATE int sqlite3MallocSize(void*);
SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);
SQLITE_PRIVATE void *sqlite3ScratchMalloc(int);
SQLITE_PRIVATE void sqlite3ScratchFree(void*);
SQLITE_PRIVATE void *sqlite3PageMalloc(int);
SQLITE_PRIVATE void sqlite3PageFree(void*);
SQLITE_PRIVATE void sqlite3MemSetDefault(void);
#ifndef SQLITE_OMIT_BUILTIN_TEST
SQLITE_PRIVATE void sqlite3BenignMallocHooks(void(*)(void), void(*)(void));
#endif
SQLITE_PRIVATE int sqlite3HeapNearlyFull(void);


#ifdef SQLITE_USE_ALLOCA
# define sqlite3StackAllocRaw(D,N)   alloca(N)
# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)
# define sqlite3StackFree(D,P)
#else
# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)
# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)
# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)
#endif


#ifdef SQLITE_ENABLE_MEMSYS5
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void);
#undef SQLITE_ENABLE_MEMSYS3
#endif
#ifdef SQLITE_ENABLE_MEMSYS3
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void);
#endif


#ifndef SQLITE_MUTEX_OMIT
SQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3DefaultMutex(void);
SQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3NoopMutex(void);
SQLITE_PRIVATE   sqlite3_mutex *sqlite3MutexAlloc(int);
SQLITE_PRIVATE   int sqlite3MutexInit(void);
SQLITE_PRIVATE   int sqlite3MutexEnd(void);
#endif
#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)
SQLITE_PRIVATE   void sqlite3MemoryBarrier(void);
#else
# define sqlite3MemoryBarrier()
#endif

SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int);
SQLITE_PRIVATE void sqlite3StatusUp(int, int);
SQLITE_PRIVATE void sqlite3StatusDown(int, int);
SQLITE_PRIVATE void sqlite3StatusHighwater(int, int);


SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void);
SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void);

#ifndef SQLITE_OMIT_FLOATING_POINT
SQLITE_PRIVATE   int sqlite3IsNaN(double);
#else
# define sqlite3IsNaN(X)  0
#endif


struct PrintfArguments {
	int nArg;                
	int nUsed;               
	sqlite3_value **apArg;   
};

SQLITE_PRIVATE void sqlite3VXPrintf(StrAccum*, const char*, va_list);
SQLITE_PRIVATE void sqlite3XPrintf(StrAccum*, const char*, ...);
SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*, const char*, ...);
SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*, const char*, va_list);
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
SQLITE_PRIVATE   void sqlite3DebugPrintf(const char*, ...);
#endif
#if defined(SQLITE_TEST)
SQLITE_PRIVATE   void *sqlite3TestTextToPtr(const char*);
#endif

#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE   void sqlite3TreeViewExpr(TreeView*, const Expr*, u8);
SQLITE_PRIVATE   void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*);
SQLITE_PRIVATE   void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*);
SQLITE_PRIVATE   void sqlite3TreeViewSelect(TreeView*, const Select*, u8);
SQLITE_PRIVATE   void sqlite3TreeViewWith(TreeView*, const With*, u8);
#endif


SQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*);
SQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...);
SQLITE_PRIVATE void sqlite3Dequote(char*);
SQLITE_PRIVATE void sqlite3TokenInit(Token*, char*);
SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int);
SQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **);
SQLITE_PRIVATE void sqlite3FinishCoding(Parse*);
SQLITE_PRIVATE int sqlite3GetTempReg(Parse*);
SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*, int);
SQLITE_PRIVATE int sqlite3GetTempRange(Parse*, int);
SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*, int, int);
SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse*, int, int);
#endif
SQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*, int, const Token*, int);
SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*, int, const char*);
SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*, Expr*, Expr*, Expr*);
SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*, const Token*);
SQLITE_PRIVATE void sqlite3PExprAddSelect(Parse*, Expr*, Select*);
SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*, Expr*, Expr*);
SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*, ExprList*, Token*);
SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);
SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);
SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*, ExprList*, Expr*);
SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(Parse*, ExprList*, IdList*, Expr*);
SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*, int);
SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*, ExprList*, Token*, int);
SQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*, ExprList*, ExprSpan*);
SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);
SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*);
SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**);
SQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**);
SQLITE_PRIVATE void sqlite3Pragma(Parse*, Token*, Token*, Token*, int);
SQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3*);
SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*, int);
SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*);
SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);
SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*, Table*);
SQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*, ExprList*, i16*, Column**);
SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*, Table*, Select*);
SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*, Select*);
SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);
SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*);
SQLITE_PRIVATE i16 sqlite3ColumnOfIndex(Index*, i16);
SQLITE_PRIVATE void sqlite3StartTable(Parse*, Token*, Token*, int, int, int, int);
#if SQLITE_ENABLE_HIDDEN_COLUMNS
SQLITE_PRIVATE   void sqlite3ColumnPropertiesFromName(Table*, Column*);
#else
# define sqlite3ColumnPropertiesFromName(T,C) 
#endif
SQLITE_PRIVATE void sqlite3AddColumn(Parse*, Token*, Token*);
SQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int);
SQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);
SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*);
SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*, ExprSpan*);
SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*);
SQLITE_PRIVATE void sqlite3EndTable(Parse*, Token*, Token*, u8, Select*);
SQLITE_PRIVATE int sqlite3ParseUri(const char*, const char*, unsigned int*,
	sqlite3_vfs**, char**, char **);
SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*, const char*);

#ifdef SQLITE_OMIT_BUILTIN_TEST
# define sqlite3FaultSim(X) SQLITE_OK
#else
SQLITE_PRIVATE   int sqlite3FaultSim(int);
#endif

SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32);
SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32);
SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec*, u32);
SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32);
SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32, void*);
SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*);
SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec*);
#ifndef SQLITE_OMIT_BUILTIN_TEST
SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int, int*);
#endif

SQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);
SQLITE_PRIVATE void sqlite3RowSetClear(RowSet*);
SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64);
SQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, int iBatch, i64);
SQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*);

SQLITE_PRIVATE void sqlite3CreateView(Parse*, Token*, Token*, Token*, ExprList*, Select*, int, int);

#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
SQLITE_PRIVATE   int sqlite3ViewGetColumnNames(Parse*, Table*);
#else
# define sqlite3ViewGetColumnNames(A,B) 0
#endif

#if SQLITE_MAX_ATTACHED>30
SQLITE_PRIVATE   int sqlite3DbMaskAllZero(yDbMask);
#endif
SQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int);
SQLITE_PRIVATE void sqlite3CodeDropTable(Parse*, Table*, int, int);
SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3*, Table*);
#ifndef SQLITE_OMIT_AUTOINCREMENT
SQLITE_PRIVATE   void sqlite3AutoincrementBegin(Parse *pParse);
SQLITE_PRIVATE   void sqlite3AutoincrementEnd(Parse *pParse);
#else
# define sqlite3AutoincrementBegin(X)
# define sqlite3AutoincrementEnd(X)
#endif
SQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int);
SQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*, void*, int, int*, int*);
SQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);
SQLITE_PRIVATE int sqlite3IdListIndex(IdList*, const char*);
SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);
SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);
SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,
	Token*, Select*, Expr*, IdList*);
SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);
SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);
SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);
SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*);
SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*);
SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*);
SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*);
SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*, i16, int, char**);
SQLITE_PRIVATE void sqlite3CreateIndex(Parse*, Token*, Token*, SrcList*, ExprList*, int, Token*,
	Expr*, int, int, u8);
SQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int);
SQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*);
SQLITE_PRIVATE Select *sqlite3SelectNew(Parse*, ExprList*, SrcList*, Expr*, ExprList*,
	Expr*, ExprList*, u32, Expr*, Expr*);
SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*);
SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*);
SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int);
SQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)
SQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse*, SrcList*, Expr*, ExprList*, Expr*, Expr*, char*);
#endif
SQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*);
SQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*, Expr*, int);
SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*, SrcList*, Expr*, ExprList*, ExprList*, u16, int);
SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*);
SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereOrderedInnerLoop(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo*);
SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo*, int*);
#define ONEPASS_OFF      0        
#define ONEPASS_SINGLE   1        
#define ONEPASS_MULTI    2        
SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);
SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);
SQLITE_PRIVATE void sqlite3ExprCodeGetColumnToReg(Parse*, Table*, int, int, int);
SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);
SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int);
SQLITE_PRIVATE void sqlite3ExprCacheStore(Parse*, int, int, int);
SQLITE_PRIVATE void sqlite3ExprCachePush(Parse*);
SQLITE_PRIVATE void sqlite3ExprCachePop(Parse*);
SQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse*, int, int);
SQLITE_PRIVATE void sqlite3ExprCacheClear(Parse*);
SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse*, int, int);
SQLITE_PRIVATE void sqlite3ExprCode(Parse*, Expr*, int);
SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, Expr*, int);
SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse*, Expr*, int);
SQLITE_PRIVATE void sqlite3ExprCodeAtInit(Parse*, Expr*, int, u8);
SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);
SQLITE_PRIVATE void sqlite3ExprCodeAndCache(Parse*, Expr*, int);
SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);
#define SQLITE_ECEL_DUP      0x01  
#define SQLITE_ECEL_FACTOR   0x02  
#define SQLITE_ECEL_REF      0x04  
SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int);
SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int);
SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);
SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*, const char*, const char*);
#define LOCATE_VIEW    0x01
#define LOCATE_NOERR   0x02
SQLITE_PRIVATE Table *sqlite3LocateTable(Parse*, u32 flags, const char*, const char*);
SQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*, u32 flags, struct SrcList_item *);
SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*, const char*, const char*);
SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*, int, const char*);
SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*, int, const char*);
SQLITE_PRIVATE void sqlite3Vacuum(Parse*, Token*);
SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*, int);
SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);
SQLITE_PRIVATE int sqlite3ExprCompare(Expr*, Expr*, int);
SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);
SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Expr*, Expr*, int);
SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*, ExprList*);
SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);
SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);
#ifndef SQLITE_OMIT_BUILTIN_TEST
SQLITE_PRIVATE void sqlite3PrngSaveState(void);
SQLITE_PRIVATE void sqlite3PrngRestoreState(void);
#endif
SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*, int);
SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int);
SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);
SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int);
SQLITE_PRIVATE void sqlite3CommitTransaction(Parse*);
SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse*);
SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);
SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);
SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*);
SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);
SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);
SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8);
SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*, int);
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr*);
#endif
SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);
SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*);
SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);
SQLITE_PRIVATE int sqlite3IsRowid(const char*);
SQLITE_PRIVATE void sqlite3GenerateRowDelete(
	Parse*, Table*, Trigger*, int, int, int, i16, u8, u8, u8, int);
SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);
SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*, Index*, int);
SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse*, int);
SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*, Table*, int*, int, int, int, int,
	u8, u8, int, int*, int*);
SQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*, Table*, int, int, int, int*, int, int, int);
SQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);
SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int);
SQLITE_PRIVATE void sqlite3MultiWrite(Parse*);
SQLITE_PRIVATE void sqlite3MayAbort(Parse*);
SQLITE_PRIVATE void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);
SQLITE_PRIVATE void sqlite3UniqueConstraint(Parse*, int, Index*);
SQLITE_PRIVATE void sqlite3RowidConstraint(Parse*, int, Table*);
SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*, Expr*, int);
SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*, ExprList*, int);
SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*, SrcList*, int);
SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*, IdList*);
SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*, Select*, int);
#if SELECTTRACE_ENABLED
SQLITE_PRIVATE void sqlite3SelectSetName(Select*, const char*);
#else
# define sqlite3SelectSetName(A,B)
#endif
SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(FuncDef*, int);
SQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*, const char*, int, u8, u8);
SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void);
SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void);
SQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);
SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*);
SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*);
SQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int);

#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, int);
#endif

#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE   void sqlite3BeginTrigger(Parse*, Token*, Token*, int, int, IdList*, SrcList*,
	Expr*, int, int);
SQLITE_PRIVATE   void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);
SQLITE_PRIVATE   void sqlite3DropTrigger(Parse*, SrcList*, int);
SQLITE_PRIVATE   void sqlite3DropTriggerPtr(Parse*, Trigger*);
SQLITE_PRIVATE   Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);
SQLITE_PRIVATE   Trigger *sqlite3TriggerList(Parse *, Table *);
SQLITE_PRIVATE   void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,
	int, int, int);
SQLITE_PRIVATE   void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);
void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);
SQLITE_PRIVATE   void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);
SQLITE_PRIVATE   TriggerStep *sqlite3TriggerSelectStep(sqlite3*, Select*);
SQLITE_PRIVATE   TriggerStep *sqlite3TriggerInsertStep(sqlite3*, Token*, IdList*,
	Select*, u8);
SQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(sqlite3*, Token*, ExprList*, Expr*, u8);
SQLITE_PRIVATE   TriggerStep *sqlite3TriggerDeleteStep(sqlite3*, Token*, Expr*);
SQLITE_PRIVATE   void sqlite3DeleteTrigger(sqlite3*, Trigger*);
SQLITE_PRIVATE   void sqlite3UnlinkAndDeleteTrigger(sqlite3*, int, const char*);
SQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*, Trigger*, ExprList*, int, int, Table*, int);
# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))
# define sqlite3IsToplevel(p) ((p)->pToplevel==0)
#else
# define sqlite3TriggersExist(B,C,D,E,F) 0
# define sqlite3DeleteTrigger(A,B)
# define sqlite3DropTriggerPtr(A,B)
# define sqlite3UnlinkAndDeleteTrigger(A,B,C)
# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)
# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)
# define sqlite3TriggerList(X, Y) 0
# define sqlite3ParseToplevel(p) p
# define sqlite3IsToplevel(p) 1
# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0
#endif

SQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*);
SQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);
SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int);
#ifndef SQLITE_OMIT_AUTHORIZATION
SQLITE_PRIVATE   void sqlite3AuthRead(Parse*, Expr*, Schema*, SrcList*);
SQLITE_PRIVATE   int sqlite3AuthCheck(Parse*, int, const char*, const char*, const char*);
SQLITE_PRIVATE   void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);
SQLITE_PRIVATE   void sqlite3AuthContextPop(AuthContext*);
SQLITE_PRIVATE   int sqlite3AuthReadCol(Parse*, const char *, const char *, int);
#else
# define sqlite3AuthRead(a,b,c,d)
# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK
# define sqlite3AuthContextPush(a,b,c)
# define sqlite3AuthContextPop(a)  ((void)(a))
#endif
SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);
SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*);
SQLITE_PRIVATE void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);
SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);
SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);
SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*);
SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);
SQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);
SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);
SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);
SQLITE_PRIVATE int sqlite3Atoi(const char*);
SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);
SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);
SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**);
SQLITE_PRIVATE LogEst sqlite3LogEst(u64);
SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst, LogEst);
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);
#endif
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \
    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);
#endif


SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64);
SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *);
SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *);
SQLITE_PRIVATE int sqlite3VarintLen(u64 v);


#define getVarint32(A,B)  \
  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))
#define putVarint32(A,B)  \
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
  sqlite3PutVarint((A),(B)))
#define getVarint    sqlite3GetVarint
#define putVarint    sqlite3PutVarint


SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int);
SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);
SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);
SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table*, int);
SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr);
SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8);
SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char*, i64*);
SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3*, int, const char*, ...);
SQLITE_PRIVATE void sqlite3Error(sqlite3*, int);
SQLITE_PRIVATE void sqlite3SystemError(sqlite3*, int);
SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n);
SQLITE_PRIVATE u8 sqlite3HexToInt(int h);
SQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);

#if defined(SQLITE_NEED_ERR_NAME)
SQLITE_PRIVATE const char *sqlite3ErrName(int);
#endif

SQLITE_PRIVATE const char *sqlite3ErrStr(int);
SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);
SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*, u8 enc, const char*, int);
SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);
SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);
SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*, Expr*, const char*);
SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);
SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);
SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);
SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);
SQLITE_PRIVATE int sqlite3AddInt64(i64*, i64);
SQLITE_PRIVATE int sqlite3SubInt64(i64*, i64);
SQLITE_PRIVATE int sqlite3MulInt64(i64*, i64);
SQLITE_PRIVATE int sqlite3AbsInt32(int);
#ifdef SQLITE_ENABLE_8_3_NAMES
SQLITE_PRIVATE void sqlite3FileSuffix3(const char*, char*);
#else
# define sqlite3FileSuffix3(X,Y)
#endif
SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z, u8);

SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8);
SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);
SQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *, u8,
	void(*)(void*));
SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*);
SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);
SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);
SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);
SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);
SQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
#ifndef SQLITE_AMALGAMATION
SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[];
SQLITE_PRIVATE const char sqlite3StrBINARY[];
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];
SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[];
SQLITE_PRIVATE const Token sqlite3IntTokens[];
SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config;
SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;
#ifndef SQLITE_OMIT_WSD
SQLITE_PRIVATE int sqlite3PendingByte;
#endif
#endif
SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, int, int);
SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);
SQLITE_PRIVATE void sqlite3AlterFunctions(void);
SQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);
SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *);
SQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...);
SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*);
SQLITE_PRIVATE int sqlite3CodeSubselect(Parse*, Expr *, int, int);
SQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*);
SQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);
SQLITE_PRIVATE int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);
SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);
SQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*);
SQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
SQLITE_PRIVATE void sqlite3ResolveSelfReference(Parse*, Table*, int, Expr*, ExprList*);
SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int, int);
SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *);
SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *);
SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
SQLITE_PRIVATE char sqlite3AffinityType(const char*, u8*);
SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);
SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*);
SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);
SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);
SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*, int iDB);
SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*, Index*);
SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*);
SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int);
SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*, Expr*, int*, char*);
SQLITE_PRIVATE void sqlite3SchemaClear(void *);
SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *);
SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *);
SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3*, int, int);
SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo*);
SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo*);
SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo*);
#endif
SQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
	void(*)(sqlite3_context*, int, sqlite3_value **),
	void(*)(sqlite3_context*, int, sqlite3_value **), void(*)(sqlite3_context*),
	FuncDestructor *pDestructor
);
SQLITE_PRIVATE void sqlite3OomFault(sqlite3*);
SQLITE_PRIVATE void sqlite3OomClear(sqlite3*);
SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int);
SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *);

SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);
SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*, const char*, int);
SQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum*, const char*);
SQLITE_PRIVATE void sqlite3AppendChar(StrAccum*, int, char);
SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*);
SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum*);
SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*, int, int);
SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);

SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *);
SQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);

#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse*, Expr*);
#else
# define sqlite3ExprCheckIN(x,y) SQLITE_OK
#endif

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void);
SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(
	Parse*, Index*, UnpackedRecord**, Expr*, int, int, int*);
SQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);
SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord*);
SQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);
SQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3*, Index*, int);
#endif


SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(u64));
SQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*));
SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);
#ifdef YYTRACKMAXSTACKDEPTH
SQLITE_PRIVATE   int sqlite3ParserStackPeak(void*);
#endif

SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3*);
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE   void sqlite3CloseExtensions(sqlite3*);
#else
# define sqlite3CloseExtensions(X)
#endif

#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, int, u8, const char *);
#else
#define sqlite3TableLock(v,w,x,y,z)
#endif

#ifdef SQLITE_TEST
SQLITE_PRIVATE   int sqlite3Utf8To8(unsigned char*);
#endif

#ifdef SQLITE_OMIT_VIRTUALTABLE
#  define sqlite3VtabClear(Y)
#  define sqlite3VtabSync(X,Y) SQLITE_OK
#  define sqlite3VtabRollback(X)
#  define sqlite3VtabCommit(X)
#  define sqlite3VtabInSync(db) 0
#  define sqlite3VtabLock(X)
#  define sqlite3VtabUnlock(X)
#  define sqlite3VtabUnlockList(X)
#  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OK
#  define sqlite3GetVTable(X,Y)  ((VTable*)0)
#else
SQLITE_PRIVATE    void sqlite3VtabClear(sqlite3 *db, Table*);
SQLITE_PRIVATE    void sqlite3VtabDisconnect(sqlite3 *db, Table *p);
SQLITE_PRIVATE    int sqlite3VtabSync(sqlite3 *db, Vdbe*);
SQLITE_PRIVATE    int sqlite3VtabRollback(sqlite3 *db);
SQLITE_PRIVATE    int sqlite3VtabCommit(sqlite3 *db);
SQLITE_PRIVATE    void sqlite3VtabLock(VTable *);
SQLITE_PRIVATE    void sqlite3VtabUnlock(VTable *);
SQLITE_PRIVATE    void sqlite3VtabUnlockList(sqlite3*);
SQLITE_PRIVATE    int sqlite3VtabSavepoint(sqlite3 *, int, int);
SQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
SQLITE_PRIVATE    VTable *sqlite3GetVTable(sqlite3*, Table*);
#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)
#endif
SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*, Module*);
SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*, Module*);
SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*, Table*);
SQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);
SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*);
SQLITE_PRIVATE void sqlite3VtabArgInit(Parse*);
SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*);
SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);
SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*);
SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *);
SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, VTable *);
SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *, FuncDef*, int nArg, Expr*);
SQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*, int, sqlite3_value**);
SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);
SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);
SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);
SQLITE_PRIVATE void sqlite3ParserReset(Parse*);
SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);
SQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);
SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);
SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*);
SQLITE_PRIVATE const char *sqlite3JournalModename(int);
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE   int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);
SQLITE_PRIVATE   int sqlite3WalDefaultHook(void*, sqlite3*, const char*, int);
#endif
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE   With *sqlite3WithAdd(Parse*, With*, Token*, ExprList*, Select*);
SQLITE_PRIVATE   void sqlite3WithDelete(sqlite3*, With*);
SQLITE_PRIVATE   void sqlite3WithPush(Parse*, With*, u8);
#else
#define sqlite3WithPush(x,y,z)
#define sqlite3WithDelete(x,y)
#endif


#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE   void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);
SQLITE_PRIVATE   void sqlite3FkDropTable(Parse*, SrcList *, Table*);
SQLITE_PRIVATE   void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);
SQLITE_PRIVATE   int sqlite3FkRequired(Parse*, Table*, int*, int);
SQLITE_PRIVATE   u32 sqlite3FkOldmask(Parse*, Table*);
SQLITE_PRIVATE   FKey *sqlite3FkReferences(Table *);
#else
#define sqlite3FkActions(a,b,c,d,e,f)
#define sqlite3FkCheck(a,b,c,d,e,f)
#define sqlite3FkDropTable(a,b,c)
#define sqlite3FkOldmask(a,b)         0
#define sqlite3FkRequired(a,b,c,d)    0
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE   void sqlite3FkDelete(sqlite3 *, Table*);
SQLITE_PRIVATE   int sqlite3FkLocateIndex(Parse*, Table*, FKey*, Index**, int**);
#else
#define sqlite3FkDelete(a,b)
#define sqlite3FkLocateIndex(a,b,c,d,e)
#endif



#define SQLITE_FAULTINJECTOR_MALLOC     0
#define SQLITE_FAULTINJECTOR_COUNT      1


#ifndef SQLITE_OMIT_BUILTIN_TEST
SQLITE_PRIVATE   void sqlite3BeginBenignMalloc(void);
SQLITE_PRIVATE   void sqlite3EndBenignMalloc(void);
#else
#define sqlite3BeginBenignMalloc()
#define sqlite3EndBenignMalloc()
#endif


#define IN_INDEX_ROWID        1   
#define IN_INDEX_EPH          2   
#define IN_INDEX_INDEX_ASC    3   
#define IN_INDEX_INDEX_DESC   4   
#define IN_INDEX_NOOP         5   

#define IN_INDEX_NOOP_OK     0x0001  
#define IN_INDEX_MEMBERSHIP  0x0002  
#define IN_INDEX_LOOP        0x0004  
SQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*);

SQLITE_PRIVATE int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);
SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *);
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
SQLITE_PRIVATE   int sqlite3JournalCreate(sqlite3_file *);
#endif

SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p);
SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *);

SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);
#if SQLITE_MAX_EXPR_DEPTH>0
SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);
SQLITE_PRIVATE   int sqlite3ExprCheckHeight(Parse*, int);
#else
#define sqlite3SelectExprHeight(x) 0
#define sqlite3ExprCheckHeight(x,y)
#endif

SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*);
SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32);

#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
SQLITE_PRIVATE   void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);
SQLITE_PRIVATE   void sqlite3ConnectionUnlocked(sqlite3 *db);
SQLITE_PRIVATE   void sqlite3ConnectionClosed(sqlite3 *db);
#else
#define sqlite3ConnectionBlocked(x,y)
#define sqlite3ConnectionUnlocked(x)
#define sqlite3ConnectionClosed(x)
#endif

#ifdef SQLITE_DEBUG
SQLITE_PRIVATE   void sqlite3ParserTrace(FILE*, char *);
#endif


#ifdef SQLITE_ENABLE_IOTRACE
# define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }
SQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);
SQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);
#else
# define IOTRACE(A)
# define sqlite3VdbeIOTraceSql(X)
#endif


#ifdef SQLITE_MEMDEBUG
SQLITE_PRIVATE   void sqlite3MemdebugSetType(void*, u8);
SQLITE_PRIVATE   int sqlite3MemdebugHasType(void*, u8);
SQLITE_PRIVATE   int sqlite3MemdebugNoType(void*, u8);
#else
# define sqlite3MemdebugSetType(X,Y)  
# define sqlite3MemdebugHasType(X,Y)  1
# define sqlite3MemdebugNoType(X,Y)   1
#endif
#define MEMTYPE_HEAP       0x01  
#define MEMTYPE_LOOKASIDE  0x02  
#define MEMTYPE_SCRATCH    0x04  
#define MEMTYPE_PCACHE     0x08  


#if SQLITE_MAX_WORKER_THREADS>0
SQLITE_PRIVATE int sqlite3ThreadCreate(SQLiteThread**, void*(*)(void*), void*);
SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread*, void**);
#endif

#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)
SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3*);
#endif

SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr);
SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr);
SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr*, int);
SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*, Expr*, int);

#endif 







SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {
#ifdef SQLITE_ASCII
	0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
	18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
	36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
	54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
	104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
	122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
	108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
	126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
	162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
	180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
	198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
	216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
	234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
	252,253,254,255
#endif
#ifdef SQLITE_EBCDIC
	0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 
	96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, 
	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, 
	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, 
	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, 
	160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, 
	176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, 
	192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, 
	208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, 
	224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, 
	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, 
#endif
};


#ifdef SQLITE_ASCII
SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
	0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
	0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  
	0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  

	0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  
	0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  
	0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  
	0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  

	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  

	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   
};
#endif


#ifndef SQLITE_USE_URI
# define  SQLITE_USE_URI 0
#endif


#ifndef SQLITE_ALLOW_COVERING_INDEX_SCAN
# define SQLITE_ALLOW_COVERING_INDEX_SCAN 1
#endif


#ifndef SQLITE_SORTER_PMASZ
# define SQLITE_SORTER_PMASZ 250
#endif


#ifndef SQLITE_STMTJRNL_SPILL 
# define SQLITE_STMTJRNL_SPILL (64*1024)
#endif


SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {
	SQLITE_DEFAULT_MEMSTATUS,  
	1,                         
	SQLITE_THREADSAFE == 1,      
	SQLITE_USE_URI,            
	SQLITE_ALLOW_COVERING_INDEX_SCAN,   
	0x7ffffffe,                
	0,                         
	128,                       
	500,                       
	SQLITE_STMTJRNL_SPILL,     
	{ 0,0,0,0,0,0,0,0 },         
	{ 0,0,0,0,0,0,0,0,0 },       
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0 },
	(void*)0,                  
	0,                         
	0, 0,                      
	SQLITE_DEFAULT_MMAP_SIZE,  
	SQLITE_MAX_MMAP_SIZE,      
	(void*)0,                  
	0,                         
	0,                         
	(void*)0,                  
	0,                         
	SQLITE_DEFAULT_PCACHE_INITSZ, 
	0,                         
	0,                         
	SQLITE_SORTER_PMASZ,       
							   
							   0,                         
							   0,                         
							   0,                         
							   0,                         
							   0,                         
							   0,                         
							   0,                         
							   0,                         
							   0,                         
#ifdef SQLITE_ENABLE_SQLLOG
							   0,                         
							   0,                         
#endif
#ifdef SQLITE_VDBE_COVERAGE
							   0,                         
							   0,                         
#endif
#ifndef SQLITE_OMIT_BUILTIN_TEST
							   0,                         
#endif
							   0,                         
							   0x7ffffffe                 
};


SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;


SQLITE_PRIVATE const Token sqlite3IntTokens[] = {
	{ "0", 1 },
	{ "1", 1 }
};



#ifndef SQLITE_OMIT_WSD
SQLITE_PRIVATE int sqlite3PendingByte = 0x40000000;
#endif



SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;


SQLITE_PRIVATE const char sqlite3StrBINARY[] = "BINARY";





#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS




static const char * const azCompileOpt[] = {

	
#define CTIMEOPT_VAL_(opt) #opt
#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)

#if SQLITE_32BIT_ROWID
	"32BIT_ROWID",
#endif
#if SQLITE_4_BYTE_ALIGNED_MALLOC
	"4_BYTE_ALIGNED_MALLOC",
#endif
#if SQLITE_CASE_SENSITIVE_LIKE
	"CASE_SENSITIVE_LIKE",
#endif
#if SQLITE_CHECK_PAGES
	"CHECK_PAGES",
#endif
#if defined(__clang__) && defined(__clang_major__)
	"COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."
	CTIMEOPT_VAL(__clang_minor__) "."
	CTIMEOPT_VAL(__clang_patchlevel__),
#elif defined(_MSC_VER)
	"COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),
#elif defined(__GNUC__) && defined(__VERSION__)
	"COMPILER=gcc-" __VERSION__,
#endif
#if SQLITE_COVERAGE_TEST
	"COVERAGE_TEST",
#endif
#if SQLITE_DEBUG
	"DEBUG",
#endif
#if SQLITE_DEFAULT_LOCKING_MODE
	"DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),
#endif
#if defined(SQLITE_DEFAULT_MMAP_SIZE) && !defined(SQLITE_DEFAULT_MMAP_SIZE_xc)
	"DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),
#endif
#if SQLITE_DISABLE_DIRSYNC
	"DISABLE_DIRSYNC",
#endif
#if SQLITE_DISABLE_LFS
	"DISABLE_LFS",
#endif
#if SQLITE_ENABLE_8_3_NAMES
	"ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),
#endif
#if SQLITE_ENABLE_API_ARMOR
	"ENABLE_API_ARMOR",
#endif
#if SQLITE_ENABLE_ATOMIC_WRITE
	"ENABLE_ATOMIC_WRITE",
#endif
#if SQLITE_ENABLE_CEROD
	"ENABLE_CEROD",
#endif
#if SQLITE_ENABLE_COLUMN_METADATA
	"ENABLE_COLUMN_METADATA",
#endif
#if SQLITE_ENABLE_DBSTAT_VTAB
	"ENABLE_DBSTAT_VTAB",
#endif
#if SQLITE_ENABLE_EXPENSIVE_ASSERT
	"ENABLE_EXPENSIVE_ASSERT",
#endif
#if SQLITE_ENABLE_FTS1
	"ENABLE_FTS1",
#endif
#if SQLITE_ENABLE_FTS2
	"ENABLE_FTS2",
#endif
#if SQLITE_ENABLE_FTS3
	"ENABLE_FTS3",
#endif
#if SQLITE_ENABLE_FTS3_PARENTHESIS
	"ENABLE_FTS3_PARENTHESIS",
#endif
#if SQLITE_ENABLE_FTS4
	"ENABLE_FTS4",
#endif
#if SQLITE_ENABLE_FTS5
	"ENABLE_FTS5",
#endif
#if SQLITE_ENABLE_ICU
	"ENABLE_ICU",
#endif
#if SQLITE_ENABLE_IOTRACE
	"ENABLE_IOTRACE",
#endif
#if SQLITE_ENABLE_JSON1
	"ENABLE_JSON1",
#endif
#if SQLITE_ENABLE_LOAD_EXTENSION
	"ENABLE_LOAD_EXTENSION",
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
	"ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),
#endif
#if SQLITE_ENABLE_MEMORY_MANAGEMENT
	"ENABLE_MEMORY_MANAGEMENT",
#endif
#if SQLITE_ENABLE_MEMSYS3
	"ENABLE_MEMSYS3",
#endif
#if SQLITE_ENABLE_MEMSYS5
	"ENABLE_MEMSYS5",
#endif
#if SQLITE_ENABLE_OVERSIZE_CELL_CHECK
	"ENABLE_OVERSIZE_CELL_CHECK",
#endif
#if SQLITE_ENABLE_RTREE
	"ENABLE_RTREE",
#endif
#if defined(SQLITE_ENABLE_STAT4)
	"ENABLE_STAT4",
#elif defined(SQLITE_ENABLE_STAT3)
	"ENABLE_STAT3",
#endif
#if SQLITE_ENABLE_UNLOCK_NOTIFY
	"ENABLE_UNLOCK_NOTIFY",
#endif
#if SQLITE_ENABLE_UPDATE_DELETE_LIMIT
	"ENABLE_UPDATE_DELETE_LIMIT",
#endif
#if SQLITE_HAS_CODEC
	"HAS_CODEC",
#endif
#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
	"HAVE_ISNAN",
#endif
#if SQLITE_HOMEGROWN_RECURSIVE_MUTEX
	"HOMEGROWN_RECURSIVE_MUTEX",
#endif
#if SQLITE_IGNORE_AFP_LOCK_ERRORS
	"IGNORE_AFP_LOCK_ERRORS",
#endif
#if SQLITE_IGNORE_FLOCK_LOCK_ERRORS
	"IGNORE_FLOCK_LOCK_ERRORS",
#endif
#ifdef SQLITE_INT64_TYPE
	"INT64_TYPE",
#endif
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
	"LIKE_DOESNT_MATCH_BLOBS",
#endif
#if SQLITE_LOCK_TRACE
	"LOCK_TRACE",
#endif
#if defined(SQLITE_MAX_MMAP_SIZE) && !defined(SQLITE_MAX_MMAP_SIZE_xc)
	"MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),
#endif
#ifdef SQLITE_MAX_SCHEMA_RETRY
	"MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),
#endif
#if SQLITE_MEMDEBUG
	"MEMDEBUG",
#endif
#if SQLITE_MIXED_ENDIAN_64BIT_FLOAT
	"MIXED_ENDIAN_64BIT_FLOAT",
#endif
#if SQLITE_NO_SYNC
	"NO_SYNC",
#endif
#if SQLITE_OMIT_ALTERTABLE
	"OMIT_ALTERTABLE",
#endif
#if SQLITE_OMIT_ANALYZE
	"OMIT_ANALYZE",
#endif
#if SQLITE_OMIT_ATTACH
	"OMIT_ATTACH",
#endif
#if SQLITE_OMIT_AUTHORIZATION
	"OMIT_AUTHORIZATION",
#endif
#if SQLITE_OMIT_AUTOINCREMENT
	"OMIT_AUTOINCREMENT",
#endif
#if SQLITE_OMIT_AUTOINIT
	"OMIT_AUTOINIT",
#endif
#if SQLITE_OMIT_AUTOMATIC_INDEX
	"OMIT_AUTOMATIC_INDEX",
#endif
#if SQLITE_OMIT_AUTORESET
	"OMIT_AUTORESET",
#endif
#if SQLITE_OMIT_AUTOVACUUM
	"OMIT_AUTOVACUUM",
#endif
#if SQLITE_OMIT_BETWEEN_OPTIMIZATION
	"OMIT_BETWEEN_OPTIMIZATION",
#endif
#if SQLITE_OMIT_BLOB_LITERAL
	"OMIT_BLOB_LITERAL",
#endif
#if SQLITE_OMIT_BTREECOUNT
	"OMIT_BTREECOUNT",
#endif
#if SQLITE_OMIT_BUILTIN_TEST
	"OMIT_BUILTIN_TEST",
#endif
#if SQLITE_OMIT_CAST
	"OMIT_CAST",
#endif
#if SQLITE_OMIT_CHECK
	"OMIT_CHECK",
#endif
#if SQLITE_OMIT_COMPLETE
	"OMIT_COMPLETE",
#endif
#if SQLITE_OMIT_COMPOUND_SELECT
	"OMIT_COMPOUND_SELECT",
#endif
#if SQLITE_OMIT_CTE
	"OMIT_CTE",
#endif
#if SQLITE_OMIT_DATETIME_FUNCS
	"OMIT_DATETIME_FUNCS",
#endif
#if SQLITE_OMIT_DECLTYPE
	"OMIT_DECLTYPE",
#endif
#if SQLITE_OMIT_DEPRECATED
	"OMIT_DEPRECATED",
#endif
#if SQLITE_OMIT_DISKIO
	"OMIT_DISKIO",
#endif
#if SQLITE_OMIT_EXPLAIN
	"OMIT_EXPLAIN",
#endif
#if SQLITE_OMIT_FLAG_PRAGMAS
	"OMIT_FLAG_PRAGMAS",
#endif
#if SQLITE_OMIT_FLOATING_POINT
	"OMIT_FLOATING_POINT",
#endif
#if SQLITE_OMIT_FOREIGN_KEY
	"OMIT_FOREIGN_KEY",
#endif
#if SQLITE_OMIT_GET_TABLE
	"OMIT_GET_TABLE",
#endif
#if SQLITE_OMIT_INCRBLOB
	"OMIT_INCRBLOB",
#endif
#if SQLITE_OMIT_INTEGRITY_CHECK
	"OMIT_INTEGRITY_CHECK",
#endif
#if SQLITE_OMIT_LIKE_OPTIMIZATION
	"OMIT_LIKE_OPTIMIZATION",
#endif
#if SQLITE_OMIT_LOAD_EXTENSION
	"OMIT_LOAD_EXTENSION",
#endif
#if SQLITE_OMIT_LOCALTIME
	"OMIT_LOCALTIME",
#endif
#if SQLITE_OMIT_LOOKASIDE
	"OMIT_LOOKASIDE",
#endif
#if SQLITE_OMIT_MEMORYDB
	"OMIT_MEMORYDB",
#endif
#if SQLITE_OMIT_OR_OPTIMIZATION
	"OMIT_OR_OPTIMIZATION",
#endif
#if SQLITE_OMIT_PAGER_PRAGMAS
	"OMIT_PAGER_PRAGMAS",
#endif
#if SQLITE_OMIT_PRAGMA
	"OMIT_PRAGMA",
#endif
#if SQLITE_OMIT_PROGRESS_CALLBACK
	"OMIT_PROGRESS_CALLBACK",
#endif
#if SQLITE_OMIT_QUICKBALANCE
	"OMIT_QUICKBALANCE",
#endif
#if SQLITE_OMIT_REINDEX
	"OMIT_REINDEX",
#endif
#if SQLITE_OMIT_SCHEMA_PRAGMAS
	"OMIT_SCHEMA_PRAGMAS",
#endif
#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
	"OMIT_SCHEMA_VERSION_PRAGMAS",
#endif
#if SQLITE_OMIT_SHARED_CACHE
	"OMIT_SHARED_CACHE",
#endif
#if SQLITE_OMIT_SUBQUERY
	"OMIT_SUBQUERY",
#endif
#if SQLITE_OMIT_TCL_VARIABLE
	"OMIT_TCL_VARIABLE",
#endif
#if SQLITE_OMIT_TEMPDB
	"OMIT_TEMPDB",
#endif
#if SQLITE_OMIT_TRACE
	"OMIT_TRACE",
#endif
#if SQLITE_OMIT_TRIGGER
	"OMIT_TRIGGER",
#endif
#if SQLITE_OMIT_TRUNCATE_OPTIMIZATION
	"OMIT_TRUNCATE_OPTIMIZATION",
#endif
#if SQLITE_OMIT_UTF16
	"OMIT_UTF16",
#endif
#if SQLITE_OMIT_VACUUM
	"OMIT_VACUUM",
#endif
#if SQLITE_OMIT_VIEW
	"OMIT_VIEW",
#endif
#if SQLITE_OMIT_VIRTUALTABLE
	"OMIT_VIRTUALTABLE",
#endif
#if SQLITE_OMIT_WAL
	"OMIT_WAL",
#endif
#if SQLITE_OMIT_WSD
	"OMIT_WSD",
#endif
#if SQLITE_OMIT_XFER_OPT
	"OMIT_XFER_OPT",
#endif
#if SQLITE_PERFORMANCE_TRACE
	"PERFORMANCE_TRACE",
#endif
#if SQLITE_PROXY_DEBUG
	"PROXY_DEBUG",
#endif
#if SQLITE_RTREE_INT_ONLY
	"RTREE_INT_ONLY",
#endif
#if SQLITE_SECURE_DELETE
	"SECURE_DELETE",
#endif
#if SQLITE_SMALL_STACK
	"SMALL_STACK",
#endif
#if SQLITE_SOUNDEX
	"SOUNDEX",
#endif
#if SQLITE_SYSTEM_MALLOC
	"SYSTEM_MALLOC",
#endif
#if SQLITE_TCL
	"TCL",
#endif
#if defined(SQLITE_TEMP_STORE) && !defined(SQLITE_TEMP_STORE_xc)
	"TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),
#endif
#if SQLITE_TEST
	"TEST",
#endif
#if defined(SQLITE_THREADSAFE)
	"THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),
#endif
#if SQLITE_USE_ALLOCA
	"USE_ALLOCA",
#endif
#if SQLITE_USER_AUTHENTICATION
	"USER_AUTHENTICATION",
#endif
#if SQLITE_WIN32_MALLOC
	"WIN32_MALLOC",
#endif
#if SQLITE_ZERO_MALLOC
	"ZERO_MALLOC"
#endif
};


SQLITE_API int sqlite3_compileoption_used(const char *zOptName) {
	int i, n;

#if SQLITE_ENABLE_API_ARMOR
	if (zOptName == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	if (sqlite3StrNICmp(zOptName, "SQLITE_", 7) == 0) zOptName += 7;
	n = sqlite3Strlen30(zOptName);

	
	for (i = 0; i<ArraySize(azCompileOpt); i++) {
		if (sqlite3StrNICmp(zOptName, azCompileOpt[i], n) == 0
			&& sqlite3IsIdChar((unsigned char)azCompileOpt[i][n]) == 0
			) {
			return 1;
		}
	}
	return 0;
}


SQLITE_API const char *sqlite3_compileoption_get(int N) {
	if (N >= 0 && N<ArraySize(azCompileOpt)) {
		return azCompileOpt[N];
	}
	return 0;
}

#endif 








#ifndef SQLITE_VDBEINT_H
#define SQLITE_VDBEINT_H


#ifndef SQLITE_MAX_SCHEMA_RETRY
# define SQLITE_MAX_SCHEMA_RETRY 50
#endif


#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \
     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)
# define VDBE_DISPLAY_P4 1
#else
# define VDBE_DISPLAY_P4 0
#endif


typedef struct VdbeOp Op;


typedef unsigned Bool;


typedef struct VdbeSorter VdbeSorter;


typedef struct AuxData AuxData;


#define CURTYPE_BTREE       0
#define CURTYPE_SORTER      1
#define CURTYPE_VTAB        2
#define CURTYPE_PSEUDO      3


typedef struct VdbeCursor VdbeCursor;
struct VdbeCursor {
	u8 eCurType;          
	i8 iDb;               
	u8 nullRow;           
	u8 deferredMoveto;    
	u8 isTable;           
#ifdef SQLITE_DEBUG
	u8 seekOp;            
	u8 wrFlag;            
#endif
	Bool isEphemeral : 1;   
	Bool useRandomRowid : 1;
	Bool isOrdered : 1;     
	Pgno pgnoRoot;        
	i16 nField;           
	u16 nHdrParsed;       
	union {
		BtCursor *pCursor;          
		sqlite3_vtab_cursor *pVCur; 
		int pseudoTableReg;         
		VdbeSorter *pSorter;        
	} uc;
	Btree *pBt;           
	KeyInfo *pKeyInfo;    
	int seekResult;       
	i64 seqCount;         
	i64 movetoTarget;     
	VdbeCursor *pAltCursor; 
	int *aAltMap;           
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
	u64 maskUsed;         
#endif

						  
	u32 cacheStatus;      
	u32 payloadSize;      
	u32 szRow;            
	u32 iHdrOffset;       
	const u8 *aRow;       
	u32 *aOffset;         
	u32 aType[1];         
						  
};



#define CACHE_STALE 0


typedef struct VdbeFrame VdbeFrame;
struct VdbeFrame {
	Vdbe *v;                
	VdbeFrame *pParent;     
	Op *aOp;                
	i64 *anExec;            
	Mem *aMem;              
	VdbeCursor **apCsr;     
	void *token;            
	i64 lastRowid;          
	AuxData *pAuxData;      
	int nCursor;            
	int pc;                 
	int nOp;                
	int nMem;               
	int nChildMem;          
	int nChildCsr;          
	int nChange;            
	int nDbChange;          
};

#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])


struct Mem {
	union MemValue {
		double r;           
		i64 i;              
		int nZero;          
		FuncDef *pDef;      
		RowSet *pRowSet;    
		VdbeFrame *pFrame;  
	} u;
	u16 flags;          
	u8  enc;            
	u8  eSubtype;       
	int n;              
	char *z;            
						
	char *zMalloc;      
	int szMalloc;       
	u32 uTemp;          
	sqlite3 *db;        
	void(*xDel)(void*);
#ifdef SQLITE_DEBUG
	Mem *pScopyFrom;    
	void *pFiller;      
#endif
};


#define MEMCELLSIZE offsetof(Mem,zMalloc)


#define MEM_Null      0x0001   
#define MEM_Str       0x0002   
#define MEM_Int       0x0004   
#define MEM_Real      0x0008   
#define MEM_Blob      0x0010   
#define MEM_AffMask   0x001f   
#define MEM_RowSet    0x0020   
#define MEM_Frame     0x0040   
#define MEM_Undefined 0x0080   
#define MEM_Cleared   0x0100   
#define MEM_TypeMask  0x81ff   



#define MEM_Term      0x0200   
#define MEM_Dyn       0x0400   
#define MEM_Static    0x0800   
#define MEM_Ephem     0x1000   
#define MEM_Agg       0x2000   
#define MEM_Zero      0x4000   
#define MEM_Subtype   0x8000   
#ifdef SQLITE_OMIT_INCRBLOB
#undef MEM_Zero
#define MEM_Zero 0x0000
#endif


#define VdbeMemDynamic(X)  \
  (((X)->flags&(MEM_Agg|MEM_Dyn|MEM_RowSet|MEM_Frame))!=0)


#define MemSetTypeFlag(p, f) \
   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)


#ifdef SQLITE_DEBUG
#define memIsValid(M)  ((M)->flags & MEM_Undefined)==0
#endif


struct AuxData {
	int iOp;                        
	int iArg;                       
	void *pAux;                     
	void(*xDelete)(void *);        
	AuxData *pNext;                 
};


struct sqlite3_context {
	Mem *pOut;              
	FuncDef *pFunc;         
	Mem *pMem;              
	Vdbe *pVdbe;            
	int iOp;                
	int isError;            
	u8 skipFlag;            
	u8 fErrorOrAux;         
	u8 argc;                
	sqlite3_value *argv[1]; 
};


typedef unsigned bft;  

typedef struct ScanStatus ScanStatus;
struct ScanStatus {
	int addrExplain;                
	int addrLoop;                   
	int addrVisit;                  
	int iSelectID;                  
	LogEst nEst;                    
	char *zName;                    
};


struct Vdbe {
	sqlite3 *db;            
	Vdbe *pPrev, *pNext;     
	Parse *pParse;          
	ynVar nVar;             
	ynVar nzVar;            
	u32 magic;              
	int nMem;               
	int nCursor;            
	u32 cacheCtr;           
	int pc;                 
	int rc;                 
	int nChange;            
	int iStatement;         
	i64 iCurrentTime;       
	i64 nFkConstraint;      
	i64 nStmtDefCons;       
	i64 nStmtDefImmCons;    

							

	Op *aOp;                
	Mem *aMem;              
	Mem **apArg;            
	Mem *aColName;          
	Mem *pResultSet;        
	char *zErrMsg;          
	VdbeCursor **apCsr;     
	Mem *aVar;              
	char **azVar;           
#ifndef SQLITE_OMIT_TRACE
	i64 startTime;          
#endif
	int nOp;                
#ifdef SQLITE_DEBUG
	int rcApp;              
#endif
	u16 nResColumn;         
	u8 errorAction;         
	u8 minWriteFileFormat;  
	bft expired : 1;          
	bft doingRerun : 1;       
	bft explain : 2;          
	bft changeCntOn : 1;      
	bft runOnlyOnce : 1;      
	bft usesStmtJournal : 1;  
	bft readOnly : 1;         
	bft bIsReader : 1;        
	bft isPrepareV2 : 1;      
	yDbMask btreeMask;      
	yDbMask lockMask;       
	u32 aCounter[5];        
	char *zSql;             
	void *pFree;            
	VdbeFrame *pFrame;      
	VdbeFrame *pDelFrame;   
	int nFrame;             
	u32 expmask;            
	SubProgram *pProgram;   
	AuxData *pAuxData;      
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
	i64 *anExec;            
	int nScan;              
	ScanStatus *aScan;      
#endif
};


#define VDBE_MAGIC_INIT     0x16bceaa5    
#define VDBE_MAGIC_RUN      0x2df20da3    
#define VDBE_MAGIC_HALT     0x319c2973    
#define VDBE_MAGIC_RESET    0x48fa9f76    
#define VDBE_MAGIC_DEAD     0x5606c3c8    


struct PreUpdate {
	Vdbe *v;
	VdbeCursor *pCsr;               
	int op;                         
	u8 *aRecord;                    
	KeyInfo keyinfo;
	UnpackedRecord *pUnpacked;      
	UnpackedRecord *pNewUnpacked;   
	int iNewReg;                    
	i64 iKey1;                      
	i64 iKey2;                      
	Mem *aNew;                      
	Table *pTab;                    
};


SQLITE_PRIVATE void sqlite3VdbeError(Vdbe*, const char *, ...);
SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);
void sqliteVdbePopStack(Vdbe*, int);
SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);
SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor*);
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, Op*);
#endif
SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32);
SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8);
SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int, u32*);
SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32);
SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);
SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);

int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(sqlite3*, VdbeCursor*, UnpackedRecord*, int*);
SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);
SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);
SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);
SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*);
SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int);
SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*);
SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);
SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));
SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);
#ifdef SQLITE_OMIT_FLOATING_POINT
# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64
#else
SQLITE_PRIVATE   void sqlite3VdbeMemSetDouble(Mem*, double);
#endif
SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem*, sqlite3*, u16);
SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);
SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*, int);
SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, u8, u8);
SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*);
SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*);
SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);
SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);
SQLITE_PRIVATE void sqlite3VdbeMemCast(Mem*, u8, u8);
SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*, u32, u32, int, Mem*);
SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p);
SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);
SQLITE_PRIVATE const char *sqlite3OpcodeName(int);
SQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);
SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);
SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);
SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame*);
SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(Vdbe*, VdbeCursor*, int, const char*, Table*, i64, int);
#endif
SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p);

SQLITE_PRIVATE int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);
SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);
SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);
SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);
SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *, int *);
SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);
SQLITE_PRIVATE int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);
SQLITE_PRIVATE int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);

#if !defined(SQLITE_OMIT_SHARED_CACHE) 
SQLITE_PRIVATE   void sqlite3VdbeEnter(Vdbe*);
#else
# define sqlite3VdbeEnter(X)
#endif

#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0
SQLITE_PRIVATE   void sqlite3VdbeLeave(Vdbe*);
#else
# define sqlite3VdbeLeave(X)
#endif

#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe*, Mem*);
SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem*);
#endif

#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);
#else
# define sqlite3VdbeCheckFk(p,i) 0
#endif

SQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem*, u8);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE   void sqlite3VdbePrintSql(Vdbe*);
SQLITE_PRIVATE   void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf);
#endif
SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem);

#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);
#define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
#else
#define sqlite3VdbeMemExpandBlob(x) SQLITE_OK
#define ExpandBlob(P) SQLITE_OK
#endif

#endif 





#if SQLITE_PTRSIZE>4
typedef sqlite3_int64 sqlite3StatValueType;
#else
typedef u32 sqlite3StatValueType;
#endif
typedef struct sqlite3StatType sqlite3StatType;
static SQLITE_WSD struct sqlite3StatType {
	sqlite3StatValueType nowValue[10];  
	sqlite3StatValueType mxValue[10];   
} sqlite3Stat = { { 0, },{ 0, } };


static const char statMutex[] = {
	0,  
	1,  
	1,  
	0,  
	0,  
	0,  
	0,  
	1,  
	0,  
	0,  
};



#ifdef SQLITE_OMIT_WSD
# define wsdStatInit  sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat)
# define wsdStat x[0]
#else
# define wsdStatInit
# define wsdStat sqlite3Stat
#endif


SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int op) {
	wsdStatInit;
	assert(op >= 0 && op<ArraySize(wsdStat.nowValue));
	assert(op >= 0 && op<ArraySize(statMutex));
	assert(sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
		: sqlite3MallocMutex()));
	return wsdStat.nowValue[op];
}


SQLITE_PRIVATE void sqlite3StatusUp(int op, int N) {
	wsdStatInit;
	assert(op >= 0 && op<ArraySize(wsdStat.nowValue));
	assert(op >= 0 && op<ArraySize(statMutex));
	assert(sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
		: sqlite3MallocMutex()));
	wsdStat.nowValue[op] += N;
	if (wsdStat.nowValue[op]>wsdStat.mxValue[op]) {
		wsdStat.mxValue[op] = wsdStat.nowValue[op];
	}
}
SQLITE_PRIVATE void sqlite3StatusDown(int op, int N) {
	wsdStatInit;
	assert(N >= 0);
	assert(op >= 0 && op<ArraySize(statMutex));
	assert(sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
		: sqlite3MallocMutex()));
	assert(op >= 0 && op<ArraySize(wsdStat.nowValue));
	wsdStat.nowValue[op] -= N;
}


SQLITE_PRIVATE void sqlite3StatusHighwater(int op, int X) {
	sqlite3StatValueType newValue;
	wsdStatInit;
	assert(X >= 0);
	newValue = (sqlite3StatValueType)X;
	assert(op >= 0 && op<ArraySize(wsdStat.nowValue));
	assert(op >= 0 && op<ArraySize(statMutex));
	assert(sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
		: sqlite3MallocMutex()));
	assert(op == SQLITE_STATUS_MALLOC_SIZE
		|| op == SQLITE_STATUS_PAGECACHE_SIZE
		|| op == SQLITE_STATUS_SCRATCH_SIZE
		|| op == SQLITE_STATUS_PARSER_STACK);
	if (newValue>wsdStat.mxValue[op]) {
		wsdStat.mxValue[op] = newValue;
	}
}


SQLITE_API int sqlite3_status64(
	int op,
	sqlite3_int64 *pCurrent,
	sqlite3_int64 *pHighwater,
	int resetFlag
) {
	sqlite3_mutex *pMutex;
	wsdStatInit;
	if (op<0 || op >= ArraySize(wsdStat.nowValue)) {
		return SQLITE_MISUSE_BKPT;
	}
#ifdef SQLITE_ENABLE_API_ARMOR
	if (pCurrent == 0 || pHighwater == 0) return SQLITE_MISUSE_BKPT;
#endif
	pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
	sqlite3_mutex_enter(pMutex);
	*pCurrent = wsdStat.nowValue[op];
	*pHighwater = wsdStat.mxValue[op];
	if (resetFlag) {
		wsdStat.mxValue[op] = wsdStat.nowValue[op];
	}
	sqlite3_mutex_leave(pMutex);
	(void)pMutex;  
	return SQLITE_OK;
}
SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag) {
	sqlite3_int64 iCur = 0, iHwtr = 0;
	int rc;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (pCurrent == 0 || pHighwater == 0) return SQLITE_MISUSE_BKPT;
#endif
	rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);
	if (rc == 0) {
		*pCurrent = (int)iCur;
		*pHighwater = (int)iHwtr;
	}
	return rc;
}


SQLITE_API int sqlite3_db_status(
	sqlite3 *db,          
	int op,               
	int *pCurrent,        
	int *pHighwater,      
	int resetFlag         
) {
	int rc = SQLITE_OK;   
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || pCurrent == 0 || pHighwater == 0) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	switch (op) {
	case SQLITE_DBSTATUS_LOOKASIDE_USED: {
		*pCurrent = db->lookaside.nOut;
		*pHighwater = db->lookaside.mxOut;
		if (resetFlag) {
			db->lookaside.mxOut = db->lookaside.nOut;
		}
		break;
	}

	case SQLITE_DBSTATUS_LOOKASIDE_HIT:
	case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:
	case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {
		testcase(op == SQLITE_DBSTATUS_LOOKASIDE_HIT);
		testcase(op == SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE);
		testcase(op == SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL);
		assert((op - SQLITE_DBSTATUS_LOOKASIDE_HIT) >= 0);
		assert((op - SQLITE_DBSTATUS_LOOKASIDE_HIT)<3);
		*pCurrent = 0;
		*pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];
		if (resetFlag) {
			db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;
		}
		break;
	}

											  
	case SQLITE_DBSTATUS_CACHE_USED_SHARED:
	case SQLITE_DBSTATUS_CACHE_USED: {
		int totalUsed = 0;
		int i;
		sqlite3BtreeEnterAll(db);
		for (i = 0; i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				Pager *pPager = sqlite3BtreePager(pBt);
				int nByte = sqlite3PagerMemUsed(pPager);
				if (op == SQLITE_DBSTATUS_CACHE_USED_SHARED) {
					nByte = nByte / sqlite3BtreeConnectionCount(pBt);
				}
				totalUsed += nByte;
			}
		}
		sqlite3BtreeLeaveAll(db);
		*pCurrent = totalUsed;
		*pHighwater = 0;
		break;
	}

									 
	case SQLITE_DBSTATUS_SCHEMA_USED: {
		int i;                      
		int nByte = 0;              

		sqlite3BtreeEnterAll(db);
		db->pnBytesFreed = &nByte;
		for (i = 0; i<db->nDb; i++) {
			Schema *pSchema = db->aDb[i].pSchema;
			if (ALWAYS(pSchema != 0)) {
				HashElem *p;

				nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (
					pSchema->tblHash.count
					+ pSchema->trigHash.count
					+ pSchema->idxHash.count
					+ pSchema->fkeyHash.count
					);
				nByte += sqlite3_msize(pSchema->tblHash.ht);
				nByte += sqlite3_msize(pSchema->trigHash.ht);
				nByte += sqlite3_msize(pSchema->idxHash.ht);
				nByte += sqlite3_msize(pSchema->fkeyHash.ht);

				for (p = sqliteHashFirst(&pSchema->trigHash); p; p = sqliteHashNext(p)) {
					sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));
				}
				for (p = sqliteHashFirst(&pSchema->tblHash); p; p = sqliteHashNext(p)) {
					sqlite3DeleteTable(db, (Table *)sqliteHashData(p));
				}
			}
		}
		db->pnBytesFreed = 0;
		sqlite3BtreeLeaveAll(db);

		*pHighwater = 0;
		*pCurrent = nByte;
		break;
	}

									  
	case SQLITE_DBSTATUS_STMT_USED: {
		struct Vdbe *pVdbe;         
		int nByte = 0;              

		db->pnBytesFreed = &nByte;
		for (pVdbe = db->pVdbe; pVdbe; pVdbe = pVdbe->pNext) {
			sqlite3VdbeClearObject(db, pVdbe);
			sqlite3DbFree(db, pVdbe);
		}
		db->pnBytesFreed = 0;

		*pHighwater = 0;  
		*pCurrent = nByte;

		break;
	}

									
	case SQLITE_DBSTATUS_CACHE_HIT:
	case SQLITE_DBSTATUS_CACHE_MISS:
	case SQLITE_DBSTATUS_CACHE_WRITE: {
		int i;
		int nRet = 0;
		assert(SQLITE_DBSTATUS_CACHE_MISS == SQLITE_DBSTATUS_CACHE_HIT + 1);
		assert(SQLITE_DBSTATUS_CACHE_WRITE == SQLITE_DBSTATUS_CACHE_HIT + 2);

		for (i = 0; i<db->nDb; i++) {
			if (db->aDb[i].pBt) {
				Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);
				sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);
			}
		}
		*pHighwater = 0; 
						 
						 
		*pCurrent = nRet;
		break;
	}

									  
	case SQLITE_DBSTATUS_DEFERRED_FKS: {
		*pHighwater = 0;  
		*pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;
		break;
	}

	default: {
		rc = SQLITE_ERROR;
	}
	}
	sqlite3_mutex_leave(db->mutex);
	return rc;
}







#include <time.h>

#ifndef SQLITE_OMIT_DATETIME_FUNCS


#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \
    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)
struct tm *__cdecl localtime(const time_t *);
#endif


typedef struct DateTime DateTime;
struct DateTime {
	sqlite3_int64 iJD; 
	int Y, M, D;       
	int h, m;          
	int tz;            
	double s;          
	char validYMD;     
	char validHMS;     
	char validJD;      
	char validTZ;      
	char tzSet;        
};



static int getDigits(const char *zDate, const char *zFormat, ...) {
	
	static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };
	va_list ap;
	int cnt = 0;
	char nextC;
	va_start(ap, zFormat);
	do {
		char N = zFormat[0] - '0';
		char min = zFormat[1] - '0';
		int val = 0;
		u16 max;

		assert(zFormat[2] >= 'a' && zFormat[2] <= 'f');
		max = aMx[zFormat[2] - 'a'];
		nextC = zFormat[3];
		val = 0;
		while (N--) {
			if (!sqlite3Isdigit(*zDate)) {
				goto end_getDigits;
			}
			val = val * 10 + *zDate - '0';
			zDate++;
		}
		if (val<(int)min || val>(int)max || (nextC != 0 && nextC != *zDate)) {
			goto end_getDigits;
		}
		*va_arg(ap, int*) = val;
		zDate++;
		cnt++;
		zFormat += 4;
	} while (nextC);
end_getDigits:
	va_end(ap);
	return cnt;
}


static int parseTimezone(const char *zDate, DateTime *p) {
	int sgn = 0;
	int nHr, nMn;
	int c;
	while (sqlite3Isspace(*zDate)) { zDate++; }
	p->tz = 0;
	c = *zDate;
	if (c == '-') {
		sgn = -1;
	}
	else if (c == '+') {
		sgn = +1;
	}
	else if (c == 'Z' || c == 'z') {
		zDate++;
		goto zulu_time;
	}
	else {
		return c != 0;
	}
	zDate++;
	if (getDigits(zDate, "20b:20e", &nHr, &nMn) != 2) {
		return 1;
	}
	zDate += 5;
	p->tz = sgn*(nMn + nHr * 60);
zulu_time:
	while (sqlite3Isspace(*zDate)) { zDate++; }
	p->tzSet = 1;
	return *zDate != 0;
}


static int parseHhMmSs(const char *zDate, DateTime *p) {
	int h, m, s;
	double ms = 0.0;
	if (getDigits(zDate, "20c:20e", &h, &m) != 2) {
		return 1;
	}
	zDate += 5;
	if (*zDate == ':') {
		zDate++;
		if (getDigits(zDate, "20e", &s) != 1) {
			return 1;
		}
		zDate += 2;
		if (*zDate == '.' && sqlite3Isdigit(zDate[1])) {
			double rScale = 1.0;
			zDate++;
			while (sqlite3Isdigit(*zDate)) {
				ms = ms*10.0 + *zDate - '0';
				rScale *= 10.0;
				zDate++;
			}
			ms /= rScale;
		}
	}
	else {
		s = 0;
	}
	p->validJD = 0;
	p->validHMS = 1;
	p->h = h;
	p->m = m;
	p->s = s + ms;
	if (parseTimezone(zDate, p)) return 1;
	p->validTZ = (p->tz != 0) ? 1 : 0;
	return 0;
}


static void computeJD(DateTime *p) {
	int Y, M, D, A, B, X1, X2;

	if (p->validJD) return;
	if (p->validYMD) {
		Y = p->Y;
		M = p->M;
		D = p->D;
	}
	else {
		Y = 2000;  
		M = 1;
		D = 1;
	}
	if (M <= 2) {
		Y--;
		M += 12;
	}
	A = Y / 100;
	B = 2 - A + (A / 4);
	X1 = 36525 * (Y + 4716) / 100;
	X2 = 306001 * (M + 1) / 10000;
	p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5) * 86400000);
	p->validJD = 1;
	if (p->validHMS) {
		p->iJD += p->h * 3600000 + p->m * 60000 + (sqlite3_int64)(p->s * 1000);
		if (p->validTZ) {
			p->iJD -= p->tz * 60000;
			p->validYMD = 0;
			p->validHMS = 0;
			p->validTZ = 0;
		}
	}
}


static int parseYyyyMmDd(const char *zDate, DateTime *p) {
	int Y, M, D, neg;

	if (zDate[0] == '-') {
		zDate++;
		neg = 1;
	}
	else {
		neg = 0;
	}
	if (getDigits(zDate, "40f-21a-21d", &Y, &M, &D) != 3) {
		return 1;
	}
	zDate += 10;
	while (sqlite3Isspace(*zDate) || 'T' == *(u8*)zDate) { zDate++; }
	if (parseHhMmSs(zDate, p) == 0) {
		
	}
	else if (*zDate == 0) {
		p->validHMS = 0;
	}
	else {
		return 1;
	}
	p->validJD = 0;
	p->validYMD = 1;
	p->Y = neg ? -Y : Y;
	p->M = M;
	p->D = D;
	if (p->validTZ) {
		computeJD(p);
	}
	return 0;
}


static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p) {
	p->iJD = sqlite3StmtCurrentTime(context);
	if (p->iJD>0) {
		p->validJD = 1;
		return 0;
	}
	else {
		return 1;
	}
}


static int parseDateOrTime(
	sqlite3_context *context,
	const char *zDate,
	DateTime *p
) {
	double r;
	if (parseYyyyMmDd(zDate, p) == 0) {
		return 0;
	}
	else if (parseHhMmSs(zDate, p) == 0) {
		return 0;
	}
	else if (sqlite3StrICmp(zDate, "now") == 0) {
		return setDateTimeToCurrent(context, p);
	}
	else if (sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8)) {
		p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);
		p->validJD = 1;
		return 0;
	}
	return 1;
}


static void computeYMD(DateTime *p) {
	int Z, A, B, C, D, E, X1;
	if (p->validYMD) return;
	if (!p->validJD) {
		p->Y = 2000;
		p->M = 1;
		p->D = 1;
	}
	else {
		Z = (int)((p->iJD + 43200000) / 86400000);
		A = (int)((Z - 1867216.25) / 36524.25);
		A = Z + 1 + A - (A / 4);
		B = A + 1524;
		C = (int)((B - 122.1) / 365.25);
		D = (36525 * (C & 32767)) / 100;
		E = (int)((B - D) / 30.6001);
		X1 = (int)(30.6001*E);
		p->D = B - D - X1;
		p->M = E<14 ? E - 1 : E - 13;
		p->Y = p->M>2 ? C - 4716 : C - 4715;
	}
	p->validYMD = 1;
}


static void computeHMS(DateTime *p) {
	int s;
	if (p->validHMS) return;
	computeJD(p);
	s = (int)((p->iJD + 43200000) % 86400000);
	p->s = s / 1000.0;
	s = (int)p->s;
	p->s -= s;
	p->h = s / 3600;
	s -= p->h * 3600;
	p->m = s / 60;
	p->s += s - p->m * 60;
	p->validHMS = 1;
}


static void computeYMD_HMS(DateTime *p) {
	computeYMD(p);
	computeHMS(p);
}


static void clearYMD_HMS_TZ(DateTime *p) {
	p->validYMD = 0;
	p->validHMS = 0;
	p->validTZ = 0;
}

#ifndef SQLITE_OMIT_LOCALTIME

#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S \
    && defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE)
#undef  HAVE_LOCALTIME_S
#define HAVE_LOCALTIME_S 1
#endif


static int osLocaltime(time_t *t, struct tm *pTm) {
	int rc;
#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S
	struct tm *pX;
#if SQLITE_THREADSAFE>0
	sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
	sqlite3_mutex_enter(mutex);
	pX = localtime(t);
#ifndef SQLITE_OMIT_BUILTIN_TEST
	if (sqlite3GlobalConfig.bLocaltimeFault) pX = 0;
#endif
	if (pX) *pTm = *pX;
	sqlite3_mutex_leave(mutex);
	rc = pX == 0;
#else
#ifndef SQLITE_OMIT_BUILTIN_TEST
	if (sqlite3GlobalConfig.bLocaltimeFault) return 1;
#endif
#if HAVE_LOCALTIME_R
	rc = localtime_r(t, pTm) == 0;
#else
	rc = localtime_s(pTm, t);
#endif 
#endif 
	return rc;
}
#endif 


#ifndef SQLITE_OMIT_LOCALTIME

static sqlite3_int64 localtimeOffset(
	DateTime *p,                    
	sqlite3_context *pCtx,          
	int *pRc                        
) {
	DateTime x, y;
	time_t t;
	struct tm sLocal;

	
	memset(&sLocal, 0, sizeof(sLocal));

	x = *p;
	computeYMD_HMS(&x);
	if (x.Y<1971 || x.Y >= 2038) {
		
		x.Y = 2000;
		x.M = 1;
		x.D = 1;
		x.h = 0;
		x.m = 0;
		x.s = 0.0;
	}
	else {
		int s = (int)(x.s + 0.5);
		x.s = s;
	}
	x.tz = 0;
	x.validJD = 0;
	computeJD(&x);
	t = (time_t)(x.iJD / 1000 - 21086676 * (i64)10000);
	if (osLocaltime(&t, &sLocal)) {
		sqlite3_result_error(pCtx, "local time unavailable", -1);
		*pRc = SQLITE_ERROR;
		return 0;
	}
	y.Y = sLocal.tm_year + 1900;
	y.M = sLocal.tm_mon + 1;
	y.D = sLocal.tm_mday;
	y.h = sLocal.tm_hour;
	y.m = sLocal.tm_min;
	y.s = sLocal.tm_sec;
	y.validYMD = 1;
	y.validHMS = 1;
	y.validJD = 0;
	y.validTZ = 0;
	computeJD(&y);
	*pRc = SQLITE_OK;
	return y.iJD - x.iJD;
}
#endif 


static int parseModifier(sqlite3_context *pCtx, const char *zMod, DateTime *p) {
	int rc = 1;
	int n;
	double r;
	char *z, zBuf[30];
	z = zBuf;
	for (n = 0; n<ArraySize(zBuf) - 1 && zMod[n]; n++) {
		z[n] = (char)sqlite3UpperToLower[(u8)zMod[n]];
	}
	z[n] = 0;
	switch (z[0]) {
#ifndef SQLITE_OMIT_LOCALTIME
	case 'l': {
		
		if (strcmp(z, "localtime") == 0) {
			computeJD(p);
			p->iJD += localtimeOffset(p, pCtx, &rc);
			clearYMD_HMS_TZ(p);
		}
		break;
	}
#endif
	case 'u': {
		
		if (strcmp(z, "unixepoch") == 0 && p->validJD) {
			p->iJD = (p->iJD + 43200) / 86400 + 21086676 * (i64)10000000;
			clearYMD_HMS_TZ(p);
			rc = 0;
		}
#ifndef SQLITE_OMIT_LOCALTIME
		else if (strcmp(z, "utc") == 0) {
			if (p->tzSet == 0) {
				sqlite3_int64 c1;
				computeJD(p);
				c1 = localtimeOffset(p, pCtx, &rc);
				if (rc == SQLITE_OK) {
					p->iJD -= c1;
					clearYMD_HMS_TZ(p);
					p->iJD += c1 - localtimeOffset(p, pCtx, &rc);
				}
				p->tzSet = 1;
			}
			else {
				rc = SQLITE_OK;
			}
		}
#endif
		break;
	}
	case 'w': {
		
		if (strncmp(z, "weekday ", 8) == 0
			&& sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)
			&& (n = (int)r) == r && n >= 0 && r<7) {
			sqlite3_int64 Z;
			computeYMD_HMS(p);
			p->validTZ = 0;
			p->validJD = 0;
			computeJD(p);
			Z = ((p->iJD + 129600000) / 86400000) % 7;
			if (Z>n) Z -= 7;
			p->iJD += (n - Z) * 86400000;
			clearYMD_HMS_TZ(p);
			rc = 0;
		}
		break;
	}
	case 's': {
		
		if (strncmp(z, "start of ", 9) != 0) break;
		z += 9;
		computeYMD(p);
		p->validHMS = 1;
		p->h = p->m = 0;
		p->s = 0.0;
		p->validTZ = 0;
		p->validJD = 0;
		if (strcmp(z, "month") == 0) {
			p->D = 1;
			rc = 0;
		}
		else if (strcmp(z, "year") == 0) {
			computeYMD(p);
			p->M = 1;
			p->D = 1;
			rc = 0;
		}
		else if (strcmp(z, "day") == 0) {
			rc = 0;
		}
		break;
	}
	case '+':
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9': {
		double rRounder;
		for (n = 1; z[n] && z[n] != ':' && !sqlite3Isspace(z[n]); n++) {}
		if (!sqlite3AtoF(z, &r, n, SQLITE_UTF8)) {
			rc = 1;
			break;
		}
		if (z[n] == ':') {
			
			const char *z2 = z;
			DateTime tx;
			sqlite3_int64 day;
			if (!sqlite3Isdigit(*z2)) z2++;
			memset(&tx, 0, sizeof(tx));
			if (parseHhMmSs(z2, &tx)) break;
			computeJD(&tx);
			tx.iJD -= 43200000;
			day = tx.iJD / 86400000;
			tx.iJD -= day * 86400000;
			if (z[0] == '-') tx.iJD = -tx.iJD;
			computeJD(p);
			clearYMD_HMS_TZ(p);
			p->iJD += tx.iJD;
			rc = 0;
			break;
		}
		z += n;
		while (sqlite3Isspace(*z)) z++;
		n = sqlite3Strlen30(z);
		if (n>10 || n<3) break;
		if (z[n - 1] == 's') { z[n - 1] = 0; n--; }
		computeJD(p);
		rc = 0;
		rRounder = r<0 ? -0.5 : +0.5;
		if (n == 3 && strcmp(z, "day") == 0) {
			p->iJD += (sqlite3_int64)(r*86400000.0 + rRounder);
		}
		else if (n == 4 && strcmp(z, "hour") == 0) {
			p->iJD += (sqlite3_int64)(r*(86400000.0 / 24.0) + rRounder);
		}
		else if (n == 6 && strcmp(z, "minute") == 0) {
			p->iJD += (sqlite3_int64)(r*(86400000.0 / (24.0*60.0)) + rRounder);
		}
		else if (n == 6 && strcmp(z, "second") == 0) {
			p->iJD += (sqlite3_int64)(r*(86400000.0 / (24.0*60.0*60.0)) + rRounder);
		}
		else if (n == 5 && strcmp(z, "month") == 0) {
			int x, y;
			computeYMD_HMS(p);
			p->M += (int)r;
			x = p->M>0 ? (p->M - 1) / 12 : (p->M - 12) / 12;
			p->Y += x;
			p->M -= x * 12;
			p->validJD = 0;
			computeJD(p);
			y = (int)r;
			if (y != r) {
				p->iJD += (sqlite3_int64)((r - y)*30.0*86400000.0 + rRounder);
			}
		}
		else if (n == 4 && strcmp(z, "year") == 0) {
			int y = (int)r;
			computeYMD_HMS(p);
			p->Y += y;
			p->validJD = 0;
			computeJD(p);
			if (y != r) {
				p->iJD += (sqlite3_int64)((r - y)*365.0*86400000.0 + rRounder);
			}
		}
		else {
			rc = 1;
		}
		clearYMD_HMS_TZ(p);
		break;
	}
	default: {
		break;
	}
	}
	return rc;
}


static int isDate(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv,
	DateTime *p
) {
	int i;
	const unsigned char *z;
	int eType;
	memset(p, 0, sizeof(*p));
	if (argc == 0) {
		return setDateTimeToCurrent(context, p);
	}
	if ((eType = sqlite3_value_type(argv[0])) == SQLITE_FLOAT
		|| eType == SQLITE_INTEGER) {
		p->iJD = (sqlite3_int64)(sqlite3_value_double(argv[0])*86400000.0 + 0.5);
		p->validJD = 1;
	}
	else {
		z = sqlite3_value_text(argv[0]);
		if (!z || parseDateOrTime(context, (char*)z, p)) {
			return 1;
		}
	}
	for (i = 1; i<argc; i++) {
		z = sqlite3_value_text(argv[i]);
		if (z == 0 || parseModifier(context, (char*)z, p)) return 1;
	}
	return 0;
}





static void juliandayFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	DateTime x;
	if (isDate(context, argc, argv, &x) == 0) {
		computeJD(&x);
		sqlite3_result_double(context, x.iJD / 86400000.0);
	}
}


static void datetimeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	DateTime x;
	if (isDate(context, argc, argv, &x) == 0) {
		char zBuf[100];
		computeYMD_HMS(&x);
		sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",
			x.Y, x.M, x.D, x.h, x.m, (int)(x.s));
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
	}
}


static void timeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	DateTime x;
	if (isDate(context, argc, argv, &x) == 0) {
		char zBuf[100];
		computeHMS(&x);
		sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
	}
}


static void dateFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	DateTime x;
	if (isDate(context, argc, argv, &x) == 0) {
		char zBuf[100];
		computeYMD(&x);
		sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
	}
}


static void strftimeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	DateTime x;
	u64 n;
	size_t i, j;
	char *z;
	sqlite3 *db;
	const char *zFmt;
	char zBuf[100];
	if (argc == 0) return;
	zFmt = (const char*)sqlite3_value_text(argv[0]);
	if (zFmt == 0 || isDate(context, argc - 1, argv + 1, &x)) return;
	db = sqlite3_context_db_handle(context);
	for (i = 0, n = 1; zFmt[i]; i++, n++) {
		if (zFmt[i] == '%') {
			switch (zFmt[i + 1]) {
			case 'd':
			case 'H':
			case 'm':
			case 'M':
			case 'S':
			case 'W':
				n++;
				
			case 'w':
			case '%':
				break;
			case 'f':
				n += 8;
				break;
			case 'j':
				n += 3;
				break;
			case 'Y':
				n += 8;
				break;
			case 's':
			case 'J':
				n += 50;
				break;
			default:
				return;  
			}
			i++;
		}
	}
	testcase(n == sizeof(zBuf) - 1);
	testcase(n == sizeof(zBuf));
	testcase(n == (u64)db->aLimit[SQLITE_LIMIT_LENGTH] + 1);
	testcase(n == (u64)db->aLimit[SQLITE_LIMIT_LENGTH]);
	if (n<sizeof(zBuf)) {
		z = zBuf;
	}
	else if (n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH]) {
		sqlite3_result_error_toobig(context);
		return;
	}
	else {
		z = sqlite3DbMallocRawNN(db, (int)n);
		if (z == 0) {
			sqlite3_result_error_nomem(context);
			return;
		}
	}
	computeJD(&x);
	computeYMD_HMS(&x);
	for (i = j = 0; zFmt[i]; i++) {
		if (zFmt[i] != '%') {
			z[j++] = zFmt[i];
		}
		else {
			i++;
			switch (zFmt[i]) {
			case 'd':  sqlite3_snprintf(3, &z[j], "%02d", x.D); j += 2; break;
			case 'f': {
				double s = x.s;
				if (s>59.999) s = 59.999;
				sqlite3_snprintf(7, &z[j], "%06.3f", s);
				j += sqlite3Strlen30(&z[j]);
				break;
			}
			case 'H':  sqlite3_snprintf(3, &z[j], "%02d", x.h); j += 2; break;
			case 'W': 
			case 'j': {
				int nDay;             
				DateTime y = x;
				y.validJD = 0;
				y.M = 1;
				y.D = 1;
				computeJD(&y);
				nDay = (int)((x.iJD - y.iJD + 43200000) / 86400000);
				if (zFmt[i] == 'W') {
					int wd;   
					wd = (int)(((x.iJD + 43200000) / 86400000) % 7);
					sqlite3_snprintf(3, &z[j], "%02d", (nDay + 7 - wd) / 7);
					j += 2;
				}
				else {
					sqlite3_snprintf(4, &z[j], "%03d", nDay + 1);
					j += 3;
				}
				break;
			}
			case 'J': {
				sqlite3_snprintf(20, &z[j], "%.16g", x.iJD / 86400000.0);
				j += sqlite3Strlen30(&z[j]);
				break;
			}
			case 'm':  sqlite3_snprintf(3, &z[j], "%02d", x.M); j += 2; break;
			case 'M':  sqlite3_snprintf(3, &z[j], "%02d", x.m); j += 2; break;
			case 's': {
				sqlite3_snprintf(30, &z[j], "%lld",
					(i64)(x.iJD / 1000 - 21086676 * (i64)10000));
				j += sqlite3Strlen30(&z[j]);
				break;
			}
			case 'S':  sqlite3_snprintf(3, &z[j], "%02d", (int)x.s); j += 2; break;
			case 'w': {
				z[j++] = (char)(((x.iJD + 129600000) / 86400000) % 7) + '0';
				break;
			}
			case 'Y': {
				sqlite3_snprintf(5, &z[j], "%04d", x.Y); j += sqlite3Strlen30(&z[j]);
				break;
			}
			default:   z[j++] = '%'; break;
			}
		}
	}
	z[j] = 0;
	sqlite3_result_text(context, z, -1,
		z == zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC);
}


static void ctimeFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	timeFunc(context, 0, 0);
}


static void cdateFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	dateFunc(context, 0, 0);
}


static void ctimestampFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	datetimeFunc(context, 0, 0);
}
#endif 

#ifdef SQLITE_OMIT_DATETIME_FUNCS

static void currentTimeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	time_t t;
	char *zFormat = (char *)sqlite3_user_data(context);
	sqlite3_int64 iT;
	struct tm *pTm;
	struct tm sNow;
	char zBuf[20];

	UNUSED_PARAMETER(argc);
	UNUSED_PARAMETER(argv);

	iT = sqlite3StmtCurrentTime(context);
	if (iT <= 0) return;
	t = iT / 1000 - 10000 * (sqlite3_int64)21086676;
#if HAVE_GMTIME_R
	pTm = gmtime_r(&t, &sNow);
#else
	sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));
	pTm = gmtime(&t);
	if (pTm) memcpy(&sNow, pTm, sizeof(sNow));
	sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));
#endif
	if (pTm) {
		strftime(zBuf, 20, zFormat, &sNow);
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
	}
}
#endif


SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void) {
	static FuncDef aDateTimeFuncs[] = {
#ifndef SQLITE_OMIT_DATETIME_FUNCS
		DFUNCTION(julianday,        -1, 0, 0, juliandayFunc),
		DFUNCTION(date,             -1, 0, 0, dateFunc),
		DFUNCTION(time,             -1, 0, 0, timeFunc),
		DFUNCTION(datetime,         -1, 0, 0, datetimeFunc),
		DFUNCTION(strftime,         -1, 0, 0, strftimeFunc),
		DFUNCTION(current_time,      0, 0, 0, ctimeFunc),
		DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),
		DFUNCTION(current_date,      0, 0, 0, cdateFunc),
#else
		STR_FUNCTION(current_time,      0, "%H:%M:%S",          0, currentTimeFunc),
		STR_FUNCTION(current_date,      0, "%Y-%m-%d",          0, currentTimeFunc),
		STR_FUNCTION(current_timestamp, 0, "%Y-%m-%d %H:%M:%S", 0, currentTimeFunc),
#endif
	};
	sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ArraySize(aDateTimeFuncs));
}







#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_io_error_hit = 0;            
SQLITE_API int sqlite3_io_error_hardhit = 0;        
SQLITE_API int sqlite3_io_error_pending = 0;        
SQLITE_API int sqlite3_io_error_persist = 0;        
SQLITE_API int sqlite3_io_error_benign = 0;         
SQLITE_API int sqlite3_diskfull_pending = 0;
SQLITE_API int sqlite3_diskfull = 0;
#endif 


#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_open_file_count = 0;
#endif 


#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_memdebug_vfs_oom_test = 1;
#define DO_OS_MALLOC_TEST(x)                                       \
  if (sqlite3_memdebug_vfs_oom_test && (!x || !sqlite3JournalIsInMemory(x))) { \
    void *pTstAlloc = sqlite3Malloc(10);                             \
    if (!pTstAlloc) return SQLITE_IOERR_NOMEM_BKPT;                  \
    sqlite3_free(pTstAlloc);                                         \
  }
#else
#define DO_OS_MALLOC_TEST(x)
#endif


SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file *pId) {
	if (pId->pMethods) {
		pId->pMethods->xClose(pId);
		pId->pMethods = 0;
	}
}
SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xRead(id, pBuf, amt, offset);
}
SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xWrite(id, pBuf, amt, offset);
}
SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size) {
	return id->pMethods->xTruncate(id, size);
}
SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xSync(id, flags);
}
SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xFileSize(id, pSize);
}
SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xLock(id, lockType);
}
SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType) {
	return id->pMethods->xUnlock(id, lockType);
}
SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xCheckReservedLock(id, pResOut);
}


SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg) {
#ifdef SQLITE_TEST
	if (op != SQLITE_FCNTL_COMMIT_PHASETWO) {
		
		DO_OS_MALLOC_TEST(id);
	}
#endif
	return id->pMethods->xFileControl(id, op, pArg);
}
SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg) {
	(void)id->pMethods->xFileControl(id, op, pArg);
}

SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id) {
	int(*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;
	return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE);
}
SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id) {
	return id->pMethods->xDeviceCharacteristics(id);
}
SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags) {
	return id->pMethods->xShmLock(id, offset, n, flags);
}
SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id) {
	id->pMethods->xShmBarrier(id);
}
SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag) {
	return id->pMethods->xShmUnmap(id, deleteFlag);
}
SQLITE_PRIVATE int sqlite3OsShmMap(
	sqlite3_file *id,               
	int iPage,
	int pgsz,
	int bExtend,                    
	void volatile **pp              
) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);
}

#if SQLITE_MAX_MMAP_SIZE>0

SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp) {
	DO_OS_MALLOC_TEST(id);
	return id->pMethods->xFetch(id, iOff, iAmt, pp);
}
SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p) {
	return id->pMethods->xUnfetch(id, iOff, p);
}
#else

SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp) {
	*pp = 0;
	return SQLITE_OK;
}
SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p) {
	return SQLITE_OK;
}
#endif


SQLITE_PRIVATE int sqlite3OsOpen(
	sqlite3_vfs *pVfs,
	const char *zPath,
	sqlite3_file *pFile,
	int flags,
	int *pFlagsOut
) {
	int rc;
	DO_OS_MALLOC_TEST(0);
	
	rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f7f, pFlagsOut);
	assert(rc == SQLITE_OK || pFile->pMethods == 0);
	return rc;
}
SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync) {
	DO_OS_MALLOC_TEST(0);
	assert(dirSync == 0 || dirSync == 1);
	return pVfs->xDelete(pVfs, zPath, dirSync);
}
SQLITE_PRIVATE int sqlite3OsAccess(
	sqlite3_vfs *pVfs,
	const char *zPath,
	int flags,
	int *pResOut
) {
	DO_OS_MALLOC_TEST(0);
	return pVfs->xAccess(pVfs, zPath, flags, pResOut);
}
SQLITE_PRIVATE int sqlite3OsFullPathname(
	sqlite3_vfs *pVfs,
	const char *zPath,
	int nPathOut,
	char *zPathOut
) {
	DO_OS_MALLOC_TEST(0);
	zPathOut[0] = 0;
	return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);
}
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath) {
	return pVfs->xDlOpen(pVfs, zPath);
}
SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut) {
	pVfs->xDlError(pVfs, nByte, zBufOut);
}
SQLITE_PRIVATE void(*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void) {
	return pVfs->xDlSym(pVfs, pHdle, zSym);
}
SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle) {
	pVfs->xDlClose(pVfs, pHandle);
}
#endif 
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut) {
	return pVfs->xRandomness(pVfs, nByte, zBufOut);
}
SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro) {
	return pVfs->xSleep(pVfs, nMicro);
}
SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs *pVfs) {
	return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;
}
SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut) {
	int rc;
	
	if (pVfs->iVersion >= 2 && pVfs->xCurrentTimeInt64) {
		rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);
	}
	else {
		double r;
		rc = pVfs->xCurrentTime(pVfs, &r);
		*pTimeOut = (sqlite3_int64)(r*86400000.0);
	}
	return rc;
}

SQLITE_PRIVATE int sqlite3OsOpenMalloc(
	sqlite3_vfs *pVfs,
	const char *zFile,
	sqlite3_file **ppFile,
	int flags,
	int *pOutFlags
) {
	int rc;
	sqlite3_file *pFile;
	pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);
	if (pFile) {
		rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);
		if (rc != SQLITE_OK) {
			sqlite3_free(pFile);
		}
		else {
			*ppFile = pFile;
		}
	}
	else {
		rc = SQLITE_NOMEM_BKPT;
	}
	return rc;
}
SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *pFile) {
	assert(pFile);
	sqlite3OsClose(pFile);
	sqlite3_free(pFile);
}


SQLITE_PRIVATE int sqlite3OsInit(void) {
	void *p = sqlite3_malloc(10);
	if (p == 0) return SQLITE_NOMEM_BKPT;
	sqlite3_free(p);
	return sqlite3_os_init();
}


static sqlite3_vfs * SQLITE_WSD vfsList = 0;
#define vfsList GLOBAL(sqlite3_vfs *, vfsList)


SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs) {
	sqlite3_vfs *pVfs = 0;
#if SQLITE_THREADSAFE
	sqlite3_mutex *mutex;
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	int rc = sqlite3_initialize();
	if (rc) return 0;
#endif
#if SQLITE_THREADSAFE
	mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
	sqlite3_mutex_enter(mutex);
	for (pVfs = vfsList; pVfs; pVfs = pVfs->pNext) {
		if (zVfs == 0) break;
		if (strcmp(zVfs, pVfs->zName) == 0) break;
	}
	sqlite3_mutex_leave(mutex);
	return pVfs;
}


static void vfsUnlink(sqlite3_vfs *pVfs) {
	assert(sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)));
	if (pVfs == 0) {
		
	}
	else if (vfsList == pVfs) {
		vfsList = pVfs->pNext;
	}
	else if (vfsList) {
		sqlite3_vfs *p = vfsList;
		while (p->pNext && p->pNext != pVfs) {
			p = p->pNext;
		}
		if (p->pNext == pVfs) {
			p->pNext = pVfs->pNext;
		}
	}
}


SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt) {
	MUTEX_LOGIC(sqlite3_mutex *mutex;)
#ifndef SQLITE_OMIT_AUTOINIT
		int rc = sqlite3_initialize();
	if (rc) return rc;
#endif
#ifdef SQLITE_ENABLE_API_ARMOR
	if (pVfs == 0) return SQLITE_MISUSE_BKPT;
#endif

	MUTEX_LOGIC(mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )
		sqlite3_mutex_enter(mutex);
	vfsUnlink(pVfs);
	if (makeDflt || vfsList == 0) {
		pVfs->pNext = vfsList;
		vfsList = pVfs;
	}
	else {
		pVfs->pNext = vfsList->pNext;
		vfsList->pNext = pVfs;
	}
	assert(vfsList);
	sqlite3_mutex_leave(mutex);
	return SQLITE_OK;
}


SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs) {
#if SQLITE_THREADSAFE
	sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
	sqlite3_mutex_enter(mutex);
	vfsUnlink(pVfs);
	sqlite3_mutex_leave(mutex);
	return SQLITE_OK;
}







#ifndef SQLITE_OMIT_BUILTIN_TEST


typedef struct BenignMallocHooks BenignMallocHooks;
static SQLITE_WSD struct BenignMallocHooks {
	void(*xBenignBegin)(void);
	void(*xBenignEnd)(void);
} sqlite3Hooks = { 0, 0 };


#ifdef SQLITE_OMIT_WSD
# define wsdHooksInit \
  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)
# define wsdHooks x[0]
#else
# define wsdHooksInit
# define wsdHooks sqlite3Hooks
#endif



SQLITE_PRIVATE void sqlite3BenignMallocHooks(
	void(*xBenignBegin)(void),
	void(*xBenignEnd)(void)
) {
	wsdHooksInit;
	wsdHooks.xBenignBegin = xBenignBegin;
	wsdHooks.xBenignEnd = xBenignEnd;
}


SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void) {
	wsdHooksInit;
	if (wsdHooks.xBenignBegin) {
		wsdHooks.xBenignBegin();
	}
}
SQLITE_PRIVATE void sqlite3EndBenignMalloc(void) {
	wsdHooksInit;
	if (wsdHooks.xBenignEnd) {
		wsdHooks.xBenignEnd();
	}
}

#endif   







#ifdef SQLITE_ZERO_MALLOC


static void *sqlite3MemMalloc(int nByte) { return 0; }
static void sqlite3MemFree(void *pPrior) { return; }
static void *sqlite3MemRealloc(void *pPrior, int nByte) { return 0; }
static int sqlite3MemSize(void *pPrior) { return 0; }
static int sqlite3MemRoundup(int n) { return n; }
static int sqlite3MemInit(void *NotUsed) { return SQLITE_OK; }
static void sqlite3MemShutdown(void *NotUsed) { return; }


SQLITE_PRIVATE void sqlite3MemSetDefault(void) {
	static const sqlite3_mem_methods defaultMethods = {
		sqlite3MemMalloc,
		sqlite3MemFree,
		sqlite3MemRealloc,
		sqlite3MemSize,
		sqlite3MemRoundup,
		sqlite3MemInit,
		sqlite3MemShutdown,
		0
	};
	sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);
}

#endif 







#ifdef SQLITE_SYSTEM_MALLOC
#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)


#include <sys/sysctl.h>
#include <malloc/malloc.h>
#include <libkern/OSAtomic.h>
static malloc_zone_t* _sqliteZone_;
#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))
#define SQLITE_FREE(x) malloc_zone_free(_sqliteZone_, (x));
#define SQLITE_REALLOC(x,y) malloc_zone_realloc(_sqliteZone_, (x), (y))
#define SQLITE_MALLOCSIZE(x) \
        (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x))

#else 


#define SQLITE_MALLOC(x)             malloc(x)
#define SQLITE_FREE(x)               free(x)
#define SQLITE_REALLOC(x,y)          realloc((x),(y))


#if HAVE_MALLOC_H && HAVE_MALLOC_USABLE_SIZE
#  define SQLITE_USE_MALLOC_H 1
#  define SQLITE_USE_MALLOC_USABLE_SIZE 1

#elif defined(_MSC_VER) && !defined(SQLITE_WITHOUT_MSIZE)
#  define SQLITE_USE_MALLOC_H
#  define SQLITE_USE_MSIZE
#endif


#if defined(SQLITE_USE_MALLOC_H)
#  include <malloc.h>
#  if defined(SQLITE_USE_MALLOC_USABLE_SIZE)
#    if !defined(SQLITE_MALLOCSIZE)
#      define SQLITE_MALLOCSIZE(x)   malloc_usable_size(x)
#    endif
#  elif defined(SQLITE_USE_MSIZE)
#    if !defined(SQLITE_MALLOCSIZE)
#      define SQLITE_MALLOCSIZE      _msize
#    endif
#  endif
#endif 

#endif 


static void *sqlite3MemMalloc(int nByte) {
#ifdef SQLITE_MALLOCSIZE
	void *p = SQLITE_MALLOC(nByte);
	if (p == 0) {
		testcase(sqlite3GlobalConfig.xLog != 0);
		sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);
	}
	return p;
#else
	sqlite3_int64 *p;
	assert(nByte>0);
	nByte = ROUND8(nByte);
	p = SQLITE_MALLOC(nByte + 8);
	if (p) {
		p[0] = nByte;
		p++;
	}
	else {
		testcase(sqlite3GlobalConfig.xLog != 0);
		sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);
	}
	return (void *)p;
#endif
}


static void sqlite3MemFree(void *pPrior) {
#ifdef SQLITE_MALLOCSIZE
	SQLITE_FREE(pPrior);
#else
	sqlite3_int64 *p = (sqlite3_int64*)pPrior;
	assert(pPrior != 0);
	p--;
	SQLITE_FREE(p);
#endif
}


static int sqlite3MemSize(void *pPrior) {
#ifdef SQLITE_MALLOCSIZE
	assert(pPrior != 0);
	return (int)SQLITE_MALLOCSIZE(pPrior);
#else
	sqlite3_int64 *p;
	assert(pPrior != 0);
	p = (sqlite3_int64*)pPrior;
	p--;
	return (int)p[0];
#endif
}


static void *sqlite3MemRealloc(void *pPrior, int nByte) {
#ifdef SQLITE_MALLOCSIZE
	void *p = SQLITE_REALLOC(pPrior, nByte);
	if (p == 0) {
		testcase(sqlite3GlobalConfig.xLog != 0);
		sqlite3_log(SQLITE_NOMEM,
			"failed memory resize %u to %u bytes",
			SQLITE_MALLOCSIZE(pPrior), nByte);
	}
	return p;
#else
	sqlite3_int64 *p = (sqlite3_int64*)pPrior;
	assert(pPrior != 0 && nByte>0);
	assert(nByte == ROUND8(nByte)); 
	p--;
	p = SQLITE_REALLOC(p, nByte + 8);
	if (p) {
		p[0] = nByte;
		p++;
	}
	else {
		testcase(sqlite3GlobalConfig.xLog != 0);
		sqlite3_log(SQLITE_NOMEM,
			"failed memory resize %u to %u bytes",
			sqlite3MemSize(pPrior), nByte);
	}
	return (void*)p;
#endif
}


static int sqlite3MemRoundup(int n) {
	return ROUND8(n);
}


static int sqlite3MemInit(void *NotUsed) {
#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)
	int cpuCount;
	size_t len;
	if (_sqliteZone_) {
		return SQLITE_OK;
	}
	len = sizeof(cpuCount);
	
	sysctlbyname("hw.ncpu", &cpuCount, &len, NULL, 0);
	if (cpuCount>1) {
		
		_sqliteZone_ = malloc_default_zone();
	}
	else {
		
		bool success;
		malloc_zone_t* newzone = malloc_create_zone(4096, 0);
		malloc_set_zone_name(newzone, "Sqlite_Heap");
		do {
			success = OSAtomicCompareAndSwapPtrBarrier(NULL, newzone,
				(void * volatile *)&_sqliteZone_);
		} while (!_sqliteZone_);
		if (!success) {
			
			malloc_destroy_zone(newzone);
		}
	}
#endif
	UNUSED_PARAMETER(NotUsed);
	return SQLITE_OK;
}


static void sqlite3MemShutdown(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	return;
}


SQLITE_PRIVATE void sqlite3MemSetDefault(void) {
	static const sqlite3_mem_methods defaultMethods = {
		sqlite3MemMalloc,
		sqlite3MemFree,
		sqlite3MemRealloc,
		sqlite3MemSize,
		sqlite3MemRoundup,
		sqlite3MemInit,
		sqlite3MemShutdown,
		0
	};
	sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);
}

#endif 







#ifdef SQLITE_MEMDEBUG


#ifdef __GLIBC__
extern int backtrace(void**, int);
extern void backtrace_symbols_fd(void*const*, int, int);
#else
# define backtrace(A,B) 1
# define backtrace_symbols_fd(A,B,C)
#endif



struct MemBlockHdr {
	i64 iSize;                          
	struct MemBlockHdr *pNext, *pPrev;  
	char nBacktrace;                    
	char nBacktraceSlots;               
	u8 nTitle;                          
	u8 eType;                           
	int iForeGuard;                     
};


#define FOREGUARD 0x80F5E153
#define REARGUARD 0xE4676B53


#define NCSIZE  1000


static struct {

	
	sqlite3_mutex *mutex;

	
	struct MemBlockHdr *pFirst;
	struct MemBlockHdr *pLast;

	
	int nBacktrace;
	void(*xBacktrace)(int, int, void **);

	
	int nTitle;        
	char zTitle[100];  

					   
	int disallow; 

				  
	int nAlloc[NCSIZE];      
	int nCurrent[NCSIZE];    
	int mxCurrent[NCSIZE];   

} mem;



static void adjustStats(int iSize, int increment) {
	int i = ROUND8(iSize) / 8;
	if (i>NCSIZE - 1) {
		i = NCSIZE - 1;
	}
	if (increment>0) {
		mem.nAlloc[i]++;
		mem.nCurrent[i]++;
		if (mem.nCurrent[i]>mem.mxCurrent[i]) {
			mem.mxCurrent[i] = mem.nCurrent[i];
		}
	}
	else {
		mem.nCurrent[i]--;
		assert(mem.nCurrent[i] >= 0);
	}
}


static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation) {
	struct MemBlockHdr *p;
	int *pInt;
	u8 *pU8;
	int nReserve;

	p = (struct MemBlockHdr*)pAllocation;
	p--;
	assert(p->iForeGuard == (int)FOREGUARD);
	nReserve = ROUND8(p->iSize);
	pInt = (int*)pAllocation;
	pU8 = (u8*)pAllocation;
	assert(pInt[nReserve / sizeof(int)] == (int)REARGUARD);
	
	while (nReserve-- > p->iSize) assert(pU8[nReserve] == 0x65);
	return p;
}


static int sqlite3MemSize(void *p) {
	struct MemBlockHdr *pHdr;
	if (!p) {
		return 0;
	}
	pHdr = sqlite3MemsysGetHeader(p);
	return (int)pHdr->iSize;
}


static int sqlite3MemInit(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	assert((sizeof(struct MemBlockHdr) & 7) == 0);
	if (!sqlite3GlobalConfig.bMemstat) {
		
		mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
	}
	return SQLITE_OK;
}


static void sqlite3MemShutdown(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	mem.mutex = 0;
}


static int sqlite3MemRoundup(int n) {
	return ROUND8(n);
}


static void randomFill(char *pBuf, int nByte) {
	unsigned int x, y, r;
	x = SQLITE_PTR_TO_INT(pBuf);
	y = nByte | 1;
	while (nByte >= 4) {
		x = (x >> 1) ^ (-(int)(x & 1) & 0xd0000001);
		y = y * 1103515245 + 12345;
		r = x ^ y;
		*(int*)pBuf = r;
		pBuf += 4;
		nByte -= 4;
	}
	while (nByte-- > 0) {
		x = (x >> 1) ^ (-(int)(x & 1) & 0xd0000001);
		y = y * 1103515245 + 12345;
		r = x ^ y;
		*(pBuf++) = r & 0xff;
	}
}


static void *sqlite3MemMalloc(int nByte) {
	struct MemBlockHdr *pHdr;
	void **pBt;
	char *z;
	int *pInt;
	void *p = 0;
	int totalSize;
	int nReserve;
	sqlite3_mutex_enter(mem.mutex);
	assert(mem.disallow == 0);
	nReserve = ROUND8(nByte);
	totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +
		mem.nBacktrace * sizeof(void*) + mem.nTitle;
	p = malloc(totalSize);
	if (p) {
		z = p;
		pBt = (void**)&z[mem.nTitle];
		pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];
		pHdr->pNext = 0;
		pHdr->pPrev = mem.pLast;
		if (mem.pLast) {
			mem.pLast->pNext = pHdr;
		}
		else {
			mem.pFirst = pHdr;
		}
		mem.pLast = pHdr;
		pHdr->iForeGuard = FOREGUARD;
		pHdr->eType = MEMTYPE_HEAP;
		pHdr->nBacktraceSlots = mem.nBacktrace;
		pHdr->nTitle = mem.nTitle;
		if (mem.nBacktrace) {
			void *aAddr[40];
			pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace + 1) - 1;
			memcpy(pBt, &aAddr[1], pHdr->nBacktrace * sizeof(void*));
			assert(pBt[0]);
			if (mem.xBacktrace) {
				mem.xBacktrace(nByte, pHdr->nBacktrace - 1, &aAddr[1]);
			}
		}
		else {
			pHdr->nBacktrace = 0;
		}
		if (mem.nTitle) {
			memcpy(z, mem.zTitle, mem.nTitle);
		}
		pHdr->iSize = nByte;
		adjustStats(nByte, +1);
		pInt = (int*)&pHdr[1];
		pInt[nReserve / sizeof(int)] = REARGUARD;
		randomFill((char*)pInt, nByte);
		memset(((char*)pInt) + nByte, 0x65, nReserve - nByte);
		p = (void*)pInt;
	}
	sqlite3_mutex_leave(mem.mutex);
	return p;
}


static void sqlite3MemFree(void *pPrior) {
	struct MemBlockHdr *pHdr;
	void **pBt;
	char *z;
	assert(sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex == 0
		|| mem.mutex != 0);
	pHdr = sqlite3MemsysGetHeader(pPrior);
	pBt = (void**)pHdr;
	pBt -= pHdr->nBacktraceSlots;
	sqlite3_mutex_enter(mem.mutex);
	if (pHdr->pPrev) {
		assert(pHdr->pPrev->pNext == pHdr);
		pHdr->pPrev->pNext = pHdr->pNext;
	}
	else {
		assert(mem.pFirst == pHdr);
		mem.pFirst = pHdr->pNext;
	}
	if (pHdr->pNext) {
		assert(pHdr->pNext->pPrev == pHdr);
		pHdr->pNext->pPrev = pHdr->pPrev;
	}
	else {
		assert(mem.pLast == pHdr);
		mem.pLast = pHdr->pPrev;
	}
	z = (char*)pBt;
	z -= pHdr->nTitle;
	adjustStats((int)pHdr->iSize, -1);
	randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +
		(int)pHdr->iSize + sizeof(int) + pHdr->nTitle);
	free(z);
	sqlite3_mutex_leave(mem.mutex);
}


static void *sqlite3MemRealloc(void *pPrior, int nByte) {
	struct MemBlockHdr *pOldHdr;
	void *pNew;
	assert(mem.disallow == 0);
	assert((nByte & 7) == 0);     
	pOldHdr = sqlite3MemsysGetHeader(pPrior);
	pNew = sqlite3MemMalloc(nByte);
	if (pNew) {
		memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));
		if (nByte>pOldHdr->iSize) {
			randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);
		}
		sqlite3MemFree(pPrior);
	}
	return pNew;
}


SQLITE_PRIVATE void sqlite3MemSetDefault(void) {
	static const sqlite3_mem_methods defaultMethods = {
		sqlite3MemMalloc,
		sqlite3MemFree,
		sqlite3MemRealloc,
		sqlite3MemSize,
		sqlite3MemRoundup,
		sqlite3MemInit,
		sqlite3MemShutdown,
		0
	};
	sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);
}


SQLITE_PRIVATE void sqlite3MemdebugSetType(void *p, u8 eType) {
	if (p && sqlite3GlobalConfig.m.xMalloc == sqlite3MemMalloc) {
		struct MemBlockHdr *pHdr;
		pHdr = sqlite3MemsysGetHeader(p);
		assert(pHdr->iForeGuard == FOREGUARD);
		pHdr->eType = eType;
	}
}


SQLITE_PRIVATE int sqlite3MemdebugHasType(void *p, u8 eType) {
	int rc = 1;
	if (p && sqlite3GlobalConfig.m.xMalloc == sqlite3MemMalloc) {
		struct MemBlockHdr *pHdr;
		pHdr = sqlite3MemsysGetHeader(p);
		assert(pHdr->iForeGuard == FOREGUARD);         
		if ((pHdr->eType&eType) == 0) {
			rc = 0;
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3MemdebugNoType(void *p, u8 eType) {
	int rc = 1;
	if (p && sqlite3GlobalConfig.m.xMalloc == sqlite3MemMalloc) {
		struct MemBlockHdr *pHdr;
		pHdr = sqlite3MemsysGetHeader(p);
		assert(pHdr->iForeGuard == FOREGUARD);         
		if ((pHdr->eType&eType) != 0) {
			rc = 0;
		}
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth) {
	if (depth<0) { depth = 0; }
	if (depth>20) { depth = 20; }
	depth = (depth + 1) & 0xfe;
	mem.nBacktrace = depth;
}

SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void(*xBacktrace)(int, int, void **)) {
	mem.xBacktrace = xBacktrace;
}


SQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle) {
	unsigned int n = sqlite3Strlen30(zTitle) + 1;
	sqlite3_mutex_enter(mem.mutex);
	if (n >= sizeof(mem.zTitle)) n = sizeof(mem.zTitle) - 1;
	memcpy(mem.zTitle, zTitle, n);
	mem.zTitle[n] = 0;
	mem.nTitle = ROUND8(n);
	sqlite3_mutex_leave(mem.mutex);
}

SQLITE_PRIVATE void sqlite3MemdebugSync() {
	struct MemBlockHdr *pHdr;
	for (pHdr = mem.pFirst; pHdr; pHdr = pHdr->pNext) {
		void **pBt = (void**)pHdr;
		pBt -= pHdr->nBacktraceSlots;
		mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace - 1, &pBt[1]);
	}
}


SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename) {
	FILE *out;
	struct MemBlockHdr *pHdr;
	void **pBt;
	int i;
	out = fopen(zFilename, "w");
	if (out == 0) {
		fprintf(stderr, "** Unable to output memory debug output log: %s **\n",
			zFilename);
		return;
	}
	for (pHdr = mem.pFirst; pHdr; pHdr = pHdr->pNext) {
		char *z = (char*)pHdr;
		z -= pHdr->nBacktraceSlots * sizeof(void*) + pHdr->nTitle;
		fprintf(out, "**** %lld bytes at %p from %s ****\n",
			pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???");
		if (pHdr->nBacktrace) {
			fflush(out);
			pBt = (void**)pHdr;
			pBt -= pHdr->nBacktraceSlots;
			backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));
			fprintf(out, "\n");
		}
	}
	fprintf(out, "COUNTS:\n");
	for (i = 0; i<NCSIZE - 1; i++) {
		if (mem.nAlloc[i]) {
			fprintf(out, "   %5d: %10d %10d %10d\n",
				i * 8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);
		}
	}
	if (mem.nAlloc[NCSIZE - 1]) {
		fprintf(out, "   %5d: %10d %10d %10d\n",
			NCSIZE * 8 - 8, mem.nAlloc[NCSIZE - 1],
			mem.nCurrent[NCSIZE - 1], mem.mxCurrent[NCSIZE - 1]);
	}
	fclose(out);
}


SQLITE_PRIVATE int sqlite3MemdebugMallocCount() {
	int i;
	int nTotal = 0;
	for (i = 0; i<NCSIZE; i++) {
		nTotal += mem.nAlloc[i];
	}
	return nTotal;
}


#endif 







#ifdef SQLITE_ENABLE_MEMSYS3


#define MX_SMALL 10



#define N_HASH  61


typedef struct Mem3Block Mem3Block;
struct Mem3Block {
	union {
		struct {
			u32 prevSize;   
			u32 size4x;     
		} hdr;
		struct {
			u32 next;       
			u32 prev;       
		} list;
	} u;
};


static SQLITE_WSD struct Mem3Global {
	
	u32 nPool;
	Mem3Block *aPool;

	
	int alarmBusy;

	
	sqlite3_mutex *mutex;

	
	u32 mnMaster;

	
	u32 iMaster;
	u32 szMaster;

	
	u32 aiSmall[MX_SMALL - 1];   
	u32 aiHash[N_HASH];        
} mem3 = { 97535575 };

#define mem3 GLOBAL(struct Mem3Global, mem3)


static void memsys3UnlinkFromList(u32 i, u32 *pRoot) {
	u32 next = mem3.aPool[i].u.list.next;
	u32 prev = mem3.aPool[i].u.list.prev;
	assert(sqlite3_mutex_held(mem3.mutex));
	if (prev == 0) {
		*pRoot = next;
	}
	else {
		mem3.aPool[prev].u.list.next = next;
	}
	if (next) {
		mem3.aPool[next].u.list.prev = prev;
	}
	mem3.aPool[i].u.list.next = 0;
	mem3.aPool[i].u.list.prev = 0;
}


static void memsys3Unlink(u32 i) {
	u32 size, hash;
	assert(sqlite3_mutex_held(mem3.mutex));
	assert((mem3.aPool[i - 1].u.hdr.size4x & 1) == 0);
	assert(i >= 1);
	size = mem3.aPool[i - 1].u.hdr.size4x / 4;
	assert(size == mem3.aPool[i + size - 1].u.hdr.prevSize);
	assert(size >= 2);
	if (size <= MX_SMALL) {
		memsys3UnlinkFromList(i, &mem3.aiSmall[size - 2]);
	}
	else {
		hash = size % N_HASH;
		memsys3UnlinkFromList(i, &mem3.aiHash[hash]);
	}
}


static void memsys3LinkIntoList(u32 i, u32 *pRoot) {
	assert(sqlite3_mutex_held(mem3.mutex));
	mem3.aPool[i].u.list.next = *pRoot;
	mem3.aPool[i].u.list.prev = 0;
	if (*pRoot) {
		mem3.aPool[*pRoot].u.list.prev = i;
	}
	*pRoot = i;
}


static void memsys3Link(u32 i) {
	u32 size, hash;
	assert(sqlite3_mutex_held(mem3.mutex));
	assert(i >= 1);
	assert((mem3.aPool[i - 1].u.hdr.size4x & 1) == 0);
	size = mem3.aPool[i - 1].u.hdr.size4x / 4;
	assert(size == mem3.aPool[i + size - 1].u.hdr.prevSize);
	assert(size >= 2);
	if (size <= MX_SMALL) {
		memsys3LinkIntoList(i, &mem3.aiSmall[size - 2]);
	}
	else {
		hash = size % N_HASH;
		memsys3LinkIntoList(i, &mem3.aiHash[hash]);
	}
}


static void memsys3Enter(void) {
	if (sqlite3GlobalConfig.bMemstat == 0 && mem3.mutex == 0) {
		mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
	}
	sqlite3_mutex_enter(mem3.mutex);
}
static void memsys3Leave(void) {
	sqlite3_mutex_leave(mem3.mutex);
}


static void memsys3OutOfMemory(int nByte) {
	if (!mem3.alarmBusy) {
		mem3.alarmBusy = 1;
		assert(sqlite3_mutex_held(mem3.mutex));
		sqlite3_mutex_leave(mem3.mutex);
		sqlite3_release_memory(nByte);
		sqlite3_mutex_enter(mem3.mutex);
		mem3.alarmBusy = 0;
	}
}



static void *memsys3Checkout(u32 i, u32 nBlock) {
	u32 x;
	assert(sqlite3_mutex_held(mem3.mutex));
	assert(i >= 1);
	assert(mem3.aPool[i - 1].u.hdr.size4x / 4 == nBlock);
	assert(mem3.aPool[i + nBlock - 1].u.hdr.prevSize == nBlock);
	x = mem3.aPool[i - 1].u.hdr.size4x;
	mem3.aPool[i - 1].u.hdr.size4x = nBlock * 4 | 1 | (x & 2);
	mem3.aPool[i + nBlock - 1].u.hdr.prevSize = nBlock;
	mem3.aPool[i + nBlock - 1].u.hdr.size4x |= 2;
	return &mem3.aPool[i];
}


static void *memsys3FromMaster(u32 nBlock) {
	assert(sqlite3_mutex_held(mem3.mutex));
	assert(mem3.szMaster >= nBlock);
	if (nBlock >= mem3.szMaster - 1) {
		
		void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster);
		mem3.iMaster = 0;
		mem3.szMaster = 0;
		mem3.mnMaster = 0;
		return p;
	}
	else {
		
		u32 newi, x;
		newi = mem3.iMaster + mem3.szMaster - nBlock;
		assert(newi > mem3.iMaster + 1);
		mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.prevSize = nBlock;
		mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.size4x |= 2;
		mem3.aPool[newi - 1].u.hdr.size4x = nBlock * 4 + 1;
		mem3.szMaster -= nBlock;
		mem3.aPool[newi - 1].u.hdr.prevSize = mem3.szMaster;
		x = mem3.aPool[mem3.iMaster - 1].u.hdr.size4x & 2;
		mem3.aPool[mem3.iMaster - 1].u.hdr.size4x = mem3.szMaster * 4 | x;
		if (mem3.szMaster < mem3.mnMaster) {
			mem3.mnMaster = mem3.szMaster;
		}
		return (void*)&mem3.aPool[newi];
	}
}


static void memsys3Merge(u32 *pRoot) {
	u32 iNext, prev, size, i, x;

	assert(sqlite3_mutex_held(mem3.mutex));
	for (i = *pRoot; i>0; i = iNext) {
		iNext = mem3.aPool[i].u.list.next;
		size = mem3.aPool[i - 1].u.hdr.size4x;
		assert((size & 1) == 0);
		if ((size & 2) == 0) {
			memsys3UnlinkFromList(i, pRoot);
			assert(i > mem3.aPool[i - 1].u.hdr.prevSize);
			prev = i - mem3.aPool[i - 1].u.hdr.prevSize;
			if (prev == iNext) {
				iNext = mem3.aPool[prev].u.list.next;
			}
			memsys3Unlink(prev);
			size = i + size / 4 - prev;
			x = mem3.aPool[prev - 1].u.hdr.size4x & 2;
			mem3.aPool[prev - 1].u.hdr.size4x = size * 4 | x;
			mem3.aPool[prev + size - 1].u.hdr.prevSize = size;
			memsys3Link(prev);
			i = prev;
		}
		else {
			size /= 4;
		}
		if (size>mem3.szMaster) {
			mem3.iMaster = i;
			mem3.szMaster = size;
		}
	}
}


static void *memsys3MallocUnsafe(int nByte) {
	u32 i;
	u32 nBlock;
	u32 toFree;

	assert(sqlite3_mutex_held(mem3.mutex));
	assert(sizeof(Mem3Block) == 8);
	if (nByte <= 12) {
		nBlock = 2;
	}
	else {
		nBlock = (nByte + 11) / 8;
	}
	assert(nBlock >= 2);

	
	if (nBlock <= MX_SMALL) {
		i = mem3.aiSmall[nBlock - 2];
		if (i>0) {
			memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock - 2]);
			return memsys3Checkout(i, nBlock);
		}
	}
	else {
		int hash = nBlock % N_HASH;
		for (i = mem3.aiHash[hash]; i>0; i = mem3.aPool[i].u.list.next) {
			if (mem3.aPool[i - 1].u.hdr.size4x / 4 == nBlock) {
				memsys3UnlinkFromList(i, &mem3.aiHash[hash]);
				return memsys3Checkout(i, nBlock);
			}
		}
	}

	
	if (mem3.szMaster >= nBlock) {
		return memsys3FromMaster(nBlock);
	}


	
	for (toFree = nBlock * 16; toFree<(mem3.nPool * 16); toFree *= 2) {
		memsys3OutOfMemory(toFree);
		if (mem3.iMaster) {
			memsys3Link(mem3.iMaster);
			mem3.iMaster = 0;
			mem3.szMaster = 0;
		}
		for (i = 0; i<N_HASH; i++) {
			memsys3Merge(&mem3.aiHash[i]);
		}
		for (i = 0; i<MX_SMALL - 1; i++) {
			memsys3Merge(&mem3.aiSmall[i]);
		}
		if (mem3.szMaster) {
			memsys3Unlink(mem3.iMaster);
			if (mem3.szMaster >= nBlock) {
				return memsys3FromMaster(nBlock);
			}
		}
	}

	
	return 0;
}


static void memsys3FreeUnsafe(void *pOld) {
	Mem3Block *p = (Mem3Block*)pOld;
	int i;
	u32 size, x;
	assert(sqlite3_mutex_held(mem3.mutex));
	assert(p>mem3.aPool && p<&mem3.aPool[mem3.nPool]);
	i = p - mem3.aPool;
	assert((mem3.aPool[i - 1].u.hdr.size4x & 1) == 1);
	size = mem3.aPool[i - 1].u.hdr.size4x / 4;
	assert(i + size <= mem3.nPool + 1);
	mem3.aPool[i - 1].u.hdr.size4x &= ~1;
	mem3.aPool[i + size - 1].u.hdr.prevSize = size;
	mem3.aPool[i + size - 1].u.hdr.size4x &= ~2;
	memsys3Link(i);

	
	if (mem3.iMaster) {
		while ((mem3.aPool[mem3.iMaster - 1].u.hdr.size4x & 2) == 0) {
			size = mem3.aPool[mem3.iMaster - 1].u.hdr.prevSize;
			mem3.iMaster -= size;
			mem3.szMaster += size;
			memsys3Unlink(mem3.iMaster);
			x = mem3.aPool[mem3.iMaster - 1].u.hdr.size4x & 2;
			mem3.aPool[mem3.iMaster - 1].u.hdr.size4x = mem3.szMaster * 4 | x;
			mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.prevSize = mem3.szMaster;
		}
		x = mem3.aPool[mem3.iMaster - 1].u.hdr.size4x & 2;
		while ((mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.size4x & 1) == 0) {
			memsys3Unlink(mem3.iMaster + mem3.szMaster);
			mem3.szMaster += mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.size4x / 4;
			mem3.aPool[mem3.iMaster - 1].u.hdr.size4x = mem3.szMaster * 4 | x;
			mem3.aPool[mem3.iMaster + mem3.szMaster - 1].u.hdr.prevSize = mem3.szMaster;
		}
	}
}


static int memsys3Size(void *p) {
	Mem3Block *pBlock;
	assert(p != 0);
	pBlock = (Mem3Block*)p;
	assert((pBlock[-1].u.hdr.size4x & 1) != 0);
	return (pBlock[-1].u.hdr.size4x&~3) * 2 - 4;
}


static int memsys3Roundup(int n) {
	if (n <= 12) {
		return 12;
	}
	else {
		return ((n + 11)&~7) - 4;
	}
}


static void *memsys3Malloc(int nBytes) {
	sqlite3_int64 *p;
	assert(nBytes>0);          
	memsys3Enter();
	p = memsys3MallocUnsafe(nBytes);
	memsys3Leave();
	return (void*)p;
}


static void memsys3Free(void *pPrior) {
	assert(pPrior);
	memsys3Enter();
	memsys3FreeUnsafe(pPrior);
	memsys3Leave();
}


static void *memsys3Realloc(void *pPrior, int nBytes) {
	int nOld;
	void *p;
	if (pPrior == 0) {
		return sqlite3_malloc(nBytes);
	}
	if (nBytes <= 0) {
		sqlite3_free(pPrior);
		return 0;
	}
	nOld = memsys3Size(pPrior);
	if (nBytes <= nOld && nBytes >= nOld - 128) {
		return pPrior;
	}
	memsys3Enter();
	p = memsys3MallocUnsafe(nBytes);
	if (p) {
		if (nOld<nBytes) {
			memcpy(p, pPrior, nOld);
		}
		else {
			memcpy(p, pPrior, nBytes);
		}
		memsys3FreeUnsafe(pPrior);
	}
	memsys3Leave();
	return p;
}


static int memsys3Init(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	if (!sqlite3GlobalConfig.pHeap) {
		return SQLITE_ERROR;
	}

	
	assert(sizeof(Mem3Block) == 8);
	mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap;
	mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2;

	
	mem3.szMaster = mem3.nPool;
	mem3.mnMaster = mem3.szMaster;
	mem3.iMaster = 1;
	mem3.aPool[0].u.hdr.size4x = (mem3.szMaster << 2) + 2;
	mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool;
	mem3.aPool[mem3.nPool].u.hdr.size4x = 1;

	return SQLITE_OK;
}


static void memsys3Shutdown(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	mem3.mutex = 0;
	return;
}




SQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename) {
#ifdef SQLITE_DEBUG
	FILE *out;
	u32 i, j;
	u32 size;
	if (zFilename == 0 || zFilename[0] == 0) {
		out = stdout;
	}
	else {
		out = fopen(zFilename, "w");
		if (out == 0) {
			fprintf(stderr, "** Unable to output memory debug output log: %s **\n",
				zFilename);
			return;
		}
	}
	memsys3Enter();
	fprintf(out, "CHUNKS:\n");
	for (i = 1; i <= mem3.nPool; i += size / 4) {
		size = mem3.aPool[i - 1].u.hdr.size4x;
		if (size / 4 <= 1) {
			fprintf(out, "%p size error\n", &mem3.aPool[i]);
			assert(0);
			break;
		}
		if ((size & 1) == 0 && mem3.aPool[i + size / 4 - 1].u.hdr.prevSize != size / 4) {
			fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]);
			assert(0);
			break;
		}
		if (((mem3.aPool[i + size / 4 - 1].u.hdr.size4x & 2) >> 1) != (size & 1)) {
			fprintf(out, "%p tail checkout bit is incorrect\n", &mem3.aPool[i]);
			assert(0);
			break;
		}
		if (size & 1) {
			fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size / 4) * 8 - 8);
		}
		else {
			fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size / 4) * 8 - 8,
				i == mem3.iMaster ? " **master**" : "");
		}
	}
	for (i = 0; i<MX_SMALL - 1; i++) {
		if (mem3.aiSmall[i] == 0) continue;
		fprintf(out, "small(%2d):", i);
		for (j = mem3.aiSmall[i]; j>0; j = mem3.aPool[j].u.list.next) {
			fprintf(out, " %p(%d)", &mem3.aPool[j],
				(mem3.aPool[j - 1].u.hdr.size4x / 4) * 8 - 8);
		}
		fprintf(out, "\n");
	}
	for (i = 0; i<N_HASH; i++) {
		if (mem3.aiHash[i] == 0) continue;
		fprintf(out, "hash(%2d):", i);
		for (j = mem3.aiHash[i]; j>0; j = mem3.aPool[j].u.list.next) {
			fprintf(out, " %p(%d)", &mem3.aPool[j],
				(mem3.aPool[j - 1].u.hdr.size4x / 4) * 8 - 8);
		}
		fprintf(out, "\n");
	}
	fprintf(out, "master=%d\n", mem3.iMaster);
	fprintf(out, "nowUsed=%d\n", mem3.nPool * 8 - mem3.szMaster * 8);
	fprintf(out, "mxUsed=%d\n", mem3.nPool * 8 - mem3.mnMaster * 8);
	sqlite3_mutex_leave(mem3.mutex);
	if (out == stdout) {
		fflush(stdout);
	}
	else {
		fclose(out);
	}
#else
	UNUSED_PARAMETER(zFilename);
#endif
}


SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void) {
	static const sqlite3_mem_methods mempoolMethods = {
		memsys3Malloc,
		memsys3Free,
		memsys3Realloc,
		memsys3Size,
		memsys3Roundup,
		memsys3Init,
		memsys3Shutdown,
		0
	};
	return &mempoolMethods;
}

#endif 







#ifdef SQLITE_ENABLE_MEMSYS5


typedef struct Mem5Link Mem5Link;
struct Mem5Link {
	int next;       
	int prev;       
};


#define LOGMAX 30


#define CTRL_LOGSIZE  0x1f    
#define CTRL_FREE     0x20    


static SQLITE_WSD struct Mem5Global {
	
	int szAtom;      
	int nBlock;      
	u8 *zPool;       

					 
	sqlite3_mutex *mutex;

#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	
	u64 nAlloc;         
	u64 totalAlloc;     
	u64 totalExcess;    
	u32 currentOut;     
	u32 currentCount;   
	u32 maxOut;         
	u32 maxCount;       
	u32 maxRequest;     
#endif

						
	int aiFreelist[LOGMAX + 1];

	
	u8 *aCtrl;

} mem5;


#define mem5 GLOBAL(struct Mem5Global, mem5)


#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.szAtom]))


static void memsys5Unlink(int i, int iLogsize) {
	int next, prev;
	assert(i >= 0 && i<mem5.nBlock);
	assert(iLogsize >= 0 && iLogsize <= LOGMAX);
	assert((mem5.aCtrl[i] & CTRL_LOGSIZE) == iLogsize);

	next = MEM5LINK(i)->next;
	prev = MEM5LINK(i)->prev;
	if (prev<0) {
		mem5.aiFreelist[iLogsize] = next;
	}
	else {
		MEM5LINK(prev)->next = next;
	}
	if (next >= 0) {
		MEM5LINK(next)->prev = prev;
	}
}


static void memsys5Link(int i, int iLogsize) {
	int x;
	assert(sqlite3_mutex_held(mem5.mutex));
	assert(i >= 0 && i<mem5.nBlock);
	assert(iLogsize >= 0 && iLogsize <= LOGMAX);
	assert((mem5.aCtrl[i] & CTRL_LOGSIZE) == iLogsize);

	x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize];
	MEM5LINK(i)->prev = -1;
	if (x >= 0) {
		assert(x<mem5.nBlock);
		MEM5LINK(x)->prev = i;
	}
	mem5.aiFreelist[iLogsize] = i;
}


static void memsys5Enter(void) {
	sqlite3_mutex_enter(mem5.mutex);
}
static void memsys5Leave(void) {
	sqlite3_mutex_leave(mem5.mutex);
}


static int memsys5Size(void *p) {
	int iSize, i;
	assert(p != 0);
	i = (int)(((u8 *)p - mem5.zPool) / mem5.szAtom);
	assert(i >= 0 && i<mem5.nBlock);
	iSize = mem5.szAtom * (1 << (mem5.aCtrl[i] & CTRL_LOGSIZE));
	return iSize;
}


static void *memsys5MallocUnsafe(int nByte) {
	int i;           
	int iBin;        
	int iFullSz;     
	int iLogsize;    

					 
	assert(nByte>0);

	
	if (nByte > 0x40000000) return 0;

#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	
	if ((u32)nByte>mem5.maxRequest) {
		mem5.maxRequest = nByte;
	}
#endif


	
	for (iFullSz = mem5.szAtom, iLogsize = 0; iFullSz<nByte; iFullSz *= 2, iLogsize++) {}

	
	for (iBin = iLogsize; iBin <= LOGMAX && mem5.aiFreelist[iBin]<0; iBin++) {}
	if (iBin>LOGMAX) {
		testcase(sqlite3GlobalConfig.xLog != 0);
		sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes", nByte);
		return 0;
	}
	i = mem5.aiFreelist[iBin];
	memsys5Unlink(i, iBin);
	while (iBin>iLogsize) {
		int newSize;

		iBin--;
		newSize = 1 << iBin;
		mem5.aCtrl[i + newSize] = CTRL_FREE | iBin;
		memsys5Link(i + newSize, iBin);
	}
	mem5.aCtrl[i] = iLogsize;

#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	
	mem5.nAlloc++;
	mem5.totalAlloc += iFullSz;
	mem5.totalExcess += iFullSz - nByte;
	mem5.currentCount++;
	mem5.currentOut += iFullSz;
	if (mem5.maxCount<mem5.currentCount) mem5.maxCount = mem5.currentCount;
	if (mem5.maxOut<mem5.currentOut) mem5.maxOut = mem5.currentOut;
#endif

#ifdef SQLITE_DEBUG
	
	memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);
#endif

	
	return (void*)&mem5.zPool[i*mem5.szAtom];
}


static void memsys5FreeUnsafe(void *pOld) {
	u32 size, iLogsize;
	int iBlock;

	
	iBlock = (int)(((u8 *)pOld - mem5.zPool) / mem5.szAtom);

	
	assert(iBlock >= 0 && iBlock<mem5.nBlock);
	assert(((u8 *)pOld - mem5.zPool) % mem5.szAtom == 0);
	assert((mem5.aCtrl[iBlock] & CTRL_FREE) == 0);

	iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE;
	size = 1 << iLogsize;
	assert(iBlock + size - 1<(u32)mem5.nBlock);

	mem5.aCtrl[iBlock] |= CTRL_FREE;
	mem5.aCtrl[iBlock + size - 1] |= CTRL_FREE;

#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	assert(mem5.currentCount>0);
	assert(mem5.currentOut >= (size*mem5.szAtom));
	mem5.currentCount--;
	mem5.currentOut -= size*mem5.szAtom;
	assert(mem5.currentOut>0 || mem5.currentCount == 0);
	assert(mem5.currentCount>0 || mem5.currentOut == 0);
#endif

	mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;
	while (ALWAYS(iLogsize<LOGMAX)) {
		int iBuddy;
		if ((iBlock >> iLogsize) & 1) {
			iBuddy = iBlock - size;
			assert(iBuddy >= 0);
		}
		else {
			iBuddy = iBlock + size;
			if (iBuddy >= mem5.nBlock) break;
		}
		if (mem5.aCtrl[iBuddy] != (CTRL_FREE | iLogsize)) break;
		memsys5Unlink(iBuddy, iLogsize);
		iLogsize++;
		if (iBuddy<iBlock) {
			mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize;
			mem5.aCtrl[iBlock] = 0;
			iBlock = iBuddy;
		}
		else {
			mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;
			mem5.aCtrl[iBuddy] = 0;
		}
		size *= 2;
	}

#ifdef SQLITE_DEBUG
	
	memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);
#endif

	memsys5Link(iBlock, iLogsize);
}


static void *memsys5Malloc(int nBytes) {
	sqlite3_int64 *p = 0;
	if (nBytes>0) {
		memsys5Enter();
		p = memsys5MallocUnsafe(nBytes);
		memsys5Leave();
	}
	return (void*)p;
}


static void memsys5Free(void *pPrior) {
	assert(pPrior != 0);
	memsys5Enter();
	memsys5FreeUnsafe(pPrior);
	memsys5Leave();
}


static void *memsys5Realloc(void *pPrior, int nBytes) {
	int nOld;
	void *p;
	assert(pPrior != 0);
	assert((nBytes&(nBytes - 1)) == 0);  
	assert(nBytes >= 0);
	if (nBytes == 0) {
		return 0;
	}
	nOld = memsys5Size(pPrior);
	if (nBytes <= nOld) {
		return pPrior;
	}
	p = memsys5Malloc(nBytes);
	if (p) {
		memcpy(p, pPrior, nOld);
		memsys5Free(pPrior);
	}
	return p;
}


static int memsys5Roundup(int n) {
	int iFullSz;
	if (n > 0x40000000) return 0;
	for (iFullSz = mem5.szAtom; iFullSz<n; iFullSz *= 2);
	return iFullSz;
}


static int memsys5Log(int iValue) {
	int iLog;
	for (iLog = 0; (iLog<(int)((sizeof(int) * 8) - 1)) && (1 << iLog)<iValue; iLog++);
	return iLog;
}


static int memsys5Init(void *NotUsed) {
	int ii;            
	int nByte;         
	u8 *zByte;         
	int nMinLog;       
	int iOffset;       

	UNUSED_PARAMETER(NotUsed);

	
	mem5.mutex = 0;

	
	assert((sizeof(Mem5Link)&(sizeof(Mem5Link) - 1)) == 0);

	nByte = sqlite3GlobalConfig.nHeap;
	zByte = (u8*)sqlite3GlobalConfig.pHeap;
	assert(zByte != 0);  

						 
	nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);
	mem5.szAtom = (1 << nMinLog);
	while ((int)sizeof(Mem5Link)>mem5.szAtom) {
		mem5.szAtom = mem5.szAtom << 1;
	}

	mem5.nBlock = (nByte / (mem5.szAtom + sizeof(u8)));
	mem5.zPool = zByte;
	mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.szAtom];

	for (ii = 0; ii <= LOGMAX; ii++) {
		mem5.aiFreelist[ii] = -1;
	}

	iOffset = 0;
	for (ii = LOGMAX; ii >= 0; ii--) {
		int nAlloc = (1 << ii);
		if ((iOffset + nAlloc) <= mem5.nBlock) {
			mem5.aCtrl[iOffset] = ii | CTRL_FREE;
			memsys5Link(iOffset, ii);
			iOffset += nAlloc;
		}
		assert((iOffset + nAlloc)>mem5.nBlock);
	}

	
	if (sqlite3GlobalConfig.bMemstat == 0) {
		mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
	}

	return SQLITE_OK;
}


static void memsys5Shutdown(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	mem5.mutex = 0;
	return;
}

#ifdef SQLITE_TEST

SQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename) {
	FILE *out;
	int i, j, n;
	int nMinLog;

	if (zFilename == 0 || zFilename[0] == 0) {
		out = stdout;
	}
	else {
		out = fopen(zFilename, "w");
		if (out == 0) {
			fprintf(stderr, "** Unable to output memory debug output log: %s **\n",
				zFilename);
			return;
		}
	}
	memsys5Enter();
	nMinLog = memsys5Log(mem5.szAtom);
	for (i = 0; i <= LOGMAX && i + nMinLog<32; i++) {
		for (n = 0, j = mem5.aiFreelist[i]; j >= 0; j = MEM5LINK(j)->next, n++) {}
		fprintf(out, "freelist items of size %d: %d\n", mem5.szAtom << i, n);
	}
	fprintf(out, "mem5.nAlloc       = %llu\n", mem5.nAlloc);
	fprintf(out, "mem5.totalAlloc   = %llu\n", mem5.totalAlloc);
	fprintf(out, "mem5.totalExcess  = %llu\n", mem5.totalExcess);
	fprintf(out, "mem5.currentOut   = %u\n", mem5.currentOut);
	fprintf(out, "mem5.currentCount = %u\n", mem5.currentCount);
	fprintf(out, "mem5.maxOut       = %u\n", mem5.maxOut);
	fprintf(out, "mem5.maxCount     = %u\n", mem5.maxCount);
	fprintf(out, "mem5.maxRequest   = %u\n", mem5.maxRequest);
	memsys5Leave();
	if (out == stdout) {
		fflush(stdout);
	}
	else {
		fclose(out);
	}
}
#endif


SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void) {
	static const sqlite3_mem_methods memsys5Methods = {
		memsys5Malloc,
		memsys5Free,
		memsys5Realloc,
		memsys5Size,
		memsys5Roundup,
		memsys5Init,
		memsys5Shutdown,
		0
	};
	return &memsys5Methods;
}

#endif 






#if defined(SQLITE_DEBUG) && !defined(SQLITE_MUTEX_OMIT)

static SQLITE_WSD int mutexIsInit = 0;
#endif 


#ifndef SQLITE_MUTEX_OMIT

SQLITE_PRIVATE int sqlite3MutexInit(void) {
	int rc = SQLITE_OK;
	if (!sqlite3GlobalConfig.mutex.xMutexAlloc) {
		
		sqlite3_mutex_methods const *pFrom;
		sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex;

		if (sqlite3GlobalConfig.bCoreMutex) {
			pFrom = sqlite3DefaultMutex();
		}
		else {
			pFrom = sqlite3NoopMutex();
		}
		pTo->xMutexInit = pFrom->xMutexInit;
		pTo->xMutexEnd = pFrom->xMutexEnd;
		pTo->xMutexFree = pFrom->xMutexFree;
		pTo->xMutexEnter = pFrom->xMutexEnter;
		pTo->xMutexTry = pFrom->xMutexTry;
		pTo->xMutexLeave = pFrom->xMutexLeave;
		pTo->xMutexHeld = pFrom->xMutexHeld;
		pTo->xMutexNotheld = pFrom->xMutexNotheld;
		sqlite3MemoryBarrier();
		pTo->xMutexAlloc = pFrom->xMutexAlloc;
	}
	assert(sqlite3GlobalConfig.mutex.xMutexInit);
	rc = sqlite3GlobalConfig.mutex.xMutexInit();

#ifdef SQLITE_DEBUG
	GLOBAL(int, mutexIsInit) = 1;
#endif

	return rc;
}


SQLITE_PRIVATE int sqlite3MutexEnd(void) {
	int rc = SQLITE_OK;
	if (sqlite3GlobalConfig.mutex.xMutexEnd) {
		rc = sqlite3GlobalConfig.mutex.xMutexEnd();
	}

#ifdef SQLITE_DEBUG
	GLOBAL(int, mutexIsInit) = 0;
#endif

	return rc;
}


SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (id <= SQLITE_MUTEX_RECURSIVE && sqlite3_initialize()) return 0;
	if (id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit()) return 0;
#endif
	assert(sqlite3GlobalConfig.mutex.xMutexAlloc);
	return sqlite3GlobalConfig.mutex.xMutexAlloc(id);
}

SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id) {
	if (!sqlite3GlobalConfig.bCoreMutex) {
		return 0;
	}
	assert(GLOBAL(int, mutexIsInit));
	assert(sqlite3GlobalConfig.mutex.xMutexAlloc);
	return sqlite3GlobalConfig.mutex.xMutexAlloc(id);
}


SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p) {
	if (p) {
		assert(sqlite3GlobalConfig.mutex.xMutexFree);
		sqlite3GlobalConfig.mutex.xMutexFree(p);
	}
}


SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p) {
	if (p) {
		assert(sqlite3GlobalConfig.mutex.xMutexEnter);
		sqlite3GlobalConfig.mutex.xMutexEnter(p);
	}
}


SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p) {
	int rc = SQLITE_OK;
	if (p) {
		assert(sqlite3GlobalConfig.mutex.xMutexTry);
		return sqlite3GlobalConfig.mutex.xMutexTry(p);
	}
	return rc;
}


SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p) {
	if (p) {
		assert(sqlite3GlobalConfig.mutex.xMutexLeave);
		sqlite3GlobalConfig.mutex.xMutexLeave(p);
	}
}

#ifndef NDEBUG

SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p) {
	assert(p == 0 || sqlite3GlobalConfig.mutex.xMutexHeld);
	return p == 0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);
}
SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p) {
	assert(p == 0 || sqlite3GlobalConfig.mutex.xMutexNotheld);
	return p == 0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);
}
#endif

#endif 






#ifndef SQLITE_MUTEX_OMIT

#ifndef SQLITE_DEBUG

static int noopMutexInit(void) { return SQLITE_OK; }
static int noopMutexEnd(void) { return SQLITE_OK; }
static sqlite3_mutex *noopMutexAlloc(int id) {
	UNUSED_PARAMETER(id);
	return (sqlite3_mutex*)8;
}
static void noopMutexFree(sqlite3_mutex *p) { UNUSED_PARAMETER(p); return; }
static void noopMutexEnter(sqlite3_mutex *p) { UNUSED_PARAMETER(p); return; }
static int noopMutexTry(sqlite3_mutex *p) {
	UNUSED_PARAMETER(p);
	return SQLITE_OK;
}
static void noopMutexLeave(sqlite3_mutex *p) { UNUSED_PARAMETER(p); return; }

SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void) {
	static const sqlite3_mutex_methods sMutex = {
		noopMutexInit,
		noopMutexEnd,
		noopMutexAlloc,
		noopMutexFree,
		noopMutexEnter,
		noopMutexTry,
		noopMutexLeave,

		0,
		0,
	};

	return &sMutex;
}
#endif 

#ifdef SQLITE_DEBUG



typedef struct sqlite3_debug_mutex {
	int id;     
	int cnt;    
} sqlite3_debug_mutex;


static int debugMutexHeld(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	return p == 0 || p->cnt>0;
}
static int debugMutexNotheld(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	return p == 0 || p->cnt == 0;
}


static int debugMutexInit(void) { return SQLITE_OK; }
static int debugMutexEnd(void) { return SQLITE_OK; }


static sqlite3_mutex *debugMutexAlloc(int id) {
	static sqlite3_debug_mutex aStatic[SQLITE_MUTEX_STATIC_VFS3 - 1];
	sqlite3_debug_mutex *pNew = 0;
	switch (id) {
	case SQLITE_MUTEX_FAST:
	case SQLITE_MUTEX_RECURSIVE: {
		pNew = sqlite3Malloc(sizeof(*pNew));
		if (pNew) {
			pNew->id = id;
			pNew->cnt = 0;
		}
		break;
	}
	default: {
#ifdef SQLITE_ENABLE_API_ARMOR
		if (id - 2<0 || id - 2 >= ArraySize(aStatic)) {
			(void)SQLITE_MISUSE_BKPT;
			return 0;
		}
#endif
		pNew = &aStatic[id - 2];
		pNew->id = id;
		break;
	}
	}
	return (sqlite3_mutex*)pNew;
}


static void debugMutexFree(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	assert(p->cnt == 0);
	if (p->id == SQLITE_MUTEX_RECURSIVE || p->id == SQLITE_MUTEX_FAST) {
		sqlite3_free(p);
	}
	else {
#ifdef SQLITE_ENABLE_API_ARMOR
		(void)SQLITE_MISUSE_BKPT;
#endif
	}
}


static void debugMutexEnter(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	assert(p->id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX));
	p->cnt++;
}
static int debugMutexTry(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	assert(p->id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX));
	p->cnt++;
	return SQLITE_OK;
}


static void debugMutexLeave(sqlite3_mutex *pX) {
	sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
	assert(debugMutexHeld(pX));
	p->cnt--;
	assert(p->id == SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX));
}

SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void) {
	static const sqlite3_mutex_methods sMutex = {
		debugMutexInit,
		debugMutexEnd,
		debugMutexAlloc,
		debugMutexFree,
		debugMutexEnter,
		debugMutexTry,
		debugMutexLeave,

		debugMutexHeld,
		debugMutexNotheld
	};

	return &sMutex;
}
#endif 


#ifdef SQLITE_MUTEX_NOOP
SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void) {
	return sqlite3NoopMutex();
}
#endif 
#endif 







#ifdef SQLITE_MUTEX_PTHREADS

#include <pthread.h>


#if defined(SQLITE_DEBUG) || defined(SQLITE_HOMEGROWN_RECURSIVE_MUTEX)
# define SQLITE_MUTEX_NREF 1
#else
# define SQLITE_MUTEX_NREF 0
#endif


struct sqlite3_mutex {
	pthread_mutex_t mutex;     
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
	int id;                    
#endif
#if SQLITE_MUTEX_NREF
	volatile int nRef;         
	volatile pthread_t owner;  
	int trace;                 
#endif
};
#if SQLITE_MUTEX_NREF
#define SQLITE3_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER,0,0,(pthread_t)0,0}
#elif defined(SQLITE_ENABLE_API_ARMOR)
#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, 0 }
#else
#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
#endif


#if !defined(NDEBUG) || defined(SQLITE_DEBUG)
static int pthreadMutexHeld(sqlite3_mutex *p) {
	return (p->nRef != 0 && pthread_equal(p->owner, pthread_self()));
}
static int pthreadMutexNotheld(sqlite3_mutex *p) {
	return p->nRef == 0 || pthread_equal(p->owner, pthread_self()) == 0;
}
#endif


SQLITE_PRIVATE void sqlite3MemoryBarrier(void) {
#if defined(SQLITE_MEMORY_BARRIER)
	SQLITE_MEMORY_BARRIER;
#elif defined(__GNUC__) && GCC_VERSION>=4001000
	__sync_synchronize();
#endif
}


static int pthreadMutexInit(void) { return SQLITE_OK; }
static int pthreadMutexEnd(void) { return SQLITE_OK; }


static sqlite3_mutex *pthreadMutexAlloc(int iType) {
	static sqlite3_mutex staticMutexes[] = {
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER,
		SQLITE3_MUTEX_INITIALIZER
	};
	sqlite3_mutex *p;
	switch (iType) {
	case SQLITE_MUTEX_RECURSIVE: {
		p = sqlite3MallocZero(sizeof(*p));
		if (p) {
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
			
			pthread_mutex_init(&p->mutex, 0);
#else
			
			pthread_mutexattr_t recursiveAttr;
			pthread_mutexattr_init(&recursiveAttr);
			pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);
			pthread_mutex_init(&p->mutex, &recursiveAttr);
			pthread_mutexattr_destroy(&recursiveAttr);
#endif
		}
		break;
	}
	case SQLITE_MUTEX_FAST: {
		p = sqlite3MallocZero(sizeof(*p));
		if (p) {
			pthread_mutex_init(&p->mutex, 0);
		}
		break;
	}
	default: {
#ifdef SQLITE_ENABLE_API_ARMOR
		if (iType - 2<0 || iType - 2 >= ArraySize(staticMutexes)) {
			(void)SQLITE_MISUSE_BKPT;
			return 0;
		}
#endif
		p = &staticMutexes[iType - 2];
		break;
	}
	}
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
	if (p) p->id = iType;
#endif
	return p;
}



static void pthreadMutexFree(sqlite3_mutex *p) {
	assert(p->nRef == 0);
#if SQLITE_ENABLE_API_ARMOR
	if (p->id == SQLITE_MUTEX_FAST || p->id == SQLITE_MUTEX_RECURSIVE)
#endif
	{
		pthread_mutex_destroy(&p->mutex);
		sqlite3_free(p);
	}
#ifdef SQLITE_ENABLE_API_ARMOR
	else {
		(void)SQLITE_MISUSE_BKPT;
	}
#endif
}


static void pthreadMutexEnter(sqlite3_mutex *p) {
	assert(p->id == SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p));

#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
	
	{
		pthread_t self = pthread_self();
		if (p->nRef>0 && pthread_equal(p->owner, self)) {
			p->nRef++;
		}
		else {
			pthread_mutex_lock(&p->mutex);
			assert(p->nRef == 0);
			p->owner = self;
			p->nRef = 1;
		}
	}
#else
	
	pthread_mutex_lock(&p->mutex);
#if SQLITE_MUTEX_NREF
	assert(p->nRef>0 || p->owner == 0);
	p->owner = pthread_self();
	p->nRef++;
#endif
#endif

#ifdef SQLITE_DEBUG
	if (p->trace) {
		printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
	}
#endif
}
static int pthreadMutexTry(sqlite3_mutex *p) {
	int rc;
	assert(p->id == SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p));

#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
	
	{
		pthread_t self = pthread_self();
		if (p->nRef>0 && pthread_equal(p->owner, self)) {
			p->nRef++;
			rc = SQLITE_OK;
		}
		else if (pthread_mutex_trylock(&p->mutex) == 0) {
			assert(p->nRef == 0);
			p->owner = self;
			p->nRef = 1;
			rc = SQLITE_OK;
		}
		else {
			rc = SQLITE_BUSY;
		}
	}
#else
	
	if (pthread_mutex_trylock(&p->mutex) == 0) {
#if SQLITE_MUTEX_NREF
		p->owner = pthread_self();
		p->nRef++;
#endif
		rc = SQLITE_OK;
	}
	else {
		rc = SQLITE_BUSY;
	}
#endif

#ifdef SQLITE_DEBUG
	if (rc == SQLITE_OK && p->trace) {
		printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
	}
#endif
	return rc;
}


static void pthreadMutexLeave(sqlite3_mutex *p) {
	assert(pthreadMutexHeld(p));
#if SQLITE_MUTEX_NREF
	p->nRef--;
	if (p->nRef == 0) p->owner = 0;
#endif
	assert(p->nRef == 0 || p->id == SQLITE_MUTEX_RECURSIVE);

#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
	if (p->nRef == 0) {
		pthread_mutex_unlock(&p->mutex);
	}
#else
	pthread_mutex_unlock(&p->mutex);
#endif

#ifdef SQLITE_DEBUG
	if (p->trace) {
		printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
	}
#endif
}

SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void) {
	static const sqlite3_mutex_methods sMutex = {
		pthreadMutexInit,
		pthreadMutexEnd,
		pthreadMutexAlloc,
		pthreadMutexFree,
		pthreadMutexEnter,
		pthreadMutexTry,
		pthreadMutexLeave,
#ifdef SQLITE_DEBUG
		pthreadMutexHeld,
		pthreadMutexNotheld
#else
		0,
		0
#endif
	};

	return &sMutex;
}

#endif 






#if SQLITE_OS_WIN




#ifndef _OS_COMMON_H_
#define _OS_COMMON_H_


#ifdef MEMORY_DEBUG
# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
#endif


#ifdef SQLITE_PERFORMANCE_TRACE





#ifndef SQLITE_HWTIME_H
#define SQLITE_HWTIME_H


#if (defined(__GNUC__) || defined(_MSC_VER)) && \
      (defined(i386) || defined(__i386__) || defined(_M_IX86))

#if defined(__GNUC__)

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned int lo, hi;
	__asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
	return (sqlite_uint64)hi << 32 | lo;
}

#elif defined(_MSC_VER)

__declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void) {
	__asm {
		rdtsc
		ret; return value at EDX : EAX
	}
}

#endif

#elif (defined(__GNUC__) && defined(__x86_64__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long val;
	__asm__ __volatile__("rdtsc" : "=A" (val));
	return val;
}

#elif (defined(__GNUC__) && defined(__ppc__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long long retval;
	unsigned long junk;
	__asm__ __volatile__("\n\
          1:      mftbu   %1\n\
                  mftb    %L0\n\
                  mftbu   %0\n\
                  cmpw    %0,%1\n\
                  bne     1b"
		: "=r" (retval), "=r" (junk));
	return retval;
}

#else

#error Need implementation of sqlite3Hwtime() for your platform.


SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void) { return ((sqlite_uint64)0); }

#endif

#endif 




static sqlite_uint64 g_start;
static sqlite_uint64 g_elapsed;
#define TIMER_START       g_start=sqlite3Hwtime()
#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start
#define TIMER_ELAPSED     g_elapsed
#else
#define TIMER_START
#define TIMER_END
#define TIMER_ELAPSED     ((sqlite_uint64)0)
#endif


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_io_error_hit;
SQLITE_API extern int sqlite3_io_error_hardhit;
SQLITE_API extern int sqlite3_io_error_pending;
SQLITE_API extern int sqlite3_io_error_persist;
SQLITE_API extern int sqlite3_io_error_benign;
SQLITE_API extern int sqlite3_diskfull_pending;
SQLITE_API extern int sqlite3_diskfull;
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)
#define SimulateIOError(CODE)  \
  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \
       || sqlite3_io_error_pending-- == 1 )  \
              { local_ioerr(); CODE; }
static void local_ioerr() {
	IOTRACE(("IOERR\n"));
	sqlite3_io_error_hit++;
	if (!sqlite3_io_error_benign) sqlite3_io_error_hardhit++;
}
#define SimulateDiskfullError(CODE) \
   if( sqlite3_diskfull_pending ){ \
     if( sqlite3_diskfull_pending == 1 ){ \
       local_ioerr(); \
       sqlite3_diskfull = 1; \
       sqlite3_io_error_hit = 1; \
       CODE; \
     }else{ \
       sqlite3_diskfull_pending--; \
     } \
   }
#else
#define SimulateIOErrorBenign(X)
#define SimulateIOError(A)
#define SimulateDiskfullError(A)
#endif 


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_open_file_count;
#define OpenCounter(X)  sqlite3_open_file_count+=(X)
#else
#define OpenCounter(X)
#endif 

#endif 








#ifndef SQLITE_OS_WIN_H
#define SQLITE_OS_WIN_H


#include "windows.h"

#ifdef __CYGWIN__
# include <sys/cygwin.h>
# include <errno.h> 
#endif


#if SQLITE_OS_WIN && !defined(SQLITE_OS_WINNT)
# define SQLITE_OS_WINNT 1
#endif


#if defined(_WIN32_WCE)
# define SQLITE_OS_WINCE 1
#else
# define SQLITE_OS_WINCE 0
#endif


#if !defined(SQLITE_OS_WINRT)
# define SQLITE_OS_WINRT 0
#endif


#if SQLITE_OS_WINCE
# define SQLITE_WIN32_VOLATILE
#else
# define SQLITE_WIN32_VOLATILE volatile
#endif


#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \
    SQLITE_THREADSAFE>0 && !defined(__CYGWIN__)
# define SQLITE_OS_WIN_THREADS 1
#else
# define SQLITE_OS_WIN_THREADS 0
#endif

#endif 



#endif


#ifdef SQLITE_MUTEX_W32


struct sqlite3_mutex {
	CRITICAL_SECTION mutex;    
	int id;                    
#ifdef SQLITE_DEBUG
	volatile int nRef;         
	volatile DWORD owner;      
	volatile int trace;        
#endif
};


#define SQLITE_W32_MUTEX_INITIALIZER { 0 }

#ifdef SQLITE_DEBUG
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, \
                                    0L, (DWORD)0, 0 }
#else
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0 }
#endif

#ifdef SQLITE_DEBUG

static int winMutexHeld(sqlite3_mutex *p) {
	return p->nRef != 0 && p->owner == GetCurrentThreadId();
}

static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid) {
	return p->nRef == 0 || p->owner != tid;
}

static int winMutexNotheld(sqlite3_mutex *p) {
	DWORD tid = GetCurrentThreadId();
	return winMutexNotheld2(p, tid);
}
#endif


SQLITE_PRIVATE void sqlite3MemoryBarrier(void) {
#if defined(SQLITE_MEMORY_BARRIER)
	SQLITE_MEMORY_BARRIER;
#elif defined(__GNUC__)
	__sync_synchronize();
#elif !defined(SQLITE_DISABLE_INTRINSIC) && \
      defined(_MSC_VER) && _MSC_VER>=1300
	_ReadWriteBarrier();
#elif defined(MemoryBarrier)
	MemoryBarrier();
#endif
}


static sqlite3_mutex winMutex_staticMutexes[] = {
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER,
	SQLITE3_MUTEX_INITIALIZER
};

static int winMutex_isInit = 0;
static int winMutex_isNt = -1; 

							   
static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;

SQLITE_API int sqlite3_win32_is_nt(void); 
SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); 

static int winMutexInit(void) {
	
	if (InterlockedCompareExchange(&winMutex_lock, 1, 0) == 0) {
		int i;
		for (i = 0; i<ArraySize(winMutex_staticMutexes); i++) {
#if SQLITE_OS_WINRT
			InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);
#else
			InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);
#endif
		}
		winMutex_isInit = 1;
	}
	else {
		
		while (!winMutex_isInit) {
			sqlite3_win32_sleep(1);
		}
	}
	return SQLITE_OK;
}

static int winMutexEnd(void) {
	
	if (InterlockedCompareExchange(&winMutex_lock, 0, 1) == 1) {
		if (winMutex_isInit == 1) {
			int i;
			for (i = 0; i<ArraySize(winMutex_staticMutexes); i++) {
				DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);
			}
			winMutex_isInit = 0;
		}
	}
	return SQLITE_OK;
}


static sqlite3_mutex *winMutexAlloc(int iType) {
	sqlite3_mutex *p;

	switch (iType) {
	case SQLITE_MUTEX_FAST:
	case SQLITE_MUTEX_RECURSIVE: {
		p = sqlite3MallocZero(sizeof(*p));
		if (p) {
			p->id = iType;
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC
			p->trace = 1;
#endif
#endif
#if SQLITE_OS_WINRT
			InitializeCriticalSectionEx(&p->mutex, 0, 0);
#else
			InitializeCriticalSection(&p->mutex);
#endif
		}
		break;
	}
	default: {
#ifdef SQLITE_ENABLE_API_ARMOR
		if (iType - 2<0 || iType - 2 >= ArraySize(winMutex_staticMutexes)) {
			(void)SQLITE_MISUSE_BKPT;
			return 0;
		}
#endif
		p = &winMutex_staticMutexes[iType - 2];
		p->id = iType;
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
		p->trace = 1;
#endif
#endif
		break;
	}
	}
	return p;
}



static void winMutexFree(sqlite3_mutex *p) {
	assert(p);
	assert(p->nRef == 0 && p->owner == 0);
	if (p->id == SQLITE_MUTEX_FAST || p->id == SQLITE_MUTEX_RECURSIVE) {
		DeleteCriticalSection(&p->mutex);
		sqlite3_free(p);
	}
	else {
#ifdef SQLITE_ENABLE_API_ARMOR
		(void)SQLITE_MISUSE_BKPT;
#endif
	}
}


static void winMutexEnter(sqlite3_mutex *p) {
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	DWORD tid = GetCurrentThreadId();
#endif
#ifdef SQLITE_DEBUG
	assert(p);
	assert(p->id == SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid));
#else
	assert(p);
#endif
	assert(winMutex_isInit == 1);
	EnterCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
	assert(p->nRef>0 || p->owner == 0);
	p->owner = tid;
	p->nRef++;
	if (p->trace) {
		OSTRACE(("ENTER-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
			tid, p, p->trace, p->nRef));
	}
#endif
}

static int winMutexTry(sqlite3_mutex *p) {
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	DWORD tid = GetCurrentThreadId();
#endif
	int rc = SQLITE_BUSY;
	assert(p);
	assert(p->id == SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid));
	
#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400
	assert(winMutex_isInit == 1);
	assert(winMutex_isNt >= -1 && winMutex_isNt <= 1);
	if (winMutex_isNt<0) {
		winMutex_isNt = sqlite3_win32_is_nt();
	}
	assert(winMutex_isNt == 0 || winMutex_isNt == 1);
	if (winMutex_isNt && TryEnterCriticalSection(&p->mutex)) {
#ifdef SQLITE_DEBUG
		p->owner = tid;
		p->nRef++;
#endif
		rc = SQLITE_OK;
	}
#else
	UNUSED_PARAMETER(p);
#endif
#ifdef SQLITE_DEBUG
	if (p->trace) {
		OSTRACE(("TRY-MUTEX tid=%lu, mutex=%p (%d), owner=%lu, nRef=%d, rc=%s\n",
			tid, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));
	}
#endif
	return rc;
}


static void winMutexLeave(sqlite3_mutex *p) {
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	DWORD tid = GetCurrentThreadId();
#endif
	assert(p);
#ifdef SQLITE_DEBUG
	assert(p->nRef>0);
	assert(p->owner == tid);
	p->nRef--;
	if (p->nRef == 0) p->owner = 0;
	assert(p->nRef == 0 || p->id == SQLITE_MUTEX_RECURSIVE);
#endif
	assert(winMutex_isInit == 1);
	LeaveCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
	if (p->trace) {
		OSTRACE(("LEAVE-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
			tid, p, p->trace, p->nRef));
	}
#endif
}

SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void) {
	static const sqlite3_mutex_methods sMutex = {
		winMutexInit,
		winMutexEnd,
		winMutexAlloc,
		winMutexFree,
		winMutexEnter,
		winMutexTry,
		winMutexLeave,
#ifdef SQLITE_DEBUG
		winMutexHeld,
		winMutexNotheld
#else
		0,
		0
#endif
	};
	return &sMutex;
}

#endif 








SQLITE_API int sqlite3_release_memory(int n) {
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
	return sqlite3PcacheReleaseMemory(n);
#else
	
	UNUSED_PARAMETER(n);
	return 0;
#endif
}


typedef struct ScratchFreeslot {
	struct ScratchFreeslot *pNext;   
} ScratchFreeslot;


static SQLITE_WSD struct Mem0Global {
	sqlite3_mutex *mutex;         
	sqlite3_int64 alarmThreshold; 

								  
	void *pScratchEnd;
	ScratchFreeslot *pScratchFree;
	u32 nScratchFree;

	
	int nearlyFull;
} mem0 = { 0, 0, 0, 0, 0, 0 };

#define mem0 GLOBAL(struct Mem0Global, mem0)


SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void) {
	return mem0.mutex;
}

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API int sqlite3_memory_alarm(
	void(*xCallback)(void *pArg, sqlite3_int64 used, int N),
	void *pArg,
	sqlite3_int64 iThreshold
) {
	(void)xCallback;
	(void)pArg;
	(void)iThreshold;
	return SQLITE_OK;
}
#endif


SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n) {
	sqlite3_int64 priorLimit;
	sqlite3_int64 excess;
	sqlite3_int64 nUsed;
#ifndef SQLITE_OMIT_AUTOINIT
	int rc = sqlite3_initialize();
	if (rc) return -1;
#endif
	sqlite3_mutex_enter(mem0.mutex);
	priorLimit = mem0.alarmThreshold;
	if (n<0) {
		sqlite3_mutex_leave(mem0.mutex);
		return priorLimit;
	}
	mem0.alarmThreshold = n;
	nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
	mem0.nearlyFull = (n>0 && n <= nUsed);
	sqlite3_mutex_leave(mem0.mutex);
	excess = sqlite3_memory_used() - n;
	if (excess>0) sqlite3_release_memory((int)(excess & 0x7fffffff));
	return priorLimit;
}
SQLITE_API void sqlite3_soft_heap_limit(int n) {
	if (n<0) n = 0;
	sqlite3_soft_heap_limit64(n);
}


SQLITE_PRIVATE int sqlite3MallocInit(void) {
	int rc;
	if (sqlite3GlobalConfig.m.xMalloc == 0) {
		sqlite3MemSetDefault();
	}
	memset(&mem0, 0, sizeof(mem0));
	mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
	if (sqlite3GlobalConfig.pScratch && sqlite3GlobalConfig.szScratch >= 100
		&& sqlite3GlobalConfig.nScratch>0) {
		int i, n, sz;
		ScratchFreeslot *pSlot;
		sz = ROUNDDOWN8(sqlite3GlobalConfig.szScratch);
		sqlite3GlobalConfig.szScratch = sz;
		pSlot = (ScratchFreeslot*)sqlite3GlobalConfig.pScratch;
		n = sqlite3GlobalConfig.nScratch;
		mem0.pScratchFree = pSlot;
		mem0.nScratchFree = n;
		for (i = 0; i<n - 1; i++) {
			pSlot->pNext = (ScratchFreeslot*)(sz + (char*)pSlot);
			pSlot = pSlot->pNext;
		}
		pSlot->pNext = 0;
		mem0.pScratchEnd = (void*)&pSlot[1];
	}
	else {
		mem0.pScratchEnd = 0;
		sqlite3GlobalConfig.pScratch = 0;
		sqlite3GlobalConfig.szScratch = 0;
		sqlite3GlobalConfig.nScratch = 0;
	}
	if (sqlite3GlobalConfig.pPage == 0 || sqlite3GlobalConfig.szPage<512
		|| sqlite3GlobalConfig.nPage <= 0) {
		sqlite3GlobalConfig.pPage = 0;
		sqlite3GlobalConfig.szPage = 0;
	}
	rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
	if (rc != SQLITE_OK) memset(&mem0, 0, sizeof(mem0));
	return rc;
}


SQLITE_PRIVATE int sqlite3HeapNearlyFull(void) {
	return mem0.nearlyFull;
}


SQLITE_PRIVATE void sqlite3MallocEnd(void) {
	if (sqlite3GlobalConfig.m.xShutdown) {
		sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);
	}
	memset(&mem0, 0, sizeof(mem0));
}


SQLITE_API sqlite3_int64 sqlite3_memory_used(void) {
	sqlite3_int64 res, mx;
	sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);
	return res;
}


SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag) {
	sqlite3_int64 res, mx;
	sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);
	return mx;
}


static void sqlite3MallocAlarm(int nByte) {
	if (mem0.alarmThreshold <= 0) return;
	sqlite3_mutex_leave(mem0.mutex);
	sqlite3_release_memory(nByte);
	sqlite3_mutex_enter(mem0.mutex);
}


static int mallocWithAlarm(int n, void **pp) {
	int nFull;
	void *p;
	assert(sqlite3_mutex_held(mem0.mutex));
	nFull = sqlite3GlobalConfig.m.xRoundup(n);
	sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);
	if (mem0.alarmThreshold>0) {
		sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
		if (nUsed >= mem0.alarmThreshold - nFull) {
			mem0.nearlyFull = 1;
			sqlite3MallocAlarm(nFull);
		}
		else {
			mem0.nearlyFull = 0;
		}
	}
	p = sqlite3GlobalConfig.m.xMalloc(nFull);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
	if (p == 0 && mem0.alarmThreshold>0) {
		sqlite3MallocAlarm(nFull);
		p = sqlite3GlobalConfig.m.xMalloc(nFull);
	}
#endif
	if (p) {
		nFull = sqlite3MallocSize(p);
		sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);
		sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);
	}
	*pp = p;
	return nFull;
}


SQLITE_PRIVATE void *sqlite3Malloc(u64 n) {
	void *p;
	if (n == 0 || n >= 0x7fffff00) {
		
		p = 0;
	}
	else if (sqlite3GlobalConfig.bMemstat) {
		sqlite3_mutex_enter(mem0.mutex);
		mallocWithAlarm((int)n, &p);
		sqlite3_mutex_leave(mem0.mutex);
	}
	else {
		p = sqlite3GlobalConfig.m.xMalloc((int)n);
	}
	assert(EIGHT_BYTE_ALIGNMENT(p));  
	return p;
}


SQLITE_API void *sqlite3_malloc(int n) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return n <= 0 ? 0 : sqlite3Malloc(n);
}
SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return sqlite3Malloc(n);
}


#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)
static int scratchAllocOut = 0;
#endif



SQLITE_PRIVATE void *sqlite3ScratchMalloc(int n) {
	void *p;
	assert(n>0);

	sqlite3_mutex_enter(mem0.mutex);
	sqlite3StatusHighwater(SQLITE_STATUS_SCRATCH_SIZE, n);
	if (mem0.nScratchFree && sqlite3GlobalConfig.szScratch >= n) {
		p = mem0.pScratchFree;
		mem0.pScratchFree = mem0.pScratchFree->pNext;
		mem0.nScratchFree--;
		sqlite3StatusUp(SQLITE_STATUS_SCRATCH_USED, 1);
		sqlite3_mutex_leave(mem0.mutex);
	}
	else {
		sqlite3_mutex_leave(mem0.mutex);
		p = sqlite3Malloc(n);
		if (sqlite3GlobalConfig.bMemstat && p) {
			sqlite3_mutex_enter(mem0.mutex);
			sqlite3StatusUp(SQLITE_STATUS_SCRATCH_OVERFLOW, sqlite3MallocSize(p));
			sqlite3_mutex_leave(mem0.mutex);
		}
		sqlite3MemdebugSetType(p, MEMTYPE_SCRATCH);
	}
	assert(sqlite3_mutex_notheld(mem0.mutex));


#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)
	
	assert(scratchAllocOut == 0);
	if (p) scratchAllocOut++;
#endif

	return p;
}
SQLITE_PRIVATE void sqlite3ScratchFree(void *p) {
	if (p) {

#if SQLITE_THREADSAFE==0 && !defined(NDEBUG)
		
		assert(scratchAllocOut >= 1 && scratchAllocOut <= 2);
		scratchAllocOut--;
#endif

		if (SQLITE_WITHIN(p, sqlite3GlobalConfig.pScratch, mem0.pScratchEnd)) {
			
			ScratchFreeslot *pSlot;
			pSlot = (ScratchFreeslot*)p;
			sqlite3_mutex_enter(mem0.mutex);
			pSlot->pNext = mem0.pScratchFree;
			mem0.pScratchFree = pSlot;
			mem0.nScratchFree++;
			assert(mem0.nScratchFree <= (u32)sqlite3GlobalConfig.nScratch);
			sqlite3StatusDown(SQLITE_STATUS_SCRATCH_USED, 1);
			sqlite3_mutex_leave(mem0.mutex);
		}
		else {
			
			assert(sqlite3MemdebugHasType(p, MEMTYPE_SCRATCH));
			assert(sqlite3MemdebugNoType(p, (u8)~MEMTYPE_SCRATCH));
			sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
			if (sqlite3GlobalConfig.bMemstat) {
				int iSize = sqlite3MallocSize(p);
				sqlite3_mutex_enter(mem0.mutex);
				sqlite3StatusDown(SQLITE_STATUS_SCRATCH_OVERFLOW, iSize);
				sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, iSize);
				sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);
				sqlite3GlobalConfig.m.xFree(p);
				sqlite3_mutex_leave(mem0.mutex);
			}
			else {
				sqlite3GlobalConfig.m.xFree(p);
			}
		}
	}
}


#ifndef SQLITE_OMIT_LOOKASIDE
static int isLookaside(sqlite3 *db, void *p) {
	return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd);
}
#else
#define isLookaside(A,B) 0
#endif


SQLITE_PRIVATE int sqlite3MallocSize(void *p) {
	assert(sqlite3MemdebugHasType(p, MEMTYPE_HEAP));
	return sqlite3GlobalConfig.m.xSize(p);
}
SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p) {
	assert(p != 0);
	if (db == 0 || !isLookaside(db, p)) {
#if SQLITE_DEBUG
		if (db == 0) {
			assert(sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP));
			assert(sqlite3MemdebugHasType(p, MEMTYPE_HEAP));
		}
		else {
			assert(sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
			assert(sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
		}
#endif
		return sqlite3GlobalConfig.m.xSize(p);
	}
	else {
		assert(sqlite3_mutex_held(db->mutex));
		return db->lookaside.sz;
	}
}
SQLITE_API sqlite3_uint64 sqlite3_msize(void *p) {
	assert(sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP));
	assert(sqlite3MemdebugHasType(p, MEMTYPE_HEAP));
	return p ? sqlite3GlobalConfig.m.xSize(p) : 0;
}


SQLITE_API void sqlite3_free(void *p) {
	if (p == 0) return;  
	assert(sqlite3MemdebugHasType(p, MEMTYPE_HEAP));
	assert(sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP));
	if (sqlite3GlobalConfig.bMemstat) {
		sqlite3_mutex_enter(mem0.mutex);
		sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));
		sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);
		sqlite3GlobalConfig.m.xFree(p);
		sqlite3_mutex_leave(mem0.mutex);
	}
	else {
		sqlite3GlobalConfig.m.xFree(p);
	}
}


static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p) {
	*db->pnBytesFreed += sqlite3DbMallocSize(db, p);
}


SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p) {
	assert(db == 0 || sqlite3_mutex_held(db->mutex));
	if (p == 0) return;
	if (db) {
		if (db->pnBytesFreed) {
			measureAllocationSize(db, p);
			return;
		}
		if (isLookaside(db, p)) {
			LookasideSlot *pBuf = (LookasideSlot*)p;
#if SQLITE_DEBUG
			
			memset(p, 0xaa, db->lookaside.sz);
#endif
			pBuf->pNext = db->lookaside.pFree;
			db->lookaside.pFree = pBuf;
			db->lookaside.nOut--;
			return;
		}
	}
	assert(sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
	assert(sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
	assert(db != 0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE));
	sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
	sqlite3_free(p);
}


SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes) {
	int nOld, nNew, nDiff;
	void *pNew;
	assert(sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP));
	assert(sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP));
	if (pOld == 0) {
		return sqlite3Malloc(nBytes); 
	}
	if (nBytes == 0) {
		sqlite3_free(pOld); 
		return 0;
	}
	if (nBytes >= 0x7fffff00) {
		
		return 0;
	}
	nOld = sqlite3MallocSize(pOld);
	
	nNew = sqlite3GlobalConfig.m.xRoundup((int)nBytes);
	if (nOld == nNew) {
		pNew = pOld;
	}
	else if (sqlite3GlobalConfig.bMemstat) {
		sqlite3_mutex_enter(mem0.mutex);
		sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);
		nDiff = nNew - nOld;
		if (sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED) >=
			mem0.alarmThreshold - nDiff) {
			sqlite3MallocAlarm(nDiff);
		}
		pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
		if (pNew == 0 && mem0.alarmThreshold>0) {
			sqlite3MallocAlarm((int)nBytes);
			pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
		}
		if (pNew) {
			nNew = sqlite3MallocSize(pNew);
			sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew - nOld);
		}
		sqlite3_mutex_leave(mem0.mutex);
	}
	else {
		pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
	}
	assert(EIGHT_BYTE_ALIGNMENT(pNew)); 
	return pNew;
}


SQLITE_API void *sqlite3_realloc(void *pOld, int n) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	if (n<0) n = 0;  
	return sqlite3Realloc(pOld, n);
}
SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return sqlite3Realloc(pOld, n);
}



SQLITE_PRIVATE void *sqlite3MallocZero(u64 n) {
	void *p = sqlite3Malloc(n);
	if (p) {
		memset(p, 0, (size_t)n);
	}
	return p;
}


SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n) {
	void *p;
	testcase(db == 0);
	p = sqlite3DbMallocRaw(db, n);
	if (p) memset(p, 0, (size_t)n);
	return p;
}



static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n) {
	void *p;
	assert(db != 0);
	p = sqlite3Malloc(n);
	if (!p) sqlite3OomFault(db);
	sqlite3MemdebugSetType(p,
		(db->lookaside.bDisable == 0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);
	return p;
}


SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n) {
	void *p;
	if (db) return sqlite3DbMallocRawNN(db, n);
	p = sqlite3Malloc(n);
	sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
	return p;
}
SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n) {
#ifndef SQLITE_OMIT_LOOKASIDE
	LookasideSlot *pBuf;
	assert(db != 0);
	assert(sqlite3_mutex_held(db->mutex));
	assert(db->pnBytesFreed == 0);
	if (db->lookaside.bDisable == 0) {
		assert(db->mallocFailed == 0);
		if (n>db->lookaside.sz) {
			db->lookaside.anStat[1]++;
		}
		else if ((pBuf = db->lookaside.pFree) == 0) {
			db->lookaside.anStat[2]++;
		}
		else {
			db->lookaside.pFree = pBuf->pNext;
			db->lookaside.nOut++;
			db->lookaside.anStat[0]++;
			if (db->lookaside.nOut>db->lookaside.mxOut) {
				db->lookaside.mxOut = db->lookaside.nOut;
			}
			return (void*)pBuf;
		}
	}
	else if (db->mallocFailed) {
		return 0;
	}
#else
	assert(db != 0);
	assert(sqlite3_mutex_held(db->mutex));
	assert(db->pnBytesFreed == 0);
	if (db->mallocFailed) {
		return 0;
	}
#endif
	return dbMallocRawFinish(db, n);
}


static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n);


SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n) {
	assert(db != 0);
	if (p == 0) return sqlite3DbMallocRawNN(db, n);
	assert(sqlite3_mutex_held(db->mutex));
	if (isLookaside(db, p) && n <= db->lookaside.sz) return p;
	return dbReallocFinish(db, p, n);
}
static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n) {
	void *pNew = 0;
	assert(db != 0);
	assert(p != 0);
	if (db->mallocFailed == 0) {
		if (isLookaside(db, p)) {
			pNew = sqlite3DbMallocRawNN(db, n);
			if (pNew) {
				memcpy(pNew, p, db->lookaside.sz);
				sqlite3DbFree(db, p);
			}
		}
		else {
			assert(sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
			assert(sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE | MEMTYPE_HEAP)));
			sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
			pNew = sqlite3_realloc64(p, n);
			if (!pNew) {
				sqlite3OomFault(db);
			}
			sqlite3MemdebugSetType(pNew,
				(db->lookaside.bDisable == 0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));
		}
	}
	return pNew;
}


SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n) {
	void *pNew;
	pNew = sqlite3DbRealloc(db, p, n);
	if (!pNew) {
		sqlite3DbFree(db, p);
	}
	return pNew;
}


SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z) {
	char *zNew;
	size_t n;
	if (z == 0) {
		return 0;
	}
	n = sqlite3Strlen30(z) + 1;
	assert((n & 0x7fffffff) == n);
	zNew = sqlite3DbMallocRaw(db, (int)n);
	if (zNew) {
		memcpy(zNew, z, n);
	}
	return zNew;
}
SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n) {
	char *zNew;
	assert(db != 0);
	if (z == 0) {
		return 0;
	}
	assert((n & 0x7fffffff) == n);
	zNew = sqlite3DbMallocRawNN(db, n + 1);
	if (zNew) {
		memcpy(zNew, z, (size_t)n);
		zNew[n] = 0;
	}
	return zNew;
}


SQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew) {
	sqlite3DbFree(db, *pz);
	*pz = sqlite3DbStrDup(db, zNew);
}


SQLITE_PRIVATE void sqlite3OomFault(sqlite3 *db) {
	if (db->mallocFailed == 0 && db->bBenignMalloc == 0) {
		db->mallocFailed = 1;
		if (db->nVdbeExec>0) {
			db->u1.isInterrupted = 1;
		}
		db->lookaside.bDisable++;
	}
}


SQLITE_PRIVATE void sqlite3OomClear(sqlite3 *db) {
	if (db->mallocFailed && db->nVdbeExec == 0) {
		db->mallocFailed = 0;
		db->u1.isInterrupted = 0;
		assert(db->lookaside.bDisable>0);
		db->lookaside.bDisable--;
	}
}


static SQLITE_NOINLINE int apiOomError(sqlite3 *db) {
	sqlite3OomClear(db);
	sqlite3Error(db, SQLITE_NOMEM);
	return SQLITE_NOMEM_BKPT;
}


SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc) {
	
	assert(db != 0);
	assert(sqlite3_mutex_held(db->mutex));
	if (db->mallocFailed || rc == SQLITE_IOERR_NOMEM) {
		return apiOomError(db);
	}
	return rc & db->errMask;
}







#define etRADIX       0 
#define etFLOAT       1 
#define etEXP         2 
#define etGENERIC     3 
#define etSIZE        4 
#define etSTRING      5 
#define etDYNSTRING   6 
#define etPERCENT     7 
#define etCHARX       8 

#define etSQLESCAPE   9 
#define etSQLESCAPE2 10 
#define etTOKEN      11 
#define etSRCLIST    12 
#define etPOINTER    13 
#define etSQLESCAPE3 14 
#define etORDINAL    15 

#define etINVALID    16 



typedef unsigned char etByte;


typedef struct et_info {   
	char fmttype;            
	etByte base;             
	etByte flags;            
	etByte type;             
	etByte charset;          
	etByte prefix;           
} et_info;


#define FLAG_SIGNED  1     
#define FLAG_INTERN  2     
#define FLAG_STRING  4     



static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[] = {
	{ 'd', 10, 1, etRADIX,      0,  0 },
	{ 's',  0, 4, etSTRING,     0,  0 },
	{ 'g',  0, 1, etGENERIC,    30, 0 },
	{ 'z',  0, 4, etDYNSTRING,  0,  0 },
	{ 'q',  0, 4, etSQLESCAPE,  0,  0 },
	{ 'Q',  0, 4, etSQLESCAPE2, 0,  0 },
	{ 'w',  0, 4, etSQLESCAPE3, 0,  0 },
	{ 'c',  0, 0, etCHARX,      0,  0 },
	{ 'o',  8, 0, etRADIX,      0,  2 },
	{ 'u', 10, 0, etRADIX,      0,  0 },
	{ 'x', 16, 0, etRADIX,      16, 1 },
	{ 'X', 16, 0, etRADIX,      0,  4 },
#ifndef SQLITE_OMIT_FLOATING_POINT
	{ 'f',  0, 1, etFLOAT,      0,  0 },
	{ 'e',  0, 1, etEXP,        30, 0 },
	{ 'E',  0, 1, etEXP,        14, 0 },
	{ 'G',  0, 1, etGENERIC,    14, 0 },
#endif
	{ 'i', 10, 1, etRADIX,      0,  0 },
	{ 'n',  0, 0, etSIZE,       0,  0 },
	{ '%',  0, 0, etPERCENT,    0,  0 },
	{ 'p', 16, 0, etPOINTER,    0,  1 },

	
	{ 'T',  0, 2, etTOKEN,      0,  0 },
	{ 'S',  0, 2, etSRCLIST,    0,  0 },
	{ 'r', 10, 3, etORDINAL,    0,  0 },
};


#ifndef SQLITE_OMIT_FLOATING_POINT

static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt) {
	int digit;
	LONGDOUBLE_TYPE d;
	if ((*cnt) <= 0) return '0';
	(*cnt)--;
	digit = (int)*val;
	d = digit;
	digit += '0';
	*val = (*val - d)*10.0;
	return (char)digit;
}
#endif 


static void setStrAccumError(StrAccum *p, u8 eError) {
	assert(eError == STRACCUM_NOMEM || eError == STRACCUM_TOOBIG);
	p->accError = eError;
	p->nAlloc = 0;
}


static sqlite3_int64 getIntArg(PrintfArguments *p) {
	if (p->nArg <= p->nUsed) return 0;
	return sqlite3_value_int64(p->apArg[p->nUsed++]);
}
static double getDoubleArg(PrintfArguments *p) {
	if (p->nArg <= p->nUsed) return 0.0;
	return sqlite3_value_double(p->apArg[p->nUsed++]);
}
static char *getTextArg(PrintfArguments *p) {
	if (p->nArg <= p->nUsed) return 0;
	return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);
}



#ifndef SQLITE_PRINT_BUF_SIZE
# define SQLITE_PRINT_BUF_SIZE 70
#endif
#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  


SQLITE_PRIVATE void sqlite3VXPrintf(
	StrAccum *pAccum,          
	const char *fmt,           
	va_list ap                 
) {
	int c;                     
	char *bufpt;               
	int precision;             
	int length;                
	int idx;                   
	int width;                 
	etByte flag_leftjustify;   
	etByte flag_plussign;      
	etByte flag_blanksign;     
	etByte flag_alternateform; 
	etByte flag_altform2;      
	etByte flag_zeropad;       
	etByte flag_long;          
	etByte flag_longlong;      
	etByte done;               
	etByte xtype = etINVALID;  
	u8 bArgList;               
	u8 useIntern;              
	char prefix;               
	sqlite_uint64 longvalue;   
	LONGDOUBLE_TYPE realvalue; 
	const et_info *infop;      
	char *zOut;                
	int nOut;                  
	char *zExtra = 0;          
#ifndef SQLITE_OMIT_FLOATING_POINT
	int  exp, e2;              
	int nsd;                   
	double rounder;            
	etByte flag_dp;            
	etByte flag_rtz;           
#endif
	PrintfArguments *pArgList = 0; 
	char buf[etBUFSIZE];       

	bufpt = 0;
	if (pAccum->printfFlags) {
		if ((bArgList = (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)) != 0) {
			pArgList = va_arg(ap, PrintfArguments*);
		}
		useIntern = pAccum->printfFlags & SQLITE_PRINTF_INTERNAL;
	}
	else {
		bArgList = useIntern = 0;
	}
	for (; (c = (*fmt)) != 0; ++fmt) {
		if (c != '%') {
			bufpt = (char *)fmt;
#if HAVE_STRCHRNUL
			fmt = strchrnul(fmt, '%');
#else
			do { fmt++; } while (*fmt && *fmt != '%');
#endif
			sqlite3StrAccumAppend(pAccum, bufpt, (int)(fmt - bufpt));
			if (*fmt == 0) break;
		}
		if ((c = (*++fmt)) == 0) {
			sqlite3StrAccumAppend(pAccum, "%", 1);
			break;
		}
		
		flag_leftjustify = flag_plussign = flag_blanksign =
			flag_alternateform = flag_altform2 = flag_zeropad = 0;
		done = 0;
		do {
			switch (c) {
			case '-':   flag_leftjustify = 1;     break;
			case '+':   flag_plussign = 1;        break;
			case ' ':   flag_blanksign = 1;       break;
			case '#':   flag_alternateform = 1;   break;
			case '!':   flag_altform2 = 1;        break;
			case '0':   flag_zeropad = 1;         break;
			default:    done = 1;                 break;
			}
		} while (!done && (c = (*++fmt)) != 0);
		
		if (c == '*') {
			if (bArgList) {
				width = (int)getIntArg(pArgList);
			}
			else {
				width = va_arg(ap, int);
			}
			if (width<0) {
				flag_leftjustify = 1;
				width = width >= -2147483647 ? -width : 0;
			}
			c = *++fmt;
		}
		else {
			unsigned wx = 0;
			while (c >= '0' && c <= '9') {
				wx = wx * 10 + c - '0';
				c = *++fmt;
			}
			testcase(wx>0x7fffffff);
			width = wx & 0x7fffffff;
		}
		assert(width >= 0);
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
		if (width>SQLITE_PRINTF_PRECISION_LIMIT) {
			width = SQLITE_PRINTF_PRECISION_LIMIT;
		}
#endif

		
		if (c == '.') {
			c = *++fmt;
			if (c == '*') {
				if (bArgList) {
					precision = (int)getIntArg(pArgList);
				}
				else {
					precision = va_arg(ap, int);
				}
				c = *++fmt;
				if (precision<0) {
					precision = precision >= -2147483647 ? -precision : -1;
				}
			}
			else {
				unsigned px = 0;
				while (c >= '0' && c <= '9') {
					px = px * 10 + c - '0';
					c = *++fmt;
				}
				testcase(px>0x7fffffff);
				precision = px & 0x7fffffff;
			}
		}
		else {
			precision = -1;
		}
		assert(precision >= (-1));
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
		if (precision>SQLITE_PRINTF_PRECISION_LIMIT) {
			precision = SQLITE_PRINTF_PRECISION_LIMIT;
		}
#endif


		
		if (c == 'l') {
			flag_long = 1;
			c = *++fmt;
			if (c == 'l') {
				flag_longlong = 1;
				c = *++fmt;
			}
			else {
				flag_longlong = 0;
			}
		}
		else {
			flag_long = flag_longlong = 0;
		}
		
		infop = &fmtinfo[0];
		xtype = etINVALID;
		for (idx = 0; idx<ArraySize(fmtinfo); idx++) {
			if (c == fmtinfo[idx].fmttype) {
				infop = &fmtinfo[idx];
				if (useIntern || (infop->flags & FLAG_INTERN) == 0) {
					xtype = infop->type;
				}
				else {
					return;
				}
				break;
			}
		}

		
		switch (xtype) {
		case etPOINTER:
			flag_longlong = sizeof(char*) == sizeof(i64);
			flag_long = sizeof(char*) == sizeof(long int);
			
		case etORDINAL:
		case etRADIX:
			if (infop->flags & FLAG_SIGNED) {
				i64 v;
				if (bArgList) {
					v = getIntArg(pArgList);
				}
				else if (flag_longlong) {
					v = va_arg(ap, i64);
				}
				else if (flag_long) {
					v = va_arg(ap, long int);
				}
				else {
					v = va_arg(ap, int);
				}
				if (v<0) {
					if (v == SMALLEST_INT64) {
						longvalue = ((u64)1) << 63;
					}
					else {
						longvalue = -v;
					}
					prefix = '-';
				}
				else {
					longvalue = v;
					if (flag_plussign)        prefix = '+';
					else if (flag_blanksign)  prefix = ' ';
					else                       prefix = 0;
				}
			}
			else {
				if (bArgList) {
					longvalue = (u64)getIntArg(pArgList);
				}
				else if (flag_longlong) {
					longvalue = va_arg(ap, u64);
				}
				else if (flag_long) {
					longvalue = va_arg(ap, unsigned long int);
				}
				else {
					longvalue = va_arg(ap, unsigned int);
				}
				prefix = 0;
			}
			if (longvalue == 0) flag_alternateform = 0;
			if (flag_zeropad && precision<width - (prefix != 0)) {
				precision = width - (prefix != 0);
			}
			if (precision<etBUFSIZE - 10) {
				nOut = etBUFSIZE;
				zOut = buf;
			}
			else {
				nOut = precision + 10;
				zOut = zExtra = sqlite3Malloc(nOut);
				if (zOut == 0) {
					setStrAccumError(pAccum, STRACCUM_NOMEM);
					return;
				}
			}
			bufpt = &zOut[nOut - 1];
			if (xtype == etORDINAL) {
				static const char zOrd[] = "thstndrd";
				int x = (int)(longvalue % 10);
				if (x >= 4 || (longvalue / 10) % 10 == 1) {
					x = 0;
				}
				*(--bufpt) = zOrd[x * 2 + 1];
				*(--bufpt) = zOrd[x * 2];
			}
			{
				const char *cset = &aDigits[infop->charset];
				u8 base = infop->base;
				do {                                           
					*(--bufpt) = cset[longvalue%base];
					longvalue = longvalue / base;
				} while (longvalue>0);
			}
			length = (int)(&zOut[nOut - 1] - bufpt);
			for (idx = precision - length; idx>0; idx--) {
				*(--bufpt) = '0';                             
			}
			if (prefix) *(--bufpt) = prefix;               
			if (flag_alternateform && infop->prefix) {      
				const char *pre;
				char x;
				pre = &aPrefix[infop->prefix];
				for (; (x = (*pre)) != 0; pre++) *(--bufpt) = x;
			}
			length = (int)(&zOut[nOut - 1] - bufpt);
			break;
		case etFLOAT:
		case etEXP:
		case etGENERIC:
			if (bArgList) {
				realvalue = getDoubleArg(pArgList);
			}
			else {
				realvalue = va_arg(ap, double);
			}
#ifdef SQLITE_OMIT_FLOATING_POINT
			length = 0;
#else
			if (precision<0) precision = 6;         
			if (realvalue<0.0) {
				realvalue = -realvalue;
				prefix = '-';
			}
			else {
				if (flag_plussign)          prefix = '+';
				else if (flag_blanksign)    prefix = ' ';
				else                         prefix = 0;
			}
			if (xtype == etGENERIC && precision>0) precision--;
			testcase(precision>0xfff);
			for (idx = precision & 0xfff, rounder = 0.5; idx>0; idx--, rounder *= 0.1) {}
			if (xtype == etFLOAT) realvalue += rounder;
			
			exp = 0;
			if (sqlite3IsNaN((double)realvalue)) {
				bufpt = "NaN";
				length = 3;
				break;
			}
			if (realvalue>0.0) {
				LONGDOUBLE_TYPE scale = 1.0;
				while (realvalue >= 1e100*scale && exp <= 350) { scale *= 1e100; exp += 100; }
				while (realvalue >= 1e10*scale && exp <= 350) { scale *= 1e10; exp += 10; }
				while (realvalue >= 10.0*scale && exp <= 350) { scale *= 10.0; exp++; }
				realvalue /= scale;
				while (realvalue<1e-8) { realvalue *= 1e8; exp -= 8; }
				while (realvalue<1.0) { realvalue *= 10.0; exp--; }
				if (exp>350) {
					bufpt = buf;
					buf[0] = prefix;
					memcpy(buf + (prefix != 0), "Inf", 4);
					length = 3 + (prefix != 0);
					break;
				}
			}
			bufpt = buf;
			
			if (xtype != etFLOAT) {
				realvalue += rounder;
				if (realvalue >= 10.0) { realvalue *= 0.1; exp++; }
			}
			if (xtype == etGENERIC) {
				flag_rtz = !flag_alternateform;
				if (exp<-4 || exp>precision) {
					xtype = etEXP;
				}
				else {
					precision = precision - exp;
					xtype = etFLOAT;
				}
			}
			else {
				flag_rtz = flag_altform2;
			}
			if (xtype == etEXP) {
				e2 = 0;
			}
			else {
				e2 = exp;
			}
			if (MAX(e2, 0) + (i64)precision + (i64)width > etBUFSIZE - 15) {
				bufpt = zExtra
					= sqlite3Malloc(MAX(e2, 0) + (i64)precision + (i64)width + 15);
				if (bufpt == 0) {
					setStrAccumError(pAccum, STRACCUM_NOMEM);
					return;
				}
			}
			zOut = bufpt;
			nsd = 16 + flag_altform2 * 10;
			flag_dp = (precision>0 ? 1 : 0) | flag_alternateform | flag_altform2;
			
			if (prefix) {
				*(bufpt++) = prefix;
			}
			
			if (e2<0) {
				*(bufpt++) = '0';
			}
			else {
				for (; e2 >= 0; e2--) {
					*(bufpt++) = et_getdigit(&realvalue, &nsd);
				}
			}
			
			if (flag_dp) {
				*(bufpt++) = '.';
			}
			
			for (e2++; e2<0; precision--, e2++) {
				assert(precision>0);
				*(bufpt++) = '0';
			}
			
			while ((precision--)>0) {
				*(bufpt++) = et_getdigit(&realvalue, &nsd);
			}
			
			if (flag_rtz && flag_dp) {
				while (bufpt[-1] == '0') *(--bufpt) = 0;
				assert(bufpt>zOut);
				if (bufpt[-1] == '.') {
					if (flag_altform2) {
						*(bufpt++) = '0';
					}
					else {
						*(--bufpt) = 0;
					}
				}
			}
			
			if (xtype == etEXP) {
				*(bufpt++) = aDigits[infop->charset];
				if (exp<0) {
					*(bufpt++) = '-'; exp = -exp;
				}
				else {
					*(bufpt++) = '+';
				}
				if (exp >= 100) {
					*(bufpt++) = (char)((exp / 100) + '0');        
					exp %= 100;
				}
				*(bufpt++) = (char)(exp / 10 + '0');             
				*(bufpt++) = (char)(exp % 10 + '0');             
			}
			*bufpt = 0;

			
			length = (int)(bufpt - zOut);
			bufpt = zOut;

			
			if (flag_zeropad && !flag_leftjustify && length < width) {
				int i;
				int nPad = width - length;
				for (i = width; i >= nPad; i--) {
					bufpt[i] = bufpt[i - nPad];
				}
				i = prefix != 0;
				while (nPad--) bufpt[i++] = '0';
				length = width;
			}
#endif 
			break;
		case etSIZE:
			if (!bArgList) {
				*(va_arg(ap, int*)) = pAccum->nChar;
			}
			length = width = 0;
			break;
		case etPERCENT:
			buf[0] = '%';
			bufpt = buf;
			length = 1;
			break;
		case etCHARX:
			if (bArgList) {
				bufpt = getTextArg(pArgList);
				c = bufpt ? bufpt[0] : 0;
			}
			else {
				c = va_arg(ap, int);
			}
			if (precision>1) {
				width -= precision - 1;
				if (width>1 && !flag_leftjustify) {
					sqlite3AppendChar(pAccum, width - 1, ' ');
					width = 0;
				}
				sqlite3AppendChar(pAccum, precision - 1, c);
			}
			length = 1;
			buf[0] = c;
			bufpt = buf;
			break;
		case etSTRING:
		case etDYNSTRING:
			if (bArgList) {
				bufpt = getTextArg(pArgList);
				xtype = etSTRING;
			}
			else {
				bufpt = va_arg(ap, char*);
			}
			if (bufpt == 0) {
				bufpt = "";
			}
			else if (xtype == etDYNSTRING) {
				zExtra = bufpt;
			}
			if (precision >= 0) {
				for (length = 0; length<precision && bufpt[length]; length++) {}
			}
			else {
				length = sqlite3Strlen30(bufpt);
			}
			break;
		case etSQLESCAPE:           
		case etSQLESCAPE2:          
		case etSQLESCAPE3: {        
			int i, j, k, n, isnull;
			int needQuote;
			char ch;
			char q = ((xtype == etSQLESCAPE3) ? '"' : '\'');   
			char *escarg;

			if (bArgList) {
				escarg = getTextArg(pArgList);
			}
			else {
				escarg = va_arg(ap, char*);
			}
			isnull = escarg == 0;
			if (isnull) escarg = (xtype == etSQLESCAPE2 ? "NULL" : "(NULL)");
			k = precision;
			for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++, k--) {
				if (ch == q)  n++;
			}
			needQuote = !isnull && xtype == etSQLESCAPE2;
			n += i + 3;
			if (n>etBUFSIZE) {
				bufpt = zExtra = sqlite3Malloc(n);
				if (bufpt == 0) {
					setStrAccumError(pAccum, STRACCUM_NOMEM);
					return;
				}
			}
			else {
				bufpt = buf;
			}
			j = 0;
			if (needQuote) bufpt[j++] = q;
			k = i;
			for (i = 0; i<k; i++) {
				bufpt[j++] = ch = escarg[i];
				if (ch == q) bufpt[j++] = ch;
			}
			if (needQuote) bufpt[j++] = q;
			bufpt[j] = 0;
			length = j;
			
			break;
		}
		case etTOKEN: {
			Token *pToken = va_arg(ap, Token*);
			assert(bArgList == 0);
			if (pToken && pToken->n) {
				sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);
			}
			length = width = 0;
			break;
		}
		case etSRCLIST: {
			SrcList *pSrc = va_arg(ap, SrcList*);
			int k = va_arg(ap, int);
			struct SrcList_item *pItem = &pSrc->a[k];
			assert(bArgList == 0);
			assert(k >= 0 && k<pSrc->nSrc);
			if (pItem->zDatabase) {
				sqlite3StrAccumAppendAll(pAccum, pItem->zDatabase);
				sqlite3StrAccumAppend(pAccum, ".", 1);
			}
			sqlite3StrAccumAppendAll(pAccum, pItem->zName);
			length = width = 0;
			break;
		}
		default: {
			assert(xtype == etINVALID);
			return;
		}
		}
		 
		width -= length;
		if (width>0 && !flag_leftjustify) sqlite3AppendChar(pAccum, width, ' ');
		sqlite3StrAccumAppend(pAccum, bufpt, length);
		if (width>0 && flag_leftjustify) sqlite3AppendChar(pAccum, width, ' ');

		if (zExtra) {
			sqlite3DbFree(pAccum->db, zExtra);
			zExtra = 0;
		}
	}
} 

  
static int sqlite3StrAccumEnlarge(StrAccum *p, int N) {
	char *zNew;
	assert(p->nChar + (i64)N >= p->nAlloc); 
	if (p->accError) {
		testcase(p->accError == STRACCUM_TOOBIG);
		testcase(p->accError == STRACCUM_NOMEM);
		return 0;
	}
	if (p->mxAlloc == 0) {
		N = p->nAlloc - p->nChar - 1;
		setStrAccumError(p, STRACCUM_TOOBIG);
		return N;
	}
	else {
		char *zOld = isMalloced(p) ? p->zText : 0;
		i64 szNew = p->nChar;
		assert((p->zText == 0 || p->zText == p->zBase) == !isMalloced(p));
		szNew += N + 1;
		if (szNew + p->nChar <= p->mxAlloc) {
			
			szNew += p->nChar;
		}
		if (szNew > p->mxAlloc) {
			sqlite3StrAccumReset(p);
			setStrAccumError(p, STRACCUM_TOOBIG);
			return 0;
		}
		else {
			p->nAlloc = (int)szNew;
		}
		if (p->db) {
			zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
		}
		else {
			zNew = sqlite3_realloc64(zOld, p->nAlloc);
		}
		if (zNew) {
			assert(p->zText != 0 || p->nChar == 0);
			if (!isMalloced(p) && p->nChar>0) memcpy(zNew, p->zText, p->nChar);
			p->zText = zNew;
			p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
			p->printfFlags |= SQLITE_PRINTF_MALLOCED;
		}
		else {
			sqlite3StrAccumReset(p);
			setStrAccumError(p, STRACCUM_NOMEM);
			return 0;
		}
	}
	return N;
}


SQLITE_PRIVATE void sqlite3AppendChar(StrAccum *p, int N, char c) {
	testcase(p->nChar + (i64)N > 0x7fffffff);
	if (p->nChar + (i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N)) <= 0) {
		return;
	}
	assert((p->zText == p->zBase) == !isMalloced(p));
	while ((N--)>0) p->zText[p->nChar++] = c;
}


static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N) {
	N = sqlite3StrAccumEnlarge(p, N);
	if (N>0) {
		memcpy(&p->zText[p->nChar], z, N);
		p->nChar += N;
	}
	assert((p->zText == 0 || p->zText == p->zBase) == !isMalloced(p));
}


SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N) {
	assert(z != 0 || N == 0);
	assert(p->zText != 0 || p->nChar == 0 || p->accError);
	assert(N >= 0);
	assert(p->accError == 0 || p->nAlloc == 0);
	if (p->nChar + N >= p->nAlloc) {
		enlargeAndAppend(p, z, N);
	}
	else {
		assert(p->zText);
		p->nChar += N;
		memcpy(&p->zText[p->nChar - N], z, N);
	}
}


SQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum *p, const char *z) {
	sqlite3StrAccumAppend(p, z, sqlite3Strlen30(z));
}



SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p) {
	if (p->zText) {
		assert((p->zText == p->zBase) == !isMalloced(p));
		p->zText[p->nChar] = 0;
		if (p->mxAlloc>0 && !isMalloced(p)) {
			p->zText = sqlite3DbMallocRaw(p->db, p->nChar + 1);
			if (p->zText) {
				memcpy(p->zText, p->zBase, p->nChar + 1);
				p->printfFlags |= SQLITE_PRINTF_MALLOCED;
			}
			else {
				setStrAccumError(p, STRACCUM_NOMEM);
			}
		}
	}
	return p->zText;
}


SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p) {
	assert((p->zText == 0 || p->zText == p->zBase) == !isMalloced(p));
	if (isMalloced(p)) {
		sqlite3DbFree(p->db, p->zText);
		p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;
	}
	p->zText = 0;
}


SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx) {
	p->zText = p->zBase = zBase;
	p->db = db;
	p->nChar = 0;
	p->nAlloc = n;
	p->mxAlloc = mx;
	p->accError = 0;
	p->printfFlags = 0;
}


SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap) {
	char *z;
	char zBase[SQLITE_PRINT_BUF_SIZE];
	StrAccum acc;
	assert(db != 0);
	sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),
		db->aLimit[SQLITE_LIMIT_LENGTH]);
	acc.printfFlags = SQLITE_PRINTF_INTERNAL;
	sqlite3VXPrintf(&acc, zFormat, ap);
	z = sqlite3StrAccumFinish(&acc);
	if (acc.accError == STRACCUM_NOMEM) {
		sqlite3OomFault(db);
	}
	return z;
}


SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...) {
	va_list ap;
	char *z;
	va_start(ap, zFormat);
	z = sqlite3VMPrintf(db, zFormat, ap);
	va_end(ap);
	return z;
}


SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap) {
	char *z;
	char zBase[SQLITE_PRINT_BUF_SIZE];
	StrAccum acc;

#ifdef SQLITE_ENABLE_API_ARMOR  
	if (zFormat == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);
	sqlite3VXPrintf(&acc, zFormat, ap);
	z = sqlite3StrAccumFinish(&acc);
	return z;
}


SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...) {
	va_list ap;
	char *z;
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	va_start(ap, zFormat);
	z = sqlite3_vmprintf(zFormat, ap);
	va_end(ap);
	return z;
}


SQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap) {
	StrAccum acc;
	if (n <= 0) return zBuf;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (zBuf == 0 || zFormat == 0) {
		(void)SQLITE_MISUSE_BKPT;
		if (zBuf) zBuf[0] = 0;
		return zBuf;
	}
#endif
	sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
	sqlite3VXPrintf(&acc, zFormat, ap);
	return sqlite3StrAccumFinish(&acc);
}
SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...) {
	char *z;
	va_list ap;
	va_start(ap, zFormat);
	z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
	va_end(ap);
	return z;
}


static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap) {
	StrAccum acc;                          
	char zMsg[SQLITE_PRINT_BUF_SIZE * 3];    

	sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);
	sqlite3VXPrintf(&acc, zFormat, ap);
	sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,
		sqlite3StrAccumFinish(&acc));
}


SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...) {
	va_list ap;                             
	if (sqlite3GlobalConfig.xLog) {
		va_start(ap, zFormat);
		renderLogMsg(iErrCode, zFormat, ap);
		va_end(ap);
	}
}

#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)

SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...) {
	va_list ap;
	StrAccum acc;
	char zBuf[500];
	sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
	va_start(ap, zFormat);
	sqlite3VXPrintf(&acc, zFormat, ap);
	va_end(ap);
	sqlite3StrAccumFinish(&acc);
	fprintf(stdout, "%s", zBuf);
	fflush(stdout);
}
#endif



SQLITE_PRIVATE void sqlite3XPrintf(StrAccum *p, const char *zFormat, ...) {
	va_list ap;
	va_start(ap, zFormat);
	sqlite3VXPrintf(p, zFormat, ap);
	va_end(ap);
}





#ifdef SQLITE_DEBUG


static TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow) {
	if (p == 0) {
		p = sqlite3_malloc64(sizeof(*p));
		if (p == 0) return 0;
		memset(p, 0, sizeof(*p));
	}
	else {
		p->iLevel++;
	}
	assert(moreToFollow == 0 || moreToFollow == 1);
	if (p->iLevel<sizeof(p->bLine)) p->bLine[p->iLevel] = moreToFollow;
	return p;
}


static void sqlite3TreeViewPop(TreeView *p) {
	if (p == 0) return;
	p->iLevel--;
	if (p->iLevel<0) sqlite3_free(p);
}


static void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...) {
	va_list ap;
	int i;
	StrAccum acc;
	char zBuf[500];
	sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
	if (p) {
		for (i = 0; i<p->iLevel && i<sizeof(p->bLine) - 1; i++) {
			sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|   " : "    ", 4);
		}
		sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|-- " : "'-- ", 4);
	}
	va_start(ap, zFormat);
	sqlite3VXPrintf(&acc, zFormat, ap);
	va_end(ap);
	if (zBuf[acc.nChar - 1] != '\n') sqlite3StrAccumAppend(&acc, "\n", 1);
	sqlite3StrAccumFinish(&acc);
	fprintf(stdout, "%s", zBuf);
	fflush(stdout);
}


static void sqlite3TreeViewItem(TreeView *p, const char *zLabel, u8 moreFollows) {
	p = sqlite3TreeViewPush(p, moreFollows);
	sqlite3TreeViewLine(p, "%s", zLabel);
}


SQLITE_PRIVATE void sqlite3TreeViewWith(TreeView *pView, const With *pWith, u8 moreToFollow) {
	int i;
	if (pWith == 0) return;
	if (pWith->nCte == 0) return;
	if (pWith->pOuter) {
		sqlite3TreeViewLine(pView, "WITH (0x%p, pOuter=0x%p)", pWith, pWith->pOuter);
	}
	else {
		sqlite3TreeViewLine(pView, "WITH (0x%p)", pWith);
	}
	if (pWith->nCte>0) {
		pView = sqlite3TreeViewPush(pView, 1);
		for (i = 0; i<pWith->nCte; i++) {
			StrAccum x;
			char zLine[1000];
			const struct Cte *pCte = &pWith->a[i];
			sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);
			sqlite3XPrintf(&x, "%s", pCte->zName);
			if (pCte->pCols && pCte->pCols->nExpr>0) {
				char cSep = '(';
				int j;
				for (j = 0; j<pCte->pCols->nExpr; j++) {
					sqlite3XPrintf(&x, "%c%s", cSep, pCte->pCols->a[j].zName);
					cSep = ',';
				}
				sqlite3XPrintf(&x, ")");
			}
			sqlite3XPrintf(&x, " AS");
			sqlite3StrAccumFinish(&x);
			sqlite3TreeViewItem(pView, zLine, i<pWith->nCte - 1);
			sqlite3TreeViewSelect(pView, pCte->pSelect, 0);
			sqlite3TreeViewPop(pView);
		}
		sqlite3TreeViewPop(pView);
	}
}



SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow) {
	int n = 0;
	int cnt = 0;
	pView = sqlite3TreeViewPush(pView, moreToFollow);
	if (p->pWith) {
		sqlite3TreeViewWith(pView, p->pWith, 1);
		cnt = 1;
		sqlite3TreeViewPush(pView, 1);
	}
	do {
		sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x nSelectRow=%d",
			((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
			((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags,
			(int)p->nSelectRow
		);
		if (cnt++) sqlite3TreeViewPop(pView);
		if (p->pPrior) {
			n = 1000;
		}
		else {
			n = 0;
			if (p->pSrc && p->pSrc->nSrc) n++;
			if (p->pWhere) n++;
			if (p->pGroupBy) n++;
			if (p->pHaving) n++;
			if (p->pOrderBy) n++;
			if (p->pLimit) n++;
			if (p->pOffset) n++;
		}
		sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");
		if (p->pSrc && p->pSrc->nSrc) {
			int i;
			pView = sqlite3TreeViewPush(pView, (n--)>0);
			sqlite3TreeViewLine(pView, "FROM");
			for (i = 0; i<p->pSrc->nSrc; i++) {
				struct SrcList_item *pItem = &p->pSrc->a[i];
				StrAccum x;
				char zLine[100];
				sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);
				sqlite3XPrintf(&x, "{%d,*}", pItem->iCursor);
				if (pItem->zDatabase) {
					sqlite3XPrintf(&x, " %s.%s", pItem->zDatabase, pItem->zName);
				}
				else if (pItem->zName) {
					sqlite3XPrintf(&x, " %s", pItem->zName);
				}
				if (pItem->pTab) {
					sqlite3XPrintf(&x, " tabname=%Q", pItem->pTab->zName);
				}
				if (pItem->zAlias) {
					sqlite3XPrintf(&x, " (AS %s)", pItem->zAlias);
				}
				if (pItem->fg.jointype & JT_LEFT) {
					sqlite3XPrintf(&x, " LEFT-JOIN");
				}
				sqlite3StrAccumFinish(&x);
				sqlite3TreeViewItem(pView, zLine, i<p->pSrc->nSrc - 1);
				if (pItem->pSelect) {
					sqlite3TreeViewSelect(pView, pItem->pSelect, 0);
				}
				if (pItem->fg.isTabFunc) {
					sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, "func-args:");
				}
				sqlite3TreeViewPop(pView);
			}
			sqlite3TreeViewPop(pView);
		}
		if (p->pWhere) {
			sqlite3TreeViewItem(pView, "WHERE", (n--)>0);
			sqlite3TreeViewExpr(pView, p->pWhere, 0);
			sqlite3TreeViewPop(pView);
		}
		if (p->pGroupBy) {
			sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");
		}
		if (p->pHaving) {
			sqlite3TreeViewItem(pView, "HAVING", (n--)>0);
			sqlite3TreeViewExpr(pView, p->pHaving, 0);
			sqlite3TreeViewPop(pView);
		}
		if (p->pOrderBy) {
			sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");
		}
		if (p->pLimit) {
			sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);
			sqlite3TreeViewExpr(pView, p->pLimit, 0);
			sqlite3TreeViewPop(pView);
		}
		if (p->pOffset) {
			sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);
			sqlite3TreeViewExpr(pView, p->pOffset, 0);
			sqlite3TreeViewPop(pView);
		}
		if (p->pPrior) {
			const char *zOp = "UNION";
			switch (p->op) {
			case TK_ALL:         zOp = "UNION ALL";  break;
			case TK_INTERSECT:   zOp = "INTERSECT";  break;
			case TK_EXCEPT:      zOp = "EXCEPT";     break;
			}
			sqlite3TreeViewItem(pView, zOp, 1);
		}
		p = p->pPrior;
	} while (p != 0);
	sqlite3TreeViewPop(pView);
}


SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow) {
	const char *zBinOp = 0;   
	const char *zUniOp = 0;   
	char zFlgs[30];
	pView = sqlite3TreeViewPush(pView, moreToFollow);
	if (pExpr == 0) {
		sqlite3TreeViewLine(pView, "nil");
		sqlite3TreeViewPop(pView);
		return;
	}
	if (pExpr->flags) {
		sqlite3_snprintf(sizeof(zFlgs), zFlgs, "  flags=0x%x", pExpr->flags);
	}
	else {
		zFlgs[0] = 0;
	}
	switch (pExpr->op) {
	case TK_AGG_COLUMN: {
		sqlite3TreeViewLine(pView, "AGG{%d:%d}%s",
			pExpr->iTable, pExpr->iColumn, zFlgs);
		break;
	}
	case TK_COLUMN: {
		if (pExpr->iTable<0) {
			
			sqlite3TreeViewLine(pView, "COLUMN(%d)%s", pExpr->iColumn, zFlgs);
		}
		else {
			sqlite3TreeViewLine(pView, "{%d:%d}%s",
				pExpr->iTable, pExpr->iColumn, zFlgs);
		}
		break;
	}
	case TK_INTEGER: {
		if (pExpr->flags & EP_IntValue) {
			sqlite3TreeViewLine(pView, "%d", pExpr->u.iValue);
		}
		else {
			sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);
		}
		break;
	}
#ifndef SQLITE_OMIT_FLOATING_POINT
	case TK_FLOAT: {
		sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);
		break;
	}
#endif
	case TK_STRING: {
		sqlite3TreeViewLine(pView, "%Q", pExpr->u.zToken);
		break;
	}
	case TK_NULL: {
		sqlite3TreeViewLine(pView, "NULL");
		break;
	}
#ifndef SQLITE_OMIT_BLOB_LITERAL
	case TK_BLOB: {
		sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);
		break;
	}
#endif
	case TK_VARIABLE: {
		sqlite3TreeViewLine(pView, "VARIABLE(%s,%d)",
			pExpr->u.zToken, pExpr->iColumn);
		break;
	}
	case TK_REGISTER: {
		sqlite3TreeViewLine(pView, "REGISTER(%d)", pExpr->iTable);
		break;
	}
	case TK_ID: {
		sqlite3TreeViewLine(pView, "ID \"%w\"", pExpr->u.zToken);
		break;
	}
#ifndef SQLITE_OMIT_CAST
	case TK_CAST: {
		
		sqlite3TreeViewLine(pView, "CAST %Q", pExpr->u.zToken);
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
		break;
	}
#endif 
	case TK_LT:      zBinOp = "LT";     break;
	case TK_LE:      zBinOp = "LE";     break;
	case TK_GT:      zBinOp = "GT";     break;
	case TK_GE:      zBinOp = "GE";     break;
	case TK_NE:      zBinOp = "NE";     break;
	case TK_EQ:      zBinOp = "EQ";     break;
	case TK_IS:      zBinOp = "IS";     break;
	case TK_ISNOT:   zBinOp = "ISNOT";  break;
	case TK_AND:     zBinOp = "AND";    break;
	case TK_OR:      zBinOp = "OR";     break;
	case TK_PLUS:    zBinOp = "ADD";    break;
	case TK_STAR:    zBinOp = "MUL";    break;
	case TK_MINUS:   zBinOp = "SUB";    break;
	case TK_REM:     zBinOp = "REM";    break;
	case TK_BITAND:  zBinOp = "BITAND"; break;
	case TK_BITOR:   zBinOp = "BITOR";  break;
	case TK_SLASH:   zBinOp = "DIV";    break;
	case TK_LSHIFT:  zBinOp = "LSHIFT"; break;
	case TK_RSHIFT:  zBinOp = "RSHIFT"; break;
	case TK_CONCAT:  zBinOp = "CONCAT"; break;
	case TK_DOT:     zBinOp = "DOT";    break;

	case TK_UMINUS:  zUniOp = "UMINUS"; break;
	case TK_UPLUS:   zUniOp = "UPLUS";  break;
	case TK_BITNOT:  zUniOp = "BITNOT"; break;
	case TK_NOT:     zUniOp = "NOT";    break;
	case TK_ISNULL:  zUniOp = "ISNULL"; break;
	case TK_NOTNULL: zUniOp = "NOTNULL"; break;

	case TK_SPAN: {
		sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
		break;
	}

	case TK_COLLATE: {
		sqlite3TreeViewLine(pView, "COLLATE %Q", pExpr->u.zToken);
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
		break;
	}

	case TK_AGG_FUNCTION:
	case TK_FUNCTION: {
		ExprList *pFarg;       
		if (ExprHasProperty(pExpr, EP_TokenOnly)) {
			pFarg = 0;
		}
		else {
			pFarg = pExpr->x.pList;
		}
		if (pExpr->op == TK_AGG_FUNCTION) {
			sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q",
				pExpr->op2, pExpr->u.zToken);
		}
		else {
			sqlite3TreeViewLine(pView, "FUNCTION %Q", pExpr->u.zToken);
		}
		if (pFarg) {
			sqlite3TreeViewExprList(pView, pFarg, 0, 0);
		}
		break;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_EXISTS: {
		sqlite3TreeViewLine(pView, "EXISTS-expr");
		sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
		break;
	}
	case TK_SELECT: {
		sqlite3TreeViewLine(pView, "SELECT-expr");
		sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
		break;
	}
	case TK_IN: {
		sqlite3TreeViewLine(pView, "IN");
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
		}
		else {
			sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);
		}
		break;
	}
#endif 

				
	case TK_BETWEEN: {
		Expr *pX = pExpr->pLeft;
		Expr *pY = pExpr->x.pList->a[0].pExpr;
		Expr *pZ = pExpr->x.pList->a[1].pExpr;
		sqlite3TreeViewLine(pView, "BETWEEN");
		sqlite3TreeViewExpr(pView, pX, 1);
		sqlite3TreeViewExpr(pView, pY, 1);
		sqlite3TreeViewExpr(pView, pZ, 0);
		break;
	}
	case TK_TRIGGER: {
		
		sqlite3TreeViewLine(pView, "%s(%d)",
			pExpr->iTable ? "NEW" : "OLD", pExpr->iColumn);
		break;
	}
	case TK_CASE: {
		sqlite3TreeViewLine(pView, "CASE");
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
		sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);
		break;
	}
#ifndef SQLITE_OMIT_TRIGGER
	case TK_RAISE: {
		const char *zType = "unk";
		switch (pExpr->affinity) {
		case OE_Rollback:   zType = "rollback";  break;
		case OE_Abort:      zType = "abort";     break;
		case OE_Fail:       zType = "fail";      break;
		case OE_Ignore:     zType = "ignore";    break;
		}
		sqlite3TreeViewLine(pView, "RAISE %s(%Q)", zType, pExpr->u.zToken);
		break;
	}
#endif
	case TK_MATCH: {
		sqlite3TreeViewLine(pView, "MATCH {%d:%d}%s",
			pExpr->iTable, pExpr->iColumn, zFlgs);
		sqlite3TreeViewExpr(pView, pExpr->pRight, 0);
		break;
	}
	case TK_VECTOR: {
		sqlite3TreeViewBareExprList(pView, pExpr->x.pList, "VECTOR");
		break;
	}
	case TK_SELECT_COLUMN: {
		sqlite3TreeViewLine(pView, "SELECT-COLUMN %d", pExpr->iColumn);
		sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);
		break;
	}
	default: {
		sqlite3TreeViewLine(pView, "op=%d", pExpr->op);
		break;
	}
	}
	if (zBinOp) {
		sqlite3TreeViewLine(pView, "%s%s", zBinOp, zFlgs);
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
		sqlite3TreeViewExpr(pView, pExpr->pRight, 0);
	}
	else if (zUniOp) {
		sqlite3TreeViewLine(pView, "%s%s", zUniOp, zFlgs);
		sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
	}
	sqlite3TreeViewPop(pView);
}



SQLITE_PRIVATE void sqlite3TreeViewBareExprList(
	TreeView *pView,
	const ExprList *pList,
	const char *zLabel
) {
	if (zLabel == 0 || zLabel[0] == 0) zLabel = "LIST";
	if (pList == 0) {
		sqlite3TreeViewLine(pView, "%s (empty)", zLabel);
	}
	else {
		int i;
		sqlite3TreeViewLine(pView, "%s", zLabel);
		for (i = 0; i<pList->nExpr; i++) {
			int j = pList->a[i].u.x.iOrderByCol;
			if (j) {
				sqlite3TreeViewPush(pView, 0);
				sqlite3TreeViewLine(pView, "iOrderByCol=%d", j);
			}
			sqlite3TreeViewExpr(pView, pList->a[i].pExpr, i<pList->nExpr - 1);
			if (j) sqlite3TreeViewPop(pView);
		}
	}
}
SQLITE_PRIVATE void sqlite3TreeViewExprList(
	TreeView *pView,
	const ExprList *pList,
	u8 moreToFollow,
	const char *zLabel
) {
	pView = sqlite3TreeViewPush(pView, moreToFollow);
	sqlite3TreeViewBareExprList(pView, pList, zLabel);
	sqlite3TreeViewPop(pView);
}

#endif 








static SQLITE_WSD struct sqlite3PrngType {
	unsigned char isInit;          
	unsigned char i, j;            
	unsigned char s[256];          
} sqlite3Prng;


SQLITE_API void sqlite3_randomness(int N, void *pBuf) {
	unsigned char t;
	unsigned char *zBuf = pBuf;

	
#ifdef SQLITE_OMIT_WSD
	struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);
# define wsdPrng p[0]
#else
# define wsdPrng sqlite3Prng
#endif

#if SQLITE_THREADSAFE
	sqlite3_mutex *mutex;
#endif

#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return;
#endif

#if SQLITE_THREADSAFE
	mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);
#endif

	sqlite3_mutex_enter(mutex);
	if (N <= 0 || pBuf == 0) {
		wsdPrng.isInit = 0;
		sqlite3_mutex_leave(mutex);
		return;
	}

	
	if (!wsdPrng.isInit) {
		int i;
		char k[256];
		wsdPrng.j = 0;
		wsdPrng.i = 0;
		sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);
		for (i = 0; i<256; i++) {
			wsdPrng.s[i] = (u8)i;
		}
		for (i = 0; i<256; i++) {
			wsdPrng.j += wsdPrng.s[i] + k[i];
			t = wsdPrng.s[wsdPrng.j];
			wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];
			wsdPrng.s[i] = t;
		}
		wsdPrng.isInit = 1;
	}

	assert(N>0);
	do {
		wsdPrng.i++;
		t = wsdPrng.s[wsdPrng.i];
		wsdPrng.j += t;
		wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];
		wsdPrng.s[wsdPrng.j] = t;
		t += wsdPrng.s[wsdPrng.i];
		*(zBuf++) = wsdPrng.s[t];
	} while (--N);
	sqlite3_mutex_leave(mutex);
}

#ifndef SQLITE_OMIT_BUILTIN_TEST

static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;
SQLITE_PRIVATE void sqlite3PrngSaveState(void) {
	memcpy(
		&GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),
		&GLOBAL(struct sqlite3PrngType, sqlite3Prng),
		sizeof(sqlite3Prng)
	);
}
SQLITE_PRIVATE void sqlite3PrngRestoreState(void) {
	memcpy(
		&GLOBAL(struct sqlite3PrngType, sqlite3Prng),
		&GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),
		sizeof(sqlite3Prng)
	);
}
#endif 





#if SQLITE_OS_WIN

#endif

#if SQLITE_MAX_WORKER_THREADS>0


#if SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) && SQLITE_THREADSAFE>0

#define SQLITE_THREADS_IMPLEMENTED 1  



struct SQLiteThread {
	pthread_t tid;                 
	int done;                      
	void *pOut;                    
	void *(*xTask)(void*);         
	void *pIn;                     
};


SQLITE_PRIVATE int sqlite3ThreadCreate(
	SQLiteThread **ppThread,  
	void *(*xTask)(void*),    
	void *pIn                 
) {
	SQLiteThread *p;
	int rc;

	assert(ppThread != 0);
	assert(xTask != 0);
	
	assert(sqlite3GlobalConfig.bCoreMutex != 0);

	*ppThread = 0;
	p = sqlite3Malloc(sizeof(*p));
	if (p == 0) return SQLITE_NOMEM_BKPT;
	memset(p, 0, sizeof(*p));
	p->xTask = xTask;
	p->pIn = pIn;
	
	if (sqlite3FaultSim(200)) {
		rc = 1;
	}
	else {
		rc = pthread_create(&p->tid, 0, xTask, pIn);
	}
	if (rc) {
		p->done = 1;
		p->pOut = xTask(pIn);
	}
	*ppThread = p;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut) {
	int rc;

	assert(ppOut != 0);
	if (NEVER(p == 0)) return SQLITE_NOMEM_BKPT;
	if (p->done) {
		*ppOut = p->pOut;
		rc = SQLITE_OK;
	}
	else {
		rc = pthread_join(p->tid, ppOut) ? SQLITE_ERROR : SQLITE_OK;
	}
	sqlite3_free(p);
	return rc;
}

#endif 




#if SQLITE_OS_WIN_THREADS

#define SQLITE_THREADS_IMPLEMENTED 1  
#include <process.h>


struct SQLiteThread {
	void *tid;               
	unsigned id;             
	void *(*xTask)(void*);   
	void *pIn;               
	void *pResult;           
};


static unsigned __stdcall sqlite3ThreadProc(
	void *pArg  
) {
	SQLiteThread *p = (SQLiteThread *)pArg;

	assert(p != 0);
#if 0
	
	assert(p->id == GetCurrentThreadId());
#endif
	assert(p->xTask != 0);
	p->pResult = p->xTask(p->pIn);

	_endthreadex(0);
	return 0; 
}


SQLITE_PRIVATE int sqlite3ThreadCreate(
	SQLiteThread **ppThread,  
	void *(*xTask)(void*),    
	void *pIn                 
) {
	SQLiteThread *p;

	assert(ppThread != 0);
	assert(xTask != 0);
	*ppThread = 0;
	p = sqlite3Malloc(sizeof(*p));
	if (p == 0) return SQLITE_NOMEM_BKPT;
	
	if (sqlite3GlobalConfig.bCoreMutex == 0 || sqlite3FaultSim(200)) {
		memset(p, 0, sizeof(*p));
	}
	else {
		p->xTask = xTask;
		p->pIn = pIn;
		p->tid = (void*)_beginthreadex(0, 0, sqlite3ThreadProc, p, 0, &p->id);
		if (p->tid == 0) {
			memset(p, 0, sizeof(*p));
		}
	}
	if (p->xTask == 0) {
		p->id = GetCurrentThreadId();
		p->pResult = xTask(pIn);
	}
	*ppThread = p;
	return SQLITE_OK;
}

SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject); 

													   
SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut) {
	DWORD rc;
	BOOL bRc;

	assert(ppOut != 0);
	if (NEVER(p == 0)) return SQLITE_NOMEM_BKPT;
	if (p->xTask == 0) {
		
		rc = WAIT_OBJECT_0;
		assert(p->tid == 0);
	}
	else {
		assert(p->id != 0 && p->id != GetCurrentThreadId());
		rc = sqlite3Win32Wait((HANDLE)p->tid);
		assert(rc != WAIT_IO_COMPLETION);
		bRc = CloseHandle((HANDLE)p->tid);
		assert(bRc);
	}
	if (rc == WAIT_OBJECT_0) *ppOut = p->pResult;
	sqlite3_free(p);
	return (rc == WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR;
}

#endif 




#ifndef SQLITE_THREADS_IMPLEMENTED



struct SQLiteThread {
	void *(*xTask)(void*);   
	void *pIn;               
	void *pResult;           
};


SQLITE_PRIVATE int sqlite3ThreadCreate(
	SQLiteThread **ppThread,  
	void *(*xTask)(void*),    
	void *pIn                 
) {
	SQLiteThread *p;

	assert(ppThread != 0);
	assert(xTask != 0);
	*ppThread = 0;
	p = sqlite3Malloc(sizeof(*p));
	if (p == 0) return SQLITE_NOMEM_BKPT;
	if ((SQLITE_PTR_TO_INT(p) / 17) & 1) {
		p->xTask = xTask;
		p->pIn = pIn;
	}
	else {
		p->xTask = 0;
		p->pResult = xTask(pIn);
	}
	*ppThread = p;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut) {

	assert(ppOut != 0);
	if (NEVER(p == 0)) return SQLITE_NOMEM_BKPT;
	if (p->xTask) {
		*ppOut = p->xTask(p->pIn);
	}
	else {
		*ppOut = p->pResult;
	}
	sqlite3_free(p);

#if defined(SQLITE_TEST)
	{
		void *pTstAlloc = sqlite3Malloc(10);
		if (!pTstAlloc) return SQLITE_NOMEM_BKPT;
		sqlite3_free(pTstAlloc);
	}
#endif

	return SQLITE_OK;
}

#endif 

#endif 








#if !defined(SQLITE_AMALGAMATION) && SQLITE_BYTEORDER==0

SQLITE_PRIVATE const int sqlite3one = 1;
#endif 


static const unsigned char sqlite3Utf8Trans1[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};


#define WRITE_UTF8(zOut, c) {                          \
  if( c<0x00080 ){                                     \
    *zOut++ = (u8)(c&0xFF);                            \
  }                                                    \
  else if( c<0x00800 ){                                \
    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
  else if( c<0x10000 ){                                \
    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }else{                                               \
    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \
    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
}

#define WRITE_UTF16LE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
  }else{                                                            \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
  }                                                                 \
}

#define WRITE_UTF16BE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }else{                                                            \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }                                                                 \
}

#define READ_UTF16LE(zIn, TERM, c){                                   \
  c = (*zIn++);                                                       \
  c += ((*zIn++)<<8);                                                 \
  if( c>=0xD800 && c<0xE000 && TERM ){                                \
    int c2 = (*zIn++);                                                \
    c2 += ((*zIn++)<<8);                                              \
    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \
  }                                                                   \
}

#define READ_UTF16BE(zIn, TERM, c){                                   \
  c = ((*zIn++)<<8);                                                  \
  c += (*zIn++);                                                      \
  if( c>=0xD800 && c<0xE000 && TERM ){                                \
    int c2 = ((*zIn++)<<8);                                           \
    c2 += (*zIn++);                                                   \
    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \
  }                                                                   \
}


#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }
SQLITE_PRIVATE u32 sqlite3Utf8Read(
	const unsigned char **pz    
) {
	unsigned int c;

	
	c = *((*pz)++);
	if (c >= 0xc0) {
		c = sqlite3Utf8Trans1[c - 0xc0];
		while ((*(*pz) & 0xc0) == 0x80) {
			c = (c << 6) + (0x3f & *((*pz)++));
		}
		if (c<0x80
			|| (c & 0xFFFFF800) == 0xD800
			|| (c & 0xFFFFFFFE) == 0xFFFE) {
			c = 0xFFFD;
		}
	}
	return c;
}







#ifndef SQLITE_OMIT_UTF16

SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc) {
	int len;                    
	unsigned char *zOut;                  
	unsigned char *zIn;                   
	unsigned char *zTerm;                 
	unsigned char *z;                     
	unsigned int c;

	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(pMem->flags&MEM_Str);
	assert(pMem->enc != desiredEnc);
	assert(pMem->enc != 0);
	assert(pMem->n >= 0);

#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
	{
		char zBuf[100];
		sqlite3VdbeMemPrettyPrint(pMem, zBuf);
		fprintf(stderr, "INPUT:  %s\n", zBuf);
	}
#endif

	
	if (pMem->enc != SQLITE_UTF8 && desiredEnc != SQLITE_UTF8) {
		u8 temp;
		int rc;
		rc = sqlite3VdbeMemMakeWriteable(pMem);
		if (rc != SQLITE_OK) {
			assert(rc == SQLITE_NOMEM);
			return SQLITE_NOMEM_BKPT;
		}
		zIn = (u8*)pMem->z;
		zTerm = &zIn[pMem->n&~1];
		while (zIn<zTerm) {
			temp = *zIn;
			*zIn = *(zIn + 1);
			zIn++;
			*zIn++ = temp;
		}
		pMem->enc = desiredEnc;
		goto translate_out;
	}

	
	if (desiredEnc == SQLITE_UTF8) {
		
		pMem->n &= ~1;
		len = pMem->n * 2 + 1;
	}
	else {
		
		len = pMem->n * 2 + 2;
	}

	
	zIn = (u8*)pMem->z;
	zTerm = &zIn[pMem->n];
	zOut = sqlite3DbMallocRaw(pMem->db, len);
	if (!zOut) {
		return SQLITE_NOMEM_BKPT;
	}
	z = zOut;

	if (pMem->enc == SQLITE_UTF8) {
		if (desiredEnc == SQLITE_UTF16LE) {
			
			while (zIn<zTerm) {
				READ_UTF8(zIn, zTerm, c);
				WRITE_UTF16LE(z, c);
			}
		}
		else {
			assert(desiredEnc == SQLITE_UTF16BE);
			
			while (zIn<zTerm) {
				READ_UTF8(zIn, zTerm, c);
				WRITE_UTF16BE(z, c);
			}
		}
		pMem->n = (int)(z - zOut);
		*z++ = 0;
	}
	else {
		assert(desiredEnc == SQLITE_UTF8);
		if (pMem->enc == SQLITE_UTF16LE) {
			
			while (zIn<zTerm) {
				READ_UTF16LE(zIn, zIn<zTerm, c);
				WRITE_UTF8(z, c);
			}
		}
		else {
			
			while (zIn<zTerm) {
				READ_UTF16BE(zIn, zIn<zTerm, c);
				WRITE_UTF8(z, c);
			}
		}
		pMem->n = (int)(z - zOut);
	}
	*z = 0;
	assert((pMem->n + (desiredEnc == SQLITE_UTF8 ? 1 : 2)) <= len);

	c = pMem->flags;
	sqlite3VdbeMemRelease(pMem);
	pMem->flags = MEM_Str | MEM_Term | (c&(MEM_AffMask | MEM_Subtype));
	pMem->enc = desiredEnc;
	pMem->z = (char*)zOut;
	pMem->zMalloc = pMem->z;
	pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);

translate_out:
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
	{
		char zBuf[100];
		sqlite3VdbeMemPrettyPrint(pMem, zBuf);
		fprintf(stderr, "OUTPUT: %s\n", zBuf);
	}
#endif
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem) {
	int rc = SQLITE_OK;
	u8 bom = 0;

	assert(pMem->n >= 0);
	if (pMem->n>1) {
		u8 b1 = *(u8 *)pMem->z;
		u8 b2 = *(((u8 *)pMem->z) + 1);
		if (b1 == 0xFE && b2 == 0xFF) {
			bom = SQLITE_UTF16BE;
		}
		if (b1 == 0xFF && b2 == 0xFE) {
			bom = SQLITE_UTF16LE;
		}
	}

	if (bom) {
		rc = sqlite3VdbeMemMakeWriteable(pMem);
		if (rc == SQLITE_OK) {
			pMem->n -= 2;
			memmove(pMem->z, &pMem->z[2], pMem->n);
			pMem->z[pMem->n] = '\0';
			pMem->z[pMem->n + 1] = '\0';
			pMem->flags |= MEM_Term;
			pMem->enc = bom;
		}
	}
	return rc;
}
#endif 


SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte) {
	int r = 0;
	const u8 *z = (const u8*)zIn;
	const u8 *zTerm;
	if (nByte >= 0) {
		zTerm = &z[nByte];
	}
	else {
		zTerm = (const u8*)(-1);
	}
	assert(z <= zTerm);
	while (*z != 0 && z<zTerm) {
		SQLITE_SKIP_UTF8(z);
		r++;
	}
	return r;
}


#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)

SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn) {
	unsigned char *zOut = zIn;
	unsigned char *zStart = zIn;
	u32 c;

	while (zIn[0] && zOut <= zIn) {
		c = sqlite3Utf8Read((const u8**)&zIn);
		if (c != 0xfffd) {
			WRITE_UTF8(zOut, c);
		}
	}
	*zOut = 0;
	return (int)(zOut - zStart);
}
#endif

#ifndef SQLITE_OMIT_UTF16

SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc) {
	Mem m;
	memset(&m, 0, sizeof(m));
	m.db = db;
	sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);
	sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);
	if (db->mallocFailed) {
		sqlite3VdbeMemRelease(&m);
		m.z = 0;
	}
	assert((m.flags & MEM_Term) != 0 || db->mallocFailed);
	assert((m.flags & MEM_Str) != 0 || db->mallocFailed);
	assert(m.z || db->mallocFailed);
	return m.z;
}


SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar) {
	int c;
	unsigned char const *z = zIn;
	int n = 0;

	if (SQLITE_UTF16NATIVE == SQLITE_UTF16BE) {
		while (n<nChar) {
			READ_UTF16BE(z, 1, c);
			n++;
		}
	}
	else {
		while (n<nChar) {
			READ_UTF16LE(z, 1, c);
			n++;
		}
	}
	return (int)(z - (unsigned char const *)zIn);
}

#if defined(SQLITE_TEST)

SQLITE_PRIVATE void sqlite3UtfSelfTest(void) {
	unsigned int i, t;
	unsigned char zBuf[20];
	unsigned char *z;
	int n;
	unsigned int c;

	for (i = 0; i<0x00110000; i++) {
		z = zBuf;
		WRITE_UTF8(z, i);
		n = (int)(z - zBuf);
		assert(n>0 && n <= 4);
		z[0] = 0;
		z = zBuf;
		c = sqlite3Utf8Read((const u8**)&z);
		t = i;
		if (i >= 0xD800 && i <= 0xDFFF) t = 0xFFFD;
		if ((i & 0xFFFFFFFE) == 0xFFFE) t = 0xFFFD;
		assert(c == t);
		assert((z - zBuf) == n);
	}
	for (i = 0; i<0x00110000; i++) {
		if (i >= 0xD800 && i<0xE000) continue;
		z = zBuf;
		WRITE_UTF16LE(z, i);
		n = (int)(z - zBuf);
		assert(n>0 && n <= 4);
		z[0] = 0;
		z = zBuf;
		READ_UTF16LE(z, 1, c);
		assert(c == i);
		assert((z - zBuf) == n);
	}
	for (i = 0; i<0x00110000; i++) {
		if (i >= 0xD800 && i<0xE000) continue;
		z = zBuf;
		WRITE_UTF16BE(z, i);
		n = (int)(z - zBuf);
		assert(n>0 && n <= 4);
		z[0] = 0;
		z = zBuf;
		READ_UTF16BE(z, 1, c);
		assert(c == i);
		assert((z - zBuf) == n);
	}
}
#endif 
#endif 






#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
# include <math.h>
#endif


#ifdef SQLITE_COVERAGE_TEST
SQLITE_PRIVATE void sqlite3Coverage(int x) {
	static unsigned dummy = 0;
	dummy += (unsigned)x;
}
#endif


#ifndef SQLITE_OMIT_BUILTIN_TEST
SQLITE_PRIVATE int sqlite3FaultSim(int iTest) {
	int(*xCallback)(int) = sqlite3GlobalConfig.xTestCallback;
	return xCallback ? xCallback(iTest) : SQLITE_OK;
}
#endif

#ifndef SQLITE_OMIT_FLOATING_POINT

SQLITE_PRIVATE int sqlite3IsNaN(double x) {
	int rc;   
#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN
			  
#ifdef __FAST_MATH__
# error SQLite will not work correctly with the -ffast-math option of GCC.
#endif
	volatile double y = x;
	volatile double z = y;
	rc = (y != z);
#else  
	rc = isnan(x);
#endif 
	testcase(rc);
	return rc;
}
#endif 


SQLITE_PRIVATE int sqlite3Strlen30(const char *z) {
	if (z == 0) return 0;
	return 0x3fffffff & (int)strlen(z);
}


SQLITE_PRIVATE char *sqlite3ColumnType(Column *pCol, char *zDflt) {
	if ((pCol->colFlags & COLFLAG_HASTYPE) == 0) return zDflt;
	return pCol->zName + strlen(pCol->zName) + 1;
}


static SQLITE_NOINLINE void  sqlite3ErrorFinish(sqlite3 *db, int err_code) {
	if (db->pErr) sqlite3ValueSetNull(db->pErr);
	sqlite3SystemError(db, err_code);
}


SQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code) {
	assert(db != 0);
	db->errCode = err_code;
	if (err_code || db->pErr) sqlite3ErrorFinish(db, err_code);
}


SQLITE_PRIVATE void sqlite3SystemError(sqlite3 *db, int rc) {
	if (rc == SQLITE_IOERR_NOMEM) return;
	rc &= 0xff;
	if (rc == SQLITE_CANTOPEN || rc == SQLITE_IOERR) {
		db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
	}
}


SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...) {
	assert(db != 0);
	db->errCode = err_code;
	sqlite3SystemError(db, err_code);
	if (zFormat == 0) {
		sqlite3Error(db, err_code);
	}
	else if (db->pErr || (db->pErr = sqlite3ValueNew(db)) != 0) {
		char *z;
		va_list ap;
		va_start(ap, zFormat);
		z = sqlite3VMPrintf(db, zFormat, ap);
		va_end(ap);
		sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);
	}
}


SQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...) {
	char *zMsg;
	va_list ap;
	sqlite3 *db = pParse->db;
	va_start(ap, zFormat);
	zMsg = sqlite3VMPrintf(db, zFormat, ap);
	va_end(ap);
	if (db->suppressErr) {
		sqlite3DbFree(db, zMsg);
	}
	else {
		pParse->nErr++;
		sqlite3DbFree(db, pParse->zErrMsg);
		pParse->zErrMsg = zMsg;
		pParse->rc = SQLITE_ERROR;
	}
}


SQLITE_PRIVATE void sqlite3Dequote(char *z) {
	char quote;
	int i, j;
	if (z == 0) return;
	quote = z[0];
	if (!sqlite3Isquote(quote)) return;
	if (quote == '[') quote = ']';
	for (i = 1, j = 0;; i++) {
		assert(z[i]);
		if (z[i] == quote) {
			if (z[i + 1] == quote) {
				z[j++] = quote;
				i++;
			}
			else {
				break;
			}
		}
		else {
			z[j++] = z[i];
		}
	}
	z[j] = 0;
}


SQLITE_PRIVATE void sqlite3TokenInit(Token *p, char *z) {
	p->z = z;
	p->n = sqlite3Strlen30(z);
}


#define UpperToLower sqlite3UpperToLower


SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight) {
	if (zLeft == 0) {
		return zRight ? -1 : 0;
	}
	else if (zRight == 0) {
		return 1;
	}
	return sqlite3StrICmp(zLeft, zRight);
}
SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight) {
	unsigned char *a, *b;
	int c;
	a = (unsigned char *)zLeft;
	b = (unsigned char *)zRight;
	for (;;) {
		c = (int)UpperToLower[*a] - (int)UpperToLower[*b];
		if (c || *a == 0) break;
		a++;
		b++;
	}
	return c;
}
SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N) {
	register unsigned char *a, *b;
	if (zLeft == 0) {
		return zRight ? -1 : 0;
	}
	else if (zRight == 0) {
		return 1;
	}
	a = (unsigned char *)zLeft;
	b = (unsigned char *)zRight;
	while (N-- > 0 && *a != 0 && UpperToLower[*a] == UpperToLower[*b]) { a++; b++; }
	return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];
}


SQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc) {
#ifndef SQLITE_OMIT_FLOATING_POINT
	int incr;
	const char *zEnd = z + length;
	
	int sign = 1;    
	i64 s = 0;       
	int d = 0;       
	int esign = 1;   
	int e = 0;       
	int eValid = 1;  
	double result;
	int nDigits = 0;
	int nonNum = 0;  

	assert(enc == SQLITE_UTF8 || enc == SQLITE_UTF16LE || enc == SQLITE_UTF16BE);
	*pResult = 0.0;   

	if (enc == SQLITE_UTF8) {
		incr = 1;
	}
	else {
		int i;
		incr = 2;
		assert(SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3);
		for (i = 3 - enc; i<length && z[i] == 0; i += 2) {}
		nonNum = i<length;
		zEnd = &z[i ^ 1];
		z += (enc & 1);
	}

	
	while (z<zEnd && sqlite3Isspace(*z)) z += incr;
	if (z >= zEnd) return 0;

	
	if (*z == '-') {
		sign = -1;
		z += incr;
	}
	else if (*z == '+') {
		z += incr;
	}

	
	while (z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64 - 9) / 10)) {
		s = s * 10 + (*z - '0');
		z += incr, nDigits++;
	}

	
	while (z<zEnd && sqlite3Isdigit(*z)) z += incr, nDigits++, d++;
	if (z >= zEnd) goto do_atof_calc;

	
	if (*z == '.') {
		z += incr;
		
		while (z<zEnd && sqlite3Isdigit(*z)) {
			if (s<((LARGEST_INT64 - 9) / 10)) {
				s = s * 10 + (*z - '0');
				d--;
			}
			z += incr, nDigits++;
		}
	}
	if (z >= zEnd) goto do_atof_calc;

	
	if (*z == 'e' || *z == 'E') {
		z += incr;
		eValid = 0;

		
		if (z >= zEnd) goto do_atof_calc;              

													   
		if (*z == '-') {
			esign = -1;
			z += incr;
		}
		else if (*z == '+') {
			z += incr;
		}
		
		while (z<zEnd && sqlite3Isdigit(*z)) {
			e = e<10000 ? (e * 10 + (*z - '0')) : 10000;
			z += incr;
			eValid = 1;
		}
	}

	
	while (z<zEnd && sqlite3Isspace(*z)) z += incr;

do_atof_calc:
	
	e = (e*esign) + d;
	if (e<0) {
		esign = -1;
		e *= -1;
	}
	else {
		esign = 1;
	}

	if (s == 0) {
		
		result = sign<0 ? -(double)0 : (double)0;
	}
	else {
		
		while (e>0) {                                       
			if (esign>0) {
				if (s >= (LARGEST_INT64 / 10)) break;             
				s *= 10;
			}
			else {
				if (s % 10 != 0) break;                           
				s /= 10;
			}
			e--;
		}

		
		s = sign<0 ? -s : s;

		if (e == 0) {                                         
			result = (double)s;
		}
		else {
			LONGDOUBLE_TYPE scale = 1.0;
			
			if (e>307) {                                      
				if (e<342) {                                    
					while (e % 308) { scale *= 1.0e+1; e -= 1; }
					if (esign<0) {
						result = s / scale;
						result /= 1.0e+308;
					}
					else {
						result = s * scale;
						result *= 1.0e+308;
					}
				}
				else {
					assert(e >= 342);
					if (esign<0) {
						result = 0.0*s;
					}
					else {
						result = 1e308*1e308*s;  
					}
				}
			}
			else {
				
				while (e % 22) { scale *= 1.0e+1; e -= 1; }
				while (e>0) { scale *= 1.0e+22; e -= 22; }
				if (esign<0) {
					result = s / scale;
				}
				else {
					result = s * scale;
				}
			}
		}
	}

	
	*pResult = result;

	
	return z == zEnd && nDigits>0 && eValid && nonNum == 0;
#else
	return !sqlite3Atoi64(z, pResult, length, enc);
#endif 
}


static int compare2pow63(const char *zNum, int incr) {
	int c = 0;
	int i;
	
	const char *pow63 = "922337203685477580";
	for (i = 0; c == 0 && i<18; i++) {
		c = (zNum[i*incr] - pow63[i]) * 10;
	}
	if (c == 0) {
		c = zNum[18 * incr] - '8';
		testcase(c == (-1));
		testcase(c == 0);
		testcase(c == (+1));
	}
	return c;
}


SQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc) {
	int incr;
	u64 u = 0;
	int neg = 0; 
	int i;
	int c = 0;
	int nonNum = 0;  
	const char *zStart;
	const char *zEnd = zNum + length;
	assert(enc == SQLITE_UTF8 || enc == SQLITE_UTF16LE || enc == SQLITE_UTF16BE);
	if (enc == SQLITE_UTF8) {
		incr = 1;
	}
	else {
		incr = 2;
		assert(SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3);
		for (i = 3 - enc; i<length && zNum[i] == 0; i += 2) {}
		nonNum = i<length;
		zEnd = &zNum[i ^ 1];
		zNum += (enc & 1);
	}
	while (zNum<zEnd && sqlite3Isspace(*zNum)) zNum += incr;
	if (zNum<zEnd) {
		if (*zNum == '-') {
			neg = 1;
			zNum += incr;
		}
		else if (*zNum == '+') {
			zNum += incr;
		}
	}
	zStart = zNum;
	while (zNum<zEnd && zNum[0] == '0') { zNum += incr; } 
	for (i = 0; &zNum[i]<zEnd && (c = zNum[i]) >= '0' && c <= '9'; i += incr) {
		u = u * 10 + c - '0';
	}
	if (u>LARGEST_INT64) {
		*pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;
	}
	else if (neg) {
		*pNum = -(i64)u;
	}
	else {
		*pNum = (i64)u;
	}
	testcase(i == 18);
	testcase(i == 19);
	testcase(i == 20);
	if (&zNum[i]<zEnd              
		|| (i == 0 && zStart == zNum)     
		|| i>19 * incr                  
		|| nonNum                     
		) {
		
		return 1;
	}
	else if (i<19 * incr) {
		
		assert(u <= LARGEST_INT64);
		return 0;
	}
	else {
		
		c = compare2pow63(zNum, incr);
		if (c<0) {
			
			assert(u <= LARGEST_INT64);
			return 0;
		}
		else if (c>0) {
			
			return 1;
		}
		else {
			
			assert(u - 1 == LARGEST_INT64);
			return neg ? 0 : 2;
		}
	}
}


SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char *z, i64 *pOut) {
#ifndef SQLITE_OMIT_HEX_INTEGER
	if (z[0] == '0'
		&& (z[1] == 'x' || z[1] == 'X')
		) {
		u64 u = 0;
		int i, k;
		for (i = 2; z[i] == '0'; i++) {}
		for (k = i; sqlite3Isxdigit(z[k]); k++) {
			u = u * 16 + sqlite3HexToInt(z[k]);
		}
		memcpy(pOut, &u, 8);
		return (z[k] == 0 && k - i <= 16) ? 0 : 1;
	}
	else
#endif 
	{
		return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);
	}
}


SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue) {
	sqlite_int64 v = 0;
	int i, c;
	int neg = 0;
	if (zNum[0] == '-') {
		neg = 1;
		zNum++;
	}
	else if (zNum[0] == '+') {
		zNum++;
	}
#ifndef SQLITE_OMIT_HEX_INTEGER
	else if (zNum[0] == '0'
		&& (zNum[1] == 'x' || zNum[1] == 'X')
		&& sqlite3Isxdigit(zNum[2])
		) {
		u32 u = 0;
		zNum += 2;
		while (zNum[0] == '0') zNum++;
		for (i = 0; sqlite3Isxdigit(zNum[i]) && i<8; i++) {
			u = u * 16 + sqlite3HexToInt(zNum[i]);
		}
		if ((u & 0x80000000) == 0 && sqlite3Isxdigit(zNum[i]) == 0) {
			memcpy(pValue, &u, 4);
			return 1;
		}
		else {
			return 0;
		}
	}
#endif
	while (zNum[0] == '0') zNum++;
	for (i = 0; i<11 && (c = zNum[i] - '0') >= 0 && c <= 9; i++) {
		v = v * 10 + c;
	}

	
	testcase(i == 10);
	if (i>10) {
		return 0;
	}
	testcase(v - neg == 2147483647);
	if (v - neg>2147483647) {
		return 0;
	}
	if (neg) {
		v = -v;
	}
	*pValue = (int)v;
	return 1;
}


SQLITE_PRIVATE int sqlite3Atoi(const char *z) {
	int x = 0;
	if (z) sqlite3GetInt32(z, &x);
	return x;
}




static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v) {
	int i, j, n;
	u8 buf[10];
	if (v & (((u64)0xff000000) << 32)) {
		p[8] = (u8)v;
		v >>= 8;
		for (i = 7; i >= 0; i--) {
			p[i] = (u8)((v & 0x7f) | 0x80);
			v >>= 7;
		}
		return 9;
	}
	n = 0;
	do {
		buf[n++] = (u8)((v & 0x7f) | 0x80);
		v >>= 7;
	} while (v != 0);
	buf[0] &= 0x7f;
	assert(n <= 9);
	for (i = 0, j = n - 1; j >= 0; j--, i++) {
		p[i] = buf[j];
	}
	return n;
}
SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v) {
	if (v <= 0x7f) {
		p[0] = v & 0x7f;
		return 1;
	}
	if (v <= 0x3fff) {
		p[0] = ((v >> 7) & 0x7f) | 0x80;
		p[1] = v & 0x7f;
		return 2;
	}
	return putVarint64(p, v);
}


#define SLOT_2_0     0x001fc07f
#define SLOT_4_2_0   0xf01fc07f



SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v) {
	u32 a, b, s;

	a = *p;
	
	if (!(a & 0x80))
	{
		*v = a;
		return 1;
	}

	p++;
	b = *p;
	
	if (!(b & 0x80))
	{
		a &= 0x7f;
		a = a << 7;
		a |= b;
		*v = a;
		return 2;
	}

	
	assert(SLOT_2_0 == ((0x7f << 14) | (0x7f)));
	assert(SLOT_4_2_0 == ((0xfU << 28) | (0x7f << 14) | (0x7f)));

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		a &= SLOT_2_0;
		b &= 0x7f;
		b = b << 7;
		a |= b;
		*v = a;
		return 3;
	}

	
	a &= SLOT_2_0;
	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		b &= SLOT_2_0;
		
		
		a = a << 7;
		a |= b;
		*v = a;
		return 4;
	}

	
	
	
	
	
	b &= SLOT_2_0;
	s = a;
	

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		
		
		
		b = b << 7;
		a |= b;
		s = s >> 18;
		*v = ((u64)s) << 32 | a;
		return 5;
	}

	
	s = s << 7;
	s |= b;
	

	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		
		
		a &= SLOT_2_0;
		a = a << 7;
		a |= b;
		s = s >> 18;
		*v = ((u64)s) << 32 | a;
		return 6;
	}

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		a &= SLOT_4_2_0;
		b &= SLOT_2_0;
		b = b << 7;
		a |= b;
		s = s >> 11;
		*v = ((u64)s) << 32 | a;
		return 7;
	}

	
	a &= SLOT_2_0;
	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		b &= SLOT_4_2_0;
		
		
		a = a << 7;
		a |= b;
		s = s >> 4;
		*v = ((u64)s) << 32 | a;
		return 8;
	}

	p++;
	a = a << 15;
	a |= *p;
	

	
	
	b &= SLOT_2_0;
	b = b << 8;
	a |= b;

	s = s << 4;
	b = p[-4];
	b &= 0x7f;
	b = b >> 3;
	s |= b;

	*v = ((u64)s) << 32 | a;

	return 9;
}


SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v) {
	u32 a, b;

	
	a = *p;
	
#ifndef getVarint32
	if (!(a & 0x80))
	{
		
		*v = a;
		return 1;
	}
#endif

	
	p++;
	b = *p;
	
	if (!(b & 0x80))
	{
		
		a &= 0x7f;
		a = a << 7;
		*v = a | b;
		return 2;
	}

	
	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		
		a &= (0x7f << 14) | (0x7f);
		b &= 0x7f;
		b = b << 7;
		*v = a | b;
		return 3;
	}

	
#if 1
	{
		u64 v64;
		u8 n;

		p -= 2;
		n = sqlite3GetVarint(p, &v64);
		assert(n>3 && n <= 9);
		if ((v64 & SQLITE_MAX_U32) != v64) {
			*v = 0xffffffff;
		}
		else {
			*v = (u32)v64;
		}
		return n;
	}

#else
	
	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		
		b &= (0x7f << 14) | (0x7f);
		a &= (0x7f << 14) | (0x7f);
		a = a << 7;
		*v = a | b;
		return 4;
	}

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		
		a &= SLOT_4_2_0;
		b &= SLOT_4_2_0;
		b = b << 7;
		*v = a | b;
		return 5;
	}

	
	{
		u64 v64;
		u8 n;

		p -= 4;
		n = sqlite3GetVarint(p, &v64);
		assert(n>5 && n <= 9);
		*v = (u32)v64;
		return n;
	}
#endif
}


SQLITE_PRIVATE int sqlite3VarintLen(u64 v) {
	int i;
	for (i = 1; (v >>= 7) != 0; i++) { assert(i<10); }
	return i;
}



SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p) {
#if SQLITE_BYTEORDER==4321
	u32 x;
	memcpy(&x, p, 4);
	return x;
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && defined(__GNUC__) && GCC_VERSION>=4003000
	u32 x;
	memcpy(&x, p, 4);
	return __builtin_bswap32(x);
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && defined(_MSC_VER) && _MSC_VER>=1300
	u32 x;
	memcpy(&x, p, 4);
	return _byteswap_ulong(x);
#else
	testcase(p[0] & 0x80);
	return ((unsigned)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
#endif
}
SQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v) {
#if SQLITE_BYTEORDER==4321
	memcpy(p, &v, 4);
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && defined(__GNUC__) && GCC_VERSION>=4003000
	u32 x = __builtin_bswap32(v);
	memcpy(p, &x, 4);
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && defined(_MSC_VER) && _MSC_VER>=1300
	u32 x = _byteswap_ulong(v);
	memcpy(p, &x, 4);
#else
	p[0] = (u8)(v >> 24);
	p[1] = (u8)(v >> 16);
	p[2] = (u8)(v >> 8);
	p[3] = (u8)v;
#endif
}




SQLITE_PRIVATE u8 sqlite3HexToInt(int h) {
	assert((h >= '0' && h <= '9') || (h >= 'a' && h <= 'f') || (h >= 'A' && h <= 'F'));
#ifdef SQLITE_ASCII
	h += 9 * (1 & (h >> 6));
#endif
#ifdef SQLITE_EBCDIC
	h += 9 * (1 & ~(h >> 4));
#endif
	return (u8)(h & 0xf);
}

#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)

SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n) {
	char *zBlob;
	int i;

	zBlob = (char *)sqlite3DbMallocRawNN(db, n / 2 + 1);
	n--;
	if (zBlob) {
		for (i = 0; i<n; i += 2) {
			zBlob[i / 2] = (sqlite3HexToInt(z[i]) << 4) | sqlite3HexToInt(z[i + 1]);
		}
		zBlob[i / 2] = 0;
	}
	return zBlob;
}
#endif 


static void logBadConnection(const char *zType) {
	sqlite3_log(SQLITE_MISUSE,
		"API call with %s database connection pointer",
		zType
	);
}


SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db) {
	u32 magic;
	if (db == 0) {
		logBadConnection("NULL");
		return 0;
	}
	magic = db->magic;
	if (magic != SQLITE_MAGIC_OPEN) {
		if (sqlite3SafetyCheckSickOrOk(db)) {
			testcase(sqlite3GlobalConfig.xLog != 0);
			logBadConnection("unopened");
		}
		return 0;
	}
	else {
		return 1;
	}
}
SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db) {
	u32 magic;
	magic = db->magic;
	if (magic != SQLITE_MAGIC_SICK &&
		magic != SQLITE_MAGIC_OPEN &&
		magic != SQLITE_MAGIC_BUSY) {
		testcase(sqlite3GlobalConfig.xLog != 0);
		logBadConnection("invalid");
		return 0;
	}
	else {
		return 1;
	}
}


SQLITE_PRIVATE int sqlite3AddInt64(i64 *pA, i64 iB) {
	i64 iA = *pA;
	testcase(iA == 0); testcase(iA == 1);
	testcase(iB == -1); testcase(iB == 0);
	if (iB >= 0) {
		testcase(iA>0 && LARGEST_INT64 - iA == iB);
		testcase(iA>0 && LARGEST_INT64 - iA == iB - 1);
		if (iA>0 && LARGEST_INT64 - iA < iB) return 1;
	}
	else {
		testcase(iA<0 && -(iA + LARGEST_INT64) == iB + 1);
		testcase(iA<0 && -(iA + LARGEST_INT64) == iB + 2);
		if (iA<0 && -(iA + LARGEST_INT64) > iB + 1) return 1;
	}
	*pA += iB;
	return 0;
}
SQLITE_PRIVATE int sqlite3SubInt64(i64 *pA, i64 iB) {
	testcase(iB == SMALLEST_INT64 + 1);
	if (iB == SMALLEST_INT64) {
		testcase((*pA) == (-1)); testcase((*pA) == 0);
		if ((*pA) >= 0) return 1;
		*pA -= iB;
		return 0;
	}
	else {
		return sqlite3AddInt64(pA, -iB);
	}
}
SQLITE_PRIVATE int sqlite3MulInt64(i64 *pA, i64 iB) {
	i64 iA = *pA;
	if (iB>0) {
		if (iA>LARGEST_INT64 / iB) return 1;
		if (iA<SMALLEST_INT64 / iB) return 1;
	}
	else if (iB<0) {
		if (iA>0) {
			if (iB<SMALLEST_INT64 / iA) return 1;
		}
		else if (iA<0) {
			if (iB == SMALLEST_INT64) return 1;
			if (iA == SMALLEST_INT64) return 1;
			if (-iA>LARGEST_INT64 / -iB) return 1;
		}
	}
	*pA = iA*iB;
	return 0;
}


SQLITE_PRIVATE int sqlite3AbsInt32(int x) {
	if (x >= 0) return x;
	if (x == (int)0x80000000) return 0x7fffffff;
	return -x;
}

#ifdef SQLITE_ENABLE_8_3_NAMES

SQLITE_PRIVATE void sqlite3FileSuffix3(const char *zBaseFilename, char *z) {
#if SQLITE_ENABLE_8_3_NAMES<2
	if (sqlite3_uri_boolean(zBaseFilename, "8_3_names", 0))
#endif
	{
		int i, sz;
		sz = sqlite3Strlen30(z);
		for (i = sz - 1; i>0 && z[i] != '/' && z[i] != '.'; i--) {}
		if (z[i] == '.' && ALWAYS(sz>i + 4)) memmove(&z[i + 1], &z[sz - 3], 4);
	}
}
#endif


SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst a, LogEst b) {
	static const unsigned char x[] = {
		10, 10,                         
		9, 9,                          
		8, 8,                          
		7, 7, 7,                       
		6, 6, 6,                       
		5, 5, 5,                       
		4, 4, 4, 4,                    
		3, 3, 3, 3, 3, 3,              
		2, 2, 2, 2, 2, 2, 2,           
	};
	if (a >= b) {
		if (a>b + 49) return a;
		if (a>b + 31) return a + 1;
		return a + x[a - b];
	}
	else {
		if (b>a + 49) return b;
		if (b>a + 31) return b + 1;
		return b + x[b - a];
	}
}


SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x) {
	static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };
	LogEst y = 40;
	if (x<8) {
		if (x<2) return 0;
		while (x<8) { y -= 10; x <<= 1; }
	}
	else {
		while (x>255) { y += 40; x >>= 4; }  
		while (x>15) { y += 10; x >>= 1; }
	}
	return a[x & 7] + y - 10;
}

#ifndef SQLITE_OMIT_VIRTUALTABLE

SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x) {
	u64 a;
	LogEst e;
	assert(sizeof(x) == 8 && sizeof(a) == 8);
	if (x <= 1) return 0;
	if (x <= 2000000000) return sqlite3LogEst((u64)x);
	memcpy(&a, &x, 8);
	e = (a >> 52) - 1022;
	return e * 10;
}
#endif 

#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \
    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)

SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x) {
	u64 n;
	n = x % 10;
	x /= 10;
	if (n >= 5) n -= 2;
	else if (n >= 1) n -= 1;
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
	if (x>60) return (u64)LARGEST_INT64;
#else
	
	assert(x <= 60);
#endif
	return x >= 3 ? (n + 8) << (x - 3) : (n + 8) >> (3 - x);
}
#endif 








SQLITE_PRIVATE void sqlite3HashInit(Hash *pNew) {
	assert(pNew != 0);
	pNew->first = 0;
	pNew->count = 0;
	pNew->htsize = 0;
	pNew->ht = 0;
}


SQLITE_PRIVATE void sqlite3HashClear(Hash *pH) {
	HashElem *elem;         

	assert(pH != 0);
	elem = pH->first;
	pH->first = 0;
	sqlite3_free(pH->ht);
	pH->ht = 0;
	pH->htsize = 0;
	while (elem) {
		HashElem *next_elem = elem->next;
		sqlite3_free(elem);
		elem = next_elem;
	}
	pH->count = 0;
}


static unsigned int strHash(const char *z) {
	unsigned int h = 0;
	unsigned char c;
	while ((c = (unsigned char)*z++) != 0) {     
												 
		h += sqlite3UpperToLower[c];
		h *= 0x9e3779b1;
	}
	return h;
}



static void insertElement(
	Hash *pH,              
	struct _ht *pEntry,    
	HashElem *pNew         
) {
	HashElem *pHead;       
	if (pEntry) {
		pHead = pEntry->count ? pEntry->chain : 0;
		pEntry->count++;
		pEntry->chain = pNew;
	}
	else {
		pHead = 0;
	}
	if (pHead) {
		pNew->next = pHead;
		pNew->prev = pHead->prev;
		if (pHead->prev) { pHead->prev->next = pNew; }
		else { pH->first = pNew; }
		pHead->prev = pNew;
	}
	else {
		pNew->next = pH->first;
		if (pH->first) { pH->first->prev = pNew; }
		pNew->prev = 0;
		pH->first = pNew;
	}
}



static int rehash(Hash *pH, unsigned int new_size) {
	struct _ht *new_ht;            
	HashElem *elem, *next_elem;    

#if SQLITE_MALLOC_SOFT_LIMIT>0
	if (new_size * sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT) {
		new_size = SQLITE_MALLOC_SOFT_LIMIT / sizeof(struct _ht);
	}
	if (new_size == pH->htsize) return 0;
#endif

	
	sqlite3BeginBenignMalloc();
	new_ht = (struct _ht *)sqlite3Malloc(new_size * sizeof(struct _ht));
	sqlite3EndBenignMalloc();

	if (new_ht == 0) return 0;
	sqlite3_free(pH->ht);
	pH->ht = new_ht;
	pH->htsize = new_size = sqlite3MallocSize(new_ht) / sizeof(struct _ht);
	memset(new_ht, 0, new_size * sizeof(struct _ht));
	for (elem = pH->first, pH->first = 0; elem; elem = next_elem) {
		unsigned int h = strHash(elem->pKey) % new_size;
		next_elem = elem->next;
		insertElement(pH, &new_ht[h], elem);
	}
	return 1;
}


static HashElem *findElementWithHash(
	const Hash *pH,     
	const char *pKey,   
	unsigned int *pHash 
) {
	HashElem *elem;                
	int count;                     
	unsigned int h;                

	if (pH->ht) {   
		struct _ht *pEntry;
		h = strHash(pKey) % pH->htsize;
		pEntry = &pH->ht[h];
		elem = pEntry->chain;
		count = pEntry->count;
	}
	else {
		h = 0;
		elem = pH->first;
		count = pH->count;
	}
	*pHash = h;
	while (count--) {
		assert(elem != 0);
		if (sqlite3StrICmp(elem->pKey, pKey) == 0) {
			return elem;
		}
		elem = elem->next;
	}
	return 0;
}


static void removeElementGivenHash(
	Hash *pH,         
	HashElem* elem,   
	unsigned int h    
) {
	struct _ht *pEntry;
	if (elem->prev) {
		elem->prev->next = elem->next;
	}
	else {
		pH->first = elem->next;
	}
	if (elem->next) {
		elem->next->prev = elem->prev;
	}
	if (pH->ht) {
		pEntry = &pH->ht[h];
		if (pEntry->chain == elem) {
			pEntry->chain = elem->next;
		}
		pEntry->count--;
		assert(pEntry->count >= 0);
	}
	sqlite3_free(elem);
	pH->count--;
	if (pH->count == 0) {
		assert(pH->first == 0);
		assert(pH->count == 0);
		sqlite3HashClear(pH);
	}
}


SQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey) {
	HashElem *elem;    
	unsigned int h;    

	assert(pH != 0);
	assert(pKey != 0);
	elem = findElementWithHash(pH, pKey, &h);
	return elem ? elem->data : 0;
}


SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data) {
	unsigned int h;       
	HashElem *elem;       
	HashElem *new_elem;   

	assert(pH != 0);
	assert(pKey != 0);
	elem = findElementWithHash(pH, pKey, &h);
	if (elem) {
		void *old_data = elem->data;
		if (data == 0) {
			removeElementGivenHash(pH, elem, h);
		}
		else {
			elem->data = data;
			elem->pKey = pKey;
		}
		return old_data;
	}
	if (data == 0) return 0;
	new_elem = (HashElem*)sqlite3Malloc(sizeof(HashElem));
	if (new_elem == 0) return data;
	new_elem->pKey = pKey;
	new_elem->data = data;
	pH->count++;
	if (pH->count >= 10 && pH->count > 2 * pH->htsize) {
		if (rehash(pH, pH->count * 2)) {
			assert(pH->htsize>0);
			h = strHash(pKey) % pH->htsize;
		}
	}
	insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);
	return 0;
}





#if !defined(SQLITE_OMIT_EXPLAIN) \
 || defined(VDBE_PROFILE) \
 || defined(SQLITE_DEBUG)
#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) || defined(SQLITE_DEBUG)
# define OpHelp(X) "\0" X
#else
# define OpHelp(X)
#endif
SQLITE_PRIVATE const char *sqlite3OpcodeName(int i) {
	static const char *const azName[] = {
		 "Savepoint"        OpHelp(""),
		 "AutoCommit"       OpHelp(""),
		 "Transaction"      OpHelp(""),
		 "SorterNext"       OpHelp(""),
		 "PrevIfOpen"       OpHelp(""),
		 "NextIfOpen"       OpHelp(""),
		 "Prev"             OpHelp(""),
		 "Next"             OpHelp(""),
		 "Checkpoint"       OpHelp(""),
		 "JournalMode"      OpHelp(""),
		 "Vacuum"           OpHelp(""),
		 "VFilter"          OpHelp("iplan=r[P3] zplan='P4'"),
		 "VUpdate"          OpHelp("data=r[P3@P2]"),
		 "Goto"             OpHelp(""),
		 "Gosub"            OpHelp(""),
		 "InitCoroutine"    OpHelp(""),
		 "Yield"            OpHelp(""),
		 "MustBeInt"        OpHelp(""),
		 "Jump"             OpHelp(""),
		 "Not"              OpHelp("r[P2]= !r[P1]"),
		 "Once"             OpHelp(""),
		 "If"               OpHelp(""),
		 "IfNot"            OpHelp(""),
		 "SeekLT"           OpHelp("key=r[P3@P4]"),
		 "SeekLE"           OpHelp("key=r[P3@P4]"),
		 "SeekGE"           OpHelp("key=r[P3@P4]"),
		 "SeekGT"           OpHelp("key=r[P3@P4]"),
		 "Or"               OpHelp("r[P3]=(r[P1] || r[P2])"),
		 "And"              OpHelp("r[P3]=(r[P1] && r[P2])"),
		 "NoConflict"       OpHelp("key=r[P3@P4]"),
		 "NotFound"         OpHelp("key=r[P3@P4]"),
		 "Found"            OpHelp("key=r[P3@P4]"),
		 "SeekRowid"        OpHelp("intkey=r[P3]"),
		 "NotExists"        OpHelp("intkey=r[P3]"),
		 "IsNull"           OpHelp("if r[P1]==NULL goto P2"),
		 "NotNull"          OpHelp("if r[P1]!=NULL goto P2"),
		 "Ne"               OpHelp("IF r[P3]!=r[P1]"),
		 "Eq"               OpHelp("IF r[P3]==r[P1]"),
		 "Gt"               OpHelp("IF r[P3]>r[P1]"),
		 "Le"               OpHelp("IF r[P3]<=r[P1]"),
		 "Lt"               OpHelp("IF r[P3]<r[P1]"),
		 "Ge"               OpHelp("IF r[P3]>=r[P1]"),
		 "ElseNotEq"        OpHelp(""),
		 "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),
		 "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),
		 "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),
		 "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),
		 "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),
		 "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),
		 "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),
		 "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),
		 "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),
		 "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
		 "Last"             OpHelp(""),
		 "BitNot"           OpHelp("r[P1]= ~r[P1]"),
		 "SorterSort"       OpHelp(""),
		 "Sort"             OpHelp(""),
		 "Rewind"           OpHelp(""),
		 "IdxLE"            OpHelp("key=r[P3@P4]"),
		 "IdxGT"            OpHelp("key=r[P3@P4]"),
		 "IdxLT"            OpHelp("key=r[P3@P4]"),
		 "IdxGE"            OpHelp("key=r[P3@P4]"),
		 "RowSetRead"       OpHelp("r[P3]=rowset(P1)"),
		 "RowSetTest"       OpHelp("if r[P3] in rowset(P1) goto P2"),
		 "Program"          OpHelp(""),
		 "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),
		 "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),
		 "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]-=P3, goto P2"),
		 "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),
		 "IncrVacuum"       OpHelp(""),
		 "VNext"            OpHelp(""),
		 "Init"             OpHelp("Start at P2"),
		 "Return"           OpHelp(""),
		 "EndCoroutine"     OpHelp(""),
		 "HaltIfNull"       OpHelp("if r[P3]=null halt"),
		 "Halt"             OpHelp(""),
		 "Integer"          OpHelp("r[P2]=P1"),
		 "Int64"            OpHelp("r[P2]=P4"),
		 "String"           OpHelp("r[P2]='P4' (len=P1)"),
		 "Null"             OpHelp("r[P2..P3]=NULL"),
		 "SoftNull"         OpHelp("r[P1]=NULL"),
		 "Blob"             OpHelp("r[P2]=P4 (len=P1)"),
		 "Variable"         OpHelp("r[P2]=parameter(P1,P4)"),
		 "Move"             OpHelp("r[P2@P3]=r[P1@P3]"),
		 "Copy"             OpHelp("r[P2@P3+1]=r[P1@P3+1]"),
		 "SCopy"            OpHelp("r[P2]=r[P1]"),
		 "IntCopy"          OpHelp("r[P2]=r[P1]"),
		 "ResultRow"        OpHelp("output=r[P1@P2]"),
		 "CollSeq"          OpHelp(""),
		 "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),
		 "Function"         OpHelp("r[P3]=func(r[P2@P5])"),
		 "AddImm"           OpHelp("r[P1]=r[P1]+P2"),
		 "RealAffinity"     OpHelp(""),
		 "Cast"             OpHelp("affinity(r[P1])"),
		 "Permutation"      OpHelp(""),
		 "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),
		 "Column"           OpHelp("r[P3]=PX"),
		 "String8"          OpHelp("r[P2]='P4'"),
		 "Affinity"         OpHelp("affinity(r[P1@P2])"),
		 "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
		 "Count"            OpHelp("r[P2]=count()"),
		 "ReadCookie"       OpHelp(""),
		 "SetCookie"        OpHelp(""),
		 "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
		 "OpenRead"         OpHelp("root=P2 iDb=P3"),
		 "OpenWrite"        OpHelp("root=P2 iDb=P3"),
		 "OpenAutoindex"    OpHelp("nColumn=P2"),
		 "OpenEphemeral"    OpHelp("nColumn=P2"),
		 "SorterOpen"       OpHelp(""),
		 "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),
		 "OpenPseudo"       OpHelp("P3 columns in r[P2]"),
		 "Close"            OpHelp(""),
		 "ColumnsUsed"      OpHelp(""),
		 "Sequence"         OpHelp("r[P2]=cursor[P1].ctr++"),
		 "NewRowid"         OpHelp("r[P2]=rowid"),
		 "Insert"           OpHelp("intkey=r[P3] data=r[P2]"),
		 "InsertInt"        OpHelp("intkey=P3 data=r[P2]"),
		 "Delete"           OpHelp(""),
		 "ResetCount"       OpHelp(""),
		 "SorterCompare"    OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),
		 "SorterData"       OpHelp("r[P2]=data"),
		 "RowKey"           OpHelp("r[P2]=key"),
		 "RowData"          OpHelp("r[P2]=data"),
		 "Rowid"            OpHelp("r[P2]=rowid"),
		 "NullRow"          OpHelp(""),
		 "SorterInsert"     OpHelp(""),
		 "IdxInsert"        OpHelp("key=r[P2]"),
		 "IdxDelete"        OpHelp("key=r[P2@P3]"),
		 "Seek"             OpHelp("Move P3 to P1.rowid"),
		 "IdxRowid"         OpHelp("r[P2]=rowid"),
		 "Destroy"          OpHelp(""),
		 "Clear"            OpHelp(""),
		 "Real"             OpHelp("r[P2]=P4"),
		 "ResetSorter"      OpHelp(""),
		 "CreateIndex"      OpHelp("r[P2]=root iDb=P1"),
		 "CreateTable"      OpHelp("r[P2]=root iDb=P1"),
		 "ParseSchema"      OpHelp(""),
		 "LoadAnalysis"     OpHelp(""),
		 "DropTable"        OpHelp(""),
		 "DropIndex"        OpHelp(""),
		 "DropTrigger"      OpHelp(""),
		 "IntegrityCk"      OpHelp(""),
		 "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),
		 "Param"            OpHelp(""),
		 "FkCounter"        OpHelp("fkctr[P1]+=P2"),
		 "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
		 "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),
		 "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),
		 "AggStep"          OpHelp("accum=r[P3] step(r[P2@P5])"),
		 "AggFinal"         OpHelp("accum=r[P1] N=P2"),
		 "Expire"           OpHelp(""),
		 "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),
		 "VBegin"           OpHelp(""),
		 "VCreate"          OpHelp(""),
		 "VDestroy"         OpHelp(""),
		 "VOpen"            OpHelp(""),
		 "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),
		 "VRename"          OpHelp(""),
		 "Pagecount"        OpHelp(""),
		 "MaxPgcnt"         OpHelp(""),
		 "CursorHint"       OpHelp(""),
		 "Noop"             OpHelp(""),
		 "Explain"          OpHelp(""),
	};
	return azName[i];
}
#endif





#if SQLITE_OS_UNIX              


#if !defined(SQLITE_ENABLE_LOCKING_STYLE)
#  if defined(__APPLE__)
#    define SQLITE_ENABLE_LOCKING_STYLE 1
#  else
#    define SQLITE_ENABLE_LOCKING_STYLE 0
#  endif
#endif


#if defined(__APPLE__)
# define HAVE_PREAD 1
# define HAVE_PWRITE 1
#endif
#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)
# undef USE_PREAD
# define USE_PREAD64 1
#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)
# undef USE_PREAD64
# define USE_PREAD 1
#endif


#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <sys/time.h>
#include <errno.h>
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
# include <sys/mman.h>
#endif

#if SQLITE_ENABLE_LOCKING_STYLE
# include <sys/ioctl.h>
# include <sys/file.h>
# include <sys/param.h>
#endif 

#if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \
                           (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))
#  if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \
       && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))
#    define HAVE_GETHOSTUUID 1
#  else
#    warning "gethostuuid() is disabled."
#  endif
#endif


#if OS_VXWORKS

# include <semaphore.h>
# include <limits.h>
#endif 

#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
# include <sys/mount.h>
#endif

#ifdef HAVE_UTIME
# include <utime.h>
#endif


#define SQLITE_FSFLAGS_IS_MSDOS     0x1


#if SQLITE_THREADSAFE

# define SQLITE_UNIX_THREADS 1
#endif


#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS
# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644
#endif


#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755
#endif


#define MAX_PATHNAME 512


#define SQLITE_MAX_SYMLINKS 100


#define osGetpid(X) (pid_t)getpid()


#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) && (x != SQLITE_BUSY))


typedef struct unixShm unixShm;               
typedef struct unixShmNode unixShmNode;       
typedef struct unixInodeInfo unixInodeInfo;   
typedef struct UnixUnusedFd UnixUnusedFd;     

											  
struct UnixUnusedFd {
	int fd;                   
	int flags;                
	UnixUnusedFd *pNext;      
};


typedef struct unixFile unixFile;
struct unixFile {
	sqlite3_io_methods const *pMethod;  
	sqlite3_vfs *pVfs;                  
	unixInodeInfo *pInode;              
	int h;                              
	unsigned char eFileLock;            
	unsigned short int ctrlFlags;       
	int lastErrno;                      
	void *lockingContext;               
	UnixUnusedFd *pUnused;              
	const char *zPath;                  
	unixShm *pShm;                      
	int szChunk;                        
#if SQLITE_MAX_MMAP_SIZE>0
	int nFetchOut;                      
	sqlite3_int64 mmapSize;             
	sqlite3_int64 mmapSizeActual;       
	sqlite3_int64 mmapSizeMax;          
	void *pMapRegion;                   
#endif
#ifdef __QNXNTO__
	int sectorSize;                     
	int deviceCharacteristics;          
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
	int openFlags;                      
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
	unsigned fsFlags;                   
#endif
#if OS_VXWORKS
	struct vxworksFileId *pId;          
#endif
#ifdef SQLITE_DEBUG
										
	unsigned char transCntrChng;   
	unsigned char dbUpdate;        
	unsigned char inNormalWrite;   

#endif

#ifdef SQLITE_TEST
								   
	char aPadding[32];
#endif
};


static pid_t randomnessPid = 0;


#define UNIXFILE_EXCL        0x01     
#define UNIXFILE_RDONLY      0x02     
#define UNIXFILE_PERSIST_WAL 0x04     
#ifndef SQLITE_DISABLE_DIRSYNC
# define UNIXFILE_DIRSYNC    0x08     
#else
# define UNIXFILE_DIRSYNC    0x00
#endif
#define UNIXFILE_PSOW        0x10     
#define UNIXFILE_DELETE      0x20     
#define UNIXFILE_URI         0x40     
#define UNIXFILE_NOLOCK      0x80     





#ifndef _OS_COMMON_H_
#define _OS_COMMON_H_


#ifdef MEMORY_DEBUG
# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
#endif


#ifdef SQLITE_PERFORMANCE_TRACE





#ifndef SQLITE_HWTIME_H
#define SQLITE_HWTIME_H


#if (defined(__GNUC__) || defined(_MSC_VER)) && \
      (defined(i386) || defined(__i386__) || defined(_M_IX86))

#if defined(__GNUC__)

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned int lo, hi;
	__asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
	return (sqlite_uint64)hi << 32 | lo;
}

#elif defined(_MSC_VER)

__declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void) {
	__asm {
		rdtsc
		ret; return value at EDX : EAX
	}
}

#endif

#elif (defined(__GNUC__) && defined(__x86_64__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long val;
	__asm__ __volatile__("rdtsc" : "=A" (val));
	return val;
}

#elif (defined(__GNUC__) && defined(__ppc__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long long retval;
	unsigned long junk;
	__asm__ __volatile__("\n\
          1:      mftbu   %1\n\
                  mftb    %L0\n\
                  mftbu   %0\n\
                  cmpw    %0,%1\n\
                  bne     1b"
		: "=r" (retval), "=r" (junk));
	return retval;
}

#else

#error Need implementation of sqlite3Hwtime() for your platform.


SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void) { return ((sqlite_uint64)0); }

#endif

#endif 




static sqlite_uint64 g_start;
static sqlite_uint64 g_elapsed;
#define TIMER_START       g_start=sqlite3Hwtime()
#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start
#define TIMER_ELAPSED     g_elapsed
#else
#define TIMER_START
#define TIMER_END
#define TIMER_ELAPSED     ((sqlite_uint64)0)
#endif


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_io_error_hit;
SQLITE_API extern int sqlite3_io_error_hardhit;
SQLITE_API extern int sqlite3_io_error_pending;
SQLITE_API extern int sqlite3_io_error_persist;
SQLITE_API extern int sqlite3_io_error_benign;
SQLITE_API extern int sqlite3_diskfull_pending;
SQLITE_API extern int sqlite3_diskfull;
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)
#define SimulateIOError(CODE)  \
  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \
       || sqlite3_io_error_pending-- == 1 )  \
              { local_ioerr(); CODE; }
static void local_ioerr() {
	IOTRACE(("IOERR\n"));
	sqlite3_io_error_hit++;
	if (!sqlite3_io_error_benign) sqlite3_io_error_hardhit++;
}
#define SimulateDiskfullError(CODE) \
   if( sqlite3_diskfull_pending ){ \
     if( sqlite3_diskfull_pending == 1 ){ \
       local_ioerr(); \
       sqlite3_diskfull = 1; \
       sqlite3_io_error_hit = 1; \
       CODE; \
     }else{ \
       sqlite3_diskfull_pending--; \
     } \
   }
#else
#define SimulateIOErrorBenign(X)
#define SimulateIOError(A)
#define SimulateDiskfullError(A)
#endif 


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_open_file_count;
#define OpenCounter(X)  sqlite3_open_file_count+=(X)
#else
#define OpenCounter(X)
#endif 

#endif 





#ifndef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifdef SQLITE_DISABLE_LFS
# undef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifndef O_NOFOLLOW
# define O_NOFOLLOW 0
#endif
#ifndef O_BINARY
# define O_BINARY 0
#endif


#if SQLITE_THREADSAFE
#define threadid pthread_self()
#else
#define threadid 0
#endif


#if !defined(HAVE_MREMAP)
# if defined(__linux__) && defined(_GNU_SOURCE)
#  define HAVE_MREMAP 1
# else
#  define HAVE_MREMAP 0
# endif
#endif


#ifdef __ANDROID__
# define lseek lseek64
#endif


static int posixOpen(const char *zFile, int flags, int mode) {
	return open(zFile, flags, mode);
}


static int openDirectory(const char*, int*);
static int unixGetpagesize(void);


static struct unix_syscall {
	const char *zName;            
	sqlite3_syscall_ptr pCurrent; 
	sqlite3_syscall_ptr pDefault; 
} aSyscall[] = {
	{ "open",         (sqlite3_syscall_ptr)posixOpen,  0 },
#define osOpen      ((int(*)(const char*,int,int))aSyscall[0].pCurrent)

	{ "close",        (sqlite3_syscall_ptr)close,      0 },
#define osClose     ((int(*)(int))aSyscall[1].pCurrent)

	{ "access",       (sqlite3_syscall_ptr)access,     0 },
#define osAccess    ((int(*)(const char*,int))aSyscall[2].pCurrent)

	{ "getcwd",       (sqlite3_syscall_ptr)getcwd,     0 },
#define osGetcwd    ((char*(*)(char*,size_t))aSyscall[3].pCurrent)

	{ "stat",         (sqlite3_syscall_ptr)stat,       0 },
#define osStat      ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)

	
#ifdef __DJGPP__
	{ "fstat",        0,                 0 },
#define osFstat(a,b,c)    0
#else     
	{ "fstat",        (sqlite3_syscall_ptr)fstat,      0 },
#define osFstat     ((int(*)(int,struct stat*))aSyscall[5].pCurrent)
#endif

	{ "ftruncate",    (sqlite3_syscall_ptr)ftruncate,  0 },
#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)

	{ "fcntl",        (sqlite3_syscall_ptr)fcntl,      0 },
#define osFcntl     ((int(*)(int,int,...))aSyscall[7].pCurrent)

	{ "read",         (sqlite3_syscall_ptr)read,       0 },
#define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)

#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
	{ "pread",        (sqlite3_syscall_ptr)pread,      0 },
#else
	{ "pread",        (sqlite3_syscall_ptr)0,          0 },
#endif
#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)

#if defined(USE_PREAD64)
	{ "pread64",      (sqlite3_syscall_ptr)pread64,    0 },
#else
	{ "pread64",      (sqlite3_syscall_ptr)0,          0 },
#endif
#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)

	{ "write",        (sqlite3_syscall_ptr)write,      0 },
#define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)

#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
	{ "pwrite",       (sqlite3_syscall_ptr)pwrite,     0 },
#else
	{ "pwrite",       (sqlite3_syscall_ptr)0,          0 },
#endif
#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\
                    aSyscall[12].pCurrent)

#if defined(USE_PREAD64)
{
	"pwrite64",     (sqlite3_syscall_ptr)pwrite64,   0
},
#else
{ "pwrite64",     (sqlite3_syscall_ptr)0,          0 },
#endif
#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off64_t))\
                    aSyscall[13].pCurrent)

{
	"fchmod",       (sqlite3_syscall_ptr)fchmod,          0
},
#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)

#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
{ "fallocate",    (sqlite3_syscall_ptr)posix_fallocate,  0 },
#else
{ "fallocate",    (sqlite3_syscall_ptr)0,                0 },
#endif
#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)

{ "unlink",       (sqlite3_syscall_ptr)unlink,           0 },
#define osUnlink    ((int(*)(const char*))aSyscall[16].pCurrent)

{ "openDirectory",    (sqlite3_syscall_ptr)openDirectory,      0 },
#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent)

{ "mkdir",        (sqlite3_syscall_ptr)mkdir,           0 },
#define osMkdir     ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)

{ "rmdir",        (sqlite3_syscall_ptr)rmdir,           0 },
#define osRmdir     ((int(*)(const char*))aSyscall[19].pCurrent)

#if defined(HAVE_FCHOWN)
{ "fchown",       (sqlite3_syscall_ptr)fchown,          0 },
#else
{ "fchown",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)

{ "geteuid",      (sqlite3_syscall_ptr)geteuid,         0 },
#define osGeteuid   ((uid_t(*)(void))aSyscall[21].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
{ "mmap",         (sqlite3_syscall_ptr)mmap,            0 },
#else
{ "mmap",         (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
{ "munmap",       (sqlite3_syscall_ptr)munmap,          0 },
#else
{ "munmap",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMunmap ((void*(*)(void*,size_t))aSyscall[23].pCurrent)

#if HAVE_MREMAP && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
{ "mremap",       (sqlite3_syscall_ptr)mremap,          0 },
#else
{ "mremap",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
{ "getpagesize",  (sqlite3_syscall_ptr)unixGetpagesize, 0 },
#else
{ "getpagesize",  (sqlite3_syscall_ptr)0,               0 },
#endif
#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent)

#if defined(HAVE_READLINK)
{ "readlink",     (sqlite3_syscall_ptr)readlink,        0 },
#else
{ "readlink",     (sqlite3_syscall_ptr)0,               0 },
#endif
#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)

#if defined(HAVE_LSTAT)
{ "lstat",         (sqlite3_syscall_ptr)lstat,          0 },
#else
{ "lstat",         (sqlite3_syscall_ptr)0,              0 },
#endif
#define osLstat      ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)

}; 


   
static int robustFchown(int fd, uid_t uid, gid_t gid) {
#if defined(HAVE_FCHOWN)
	return osGeteuid() ? 0 : osFchown(fd, uid, gid);
#else
	return 0;
#endif
}


static int unixSetSystemCall(
	sqlite3_vfs *pNotUsed,        
	const char *zName,            
	sqlite3_syscall_ptr pNewFunc  
) {
	unsigned int i;
	int rc = SQLITE_NOTFOUND;

	UNUSED_PARAMETER(pNotUsed);
	if (zName == 0) {
		
		rc = SQLITE_OK;
		for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
			if (aSyscall[i].pDefault) {
				aSyscall[i].pCurrent = aSyscall[i].pDefault;
			}
		}
	}
	else {
		
		for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
			if (strcmp(zName, aSyscall[i].zName) == 0) {
				if (aSyscall[i].pDefault == 0) {
					aSyscall[i].pDefault = aSyscall[i].pCurrent;
				}
				rc = SQLITE_OK;
				if (pNewFunc == 0) pNewFunc = aSyscall[i].pDefault;
				aSyscall[i].pCurrent = pNewFunc;
				break;
			}
		}
	}
	return rc;
}


static sqlite3_syscall_ptr unixGetSystemCall(
	sqlite3_vfs *pNotUsed,
	const char *zName
) {
	unsigned int i;

	UNUSED_PARAMETER(pNotUsed);
	for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
		if (strcmp(zName, aSyscall[i].zName) == 0) return aSyscall[i].pCurrent;
	}
	return 0;
}


static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName) {
	int i = -1;

	UNUSED_PARAMETER(p);
	if (zName) {
		for (i = 0; i<ArraySize(aSyscall) - 1; i++) {
			if (strcmp(zName, aSyscall[i].zName) == 0) break;
		}
	}
	for (i++; i<ArraySize(aSyscall); i++) {
		if (aSyscall[i].pCurrent != 0) return aSyscall[i].zName;
	}
	return 0;
}


#ifndef SQLITE_MINIMUM_FILE_DESCRIPTOR
# define SQLITE_MINIMUM_FILE_DESCRIPTOR 3
#endif


static int robust_open(const char *z, int f, mode_t m) {
	int fd;
	mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;
	while (1) {
#if defined(O_CLOEXEC)
		fd = osOpen(z, f | O_CLOEXEC, m2);
#else
		fd = osOpen(z, f, m2);
#endif
		if (fd<0) {
			if (errno == EINTR) continue;
			break;
		}
		if (fd >= SQLITE_MINIMUM_FILE_DESCRIPTOR) break;
		osClose(fd);
		sqlite3_log(SQLITE_WARNING,
			"attempt to open \"%s\" as file descriptor %d", z, fd);
		fd = -1;
		if (osOpen("/dev/null", f, m)<0) break;
	}
	if (fd >= 0) {
		if (m != 0) {
			struct stat statbuf;
			if (osFstat(fd, &statbuf) == 0
				&& statbuf.st_size == 0
				&& (statbuf.st_mode & 0777) != m
				) {
				osFchmod(fd, m);
			}
		}
#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)
		osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
#endif
	}
	return fd;
}


static void unixEnterMutex(void) {
	sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
static void unixLeaveMutex(void) {
	sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
#ifdef SQLITE_DEBUG
static int unixMutexHeld(void) {
	return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
#endif


#ifdef SQLITE_HAVE_OS_TRACE

static const char *azFileLock(int eFileLock) {
	switch (eFileLock) {
	case NO_LOCK: return "NONE";
	case SHARED_LOCK: return "SHARED";
	case RESERVED_LOCK: return "RESERVED";
	case PENDING_LOCK: return "PENDING";
	case EXCLUSIVE_LOCK: return "EXCLUSIVE";
	}
	return "ERROR";
}
#endif

#ifdef SQLITE_LOCK_TRACE

static int lockTrace(int fd, int op, struct flock *p) {
	char *zOpName, *zType;
	int s;
	int savedErrno;
	if (op == F_GETLK) {
		zOpName = "GETLK";
	}
	else if (op == F_SETLK) {
		zOpName = "SETLK";
	}
	else {
		s = osFcntl(fd, op, p);
		sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s);
		return s;
	}
	if (p->l_type == F_RDLCK) {
		zType = "RDLCK";
	}
	else if (p->l_type == F_WRLCK) {
		zType = "WRLCK";
	}
	else if (p->l_type == F_UNLCK) {
		zType = "UNLCK";
	}
	else {
		assert(0);
	}
	assert(p->l_whence == SEEK_SET);
	s = osFcntl(fd, op, p);
	savedErrno = errno;
	sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n",
		threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,
		(int)p->l_pid, s);
	if (s == (-1) && op == F_SETLK && (p->l_type == F_RDLCK || p->l_type == F_WRLCK)) {
		struct flock l2;
		l2 = *p;
		osFcntl(fd, F_GETLK, &l2);
		if (l2.l_type == F_RDLCK) {
			zType = "RDLCK";
		}
		else if (l2.l_type == F_WRLCK) {
			zType = "WRLCK";
		}
		else if (l2.l_type == F_UNLCK) {
			zType = "UNLCK";
		}
		else {
			assert(0);
		}
		sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n",
			zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);
	}
	errno = savedErrno;
	return s;
}
#undef osFcntl
#define osFcntl lockTrace
#endif 


static int robust_ftruncate(int h, sqlite3_int64 sz) {
	int rc;
#ifdef __ANDROID__
	
	if (sz>(sqlite3_int64)0x7FFFFFFF) {
		rc = SQLITE_OK;
	}
	else
#endif
		do { rc = osFtruncate(h, sz); } while (rc<0 && errno == EINTR);
	return rc;
}


static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
	assert((sqliteIOErr == SQLITE_IOERR_LOCK) ||
		(sqliteIOErr == SQLITE_IOERR_UNLOCK) ||
		(sqliteIOErr == SQLITE_IOERR_RDLOCK) ||
		(sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK));
	switch (posixError) {
	case EACCES:
	case EAGAIN:
	case ETIMEDOUT:
	case EBUSY:
	case EINTR:
	case ENOLCK:
		
		return SQLITE_BUSY;

	case EPERM:
		return SQLITE_PERM;

	default:
		return sqliteIOErr;
	}
}



struct vxworksFileId {
	struct vxworksFileId *pNext;  
	int nRef;                     
	int nName;                    
	char *zCanonicalName;         
};

#if OS_VXWORKS

static struct vxworksFileId *vxworksFileList = 0;


static int vxworksSimplifyName(char *z, int n) {
	int i, j;
	while (n>1 && z[n - 1] == '/') { n--; }
	for (i = j = 0; i<n; i++) {
		if (z[i] == '/') {
			if (z[i + 1] == '/') continue;
			if (z[i + 1] == '.' && i + 2<n && z[i + 2] == '/') {
				i += 1;
				continue;
			}
			if (z[i + 1] == '.' && i + 3<n && z[i + 2] == '.' && z[i + 3] == '/') {
				while (j>0 && z[j - 1] != '/') { j--; }
				if (j>0) { j--; }
				i += 2;
				continue;
			}
		}
		z[j++] = z[i];
	}
	z[j] = 0;
	return j;
}


static struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName) {
	struct vxworksFileId *pNew;         
	struct vxworksFileId *pCandidate;   
	int n;                              

	assert(zAbsoluteName[0] == '/');
	n = (int)strlen(zAbsoluteName);
	pNew = sqlite3_malloc64(sizeof(*pNew) + (n + 1));
	if (pNew == 0) return 0;
	pNew->zCanonicalName = (char*)&pNew[1];
	memcpy(pNew->zCanonicalName, zAbsoluteName, n + 1);
	n = vxworksSimplifyName(pNew->zCanonicalName, n);

	
	unixEnterMutex();
	for (pCandidate = vxworksFileList; pCandidate; pCandidate = pCandidate->pNext) {
		if (pCandidate->nName == n
			&& memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n) == 0
			) {
			sqlite3_free(pNew);
			pCandidate->nRef++;
			unixLeaveMutex();
			return pCandidate;
		}
	}

	
	pNew->nRef = 1;
	pNew->nName = n;
	pNew->pNext = vxworksFileList;
	vxworksFileList = pNew;
	unixLeaveMutex();
	return pNew;
}


static void vxworksReleaseFileId(struct vxworksFileId *pId) {
	unixEnterMutex();
	assert(pId->nRef>0);
	pId->nRef--;
	if (pId->nRef == 0) {
		struct vxworksFileId **pp;
		for (pp = &vxworksFileList; *pp && *pp != pId; pp = &((*pp)->pNext)) {}
		assert(*pp == pId);
		*pp = pId->pNext;
		sqlite3_free(pId);
	}
	unixLeaveMutex();
}
#endif 






struct unixFileId {
	dev_t dev;                  
#if OS_VXWORKS
	struct vxworksFileId *pId;  
#else
	ino_t ino;                  
#endif
};


struct unixInodeInfo {
	struct unixFileId fileId;       
	int nShared;                    
	unsigned char eFileLock;        
	unsigned char bProcessLock;     
	int nRef;                       
	unixShmNode *pShmNode;          
	int nLock;                      
	UnixUnusedFd *pUnused;          
	unixInodeInfo *pNext;           
	unixInodeInfo *pPrev;           
#if SQLITE_ENABLE_LOCKING_STYLE
	unsigned long long sharedByte;  
#endif
#if OS_VXWORKS
	sem_t *pSem;                    
	char aSemName[MAX_PATHNAME + 2];  
#endif
};


static unixInodeInfo *inodeList = 0;


#define unixLogError(a,b,c)     unixLogErrorAtLine(a,b,c,__LINE__)
static int unixLogErrorAtLine(
	int errcode,                    
	const char *zFunc,              
	const char *zPath,              
	int iLine                       
) {
	char *zErr;                     
	int iErrno = errno;             

									
#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)
	char aErr[80];
	memset(aErr, 0, sizeof(aErr));
	zErr = aErr;

	
#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)
	zErr =
# endif
		strerror_r(iErrno, aErr, sizeof(aErr) - 1);

#elif SQLITE_THREADSAFE
									
	zErr = "";
#else
									
	zErr = strerror(iErrno);
#endif

	if (zPath == 0) zPath = "";
	sqlite3_log(errcode,
		"os_unix.c:%d: (%d) %s(%s) - %s",
		iLine, iErrno, zFunc, zPath, zErr
	);

	return errcode;
}


static void robust_close(unixFile *pFile, int h, int lineno) {
	if (osClose(h)) {
		unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",
			pFile ? pFile->zPath : 0, lineno);
	}
}


static void storeLastErrno(unixFile *pFile, int error) {
	pFile->lastErrno = error;
}


static void closePendingFds(unixFile *pFile) {
	unixInodeInfo *pInode = pFile->pInode;
	UnixUnusedFd *p;
	UnixUnusedFd *pNext;
	for (p = pInode->pUnused; p; p = pNext) {
		pNext = p->pNext;
		robust_close(pFile, p->fd, __LINE__);
		sqlite3_free(p);
	}
	pInode->pUnused = 0;
}


static void releaseInodeInfo(unixFile *pFile) {
	unixInodeInfo *pInode = pFile->pInode;
	assert(unixMutexHeld());
	if (ALWAYS(pInode)) {
		pInode->nRef--;
		if (pInode->nRef == 0) {
			assert(pInode->pShmNode == 0);
			closePendingFds(pFile);
			if (pInode->pPrev) {
				assert(pInode->pPrev->pNext == pInode);
				pInode->pPrev->pNext = pInode->pNext;
			}
			else {
				assert(inodeList == pInode);
				inodeList = pInode->pNext;
			}
			if (pInode->pNext) {
				assert(pInode->pNext->pPrev == pInode);
				pInode->pNext->pPrev = pInode->pPrev;
			}
			sqlite3_free(pInode);
		}
	}
}


static int findInodeInfo(
	unixFile *pFile,               
	unixInodeInfo **ppInode        
) {
	int rc;                        
	int fd;                        
	struct unixFileId fileId;      
	struct stat statbuf;           
	unixInodeInfo *pInode = 0;     

	assert(unixMutexHeld());

	
	fd = pFile->h;
	rc = osFstat(fd, &statbuf);
	if (rc != 0) {
		storeLastErrno(pFile, errno);
#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)
		if (pFile->lastErrno == EOVERFLOW) return SQLITE_NOLFS;
#endif
		return SQLITE_IOERR;
	}

#ifdef __APPLE__
	
	if (statbuf.st_size == 0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS) != 0) {
		do { rc = osWrite(fd, "S", 1); } while (rc<0 && errno == EINTR);
		if (rc != 1) {
			storeLastErrno(pFile, errno);
			return SQLITE_IOERR;
		}
		rc = osFstat(fd, &statbuf);
		if (rc != 0) {
			storeLastErrno(pFile, errno);
			return SQLITE_IOERR;
		}
	}
#endif

	memset(&fileId, 0, sizeof(fileId));
	fileId.dev = statbuf.st_dev;
#if OS_VXWORKS
	fileId.pId = pFile->pId;
#else
	fileId.ino = statbuf.st_ino;
#endif
	pInode = inodeList;
	while (pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId))) {
		pInode = pInode->pNext;
	}
	if (pInode == 0) {
		pInode = sqlite3_malloc64(sizeof(*pInode));
		if (pInode == 0) {
			return SQLITE_NOMEM_BKPT;
		}
		memset(pInode, 0, sizeof(*pInode));
		memcpy(&pInode->fileId, &fileId, sizeof(fileId));
		pInode->nRef = 1;
		pInode->pNext = inodeList;
		pInode->pPrev = 0;
		if (inodeList) inodeList->pPrev = pInode;
		inodeList = pInode;
	}
	else {
		pInode->nRef++;
	}
	*ppInode = pInode;
	return SQLITE_OK;
}


static int fileHasMoved(unixFile *pFile) {
#if OS_VXWORKS
	return pFile->pInode != 0 && pFile->pId != pFile->pInode->fileId.pId;
#else
	struct stat buf;
	return pFile->pInode != 0 &&
		(osStat(pFile->zPath, &buf) != 0 || buf.st_ino != pFile->pInode->fileId.ino);
#endif
}



static void verifyDbFile(unixFile *pFile) {
	struct stat buf;
	int rc;

	
	if (pFile->ctrlFlags & UNIXFILE_NOLOCK) return;

	rc = osFstat(pFile->h, &buf);
	if (rc != 0) {
		sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);
		return;
	}
	if (buf.st_nlink == 0) {
		sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);
		return;
	}
	if (buf.st_nlink>1) {
		sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);
		return;
	}
	if (fileHasMoved(pFile)) {
		sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);
		return;
	}
}



static int unixCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int rc = SQLITE_OK;
	int reserved = 0;
	unixFile *pFile = (unixFile*)id;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );

	assert(pFile);
	assert(pFile->eFileLock <= SHARED_LOCK);
	unixEnterMutex(); 

					  
	if (pFile->pInode->eFileLock>SHARED_LOCK) {
		reserved = 1;
	}

	
#ifndef __DJGPP__
	if (!reserved && !pFile->pInode->bProcessLock) {
		struct flock lock;
		lock.l_whence = SEEK_SET;
		lock.l_start = RESERVED_BYTE;
		lock.l_len = 1;
		lock.l_type = F_WRLCK;
		if (osFcntl(pFile->h, F_GETLK, &lock)) {
			rc = SQLITE_IOERR_CHECKRESERVEDLOCK;
			storeLastErrno(pFile, errno);
		}
		else if (lock.l_type != F_UNLCK) {
			reserved = 1;
		}
	}
#endif

	unixLeaveMutex();
	OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));

	*pResOut = reserved;
	return rc;
}


static int unixFileLock(unixFile *pFile, struct flock *pLock) {
	int rc;
	unixInodeInfo *pInode = pFile->pInode;
	assert(unixMutexHeld());
	assert(pInode != 0);
	if ((pFile->ctrlFlags & (UNIXFILE_EXCL | UNIXFILE_RDONLY)) == UNIXFILE_EXCL) {
		if (pInode->bProcessLock == 0) {
			struct flock lock;
			assert(pInode->nLock == 0);
			lock.l_whence = SEEK_SET;
			lock.l_start = SHARED_FIRST;
			lock.l_len = SHARED_SIZE;
			lock.l_type = F_WRLCK;
			rc = osFcntl(pFile->h, F_SETLK, &lock);
			if (rc<0) return rc;
			pInode->bProcessLock = 1;
			pInode->nLock++;
		}
		else {
			rc = 0;
		}
	}
	else {
		rc = osFcntl(pFile->h, F_SETLK, pLock);
	}
	return rc;
}


static int unixLock(sqlite3_file *id, int eFileLock) {
	
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile*)id;
	unixInodeInfo *pInode;
	struct flock lock;
	int tErrno = 0;

	assert(pFile);
	OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,
		azFileLock(eFileLock), azFileLock(pFile->eFileLock),
		azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,
		osGetpid(0)));

	
	if (pFile->eFileLock >= eFileLock) {
		OSTRACE(("LOCK    %d %s ok (already held) (unix)\n", pFile->h,
			azFileLock(eFileLock)));
		return SQLITE_OK;
	}

	
	assert(pFile->eFileLock != NO_LOCK || eFileLock == SHARED_LOCK);
	assert(eFileLock != PENDING_LOCK);
	assert(eFileLock != RESERVED_LOCK || pFile->eFileLock == SHARED_LOCK);

	
	unixEnterMutex();
	pInode = pFile->pInode;

	
	if ((pFile->eFileLock != pInode->eFileLock &&
		(pInode->eFileLock >= PENDING_LOCK || eFileLock>SHARED_LOCK))
		) {
		rc = SQLITE_BUSY;
		goto end_lock;
	}

	
	if (eFileLock == SHARED_LOCK &&
		(pInode->eFileLock == SHARED_LOCK || pInode->eFileLock == RESERVED_LOCK)) {
		assert(eFileLock == SHARED_LOCK);
		assert(pFile->eFileLock == 0);
		assert(pInode->nShared>0);
		pFile->eFileLock = SHARED_LOCK;
		pInode->nShared++;
		pInode->nLock++;
		goto end_lock;
	}


	
	lock.l_len = 1L;
	lock.l_whence = SEEK_SET;
	if (eFileLock == SHARED_LOCK
		|| (eFileLock == EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)
		) {
		lock.l_type = (eFileLock == SHARED_LOCK ? F_RDLCK : F_WRLCK);
		lock.l_start = PENDING_BYTE;
		if (unixFileLock(pFile, &lock)) {
			tErrno = errno;
			rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
			if (rc != SQLITE_BUSY) {
				storeLastErrno(pFile, tErrno);
			}
			goto end_lock;
		}
	}


	
	if (eFileLock == SHARED_LOCK) {
		assert(pInode->nShared == 0);
		assert(pInode->eFileLock == 0);
		assert(rc == SQLITE_OK);

		
		lock.l_start = SHARED_FIRST;
		lock.l_len = SHARED_SIZE;
		if (unixFileLock(pFile, &lock)) {
			tErrno = errno;
			rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
		}

		
		lock.l_start = PENDING_BYTE;
		lock.l_len = 1L;
		lock.l_type = F_UNLCK;
		if (unixFileLock(pFile, &lock) && rc == SQLITE_OK) {
			
			tErrno = errno;
			rc = SQLITE_IOERR_UNLOCK;
		}

		if (rc) {
			if (rc != SQLITE_BUSY) {
				storeLastErrno(pFile, tErrno);
			}
			goto end_lock;
		}
		else {
			pFile->eFileLock = SHARED_LOCK;
			pInode->nLock++;
			pInode->nShared = 1;
		}
	}
	else if (eFileLock == EXCLUSIVE_LOCK && pInode->nShared>1) {
		
		rc = SQLITE_BUSY;
	}
	else {
		
		assert(0 != pFile->eFileLock);
		lock.l_type = F_WRLCK;

		assert(eFileLock == RESERVED_LOCK || eFileLock == EXCLUSIVE_LOCK);
		if (eFileLock == RESERVED_LOCK) {
			lock.l_start = RESERVED_BYTE;
			lock.l_len = 1L;
		}
		else {
			lock.l_start = SHARED_FIRST;
			lock.l_len = SHARED_SIZE;
		}

		if (unixFileLock(pFile, &lock)) {
			tErrno = errno;
			rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
			if (rc != SQLITE_BUSY) {
				storeLastErrno(pFile, tErrno);
			}
		}
	}


#ifdef SQLITE_DEBUG
	
	if (rc == SQLITE_OK
		&& pFile->eFileLock <= SHARED_LOCK
		&& eFileLock == RESERVED_LOCK
		) {
		pFile->transCntrChng = 0;
		pFile->dbUpdate = 0;
		pFile->inNormalWrite = 1;
	}
#endif


	if (rc == SQLITE_OK) {
		pFile->eFileLock = eFileLock;
		pInode->eFileLock = eFileLock;
	}
	else if (eFileLock == EXCLUSIVE_LOCK) {
		pFile->eFileLock = PENDING_LOCK;
		pInode->eFileLock = PENDING_LOCK;
	}

end_lock:
	unixLeaveMutex();
	OSTRACE(("LOCK    %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock),
		rc == SQLITE_OK ? "ok" : "failed"));
	return rc;
}


static void setPendingFd(unixFile *pFile) {
	unixInodeInfo *pInode = pFile->pInode;
	UnixUnusedFd *p = pFile->pUnused;
	p->pNext = pInode->pUnused;
	pInode->pUnused = p;
	pFile->h = -1;
	pFile->pUnused = 0;
}


static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock) {
	unixFile *pFile = (unixFile*)id;
	unixInodeInfo *pInode;
	struct flock lock;
	int rc = SQLITE_OK;

	assert(pFile);
	OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,
		pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
		osGetpid(0)));

	assert(eFileLock <= SHARED_LOCK);
	if (pFile->eFileLock <= eFileLock) {
		return SQLITE_OK;
	}
	unixEnterMutex();
	pInode = pFile->pInode;
	assert(pInode->nShared != 0);
	if (pFile->eFileLock>SHARED_LOCK) {
		assert(pInode->eFileLock == pFile->eFileLock);

#ifdef SQLITE_DEBUG
		
		pFile->inNormalWrite = 0;
#endif

		
		if (eFileLock == SHARED_LOCK) {
#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE
			(void)handleNFSUnlock;
			assert(handleNFSUnlock == 0);
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
			if (handleNFSUnlock) {
				int tErrno;               
				off_t divSize = SHARED_SIZE - 1;

				lock.l_type = F_UNLCK;
				lock.l_whence = SEEK_SET;
				lock.l_start = SHARED_FIRST;
				lock.l_len = divSize;
				if (unixFileLock(pFile, &lock) == (-1)) {
					tErrno = errno;
					rc = SQLITE_IOERR_UNLOCK;
					storeLastErrno(pFile, tErrno);
					goto end_unlock;
				}
				lock.l_type = F_RDLCK;
				lock.l_whence = SEEK_SET;
				lock.l_start = SHARED_FIRST;
				lock.l_len = divSize;
				if (unixFileLock(pFile, &lock) == (-1)) {
					tErrno = errno;
					rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);
					if (IS_LOCK_ERROR(rc)) {
						storeLastErrno(pFile, tErrno);
					}
					goto end_unlock;
				}
				lock.l_type = F_UNLCK;
				lock.l_whence = SEEK_SET;
				lock.l_start = SHARED_FIRST + divSize;
				lock.l_len = SHARED_SIZE - divSize;
				if (unixFileLock(pFile, &lock) == (-1)) {
					tErrno = errno;
					rc = SQLITE_IOERR_UNLOCK;
					storeLastErrno(pFile, tErrno);
					goto end_unlock;
				}
			}
			else
#endif 
			{
				lock.l_type = F_RDLCK;
				lock.l_whence = SEEK_SET;
				lock.l_start = SHARED_FIRST;
				lock.l_len = SHARED_SIZE;
				if (unixFileLock(pFile, &lock)) {
					
					rc = SQLITE_IOERR_RDLOCK;
					storeLastErrno(pFile, errno);
					goto end_unlock;
				}
			}
		}
		lock.l_type = F_UNLCK;
		lock.l_whence = SEEK_SET;
		lock.l_start = PENDING_BYTE;
		lock.l_len = 2L;  assert(PENDING_BYTE + 1 == RESERVED_BYTE);
		if (unixFileLock(pFile, &lock) == 0) {
			pInode->eFileLock = SHARED_LOCK;
		}
		else {
			rc = SQLITE_IOERR_UNLOCK;
			storeLastErrno(pFile, errno);
			goto end_unlock;
		}
	}
	if (eFileLock == NO_LOCK) {
		
		pInode->nShared--;
		if (pInode->nShared == 0) {
			lock.l_type = F_UNLCK;
			lock.l_whence = SEEK_SET;
			lock.l_start = lock.l_len = 0L;
			if (unixFileLock(pFile, &lock) == 0) {
				pInode->eFileLock = NO_LOCK;
			}
			else {
				rc = SQLITE_IOERR_UNLOCK;
				storeLastErrno(pFile, errno);
				pInode->eFileLock = NO_LOCK;
				pFile->eFileLock = NO_LOCK;
			}
		}

		
		pInode->nLock--;
		assert(pInode->nLock >= 0);
		if (pInode->nLock == 0) {
			closePendingFds(pFile);
		}
	}

end_unlock:
	unixLeaveMutex();
	if (rc == SQLITE_OK) pFile->eFileLock = eFileLock;
	return rc;
}


static int unixUnlock(sqlite3_file *id, int eFileLock) {
#if SQLITE_MAX_MMAP_SIZE>0
	assert(eFileLock == SHARED_LOCK || ((unixFile *)id)->nFetchOut == 0);
#endif
	return posixUnlock(id, eFileLock, 0);
}

#if SQLITE_MAX_MMAP_SIZE>0
static int unixMapfile(unixFile *pFd, i64 nByte);
static void unixUnmapfile(unixFile *pFd);
#endif


static int closeUnixFile(sqlite3_file *id) {
	unixFile *pFile = (unixFile*)id;
#if SQLITE_MAX_MMAP_SIZE>0
	unixUnmapfile(pFile);
#endif
	if (pFile->h >= 0) {
		robust_close(pFile, pFile->h, __LINE__);
		pFile->h = -1;
	}
#if OS_VXWORKS
	if (pFile->pId) {
		if (pFile->ctrlFlags & UNIXFILE_DELETE) {
			osUnlink(pFile->pId->zCanonicalName);
		}
		vxworksReleaseFileId(pFile->pId);
		pFile->pId = 0;
	}
#endif
#ifdef SQLITE_UNLINK_AFTER_CLOSE
	if (pFile->ctrlFlags & UNIXFILE_DELETE) {
		osUnlink(pFile->zPath);
		sqlite3_free(*(char**)&pFile->zPath);
		pFile->zPath = 0;
	}
#endif
	OSTRACE(("CLOSE   %-3d\n", pFile->h));
	OpenCounter(-1);
	sqlite3_free(pFile->pUnused);
	memset(pFile, 0, sizeof(unixFile));
	return SQLITE_OK;
}


static int unixClose(sqlite3_file *id) {
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile *)id;
	verifyDbFile(pFile);
	unixUnlock(id, NO_LOCK);
	unixEnterMutex();

	
	assert(pFile->pInode->nLock>0 || pFile->pInode->bProcessLock == 0);
	if (ALWAYS(pFile->pInode) && pFile->pInode->nLock) {
		
		setPendingFd(pFile);
	}
	releaseInodeInfo(pFile);
	rc = closeUnixFile(id);
	unixLeaveMutex();
	return rc;
}





static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut) {
	UNUSED_PARAMETER(NotUsed);
	*pResOut = 0;
	return SQLITE_OK;
}
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	return SQLITE_OK;
}
static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	return SQLITE_OK;
}


static int nolockClose(sqlite3_file *id) {
	return closeUnixFile(id);
}






#define DOTLOCK_SUFFIX ".lock"


static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int rc = SQLITE_OK;
	int reserved = 0;
	unixFile *pFile = (unixFile*)id;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );

	assert(pFile);
	reserved = osAccess((const char*)pFile->lockingContext, 0) == 0;
	OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));
	*pResOut = reserved;
	return rc;
}


static int dotlockLock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	char *zLockFile = (char *)pFile->lockingContext;
	int rc = SQLITE_OK;


	
	if (pFile->eFileLock > NO_LOCK) {
		pFile->eFileLock = eFileLock;
		
#ifdef HAVE_UTIME
		utime(zLockFile, NULL);
#else
		utimes(zLockFile, NULL);
#endif
		return SQLITE_OK;
	}

	
	rc = osMkdir(zLockFile, 0777);
	if (rc<0) {
		
		int tErrno = errno;
		if (EEXIST == tErrno) {
			rc = SQLITE_BUSY;
		}
		else {
			rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
			if (rc != SQLITE_BUSY) {
				storeLastErrno(pFile, tErrno);
			}
		}
		return rc;
	}

	
	pFile->eFileLock = eFileLock;
	return rc;
}


static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	char *zLockFile = (char *)pFile->lockingContext;
	int rc;

	assert(pFile);
	OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,
		pFile->eFileLock, osGetpid(0)));
	assert(eFileLock <= SHARED_LOCK);

	
	if (pFile->eFileLock == eFileLock) {
		return SQLITE_OK;
	}

	
	if (eFileLock == SHARED_LOCK) {
		pFile->eFileLock = SHARED_LOCK;
		return SQLITE_OK;
	}

	
	assert(eFileLock == NO_LOCK);
	rc = osRmdir(zLockFile);
	if (rc<0) {
		int tErrno = errno;
		if (tErrno == ENOENT) {
			rc = SQLITE_OK;
		}
		else {
			rc = SQLITE_IOERR_UNLOCK;
			storeLastErrno(pFile, tErrno);
		}
		return rc;
	}
	pFile->eFileLock = NO_LOCK;
	return SQLITE_OK;
}


static int dotlockClose(sqlite3_file *id) {
	unixFile *pFile = (unixFile*)id;
	assert(id != 0);
	dotlockUnlock(id, NO_LOCK);
	sqlite3_free(pFile->lockingContext);
	return closeUnixFile(id);
}



#if SQLITE_ENABLE_LOCKING_STYLE


#ifdef EINTR
static int robust_flock(int fd, int op) {
	int rc;
	do { rc = flock(fd, op); } while (rc<0 && errno == EINTR);
	return rc;
}
#else
# define robust_flock(a,b) flock(a,b)
#endif



static int flockCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int rc = SQLITE_OK;
	int reserved = 0;
	unixFile *pFile = (unixFile*)id;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );

	assert(pFile);

	
	if (pFile->eFileLock>SHARED_LOCK) {
		reserved = 1;
	}

	
	if (!reserved) {
		
		int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);
		if (!lrc) {
			
			lrc = robust_flock(pFile->h, LOCK_UN);
			if (lrc) {
				int tErrno = errno;
				
				lrc = SQLITE_IOERR_UNLOCK;
				storeLastErrno(pFile, tErrno);
				rc = lrc;
			}
		}
		else {
			int tErrno = errno;
			reserved = 1;
			
			lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
			if (IS_LOCK_ERROR(lrc)) {
				storeLastErrno(pFile, tErrno);
				rc = lrc;
			}
		}
	}
	OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved));

#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
	if ((rc & SQLITE_IOERR) == SQLITE_IOERR) {
		rc = SQLITE_OK;
		reserved = 1;
	}
#endif 
	*pResOut = reserved;
	return rc;
}


static int flockLock(sqlite3_file *id, int eFileLock) {
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile*)id;

	assert(pFile);

	
	if (pFile->eFileLock > NO_LOCK) {
		pFile->eFileLock = eFileLock;
		return SQLITE_OK;
	}

	

	if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {
		int tErrno = errno;
		
		rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
		if (IS_LOCK_ERROR(rc)) {
			storeLastErrno(pFile, tErrno);
		}
	}
	else {
		
		pFile->eFileLock = eFileLock;
	}
	OSTRACE(("LOCK    %d %s %s (flock)\n", pFile->h, azFileLock(eFileLock),
		rc == SQLITE_OK ? "ok" : "failed"));
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
	if ((rc & SQLITE_IOERR) == SQLITE_IOERR) {
		rc = SQLITE_BUSY;
	}
#endif 
	return rc;
}



static int flockUnlock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;

	assert(pFile);
	OSTRACE(("UNLOCK  %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,
		pFile->eFileLock, osGetpid(0)));
	assert(eFileLock <= SHARED_LOCK);

	
	if (pFile->eFileLock == eFileLock) {
		return SQLITE_OK;
	}

	
	if (eFileLock == SHARED_LOCK) {
		pFile->eFileLock = eFileLock;
		return SQLITE_OK;
	}

	
	if (robust_flock(pFile->h, LOCK_UN)) {
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
		return SQLITE_OK;
#endif 
		return SQLITE_IOERR_UNLOCK;
	}
	else {
		pFile->eFileLock = NO_LOCK;
		return SQLITE_OK;
	}
}


static int flockClose(sqlite3_file *id) {
	assert(id != 0);
	flockUnlock(id, NO_LOCK);
	return closeUnixFile(id);
}

#endif 




#if OS_VXWORKS


static int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int rc = SQLITE_OK;
	int reserved = 0;
	unixFile *pFile = (unixFile*)id;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );

	assert(pFile);

	
	if (pFile->eFileLock>SHARED_LOCK) {
		reserved = 1;
	}

	
	if (!reserved) {
		sem_t *pSem = pFile->pInode->pSem;

		if (sem_trywait(pSem) == -1) {
			int tErrno = errno;
			if (EAGAIN != tErrno) {
				rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);
				storeLastErrno(pFile, tErrno);
			}
			else {
				
				reserved = (pFile->eFileLock < SHARED_LOCK);
			}
		}
		else {
			
			sem_post(pSem);
		}
	}
	OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved));

	*pResOut = reserved;
	return rc;
}


static int semXLock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	sem_t *pSem = pFile->pInode->pSem;
	int rc = SQLITE_OK;

	
	if (pFile->eFileLock > NO_LOCK) {
		pFile->eFileLock = eFileLock;
		rc = SQLITE_OK;
		goto sem_end_lock;
	}

	
	if (sem_trywait(pSem) == -1) {
		rc = SQLITE_BUSY;
		goto sem_end_lock;
	}

	
	pFile->eFileLock = eFileLock;

sem_end_lock:
	return rc;
}


static int semXUnlock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	sem_t *pSem = pFile->pInode->pSem;

	assert(pFile);
	assert(pSem);
	OSTRACE(("UNLOCK  %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,
		pFile->eFileLock, osGetpid(0)));
	assert(eFileLock <= SHARED_LOCK);

	
	if (pFile->eFileLock == eFileLock) {
		return SQLITE_OK;
	}

	
	if (eFileLock == SHARED_LOCK) {
		pFile->eFileLock = eFileLock;
		return SQLITE_OK;
	}

	
	if (sem_post(pSem) == -1) {
		int rc, tErrno = errno;
		rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);
		if (IS_LOCK_ERROR(rc)) {
			storeLastErrno(pFile, tErrno);
		}
		return rc;
	}
	pFile->eFileLock = NO_LOCK;
	return SQLITE_OK;
}


static int semXClose(sqlite3_file *id) {
	if (id) {
		unixFile *pFile = (unixFile*)id;
		semXUnlock(id, NO_LOCK);
		assert(pFile);
		unixEnterMutex();
		releaseInodeInfo(pFile);
		unixLeaveMutex();
		closeUnixFile(id);
	}
	return SQLITE_OK;
}

#endif 





#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE

typedef struct afpLockingContext afpLockingContext;
struct afpLockingContext {
	int reserved;
	const char *dbPath;             
};

struct ByteRangeLockPB2
{
	unsigned long long offset;        
	unsigned long long length;        
	unsigned long long retRangeStart; 
	unsigned char unLockFlag;         
	unsigned char startEndFlag;       
	int fd;                           
};

#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2)


static int afpSetLock(
	const char *path,              
	unixFile *pFile,               
	unsigned long long offset,     
	unsigned long long length,     
	int setLockFlag                
) {
	struct ByteRangeLockPB2 pb;
	int err;

	pb.unLockFlag = setLockFlag ? 0 : 1;
	pb.startEndFlag = 0;
	pb.offset = offset;
	pb.length = length;
	pb.fd = pFile->h;

	OSTRACE(("AFPSETLOCK [%s] for %d%s in range %llx:%llx\n",
		(setLockFlag ? "ON" : "OFF"), pFile->h, (pb.fd == -1 ? "[testval-1]" : ""),
		offset, length));
	err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);
	if (err == -1) {
		int rc;
		int tErrno = errno;
		OSTRACE(("AFPSETLOCK failed to fsctl() '%s' %d %s\n",
			path, tErrno, strerror(tErrno)));
#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS
		rc = SQLITE_BUSY;
#else
		rc = sqliteErrorFromPosixError(tErrno,
			setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);
#endif 
		if (IS_LOCK_ERROR(rc)) {
			storeLastErrno(pFile, tErrno);
		}
		return rc;
	}
	else {
		return SQLITE_OK;
	}
}


static int afpCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int rc = SQLITE_OK;
	int reserved = 0;
	unixFile *pFile = (unixFile*)id;
	afpLockingContext *context;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );

	assert(pFile);
	context = (afpLockingContext *)pFile->lockingContext;
	if (context->reserved) {
		*pResOut = 1;
		return SQLITE_OK;
	}
	unixEnterMutex(); 

					  
	if (pFile->pInode->eFileLock>SHARED_LOCK) {
		reserved = 1;
	}

	
	if (!reserved) {
		
		int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 1);
		if (SQLITE_OK == lrc) {
			
			lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);
		}
		else {
			
			reserved = 1;
		}
		if (IS_LOCK_ERROR(lrc)) {
			rc = lrc;
		}
	}

	unixLeaveMutex();
	OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));

	*pResOut = reserved;
	return rc;
}


static int afpLock(sqlite3_file *id, int eFileLock) {
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile*)id;
	unixInodeInfo *pInode = pFile->pInode;
	afpLockingContext *context = (afpLockingContext *)pFile->lockingContext;

	assert(pFile);
	OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,
		azFileLock(eFileLock), azFileLock(pFile->eFileLock),
		azFileLock(pInode->eFileLock), pInode->nShared, osGetpid(0)));

	
	if (pFile->eFileLock >= eFileLock) {
		OSTRACE(("LOCK    %d %s ok (already held) (afp)\n", pFile->h,
			azFileLock(eFileLock)));
		return SQLITE_OK;
	}

	
	assert(pFile->eFileLock != NO_LOCK || eFileLock == SHARED_LOCK);
	assert(eFileLock != PENDING_LOCK);
	assert(eFileLock != RESERVED_LOCK || pFile->eFileLock == SHARED_LOCK);

	
	unixEnterMutex();
	pInode = pFile->pInode;

	
	if ((pFile->eFileLock != pInode->eFileLock &&
		(pInode->eFileLock >= PENDING_LOCK || eFileLock>SHARED_LOCK))
		) {
		rc = SQLITE_BUSY;
		goto afp_end_lock;
	}

	
	if (eFileLock == SHARED_LOCK &&
		(pInode->eFileLock == SHARED_LOCK || pInode->eFileLock == RESERVED_LOCK)) {
		assert(eFileLock == SHARED_LOCK);
		assert(pFile->eFileLock == 0);
		assert(pInode->nShared>0);
		pFile->eFileLock = SHARED_LOCK;
		pInode->nShared++;
		pInode->nLock++;
		goto afp_end_lock;
	}

	
	if (eFileLock == SHARED_LOCK
		|| (eFileLock == EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)
		) {
		int failed;
		failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);
		if (failed) {
			rc = failed;
			goto afp_end_lock;
		}
	}

	
	if (eFileLock == SHARED_LOCK) {
		int lrc1, lrc2, lrc1Errno = 0;
		long lk, mask;

		assert(pInode->nShared == 0);
		assert(pInode->eFileLock == 0);

		mask = (sizeof(long) == 8) ? LARGEST_INT64 : 0x7fffffff;
		
		
		lk = random();
		pInode->sharedByte = (lk & mask) % (SHARED_SIZE - 1);
		lrc1 = afpSetLock(context->dbPath, pFile,
			SHARED_FIRST + pInode->sharedByte, 1, 1);
		if (IS_LOCK_ERROR(lrc1)) {
			lrc1Errno = pFile->lastErrno;
		}
		
		lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);

		if (IS_LOCK_ERROR(lrc1)) {
			storeLastErrno(pFile, lrc1Errno);
			rc = lrc1;
			goto afp_end_lock;
		}
		else if (IS_LOCK_ERROR(lrc2)) {
			rc = lrc2;
			goto afp_end_lock;
		}
		else if (lrc1 != SQLITE_OK) {
			rc = lrc1;
		}
		else {
			pFile->eFileLock = SHARED_LOCK;
			pInode->nLock++;
			pInode->nShared = 1;
		}
	}
	else if (eFileLock == EXCLUSIVE_LOCK && pInode->nShared>1) {
		
		rc = SQLITE_BUSY;
	}
	else {
		
		int failed = 0;
		assert(0 != pFile->eFileLock);
		if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {
			
			failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 1);
			if (!failed) {
				context->reserved = 1;
			}
		}
		if (!failed && eFileLock == EXCLUSIVE_LOCK) {
			

			
			if (!(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +
				pInode->sharedByte, 1, 0))) {
				int failed2 = SQLITE_OK;
				
				failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST,
					SHARED_SIZE, 1);
				if (failed && (failed2 = afpSetLock(context->dbPath, pFile,
					SHARED_FIRST + pInode->sharedByte, 1, 1))) {
					
					rc = ((failed & SQLITE_IOERR) == SQLITE_IOERR) ? failed2 :
						SQLITE_IOERR_LOCK;
					goto afp_end_lock;
				}
			}
			else {
				rc = failed;
			}
		}
		if (failed) {
			rc = failed;
		}
	}

	if (rc == SQLITE_OK) {
		pFile->eFileLock = eFileLock;
		pInode->eFileLock = eFileLock;
	}
	else if (eFileLock == EXCLUSIVE_LOCK) {
		pFile->eFileLock = PENDING_LOCK;
		pInode->eFileLock = PENDING_LOCK;
	}

afp_end_lock:
	unixLeaveMutex();
	OSTRACE(("LOCK    %d %s %s (afp)\n", pFile->h, azFileLock(eFileLock),
		rc == SQLITE_OK ? "ok" : "failed"));
	return rc;
}


static int afpUnlock(sqlite3_file *id, int eFileLock) {
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile*)id;
	unixInodeInfo *pInode;
	afpLockingContext *context = (afpLockingContext *)pFile->lockingContext;
	int skipShared = 0;
#ifdef SQLITE_TEST
	int h = pFile->h;
#endif

	assert(pFile);
	OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,
		pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
		osGetpid(0)));

	assert(eFileLock <= SHARED_LOCK);
	if (pFile->eFileLock <= eFileLock) {
		return SQLITE_OK;
	}
	unixEnterMutex();
	pInode = pFile->pInode;
	assert(pInode->nShared != 0);
	if (pFile->eFileLock>SHARED_LOCK) {
		assert(pInode->eFileLock == pFile->eFileLock);
		SimulateIOErrorBenign(1);
		SimulateIOError(h = (-1))
			SimulateIOErrorBenign(0);

#ifdef SQLITE_DEBUG
		
		assert(pFile->inNormalWrite == 0
			|| pFile->dbUpdate == 0
			|| pFile->transCntrChng == 1);
		pFile->inNormalWrite = 0;
#endif

		if (pFile->eFileLock == EXCLUSIVE_LOCK) {
			rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);
			if (rc == SQLITE_OK && (eFileLock == SHARED_LOCK || pInode->nShared>1)) {
				
				int sharedLockByte = SHARED_FIRST + pInode->sharedByte;
				rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);
			}
			else {
				skipShared = 1;
			}
		}
		if (rc == SQLITE_OK && pFile->eFileLock >= PENDING_LOCK) {
			rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);
		}
		if (rc == SQLITE_OK && pFile->eFileLock >= RESERVED_LOCK && context->reserved) {
			rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);
			if (!rc) {
				context->reserved = 0;
			}
		}
		if (rc == SQLITE_OK && (eFileLock == SHARED_LOCK || pInode->nShared>1)) {
			pInode->eFileLock = SHARED_LOCK;
		}
	}
	if (rc == SQLITE_OK && eFileLock == NO_LOCK) {

		
		unsigned long long sharedLockByte = SHARED_FIRST + pInode->sharedByte;
		pInode->nShared--;
		if (pInode->nShared == 0) {
			SimulateIOErrorBenign(1);
			SimulateIOError(h = (-1))
				SimulateIOErrorBenign(0);
			if (!skipShared) {
				rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);
			}
			if (!rc) {
				pInode->eFileLock = NO_LOCK;
				pFile->eFileLock = NO_LOCK;
			}
		}
		if (rc == SQLITE_OK) {
			pInode->nLock--;
			assert(pInode->nLock >= 0);
			if (pInode->nLock == 0) {
				closePendingFds(pFile);
			}
		}
	}

	unixLeaveMutex();
	if (rc == SQLITE_OK) pFile->eFileLock = eFileLock;
	return rc;
}


static int afpClose(sqlite3_file *id) {
	int rc = SQLITE_OK;
	unixFile *pFile = (unixFile*)id;
	assert(id != 0);
	afpUnlock(id, NO_LOCK);
	unixEnterMutex();
	if (pFile->pInode && pFile->pInode->nLock) {
		
		setPendingFd(pFile);
	}
	releaseInodeInfo(pFile);
	sqlite3_free(pFile->lockingContext);
	rc = closeUnixFile(id);
	unixLeaveMutex();
	return rc;
}

#endif 




#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE

static int nfsUnlock(sqlite3_file *id, int eFileLock) {
	return posixUnlock(id, eFileLock, 1);
}

#endif 





static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt) {
	int got;
	int prior = 0;
#if (!defined(USE_PREAD) && !defined(USE_PREAD64))
	i64 newOffset;
#endif
	TIMER_START;
	assert(cnt == (cnt & 0x1ffff));
	assert(id->h>2);
	do {
#if defined(USE_PREAD)
		got = osPread(id->h, pBuf, cnt, offset);
		SimulateIOError(got = -1);
#elif defined(USE_PREAD64)
		got = osPread64(id->h, pBuf, cnt, offset);
		SimulateIOError(got = -1);
#else
		newOffset = lseek(id->h, offset, SEEK_SET);
		SimulateIOError(newOffset = -1);
		if (newOffset<0) {
			storeLastErrno((unixFile*)id, errno);
			return -1;
		}
		got = osRead(id->h, pBuf, cnt);
#endif
		if (got == cnt) break;
		if (got<0) {
			if (errno == EINTR) { got = 1; continue; }
			prior = 0;
			storeLastErrno((unixFile*)id, errno);
			break;
		}
		else if (got>0) {
			cnt -= got;
			offset += got;
			prior += got;
			pBuf = (void*)(got + (char*)pBuf);
		}
	} while (got>0);
	TIMER_END;
	OSTRACE(("READ    %-3d %5d %7lld %llu\n",
		id->h, got + prior, offset - prior, TIMER_ELAPSED));
	return got + prior;
}


static int unixRead(
	sqlite3_file *id,
	void *pBuf,
	int amt,
	sqlite3_int64 offset
) {
	unixFile *pFile = (unixFile *)id;
	int got;
	assert(id);
	assert(offset >= 0);
	assert(amt>0);

	
#if 0
	assert(pFile->pUnused == 0
		|| offset >= PENDING_BYTE + 512
		|| offset + amt <= PENDING_BYTE
	);
#endif

#if SQLITE_MAX_MMAP_SIZE>0
	
	if (offset<pFile->mmapSize) {
		if (offset + amt <= pFile->mmapSize) {
			memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
			return SQLITE_OK;
		}
		else {
			int nCopy = pFile->mmapSize - offset;
			memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
			pBuf = &((u8 *)pBuf)[nCopy];
			amt -= nCopy;
			offset += nCopy;
		}
	}
#endif

	got = seekAndRead(pFile, offset, pBuf, amt);
	if (got == amt) {
		return SQLITE_OK;
	}
	else if (got<0) {
		
		return SQLITE_IOERR_READ;
	}
	else {
		storeLastErrno(pFile, 0);   
									
		memset(&((char*)pBuf)[got], 0, amt - got);
		return SQLITE_IOERR_SHORT_READ;
	}
}


static int seekAndWriteFd(
	int fd,                         
	i64 iOff,                       
	const void *pBuf,               
	int nBuf,                       
	int *piErrno                    
) {
	int rc = 0;                     

	assert(nBuf == (nBuf & 0x1ffff));
	assert(fd>2);
	assert(piErrno != 0);
	nBuf &= 0x1ffff;
	TIMER_START;

#if defined(USE_PREAD)
	do { rc = (int)osPwrite(fd, pBuf, nBuf, iOff); } while (rc<0 && errno == EINTR);
#elif defined(USE_PREAD64)
	do { rc = (int)osPwrite64(fd, pBuf, nBuf, iOff); } while (rc<0 && errno == EINTR);
#else
	do {
		i64 iSeek = lseek(fd, iOff, SEEK_SET);
		SimulateIOError(iSeek = -1);
		if (iSeek<0) {
			rc = -1;
			break;
		}
		rc = osWrite(fd, pBuf, nBuf);
	} while (rc<0 && errno == EINTR);
#endif

	TIMER_END;
	OSTRACE(("WRITE   %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED));

	if (rc<0) *piErrno = errno;
	return rc;
}



static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt) {
	return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);
}



static int unixWrite(
	sqlite3_file *id,
	const void *pBuf,
	int amt,
	sqlite3_int64 offset
) {
	unixFile *pFile = (unixFile*)id;
	int wrote = 0;
	assert(id);
	assert(amt>0);

	
#if 0
	assert(pFile->pUnused == 0
		|| offset >= PENDING_BYTE + 512
		|| offset + amt <= PENDING_BYTE
	);
#endif

#ifdef SQLITE_DEBUG
	
	if (pFile->inNormalWrite) {
		pFile->dbUpdate = 1;  
		if (offset <= 24 && offset + amt >= 27) {
			int rc;
			char oldCntr[4];
			SimulateIOErrorBenign(1);
			rc = seekAndRead(pFile, 24, oldCntr, 4);
			SimulateIOErrorBenign(0);
			if (rc != 4 || memcmp(oldCntr, &((char*)pBuf)[24 - offset], 4) != 0) {
				pFile->transCntrChng = 1;  
			}
		}
	}
#endif

#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0
	
	if (offset<pFile->mmapSize) {
		if (offset + amt <= pFile->mmapSize) {
			memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
			return SQLITE_OK;
		}
		else {
			int nCopy = pFile->mmapSize - offset;
			memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);
			pBuf = &((u8 *)pBuf)[nCopy];
			amt -= nCopy;
			offset += nCopy;
		}
	}
#endif

	while ((wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0) {
		amt -= wrote;
		offset += wrote;
		pBuf = &((char*)pBuf)[wrote];
	}
	SimulateIOError((wrote = (-1), amt = 1));
	SimulateDiskfullError((wrote = 0, amt = 1));

	if (amt>wrote) {
		if (wrote<0 && pFile->lastErrno != ENOSPC) {
			
			return SQLITE_IOERR_WRITE;
		}
		else {
			storeLastErrno(pFile, 0); 
			return SQLITE_FULL;
		}
	}

	return SQLITE_OK;
}

#ifdef SQLITE_TEST

SQLITE_API int sqlite3_sync_count = 0;
SQLITE_API int sqlite3_fullsync_count = 0;
#endif


#if !defined(fdatasync) && !HAVE_FDATASYNC
# define fdatasync fsync
#endif


#ifdef F_FULLFSYNC
# define HAVE_FULLFSYNC 1
#else
# define HAVE_FULLFSYNC 0
#endif



static int full_fsync(int fd, int fullSync, int dataOnly) {
	int rc;

	
#ifdef SQLITE_NO_SYNC
	UNUSED_PARAMETER(fd);
	UNUSED_PARAMETER(fullSync);
	UNUSED_PARAMETER(dataOnly);
#elif HAVE_FULLFSYNC
	UNUSED_PARAMETER(dataOnly);
#else
	UNUSED_PARAMETER(fullSync);
	UNUSED_PARAMETER(dataOnly);
#endif

	
#ifdef SQLITE_TEST
	if (fullSync) sqlite3_fullsync_count++;
	sqlite3_sync_count++;
#endif

	
#ifdef SQLITE_NO_SYNC
	{
		struct stat buf;
		rc = osFstat(fd, &buf);
	}
#elif HAVE_FULLFSYNC
	if (fullSync) {
		rc = osFcntl(fd, F_FULLFSYNC, 0);
	}
	else {
		rc = 1;
	}
	
	if (rc) rc = fsync(fd);

#elif defined(__APPLE__)
	
	rc = fsync(fd);
#else 
	rc = fdatasync(fd);
#if OS_VXWORKS
	if (rc == -1 && errno == ENOTSUP) {
		rc = fsync(fd);
	}
#endif 
#endif 

	if (OS_VXWORKS && rc != -1) {
		rc = 0;
	}
	return rc;
}


static int openDirectory(const char *zFilename, int *pFd) {
	int ii;
	int fd = -1;
	char zDirname[MAX_PATHNAME + 1];

	sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);
	for (ii = (int)strlen(zDirname); ii>0 && zDirname[ii] != '/'; ii--);
	if (ii>0) {
		zDirname[ii] = '\0';
	}
	else {
		if (zDirname[0] != '/') zDirname[0] = '.';
		zDirname[1] = 0;
	}
	fd = robust_open(zDirname, O_RDONLY | O_BINARY, 0);
	if (fd >= 0) {
		OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));
	}
	*pFd = fd;
	if (fd >= 0) return SQLITE_OK;
	return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);
}


static int unixSync(sqlite3_file *id, int flags) {
	int rc;
	unixFile *pFile = (unixFile*)id;

	int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);
	int isFullsync = (flags & 0x0F) == SQLITE_SYNC_FULL;

	
	assert((flags & 0x0F) == SQLITE_SYNC_NORMAL
		|| (flags & 0x0F) == SQLITE_SYNC_FULL
	);

	
	SimulateDiskfullError(return SQLITE_FULL);

	assert(pFile);
	OSTRACE(("SYNC    %-3d\n", pFile->h));
	rc = full_fsync(pFile->h, isFullsync, isDataOnly);
	SimulateIOError(rc = 1);
	if (rc) {
		storeLastErrno(pFile, errno);
		return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);
	}

	
	if (pFile->ctrlFlags & UNIXFILE_DIRSYNC) {
		int dirfd;
		OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,
			HAVE_FULLFSYNC, isFullsync));
		rc = osOpenDirectory(pFile->zPath, &dirfd);
		if (rc == SQLITE_OK) {
			full_fsync(dirfd, 0, 0);
			robust_close(pFile, dirfd, __LINE__);
		}
		else {
			assert(rc == SQLITE_CANTOPEN);
			rc = SQLITE_OK;
		}
		pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;
	}
	return rc;
}


static int unixTruncate(sqlite3_file *id, i64 nByte) {
	unixFile *pFile = (unixFile *)id;
	int rc;
	assert(pFile);
	SimulateIOError(return SQLITE_IOERR_TRUNCATE);

	
	if (pFile->szChunk>0) {
		nByte = ((nByte + pFile->szChunk - 1) / pFile->szChunk) * pFile->szChunk;
	}

	rc = robust_ftruncate(pFile->h, nByte);
	if (rc) {
		storeLastErrno(pFile, errno);
		return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
	}
	else {
#ifdef SQLITE_DEBUG
		
		if (pFile->inNormalWrite && nByte == 0) {
			pFile->transCntrChng = 1;
		}
#endif

#if SQLITE_MAX_MMAP_SIZE>0
		
		if (nByte<pFile->mmapSize) {
			pFile->mmapSize = nByte;
		}
#endif

		return SQLITE_OK;
	}
}


static int unixFileSize(sqlite3_file *id, i64 *pSize) {
	int rc;
	struct stat buf;
	assert(id);
	rc = osFstat(((unixFile*)id)->h, &buf);
	SimulateIOError(rc = 1);
	if (rc != 0) {
		storeLastErrno((unixFile*)id, errno);
		return SQLITE_IOERR_FSTAT;
	}
	*pSize = buf.st_size;

	
	if (*pSize == 1) *pSize = 0;


	return SQLITE_OK;
}

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)

static int proxyFileControl(sqlite3_file*, int, void*);
#endif


static int fcntlSizeHint(unixFile *pFile, i64 nByte) {
	if (pFile->szChunk>0) {
		i64 nSize;                    
		struct stat buf;              

		if (osFstat(pFile->h, &buf)) {
			return SQLITE_IOERR_FSTAT;
		}

		nSize = ((nByte + pFile->szChunk - 1) / pFile->szChunk) * pFile->szChunk;
		if (nSize>(i64)buf.st_size) {

#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
			
			int err;
			do {
				err = osFallocate(pFile->h, buf.st_size, nSize - buf.st_size);
			} while (err == EINTR);
			if (err) return SQLITE_IOERR_WRITE;
#else
			
			int nBlk = buf.st_blksize;  
			int nWrite = 0;             
			i64 iWrite;                 

			iWrite = (buf.st_size / nBlk)*nBlk + nBlk - 1;
			assert(iWrite >= buf.st_size);
			assert(((iWrite + 1) % nBlk) == 0);
			for (; iWrite<nSize + nBlk - 1; iWrite += nBlk) {
				if (iWrite >= nSize) iWrite = nSize - 1;
				nWrite = seekAndWrite(pFile, iWrite, "", 1);
				if (nWrite != 1) return SQLITE_IOERR_WRITE;
			}
#endif
		}
	}

#if SQLITE_MAX_MMAP_SIZE>0
	if (pFile->mmapSizeMax>0 && nByte>pFile->mmapSize) {
		int rc;
		if (pFile->szChunk <= 0) {
			if (robust_ftruncate(pFile->h, nByte)) {
				storeLastErrno(pFile, errno);
				return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
			}
		}

		rc = unixMapfile(pFile, nByte);
		return rc;
	}
#endif

	return SQLITE_OK;
}


static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg) {
	if (*pArg<0) {
		*pArg = (pFile->ctrlFlags & mask) != 0;
	}
	else if ((*pArg) == 0) {
		pFile->ctrlFlags &= ~mask;
	}
	else {
		pFile->ctrlFlags |= mask;
	}
}


static int unixGetTempname(int nBuf, char *zBuf);


static int unixFileControl(sqlite3_file *id, int op, void *pArg) {
	unixFile *pFile = (unixFile*)id;
	switch (op) {
	case SQLITE_FCNTL_LOCKSTATE: {
		*(int*)pArg = pFile->eFileLock;
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_LAST_ERRNO: {
		*(int*)pArg = pFile->lastErrno;
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_CHUNK_SIZE: {
		pFile->szChunk = *(int *)pArg;
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_SIZE_HINT: {
		int rc;
		SimulateIOErrorBenign(1);
		rc = fcntlSizeHint(pFile, *(i64 *)pArg);
		SimulateIOErrorBenign(0);
		return rc;
	}
	case SQLITE_FCNTL_PERSIST_WAL: {
		unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {
		unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_VFSNAME: {
		*(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_TEMPFILENAME: {
		char *zTFile = sqlite3_malloc64(pFile->pVfs->mxPathname);
		if (zTFile) {
			unixGetTempname(pFile->pVfs->mxPathname, zTFile);
			*(char**)pArg = zTFile;
		}
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_HAS_MOVED: {
		*(int*)pArg = fileHasMoved(pFile);
		return SQLITE_OK;
	}
#if SQLITE_MAX_MMAP_SIZE>0
	case SQLITE_FCNTL_MMAP_SIZE: {
		i64 newLimit = *(i64*)pArg;
		int rc = SQLITE_OK;
		if (newLimit>sqlite3GlobalConfig.mxMmap) {
			newLimit = sqlite3GlobalConfig.mxMmap;
		}
		*(i64*)pArg = pFile->mmapSizeMax;
		if (newLimit >= 0 && newLimit != pFile->mmapSizeMax && pFile->nFetchOut == 0) {
			pFile->mmapSizeMax = newLimit;
			if (pFile->mmapSize>0) {
				unixUnmapfile(pFile);
				rc = unixMapfile(pFile, -1);
			}
		}
		return rc;
	}
#endif
#ifdef SQLITE_DEBUG
								 
	case SQLITE_FCNTL_DB_UNCHANGED: {
		((unixFile*)id)->dbUpdate = 0;
		return SQLITE_OK;
	}
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
	case SQLITE_FCNTL_SET_LOCKPROXYFILE:
	case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
		return proxyFileControl(id, op, pArg);
	}
#endif 
	}
	return SQLITE_NOTFOUND;
}


#ifndef __QNXNTO__ 
static int unixSectorSize(sqlite3_file *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	return SQLITE_DEFAULT_SECTOR_SIZE;
}
#endif


#ifdef __QNXNTO__
#include <sys/dcmd_blk.h>
#include <sys/statvfs.h>
static int unixSectorSize(sqlite3_file *id) {
	unixFile *pFile = (unixFile*)id;
	if (pFile->sectorSize == 0) {
		struct statvfs fsInfo;

		
		pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;
		pFile->deviceCharacteristics = 0;
		if (fstatvfs(pFile->h, &fsInfo) == -1) {
			return pFile->sectorSize;
		}

		if (!strcmp(fsInfo.f_basetype, "tmp")) {
			pFile->sectorSize = fsInfo.f_bsize;
			pFile->deviceCharacteristics =
				SQLITE_IOCAP_ATOMIC4K |       
				SQLITE_IOCAP_SAFE_APPEND |    
				SQLITE_IOCAP_SEQUENTIAL |     
				0;
		}
		else if (strstr(fsInfo.f_basetype, "etfs")) {
			pFile->sectorSize = fsInfo.f_bsize;
			pFile->deviceCharacteristics =
				
				(pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) |
				SQLITE_IOCAP_SAFE_APPEND |    
				SQLITE_IOCAP_SEQUENTIAL |     
				0;
		}
		else if (!strcmp(fsInfo.f_basetype, "qnx6")) {
			pFile->sectorSize = fsInfo.f_bsize;
			pFile->deviceCharacteristics =
				SQLITE_IOCAP_ATOMIC |         
				SQLITE_IOCAP_SAFE_APPEND |    
				SQLITE_IOCAP_SEQUENTIAL |     
				0;
		}
		else if (!strcmp(fsInfo.f_basetype, "qnx4")) {
			pFile->sectorSize = fsInfo.f_bsize;
			pFile->deviceCharacteristics =
				
				((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |
				SQLITE_IOCAP_SEQUENTIAL |     
				0;
		}
		else if (strstr(fsInfo.f_basetype, "dos")) {
			pFile->sectorSize = fsInfo.f_bsize;
			pFile->deviceCharacteristics =
				
				((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |
				SQLITE_IOCAP_SEQUENTIAL |     
				0;
		}
		else {
			pFile->deviceCharacteristics =
				SQLITE_IOCAP_ATOMIC512 |      
				SQLITE_IOCAP_SAFE_APPEND |    
				0;
		}
	}
	
	if (pFile->sectorSize % 512 != 0) {
		pFile->deviceCharacteristics = 0;
		pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;
	}
	return pFile->sectorSize;
}
#endif 


static int unixDeviceCharacteristics(sqlite3_file *id) {
	unixFile *p = (unixFile*)id;
	int rc = 0;
#ifdef __QNXNTO__
	if (p->sectorSize == 0) unixSectorSize(id);
	rc = p->deviceCharacteristics;
#endif
	if (p->ctrlFlags & UNIXFILE_PSOW) {
		rc |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;
	}
	return rc;
}

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0


static int unixGetpagesize(void) {
#if OS_VXWORKS
	return 1024;
#elif defined(_BSD_SOURCE)
	return getpagesize();
#else
	return (int)sysconf(_SC_PAGESIZE);
#endif
}

#endif 

#ifndef SQLITE_OMIT_WAL


struct unixShmNode {
	unixInodeInfo *pInode;     
	sqlite3_mutex *mutex;      
	char *zFilename;           
	int h;                     
	int szRegion;              
	u16 nRegion;               
	u8 isReadonly;             
	char **apRegion;           
	int nRef;                  
	unixShm *pFirst;           
#ifdef SQLITE_DEBUG
	u8 exclMask;               
	u8 sharedMask;             
	u8 nextShmId;              
#endif
};


struct unixShm {
	unixShmNode *pShmNode;     
	unixShm *pNext;            
	u8 hasMutex;               
	u8 id;                     
	u16 sharedMask;            
	u16 exclMask;              
};


#define UNIX_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)         
#define UNIX_SHM_DMS    (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)  


static int unixShmSystemLock(
	unixFile *pFile,       
	int lockType,          
	int ofst,              
	int n                  
) {
	unixShmNode *pShmNode; 
	struct flock f;        
	int rc = SQLITE_OK;    

						   
	pShmNode = pFile->pInode->pShmNode;
	assert(sqlite3_mutex_held(pShmNode->mutex) || pShmNode->nRef == 0);

	
	assert(n == 1 || lockType != F_RDLCK);

	
	assert(n >= 1 && n <= SQLITE_SHM_NLOCK);

	if (pShmNode->h >= 0) {
		
		memset(&f, 0, sizeof(f));
		f.l_type = lockType;
		f.l_whence = SEEK_SET;
		f.l_start = ofst;
		f.l_len = n;

		rc = osFcntl(pShmNode->h, F_SETLK, &f);
		rc = (rc != (-1)) ? SQLITE_OK : SQLITE_BUSY;
	}

	
#ifdef SQLITE_DEBUG
	{ u16 mask;
	OSTRACE(("SHM-LOCK "));
	mask = ofst>31 ? 0xffff : (1 << (ofst + n)) - (1 << ofst);
	if (rc == SQLITE_OK) {
		if (lockType == F_UNLCK) {
			OSTRACE(("unlock %d ok", ofst));
			pShmNode->exclMask &= ~mask;
			pShmNode->sharedMask &= ~mask;
		}
		else if (lockType == F_RDLCK) {
			OSTRACE(("read-lock %d ok", ofst));
			pShmNode->exclMask &= ~mask;
			pShmNode->sharedMask |= mask;
		}
		else {
			assert(lockType == F_WRLCK);
			OSTRACE(("write-lock %d ok", ofst));
			pShmNode->exclMask |= mask;
			pShmNode->sharedMask &= ~mask;
		}
	}
	else {
		if (lockType == F_UNLCK) {
			OSTRACE(("unlock %d failed", ofst));
		}
		else if (lockType == F_RDLCK) {
			OSTRACE(("read-lock failed"));
		}
		else {
			assert(lockType == F_WRLCK);
			OSTRACE(("write-lock %d failed", ofst));
		}
	}
	OSTRACE((" - afterwards %03x,%03x\n",
		pShmNode->sharedMask, pShmNode->exclMask));
	}
#endif

	return rc;
}


static int unixShmRegionPerMap(void) {
	int shmsz = 32 * 1024;            
	int pgsz = osGetpagesize();   
	assert(((pgsz - 1)&pgsz) == 0);   
	if (pgsz<shmsz) return 1;
	return pgsz / shmsz;
}


static void unixShmPurge(unixFile *pFd) {
	unixShmNode *p = pFd->pInode->pShmNode;
	assert(unixMutexHeld());
	if (p && ALWAYS(p->nRef == 0)) {
		int nShmPerMap = unixShmRegionPerMap();
		int i;
		assert(p->pInode == pFd->pInode);
		sqlite3_mutex_free(p->mutex);
		for (i = 0; i<p->nRegion; i += nShmPerMap) {
			if (p->h >= 0) {
				osMunmap(p->apRegion[i], p->szRegion);
			}
			else {
				sqlite3_free(p->apRegion[i]);
			}
		}
		sqlite3_free(p->apRegion);
		if (p->h >= 0) {
			robust_close(pFd, p->h, __LINE__);
			p->h = -1;
		}
		p->pInode->pShmNode = 0;
		sqlite3_free(p);
	}
}


static int unixOpenSharedMemory(unixFile *pDbFd) {
	struct unixShm *p = 0;          
	struct unixShmNode *pShmNode;   
	int rc;                         
	unixInodeInfo *pInode;          
	char *zShmFilename;             
	int nShmFilename;               

									
	p = sqlite3_malloc64(sizeof(*p));
	if (p == 0) return SQLITE_NOMEM_BKPT;
	memset(p, 0, sizeof(*p));
	assert(pDbFd->pShm == 0);

	
	unixEnterMutex();
	pInode = pDbFd->pInode;
	pShmNode = pInode->pShmNode;
	if (pShmNode == 0) {
		struct stat sStat;                 
#ifndef SQLITE_SHM_DIRECTORY
		const char *zBasePath = pDbFd->zPath;
#endif

		
		if (osFstat(pDbFd->h, &sStat)) {
			rc = SQLITE_IOERR_FSTAT;
			goto shm_open_err;
		}

#ifdef SQLITE_SHM_DIRECTORY
		nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;
#else
		nShmFilename = 6 + (int)strlen(zBasePath);
#endif
		pShmNode = sqlite3_malloc64(sizeof(*pShmNode) + nShmFilename);
		if (pShmNode == 0) {
			rc = SQLITE_NOMEM_BKPT;
			goto shm_open_err;
		}
		memset(pShmNode, 0, sizeof(*pShmNode) + nShmFilename);
		zShmFilename = pShmNode->zFilename = (char*)&pShmNode[1];
#ifdef SQLITE_SHM_DIRECTORY
		sqlite3_snprintf(nShmFilename, zShmFilename,
			SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",
			(u32)sStat.st_ino, (u32)sStat.st_dev);
#else
		sqlite3_snprintf(nShmFilename, zShmFilename, "%s-shm", zBasePath);
		sqlite3FileSuffix3(pDbFd->zPath, zShmFilename);
#endif
		pShmNode->h = -1;
		pDbFd->pInode->pShmNode = pShmNode;
		pShmNode->pInode = pDbFd->pInode;
		if (sqlite3GlobalConfig.bCoreMutex) {
			pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
			if (pShmNode->mutex == 0) {
				rc = SQLITE_NOMEM_BKPT;
				goto shm_open_err;
			}
		}

		if (pInode->bProcessLock == 0) {
			int openFlags = O_RDWR | O_CREAT;
			if (sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0)) {
				openFlags = O_RDONLY;
				pShmNode->isReadonly = 1;
			}
			pShmNode->h = robust_open(zShmFilename, openFlags, (sStat.st_mode & 0777));
			if (pShmNode->h<0) {
				rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShmFilename);
				goto shm_open_err;
			}

			
			robustFchown(pShmNode->h, sStat.st_uid, sStat.st_gid);

			
			rc = SQLITE_OK;
			if (unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1) == SQLITE_OK) {
				if (robust_ftruncate(pShmNode->h, 0)) {
					rc = unixLogError(SQLITE_IOERR_SHMOPEN, "ftruncate", zShmFilename);
				}
			}
			if (rc == SQLITE_OK) {
				rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);
			}
			if (rc) goto shm_open_err;
		}
	}

	
	p->pShmNode = pShmNode;
#ifdef SQLITE_DEBUG
	p->id = pShmNode->nextShmId++;
#endif
	pShmNode->nRef++;
	pDbFd->pShm = p;
	unixLeaveMutex();

	
	sqlite3_mutex_enter(pShmNode->mutex);
	p->pNext = pShmNode->pFirst;
	pShmNode->pFirst = p;
	sqlite3_mutex_leave(pShmNode->mutex);
	return SQLITE_OK;

	
shm_open_err:
	unixShmPurge(pDbFd);       
	sqlite3_free(p);
	unixLeaveMutex();
	return rc;
}


static int unixShmMap(
	sqlite3_file *fd,               
	int iRegion,                    
	int szRegion,                   
	int bExtend,                    
	void volatile **pp              
) {
	unixFile *pDbFd = (unixFile*)fd;
	unixShm *p;
	unixShmNode *pShmNode;
	int rc = SQLITE_OK;
	int nShmPerMap = unixShmRegionPerMap();
	int nReqRegion;

	
	if (pDbFd->pShm == 0) {
		rc = unixOpenSharedMemory(pDbFd);
		if (rc != SQLITE_OK) return rc;
	}

	p = pDbFd->pShm;
	pShmNode = p->pShmNode;
	sqlite3_mutex_enter(pShmNode->mutex);
	assert(szRegion == pShmNode->szRegion || pShmNode->nRegion == 0);
	assert(pShmNode->pInode == pDbFd->pInode);
	assert(pShmNode->h >= 0 || pDbFd->pInode->bProcessLock == 1);
	assert(pShmNode->h<0 || pDbFd->pInode->bProcessLock == 0);

	
	nReqRegion = ((iRegion + nShmPerMap) / nShmPerMap) * nShmPerMap;

	if (pShmNode->nRegion<nReqRegion) {
		char **apNew;                      
		int nByte = nReqRegion*szRegion;   
		struct stat sStat;                 

		pShmNode->szRegion = szRegion;

		if (pShmNode->h >= 0) {
			
			if (osFstat(pShmNode->h, &sStat)) {
				rc = SQLITE_IOERR_SHMSIZE;
				goto shmpage_out;
			}

			if (sStat.st_size<nByte) {
				
				if (!bExtend) {
					goto shmpage_out;
				}

				
				else {
					static const int pgsz = 4096;
					int iPg;

					
					assert((nByte % pgsz) == 0);
					for (iPg = (sStat.st_size / pgsz); iPg<(nByte / pgsz); iPg++) {
						int x = 0;
						if (seekAndWriteFd(pShmNode->h, iPg*pgsz + pgsz - 1, "", 1, &x) != 1) {
							const char *zFile = pShmNode->zFilename;
							rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);
							goto shmpage_out;
						}
					}
				}
			}
		}

		
		apNew = (char **)sqlite3_realloc(
			pShmNode->apRegion, nReqRegion * sizeof(char *)
		);
		if (!apNew) {
			rc = SQLITE_IOERR_NOMEM_BKPT;
			goto shmpage_out;
		}
		pShmNode->apRegion = apNew;
		while (pShmNode->nRegion<nReqRegion) {
			int nMap = szRegion*nShmPerMap;
			int i;
			void *pMem;
			if (pShmNode->h >= 0) {
				pMem = osMmap(0, nMap,
					pShmNode->isReadonly ? PROT_READ : PROT_READ | PROT_WRITE,
					MAP_SHARED, pShmNode->h, szRegion*(i64)pShmNode->nRegion
				);
				if (pMem == MAP_FAILED) {
					rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);
					goto shmpage_out;
				}
			}
			else {
				pMem = sqlite3_malloc64(szRegion);
				if (pMem == 0) {
					rc = SQLITE_NOMEM_BKPT;
					goto shmpage_out;
				}
				memset(pMem, 0, szRegion);
			}

			for (i = 0; i<nShmPerMap; i++) {
				pShmNode->apRegion[pShmNode->nRegion + i] = &((char*)pMem)[szRegion*i];
			}
			pShmNode->nRegion += nShmPerMap;
		}
	}

shmpage_out:
	if (pShmNode->nRegion>iRegion) {
		*pp = pShmNode->apRegion[iRegion];
	}
	else {
		*pp = 0;
	}
	if (pShmNode->isReadonly && rc == SQLITE_OK) rc = SQLITE_READONLY;
	sqlite3_mutex_leave(pShmNode->mutex);
	return rc;
}


static int unixShmLock(
	sqlite3_file *fd,          
	int ofst,                  
	int n,                     
	int flags                  
) {
	unixFile *pDbFd = (unixFile*)fd;      
	unixShm *p = pDbFd->pShm;             
	unixShm *pX;                          
	unixShmNode *pShmNode = p->pShmNode;  
	int rc = SQLITE_OK;                   
	u16 mask;                             

	assert(pShmNode == pDbFd->pInode->pShmNode);
	assert(pShmNode->pInode == pDbFd->pInode);
	assert(ofst >= 0 && ofst + n <= SQLITE_SHM_NLOCK);
	assert(n >= 1);
	assert(flags == (SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)
		|| flags == (SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)
		|| flags == (SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)
		|| flags == (SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE));
	assert(n == 1 || (flags & SQLITE_SHM_EXCLUSIVE) != 0);
	assert(pShmNode->h >= 0 || pDbFd->pInode->bProcessLock == 1);
	assert(pShmNode->h<0 || pDbFd->pInode->bProcessLock == 0);

	mask = (1 << (ofst + n)) - (1 << ofst);
	assert(n>1 || mask == (1 << ofst));
	sqlite3_mutex_enter(pShmNode->mutex);
	if (flags & SQLITE_SHM_UNLOCK) {
		u16 allMask = 0; 

						 
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if (pX == p) continue;
			assert((pX->exclMask & (p->exclMask | p->sharedMask)) == 0);
			allMask |= pX->sharedMask;
		}

		
		if ((mask & allMask) == 0) {
			rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst + UNIX_SHM_BASE, n);
		}
		else {
			rc = SQLITE_OK;
		}

		
		if (rc == SQLITE_OK) {
			p->exclMask &= ~mask;
			p->sharedMask &= ~mask;
		}
	}
	else if (flags & SQLITE_SHM_SHARED) {
		u16 allShared = 0;  

							
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if ((pX->exclMask & mask) != 0) {
				rc = SQLITE_BUSY;
				break;
			}
			allShared |= pX->sharedMask;
		}

		
		if (rc == SQLITE_OK) {
			if ((allShared & mask) == 0) {
				rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst + UNIX_SHM_BASE, n);
			}
			else {
				rc = SQLITE_OK;
			}
		}

		
		if (rc == SQLITE_OK) {
			p->sharedMask |= mask;
		}
	}
	else {
		
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if ((pX->exclMask & mask) != 0 || (pX->sharedMask & mask) != 0) {
				rc = SQLITE_BUSY;
				break;
			}
		}

		
		if (rc == SQLITE_OK) {
			rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst + UNIX_SHM_BASE, n);
			if (rc == SQLITE_OK) {
				assert((p->sharedMask & mask) == 0);
				p->exclMask |= mask;
			}
		}
	}
	sqlite3_mutex_leave(pShmNode->mutex);
	OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",
		p->id, osGetpid(0), p->sharedMask, p->exclMask));
	return rc;
}


static void unixShmBarrier(
	sqlite3_file *fd                
) {
	UNUSED_PARAMETER(fd);
	sqlite3MemoryBarrier();         
	unixEnterMutex();               
	unixLeaveMutex();
}


static int unixShmUnmap(
	sqlite3_file *fd,               
	int deleteFlag                  
) {
	unixShm *p;                     
	unixShmNode *pShmNode;          
	unixShm **pp;                   
	unixFile *pDbFd;                

	pDbFd = (unixFile*)fd;
	p = pDbFd->pShm;
	if (p == 0) return SQLITE_OK;
	pShmNode = p->pShmNode;

	assert(pShmNode == pDbFd->pInode->pShmNode);
	assert(pShmNode->pInode == pDbFd->pInode);

	
	sqlite3_mutex_enter(pShmNode->mutex);
	for (pp = &pShmNode->pFirst; (*pp) != p; pp = &(*pp)->pNext) {}
	*pp = p->pNext;

	
	sqlite3_free(p);
	pDbFd->pShm = 0;
	sqlite3_mutex_leave(pShmNode->mutex);

	
	unixEnterMutex();
	assert(pShmNode->nRef>0);
	pShmNode->nRef--;
	if (pShmNode->nRef == 0) {
		if (deleteFlag && pShmNode->h >= 0) {
			osUnlink(pShmNode->zFilename);
		}
		unixShmPurge(pDbFd);
	}
	unixLeaveMutex();

	return SQLITE_OK;
}


#else
# define unixShmMap     0
# define unixShmLock    0
# define unixShmBarrier 0
# define unixShmUnmap   0
#endif 

#if SQLITE_MAX_MMAP_SIZE>0

static void unixUnmapfile(unixFile *pFd) {
	assert(pFd->nFetchOut == 0);
	if (pFd->pMapRegion) {
		osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);
		pFd->pMapRegion = 0;
		pFd->mmapSize = 0;
		pFd->mmapSizeActual = 0;
	}
}


static void unixRemapfile(
	unixFile *pFd,                  
	i64 nNew                        
) {
	const char *zErr = "mmap";
	int h = pFd->h;                      
	u8 *pOrig = (u8 *)pFd->pMapRegion;   
	i64 nOrig = pFd->mmapSizeActual;     
	u8 *pNew = 0;                        
	int flags = PROT_READ;               

	assert(pFd->nFetchOut == 0);
	assert(nNew>pFd->mmapSize);
	assert(nNew <= pFd->mmapSizeMax);
	assert(nNew>0);
	assert(pFd->mmapSizeActual >= pFd->mmapSize);
	assert(MAP_FAILED != 0);

#ifdef SQLITE_MMAP_READWRITE
	if ((pFd->ctrlFlags & UNIXFILE_RDONLY) == 0) flags |= PROT_WRITE;
#endif

	if (pOrig) {
#if HAVE_MREMAP
		i64 nReuse = pFd->mmapSize;
#else
		const int szSyspage = osGetpagesize();
		i64 nReuse = (pFd->mmapSize & ~(szSyspage - 1));
#endif
		u8 *pReq = &pOrig[nReuse];

		
		if (nReuse != nOrig) {
			osMunmap(pReq, nOrig - nReuse);
		}

#if HAVE_MREMAP
		pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);
		zErr = "mremap";
#else
		pNew = osMmap(pReq, nNew - nReuse, flags, MAP_SHARED, h, nReuse);
		if (pNew != MAP_FAILED) {
			if (pNew != pReq) {
				osMunmap(pNew, nNew - nReuse);
				pNew = 0;
			}
			else {
				pNew = pOrig;
			}
		}
#endif

		
		if (pNew == MAP_FAILED || pNew == 0) {
			osMunmap(pOrig, nReuse);
		}
	}

	
	if (pNew == 0) {
		pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);
	}

	if (pNew == MAP_FAILED) {
		pNew = 0;
		nNew = 0;
		unixLogError(SQLITE_OK, zErr, pFd->zPath);

		
		pFd->mmapSizeMax = 0;
	}
	pFd->pMapRegion = (void *)pNew;
	pFd->mmapSize = pFd->mmapSizeActual = nNew;
}


static int unixMapfile(unixFile *pFd, i64 nMap) {
	assert(nMap >= 0 || pFd->nFetchOut == 0);
	assert(nMap>0 || (pFd->mmapSize == 0 && pFd->pMapRegion == 0));
	if (pFd->nFetchOut>0) return SQLITE_OK;

	if (nMap<0) {
		struct stat statbuf;          
		if (osFstat(pFd->h, &statbuf)) {
			return SQLITE_IOERR_FSTAT;
		}
		nMap = statbuf.st_size;
	}
	if (nMap>pFd->mmapSizeMax) {
		nMap = pFd->mmapSizeMax;
	}

	assert(nMap>0 || (pFd->mmapSize == 0 && pFd->pMapRegion == 0));
	if (nMap != pFd->mmapSize) {
		unixRemapfile(pFd, nMap);
	}

	return SQLITE_OK;
}
#endif 


static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp) {
#if SQLITE_MAX_MMAP_SIZE>0
	unixFile *pFd = (unixFile *)fd;   
#endif
	*pp = 0;

#if SQLITE_MAX_MMAP_SIZE>0
	if (pFd->mmapSizeMax>0) {
		if (pFd->pMapRegion == 0) {
			int rc = unixMapfile(pFd, -1);
			if (rc != SQLITE_OK) return rc;
		}
		if (pFd->mmapSize >= iOff + nAmt) {
			*pp = &((u8 *)pFd->pMapRegion)[iOff];
			pFd->nFetchOut++;
		}
	}
#endif
	return SQLITE_OK;
}


static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p) {
#if SQLITE_MAX_MMAP_SIZE>0
	unixFile *pFd = (unixFile *)fd;   
	UNUSED_PARAMETER(iOff);

	
	assert((p == 0) == (pFd->nFetchOut == 0));

	
	assert(p == 0 || p == &((u8 *)pFd->pMapRegion)[iOff]);

	if (p) {
		pFd->nFetchOut--;
	}
	else {
		unixUnmapfile(pFd);
	}

	assert(pFd->nFetchOut >= 0);
#else
	UNUSED_PARAMETER(fd);
	UNUSED_PARAMETER(p);
	UNUSED_PARAMETER(iOff);
#endif
	return SQLITE_OK;
}




#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)     \
static const sqlite3_io_methods METHOD = {                                   \
   VERSION,                                                    \
   CLOSE,                                                        \
   unixRead,                                                      \
   unixWrite,                                                    \
   unixTruncate,                                              \
   unixSync,                                                      \
   unixFileSize,                                              \
   LOCK,                                                          \
   UNLOCK,                                                      \
   CKLOCK,                                           \
   unixFileControl,                                        \
   unixSectorSize,                                          \
   unixDeviceCharacteristics,                       \
   SHMMAP,                                                      \
   unixShmLock,                                                \
   unixShmBarrier,                                          \
   unixShmUnmap,                                              \
   unixFetch,                                                    \
   unixUnfetch,                                                \
};                                                                           \
static const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \
  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \
  return &METHOD;                                                            \
}                                                                            \
static const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \
    = FINDER##Impl;


IOMETHODS(
	posixIoFinder,            
	posixIoMethods,           
	3,                        
	unixClose,                
	unixLock,                 
	unixUnlock,               
	unixCheckReservedLock,    
	unixShmMap                
)
IOMETHODS(
	nolockIoFinder,           
	nolockIoMethods,          
	3,                        
	nolockClose,              
	nolockLock,               
	nolockUnlock,             
	nolockCheckReservedLock,  
	0                         
)
IOMETHODS(
	dotlockIoFinder,          
	dotlockIoMethods,         
	1,                        
	dotlockClose,             
	dotlockLock,              
	dotlockUnlock,            
	dotlockCheckReservedLock, 
	0                         
)

#if SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
	flockIoFinder,            
	flockIoMethods,           
	1,                        
	flockClose,               
	flockLock,                
	flockUnlock,              
	flockCheckReservedLock,   
	0                         
)
#endif

#if OS_VXWORKS
IOMETHODS(
	semIoFinder,              
	semIoMethods,             
	1,                        
	semXClose,                
	semXLock,                 
	semXUnlock,               
	semXCheckReservedLock,    
	0                         
)
#endif

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
	afpIoFinder,              
	afpIoMethods,             
	1,                        
	afpClose,                 
	afpLock,                  
	afpUnlock,                
	afpCheckReservedLock,     
	0                         
)
#endif


#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
static int proxyClose(sqlite3_file*);
static int proxyLock(sqlite3_file*, int);
static int proxyUnlock(sqlite3_file*, int);
static int proxyCheckReservedLock(sqlite3_file*, int*);
IOMETHODS(
	proxyIoFinder,            
	proxyIoMethods,           
	1,                        
	proxyClose,               
	proxyLock,                
	proxyUnlock,              
	proxyCheckReservedLock,   
	0                         
)
#endif


#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
	nfsIoFinder,               
	nfsIoMethods,              
	1,                         
	unixClose,                 
	unixLock,                  
	nfsUnlock,                 
	unixCheckReservedLock,     
	0                          
)
#endif

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE

static const sqlite3_io_methods *autolockIoFinderImpl(
	const char *filePath,    
	unixFile *pNew           
) {
	static const struct Mapping {
		const char *zFilesystem;              
		const sqlite3_io_methods *pMethods;   
	} aMap[] = {
		{ "hfs",    &posixIoMethods },
		{ "ufs",    &posixIoMethods },
		{ "afpfs",  &afpIoMethods },
		{ "smbfs",  &afpIoMethods },
		{ "webdav", &nolockIoMethods },
		{ 0, 0 }
	};
	int i;
	struct statfs fsInfo;
	struct flock lockInfo;

	if (!filePath) {
		
		return &nolockIoMethods;
	}
	if (statfs(filePath, &fsInfo) != -1) {
		if (fsInfo.f_flags & MNT_RDONLY) {
			return &nolockIoMethods;
		}
		for (i = 0; aMap[i].zFilesystem; i++) {
			if (strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem) == 0) {
				return aMap[i].pMethods;
			}
		}
	}

	
	lockInfo.l_len = 1;
	lockInfo.l_start = 0;
	lockInfo.l_whence = SEEK_SET;
	lockInfo.l_type = F_RDLCK;
	if (osFcntl(pNew->h, F_GETLK, &lockInfo) != -1) {
		if (strcmp(fsInfo.f_fstypename, "nfs") == 0) {
			return &nfsIoMethods;
		}
		else {
			return &posixIoMethods;
		}
	}
	else {
		return &dotlockIoMethods;
	}
}
static const sqlite3_io_methods
*(*const autolockIoFinder)(const char*, unixFile*) = autolockIoFinderImpl;

#endif 

#if OS_VXWORKS

static const sqlite3_io_methods *vxworksIoFinderImpl(
	const char *filePath,    
	unixFile *pNew           
) {
	struct flock lockInfo;

	if (!filePath) {
		
		return &nolockIoMethods;
	}

	
	lockInfo.l_len = 1;
	lockInfo.l_start = 0;
	lockInfo.l_whence = SEEK_SET;
	lockInfo.l_type = F_RDLCK;
	if (osFcntl(pNew->h, F_GETLK, &lockInfo) != -1) {
		return &posixIoMethods;
	}
	else {
		return &semIoMethods;
	}
}
static const sqlite3_io_methods
*(*const vxworksIoFinder)(const char*, unixFile*) = vxworksIoFinderImpl;

#endif 


typedef const sqlite3_io_methods *(*finder_type)(const char*, unixFile*);





static int fillInUnixFile(
	sqlite3_vfs *pVfs,      
	int h,                  
	sqlite3_file *pId,      
	const char *zFilename,  
	int ctrlFlags           
) {
	const sqlite3_io_methods *pLockingStyle;
	unixFile *pNew = (unixFile *)pId;
	int rc = SQLITE_OK;

	assert(pNew->pInode == NULL);

	
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
	assert(zFilename == 0 || zFilename[0] == '/'
		|| pVfs->pAppData == (void*)&autolockIoFinder);
#else
	assert(zFilename == 0 || zFilename[0] == '/');
#endif

	
	assert(zFilename != 0 || (ctrlFlags & UNIXFILE_NOLOCK) != 0);

	OSTRACE(("OPEN    %-3d %s\n", h, zFilename));
	pNew->h = h;
	pNew->pVfs = pVfs;
	pNew->zPath = zFilename;
	pNew->ctrlFlags = (u8)ctrlFlags;
#if SQLITE_MAX_MMAP_SIZE>0
	pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;
#endif
	if (sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),
		"psow", SQLITE_POWERSAFE_OVERWRITE)) {
		pNew->ctrlFlags |= UNIXFILE_PSOW;
	}
	if (strcmp(pVfs->zName, "unix-excl") == 0) {
		pNew->ctrlFlags |= UNIXFILE_EXCL;
	}

#if OS_VXWORKS
	pNew->pId = vxworksFindFileId(zFilename);
	if (pNew->pId == 0) {
		ctrlFlags |= UNIXFILE_NOLOCK;
		rc = SQLITE_NOMEM_BKPT;
	}
#endif

	if (ctrlFlags & UNIXFILE_NOLOCK) {
		pLockingStyle = &nolockIoMethods;
	}
	else {
		pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);
#if SQLITE_ENABLE_LOCKING_STYLE
		
		pNew->lockingContext = (void*)zFilename;
#endif
	}

	if (pLockingStyle == &posixIoMethods
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
		|| pLockingStyle == &nfsIoMethods
#endif
		) {
		unixEnterMutex();
		rc = findInodeInfo(pNew, &pNew->pInode);
		if (rc != SQLITE_OK) {
			
			robust_close(pNew, h, __LINE__);
			h = -1;
		}
		unixLeaveMutex();
	}

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
	else if (pLockingStyle == &afpIoMethods) {
		
		afpLockingContext *pCtx;
		pNew->lockingContext = pCtx = sqlite3_malloc64(sizeof(*pCtx));
		if (pCtx == 0) {
			rc = SQLITE_NOMEM_BKPT;
		}
		else {
			
			pCtx->dbPath = zFilename;
			pCtx->reserved = 0;
			srandomdev();
			unixEnterMutex();
			rc = findInodeInfo(pNew, &pNew->pInode);
			if (rc != SQLITE_OK) {
				sqlite3_free(pNew->lockingContext);
				robust_close(pNew, h, __LINE__);
				h = -1;
			}
			unixLeaveMutex();
		}
	}
#endif

	else if (pLockingStyle == &dotlockIoMethods) {
		
		char *zLockFile;
		int nFilename;
		assert(zFilename != 0);
		nFilename = (int)strlen(zFilename) + 6;
		zLockFile = (char *)sqlite3_malloc64(nFilename);
		if (zLockFile == 0) {
			rc = SQLITE_NOMEM_BKPT;
		}
		else {
			sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);
		}
		pNew->lockingContext = zLockFile;
	}

#if OS_VXWORKS
	else if (pLockingStyle == &semIoMethods) {
		
		unixEnterMutex();
		rc = findInodeInfo(pNew, &pNew->pInode);
		if ((rc == SQLITE_OK) && (pNew->pInode->pSem == NULL)) {
			char *zSemName = pNew->pInode->aSemName;
			int n;
			sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",
				pNew->pId->zCanonicalName);
			for (n = 1; zSemName[n]; n++)
				if (zSemName[n] == '/') zSemName[n] = '_';
			pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);
			if (pNew->pInode->pSem == SEM_FAILED) {
				rc = SQLITE_NOMEM_BKPT;
				pNew->pInode->aSemName[0] = '\0';
			}
		}
		unixLeaveMutex();
	}
#endif

	storeLastErrno(pNew, 0);
#if OS_VXWORKS
	if (rc != SQLITE_OK) {
		if (h >= 0) robust_close(pNew, h, __LINE__);
		h = -1;
		osUnlink(zFilename);
		pNew->ctrlFlags |= UNIXFILE_DELETE;
	}
#endif
	if (rc != SQLITE_OK) {
		if (h >= 0) robust_close(pNew, h, __LINE__);
	}
	else {
		pNew->pMethod = pLockingStyle;
		OpenCounter(+1);
		verifyDbFile(pNew);
	}
	return rc;
}


static const char *unixTempFileDir(void) {
	static const char *azDirs[] = {
		0,
		0,
		"/var/tmp",
		"/usr/tmp",
		"/tmp",
		"."
	};
	unsigned int i = 0;
	struct stat buf;
	const char *zDir = sqlite3_temp_directory;

	if (!azDirs[0]) azDirs[0] = getenv("SQLITE_TMPDIR");
	if (!azDirs[1]) azDirs[1] = getenv("TMPDIR");
	while (1) {
		if (zDir != 0
			&& osStat(zDir, &buf) == 0
			&& S_ISDIR(buf.st_mode)
			&& osAccess(zDir, 03) == 0
			) {
			return zDir;
		}
		if (i >= sizeof(azDirs) / sizeof(azDirs[0])) break;
		zDir = azDirs[i++];
	}
	return 0;
}


static int unixGetTempname(int nBuf, char *zBuf) {
	const char *zDir;
	int iLimit = 0;

	
	zBuf[0] = 0;
	SimulateIOError(return SQLITE_IOERR);

	zDir = unixTempFileDir();
	if (zDir == 0) return SQLITE_IOERR_GETTEMPPATH;
	do {
		u64 r;
		sqlite3_randomness(sizeof(r), &r);
		assert(nBuf>2);
		zBuf[nBuf - 2] = 0;
		sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",
			zDir, r, 0);
		if (zBuf[nBuf - 2] != 0 || (iLimit++)>10) return SQLITE_ERROR;
	} while (osAccess(zBuf, 0) == 0);
	return SQLITE_OK;
}

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)

static int proxyTransformUnixFile(unixFile*, const char*);
#endif


static UnixUnusedFd *findReusableFd(const char *zPath, int flags) {
	UnixUnusedFd *pUnused = 0;

	
#if !OS_VXWORKS
	struct stat sStat;                   

										 
	if (0 == osStat(zPath, &sStat)) {
		unixInodeInfo *pInode;

		unixEnterMutex();
		pInode = inodeList;
		while (pInode && (pInode->fileId.dev != sStat.st_dev
			|| pInode->fileId.ino != sStat.st_ino)) {
			pInode = pInode->pNext;
		}
		if (pInode) {
			UnixUnusedFd **pp;
			for (pp = &pInode->pUnused; *pp && (*pp)->flags != flags; pp = &((*pp)->pNext));
			pUnused = *pp;
			if (pUnused) {
				*pp = pUnused->pNext;
			}
		}
		unixLeaveMutex();
	}
#endif    
	return pUnused;
}


static int getFileMode(
	const char *zFile,              
	mode_t *pMode,                  
	uid_t *pUid,                    
	gid_t *pGid                     
) {
	struct stat sStat;              
	int rc = SQLITE_OK;
	if (0 == osStat(zFile, &sStat)) {
		*pMode = sStat.st_mode & 0777;
		*pUid = sStat.st_uid;
		*pGid = sStat.st_gid;
	}
	else {
		rc = SQLITE_IOERR_FSTAT;
	}
	return rc;
}


static int findCreateFileMode(
	const char *zPath,              
	int flags,                      
	mode_t *pMode,                  
	uid_t *pUid,                    
	gid_t *pGid                     
) {
	int rc = SQLITE_OK;             
	*pMode = 0;
	*pUid = 0;
	*pGid = 0;
	if (flags & (SQLITE_OPEN_WAL | SQLITE_OPEN_MAIN_JOURNAL)) {
		char zDb[MAX_PATHNAME + 1];     
		int nDb;                      

									  
		nDb = sqlite3Strlen30(zPath) - 1;
		while (zPath[nDb] != '-') {
#ifndef SQLITE_ENABLE_8_3_NAMES
			
			assert(nDb>0);
			assert(sqlite3Isalnum(zPath[nDb]));
#else
			
			if (nDb == 0 || zPath[nDb] == '.') return SQLITE_OK;
#endif
			nDb--;
		}
		memcpy(zDb, zPath, nDb);
		zDb[nDb] = '\0';

		rc = getFileMode(zDb, pMode, pUid, pGid);
	}
	else if (flags & SQLITE_OPEN_DELETEONCLOSE) {
		*pMode = 0600;
	}
	else if (flags & SQLITE_OPEN_URI) {
		
		const char *z = sqlite3_uri_parameter(zPath, "modeof");
		if (z) {
			rc = getFileMode(z, pMode, pUid, pGid);
		}
	}
	return rc;
}


static int unixOpen(
	sqlite3_vfs *pVfs,           
	const char *zPath,           
	sqlite3_file *pFile,         
	int flags,                   
	int *pOutFlags               
) {
	unixFile *p = (unixFile *)pFile;
	int fd = -1;                   
	int openFlags = 0;             
	int eType = flags & 0xFFFFFF00;  
	int noLock;                    
	int rc = SQLITE_OK;            
	int ctrlFlags = 0;             

	int isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE);
	int isDelete = (flags & SQLITE_OPEN_DELETEONCLOSE);
	int isCreate = (flags & SQLITE_OPEN_CREATE);
	int isReadonly = (flags & SQLITE_OPEN_READONLY);
	int isReadWrite = (flags & SQLITE_OPEN_READWRITE);
#if SQLITE_ENABLE_LOCKING_STYLE
	int isAutoProxy = (flags & SQLITE_OPEN_AUTOPROXY);
#endif
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
	struct statfs fsInfo;
#endif

	
	int syncDir = (isCreate && (
		eType == SQLITE_OPEN_MASTER_JOURNAL
		|| eType == SQLITE_OPEN_MAIN_JOURNAL
		|| eType == SQLITE_OPEN_WAL
		));

	
	char zTmpname[MAX_PATHNAME + 2];
	const char *zName = zPath;

	
	assert((isReadonly == 0 || isReadWrite == 0) && (isReadWrite || isReadonly));
	assert(isCreate == 0 || isReadWrite);
	assert(isExclusive == 0 || isCreate);
	assert(isDelete == 0 || isCreate);

	
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MAIN_DB);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MAIN_JOURNAL);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MASTER_JOURNAL);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_WAL);

	
	assert(eType == SQLITE_OPEN_MAIN_DB || eType == SQLITE_OPEN_TEMP_DB
		|| eType == SQLITE_OPEN_MAIN_JOURNAL || eType == SQLITE_OPEN_TEMP_JOURNAL
		|| eType == SQLITE_OPEN_SUBJOURNAL || eType == SQLITE_OPEN_MASTER_JOURNAL
		|| eType == SQLITE_OPEN_TRANSIENT_DB || eType == SQLITE_OPEN_WAL
	);

	
	if (randomnessPid != osGetpid(0)) {
		randomnessPid = osGetpid(0);
		sqlite3_randomness(0, 0);
	}

	memset(p, 0, sizeof(unixFile));

	if (eType == SQLITE_OPEN_MAIN_DB) {
		UnixUnusedFd *pUnused;
		pUnused = findReusableFd(zName, flags);
		if (pUnused) {
			fd = pUnused->fd;
		}
		else {
			pUnused = sqlite3_malloc64(sizeof(*pUnused));
			if (!pUnused) {
				return SQLITE_NOMEM_BKPT;
			}
		}
		p->pUnused = pUnused;

		
		assert((flags & SQLITE_OPEN_URI) || zName[strlen(zName) + 1] == 0);

	}
	else if (!zName) {
		
		assert(isDelete && !syncDir);
		rc = unixGetTempname(pVfs->mxPathname, zTmpname);
		if (rc != SQLITE_OK) {
			return rc;
		}
		zName = zTmpname;

		
		assert(zName[strlen(zName) + 1] == 0);
	}

	
	if (isReadonly)  openFlags |= O_RDONLY;
	if (isReadWrite) openFlags |= O_RDWR;
	if (isCreate)    openFlags |= O_CREAT;
	if (isExclusive) openFlags |= (O_EXCL | O_NOFOLLOW);
	openFlags |= (O_LARGEFILE | O_BINARY);

	if (fd<0) {
		mode_t openMode;              
		uid_t uid;                    
		gid_t gid;                    
		rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);
		if (rc != SQLITE_OK) {
			assert(!p->pUnused);
			assert(eType == SQLITE_OPEN_WAL || eType == SQLITE_OPEN_MAIN_JOURNAL);
			return rc;
		}
		fd = robust_open(zName, openFlags, openMode);
		OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));
		assert(!isExclusive || (openFlags & O_CREAT) != 0);
		if (fd<0 && errno != EISDIR && isReadWrite) {
			
			flags &= ~(SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
			openFlags &= ~(O_RDWR | O_CREAT);
			flags |= SQLITE_OPEN_READONLY;
			openFlags |= O_RDONLY;
			isReadonly = 1;
			fd = robust_open(zName, openFlags, openMode);
		}
		if (fd<0) {
			rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);
			goto open_finished;
		}

		
		if (flags & (SQLITE_OPEN_WAL | SQLITE_OPEN_MAIN_JOURNAL)) {
			robustFchown(fd, uid, gid);
		}
	}
	assert(fd >= 0);
	if (pOutFlags) {
		*pOutFlags = flags;
	}

	if (p->pUnused) {
		p->pUnused->fd = fd;
		p->pUnused->flags = flags;
	}

	if (isDelete) {
#if OS_VXWORKS
		zPath = zName;
#elif defined(SQLITE_UNLINK_AFTER_CLOSE)
		zPath = sqlite3_mprintf("%s", zName);
		if (zPath == 0) {
			robust_close(p, fd, __LINE__);
			return SQLITE_NOMEM_BKPT;
		}
#else
		osUnlink(zName);
#endif
	}
#if SQLITE_ENABLE_LOCKING_STYLE
	else {
		p->openFlags = openFlags;
	}
#endif

#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
	if (fstatfs(fd, &fsInfo) == -1) {
		storeLastErrno(p, errno);
		robust_close(p, fd, __LINE__);
		return SQLITE_IOERR_ACCESS;
	}
	if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {
		((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
	}
	if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {
		((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
	}
#endif

	
	if (isDelete)                ctrlFlags |= UNIXFILE_DELETE;
	if (isReadonly)              ctrlFlags |= UNIXFILE_RDONLY;
	noLock = eType != SQLITE_OPEN_MAIN_DB;
	if (noLock)                  ctrlFlags |= UNIXFILE_NOLOCK;
	if (syncDir)                 ctrlFlags |= UNIXFILE_DIRSYNC;
	if (flags & SQLITE_OPEN_URI) ctrlFlags |= UNIXFILE_URI;

#if SQLITE_ENABLE_LOCKING_STYLE
#if SQLITE_PREFER_PROXY_LOCKING
	isAutoProxy = 1;
#endif
	if (isAutoProxy && (zPath != NULL) && (!noLock) && pVfs->xOpen) {
		char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");
		int useProxy = 0;

		
		if (envforce != NULL) {
			useProxy = atoi(envforce)>0;
		}
		else {
			useProxy = !(fsInfo.f_flags&MNT_LOCAL);
		}
		if (useProxy) {
			rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);
			if (rc == SQLITE_OK) {
				rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");
				if (rc != SQLITE_OK) {
					
					unixClose(pFile);
					return rc;
				}
			}
			goto open_finished;
		}
	}
#endif

	rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);

open_finished:
	if (rc != SQLITE_OK) {
		sqlite3_free(p->pUnused);
	}
	return rc;
}



static int unixDelete(
	sqlite3_vfs *NotUsed,     
	const char *zPath,        
	int dirSync               
) {
	int rc = SQLITE_OK;
	UNUSED_PARAMETER(NotUsed);
	SimulateIOError(return SQLITE_IOERR_DELETE);
	if (osUnlink(zPath) == (-1)) {
		if (errno == ENOENT
#if OS_VXWORKS
			|| osAccess(zPath, 0) != 0
#endif
			) {
			rc = SQLITE_IOERR_DELETE_NOENT;
		}
		else {
			rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);
		}
		return rc;
	}
#ifndef SQLITE_DISABLE_DIRSYNC
	if ((dirSync & 1) != 0) {
		int fd;
		rc = osOpenDirectory(zPath, &fd);
		if (rc == SQLITE_OK) {
			if (full_fsync(fd, 0, 0)) {
				rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);
			}
			robust_close(0, fd, __LINE__);
		}
		else {
			assert(rc == SQLITE_CANTOPEN);
			rc = SQLITE_OK;
		}
	}
#endif
	return rc;
}


static int unixAccess(
	sqlite3_vfs *NotUsed,   
	const char *zPath,      
	int flags,              
	int *pResOut            
) {
	UNUSED_PARAMETER(NotUsed);
	SimulateIOError(return SQLITE_IOERR_ACCESS; );
	assert(pResOut != 0);

	
	assert(flags == SQLITE_ACCESS_EXISTS || flags == SQLITE_ACCESS_READWRITE);

	if (flags == SQLITE_ACCESS_EXISTS) {
		struct stat buf;
		*pResOut = (0 == osStat(zPath, &buf) && buf.st_size>0);
	}
	else {
		*pResOut = osAccess(zPath, W_OK | R_OK) == 0;
	}
	return SQLITE_OK;
}


static int mkFullPathname(
	const char *zPath,              
	char *zOut,                     
	int nOut                        
) {
	int nPath = sqlite3Strlen30(zPath);
	int iOff = 0;
	if (zPath[0] != '/') {
		if (osGetcwd(zOut, nOut - 2) == 0) {
			return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);
		}
		iOff = sqlite3Strlen30(zOut);
		zOut[iOff++] = '/';
	}
	if ((iOff + nPath + 1)>nOut) {
		
		zOut[iOff] = '\0';
		return SQLITE_CANTOPEN_BKPT;
	}
	sqlite3_snprintf(nOut - iOff, &zOut[iOff], "%s", zPath);
	return SQLITE_OK;
}


static int unixFullPathname(
	sqlite3_vfs *pVfs,            
	const char *zPath,            
	int nOut,                     
	char *zOut                    
) {
#if !defined(HAVE_READLINK) || !defined(HAVE_LSTAT)
	return mkFullPathname(zPath, zOut, nOut);
#else
	int rc = SQLITE_OK;
	int nByte;
	int nLink = 1;                
	const char *zIn = zPath;      
	char *zDel = 0;

	assert(pVfs->mxPathname == MAX_PATHNAME);
	UNUSED_PARAMETER(pVfs);

	
	SimulateIOError(return SQLITE_ERROR);

	do {

		
		int bLink = 0;
		struct stat buf;
		if (osLstat(zIn, &buf) != 0) {
			if (errno != ENOENT) {
				rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);
			}
		}
		else {
			bLink = S_ISLNK(buf.st_mode);
		}

		if (bLink) {
			if (zDel == 0) {
				zDel = sqlite3_malloc(nOut);
				if (zDel == 0) rc = SQLITE_NOMEM_BKPT;
			}
			else if (++nLink>SQLITE_MAX_SYMLINKS) {
				rc = SQLITE_CANTOPEN_BKPT;
			}

			if (rc == SQLITE_OK) {
				nByte = osReadlink(zIn, zDel, nOut - 1);
				if (nByte<0) {
					rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);
				}
				else {
					if (zDel[0] != '/') {
						int n;
						for (n = sqlite3Strlen30(zIn); n>0 && zIn[n - 1] != '/'; n--);
						if (nByte + n + 1>nOut) {
							rc = SQLITE_CANTOPEN_BKPT;
						}
						else {
							memmove(&zDel[n], zDel, nByte + 1);
							memcpy(zDel, zIn, n);
							nByte += n;
						}
					}
					zDel[nByte] = '\0';
				}
			}

			zIn = zDel;
		}

		assert(rc != SQLITE_OK || zIn != zOut || zIn[0] == '/');
		if (rc == SQLITE_OK && zIn != zOut) {
			rc = mkFullPathname(zIn, zOut, nOut);
		}
		if (bLink == 0) break;
		zIn = zOut;
	} while (rc == SQLITE_OK);

	sqlite3_free(zDel);
	return rc;
#endif   
}


#ifndef SQLITE_OMIT_LOAD_EXTENSION

#include <dlfcn.h>
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename) {
	UNUSED_PARAMETER(NotUsed);
	return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);
}


static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut) {
	const char *zErr;
	UNUSED_PARAMETER(NotUsed);
	unixEnterMutex();
	zErr = dlerror();
	if (zErr) {
		sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);
	}
	unixLeaveMutex();
}
static void(*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void) {
	
	void(*(*x)(void*, const char*))(void);
	UNUSED_PARAMETER(NotUsed);
	x = (void(*(*)(void*, const char*))(void))dlsym;
	return (*x)(p, zSym);
}
static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle) {
	UNUSED_PARAMETER(NotUsed);
	dlclose(pHandle);
}
#else 
#define unixDlOpen  0
#define unixDlError 0
#define unixDlSym   0
#define unixDlClose 0
#endif


static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf) {
	UNUSED_PARAMETER(NotUsed);
	assert((size_t)nBuf >= (sizeof(time_t) + sizeof(int)));

	
	memset(zBuf, 0, nBuf);
	randomnessPid = osGetpid(0);
#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
	{
		int fd, got;
		fd = robust_open("/dev/urandom", O_RDONLY, 0);
		if (fd<0) {
			time_t t;
			time(&t);
			memcpy(zBuf, &t, sizeof(t));
			memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
			assert(sizeof(t) + sizeof(randomnessPid) <= (size_t)nBuf);
			nBuf = sizeof(t) + sizeof(randomnessPid);
		}
		else {
			do { got = osRead(fd, zBuf, nBuf); } while (got<0 && errno == EINTR);
			robust_close(0, fd, __LINE__);
		}
	}
#endif
	return nBuf;
}



static int unixSleep(sqlite3_vfs *NotUsed, int microseconds) {
#if OS_VXWORKS
	struct timespec sp;

	sp.tv_sec = microseconds / 1000000;
	sp.tv_nsec = (microseconds % 1000000) * 1000;
	nanosleep(&sp, NULL);
	UNUSED_PARAMETER(NotUsed);
	return microseconds;
#elif defined(HAVE_USLEEP) && HAVE_USLEEP
	usleep(microseconds);
	UNUSED_PARAMETER(NotUsed);
	return microseconds;
#else
	int seconds = (microseconds + 999999) / 1000000;
	sleep(seconds);
	UNUSED_PARAMETER(NotUsed);
	return seconds * 1000000;
#endif
}


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_current_time = 0;  
#endif

										  
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow) {
	static const sqlite3_int64 unixEpoch = 24405875 * (sqlite3_int64)8640000;
	int rc = SQLITE_OK;
#if defined(NO_GETTOD)
	time_t t;
	time(&t);
	*piNow = ((sqlite3_int64)t) * 1000 + unixEpoch;
#elif OS_VXWORKS
	struct timespec sNow;
	clock_gettime(CLOCK_REALTIME, &sNow);
	*piNow = unixEpoch + 1000 * (sqlite3_int64)sNow.tv_sec + sNow.tv_nsec / 1000000;
#else
	struct timeval sNow;
	(void)gettimeofday(&sNow, 0);  
	*piNow = unixEpoch + 1000 * (sqlite3_int64)sNow.tv_sec + sNow.tv_usec / 1000;
#endif

#ifdef SQLITE_TEST
	if (sqlite3_current_time) {
		*piNow = 1000 * (sqlite3_int64)sqlite3_current_time + unixEpoch;
	}
#endif
	UNUSED_PARAMETER(NotUsed);
	return rc;
}

#ifndef SQLITE_OMIT_DEPRECATED

static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow) {
	sqlite3_int64 i = 0;
	int rc;
	UNUSED_PARAMETER(NotUsed);
	rc = unixCurrentTimeInt64(0, &i);
	*prNow = i / 86400000.0;
	return rc;
}
#else
# define unixCurrentTime 0
#endif


static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3) {
	UNUSED_PARAMETER(NotUsed);
	UNUSED_PARAMETER(NotUsed2);
	UNUSED_PARAMETER(NotUsed3);
	return errno;
}







#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE


typedef struct proxyLockingContext proxyLockingContext;
struct proxyLockingContext {
	unixFile *conchFile;         
	char *conchFilePath;         
	unixFile *lockProxy;         
	char *lockProxyPath;         
	char *dbPath;                
	int conchHeld;               
	int nFails;                  
	void *oldLockingContext;     
	sqlite3_io_methods const *pOldMethod;     
};


static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen) {
	int len;
	int dbLen;
	int i;

#ifdef LOCKPROXYDIR
	len = strlcpy(lPath, LOCKPROXYDIR, maxLen);
#else
# ifdef _CS_DARWIN_USER_TEMP_DIR
	{
		if (!confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen)) {
			OSTRACE(("GETLOCKPATH  failed %s errno=%d pid=%d\n",
				lPath, errno, osGetpid(0)));
			return SQLITE_IOERR_LOCK;
		}
		len = strlcat(lPath, "sqliteplocks", maxLen);
	}
# else
	len = strlcpy(lPath, "/tmp/", maxLen);
# endif
#endif

	if (lPath[len - 1] != '/') {
		len = strlcat(lPath, "/", maxLen);
	}

	
	dbLen = (int)strlen(dbPath);
	for (i = 0; i<dbLen && (i + len + 7)<(int)maxLen; i++) {
		char c = dbPath[i];
		lPath[i + len] = (c == '/') ? '_' : c;
	}
	lPath[i + len] = '\0';
	strlcat(lPath, ":auto:", maxLen);
	OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));
	return SQLITE_OK;
}


static int proxyCreateLockPath(const char *lockPath) {
	int i, len;
	char buf[MAXPATHLEN];
	int start = 0;

	assert(lockPath != NULL);
	
	len = (int)strlen(lockPath);
	buf[0] = lockPath[0];
	for (i = 1; i<len; i++) {
		if (lockPath[i] == '/' && (i - start > 0)) {
			
			if (i - start>2 || (i - start == 1 && buf[start] != '.' && buf[start] != '/')
				|| (i - start == 2 && buf[start] != '.' && buf[start + 1] != '.')) {
				buf[i] = '\0';
				if (osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS)) {
					int err = errno;
					if (err != EEXIST) {
						OSTRACE(("CREATELOCKPATH  FAILED creating %s, "
							"'%s' proxy lock path=%s pid=%d\n",
							buf, strerror(err), lockPath, osGetpid(0)));
						return err;
					}
				}
			}
			start = i + 1;
		}
		buf[i] = lockPath[i];
	}
	OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n", lockPath, osGetpid(0)));
	return 0;
}


static int proxyCreateUnixFile(
	const char *path,        
	unixFile **ppFile,       
	int islockfile           
) {
	int fd = -1;
	unixFile *pNew;
	int rc = SQLITE_OK;
	int openFlags = O_RDWR | O_CREAT;
	sqlite3_vfs dummyVfs;
	int terrno = 0;
	UnixUnusedFd *pUnused = NULL;

	
	pUnused = findReusableFd(path, openFlags);
	if (pUnused) {
		fd = pUnused->fd;
	}
	else {
		pUnused = sqlite3_malloc64(sizeof(*pUnused));
		if (!pUnused) {
			return SQLITE_NOMEM_BKPT;
		}
	}
	if (fd<0) {
		fd = robust_open(path, openFlags, 0);
		terrno = errno;
		if (fd<0 && errno == ENOENT && islockfile) {
			if (proxyCreateLockPath(path) == SQLITE_OK) {
				fd = robust_open(path, openFlags, 0);
			}
		}
	}
	if (fd<0) {
		openFlags = O_RDONLY;
		fd = robust_open(path, openFlags, 0);
		terrno = errno;
	}
	if (fd<0) {
		if (islockfile) {
			return SQLITE_BUSY;
		}
		switch (terrno) {
		case EACCES:
			return SQLITE_PERM;
		case EIO:
			return SQLITE_IOERR_LOCK; 
		default:
			return SQLITE_CANTOPEN_BKPT;
		}
	}

	pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));
	if (pNew == NULL) {
		rc = SQLITE_NOMEM_BKPT;
		goto end_create_proxy;
	}
	memset(pNew, 0, sizeof(unixFile));
	pNew->openFlags = openFlags;
	memset(&dummyVfs, 0, sizeof(dummyVfs));
	dummyVfs.pAppData = (void*)&autolockIoFinder;
	dummyVfs.zName = "dummy";
	pUnused->fd = fd;
	pUnused->flags = openFlags;
	pNew->pUnused = pUnused;

	rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);
	if (rc == SQLITE_OK) {
		*ppFile = pNew;
		return SQLITE_OK;
	}
end_create_proxy:
	robust_close(pNew, fd, __LINE__);
	sqlite3_free(pNew);
	sqlite3_free(pUnused);
	return rc;
}

#ifdef SQLITE_TEST

SQLITE_API int sqlite3_hostid_num = 0;
#endif

#define PROXY_HOSTIDLEN    16  

#ifdef HAVE_GETHOSTUUID

extern int gethostuuid(uuid_t id, const struct timespec *wait);
#endif


static int proxyGetHostID(unsigned char *pHostID, int *pError) {
	assert(PROXY_HOSTIDLEN == sizeof(uuid_t));
	memset(pHostID, 0, PROXY_HOSTIDLEN);
#ifdef HAVE_GETHOSTUUID
	{
		struct timespec timeout = { 1, 0 }; 
		if (gethostuuid(pHostID, &timeout)) {
			int err = errno;
			if (pError) {
				*pError = err;
			}
			return SQLITE_IOERR;
		}
	}
#else
	UNUSED_PARAMETER(pError);
#endif
#ifdef SQLITE_TEST
	
	if (sqlite3_hostid_num != 0) {
		pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));
	}
#endif

	return SQLITE_OK;
}


#define PROXY_CONCHVERSION 2   
#define PROXY_HEADERLEN    1   
#define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)
#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)


static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID) {
	proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
	unixFile *conchFile = pCtx->conchFile;
	char tPath[MAXPATHLEN];
	char buf[PROXY_MAXCONCHLEN];
	char *cPath = pCtx->conchFilePath;
	size_t readLen = 0;
	size_t pathLen = 0;
	char errmsg[64] = "";
	int fd = -1;
	int rc = -1;
	UNUSED_PARAMETER(myHostID);

	
	pathLen = strlcpy(tPath, cPath, MAXPATHLEN);
	if (pathLen>MAXPATHLEN || pathLen<6 ||
		(strlcpy(&tPath[pathLen - 5], "break", 6) != 5)) {
		sqlite3_snprintf(sizeof(errmsg), errmsg, "path error (len %d)", (int)pathLen);
		goto end_breaklock;
	}
	
	readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);
	if (readLen<PROXY_PATHINDEX) {
		sqlite3_snprintf(sizeof(errmsg), errmsg, "read error (len %d)", (int)readLen);
		goto end_breaklock;
	}
	
	fd = robust_open(tPath, (O_RDWR | O_CREAT | O_EXCL), 0);
	if (fd<0) {
		sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", errno);
		goto end_breaklock;
	}
	if (osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen) {
		sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", errno);
		goto end_breaklock;
	}
	if (rename(tPath, cPath)) {
		sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", errno);
		goto end_breaklock;
	}
	rc = 0;
	fprintf(stderr, "broke stale lock on %s\n", cPath);
	robust_close(pFile, conchFile->h, __LINE__);
	conchFile->h = fd;
	conchFile->openFlags = O_RDWR | O_CREAT;

end_breaklock:
	if (rc) {
		if (fd >= 0) {
			osUnlink(tPath);
			robust_close(pFile, fd, __LINE__);
		}
		fprintf(stderr, "failed to break stale lock on %s, %s\n", cPath, errmsg);
	}
	return rc;
}


static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType) {
	proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
	unixFile *conchFile = pCtx->conchFile;
	int rc = SQLITE_OK;
	int nTries = 0;
	struct timespec conchModTime;

	memset(&conchModTime, 0, sizeof(conchModTime));
	do {
		rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
		nTries++;
		if (rc == SQLITE_BUSY) {
			
			struct stat buf;
			if (osFstat(conchFile->h, &buf)) {
				storeLastErrno(pFile, errno);
				return SQLITE_IOERR_LOCK;
			}

			if (nTries == 1) {
				conchModTime = buf.st_mtimespec;
				usleep(500000); 
				continue;
			}

			assert(nTries>1);
			if (conchModTime.tv_sec != buf.st_mtimespec.tv_sec ||
				conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec) {
				return SQLITE_BUSY;
			}

			if (nTries == 2) {
				char tBuf[PROXY_MAXCONCHLEN];
				int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);
				if (len<0) {
					storeLastErrno(pFile, errno);
					return SQLITE_IOERR_LOCK;
				}
				if (len>PROXY_PATHINDEX && tBuf[0] == (char)PROXY_CONCHVERSION) {
					
					if (0 != memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN)) {
						return SQLITE_BUSY;
					}
				}
				else {
					
					return SQLITE_BUSY;
				}
				usleep(10000000); 
				continue;
			}

			assert(nTries == 3);
			if (0 == proxyBreakConchLock(pFile, myHostID)) {
				rc = SQLITE_OK;
				if (lockType == EXCLUSIVE_LOCK) {
					rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);
				}
				if (!rc) {
					rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
				}
			}
		}
	} while (rc == SQLITE_BUSY && nTries<3);

	return rc;
}


static int proxyTakeConch(unixFile *pFile) {
	proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;

	if (pCtx->conchHeld != 0) {
		return SQLITE_OK;
	}
	else {
		unixFile *conchFile = pCtx->conchFile;
		uuid_t myHostID;
		int pError = 0;
		char readBuf[PROXY_MAXCONCHLEN];
		char lockPath[MAXPATHLEN];
		char *tempLockPath = NULL;
		int rc = SQLITE_OK;
		int createConch = 0;
		int hostIdMatch = 0;
		int readLen = 0;
		int tryOldLockPath = 0;
		int forceNewLockPath = 0;

		OSTRACE(("TAKECONCH  %d for %s pid=%d\n", conchFile->h,
			(pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),
			osGetpid(0)));

		rc = proxyGetHostID(myHostID, &pError);
		if ((rc & 0xff) == SQLITE_IOERR) {
			storeLastErrno(pFile, pError);
			goto end_takeconch;
		}
		rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);
		if (rc != SQLITE_OK) {
			goto end_takeconch;
		}
		
		readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);
		if (readLen<0) {
			
			storeLastErrno(pFile, conchFile->lastErrno);
			rc = SQLITE_IOERR_READ;
			goto end_takeconch;
		}
		else if (readLen <= (PROXY_HEADERLEN + PROXY_HOSTIDLEN) ||
			readBuf[0] != (char)PROXY_CONCHVERSION) {
			
			createConch = 1;
		}
		
		do { 

			if (!createConch && !forceNewLockPath) {
				hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID,
					PROXY_HOSTIDLEN);
				
				if (!pCtx->lockProxyPath) {
					
					if (hostIdMatch) {
						size_t pathLen = (readLen - PROXY_PATHINDEX);

						if (pathLen >= MAXPATHLEN) {
							pathLen = MAXPATHLEN - 1;
						}
						memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);
						lockPath[pathLen] = 0;
						tempLockPath = lockPath;
						tryOldLockPath = 1;
						
						goto end_takeconch;
					}
				}
				else if (hostIdMatch
					&& !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],
						readLen - PROXY_PATHINDEX)
					) {
					
					goto end_takeconch;
				}
			}

			
			if ((conchFile->openFlags&O_RDWR) == 0) {
				rc = SQLITE_BUSY;
				goto end_takeconch;
			}

			
			if (!pCtx->lockProxyPath) {
				proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);
				tempLockPath = lockPath;
				
			}

			
			futimes(conchFile->h, NULL);
			if (hostIdMatch && !createConch) {
				if (conchFile->pInode && conchFile->pInode->nShared>1) {
					
					rc = SQLITE_BUSY;
				}
				else {
					rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
				}
			}
			else {
				rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
			}
			if (rc == SQLITE_OK) {
				char writeBuffer[PROXY_MAXCONCHLEN];
				int writeSize = 0;

				writeBuffer[0] = (char)PROXY_CONCHVERSION;
				memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);
				if (pCtx->lockProxyPath != NULL) {
					strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,
						MAXPATHLEN);
				}
				else {
					strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);
				}
				writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);
				robust_ftruncate(conchFile->h, writeSize);
				rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);
				full_fsync(conchFile->h, 0, 0);
				
				if (rc == SQLITE_OK && createConch) {
					struct stat buf;
					int err = osFstat(pFile->h, &buf);
					if (err == 0) {
						mode_t cmode = buf.st_mode&(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |
							S_IROTH | S_IWOTH);
						
#ifndef SQLITE_PROXY_DEBUG
						osFchmod(conchFile->h, cmode);
#else
						do {
							rc = osFchmod(conchFile->h, cmode);
						} while (rc == (-1) && errno == EINTR);
						if (rc != 0) {
							int code = errno;
							fprintf(stderr, "fchmod %o FAILED with %d %s\n",
								cmode, code, strerror(code));
						}
						else {
							fprintf(stderr, "fchmod %o SUCCEDED\n", cmode);
						}
					}
					else {
						int code = errno;
						fprintf(stderr, "STAT FAILED[%d] with %d %s\n",
							err, code, strerror(code));
#endif
					}
				}
			}
			conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);

		end_takeconch:
			OSTRACE(("TRANSPROXY: CLOSE  %d\n", pFile->h));
			if (rc == SQLITE_OK && pFile->openFlags) {
				int fd;
				if (pFile->h >= 0) {
					robust_close(pFile, pFile->h, __LINE__);
				}
				pFile->h = -1;
				fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);
				OSTRACE(("TRANSPROXY: OPEN  %d\n", fd));
				if (fd >= 0) {
					pFile->h = fd;
				}
				else {
					rc = SQLITE_CANTOPEN_BKPT; 
				}
			}
			if (rc == SQLITE_OK && !pCtx->lockProxy) {
				char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;
				rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);
				if (rc != SQLITE_OK && rc != SQLITE_NOMEM && tryOldLockPath) {
					
					forceNewLockPath = 1;
					tryOldLockPath = 0;
					continue; 
				}
			}
			if (rc == SQLITE_OK) {
				
				if (tempLockPath) {
					pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);
					if (!pCtx->lockProxyPath) {
						rc = SQLITE_NOMEM_BKPT;
					}
				}
			}
			if (rc == SQLITE_OK) {
				pCtx->conchHeld = 1;

				if (pCtx->lockProxy->pMethod == &afpIoMethods) {
					afpLockingContext *afpCtx;
					afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;
					afpCtx->dbPath = pCtx->lockProxyPath;
				}
			}
			else {
				conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);
			}
			OSTRACE(("TAKECONCH  %d %s\n", conchFile->h,
				rc == SQLITE_OK ? "ok" : "failed"));
			return rc;
		} while (1); 
	}
}


static int proxyReleaseConch(unixFile *pFile) {
	int rc = SQLITE_OK;         
	proxyLockingContext *pCtx;  
	unixFile *conchFile;        

	pCtx = (proxyLockingContext *)pFile->lockingContext;
	conchFile = pCtx->conchFile;
	OSTRACE(("RELEASECONCH  %d for %s pid=%d\n", conchFile->h,
		(pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),
		osGetpid(0)));
	if (pCtx->conchHeld>0) {
		rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);
	}
	pCtx->conchHeld = 0;
	OSTRACE(("RELEASECONCH  %d %s\n", conchFile->h,
		(rc == SQLITE_OK ? "ok" : "failed")));
	return rc;
}


static int proxyCreateConchPathname(char *dbPath, char **pConchPath) {
	int i;                        
	int len = (int)strlen(dbPath); 
	char *conchPath;              

								  
	*pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);
	if (conchPath == 0) {
		return SQLITE_NOMEM_BKPT;
	}
	memcpy(conchPath, dbPath, len + 1);

	
	for (i = (len - 1); i >= 0; i--) {
		if (conchPath[i] == '/') {
			i++;
			break;
		}
	}
	conchPath[i] = '.';
	while (i<len) {
		conchPath[i + 1] = dbPath[i];
		i++;
	}

	
	memcpy(&conchPath[i + 1], "-conch", 7);
	assert((int)strlen(conchPath) == len + 7);

	return SQLITE_OK;
}



static int switchLockProxyPath(unixFile *pFile, const char *path) {
	proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
	char *oldPath = pCtx->lockProxyPath;
	int rc = SQLITE_OK;

	if (pFile->eFileLock != NO_LOCK) {
		return SQLITE_BUSY;
	}

	
	if (!path || path[0] == '\0' || !strcmp(path, ":auto:") ||
		(oldPath && !strncmp(oldPath, path, MAXPATHLEN))) {
		return SQLITE_OK;
	}
	else {
		unixFile *lockProxy = pCtx->lockProxy;
		pCtx->lockProxy = NULL;
		pCtx->conchHeld = 0;
		if (lockProxy != NULL) {
			rc = lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);
			if (rc) return rc;
			sqlite3_free(lockProxy);
		}
		sqlite3_free(oldPath);
		pCtx->lockProxyPath = sqlite3DbStrDup(0, path);
	}

	return rc;
}


static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath) {
#if defined(__APPLE__)
	if (pFile->pMethod == &afpIoMethods) {
		
		assert((int)strlen((char*)pFile->lockingContext) <= MAXPATHLEN);
		strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,
			MAXPATHLEN);
	}
	else
#endif
		if (pFile->pMethod == &dotlockIoMethods) {
			
			int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);
			memcpy(dbPath, (char *)pFile->lockingContext, len + 1);
		}
		else {
			
			assert(strlen((char*)pFile->lockingContext) <= MAXPATHLEN);
			strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);
		}
		return SQLITE_OK;
}


static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
	proxyLockingContext *pCtx;
	char dbPath[MAXPATHLEN + 1];       
	char *lockPath = NULL;
	int rc = SQLITE_OK;

	if (pFile->eFileLock != NO_LOCK) {
		return SQLITE_BUSY;
	}
	proxyGetDbPathForUnixFile(pFile, dbPath);
	if (!path || path[0] == '\0' || !strcmp(path, ":auto:")) {
		lockPath = NULL;
	}
	else {
		lockPath = (char *)path;
	}

	OSTRACE(("TRANSPROXY  %d for %s pid=%d\n", pFile->h,
		(lockPath ? lockPath : ":auto:"), osGetpid(0)));

	pCtx = sqlite3_malloc64(sizeof(*pCtx));
	if (pCtx == 0) {
		return SQLITE_NOMEM_BKPT;
	}
	memset(pCtx, 0, sizeof(*pCtx));

	rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);
	if (rc == SQLITE_OK) {
		rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);
		if (rc == SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0)) {
			
			struct statfs fsInfo;
			struct stat conchInfo;
			int goLockless = 0;

			if (osStat(pCtx->conchFilePath, &conchInfo) == -1) {
				int err = errno;
				if ((err == ENOENT) && (statfs(dbPath, &fsInfo) != -1)) {
					goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;
				}
			}
			if (goLockless) {
				pCtx->conchHeld = -1; 
				rc = SQLITE_OK;
			}
		}
	}
	if (rc == SQLITE_OK && lockPath) {
		pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);
	}

	if (rc == SQLITE_OK) {
		pCtx->dbPath = sqlite3DbStrDup(0, dbPath);
		if (pCtx->dbPath == NULL) {
			rc = SQLITE_NOMEM_BKPT;
		}
	}
	if (rc == SQLITE_OK) {
		
		pCtx->oldLockingContext = pFile->lockingContext;
		pFile->lockingContext = pCtx;
		pCtx->pOldMethod = pFile->pMethod;
		pFile->pMethod = &proxyIoMethods;
	}
	else {
		if (pCtx->conchFile) {
			pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);
			sqlite3_free(pCtx->conchFile);
		}
		sqlite3DbFree(0, pCtx->lockProxyPath);
		sqlite3_free(pCtx->conchFilePath);
		sqlite3_free(pCtx);
	}
	OSTRACE(("TRANSPROXY  %d %s\n", pFile->h,
		(rc == SQLITE_OK ? "ok" : "failed")));
	return rc;
}



static int proxyFileControl(sqlite3_file *id, int op, void *pArg) {
	switch (op) {
	case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
		unixFile *pFile = (unixFile*)id;
		if (pFile->pMethod == &proxyIoMethods) {
			proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
			proxyTakeConch(pFile);
			if (pCtx->lockProxyPath) {
				*(const char **)pArg = pCtx->lockProxyPath;
			}
			else {
				*(const char **)pArg = ":auto: (not held)";
			}
		}
		else {
			*(const char **)pArg = NULL;
		}
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_SET_LOCKPROXYFILE: {
		unixFile *pFile = (unixFile*)id;
		int rc = SQLITE_OK;
		int isProxyStyle = (pFile->pMethod == &proxyIoMethods);
		if (pArg == NULL || (const char *)pArg == 0) {
			if (isProxyStyle) {
				
				rc = SQLITE_ERROR ;
			}
			else {
				
				rc = SQLITE_OK;
			}
		}
		else {
			const char *proxyPath = (const char *)pArg;
			if (isProxyStyle) {
				proxyLockingContext *pCtx =
					(proxyLockingContext*)pFile->lockingContext;
				if (!strcmp(pArg, ":auto:")
					|| (pCtx->lockProxyPath &&
						!strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))
					) {
					rc = SQLITE_OK;
				}
				else {
					rc = switchLockProxyPath(pFile, proxyPath);
				}
			}
			else {
				
				rc = proxyTransformUnixFile(pFile, proxyPath);
			}
		}
		return rc;
	}
	default: {
		assert(0);  
	}
	}
	
	return SQLITE_ERROR;
}





static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {
	unixFile *pFile = (unixFile*)id;
	int rc = proxyTakeConch(pFile);
	if (rc == SQLITE_OK) {
		proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
		if (pCtx->conchHeld>0) {
			unixFile *proxy = pCtx->lockProxy;
			return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);
		}
		else { 
			pResOut = 0;
		}
	}
	return rc;
}


static int proxyLock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	int rc = proxyTakeConch(pFile);
	if (rc == SQLITE_OK) {
		proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
		if (pCtx->conchHeld>0) {
			unixFile *proxy = pCtx->lockProxy;
			rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);
			pFile->eFileLock = proxy->eFileLock;
		}
		else {
			
		}
	}
	return rc;
}



static int proxyUnlock(sqlite3_file *id, int eFileLock) {
	unixFile *pFile = (unixFile*)id;
	int rc = proxyTakeConch(pFile);
	if (rc == SQLITE_OK) {
		proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
		if (pCtx->conchHeld>0) {
			unixFile *proxy = pCtx->lockProxy;
			rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);
			pFile->eFileLock = proxy->eFileLock;
		}
		else {
			
		}
	}
	return rc;
}


static int proxyClose(sqlite3_file *id) {
	if (ALWAYS(id)) {
		unixFile *pFile = (unixFile*)id;
		proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
		unixFile *lockProxy = pCtx->lockProxy;
		unixFile *conchFile = pCtx->conchFile;
		int rc = SQLITE_OK;

		if (lockProxy) {
			rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);
			if (rc) return rc;
			rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);
			if (rc) return rc;
			sqlite3_free(lockProxy);
			pCtx->lockProxy = 0;
		}
		if (conchFile) {
			if (pCtx->conchHeld) {
				rc = proxyReleaseConch(pFile);
				if (rc) return rc;
			}
			rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);
			if (rc) return rc;
			sqlite3_free(conchFile);
		}
		sqlite3DbFree(0, pCtx->lockProxyPath);
		sqlite3_free(pCtx->conchFilePath);
		sqlite3DbFree(0, pCtx->dbPath);
		
		pFile->lockingContext = pCtx->oldLockingContext;
		pFile->pMethod = pCtx->pOldMethod;
		sqlite3_free(pCtx);
		return pFile->pMethod->xClose(id);
	}
	return SQLITE_OK;
}



#endif 



SQLITE_API int sqlite3_os_init(void) {
	
#define UNIXVFS(VFSNAME, FINDER) {                        \
    3,                                        \
    sizeof(unixFile),                         \
    MAX_PATHNAME,                           \
    0,                                           \
    VFSNAME,                                     \
    (void*)&FINDER,                           \
    unixOpen,                                    \
    unixDelete,                                \
    unixAccess,                                \
    unixFullPathname,                    \
    unixDlOpen,                                \
    unixDlError,                              \
    unixDlSym,                                  \
    unixDlClose,                              \
    unixRandomness,                        \
    unixSleep,                                  \
    unixCurrentTime,                      \
    unixGetLastError,                    \
    unixCurrentTimeInt64,            \
    unixSetSystemCall,                  \
    unixGetSystemCall,                  \
    unixNextSystemCall,                \
  }

	
	static sqlite3_vfs aVfs[] = {
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
		UNIXVFS("unix",          autolockIoFinder),
#elif OS_VXWORKS
		UNIXVFS("unix",          vxworksIoFinder),
#else
		UNIXVFS("unix",          posixIoFinder),
#endif
		UNIXVFS("unix-none",     nolockIoFinder),
		UNIXVFS("unix-dotfile",  dotlockIoFinder),
		UNIXVFS("unix-excl",     posixIoFinder),
#if OS_VXWORKS
		UNIXVFS("unix-namedsem", semIoFinder),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS
		UNIXVFS("unix-posix",    posixIoFinder),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
		UNIXVFS("unix-flock",    flockIoFinder),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
		UNIXVFS("unix-afp",      afpIoFinder),
		UNIXVFS("unix-nfs",      nfsIoFinder),
		UNIXVFS("unix-proxy",    proxyIoFinder),
#endif
	};
	unsigned int i;          

							 
	assert(ArraySize(aSyscall) == 28);

	
	for (i = 0; i<(sizeof(aVfs) / sizeof(sqlite3_vfs)); i++) {
		sqlite3_vfs_register(&aVfs[i], i == 0);
	}
	return SQLITE_OK;
}


SQLITE_API int sqlite3_os_end(void) {
	return SQLITE_OK;
}

#endif 





#if SQLITE_OS_WIN               





#ifndef _OS_COMMON_H_
#define _OS_COMMON_H_


#ifdef MEMORY_DEBUG
# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
#endif


#ifdef SQLITE_PERFORMANCE_TRACE





#ifndef SQLITE_HWTIME_H
#define SQLITE_HWTIME_H


#if (defined(__GNUC__) || defined(_MSC_VER)) && \
      (defined(i386) || defined(__i386__) || defined(_M_IX86))

#if defined(__GNUC__)

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned int lo, hi;
	__asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
	return (sqlite_uint64)hi << 32 | lo;
}

#elif defined(_MSC_VER)

__declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void) {
	__asm {
		rdtsc
		ret; return value at EDX : EAX
	}
}

#endif

#elif (defined(__GNUC__) && defined(__x86_64__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long val;
	__asm__ __volatile__("rdtsc" : "=A" (val));
	return val;
}

#elif (defined(__GNUC__) && defined(__ppc__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long long retval;
	unsigned long junk;
	__asm__ __volatile__("\n\
          1:      mftbu   %1\n\
                  mftb    %L0\n\
                  mftbu   %0\n\
                  cmpw    %0,%1\n\
                  bne     1b"
		: "=r" (retval), "=r" (junk));
	return retval;
}

#else

#error Need implementation of sqlite3Hwtime() for your platform.


SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void) { return ((sqlite_uint64)0); }

#endif

#endif 




static sqlite_uint64 g_start;
static sqlite_uint64 g_elapsed;
#define TIMER_START       g_start=sqlite3Hwtime()
#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start
#define TIMER_ELAPSED     g_elapsed
#else
#define TIMER_START
#define TIMER_END
#define TIMER_ELAPSED     ((sqlite_uint64)0)
#endif


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_io_error_hit;
SQLITE_API extern int sqlite3_io_error_hardhit;
SQLITE_API extern int sqlite3_io_error_pending;
SQLITE_API extern int sqlite3_io_error_persist;
SQLITE_API extern int sqlite3_io_error_benign;
SQLITE_API extern int sqlite3_diskfull_pending;
SQLITE_API extern int sqlite3_diskfull;
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)
#define SimulateIOError(CODE)  \
  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \
       || sqlite3_io_error_pending-- == 1 )  \
              { local_ioerr(); CODE; }
static void local_ioerr() {
	IOTRACE(("IOERR\n"));
	sqlite3_io_error_hit++;
	if (!sqlite3_io_error_benign) sqlite3_io_error_hardhit++;
}
#define SimulateDiskfullError(CODE) \
   if( sqlite3_diskfull_pending ){ \
     if( sqlite3_diskfull_pending == 1 ){ \
       local_ioerr(); \
       sqlite3_diskfull = 1; \
       sqlite3_io_error_hit = 1; \
       CODE; \
     }else{ \
       sqlite3_diskfull_pending--; \
     } \
   }
#else
#define SimulateIOErrorBenign(X)
#define SimulateIOError(A)
#define SimulateDiskfullError(A)
#endif 


#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_open_file_count;
#define OpenCounter(X)  sqlite3_open_file_count+=(X)
#else
#define OpenCounter(X)
#endif 

#endif 








#if !SQLITE_OS_WINNT && !defined(SQLITE_OMIT_WAL)
#  error "WAL mode requires support from the Windows NT kernel, compile\
 with SQLITE_OMIT_WAL."
#endif

#if !SQLITE_OS_WINNT && SQLITE_MAX_MMAP_SIZE>0
#  error "Memory mapped files require support from the Windows NT kernel,\
 compile with SQLITE_MAX_MMAP_SIZE=0."
#endif


#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI)
#  define SQLITE_WIN32_HAS_ANSI
#endif


#if (SQLITE_OS_WINCE || SQLITE_OS_WINNT || SQLITE_OS_WINRT) && \
    !defined(SQLITE_WIN32_NO_WIDE)
#  define SQLITE_WIN32_HAS_WIDE
#endif


#if !defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_WIN32_HAS_WIDE)
#  error "At least one of SQLITE_WIN32_HAS_ANSI and SQLITE_WIN32_HAS_WIDE\
 must be defined."
#endif


#ifndef NTDDI_WIN8
#  define NTDDI_WIN8                        0x06020000
#endif

#ifndef NTDDI_WINBLUE
#  define NTDDI_WINBLUE                     0x06030000
#endif

#ifndef NTDDI_WINTHRESHOLD
#  define NTDDI_WINTHRESHOLD                0x06040000
#endif


#ifndef SQLITE_WIN32_GETVERSIONEX
#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINBLUE
#    define SQLITE_WIN32_GETVERSIONEX   0   
#  else
#    define SQLITE_WIN32_GETVERSIONEX   1   
#  endif
#endif


#ifndef SQLITE_WIN32_CREATEFILEMAPPINGA
#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINTHRESHOLD
#    define SQLITE_WIN32_CREATEFILEMAPPINGA   0
#  else
#    define SQLITE_WIN32_CREATEFILEMAPPINGA   1
#  endif
#endif


#ifndef MAX_PATH
#  define MAX_PATH                      (260)
#endif


#ifndef SQLITE_WIN32_MAX_PATH_CHARS
#  define SQLITE_WIN32_MAX_PATH_CHARS   (MAX_PATH)
#endif


#ifndef UNICODE_STRING_MAX_CHARS
#  define UNICODE_STRING_MAX_CHARS      (32767)
#endif


#ifndef SQLITE_WINNT_MAX_PATH_CHARS
#  define SQLITE_WINNT_MAX_PATH_CHARS   (UNICODE_STRING_MAX_CHARS)
#endif


#ifndef SQLITE_WIN32_MAX_PATH_BYTES
#  define SQLITE_WIN32_MAX_PATH_BYTES   (SQLITE_WIN32_MAX_PATH_CHARS*4)
#endif


#ifndef SQLITE_WINNT_MAX_PATH_BYTES
#  define SQLITE_WINNT_MAX_PATH_BYTES   \
                            (sizeof(WCHAR) * SQLITE_WINNT_MAX_PATH_CHARS)
#endif


#ifndef SQLITE_WIN32_MAX_ERRMSG_CHARS
#  define SQLITE_WIN32_MAX_ERRMSG_CHARS (1024)
#endif


#ifndef winIsDirSep
#  define winIsDirSep(a)                (((a) == '/') || ((a) == '\\'))
#endif


#ifndef UNUSED_VARIABLE_VALUE
#  define UNUSED_VARIABLE_VALUE(x)      (void)(x)
#endif


#ifndef winGetDirSep
#  define winGetDirSep()                '\\'
#endif


#if SQLITE_WIN32_FILEMAPPING_API && \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)

#if SQLITE_OS_WINRT
WINBASEAPI HANDLE WINAPI CreateFileMappingFromApp(HANDLE, \
	LPSECURITY_ATTRIBUTES, ULONG, ULONG64, LPCWSTR);

WINBASEAPI LPVOID WINAPI MapViewOfFileFromApp(HANDLE, ULONG, ULONG64, SIZE_T);
#else
#if defined(SQLITE_WIN32_HAS_ANSI)
WINBASEAPI HANDLE WINAPI CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, \
	DWORD, DWORD, DWORD, LPCSTR);
#endif 

#if defined(SQLITE_WIN32_HAS_WIDE)
WINBASEAPI HANDLE WINAPI CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, \
	DWORD, DWORD, DWORD, LPCWSTR);
#endif 

WINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
#endif 



WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T);
WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);
#endif 


#ifndef INVALID_FILE_ATTRIBUTES
# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#endif

#ifndef FILE_FLAG_MASK
# define FILE_FLAG_MASK          (0xFF3C0000)
#endif

#ifndef FILE_ATTRIBUTE_MASK
# define FILE_ATTRIBUTE_MASK     (0x0003FFF7)
#endif

#ifndef SQLITE_OMIT_WAL

typedef struct winShm winShm;           
typedef struct winShmNode winShmNode;   
#endif

										
#if SQLITE_OS_WINCE
typedef struct winceLock {
	int nReaders;       
	BOOL bPending;      
	BOOL bReserved;     
	BOOL bExclusive;    
} winceLock;
#endif


typedef struct winFile winFile;
struct winFile {
	const sqlite3_io_methods *pMethod; 
	sqlite3_vfs *pVfs;      
	HANDLE h;               
	u8 locktype;            
	short sharedLockByte;   
	u8 ctrlFlags;           
	DWORD lastErrno;        
#ifndef SQLITE_OMIT_WAL
	winShm *pShm;           
#endif
	const char *zPath;      
	int szChunk;            
#if SQLITE_OS_WINCE
	LPWSTR zDeleteOnClose;  
	HANDLE hMutex;          
	HANDLE hShared;         
	winceLock local;        
	winceLock *shared;      
#endif
#if SQLITE_MAX_MMAP_SIZE>0
	int nFetchOut;                
	HANDLE hMap;                  
	void *pMapRegion;             
	sqlite3_int64 mmapSize;       
	sqlite3_int64 mmapSizeActual; 
	sqlite3_int64 mmapSizeMax;    
#endif
};


typedef struct winVfsAppData winVfsAppData;
struct winVfsAppData {
	const sqlite3_io_methods *pMethod; 
	void *pAppData;                    
	BOOL bNoLock;                      
};


#define WINFILE_RDONLY          0x02   
#define WINFILE_PERSIST_WAL     0x04   
#define WINFILE_PSOW            0x10   


#ifndef SQLITE_WIN32_DBG_BUF_SIZE
#  define SQLITE_WIN32_DBG_BUF_SIZE   ((int)(4096-sizeof(DWORD)))
#endif


#ifndef SQLITE_WIN32_DATA_DIRECTORY_TYPE
#  define SQLITE_WIN32_DATA_DIRECTORY_TYPE (1)
#endif


#ifndef SQLITE_WIN32_TEMP_DIRECTORY_TYPE
#  define SQLITE_WIN32_TEMP_DIRECTORY_TYPE (2)
#endif


#ifdef SQLITE_WIN32_MALLOC


#ifndef SQLITE_WIN32_HEAP_CREATE
#  define SQLITE_WIN32_HEAP_CREATE    (TRUE)
#endif


#ifndef SQLITE_WIN32_CACHE_SIZE
#  if SQLITE_DEFAULT_CACHE_SIZE>=0
#    define SQLITE_WIN32_CACHE_SIZE (SQLITE_DEFAULT_CACHE_SIZE)
#  else
#    define SQLITE_WIN32_CACHE_SIZE (-(SQLITE_DEFAULT_CACHE_SIZE))
#  endif
#endif


#ifndef SQLITE_WIN32_HEAP_INIT_SIZE
#  define SQLITE_WIN32_HEAP_INIT_SIZE ((SQLITE_WIN32_CACHE_SIZE) * \
                                       (SQLITE_DEFAULT_PAGE_SIZE) + 4194304)
#endif


#ifndef SQLITE_WIN32_HEAP_MAX_SIZE
#  define SQLITE_WIN32_HEAP_MAX_SIZE  (0)
#endif


#ifndef SQLITE_WIN32_HEAP_FLAGS
#  define SQLITE_WIN32_HEAP_FLAGS     (0)
#endif



typedef struct winMemData winMemData;
struct winMemData {
#ifndef NDEBUG
	u32 magic1;   
#endif
	HANDLE hHeap; 
	BOOL bOwned;  
#ifndef NDEBUG
	u32 magic2;   
#endif
};

#ifndef NDEBUG
#define WINMEM_MAGIC1     0x42b2830b
#define WINMEM_MAGIC2     0xbd4d7cf4
#endif

static struct winMemData win_mem_data = {
#ifndef NDEBUG
	WINMEM_MAGIC1,
#endif
	NULL, FALSE
#ifndef NDEBUG
	,WINMEM_MAGIC2
#endif
};

#ifndef NDEBUG
#define winMemAssertMagic1() assert( win_mem_data.magic1==WINMEM_MAGIC1 )
#define winMemAssertMagic2() assert( win_mem_data.magic2==WINMEM_MAGIC2 )
#define winMemAssertMagic()  winMemAssertMagic1(); winMemAssertMagic2();
#else
#define winMemAssertMagic()
#endif

#define winMemGetDataPtr()  &win_mem_data
#define winMemGetHeap()     win_mem_data.hHeap
#define winMemGetOwned()    win_mem_data.bOwned

static void *winMemMalloc(int nBytes);
static void winMemFree(void *pPrior);
static void *winMemRealloc(void *pPrior, int nBytes);
static int winMemSize(void *p);
static int winMemRoundup(int n);
static int winMemInit(void *pAppData);
static void winMemShutdown(void *pAppData);

SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void);
#endif 


#ifdef SQLITE_TEST
SQLITE_API LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#else
static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#endif

#ifndef SYSCALL
#  define SYSCALL sqlite3_syscall_ptr
#endif



#if SQLITE_OS_WINCE || SQLITE_OS_WINRT
#  define osAreFileApisANSI()       1
#endif


static struct win_syscall {
	const char *zName;            
	sqlite3_syscall_ptr pCurrent; 
	sqlite3_syscall_ptr pDefault; 
} aSyscall[] = {
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
	{ "AreFileApisANSI",         (SYSCALL)AreFileApisANSI,         0 },
#else
	{ "AreFileApisANSI",         (SYSCALL)0,                       0 },
#endif

#ifndef osAreFileApisANSI
#define osAreFileApisANSI ((BOOL(WINAPI*)(VOID))aSyscall[0].pCurrent)
#endif

#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)
	{ "CharLowerW",              (SYSCALL)CharLowerW,              0 },
#else
	{ "CharLowerW",              (SYSCALL)0,                       0 },
#endif

#define osCharLowerW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[1].pCurrent)

#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)
	{ "CharUpperW",              (SYSCALL)CharUpperW,              0 },
#else
	{ "CharUpperW",              (SYSCALL)0,                       0 },
#endif

#define osCharUpperW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[2].pCurrent)

	{ "CloseHandle",             (SYSCALL)CloseHandle,             0 },

#define osCloseHandle ((BOOL(WINAPI*)(HANDLE))aSyscall[3].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
	{ "CreateFileA",             (SYSCALL)CreateFileA,             0 },
#else
	{ "CreateFileA",             (SYSCALL)0,                       0 },
#endif

#define osCreateFileA ((HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD, \
        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[4].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
{
	"CreateFileW",             (SYSCALL)CreateFileW,             0
},
#else
{ "CreateFileW",             (SYSCALL)0,                       0 },
#endif

#define osCreateFileW ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD, \
        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[5].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_ANSI) && \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) && \
        SQLITE_WIN32_CREATEFILEMAPPINGA
{ "CreateFileMappingA",      (SYSCALL)CreateFileMappingA,      0 },
#else
{ "CreateFileMappingA",      (SYSCALL)0,                       0 },
#endif

#define osCreateFileMappingA ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \
        DWORD,DWORD,DWORD,LPCSTR))aSyscall[6].pCurrent)

#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))
{ "CreateFileMappingW",      (SYSCALL)CreateFileMappingW,      0 },
#else
{ "CreateFileMappingW",      (SYSCALL)0,                       0 },
#endif

#define osCreateFileMappingW ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \
        DWORD,DWORD,DWORD,LPCWSTR))aSyscall[7].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
{
	"CreateMutexW",            (SYSCALL)CreateMutexW,            0
},
#else
{ "CreateMutexW",            (SYSCALL)0,                       0 },
#endif

#define osCreateMutexW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,BOOL, \
        LPCWSTR))aSyscall[8].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
{
	"DeleteFileA",             (SYSCALL)DeleteFileA,             0
},
#else
{ "DeleteFileA",             (SYSCALL)0,                       0 },
#endif

#define osDeleteFileA ((BOOL(WINAPI*)(LPCSTR))aSyscall[9].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
{ "DeleteFileW",             (SYSCALL)DeleteFileW,             0 },
#else
{ "DeleteFileW",             (SYSCALL)0,                       0 },
#endif

#define osDeleteFileW ((BOOL(WINAPI*)(LPCWSTR))aSyscall[10].pCurrent)

#if SQLITE_OS_WINCE
{ "FileTimeToLocalFileTime", (SYSCALL)FileTimeToLocalFileTime, 0 },
#else
{ "FileTimeToLocalFileTime", (SYSCALL)0,                       0 },
#endif

#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*, \
        LPFILETIME))aSyscall[11].pCurrent)

#if SQLITE_OS_WINCE
{
	"FileTimeToSystemTime",    (SYSCALL)FileTimeToSystemTime,    0
},
#else
{ "FileTimeToSystemTime",    (SYSCALL)0,                       0 },
#endif

#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*, \
        LPSYSTEMTIME))aSyscall[12].pCurrent)

{
	"FlushFileBuffers",        (SYSCALL)FlushFileBuffers,        0
},

#define osFlushFileBuffers ((BOOL(WINAPI*)(HANDLE))aSyscall[13].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
{ "FormatMessageA",          (SYSCALL)FormatMessageA,          0 },
#else
{ "FormatMessageA",          (SYSCALL)0,                       0 },
#endif

#define osFormatMessageA ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPSTR, \
        DWORD,va_list*))aSyscall[14].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
	{
		"FormatMessageW",          (SYSCALL)FormatMessageW,          0
	},
#else
	{ "FormatMessageW",          (SYSCALL)0,                       0 },
#endif

#define osFormatMessageW ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPWSTR, \
        DWORD,va_list*))aSyscall[15].pCurrent)

#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
	{
		"FreeLibrary",             (SYSCALL)FreeLibrary,             0
	},
#else
	{ "FreeLibrary",             (SYSCALL)0,                       0 },
#endif

#define osFreeLibrary ((BOOL(WINAPI*)(HMODULE))aSyscall[16].pCurrent)

	{ "GetCurrentProcessId",     (SYSCALL)GetCurrentProcessId,     0 },

#define osGetCurrentProcessId ((DWORD(WINAPI*)(VOID))aSyscall[17].pCurrent)

#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)
	{ "GetDiskFreeSpaceA",       (SYSCALL)GetDiskFreeSpaceA,       0 },
#else
	{ "GetDiskFreeSpaceA",       (SYSCALL)0,                       0 },
#endif

#define osGetDiskFreeSpaceA ((BOOL(WINAPI*)(LPCSTR,LPDWORD,LPDWORD,LPDWORD, \
        LPDWORD))aSyscall[18].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
	{
		"GetDiskFreeSpaceW",       (SYSCALL)GetDiskFreeSpaceW,       0
	},
#else
	{ "GetDiskFreeSpaceW",       (SYSCALL)0,                       0 },
#endif

#define osGetDiskFreeSpaceW ((BOOL(WINAPI*)(LPCWSTR,LPDWORD,LPDWORD,LPDWORD, \
        LPDWORD))aSyscall[19].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
	{
		"GetFileAttributesA",      (SYSCALL)GetFileAttributesA,      0
	},
#else
	{ "GetFileAttributesA",      (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesA ((DWORD(WINAPI*)(LPCSTR))aSyscall[20].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
	{ "GetFileAttributesW",      (SYSCALL)GetFileAttributesW,      0 },
#else
	{ "GetFileAttributesW",      (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesW ((DWORD(WINAPI*)(LPCWSTR))aSyscall[21].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
	{ "GetFileAttributesExW",    (SYSCALL)GetFileAttributesExW,    0 },
#else
	{ "GetFileAttributesExW",    (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesExW ((BOOL(WINAPI*)(LPCWSTR,GET_FILEEX_INFO_LEVELS, \
        LPVOID))aSyscall[22].pCurrent)

#if !SQLITE_OS_WINRT
	{
		"GetFileSize",             (SYSCALL)GetFileSize,             0
	},
#else
	{ "GetFileSize",             (SYSCALL)0,                       0 },
#endif

#define osGetFileSize ((DWORD(WINAPI*)(HANDLE,LPDWORD))aSyscall[23].pCurrent)

#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)
	{ "GetFullPathNameA",        (SYSCALL)GetFullPathNameA,        0 },
#else
	{ "GetFullPathNameA",        (SYSCALL)0,                       0 },
#endif

#define osGetFullPathNameA ((DWORD(WINAPI*)(LPCSTR,DWORD,LPSTR, \
        LPSTR*))aSyscall[24].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
	{
		"GetFullPathNameW",        (SYSCALL)GetFullPathNameW,        0
	},
#else
	{ "GetFullPathNameW",        (SYSCALL)0,                       0 },
#endif

#define osGetFullPathNameW ((DWORD(WINAPI*)(LPCWSTR,DWORD,LPWSTR, \
        LPWSTR*))aSyscall[25].pCurrent)

	{
		"GetLastError",            (SYSCALL)GetLastError,            0
	},

#define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent)

#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
#if SQLITE_OS_WINCE
		
	{ "GetProcAddressA",         (SYSCALL)GetProcAddressA,         0 },
#else
		
	{ "GetProcAddressA",         (SYSCALL)GetProcAddress,          0 },
#endif
#else
	{ "GetProcAddressA",         (SYSCALL)0,                       0 },
#endif

#define osGetProcAddressA ((FARPROC(WINAPI*)(HMODULE, \
        LPCSTR))aSyscall[27].pCurrent)

#if !SQLITE_OS_WINRT
		{
			"GetSystemInfo",           (SYSCALL)GetSystemInfo,           0
		},
#else
		{ "GetSystemInfo",           (SYSCALL)0,                       0 },
#endif

#define osGetSystemInfo ((VOID(WINAPI*)(LPSYSTEM_INFO))aSyscall[28].pCurrent)

		{ "GetSystemTime",           (SYSCALL)GetSystemTime,           0 },

#define osGetSystemTime ((VOID(WINAPI*)(LPSYSTEMTIME))aSyscall[29].pCurrent)

#if !SQLITE_OS_WINCE
		{ "GetSystemTimeAsFileTime", (SYSCALL)GetSystemTimeAsFileTime, 0 },
#else
		{ "GetSystemTimeAsFileTime", (SYSCALL)0,                       0 },
#endif

#define osGetSystemTimeAsFileTime ((VOID(WINAPI*)( \
        LPFILETIME))aSyscall[30].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
		{
			"GetTempPathA",            (SYSCALL)GetTempPathA,            0
		},
#else
		{ "GetTempPathA",            (SYSCALL)0,                       0 },
#endif

#define osGetTempPathA ((DWORD(WINAPI*)(DWORD,LPSTR))aSyscall[31].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
		{ "GetTempPathW",            (SYSCALL)GetTempPathW,            0 },
#else
		{ "GetTempPathW",            (SYSCALL)0,                       0 },
#endif

#define osGetTempPathW ((DWORD(WINAPI*)(DWORD,LPWSTR))aSyscall[32].pCurrent)

#if !SQLITE_OS_WINRT
		{ "GetTickCount",            (SYSCALL)GetTickCount,            0 },
#else
		{ "GetTickCount",            (SYSCALL)0,                       0 },
#endif

#define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_GETVERSIONEX
		{ "GetVersionExA",           (SYSCALL)GetVersionExA,           0 },
#else
		{ "GetVersionExA",           (SYSCALL)0,                       0 },
#endif

#define osGetVersionExA ((BOOL(WINAPI*)( \
        LPOSVERSIONINFOA))aSyscall[34].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \
        SQLITE_WIN32_GETVERSIONEX
		{
			"GetVersionExW",           (SYSCALL)GetVersionExW,           0
		},
#else
		{ "GetVersionExW",           (SYSCALL)0,                       0 },
#endif

#define osGetVersionExW ((BOOL(WINAPI*)( \
        LPOSVERSIONINFOW))aSyscall[35].pCurrent)

		{
			"HeapAlloc",               (SYSCALL)HeapAlloc,               0
		},

#define osHeapAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD, \
        SIZE_T))aSyscall[36].pCurrent)

#if !SQLITE_OS_WINRT
		{
			"HeapCreate",              (SYSCALL)HeapCreate,              0
		},
#else
		{ "HeapCreate",              (SYSCALL)0,                       0 },
#endif

#define osHeapCreate ((HANDLE(WINAPI*)(DWORD,SIZE_T, \
        SIZE_T))aSyscall[37].pCurrent)

#if !SQLITE_OS_WINRT
			{
				"HeapDestroy",             (SYSCALL)HeapDestroy,             0
			},
#else
			{ "HeapDestroy",             (SYSCALL)0,                       0 },
#endif

#define osHeapDestroy ((BOOL(WINAPI*)(HANDLE))aSyscall[38].pCurrent)

			{ "HeapFree",                (SYSCALL)HeapFree,                0 },

#define osHeapFree ((BOOL(WINAPI*)(HANDLE,DWORD,LPVOID))aSyscall[39].pCurrent)

			{ "HeapReAlloc",             (SYSCALL)HeapReAlloc,             0 },

#define osHeapReAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,LPVOID, \
        SIZE_T))aSyscall[40].pCurrent)

			{
				"HeapSize",                (SYSCALL)HeapSize,                0
			},

#define osHeapSize ((SIZE_T(WINAPI*)(HANDLE,DWORD, \
        LPCVOID))aSyscall[41].pCurrent)

#if !SQLITE_OS_WINRT
			{
				"HeapValidate",            (SYSCALL)HeapValidate,            0
			},
#else
			{ "HeapValidate",            (SYSCALL)0,                       0 },
#endif

#define osHeapValidate ((BOOL(WINAPI*)(HANDLE,DWORD, \
        LPCVOID))aSyscall[42].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
				{
					"HeapCompact",             (SYSCALL)HeapCompact,             0
				},
#else
				{ "HeapCompact",             (SYSCALL)0,                       0 },
#endif

#define osHeapCompact ((UINT(WINAPI*)(HANDLE,DWORD))aSyscall[43].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
				{ "LoadLibraryA",            (SYSCALL)LoadLibraryA,            0 },
#else
				{ "LoadLibraryA",            (SYSCALL)0,                       0 },
#endif

#define osLoadLibraryA ((HMODULE(WINAPI*)(LPCSTR))aSyscall[44].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \
        !defined(SQLITE_OMIT_LOAD_EXTENSION)
				{
					"LoadLibraryW",            (SYSCALL)LoadLibraryW,            0
				},
#else
				{ "LoadLibraryW",            (SYSCALL)0,                       0 },
#endif

#define osLoadLibraryW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[45].pCurrent)

#if !SQLITE_OS_WINRT
				{ "LocalFree",               (SYSCALL)LocalFree,               0 },
#else
				{ "LocalFree",               (SYSCALL)0,                       0 },
#endif

#define osLocalFree ((HLOCAL(WINAPI*)(HLOCAL))aSyscall[46].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
				{ "LockFile",                (SYSCALL)LockFile,                0 },
#else
				{ "LockFile",                (SYSCALL)0,                       0 },
#endif

#ifndef osLockFile
#define osLockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        DWORD))aSyscall[47].pCurrent)
#endif

#if !SQLITE_OS_WINCE
				{
					"LockFileEx",              (SYSCALL)LockFileEx,              0
				},
#else
				{ "LockFileEx",              (SYSCALL)0,                       0 },
#endif

#ifndef osLockFileEx
#define osLockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,DWORD, \
        LPOVERLAPPED))aSyscall[48].pCurrent)
#endif

#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))
				{ "MapViewOfFile",           (SYSCALL)MapViewOfFile,           0 },
#else
				{ "MapViewOfFile",           (SYSCALL)0,                       0 },
#endif

#define osMapViewOfFile ((LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        SIZE_T))aSyscall[49].pCurrent)

				{
					"MultiByteToWideChar",     (SYSCALL)MultiByteToWideChar,     0
				},

#define osMultiByteToWideChar ((int(WINAPI*)(UINT,DWORD,LPCSTR,int,LPWSTR, \
        int))aSyscall[50].pCurrent)

				{
					"QueryPerformanceCounter", (SYSCALL)QueryPerformanceCounter, 0
				},

#define osQueryPerformanceCounter ((BOOL(WINAPI*)( \
        LARGE_INTEGER*))aSyscall[51].pCurrent)

					{
						"ReadFile",                (SYSCALL)ReadFile,                0
					},

#define osReadFile ((BOOL(WINAPI*)(HANDLE,LPVOID,DWORD,LPDWORD, \
        LPOVERLAPPED))aSyscall[52].pCurrent)

					{
						"SetEndOfFile",            (SYSCALL)SetEndOfFile,            0
					},

#define osSetEndOfFile ((BOOL(WINAPI*)(HANDLE))aSyscall[53].pCurrent)

#if !SQLITE_OS_WINRT
					{ "SetFilePointer",          (SYSCALL)SetFilePointer,          0 },
#else
					{ "SetFilePointer",          (SYSCALL)0,                       0 },
#endif

#define osSetFilePointer ((DWORD(WINAPI*)(HANDLE,LONG,PLONG, \
        DWORD))aSyscall[54].pCurrent)

#if !SQLITE_OS_WINRT
						{
							"Sleep",                   (SYSCALL)Sleep,                   0
						},
#else
						{ "Sleep",                   (SYSCALL)0,                       0 },
#endif

#define osSleep ((VOID(WINAPI*)(DWORD))aSyscall[55].pCurrent)

						{ "SystemTimeToFileTime",    (SYSCALL)SystemTimeToFileTime,    0 },

#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*, \
        LPFILETIME))aSyscall[56].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
						{
							"UnlockFile",              (SYSCALL)UnlockFile,              0
						},
#else
						{ "UnlockFile",              (SYSCALL)0,                       0 },
#endif

#ifndef osUnlockFile
#define osUnlockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        DWORD))aSyscall[57].pCurrent)
#endif

#if !SQLITE_OS_WINCE
						{
							"UnlockFileEx",            (SYSCALL)UnlockFileEx,            0
						},
#else
						{ "UnlockFileEx",            (SYSCALL)0,                       0 },
#endif

#define osUnlockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        LPOVERLAPPED))aSyscall[58].pCurrent)

#if SQLITE_OS_WINCE || !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
						{
							"UnmapViewOfFile",         (SYSCALL)UnmapViewOfFile,         0
						},
#else
						{ "UnmapViewOfFile",         (SYSCALL)0,                       0 },
#endif

#define osUnmapViewOfFile ((BOOL(WINAPI*)(LPCVOID))aSyscall[59].pCurrent)

						{ "WideCharToMultiByte",     (SYSCALL)WideCharToMultiByte,     0 },

#define osWideCharToMultiByte ((int(WINAPI*)(UINT,DWORD,LPCWSTR,int,LPSTR,int, \
        LPCSTR,LPBOOL))aSyscall[60].pCurrent)

						{
							"WriteFile",               (SYSCALL)WriteFile,               0
						},

#define osWriteFile ((BOOL(WINAPI*)(HANDLE,LPCVOID,DWORD,LPDWORD, \
        LPOVERLAPPED))aSyscall[61].pCurrent)

#if SQLITE_OS_WINRT
						{
							"CreateEventExW",          (SYSCALL)CreateEventExW,          0
						},
#else
						{ "CreateEventExW",          (SYSCALL)0,                       0 },
#endif

#define osCreateEventExW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,LPCWSTR, \
        DWORD,DWORD))aSyscall[62].pCurrent)

#if !SQLITE_OS_WINRT
							{
								"WaitForSingleObject",     (SYSCALL)WaitForSingleObject,     0
							},
#else
							{ "WaitForSingleObject",     (SYSCALL)0,                       0 },
#endif

#define osWaitForSingleObject ((DWORD(WINAPI*)(HANDLE, \
        DWORD))aSyscall[63].pCurrent)

#if !SQLITE_OS_WINCE
							{
								"WaitForSingleObjectEx",   (SYSCALL)WaitForSingleObjectEx,   0
							},
#else
							{ "WaitForSingleObjectEx",   (SYSCALL)0,                       0 },
#endif

#define osWaitForSingleObjectEx ((DWORD(WINAPI*)(HANDLE,DWORD, \
        BOOL))aSyscall[64].pCurrent)

#if SQLITE_OS_WINRT
							{
								"SetFilePointerEx",        (SYSCALL)SetFilePointerEx,        0
							},
#else
							{ "SetFilePointerEx",        (SYSCALL)0,                       0 },
#endif

#define osSetFilePointerEx ((BOOL(WINAPI*)(HANDLE,LARGE_INTEGER, \
        PLARGE_INTEGER,DWORD))aSyscall[65].pCurrent)

#if SQLITE_OS_WINRT
							{
								"GetFileInformationByHandleEx", (SYSCALL)GetFileInformationByHandleEx, 0
							},
#else
							{ "GetFileInformationByHandleEx", (SYSCALL)0,                  0 },
#endif

#define osGetFileInformationByHandleEx ((BOOL(WINAPI*)(HANDLE, \
        FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD))aSyscall[66].pCurrent)

#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
							{
								"MapViewOfFileFromApp",    (SYSCALL)MapViewOfFileFromApp,    0
							},
#else
							{ "MapViewOfFileFromApp",    (SYSCALL)0,                       0 },
#endif

#define osMapViewOfFileFromApp ((LPVOID(WINAPI*)(HANDLE,ULONG,ULONG64, \
        SIZE_T))aSyscall[67].pCurrent)

#if SQLITE_OS_WINRT
							{
								"CreateFile2",             (SYSCALL)CreateFile2,             0
							},
#else
							{ "CreateFile2",             (SYSCALL)0,                       0 },
#endif

#define osCreateFile2 ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,DWORD, \
        LPCREATEFILE2_EXTENDED_PARAMETERS))aSyscall[68].pCurrent)

#if SQLITE_OS_WINRT && !defined(SQLITE_OMIT_LOAD_EXTENSION)
							{
								"LoadPackagedLibrary",     (SYSCALL)LoadPackagedLibrary,     0
							},
#else
							{ "LoadPackagedLibrary",     (SYSCALL)0,                       0 },
#endif

#define osLoadPackagedLibrary ((HMODULE(WINAPI*)(LPCWSTR, \
        DWORD))aSyscall[69].pCurrent)

#if SQLITE_OS_WINRT
							{
								"GetTickCount64",          (SYSCALL)GetTickCount64,          0
							},
#else
							{ "GetTickCount64",          (SYSCALL)0,                       0 },
#endif

#define osGetTickCount64 ((ULONGLONG(WINAPI*)(VOID))aSyscall[70].pCurrent)

#if SQLITE_OS_WINRT
							{ "GetNativeSystemInfo",     (SYSCALL)GetNativeSystemInfo,     0 },
#else
							{ "GetNativeSystemInfo",     (SYSCALL)0,                       0 },
#endif

#define osGetNativeSystemInfo ((VOID(WINAPI*)( \
        LPSYSTEM_INFO))aSyscall[71].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
							{
								"OutputDebugStringA",      (SYSCALL)OutputDebugStringA,      0
							},
#else
							{ "OutputDebugStringA",      (SYSCALL)0,                       0 },
#endif

#define osOutputDebugStringA ((VOID(WINAPI*)(LPCSTR))aSyscall[72].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
							{ "OutputDebugStringW",      (SYSCALL)OutputDebugStringW,      0 },
#else
							{ "OutputDebugStringW",      (SYSCALL)0,                       0 },
#endif

#define osOutputDebugStringW ((VOID(WINAPI*)(LPCWSTR))aSyscall[73].pCurrent)

							{ "GetProcessHeap",          (SYSCALL)GetProcessHeap,          0 },

#define osGetProcessHeap ((HANDLE(WINAPI*)(VOID))aSyscall[74].pCurrent)

#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
							{ "CreateFileMappingFromApp", (SYSCALL)CreateFileMappingFromApp, 0 },
#else
							{ "CreateFileMappingFromApp", (SYSCALL)0,                      0 },
#endif

#define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE, \
        LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent)

								
#if defined(InterlockedCompareExchange)
							{
								"InterlockedCompareExchange", (SYSCALL)0,                    0
							},

#define osInterlockedCompareExchange InterlockedCompareExchange
#else
							{ "InterlockedCompareExchange", (SYSCALL)InterlockedCompareExchange, 0 },

#define osInterlockedCompareExchange ((LONG(WINAPI*)(LONG \
        SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)
#endif 

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
							{
								"UuidCreate",               (SYSCALL)UuidCreate,             0
							},
#else
							{ "UuidCreate",               (SYSCALL)0,                      0 },
#endif

#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
							{ "UuidCreateSequential",     (SYSCALL)UuidCreateSequential,   0 },
#else
							{ "UuidCreateSequential",     (SYSCALL)0,                      0 },
#endif

#define osUuidCreateSequential \
        ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent)

#if !defined(SQLITE_NO_SYNC) && SQLITE_MAX_MMAP_SIZE>0
							{
								"FlushViewOfFile",          (SYSCALL)FlushViewOfFile,        0
							},
#else
							{ "FlushViewOfFile",          (SYSCALL)0,                      0 },
#endif

#define osFlushViewOfFile \
        ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent)

}; 

   
static int winSetSystemCall(
	sqlite3_vfs *pNotUsed,        
	const char *zName,            
	sqlite3_syscall_ptr pNewFunc  
) {
	unsigned int i;
	int rc = SQLITE_NOTFOUND;

	UNUSED_PARAMETER(pNotUsed);
	if (zName == 0) {
		
		rc = SQLITE_OK;
		for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
			if (aSyscall[i].pDefault) {
				aSyscall[i].pCurrent = aSyscall[i].pDefault;
			}
		}
	}
	else {
		
		for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
			if (strcmp(zName, aSyscall[i].zName) == 0) {
				if (aSyscall[i].pDefault == 0) {
					aSyscall[i].pDefault = aSyscall[i].pCurrent;
				}
				rc = SQLITE_OK;
				if (pNewFunc == 0) pNewFunc = aSyscall[i].pDefault;
				aSyscall[i].pCurrent = pNewFunc;
				break;
			}
		}
	}
	return rc;
}


static sqlite3_syscall_ptr winGetSystemCall(
	sqlite3_vfs *pNotUsed,
	const char *zName
) {
	unsigned int i;

	UNUSED_PARAMETER(pNotUsed);
	for (i = 0; i<sizeof(aSyscall) / sizeof(aSyscall[0]); i++) {
		if (strcmp(zName, aSyscall[i].zName) == 0) return aSyscall[i].pCurrent;
	}
	return 0;
}


static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName) {
	int i = -1;

	UNUSED_PARAMETER(p);
	if (zName) {
		for (i = 0; i<ArraySize(aSyscall) - 1; i++) {
			if (strcmp(zName, aSyscall[i].zName) == 0) break;
		}
	}
	for (i++; i<ArraySize(aSyscall); i++) {
		if (aSyscall[i].pCurrent != 0) return aSyscall[i].zName;
	}
	return 0;
}

#ifdef SQLITE_WIN32_MALLOC

SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest) {
	int rc = SQLITE_OK;
	UINT nLargest = 0;
	HANDLE hHeap;

	winMemAssertMagic();
	hHeap = winMemGetHeap();
	assert(hHeap != 0);
	assert(hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL));
#endif
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
	if ((nLargest = osHeapCompact(hHeap, SQLITE_WIN32_HEAP_FLAGS)) == 0) {
		DWORD lastErrno = osGetLastError();
		if (lastErrno == NO_ERROR) {
			sqlite3_log(SQLITE_NOMEM, "failed to HeapCompact (no space), heap=%p",
				(void*)hHeap);
			rc = SQLITE_NOMEM_BKPT;
		}
		else {
			sqlite3_log(SQLITE_ERROR, "failed to HeapCompact (%lu), heap=%p",
				osGetLastError(), (void*)hHeap);
			rc = SQLITE_ERROR;
		}
	}
#else
	sqlite3_log(SQLITE_NOTFOUND, "failed to HeapCompact, heap=%p",
		(void*)hHeap);
	rc = SQLITE_NOTFOUND;
#endif
	if (pnLargest) *pnLargest = nLargest;
	return rc;
}


SQLITE_API int sqlite3_win32_reset_heap() {
	int rc;
	MUTEX_LOGIC(sqlite3_mutex *pMaster; ) 
		MUTEX_LOGIC(sqlite3_mutex *pMem; )    
		MUTEX_LOGIC(pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )
		MUTEX_LOGIC(pMem = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); )
		sqlite3_mutex_enter(pMaster);
	sqlite3_mutex_enter(pMem);
	winMemAssertMagic();
	if (winMemGetHeap() != NULL && winMemGetOwned() && sqlite3_memory_used() == 0) {
		
		assert(winMemGetHeap() != NULL);
		assert(winMemGetOwned());
		assert(sqlite3_memory_used() == 0);
		winMemShutdown(winMemGetDataPtr());
		assert(winMemGetHeap() == NULL);
		assert(!winMemGetOwned());
		assert(sqlite3_memory_used() == 0);
		rc = winMemInit(winMemGetDataPtr());
		assert(rc != SQLITE_OK || winMemGetHeap() != NULL);
		assert(rc != SQLITE_OK || winMemGetOwned());
		assert(rc != SQLITE_OK || sqlite3_memory_used() == 0);
	}
	else {
		
		rc = SQLITE_BUSY;
	}
	sqlite3_mutex_leave(pMem);
	sqlite3_mutex_leave(pMaster);
	return rc;
}
#endif 



SQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf) {
	char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];
	int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1)); 
	if (nMin<-1) nMin = -1; 
	assert(nMin == -1 || nMin == 0 || nMin<SQLITE_WIN32_DBG_BUF_SIZE);
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zBuf) {
		(void)SQLITE_MISUSE_BKPT;
		return;
	}
#endif
#if defined(SQLITE_WIN32_HAS_ANSI)
	if (nMin>0) {
		memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
		memcpy(zDbgBuf, zBuf, nMin);
		osOutputDebugStringA(zDbgBuf);
	}
	else {
		osOutputDebugStringA(zBuf);
	}
#elif defined(SQLITE_WIN32_HAS_WIDE)
	memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
	if (osMultiByteToWideChar(
		osAreFileApisANSI() ? CP_ACP : CP_OEMCP, 0, zBuf,
		nMin, (LPWSTR)zDbgBuf, SQLITE_WIN32_DBG_BUF_SIZE / sizeof(WCHAR)) <= 0) {
		return;
	}
	osOutputDebugStringW((LPCWSTR)zDbgBuf);
#else
	if (nMin>0) {
		memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
		memcpy(zDbgBuf, zBuf, nMin);
		fprintf(stderr, "%s", zDbgBuf);
	}
	else {
		fprintf(stderr, "%s", zBuf);
	}
#endif
}


#if SQLITE_OS_WINRT
static HANDLE sleepObj = NULL;
#endif

SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds) {
#if SQLITE_OS_WINRT
	if (sleepObj == NULL) {
		sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,
			SYNCHRONIZE);
	}
	assert(sleepObj != NULL);
	osWaitForSingleObjectEx(sleepObj, milliseconds, FALSE);
#else
	osSleep(milliseconds);
#endif
}

#if SQLITE_MAX_WORKER_THREADS>0 && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \
        SQLITE_THREADSAFE>0
SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject) {
	DWORD rc;
	while ((rc = osWaitForSingleObjectEx(hObject, INFINITE,
		TRUE)) == WAIT_IO_COMPLETION) {
	}
	return rc;
}
#endif



#if !SQLITE_WIN32_GETVERSIONEX
# define osIsNT()  (1)
#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)
# define osIsNT()  (1)
#elif !defined(SQLITE_WIN32_HAS_WIDE)
# define osIsNT()  (0)
#else
# define osIsNT()  ((sqlite3_os_type==2) || sqlite3_win32_is_nt())
#endif


SQLITE_API int sqlite3_win32_is_nt(void) {
#if SQLITE_OS_WINRT
	
	return 1;
#elif SQLITE_WIN32_GETVERSIONEX
	if (osInterlockedCompareExchange(&sqlite3_os_type, 0, 0) == 0) {
#if defined(SQLITE_WIN32_HAS_ANSI)
		OSVERSIONINFOA sInfo;
		sInfo.dwOSVersionInfoSize = sizeof(sInfo);
		osGetVersionExA(&sInfo);
		osInterlockedCompareExchange(&sqlite3_os_type,
			(sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#elif defined(SQLITE_WIN32_HAS_WIDE)
		OSVERSIONINFOW sInfo;
		sInfo.dwOSVersionInfoSize = sizeof(sInfo);
		osGetVersionExW(&sInfo);
		osInterlockedCompareExchange(&sqlite3_os_type,
			(sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#endif
	}
	return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2) == 2;
#elif SQLITE_TEST
	return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2) == 2;
#else
	
	return 1;
#endif
}

#ifdef SQLITE_WIN32_MALLOC

static void *winMemMalloc(int nBytes) {
	HANDLE hHeap;
	void *p;

	winMemAssertMagic();
	hHeap = winMemGetHeap();
	assert(hHeap != 0);
	assert(hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL));
#endif
	assert(nBytes >= 0);
	p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);
	if (!p) {
		sqlite3_log(SQLITE_NOMEM, "failed to HeapAlloc %u bytes (%lu), heap=%p",
			nBytes, osGetLastError(), (void*)hHeap);
	}
	return p;
}


static void winMemFree(void *pPrior) {
	HANDLE hHeap;

	winMemAssertMagic();
	hHeap = winMemGetHeap();
	assert(hHeap != 0);
	assert(hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior));
#endif
	if (!pPrior) return; 
	if (!osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior)) {
		sqlite3_log(SQLITE_NOMEM, "failed to HeapFree block %p (%lu), heap=%p",
			pPrior, osGetLastError(), (void*)hHeap);
	}
}


static void *winMemRealloc(void *pPrior, int nBytes) {
	HANDLE hHeap;
	void *p;

	winMemAssertMagic();
	hHeap = winMemGetHeap();
	assert(hHeap != 0);
	assert(hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior));
#endif
	assert(nBytes >= 0);
	if (!pPrior) {
		p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);
	}
	else {
		p = osHeapReAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior, (SIZE_T)nBytes);
	}
	if (!p) {
		sqlite3_log(SQLITE_NOMEM, "failed to %s %u bytes (%lu), heap=%p",
			pPrior ? "HeapReAlloc" : "HeapAlloc", nBytes, osGetLastError(),
			(void*)hHeap);
	}
	return p;
}


static int winMemSize(void *p) {
	HANDLE hHeap;
	SIZE_T n;

	winMemAssertMagic();
	hHeap = winMemGetHeap();
	assert(hHeap != 0);
	assert(hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p));
#endif
	if (!p) return 0;
	n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);
	if (n == (SIZE_T)-1) {
		sqlite3_log(SQLITE_NOMEM, "failed to HeapSize block %p (%lu), heap=%p",
			p, osGetLastError(), (void*)hHeap);
		return 0;
	}
	return (int)n;
}


static int winMemRoundup(int n) {
	return n;
}


static int winMemInit(void *pAppData) {
	winMemData *pWinMemData = (winMemData *)pAppData;

	if (!pWinMemData) return SQLITE_ERROR;
	assert(pWinMemData->magic1 == WINMEM_MAGIC1);
	assert(pWinMemData->magic2 == WINMEM_MAGIC2);

#if !SQLITE_OS_WINRT && SQLITE_WIN32_HEAP_CREATE
	if (!pWinMemData->hHeap) {
		DWORD dwInitialSize = SQLITE_WIN32_HEAP_INIT_SIZE;
		DWORD dwMaximumSize = (DWORD)sqlite3GlobalConfig.nHeap;
		if (dwMaximumSize == 0) {
			dwMaximumSize = SQLITE_WIN32_HEAP_MAX_SIZE;
		}
		else if (dwInitialSize>dwMaximumSize) {
			dwInitialSize = dwMaximumSize;
		}
		pWinMemData->hHeap = osHeapCreate(SQLITE_WIN32_HEAP_FLAGS,
			dwInitialSize, dwMaximumSize);
		if (!pWinMemData->hHeap) {
			sqlite3_log(SQLITE_NOMEM,
				"failed to HeapCreate (%lu), flags=%u, initSize=%lu, maxSize=%lu",
				osGetLastError(), SQLITE_WIN32_HEAP_FLAGS, dwInitialSize,
				dwMaximumSize);
			return SQLITE_NOMEM_BKPT;
		}
		pWinMemData->bOwned = TRUE;
		assert(pWinMemData->bOwned);
	}
#else
	pWinMemData->hHeap = osGetProcessHeap();
	if (!pWinMemData->hHeap) {
		sqlite3_log(SQLITE_NOMEM,
			"failed to GetProcessHeap (%lu)", osGetLastError());
		return SQLITE_NOMEM_BKPT;
	}
	pWinMemData->bOwned = FALSE;
	assert(!pWinMemData->bOwned);
#endif
	assert(pWinMemData->hHeap != 0);
	assert(pWinMemData->hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
	assert(osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL));
#endif
	return SQLITE_OK;
}


static void winMemShutdown(void *pAppData) {
	winMemData *pWinMemData = (winMemData *)pAppData;

	if (!pWinMemData) return;
	assert(pWinMemData->magic1 == WINMEM_MAGIC1);
	assert(pWinMemData->magic2 == WINMEM_MAGIC2);

	if (pWinMemData->hHeap) {
		assert(pWinMemData->hHeap != INVALID_HANDLE_VALUE);
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
		assert(osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL));
#endif
		if (pWinMemData->bOwned) {
			if (!osHeapDestroy(pWinMemData->hHeap)) {
				sqlite3_log(SQLITE_NOMEM, "failed to HeapDestroy (%lu), heap=%p",
					osGetLastError(), (void*)pWinMemData->hHeap);
			}
			pWinMemData->bOwned = FALSE;
		}
		pWinMemData->hHeap = NULL;
	}
}


SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void) {
	static const sqlite3_mem_methods winMemMethods = {
		winMemMalloc,
		winMemFree,
		winMemRealloc,
		winMemSize,
		winMemRoundup,
		winMemInit,
		winMemShutdown,
		&win_mem_data
	};
	return &winMemMethods;
}

SQLITE_PRIVATE void sqlite3MemSetDefault(void) {
	sqlite3_config(SQLITE_CONFIG_MALLOC, sqlite3MemGetWin32());
}
#endif 


static LPWSTR winUtf8ToUnicode(const char *zText) {
	int nChar;
	LPWSTR zWideText;

	nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);
	if (nChar == 0) {
		return 0;
	}
	zWideText = sqlite3MallocZero(nChar * sizeof(WCHAR));
	if (zWideText == 0) {
		return 0;
	}
	nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText,
		nChar);
	if (nChar == 0) {
		sqlite3_free(zWideText);
		zWideText = 0;
	}
	return zWideText;
}


static char *winUnicodeToUtf8(LPCWSTR zWideText) {
	int nByte;
	char *zText;

	nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);
	if (nByte == 0) {
		return 0;
	}
	zText = sqlite3MallocZero(nByte);
	if (zText == 0) {
		return 0;
	}
	nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte,
		0, 0);
	if (nByte == 0) {
		sqlite3_free(zText);
		zText = 0;
	}
	return zText;
}


static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi) {
	int nByte;
	LPWSTR zMbcsText;
	int codepage = useAnsi ? CP_ACP : CP_OEMCP;

	nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,
		0) * sizeof(WCHAR);
	if (nByte == 0) {
		return 0;
	}
	zMbcsText = sqlite3MallocZero(nByte * sizeof(WCHAR));
	if (zMbcsText == 0) {
		return 0;
	}
	nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,
		nByte);
	if (nByte == 0) {
		sqlite3_free(zMbcsText);
		zMbcsText = 0;
	}
	return zMbcsText;
}


static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi) {
	int nByte;
	char *zText;
	int codepage = useAnsi ? CP_ACP : CP_OEMCP;

	nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);
	if (nByte == 0) {
		return 0;
	}
	zText = sqlite3MallocZero(nByte);
	if (zText == 0) {
		return 0;
	}
	nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, zText,
		nByte, 0, 0);
	if (nByte == 0) {
		sqlite3_free(zText);
		zText = 0;
	}
	return zText;
}


static char *winMbcsToUtf8(const char *zText, int useAnsi) {
	char *zTextUtf8;
	LPWSTR zTmpWide;

	zTmpWide = winMbcsToUnicode(zText, useAnsi);
	if (zTmpWide == 0) {
		return 0;
	}
	zTextUtf8 = winUnicodeToUtf8(zTmpWide);
	sqlite3_free(zTmpWide);
	return zTextUtf8;
}


static char *winUtf8ToMbcs(const char *zText, int useAnsi) {
	char *zTextMbcs;
	LPWSTR zTmpWide;

	zTmpWide = winUtf8ToUnicode(zText);
	if (zTmpWide == 0) {
		return 0;
	}
	zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);
	sqlite3_free(zTmpWide);
	return zTextMbcs;
}


SQLITE_API LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winUtf8ToUnicode(zText);
}


SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zWideText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winUnicodeToUtf8(zWideText);
}


SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zText) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winMbcsToUtf8(zText, osAreFileApisANSI());
}


SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winMbcsToUtf8(zText, useAnsi);
}


SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zText) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winUtf8ToMbcs(zText, osAreFileApisANSI());
}


SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!zText) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize()) return 0;
#endif
	return winUtf8ToMbcs(zText, useAnsi);
}


SQLITE_API int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue) {
	char **ppDirectory = 0;
#ifndef SQLITE_OMIT_AUTOINIT
	int rc = sqlite3_initialize();
	if (rc) return rc;
#endif
	if (type == SQLITE_WIN32_DATA_DIRECTORY_TYPE) {
		ppDirectory = &sqlite3_data_directory;
	}
	else if (type == SQLITE_WIN32_TEMP_DIRECTORY_TYPE) {
		ppDirectory = &sqlite3_temp_directory;
	}
	assert(!ppDirectory || type == SQLITE_WIN32_DATA_DIRECTORY_TYPE
		|| type == SQLITE_WIN32_TEMP_DIRECTORY_TYPE
	);
	assert(!ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP));
	if (ppDirectory) {
		char *zValueUtf8 = 0;
		if (zValue && zValue[0]) {
			zValueUtf8 = winUnicodeToUtf8(zValue);
			if (zValueUtf8 == 0) {
				return SQLITE_NOMEM_BKPT;
			}
		}
		sqlite3_free(*ppDirectory);
		*ppDirectory = zValueUtf8;
		return SQLITE_OK;
	}
	return SQLITE_ERROR;
}


static int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf) {
	
	DWORD dwLen = 0;
	char *zOut = 0;

	if (osIsNT()) {
#if SQLITE_OS_WINRT
		WCHAR zTempWide[SQLITE_WIN32_MAX_ERRMSG_CHARS + 1];
		dwLen = osFormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			lastErrno,
			0,
			zTempWide,
			SQLITE_WIN32_MAX_ERRMSG_CHARS,
			0);
#else
		LPWSTR zTempWide = NULL;
		dwLen = osFormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			lastErrno,
			0,
			(LPWSTR)&zTempWide,
			0,
			0);
#endif
		if (dwLen > 0) {
			
			sqlite3BeginBenignMalloc();
			zOut = winUnicodeToUtf8(zTempWide);
			sqlite3EndBenignMalloc();
#if !SQLITE_OS_WINRT
			
			osLocalFree(zTempWide);
#endif
		}
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		char *zTemp = NULL;
		dwLen = osFormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			lastErrno,
			0,
			(LPSTR)&zTemp,
			0,
			0);
		if (dwLen > 0) {
			
			sqlite3BeginBenignMalloc();
			zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());
			sqlite3EndBenignMalloc();
			
			osLocalFree(zTemp);
		}
	}
#endif
	if (0 == dwLen) {
		sqlite3_snprintf(nBuf, zBuf, "OsError 0x%lx (%lu)", lastErrno, lastErrno);
	}
	else {
		
		sqlite3_snprintf(nBuf, zBuf, "%s", zOut);
		
		sqlite3_free(zOut);
	}
	return 0;
}


#define winLogError(a,b,c,d)   winLogErrorAtLine(a,b,c,d,__LINE__)
static int winLogErrorAtLine(
	int errcode,                    
	DWORD lastErrno,                
	const char *zFunc,              
	const char *zPath,              
	int iLine                       
) {
	char zMsg[500];                 
	int i;                          

	zMsg[0] = 0;
	winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);
	assert(errcode != SQLITE_OK);
	if (zPath == 0) zPath = "";
	for (i = 0; zMsg[i] && zMsg[i] != '\r' && zMsg[i] != '\n'; i++) {}
	zMsg[i] = 0;
	sqlite3_log(errcode,
		"os_win.c:%d: (%lu) %s(%s) - %s",
		iLine, lastErrno, zFunc, zPath, zMsg
	);

	return errcode;
}


#ifndef SQLITE_WIN32_IOERR_RETRY
# define SQLITE_WIN32_IOERR_RETRY 10
#endif
#ifndef SQLITE_WIN32_IOERR_RETRY_DELAY
# define SQLITE_WIN32_IOERR_RETRY_DELAY 25
#endif
static int winIoerrRetry = SQLITE_WIN32_IOERR_RETRY;
static int winIoerrRetryDelay = SQLITE_WIN32_IOERR_RETRY_DELAY;


#if !defined(winIoerrCanRetry1)
#define winIoerrCanRetry1(a) (((a)==ERROR_ACCESS_DENIED)        || \
                              ((a)==ERROR_SHARING_VIOLATION)    || \
                              ((a)==ERROR_LOCK_VIOLATION)       || \
                              ((a)==ERROR_DEV_NOT_EXIST)        || \
                              ((a)==ERROR_NETNAME_DELETED)      || \
                              ((a)==ERROR_SEM_TIMEOUT)          || \
                              ((a)==ERROR_NETWORK_UNREACHABLE))
#endif


static int winRetryIoerr(int *pnRetry, DWORD *pError) {
	DWORD e = osGetLastError();
	if (*pnRetry >= winIoerrRetry) {
		if (pError) {
			*pError = e;
		}
		return 0;
	}
	if (winIoerrCanRetry1(e)) {
		sqlite3_win32_sleep(winIoerrRetryDelay*(1 + *pnRetry));
		++*pnRetry;
		return 1;
	}
#if defined(winIoerrCanRetry2)
	else if (winIoerrCanRetry2(e)) {
		sqlite3_win32_sleep(winIoerrRetryDelay*(1 + *pnRetry));
		++*pnRetry;
		return 1;
	}
#endif
	if (pError) {
		*pError = e;
	}
	return 0;
}


static void winLogIoerr(int nRetry, int lineno) {
	if (nRetry) {
		sqlite3_log(SQLITE_NOTICE,
			"delayed %dms for lock/sharing conflict at line %d",
			winIoerrRetryDelay*nRetry*(nRetry + 1) / 2, lineno
		);
	}
}


#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \
    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)


struct tm *__cdecl localtime(const time_t *t)
{
	static struct tm y;
	FILETIME uTm, lTm;
	SYSTEMTIME pTm;
	sqlite3_int64 t64;
	t64 = *t;
	t64 = (t64 + 11644473600) * 10000000;
	uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);
	uTm.dwHighDateTime = (DWORD)(t64 >> 32);
	osFileTimeToLocalFileTime(&uTm, &lTm);
	osFileTimeToSystemTime(&lTm, &pTm);
	y.tm_year = pTm.wYear - 1900;
	y.tm_mon = pTm.wMonth - 1;
	y.tm_wday = pTm.wDayOfWeek;
	y.tm_mday = pTm.wDay;
	y.tm_hour = pTm.wHour;
	y.tm_min = pTm.wMinute;
	y.tm_sec = pTm.wSecond;
	return &y;
}
#endif

#if SQLITE_OS_WINCE

#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-(int)offsetof(winFile,h)]


static void winceMutexAcquire(HANDLE h) {
	DWORD dwErr;
	do {
		dwErr = osWaitForSingleObject(h, INFINITE);
	} while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED);
}

#define winceMutexRelease(h) ReleaseMutex(h)


static int winceCreateLock(const char *zFilename, winFile *pFile) {
	LPWSTR zTok;
	LPWSTR zName;
	DWORD lastErrno;
	BOOL bLogged = FALSE;
	BOOL bInit = TRUE;

	zName = winUtf8ToUnicode(zFilename);
	if (zName == 0) {
		
		return SQLITE_IOERR_NOMEM_BKPT;
	}

	
	memset(&pFile->local, 0, sizeof(pFile->local));

	
	zTok = osCharLowerW(zName);
	for (; *zTok; zTok++) {
		if (*zTok == '\\') *zTok = '_';
	}

	
	pFile->hMutex = osCreateMutexW(NULL, FALSE, zName);
	if (!pFile->hMutex) {
		pFile->lastErrno = osGetLastError();
		sqlite3_free(zName);
		return winLogError(SQLITE_IOERR, pFile->lastErrno,
			"winceCreateLock1", zFilename);
	}

	
	winceMutexAcquire(pFile->hMutex);

	
	osCharUpperW(zName);
	pFile->hShared = osCreateFileMappingW(INVALID_HANDLE_VALUE, NULL,
		PAGE_READWRITE, 0, sizeof(winceLock),
		zName);

	
	lastErrno = osGetLastError();
	if (lastErrno == ERROR_ALREADY_EXISTS) {
		bInit = FALSE;
	}

	sqlite3_free(zName);

	
	if (pFile->hShared) {
		pFile->shared = (winceLock*)osMapViewOfFile(pFile->hShared,
			FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, sizeof(winceLock));
		
		if (!pFile->shared) {
			pFile->lastErrno = osGetLastError();
			winLogError(SQLITE_IOERR, pFile->lastErrno,
				"winceCreateLock2", zFilename);
			bLogged = TRUE;
			osCloseHandle(pFile->hShared);
			pFile->hShared = NULL;
		}
	}

	
	if (pFile->hShared == NULL) {
		if (!bLogged) {
			pFile->lastErrno = lastErrno;
			winLogError(SQLITE_IOERR, pFile->lastErrno,
				"winceCreateLock3", zFilename);
			bLogged = TRUE;
		}
		winceMutexRelease(pFile->hMutex);
		osCloseHandle(pFile->hMutex);
		pFile->hMutex = NULL;
		return SQLITE_IOERR;
	}

	
	if (bInit) {
		memset(pFile->shared, 0, sizeof(winceLock));
	}

	winceMutexRelease(pFile->hMutex);
	return SQLITE_OK;
}


static void winceDestroyLock(winFile *pFile) {
	if (pFile->hMutex) {
		
		winceMutexAcquire(pFile->hMutex);

		
		if (pFile->local.nReaders) {
			pFile->shared->nReaders--;
		}
		if (pFile->local.bReserved) {
			pFile->shared->bReserved = FALSE;
		}
		if (pFile->local.bPending) {
			pFile->shared->bPending = FALSE;
		}
		if (pFile->local.bExclusive) {
			pFile->shared->bExclusive = FALSE;
		}

		
		osUnmapViewOfFile(pFile->shared);
		osCloseHandle(pFile->hShared);

		
		winceMutexRelease(pFile->hMutex);
		osCloseHandle(pFile->hMutex);
		pFile->hMutex = NULL;
	}
}


static BOOL winceLockFile(
	LPHANDLE phFile,
	DWORD dwFileOffsetLow,
	DWORD dwFileOffsetHigh,
	DWORD nNumberOfBytesToLockLow,
	DWORD nNumberOfBytesToLockHigh
) {
	winFile *pFile = HANDLE_TO_WINFILE(phFile);
	BOOL bReturn = FALSE;

	UNUSED_PARAMETER(dwFileOffsetHigh);
	UNUSED_PARAMETER(nNumberOfBytesToLockHigh);

	if (!pFile->hMutex) return TRUE;
	winceMutexAcquire(pFile->hMutex);

	
	if (dwFileOffsetLow == (DWORD)SHARED_FIRST
		&& nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE) {
		if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0) {
			pFile->shared->bExclusive = TRUE;
			pFile->local.bExclusive = TRUE;
			bReturn = TRUE;
		}
	}

	
	else if (dwFileOffsetLow == (DWORD)SHARED_FIRST &&
		nNumberOfBytesToLockLow == 1) {
		if (pFile->shared->bExclusive == 0) {
			pFile->local.nReaders++;
			if (pFile->local.nReaders == 1) {
				pFile->shared->nReaders++;
			}
			bReturn = TRUE;
		}
	}

	
	else if (dwFileOffsetLow == (DWORD)PENDING_BYTE
		&& nNumberOfBytesToLockLow == 1) {
		
		if (pFile->shared->bPending == 0) {
			pFile->shared->bPending = TRUE;
			pFile->local.bPending = TRUE;
			bReturn = TRUE;
		}
	}

	
	else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE
		&& nNumberOfBytesToLockLow == 1) {
		if (pFile->shared->bReserved == 0) {
			pFile->shared->bReserved = TRUE;
			pFile->local.bReserved = TRUE;
			bReturn = TRUE;
		}
	}

	winceMutexRelease(pFile->hMutex);
	return bReturn;
}


static BOOL winceUnlockFile(
	LPHANDLE phFile,
	DWORD dwFileOffsetLow,
	DWORD dwFileOffsetHigh,
	DWORD nNumberOfBytesToUnlockLow,
	DWORD nNumberOfBytesToUnlockHigh
) {
	winFile *pFile = HANDLE_TO_WINFILE(phFile);
	BOOL bReturn = FALSE;

	UNUSED_PARAMETER(dwFileOffsetHigh);
	UNUSED_PARAMETER(nNumberOfBytesToUnlockHigh);

	if (!pFile->hMutex) return TRUE;
	winceMutexAcquire(pFile->hMutex);

	
	if (dwFileOffsetLow == (DWORD)SHARED_FIRST) {
		
		if (pFile->local.bExclusive) {
			assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);
			pFile->local.bExclusive = FALSE;
			pFile->shared->bExclusive = FALSE;
			bReturn = TRUE;
		}

		
		else if (pFile->local.nReaders) {
			assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE
				|| nNumberOfBytesToUnlockLow == 1);
			pFile->local.nReaders--;
			if (pFile->local.nReaders == 0)
			{
				pFile->shared->nReaders--;
			}
			bReturn = TRUE;
		}
	}

	
	else if (dwFileOffsetLow == (DWORD)PENDING_BYTE
		&& nNumberOfBytesToUnlockLow == 1) {
		if (pFile->local.bPending) {
			pFile->local.bPending = FALSE;
			pFile->shared->bPending = FALSE;
			bReturn = TRUE;
		}
	}
	
	else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE
		&& nNumberOfBytesToUnlockLow == 1) {
		if (pFile->local.bReserved) {
			pFile->local.bReserved = FALSE;
			pFile->shared->bReserved = FALSE;
			bReturn = TRUE;
		}
	}

	winceMutexRelease(pFile->hMutex);
	return bReturn;
}

#endif 


static BOOL winLockFile(
	LPHANDLE phFile,
	DWORD flags,
	DWORD offsetLow,
	DWORD offsetHigh,
	DWORD numBytesLow,
	DWORD numBytesHigh
) {
#if SQLITE_OS_WINCE
	
	return winceLockFile(phFile, offsetLow, offsetHigh,
		numBytesLow, numBytesHigh);
#else
	if (osIsNT()) {
		OVERLAPPED ovlp;
		memset(&ovlp, 0, sizeof(OVERLAPPED));
		ovlp.Offset = offsetLow;
		ovlp.OffsetHigh = offsetHigh;
		return osLockFileEx(*phFile, flags, 0, numBytesLow, numBytesHigh, &ovlp);
	}
	else {
		return osLockFile(*phFile, offsetLow, offsetHigh, numBytesLow,
			numBytesHigh);
	}
#endif
}


static BOOL winUnlockFile(
	LPHANDLE phFile,
	DWORD offsetLow,
	DWORD offsetHigh,
	DWORD numBytesLow,
	DWORD numBytesHigh
) {
#if SQLITE_OS_WINCE
	
	return winceUnlockFile(phFile, offsetLow, offsetHigh,
		numBytesLow, numBytesHigh);
#else
	if (osIsNT()) {
		OVERLAPPED ovlp;
		memset(&ovlp, 0, sizeof(OVERLAPPED));
		ovlp.Offset = offsetLow;
		ovlp.OffsetHigh = offsetHigh;
		return osUnlockFileEx(*phFile, 0, numBytesLow, numBytesHigh, &ovlp);
	}
	else {
		return osUnlockFile(*phFile, offsetLow, offsetHigh, numBytesLow,
			numBytesHigh);
	}
#endif
}




#ifndef INVALID_SET_FILE_POINTER
# define INVALID_SET_FILE_POINTER ((DWORD)-1)
#endif


static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset) {
#if !SQLITE_OS_WINRT
	LONG upperBits;                 
	LONG lowerBits;                 
	DWORD dwRet;                    
	DWORD lastErrno;                

	OSTRACE(("SEEK file=%p, offset=%lld\n", pFile->h, iOffset));

	upperBits = (LONG)((iOffset >> 32) & 0x7fffffff);
	lowerBits = (LONG)(iOffset & 0xffffffff);

	
	dwRet = osSetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN);

	if ((dwRet == INVALID_SET_FILE_POINTER
		&& ((lastErrno = osGetLastError()) != NO_ERROR))) {
		pFile->lastErrno = lastErrno;
		winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,
			"winSeekFile", pFile->zPath);
		OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));
		return 1;
	}

	OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));
	return 0;
#else
	

	LARGE_INTEGER x;                
	BOOL bRet;                      

	x.QuadPart = iOffset;
	bRet = osSetFilePointerEx(pFile->h, x, 0, FILE_BEGIN);

	if (!bRet) {
		pFile->lastErrno = osGetLastError();
		winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,
			"winSeekFile", pFile->zPath);
		OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));
		return 1;
	}

	OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));
	return 0;
#endif
}

#if SQLITE_MAX_MMAP_SIZE>0

static int winMapfile(winFile*, sqlite3_int64);
static int winUnmapfile(winFile*);
#endif


#define MX_CLOSE_ATTEMPT 3
static int winClose(sqlite3_file *id) {
	int rc, cnt = 0;
	winFile *pFile = (winFile*)id;

	assert(id != 0);
#ifndef SQLITE_OMIT_WAL
	assert(pFile->pShm == 0);
#endif
	assert(pFile->h != NULL && pFile->h != INVALID_HANDLE_VALUE);
	OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p\n",
		osGetCurrentProcessId(), pFile, pFile->h));

#if SQLITE_MAX_MMAP_SIZE>0
	winUnmapfile(pFile);
#endif

	do {
		rc = osCloseHandle(pFile->h);
		
	} while (rc == 0 && ++cnt < MX_CLOSE_ATTEMPT && (sqlite3_win32_sleep(100), 1));
#if SQLITE_OS_WINCE
#define WINCE_DELETION_ATTEMPTS 3
	{
		winVfsAppData *pAppData = (winVfsAppData*)pFile->pVfs->pAppData;
		if (pAppData == NULL || !pAppData->bNoLock) {
			winceDestroyLock(pFile);
		}
	}
	if (pFile->zDeleteOnClose) {
		int cnt = 0;
		while (
			osDeleteFileW(pFile->zDeleteOnClose) == 0
			&& osGetFileAttributesW(pFile->zDeleteOnClose) != 0xffffffff
			&& cnt++ < WINCE_DELETION_ATTEMPTS
			) {
			sqlite3_win32_sleep(100);  
		}
		sqlite3_free(pFile->zDeleteOnClose);
	}
#endif
	if (rc) {
		pFile->h = NULL;
	}
	OpenCounter(-1);
	OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n",
		osGetCurrentProcessId(), pFile, pFile->h, rc ? "ok" : "failed"));
	return rc ? SQLITE_OK
		: winLogError(SQLITE_IOERR_CLOSE, osGetLastError(),
			"winClose", pFile->zPath);
}


static int winRead(
	sqlite3_file *id,          
	void *pBuf,                
	int amt,                   
	sqlite3_int64 offset       
) {
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
	OVERLAPPED overlapped;          
#endif
	winFile *pFile = (winFile*)id;  
	DWORD nRead;                    
	int nRetry = 0;                 

	assert(id != 0);
	assert(amt>0);
	assert(offset >= 0);
	SimulateIOError(return SQLITE_IOERR_READ);
	OSTRACE(("READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "
		"offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,
		pFile->h, pBuf, amt, offset, pFile->locktype));

#if SQLITE_MAX_MMAP_SIZE>0
	
	if (offset<pFile->mmapSize) {
		if (offset + amt <= pFile->mmapSize) {
			memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
			OSTRACE(("READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
				osGetCurrentProcessId(), pFile, pFile->h));
			return SQLITE_OK;
		}
		else {
			int nCopy = (int)(pFile->mmapSize - offset);
			memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
			pBuf = &((u8 *)pBuf)[nCopy];
			amt -= nCopy;
			offset += nCopy;
		}
	}
#endif

#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
	if (winSeekFile(pFile, offset)) {
		OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return SQLITE_FULL;
	}
	while (!osReadFile(pFile->h, pBuf, amt, &nRead, 0)) {
#else
	memset(&overlapped, 0, sizeof(OVERLAPPED));
	overlapped.Offset = (LONG)(offset & 0xffffffff);
	overlapped.OffsetHigh = (LONG)((offset >> 32) & 0x7fffffff);
	while (!osReadFile(pFile->h, pBuf, amt, &nRead, &overlapped) &&
		osGetLastError() != ERROR_HANDLE_EOF) {
#endif
		DWORD lastErrno;
		if (winRetryIoerr(&nRetry, &lastErrno)) continue;
		pFile->lastErrno = lastErrno;
		OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return winLogError(SQLITE_IOERR_READ, pFile->lastErrno,
			"winRead", pFile->zPath);
	}
	winLogIoerr(nRetry, __LINE__);
	if (nRead<(DWORD)amt) {
		
		memset(&((char*)pBuf)[nRead], 0, amt - nRead);
		OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return SQLITE_IOERR_SHORT_READ;
	}

	OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), pFile, pFile->h));
	return SQLITE_OK;
	}


static int winWrite(
	sqlite3_file *id,               
	const void *pBuf,               
	int amt,                        
	sqlite3_int64 offset            
) {
	int rc = 0;                     
	winFile *pFile = (winFile*)id;  
	int nRetry = 0;                 

	assert(amt>0);
	assert(pFile);
	SimulateIOError(return SQLITE_IOERR_WRITE);
	SimulateDiskfullError(return SQLITE_FULL);

	OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "
		"offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,
		pFile->h, pBuf, amt, offset, pFile->locktype));

#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0
	
	if (offset<pFile->mmapSize) {
		if (offset + amt <= pFile->mmapSize) {
			memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
			OSTRACE(("WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
				osGetCurrentProcessId(), pFile, pFile->h));
			return SQLITE_OK;
		}
		else {
			int nCopy = (int)(pFile->mmapSize - offset);
			memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);
			pBuf = &((u8 *)pBuf)[nCopy];
			amt -= nCopy;
			offset += nCopy;
		}
	}
#endif

#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
	rc = winSeekFile(pFile, offset);
	if (rc == 0) {
#else
		{
#endif
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
			OVERLAPPED overlapped;        
#endif
			u8 *aRem = (u8 *)pBuf;        
			int nRem = amt;               
			DWORD nWrite;                 
			DWORD lastErrno = NO_ERROR;   

#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
			memset(&overlapped, 0, sizeof(OVERLAPPED));
			overlapped.Offset = (LONG)(offset & 0xffffffff);
			overlapped.OffsetHigh = (LONG)((offset >> 32) & 0x7fffffff);
#endif

			while (nRem>0) {
#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
				if (!osWriteFile(pFile->h, aRem, nRem, &nWrite, 0)) {
#else
				if (!osWriteFile(pFile->h, aRem, nRem, &nWrite, &overlapped)) {
#endif
					if (winRetryIoerr(&nRetry, &lastErrno)) continue;
					break;
				}
				assert(nWrite == 0 || nWrite <= (DWORD)nRem);
				if (nWrite == 0 || nWrite>(DWORD)nRem) {
					lastErrno = osGetLastError();
					break;
				}
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
				offset += nWrite;
				overlapped.Offset = (LONG)(offset & 0xffffffff);
				overlapped.OffsetHigh = (LONG)((offset >> 32) & 0x7fffffff);
#endif
				aRem += nWrite;
				nRem -= nWrite;
				}
			if (nRem>0) {
				pFile->lastErrno = lastErrno;
				rc = 1;
			}
			}

		if (rc) {
			if ((pFile->lastErrno == ERROR_HANDLE_DISK_FULL)
				|| (pFile->lastErrno == ERROR_DISK_FULL)) {
				OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",
					osGetCurrentProcessId(), pFile, pFile->h));
				return winLogError(SQLITE_FULL, pFile->lastErrno,
					"winWrite1", pFile->zPath);
			}
			OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n",
				osGetCurrentProcessId(), pFile, pFile->h));
			return winLogError(SQLITE_IOERR_WRITE, pFile->lastErrno,
				"winWrite2", pFile->zPath);
		}
		else {
			winLogIoerr(nRetry, __LINE__);
		}
		OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return SQLITE_OK;
		}


static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte) {
	winFile *pFile = (winFile*)id;  
	int rc = SQLITE_OK;             
	DWORD lastErrno;

	assert(pFile);
	SimulateIOError(return SQLITE_IOERR_TRUNCATE);
	OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n",
		osGetCurrentProcessId(), pFile, pFile->h, nByte, pFile->locktype));

	
	if (pFile->szChunk>0) {
		nByte = ((nByte + pFile->szChunk - 1) / pFile->szChunk) * pFile->szChunk;
	}

	
	if (winSeekFile(pFile, nByte)) {
		rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,
			"winTruncate1", pFile->zPath);
	}
	else if (0 == osSetEndOfFile(pFile->h) &&
		((lastErrno = osGetLastError()) != ERROR_USER_MAPPED_FILE)) {
		pFile->lastErrno = lastErrno;
		rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,
			"winTruncate2", pFile->zPath);
	}

#if SQLITE_MAX_MMAP_SIZE>0
	
	if (pFile->pMapRegion && nByte<pFile->mmapSize) {
		pFile->mmapSize = nByte;
	}
#endif

	OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n",
		osGetCurrentProcessId(), pFile, pFile->h, sqlite3ErrName(rc)));
	return rc;
}

#ifdef SQLITE_TEST

SQLITE_API int sqlite3_sync_count = 0;
SQLITE_API int sqlite3_fullsync_count = 0;
#endif


static int winSync(sqlite3_file *id, int flags) {
#ifndef SQLITE_NO_SYNC
	
	BOOL rc;
#endif
#if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) || \
    defined(SQLITE_HAVE_OS_TRACE)
	
	winFile *pFile = (winFile*)id;
#else
	UNUSED_PARAMETER(id);
#endif

	assert(pFile);
	
	assert((flags & 0x0F) == SQLITE_SYNC_NORMAL
		|| (flags & 0x0F) == SQLITE_SYNC_FULL
	);

	
	SimulateDiskfullError(return SQLITE_FULL);

	OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n",
		osGetCurrentProcessId(), pFile, pFile->h, flags,
		pFile->locktype));

#ifndef SQLITE_TEST
	UNUSED_PARAMETER(flags);
#else
	if ((flags & 0x0F) == SQLITE_SYNC_FULL) {
		sqlite3_fullsync_count++;
	}
	sqlite3_sync_count++;
#endif

	
#ifdef SQLITE_NO_SYNC
	OSTRACE(("SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), pFile, pFile->h));
	return SQLITE_OK;
#else
#if SQLITE_MAX_MMAP_SIZE>0
	if (pFile->pMapRegion) {
		if (osFlushViewOfFile(pFile->pMapRegion, 0)) {
			OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "
				"rc=SQLITE_OK\n", osGetCurrentProcessId(),
				pFile, pFile->pMapRegion));
		}
		else {
			pFile->lastErrno = osGetLastError();
			OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "
				"rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(),
				pFile, pFile->pMapRegion));
			return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,
				"winSync1", pFile->zPath);
		}
	}
#endif
	rc = osFlushFileBuffers(pFile->h);
	SimulateIOError(rc = FALSE);
	if (rc) {
		OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return SQLITE_OK;
	}
	else {
		pFile->lastErrno = osGetLastError();
		OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n",
			osGetCurrentProcessId(), pFile, pFile->h));
		return winLogError(SQLITE_IOERR_FSYNC, pFile->lastErrno,
			"winSync2", pFile->zPath);
	}
#endif
}


static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize) {
	winFile *pFile = (winFile*)id;
	int rc = SQLITE_OK;

	assert(id != 0);
	assert(pSize != 0);
	SimulateIOError(return SQLITE_IOERR_FSTAT);
	OSTRACE(("SIZE file=%p, pSize=%p\n", pFile->h, pSize));

#if SQLITE_OS_WINRT
	{
		FILE_STANDARD_INFO info;
		if (osGetFileInformationByHandleEx(pFile->h, FileStandardInfo,
			&info, sizeof(info))) {
			*pSize = info.EndOfFile.QuadPart;
		}
		else {
			pFile->lastErrno = osGetLastError();
			rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,
				"winFileSize", pFile->zPath);
		}
	}
#else
	{
		DWORD upperBits;
		DWORD lowerBits;
		DWORD lastErrno;

		lowerBits = osGetFileSize(pFile->h, &upperBits);
		*pSize = (((sqlite3_int64)upperBits) << 32) + lowerBits;
		if ((lowerBits == INVALID_FILE_SIZE)
			&& ((lastErrno = osGetLastError()) != NO_ERROR)) {
			pFile->lastErrno = lastErrno;
			rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,
				"winFileSize", pFile->zPath);
		}
	}
#endif
	OSTRACE(("SIZE file=%p, pSize=%p, *pSize=%lld, rc=%s\n",
		pFile->h, pSize, *pSize, sqlite3ErrName(rc)));
	return rc;
}


#ifndef LOCKFILE_FAIL_IMMEDIATELY
# define LOCKFILE_FAIL_IMMEDIATELY 1
#endif

#ifndef LOCKFILE_EXCLUSIVE_LOCK
# define LOCKFILE_EXCLUSIVE_LOCK 2
#endif


#ifndef SQLITE_LOCKFILE_FLAGS
# define SQLITE_LOCKFILE_FLAGS   (LOCKFILE_FAIL_IMMEDIATELY | \
                                  LOCKFILE_EXCLUSIVE_LOCK)
#endif


#ifndef SQLITE_LOCKFILEEX_FLAGS
# define SQLITE_LOCKFILEEX_FLAGS (LOCKFILE_FAIL_IMMEDIATELY)
#endif


static int winGetReadLock(winFile *pFile) {
	int res;
	OSTRACE(("READ-LOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));
	if (osIsNT()) {
#if SQLITE_OS_WINCE
		
		res = winceLockFile(&pFile->h, SHARED_FIRST, 0, 1, 0);
#else
		res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, SHARED_FIRST, 0,
			SHARED_SIZE, 0);
#endif
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		int lk;
		sqlite3_randomness(sizeof(lk), &lk);
		pFile->sharedLockByte = (short)((lk & 0x7fffffff) % (SHARED_SIZE - 1));
		res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,
			SHARED_FIRST + pFile->sharedLockByte, 0, 1, 0);
	}
#endif
	if (res == 0) {
		pFile->lastErrno = osGetLastError();
		
	}
	OSTRACE(("READ-LOCK file=%p, result=%d\n", pFile->h, res));
	return res;
}


static int winUnlockReadLock(winFile *pFile) {
	int res;
	DWORD lastErrno;
	OSTRACE(("READ-UNLOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));
	if (osIsNT()) {
		res = winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		res = winUnlockFile(&pFile->h, SHARED_FIRST + pFile->sharedLockByte, 0, 1, 0);
	}
#endif
	if (res == 0 && ((lastErrno = osGetLastError()) != ERROR_NOT_LOCKED)) {
		pFile->lastErrno = lastErrno;
		winLogError(SQLITE_IOERR_UNLOCK, pFile->lastErrno,
			"winUnlockReadLock", pFile->zPath);
	}
	OSTRACE(("READ-UNLOCK file=%p, result=%d\n", pFile->h, res));
	return res;
}


static int winLock(sqlite3_file *id, int locktype) {
	int rc = SQLITE_OK;    
	int res = 1;           
	int newLocktype;       
	int gotPendingLock = 0;
	winFile *pFile = (winFile*)id;
	DWORD lastErrno = NO_ERROR;

	assert(id != 0);
	OSTRACE(("LOCK file=%p, oldLock=%d(%d), newLock=%d\n",
		pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));

	
	if (pFile->locktype >= locktype) {
		OSTRACE(("LOCK-HELD file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}

	
	if ((pFile->ctrlFlags & WINFILE_RDONLY) != 0 && locktype >= RESERVED_LOCK) {
		return SQLITE_IOERR_LOCK;
	}

	
	assert(pFile->locktype != NO_LOCK || locktype == SHARED_LOCK);
	assert(locktype != PENDING_LOCK);
	assert(locktype != RESERVED_LOCK || pFile->locktype == SHARED_LOCK);

	
	newLocktype = pFile->locktype;
	if (pFile->locktype == NO_LOCK
		|| (locktype == EXCLUSIVE_LOCK && pFile->locktype <= RESERVED_LOCK)
		) {
		int cnt = 3;
		while (cnt-->0 && (res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,
			PENDING_BYTE, 0, 1, 0)) == 0) {
			
			lastErrno = osGetLastError();
			OSTRACE(("LOCK-PENDING-FAIL file=%p, count=%d, result=%d\n",
				pFile->h, cnt, res));
			if (lastErrno == ERROR_INVALID_HANDLE) {
				pFile->lastErrno = lastErrno;
				rc = SQLITE_IOERR_LOCK;
				OSTRACE(("LOCK-FAIL file=%p, count=%d, rc=%s\n",
					pFile->h, cnt, sqlite3ErrName(rc)));
				return rc;
			}
			if (cnt) sqlite3_win32_sleep(1);
		}
		gotPendingLock = res;
		if (!res) {
			lastErrno = osGetLastError();
		}
	}

	
	if (locktype == SHARED_LOCK && res) {
		assert(pFile->locktype == NO_LOCK);
		res = winGetReadLock(pFile);
		if (res) {
			newLocktype = SHARED_LOCK;
		}
		else {
			lastErrno = osGetLastError();
		}
	}

	
	if (locktype == RESERVED_LOCK && res) {
		assert(pFile->locktype == SHARED_LOCK);
		res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, RESERVED_BYTE, 0, 1, 0);
		if (res) {
			newLocktype = RESERVED_LOCK;
		}
		else {
			lastErrno = osGetLastError();
		}
	}

	
	if (locktype == EXCLUSIVE_LOCK && res) {
		newLocktype = PENDING_LOCK;
		gotPendingLock = 0;
	}

	
	if (locktype == EXCLUSIVE_LOCK && res) {
		assert(pFile->locktype >= SHARED_LOCK);
		res = winUnlockReadLock(pFile);
		res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, SHARED_FIRST, 0,
			SHARED_SIZE, 0);
		if (res) {
			newLocktype = EXCLUSIVE_LOCK;
		}
		else {
			lastErrno = osGetLastError();
			winGetReadLock(pFile);
		}
	}

	
	if (gotPendingLock && locktype == SHARED_LOCK) {
		winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);
	}

	
	if (res) {
		rc = SQLITE_OK;
	}
	else {
		pFile->lastErrno = lastErrno;
		rc = SQLITE_BUSY;
		OSTRACE(("LOCK-FAIL file=%p, wanted=%d, got=%d\n",
			pFile->h, locktype, newLocktype));
	}
	pFile->locktype = (u8)newLocktype;
	OSTRACE(("LOCK file=%p, lock=%d, rc=%s\n",
		pFile->h, pFile->locktype, sqlite3ErrName(rc)));
	return rc;
}


static int winCheckReservedLock(sqlite3_file *id, int *pResOut) {
	int res;
	winFile *pFile = (winFile*)id;

	SimulateIOError(return SQLITE_IOERR_CHECKRESERVEDLOCK; );
	OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p\n", pFile->h, pResOut));

	assert(id != 0);
	if (pFile->locktype >= RESERVED_LOCK) {
		res = 1;
		OSTRACE(("TEST-WR-LOCK file=%p, result=%d (local)\n", pFile->h, res));
	}
	else {
		res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, RESERVED_BYTE, 0, 1, 0);
		if (res) {
			winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);
		}
		res = !res;
		OSTRACE(("TEST-WR-LOCK file=%p, result=%d (remote)\n", pFile->h, res));
	}
	*pResOut = res;
	OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",
		pFile->h, pResOut, *pResOut));
	return SQLITE_OK;
}


static int winUnlock(sqlite3_file *id, int locktype) {
	int type;
	winFile *pFile = (winFile*)id;
	int rc = SQLITE_OK;
	assert(pFile != 0);
	assert(locktype <= SHARED_LOCK);
	OSTRACE(("UNLOCK file=%p, oldLock=%d(%d), newLock=%d\n",
		pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));
	type = pFile->locktype;
	if (type >= EXCLUSIVE_LOCK) {
		winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);
		if (locktype == SHARED_LOCK && !winGetReadLock(pFile)) {
			
			rc = winLogError(SQLITE_IOERR_UNLOCK, osGetLastError(),
				"winUnlock", pFile->zPath);
		}
	}
	if (type >= RESERVED_LOCK) {
		winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);
	}
	if (locktype == NO_LOCK && type >= SHARED_LOCK) {
		winUnlockReadLock(pFile);
	}
	if (type >= PENDING_LOCK) {
		winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);
	}
	pFile->locktype = (u8)locktype;
	OSTRACE(("UNLOCK file=%p, lock=%d, rc=%s\n",
		pFile->h, pFile->locktype, sqlite3ErrName(rc)));
	return rc;
}



static int winNolockLock(sqlite3_file *id, int locktype) {
	UNUSED_PARAMETER(id);
	UNUSED_PARAMETER(locktype);
	return SQLITE_OK;
}

static int winNolockCheckReservedLock(sqlite3_file *id, int *pResOut) {
	UNUSED_PARAMETER(id);
	UNUSED_PARAMETER(pResOut);
	return SQLITE_OK;
}

static int winNolockUnlock(sqlite3_file *id, int locktype) {
	UNUSED_PARAMETER(id);
	UNUSED_PARAMETER(locktype);
	return SQLITE_OK;
}




static void winModeBit(winFile *pFile, unsigned char mask, int *pArg) {
	if (*pArg<0) {
		*pArg = (pFile->ctrlFlags & mask) != 0;
	}
	else if ((*pArg) == 0) {
		pFile->ctrlFlags &= ~mask;
	}
	else {
		pFile->ctrlFlags |= mask;
	}
}


static int winGetTempname(sqlite3_vfs *, char **);
static int winIsDir(const void *);
static BOOL winIsDriveLetterAndColon(const char *);


static int winFileControl(sqlite3_file *id, int op, void *pArg) {
	winFile *pFile = (winFile*)id;
	OSTRACE(("FCNTL file=%p, op=%d, pArg=%p\n", pFile->h, op, pArg));
	switch (op) {
	case SQLITE_FCNTL_LOCKSTATE: {
		*(int*)pArg = pFile->locktype;
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_LAST_ERRNO: {
		*(int*)pArg = (int)pFile->lastErrno;
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_CHUNK_SIZE: {
		pFile->szChunk = *(int *)pArg;
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_SIZE_HINT: {
		if (pFile->szChunk>0) {
			sqlite3_int64 oldSz;
			int rc = winFileSize(id, &oldSz);
			if (rc == SQLITE_OK) {
				sqlite3_int64 newSz = *(sqlite3_int64*)pArg;
				if (newSz>oldSz) {
					SimulateIOErrorBenign(1);
					rc = winTruncate(id, newSz);
					SimulateIOErrorBenign(0);
				}
			}
			OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));
			return rc;
		}
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_PERSIST_WAL: {
		winModeBit(pFile, WINFILE_PERSIST_WAL, (int*)pArg);
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {
		winModeBit(pFile, WINFILE_PSOW, (int*)pArg);
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_VFSNAME: {
		*(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_WIN32_AV_RETRY: {
		int *a = (int*)pArg;
		if (a[0]>0) {
			winIoerrRetry = a[0];
		}
		else {
			a[0] = winIoerrRetry;
		}
		if (a[1]>0) {
			winIoerrRetryDelay = a[1];
		}
		else {
			a[1] = winIoerrRetryDelay;
		}
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
	case SQLITE_FCNTL_WIN32_GET_HANDLE: {
		LPHANDLE phFile = (LPHANDLE)pArg;
		*phFile = pFile->h;
		OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
		return SQLITE_OK;
	}
#ifdef SQLITE_TEST
	case SQLITE_FCNTL_WIN32_SET_HANDLE: {
		LPHANDLE phFile = (LPHANDLE)pArg;
		HANDLE hOldFile = pFile->h;
		pFile->h = *phFile;
		*phFile = hOldFile;
		OSTRACE(("FCNTL oldFile=%p, newFile=%p, rc=SQLITE_OK\n",
			hOldFile, pFile->h));
		return SQLITE_OK;
	}
#endif
	case SQLITE_FCNTL_TEMPFILENAME: {
		char *zTFile = 0;
		int rc = winGetTempname(pFile->pVfs, &zTFile);
		if (rc == SQLITE_OK) {
			*(char**)pArg = zTFile;
		}
		OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));
		return rc;
	}
#if SQLITE_MAX_MMAP_SIZE>0
	case SQLITE_FCNTL_MMAP_SIZE: {
		i64 newLimit = *(i64*)pArg;
		int rc = SQLITE_OK;
		if (newLimit>sqlite3GlobalConfig.mxMmap) {
			newLimit = sqlite3GlobalConfig.mxMmap;
		}
		*(i64*)pArg = pFile->mmapSizeMax;
		if (newLimit >= 0 && newLimit != pFile->mmapSizeMax && pFile->nFetchOut == 0) {
			pFile->mmapSizeMax = newLimit;
			if (pFile->mmapSize>0) {
				winUnmapfile(pFile);
				rc = winMapfile(pFile, -1);
			}
		}
		OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));
		return rc;
	}
#endif
	}
	OSTRACE(("FCNTL file=%p, rc=SQLITE_NOTFOUND\n", pFile->h));
	return SQLITE_NOTFOUND;
}


static int winSectorSize(sqlite3_file *id) {
	(void)id;
	return SQLITE_DEFAULT_SECTOR_SIZE;
}


static int winDeviceCharacteristics(sqlite3_file *id) {
	winFile *p = (winFile*)id;
	return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN |
		((p->ctrlFlags & WINFILE_PSOW) ? SQLITE_IOCAP_POWERSAFE_OVERWRITE : 0);
}


static SYSTEM_INFO winSysInfo;

#ifndef SQLITE_OMIT_WAL


static void winShmEnterMutex(void) {
	sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
static void winShmLeaveMutex(void) {
	sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
#ifndef NDEBUG
static int winShmMutexHeld(void) {
	return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
}
#endif


struct winShmNode {
	sqlite3_mutex *mutex;      
	char *zFilename;           
	winFile hFile;             

	int szRegion;              
	int nRegion;               
	struct ShmRegion {
		HANDLE hMap;             
		void *pMap;
	} *aRegion;
	DWORD lastErrno;           

	int nRef;                  
	winShm *pFirst;            
	winShmNode *pNext;         
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
	u8 nextShmId;              
#endif
};


static winShmNode *winShmNodeList = 0;


struct winShm {
	winShmNode *pShmNode;      
	winShm *pNext;             
	u8 hasMutex;               
	u16 sharedMask;            
	u16 exclMask;              
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
	u8 id;                     
#endif
};


#define WIN_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)        
#define WIN_SHM_DMS    (WIN_SHM_BASE+SQLITE_SHM_NLOCK)  


#define WINSHM_UNLCK  1
#define WINSHM_RDLCK  2
#define WINSHM_WRLCK  3
static int winShmSystemLock(
	winShmNode *pFile,    
	int lockType,         
	int ofst,             
	int nByte             
) {
	int rc = 0;           

						  
	assert(sqlite3_mutex_held(pFile->mutex) || pFile->nRef == 0);

	OSTRACE(("SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n",
		pFile->hFile.h, lockType, ofst, nByte));

	
	if (lockType == WINSHM_UNLCK) {
		rc = winUnlockFile(&pFile->hFile.h, ofst, 0, nByte, 0);
	}
	else {
		
		DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;
		if (lockType == WINSHM_WRLCK) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;
		rc = winLockFile(&pFile->hFile.h, dwFlags, ofst, 0, nByte, 0);
	}

	if (rc != 0) {
		rc = SQLITE_OK;
	}
	else {
		pFile->lastErrno = osGetLastError();
		rc = SQLITE_BUSY;
	}

	OSTRACE(("SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\n",
		pFile->hFile.h, (lockType == WINSHM_UNLCK) ? "winUnlockFile" :
		"winLockFile", pFile->lastErrno, sqlite3ErrName(rc)));

	return rc;
}


static int winOpen(sqlite3_vfs*, const char*, sqlite3_file*, int, int*);
static int winDelete(sqlite3_vfs *, const char*, int);


static void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag) {
	winShmNode **pp;
	winShmNode *p;
	assert(winShmMutexHeld());
	OSTRACE(("SHM-PURGE pid=%lu, deleteFlag=%d\n",
		osGetCurrentProcessId(), deleteFlag));
	pp = &winShmNodeList;
	while ((p = *pp) != 0) {
		if (p->nRef == 0) {
			int i;
			if (p->mutex) { sqlite3_mutex_free(p->mutex); }
			for (i = 0; i<p->nRegion; i++) {
				BOOL bRc = osUnmapViewOfFile(p->aRegion[i].pMap);
				OSTRACE(("SHM-PURGE-UNMAP pid=%lu, region=%d, rc=%s\n",
					osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));
				UNUSED_VARIABLE_VALUE(bRc);
				bRc = osCloseHandle(p->aRegion[i].hMap);
				OSTRACE(("SHM-PURGE-CLOSE pid=%lu, region=%d, rc=%s\n",
					osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));
				UNUSED_VARIABLE_VALUE(bRc);
			}
			if (p->hFile.h != NULL && p->hFile.h != INVALID_HANDLE_VALUE) {
				SimulateIOErrorBenign(1);
				winClose((sqlite3_file *)&p->hFile);
				SimulateIOErrorBenign(0);
			}
			if (deleteFlag) {
				SimulateIOErrorBenign(1);
				sqlite3BeginBenignMalloc();
				winDelete(pVfs, p->zFilename, 0);
				sqlite3EndBenignMalloc();
				SimulateIOErrorBenign(0);
			}
			*pp = p->pNext;
			sqlite3_free(p->aRegion);
			sqlite3_free(p);
		}
		else {
			pp = &p->pNext;
		}
	}
}


static int winOpenSharedMemory(winFile *pDbFd) {
	struct winShm *p;                  
	struct winShmNode *pShmNode = 0;   
	int rc;                            
	struct winShmNode *pNew;           
	int nName;                         

	assert(pDbFd->pShm == 0);    

								 
	p = sqlite3MallocZero(sizeof(*p));
	if (p == 0) return SQLITE_IOERR_NOMEM_BKPT;
	nName = sqlite3Strlen30(pDbFd->zPath);
	pNew = sqlite3MallocZero(sizeof(*pShmNode) + nName + 17);
	if (pNew == 0) {
		sqlite3_free(p);
		return SQLITE_IOERR_NOMEM_BKPT;
	}
	pNew->zFilename = (char*)&pNew[1];
	sqlite3_snprintf(nName + 15, pNew->zFilename, "%s-shm", pDbFd->zPath);
	sqlite3FileSuffix3(pDbFd->zPath, pNew->zFilename);

	
	winShmEnterMutex();
	for (pShmNode = winShmNodeList; pShmNode; pShmNode = pShmNode->pNext) {
		
		if (sqlite3StrICmp(pShmNode->zFilename, pNew->zFilename) == 0) break;
	}
	if (pShmNode) {
		sqlite3_free(pNew);
	}
	else {
		pShmNode = pNew;
		pNew = 0;
		((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;
		pShmNode->pNext = winShmNodeList;
		winShmNodeList = pShmNode;

		if (sqlite3GlobalConfig.bCoreMutex) {
			pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
			if (pShmNode->mutex == 0) {
				rc = SQLITE_IOERR_NOMEM_BKPT;
				goto shm_open_err;
			}
		}

		rc = winOpen(pDbFd->pVfs,
			pShmNode->zFilename,             
			(sqlite3_file*)&pShmNode->hFile,  
			SQLITE_OPEN_WAL | SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
			0);
		if (SQLITE_OK != rc) {
			goto shm_open_err;
		}

		
		if (winShmSystemLock(pShmNode, WINSHM_WRLCK, WIN_SHM_DMS, 1) == SQLITE_OK) {
			rc = winTruncate((sqlite3_file *)&pShmNode->hFile, 0);
			if (rc != SQLITE_OK) {
				rc = winLogError(SQLITE_IOERR_SHMOPEN, osGetLastError(),
					"winOpenShm", pDbFd->zPath);
			}
		}
		if (rc == SQLITE_OK) {
			winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);
			rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, WIN_SHM_DMS, 1);
		}
		if (rc) goto shm_open_err;
	}

	
	p->pShmNode = pShmNode;
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
	p->id = pShmNode->nextShmId++;
#endif
	pShmNode->nRef++;
	pDbFd->pShm = p;
	winShmLeaveMutex();

	
	sqlite3_mutex_enter(pShmNode->mutex);
	p->pNext = pShmNode->pFirst;
	pShmNode->pFirst = p;
	sqlite3_mutex_leave(pShmNode->mutex);
	return SQLITE_OK;

	
shm_open_err:
	winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);
	winShmPurge(pDbFd->pVfs, 0);      
	sqlite3_free(p);
	sqlite3_free(pNew);
	winShmLeaveMutex();
	return rc;
}


static int winShmUnmap(
	sqlite3_file *fd,          
	int deleteFlag             
) {
	winFile *pDbFd;       
	winShm *p;            
	winShmNode *pShmNode; 
	winShm **pp;          

	pDbFd = (winFile*)fd;
	p = pDbFd->pShm;
	if (p == 0) return SQLITE_OK;
	pShmNode = p->pShmNode;

	
	sqlite3_mutex_enter(pShmNode->mutex);
	for (pp = &pShmNode->pFirst; (*pp) != p; pp = &(*pp)->pNext) {}
	*pp = p->pNext;

	
	sqlite3_free(p);
	pDbFd->pShm = 0;
	sqlite3_mutex_leave(pShmNode->mutex);

	
	winShmEnterMutex();
	assert(pShmNode->nRef>0);
	pShmNode->nRef--;
	if (pShmNode->nRef == 0) {
		winShmPurge(pDbFd->pVfs, deleteFlag);
	}
	winShmLeaveMutex();

	return SQLITE_OK;
}


static int winShmLock(
	sqlite3_file *fd,          
	int ofst,                  
	int n,                     
	int flags                  
) {
	winFile *pDbFd = (winFile*)fd;        
	winShm *p = pDbFd->pShm;              
	winShm *pX;                           
	winShmNode *pShmNode = p->pShmNode;
	int rc = SQLITE_OK;                   
	u16 mask;                             

	assert(ofst >= 0 && ofst + n <= SQLITE_SHM_NLOCK);
	assert(n >= 1);
	assert(flags == (SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)
		|| flags == (SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)
		|| flags == (SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)
		|| flags == (SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE));
	assert(n == 1 || (flags & SQLITE_SHM_EXCLUSIVE) != 0);

	mask = (u16)((1U << (ofst + n)) - (1U << ofst));
	assert(n>1 || mask == (1 << ofst));
	sqlite3_mutex_enter(pShmNode->mutex);
	if (flags & SQLITE_SHM_UNLOCK) {
		u16 allMask = 0; 

						 
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if (pX == p) continue;
			assert((pX->exclMask & (p->exclMask | p->sharedMask)) == 0);
			allMask |= pX->sharedMask;
		}

		
		if ((mask & allMask) == 0) {
			rc = winShmSystemLock(pShmNode, WINSHM_UNLCK, ofst + WIN_SHM_BASE, n);
		}
		else {
			rc = SQLITE_OK;
		}

		
		if (rc == SQLITE_OK) {
			p->exclMask &= ~mask;
			p->sharedMask &= ~mask;
		}
	}
	else if (flags & SQLITE_SHM_SHARED) {
		u16 allShared = 0;  

							
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if ((pX->exclMask & mask) != 0) {
				rc = SQLITE_BUSY;
				break;
			}
			allShared |= pX->sharedMask;
		}

		
		if (rc == SQLITE_OK) {
			if ((allShared & mask) == 0) {
				rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, ofst + WIN_SHM_BASE, n);
			}
			else {
				rc = SQLITE_OK;
			}
		}

		
		if (rc == SQLITE_OK) {
			p->sharedMask |= mask;
		}
	}
	else {
		
		for (pX = pShmNode->pFirst; pX; pX = pX->pNext) {
			if ((pX->exclMask & mask) != 0 || (pX->sharedMask & mask) != 0) {
				rc = SQLITE_BUSY;
				break;
			}
		}

		
		if (rc == SQLITE_OK) {
			rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, ofst + WIN_SHM_BASE, n);
			if (rc == SQLITE_OK) {
				assert((p->sharedMask & mask) == 0);
				p->exclMask |= mask;
			}
		}
	}
	sqlite3_mutex_leave(pShmNode->mutex);
	OSTRACE(("SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\n",
		osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,
		sqlite3ErrName(rc)));
	return rc;
}


static void winShmBarrier(
	sqlite3_file *fd          
) {
	UNUSED_PARAMETER(fd);
	sqlite3MemoryBarrier();   
	winShmEnterMutex();       
	winShmLeaveMutex();
}


static int winShmMap(
	sqlite3_file *fd,               
	int iRegion,                    
	int szRegion,                   
	int isWrite,                    
	void volatile **pp              
) {
	winFile *pDbFd = (winFile*)fd;
	winShm *pShm = pDbFd->pShm;
	winShmNode *pShmNode;
	int rc = SQLITE_OK;

	if (!pShm) {
		rc = winOpenSharedMemory(pDbFd);
		if (rc != SQLITE_OK) return rc;
		pShm = pDbFd->pShm;
	}
	pShmNode = pShm->pShmNode;

	sqlite3_mutex_enter(pShmNode->mutex);
	assert(szRegion == pShmNode->szRegion || pShmNode->nRegion == 0);

	if (pShmNode->nRegion <= iRegion) {
		struct ShmRegion *apNew;           
		int nByte = (iRegion + 1)*szRegion;  
		sqlite3_int64 sz;                  

		pShmNode->szRegion = szRegion;

		
		rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);
		if (rc != SQLITE_OK) {
			rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),
				"winShmMap1", pDbFd->zPath);
			goto shmpage_out;
		}

		if (sz<nByte) {
			
			if (!isWrite) goto shmpage_out;
			rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);
			if (rc != SQLITE_OK) {
				rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),
					"winShmMap2", pDbFd->zPath);
				goto shmpage_out;
			}
		}

		
		apNew = (struct ShmRegion *)sqlite3_realloc64(
			pShmNode->aRegion, (iRegion + 1) * sizeof(apNew[0])
		);
		if (!apNew) {
			rc = SQLITE_IOERR_NOMEM_BKPT;
			goto shmpage_out;
		}
		pShmNode->aRegion = apNew;

		while (pShmNode->nRegion <= iRegion) {
			HANDLE hMap = NULL;         
			void *pMap = 0;             

#if SQLITE_OS_WINRT
			hMap = osCreateFileMappingFromApp(pShmNode->hFile.h,
				NULL, PAGE_READWRITE, nByte, NULL
			);
#elif defined(SQLITE_WIN32_HAS_WIDE)
			hMap = osCreateFileMappingW(pShmNode->hFile.h,
				NULL, PAGE_READWRITE, 0, nByte, NULL
			);
#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGA
			hMap = osCreateFileMappingA(pShmNode->hFile.h,
				NULL, PAGE_READWRITE, 0, nByte, NULL
			);
#endif
			OSTRACE(("SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n",
				osGetCurrentProcessId(), pShmNode->nRegion, nByte,
				hMap ? "ok" : "failed"));
			if (hMap) {
				int iOffset = pShmNode->nRegion*szRegion;
				int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;
#if SQLITE_OS_WINRT
				pMap = osMapViewOfFileFromApp(hMap, FILE_MAP_WRITE | FILE_MAP_READ,
					iOffset - iOffsetShift, szRegion + iOffsetShift
				);
#else
				pMap = osMapViewOfFile(hMap, FILE_MAP_WRITE | FILE_MAP_READ,
					0, iOffset - iOffsetShift, szRegion + iOffsetShift
				);
#endif
				OSTRACE(("SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n",
					osGetCurrentProcessId(), pShmNode->nRegion, iOffset,
					szRegion, pMap ? "ok" : "failed"));
			}
			if (!pMap) {
				pShmNode->lastErrno = osGetLastError();
				rc = winLogError(SQLITE_IOERR_SHMMAP, pShmNode->lastErrno,
					"winShmMap3", pDbFd->zPath);
				if (hMap) osCloseHandle(hMap);
				goto shmpage_out;
			}

			pShmNode->aRegion[pShmNode->nRegion].pMap = pMap;
			pShmNode->aRegion[pShmNode->nRegion].hMap = hMap;
			pShmNode->nRegion++;
		}
	}

shmpage_out:
	if (pShmNode->nRegion>iRegion) {
		int iOffset = iRegion*szRegion;
		int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;
		char *p = (char *)pShmNode->aRegion[iRegion].pMap;
		*pp = (void *)&p[iOffsetShift];
	}
	else {
		*pp = 0;
	}
	sqlite3_mutex_leave(pShmNode->mutex);
	return rc;
}

#else
# define winShmMap     0
# define winShmLock    0
# define winShmBarrier 0
# define winShmUnmap   0
#endif 


#if SQLITE_MAX_MMAP_SIZE>0
static int winUnmapfile(winFile *pFile) {
	assert(pFile != 0);
	OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, pMapRegion=%p, "
		"mmapSize=%lld, mmapSizeActual=%lld, mmapSizeMax=%lld\n",
		osGetCurrentProcessId(), pFile, pFile->hMap, pFile->pMapRegion,
		pFile->mmapSize, pFile->mmapSizeActual, pFile->mmapSizeMax));
	if (pFile->pMapRegion) {
		if (!osUnmapViewOfFile(pFile->pMapRegion)) {
			pFile->lastErrno = osGetLastError();
			OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, pMapRegion=%p, "
				"rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(), pFile,
				pFile->pMapRegion));
			return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,
				"winUnmapfile1", pFile->zPath);
		}
		pFile->pMapRegion = 0;
		pFile->mmapSize = 0;
		pFile->mmapSizeActual = 0;
	}
	if (pFile->hMap != NULL) {
		if (!osCloseHandle(pFile->hMap)) {
			pFile->lastErrno = osGetLastError();
			OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, rc=SQLITE_IOERR_MMAP\n",
				osGetCurrentProcessId(), pFile, pFile->hMap));
			return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,
				"winUnmapfile2", pFile->zPath);
		}
		pFile->hMap = NULL;
	}
	OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), pFile));
	return SQLITE_OK;
}


static int winMapfile(winFile *pFd, sqlite3_int64 nByte) {
	sqlite3_int64 nMap = nByte;
	int rc;

	assert(nMap >= 0 || pFd->nFetchOut == 0);
	OSTRACE(("MAP-FILE pid=%lu, pFile=%p, size=%lld\n",
		osGetCurrentProcessId(), pFd, nByte));

	if (pFd->nFetchOut>0) return SQLITE_OK;

	if (nMap<0) {
		rc = winFileSize((sqlite3_file*)pFd, &nMap);
		if (rc) {
			OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_IOERR_FSTAT\n",
				osGetCurrentProcessId(), pFd));
			return SQLITE_IOERR_FSTAT;
		}
	}
	if (nMap>pFd->mmapSizeMax) {
		nMap = pFd->mmapSizeMax;
	}
	nMap &= ~(sqlite3_int64)(winSysInfo.dwPageSize - 1);

	if (nMap == 0 && pFd->mmapSize>0) {
		winUnmapfile(pFd);
	}
	if (nMap != pFd->mmapSize) {
		void *pNew = 0;
		DWORD protect = PAGE_READONLY;
		DWORD flags = FILE_MAP_READ;

		winUnmapfile(pFd);
#ifdef SQLITE_MMAP_READWRITE
		if ((pFd->ctrlFlags & WINFILE_RDONLY) == 0) {
			protect = PAGE_READWRITE;
			flags |= FILE_MAP_WRITE;
		}
#endif
#if SQLITE_OS_WINRT
		pFd->hMap = osCreateFileMappingFromApp(pFd->h, NULL, protect, nMap, NULL);
#elif defined(SQLITE_WIN32_HAS_WIDE)
		pFd->hMap = osCreateFileMappingW(pFd->h, NULL, protect,
			(DWORD)((nMap >> 32) & 0xffffffff),
			(DWORD)(nMap & 0xffffffff), NULL);
#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGA
		pFd->hMap = osCreateFileMappingA(pFd->h, NULL, protect,
			(DWORD)((nMap >> 32) & 0xffffffff),
			(DWORD)(nMap & 0xffffffff), NULL);
#endif
		if (pFd->hMap == NULL) {
			pFd->lastErrno = osGetLastError();
			rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,
				"winMapfile1", pFd->zPath);
			
			OSTRACE(("MAP-FILE-CREATE pid=%lu, pFile=%p, rc=%s\n",
				osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));
			return SQLITE_OK;
		}
		assert((nMap % winSysInfo.dwPageSize) == 0);
		assert(sizeof(SIZE_T) == sizeof(sqlite3_int64) || nMap <= 0xffffffff);
#if SQLITE_OS_WINRT
		pNew = osMapViewOfFileFromApp(pFd->hMap, flags, 0, (SIZE_T)nMap);
#else
		pNew = osMapViewOfFile(pFd->hMap, flags, 0, 0, (SIZE_T)nMap);
#endif
		if (pNew == NULL) {
			osCloseHandle(pFd->hMap);
			pFd->hMap = NULL;
			pFd->lastErrno = osGetLastError();
			rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,
				"winMapfile2", pFd->zPath);
			
			OSTRACE(("MAP-FILE-MAP pid=%lu, pFile=%p, rc=%s\n",
				osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));
			return SQLITE_OK;
		}
		pFd->pMapRegion = pNew;
		pFd->mmapSize = nMap;
		pFd->mmapSizeActual = nMap;
	}

	OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), pFd));
	return SQLITE_OK;
}
#endif 


static int winFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp) {
#if SQLITE_MAX_MMAP_SIZE>0
	winFile *pFd = (winFile*)fd;   
#endif
	*pp = 0;

	OSTRACE(("FETCH pid=%lu, pFile=%p, offset=%lld, amount=%d, pp=%p\n",
		osGetCurrentProcessId(), fd, iOff, nAmt, pp));

#if SQLITE_MAX_MMAP_SIZE>0
	if (pFd->mmapSizeMax>0) {
		if (pFd->pMapRegion == 0) {
			int rc = winMapfile(pFd, -1);
			if (rc != SQLITE_OK) {
				OSTRACE(("FETCH pid=%lu, pFile=%p, rc=%s\n",
					osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));
				return rc;
			}
		}
		if (pFd->mmapSize >= iOff + nAmt) {
			*pp = &((u8 *)pFd->pMapRegion)[iOff];
			pFd->nFetchOut++;
		}
	}
#endif

	OSTRACE(("FETCH pid=%lu, pFile=%p, pp=%p, *pp=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), fd, pp, *pp));
	return SQLITE_OK;
}


static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p) {
#if SQLITE_MAX_MMAP_SIZE>0
	winFile *pFd = (winFile*)fd;   

								   
	assert((p == 0) == (pFd->nFetchOut == 0));

	
	assert(p == 0 || p == &((u8 *)pFd->pMapRegion)[iOff]);

	OSTRACE(("UNFETCH pid=%lu, pFile=%p, offset=%lld, p=%p\n",
		osGetCurrentProcessId(), pFd, iOff, p));

	if (p) {
		pFd->nFetchOut--;
	}
	else {
		
		winUnmapfile(pFd);
	}

	assert(pFd->nFetchOut >= 0);
#endif

	OSTRACE(("UNFETCH pid=%lu, pFile=%p, rc=SQLITE_OK\n",
		osGetCurrentProcessId(), fd));
	return SQLITE_OK;
}




static const sqlite3_io_methods winIoMethod = {
	3,                              
	winClose,                       
	winRead,                        
	winWrite,                       
	winTruncate,                    
	winSync,                        
	winFileSize,                    
	winLock,                        
	winUnlock,                      
	winCheckReservedLock,           
	winFileControl,                 
	winSectorSize,                  
	winDeviceCharacteristics,       
	winShmMap,                      
	winShmLock,                     
	winShmBarrier,                  
	winShmUnmap,                    
	winFetch,                       
	winUnfetch                      
};


static const sqlite3_io_methods winIoNolockMethod = {
	3,                              
	winClose,                       
	winRead,                        
	winWrite,                       
	winTruncate,                    
	winSync,                        
	winFileSize,                    
	winNolockLock,                  
	winNolockUnlock,                
	winNolockCheckReservedLock,     
	winFileControl,                 
	winSectorSize,                  
	winDeviceCharacteristics,       
	winShmMap,                      
	winShmLock,                     
	winShmBarrier,                  
	winShmUnmap,                    
	winFetch,                       
	winUnfetch                      
};

static winVfsAppData winAppData = {
	&winIoMethod,       
	0,                  
	0                   
};

static winVfsAppData winNolockAppData = {
	&winIoNolockMethod, 
	0,                  
	1                   
};



#if defined(__CYGWIN__)

static char *winConvertToUtf8Filename(const void *zFilename) {
	char *zConverted = 0;
	if (osIsNT()) {
		zConverted = winUnicodeToUtf8(zFilename);
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		zConverted = winMbcsToUtf8(zFilename, osAreFileApisANSI());
	}
#endif
	
	return zConverted;
}
#endif


static void *winConvertFromUtf8Filename(const char *zFilename) {
	void *zConverted = 0;
	if (osIsNT()) {
		zConverted = winUtf8ToUnicode(zFilename);
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());
	}
#endif
	
	return zConverted;
}


static int winMakeEndInDirSep(int nBuf, char *zBuf) {
	if (zBuf) {
		int nLen = sqlite3Strlen30(zBuf);
		if (nLen>0) {
			if (winIsDirSep(zBuf[nLen - 1])) {
				return 1;
			}
			else if (nLen + 1<nBuf) {
				zBuf[nLen] = winGetDirSep();
				zBuf[nLen + 1] = '\0';
				return 1;
			}
		}
	}
	return 0;
}


static int winGetTempname(sqlite3_vfs *pVfs, char **pzBuf) {
	static char zChars[] =
		"abcdefghijklmnopqrstuvwxyz"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"0123456789";
	size_t i, j;
	int nPre = sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX);
	int nMax, nBuf, nDir, nLen;
	char *zBuf;

	
	SimulateIOError(return SQLITE_IOERR);

	
	nMax = pVfs->mxPathname; nBuf = nMax + 2;
	zBuf = sqlite3MallocZero(nBuf);
	if (!zBuf) {
		OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
		return SQLITE_IOERR_NOMEM_BKPT;
	}

	
	nDir = nMax - (nPre + 15);
	assert(nDir>0);
	if (sqlite3_temp_directory) {
		int nDirLen = sqlite3Strlen30(sqlite3_temp_directory);
		if (nDirLen>0) {
			if (!winIsDirSep(sqlite3_temp_directory[nDirLen - 1])) {
				nDirLen++;
			}
			if (nDirLen>nDir) {
				sqlite3_free(zBuf);
				OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
				return winLogError(SQLITE_ERROR, 0, "winGetTempname1", 0);
			}
			sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);
		}
	}
#if defined(__CYGWIN__)
	else {
		static const char *azDirs[] = {
			0, 
			0, 
			0, 
			0, 
			0, 
			"/var/tmp",
			"/usr/tmp",
			"/tmp",
			".",
			0        
		};
		unsigned int i;
		const char *zDir = 0;

		if (!azDirs[0]) azDirs[0] = getenv("SQLITE_TMPDIR");
		if (!azDirs[1]) azDirs[1] = getenv("TMPDIR");
		if (!azDirs[2]) azDirs[2] = getenv("TMP");
		if (!azDirs[3]) azDirs[3] = getenv("TEMP");
		if (!azDirs[4]) azDirs[4] = getenv("USERPROFILE");
		for (i = 0; i<sizeof(azDirs) / sizeof(azDirs[0]); zDir = azDirs[i++]) {
			void *zConverted;
			if (zDir == 0) continue;
			
			if (winIsDriveLetterAndColon(zDir)) {
				zConverted = winConvertFromUtf8Filename(zDir);
				if (!zConverted) {
					sqlite3_free(zBuf);
					OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
					return SQLITE_IOERR_NOMEM_BKPT;
				}
				if (winIsDir(zConverted)) {
					sqlite3_snprintf(nMax, zBuf, "%s", zDir);
					sqlite3_free(zConverted);
					break;
				}
				sqlite3_free(zConverted);
			}
			else {
				zConverted = sqlite3MallocZero(nMax + 1);
				if (!zConverted) {
					sqlite3_free(zBuf);
					OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
					return SQLITE_IOERR_NOMEM_BKPT;
				}
				if (cygwin_conv_path(
					osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,
					zConverted, nMax + 1)<0) {
					sqlite3_free(zConverted);
					sqlite3_free(zBuf);
					OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"));
					return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,
						"winGetTempname2", zDir);
				}
				if (winIsDir(zConverted)) {
					
					char *zUtf8 = winConvertToUtf8Filename(zConverted);
					if (!zUtf8) {
						sqlite3_free(zConverted);
						sqlite3_free(zBuf);
						OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
						return SQLITE_IOERR_NOMEM_BKPT;
					}
					sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);
					sqlite3_free(zUtf8);
					sqlite3_free(zConverted);
					break;
				}
				sqlite3_free(zConverted);
			}
		}
	}
#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)
	else if (osIsNT()) {
		char *zMulti;
		LPWSTR zWidePath = sqlite3MallocZero(nMax * sizeof(WCHAR));
		if (!zWidePath) {
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		if (osGetTempPathW(nMax, zWidePath) == 0) {
			sqlite3_free(zWidePath);
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));
			return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),
				"winGetTempname2", 0);
		}
		zMulti = winUnicodeToUtf8(zWidePath);
		if (zMulti) {
			sqlite3_snprintf(nMax, zBuf, "%s", zMulti);
			sqlite3_free(zMulti);
			sqlite3_free(zWidePath);
		}
		else {
			sqlite3_free(zWidePath);
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
			return SQLITE_IOERR_NOMEM_BKPT;
		}
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		char *zUtf8;
		char *zMbcsPath = sqlite3MallocZero(nMax);
		if (!zMbcsPath) {
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		if (osGetTempPathA(nMax, zMbcsPath) == 0) {
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));
			return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),
				"winGetTempname3", 0);
		}
		zUtf8 = winMbcsToUtf8(zMbcsPath, osAreFileApisANSI());
		if (zUtf8) {
			sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);
			sqlite3_free(zUtf8);
		}
		else {
			sqlite3_free(zBuf);
			OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
			return SQLITE_IOERR_NOMEM_BKPT;
		}
	}
#endif 
#endif 

	
	if (!winMakeEndInDirSep(nDir + 1, zBuf)) {
		sqlite3_free(zBuf);
		OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
		return winLogError(SQLITE_ERROR, 0, "winGetTempname4", 0);
	}

	
	nLen = sqlite3Strlen30(zBuf);
	if ((nLen + nPre + 17) > nBuf) {
		sqlite3_free(zBuf);
		OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
		return winLogError(SQLITE_ERROR, 0, "winGetTempname5", 0);
	}

	sqlite3_snprintf(nBuf - 16 - nLen, zBuf + nLen, SQLITE_TEMP_FILE_PREFIX);

	j = sqlite3Strlen30(zBuf);
	sqlite3_randomness(15, &zBuf[j]);
	for (i = 0; i<15; i++, j++) {
		zBuf[j] = (char)zChars[((unsigned char)zBuf[j]) % (sizeof(zChars) - 1)];
	}
	zBuf[j] = 0;
	zBuf[j + 1] = 0;
	*pzBuf = zBuf;

	OSTRACE(("TEMP-FILENAME name=%s, rc=SQLITE_OK\n", zBuf));
	return SQLITE_OK;
}


static int winIsDir(const void *zConverted) {
	DWORD attr;
	int rc = 0;
	DWORD lastErrno;

	if (osIsNT()) {
		int cnt = 0;
		WIN32_FILE_ATTRIBUTE_DATA sAttrData;
		memset(&sAttrData, 0, sizeof(sAttrData));
		while (!(rc = osGetFileAttributesExW((LPCWSTR)zConverted,
			GetFileExInfoStandard,
			&sAttrData)) && winRetryIoerr(&cnt, &lastErrno)) {
		}
		if (!rc) {
			return 0; 
		}
		attr = sAttrData.dwFileAttributes;
#if SQLITE_OS_WINCE==0
	}
	else {
		attr = osGetFileAttributesA((char*)zConverted);
#endif
	}
	return (attr != INVALID_FILE_ATTRIBUTES) && (attr&FILE_ATTRIBUTE_DIRECTORY);
}


static int winOpen(
	sqlite3_vfs *pVfs,        
	const char *zName,        
	sqlite3_file *id,         
	int flags,                
	int *pOutFlags            
) {
	HANDLE h;
	DWORD lastErrno = 0;
	DWORD dwDesiredAccess;
	DWORD dwShareMode;
	DWORD dwCreationDisposition;
	DWORD dwFlagsAndAttributes = 0;
#if SQLITE_OS_WINCE
	int isTemp = 0;
#endif
	winVfsAppData *pAppData;
	winFile *pFile = (winFile*)id;
	void *zConverted;              
	const char *zUtf8Name = zName; 
	int cnt = 0;

	
	char *zTmpname = 0; 

	int rc = SQLITE_OK;            
#if !defined(NDEBUG) || SQLITE_OS_WINCE
	int eType = flags & 0xFFFFFF00;  
#endif

	int isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE);
	int isDelete = (flags & SQLITE_OPEN_DELETEONCLOSE);
	int isCreate = (flags & SQLITE_OPEN_CREATE);
	int isReadonly = (flags & SQLITE_OPEN_READONLY);
	int isReadWrite = (flags & SQLITE_OPEN_READWRITE);

#ifndef NDEBUG
	int isOpenJournal = (isCreate && (
		eType == SQLITE_OPEN_MASTER_JOURNAL
		|| eType == SQLITE_OPEN_MAIN_JOURNAL
		|| eType == SQLITE_OPEN_WAL
		));
#endif

	OSTRACE(("OPEN name=%s, pFile=%p, flags=%x, pOutFlags=%p\n",
		zUtf8Name, id, flags, pOutFlags));

	
	assert((isReadonly == 0 || isReadWrite == 0) && (isReadWrite || isReadonly));
	assert(isCreate == 0 || isReadWrite);
	assert(isExclusive == 0 || isCreate);
	assert(isDelete == 0 || isCreate);

	
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MAIN_DB);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MAIN_JOURNAL);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_MASTER_JOURNAL);
	assert((!isDelete && zName) || eType != SQLITE_OPEN_WAL);

	
	assert(eType == SQLITE_OPEN_MAIN_DB || eType == SQLITE_OPEN_TEMP_DB
		|| eType == SQLITE_OPEN_MAIN_JOURNAL || eType == SQLITE_OPEN_TEMP_JOURNAL
		|| eType == SQLITE_OPEN_SUBJOURNAL || eType == SQLITE_OPEN_MASTER_JOURNAL
		|| eType == SQLITE_OPEN_TRANSIENT_DB || eType == SQLITE_OPEN_WAL
	);

	assert(pFile != 0);
	memset(pFile, 0, sizeof(winFile));
	pFile->h = INVALID_HANDLE_VALUE;

#if SQLITE_OS_WINRT
	if (!zUtf8Name && !sqlite3_temp_directory) {
		sqlite3_log(SQLITE_ERROR,
			"sqlite3_temp_directory variable should be set for WinRT");
	}
#endif

	
	if (!zUtf8Name) {
		assert(isDelete && !isOpenJournal);
		rc = winGetTempname(pVfs, &zTmpname);
		if (rc != SQLITE_OK) {
			OSTRACE(("OPEN name=%s, rc=%s", zUtf8Name, sqlite3ErrName(rc)));
			return rc;
		}
		zUtf8Name = zTmpname;
	}

	
	assert((eType != SQLITE_OPEN_MAIN_DB) || (flags & SQLITE_OPEN_URI) ||
		zUtf8Name[sqlite3Strlen30(zUtf8Name) + 1] == 0);

	
	zConverted = winConvertFromUtf8Filename(zUtf8Name);
	if (zConverted == 0) {
		sqlite3_free(zTmpname);
		OSTRACE(("OPEN name=%s, rc=SQLITE_IOERR_NOMEM", zUtf8Name));
		return SQLITE_IOERR_NOMEM_BKPT;
	}

	if (winIsDir(zConverted)) {
		sqlite3_free(zConverted);
		sqlite3_free(zTmpname);
		OSTRACE(("OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR", zUtf8Name));
		return SQLITE_CANTOPEN_ISDIR;
	}

	if (isReadWrite) {
		dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
	}
	else {
		dwDesiredAccess = GENERIC_READ;
	}

	
	if (isExclusive) {
		
		
		dwCreationDisposition = CREATE_NEW;
	}
	else if (isCreate) {
		
		dwCreationDisposition = OPEN_ALWAYS;
	}
	else {
		
		dwCreationDisposition = OPEN_EXISTING;
	}

	dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

	if (isDelete) {
#if SQLITE_OS_WINCE
		dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;
		isTemp = 1;
#else
		dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARY
			| FILE_ATTRIBUTE_HIDDEN
			| FILE_FLAG_DELETE_ON_CLOSE;
#endif
	}
	else {
		dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	}
	
#if SQLITE_OS_WINCE
	dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
#endif

	if (osIsNT()) {
#if SQLITE_OS_WINRT
		CREATEFILE2_EXTENDED_PARAMETERS extendedParameters;
		extendedParameters.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
		extendedParameters.dwFileAttributes =
			dwFlagsAndAttributes & FILE_ATTRIBUTE_MASK;
		extendedParameters.dwFileFlags = dwFlagsAndAttributes & FILE_FLAG_MASK;
		extendedParameters.dwSecurityQosFlags = SECURITY_ANONYMOUS;
		extendedParameters.lpSecurityAttributes = NULL;
		extendedParameters.hTemplateFile = NULL;
		while ((h = osCreateFile2((LPCWSTR)zConverted,
			dwDesiredAccess,
			dwShareMode,
			dwCreationDisposition,
			&extendedParameters)) == INVALID_HANDLE_VALUE &&
			winRetryIoerr(&cnt, &lastErrno)) {
			
		}
#else
		while ((h = osCreateFileW((LPCWSTR)zConverted,
			dwDesiredAccess,
			dwShareMode, NULL,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			NULL)) == INVALID_HANDLE_VALUE &&
			winRetryIoerr(&cnt, &lastErrno)) {
			
		}
#endif
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		while ((h = osCreateFileA((LPCSTR)zConverted,
			dwDesiredAccess,
			dwShareMode, NULL,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			NULL)) == INVALID_HANDLE_VALUE &&
			winRetryIoerr(&cnt, &lastErrno)) {
			
		}
	}
#endif
	winLogIoerr(cnt, __LINE__);

	OSTRACE(("OPEN file=%p, name=%s, access=%lx, rc=%s\n", h, zUtf8Name,
		dwDesiredAccess, (h == INVALID_HANDLE_VALUE) ? "failed" : "ok"));

	if (h == INVALID_HANDLE_VALUE) {
		pFile->lastErrno = lastErrno;
		winLogError(SQLITE_CANTOPEN, pFile->lastErrno, "winOpen", zUtf8Name);
		sqlite3_free(zConverted);
		sqlite3_free(zTmpname);
		if (isReadWrite && !isExclusive) {
			return winOpen(pVfs, zName, id,
				((flags | SQLITE_OPEN_READONLY) &
					~(SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE)),
				pOutFlags);
		}
		else {
			return SQLITE_CANTOPEN_BKPT;
		}
	}

	if (pOutFlags) {
		if (isReadWrite) {
			*pOutFlags = SQLITE_OPEN_READWRITE;
		}
		else {
			*pOutFlags = SQLITE_OPEN_READONLY;
		}
	}

	OSTRACE(("OPEN file=%p, name=%s, access=%lx, pOutFlags=%p, *pOutFlags=%d, "
		"rc=%s\n", h, zUtf8Name, dwDesiredAccess, pOutFlags, pOutFlags ?
		*pOutFlags : 0, (h == INVALID_HANDLE_VALUE) ? "failed" : "ok"));

	pAppData = (winVfsAppData*)pVfs->pAppData;

#if SQLITE_OS_WINCE
	{
		if (isReadWrite && eType == SQLITE_OPEN_MAIN_DB
			&& ((pAppData == NULL) || !pAppData->bNoLock)
			&& (rc = winceCreateLock(zName, pFile)) != SQLITE_OK
			) {
			osCloseHandle(h);
			sqlite3_free(zConverted);
			sqlite3_free(zTmpname);
			OSTRACE(("OPEN-CE-LOCK name=%s, rc=%s\n", zName, sqlite3ErrName(rc)));
			return rc;
		}
	}
	if (isTemp) {
		pFile->zDeleteOnClose = zConverted;
	}
	else
#endif
	{
		sqlite3_free(zConverted);
	}

	sqlite3_free(zTmpname);
	pFile->pMethod = pAppData ? pAppData->pMethod : &winIoMethod;
	pFile->pVfs = pVfs;
	pFile->h = h;
	if (isReadonly) {
		pFile->ctrlFlags |= WINFILE_RDONLY;
	}
	if (sqlite3_uri_boolean(zName, "psow", SQLITE_POWERSAFE_OVERWRITE)) {
		pFile->ctrlFlags |= WINFILE_PSOW;
	}
	pFile->lastErrno = NO_ERROR;
	pFile->zPath = zName;
#if SQLITE_MAX_MMAP_SIZE>0
	pFile->hMap = NULL;
	pFile->pMapRegion = 0;
	pFile->mmapSize = 0;
	pFile->mmapSizeActual = 0;
	pFile->mmapSizeMax = sqlite3GlobalConfig.szMmap;
#endif

	OpenCounter(+1);
	return rc;
}


static int winDelete(
	sqlite3_vfs *pVfs,          
	const char *zFilename,      
	int syncDir                 
) {
	int cnt = 0;
	int rc;
	DWORD attr;
	DWORD lastErrno = 0;
	void *zConverted;
	UNUSED_PARAMETER(pVfs);
	UNUSED_PARAMETER(syncDir);

	SimulateIOError(return SQLITE_IOERR_DELETE);
	OSTRACE(("DELETE name=%s, syncDir=%d\n", zFilename, syncDir));

	zConverted = winConvertFromUtf8Filename(zFilename);
	if (zConverted == 0) {
		OSTRACE(("DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));
		return SQLITE_IOERR_NOMEM_BKPT;
	}
	if (osIsNT()) {
		do {
#if SQLITE_OS_WINRT
			WIN32_FILE_ATTRIBUTE_DATA sAttrData;
			memset(&sAttrData, 0, sizeof(sAttrData));
			if (osGetFileAttributesExW(zConverted, GetFileExInfoStandard,
				&sAttrData)) {
				attr = sAttrData.dwFileAttributes;
			}
			else {
				lastErrno = osGetLastError();
				if (lastErrno == ERROR_FILE_NOT_FOUND
					|| lastErrno == ERROR_PATH_NOT_FOUND) {
					rc = SQLITE_IOERR_DELETE_NOENT; 
				}
				else {
					rc = SQLITE_ERROR;
				}
				break;
			}
#else
			attr = osGetFileAttributesW(zConverted);
#endif
			if (attr == INVALID_FILE_ATTRIBUTES) {
				lastErrno = osGetLastError();
				if (lastErrno == ERROR_FILE_NOT_FOUND
					|| lastErrno == ERROR_PATH_NOT_FOUND) {
					rc = SQLITE_IOERR_DELETE_NOENT; 
				}
				else {
					rc = SQLITE_ERROR;
				}
				break;
			}
			if (attr&FILE_ATTRIBUTE_DIRECTORY) {
				rc = SQLITE_ERROR; 
				break;
			}
			if (osDeleteFileW(zConverted)) {
				rc = SQLITE_OK; 
				break;
			}
			if (!winRetryIoerr(&cnt, &lastErrno)) {
				rc = SQLITE_ERROR; 
				break;
			}
		} while (1);
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		do {
			attr = osGetFileAttributesA(zConverted);
			if (attr == INVALID_FILE_ATTRIBUTES) {
				lastErrno = osGetLastError();
				if (lastErrno == ERROR_FILE_NOT_FOUND
					|| lastErrno == ERROR_PATH_NOT_FOUND) {
					rc = SQLITE_IOERR_DELETE_NOENT; 
				}
				else {
					rc = SQLITE_ERROR;
				}
				break;
			}
			if (attr&FILE_ATTRIBUTE_DIRECTORY) {
				rc = SQLITE_ERROR; 
				break;
			}
			if (osDeleteFileA(zConverted)) {
				rc = SQLITE_OK; 
				break;
			}
			if (!winRetryIoerr(&cnt, &lastErrno)) {
				rc = SQLITE_ERROR; 
				break;
			}
		} while (1);
	}
#endif
	if (rc && rc != SQLITE_IOERR_DELETE_NOENT) {
		rc = winLogError(SQLITE_IOERR_DELETE, lastErrno, "winDelete", zFilename);
	}
	else {
		winLogIoerr(cnt, __LINE__);
	}
	sqlite3_free(zConverted);
	OSTRACE(("DELETE name=%s, rc=%s\n", zFilename, sqlite3ErrName(rc)));
	return rc;
}


static int winAccess(
	sqlite3_vfs *pVfs,         
	const char *zFilename,     
	int flags,                 
	int *pResOut               
) {
	DWORD attr;
	int rc = 0;
	DWORD lastErrno = 0;
	void *zConverted;
	UNUSED_PARAMETER(pVfs);

	SimulateIOError(return SQLITE_IOERR_ACCESS; );
	OSTRACE(("ACCESS name=%s, flags=%x, pResOut=%p\n",
		zFilename, flags, pResOut));

	zConverted = winConvertFromUtf8Filename(zFilename);
	if (zConverted == 0) {
		OSTRACE(("ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));
		return SQLITE_IOERR_NOMEM_BKPT;
	}
	if (osIsNT()) {
		int cnt = 0;
		WIN32_FILE_ATTRIBUTE_DATA sAttrData;
		memset(&sAttrData, 0, sizeof(sAttrData));
		while (!(rc = osGetFileAttributesExW((LPCWSTR)zConverted,
			GetFileExInfoStandard,
			&sAttrData)) && winRetryIoerr(&cnt, &lastErrno)) {
		}
		if (rc) {
			
			if (flags == SQLITE_ACCESS_EXISTS
				&& sAttrData.nFileSizeHigh == 0
				&& sAttrData.nFileSizeLow == 0) {
				attr = INVALID_FILE_ATTRIBUTES;
			}
			else {
				attr = sAttrData.dwFileAttributes;
			}
		}
		else {
			winLogIoerr(cnt, __LINE__);
			if (lastErrno != ERROR_FILE_NOT_FOUND && lastErrno != ERROR_PATH_NOT_FOUND) {
				sqlite3_free(zConverted);
				return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",
					zFilename);
			}
			else {
				attr = INVALID_FILE_ATTRIBUTES;
			}
		}
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		attr = osGetFileAttributesA((char*)zConverted);
	}
#endif
	sqlite3_free(zConverted);
	switch (flags) {
	case SQLITE_ACCESS_READ:
	case SQLITE_ACCESS_EXISTS:
		rc = attr != INVALID_FILE_ATTRIBUTES;
		break;
	case SQLITE_ACCESS_READWRITE:
		rc = attr != INVALID_FILE_ATTRIBUTES &&
			(attr & FILE_ATTRIBUTE_READONLY) == 0;
		break;
	default:
		assert(!"Invalid flags argument");
	}
	*pResOut = rc;
	OSTRACE(("ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",
		zFilename, pResOut, *pResOut));
	return SQLITE_OK;
}


static BOOL winIsDriveLetterAndColon(
	const char *zPathname
) {
	return (sqlite3Isalpha(zPathname[0]) && zPathname[1] == ':');
}


static BOOL winIsVerbatimPathname(
	const char *zPathname
) {
	
	if (winIsDirSep(zPathname[0])) {
		return TRUE;
	}

	
	if (winIsDriveLetterAndColon(zPathname)) {
		return TRUE;
	}

	
	return FALSE;
}


static int winFullPathname(
	sqlite3_vfs *pVfs,            
	const char *zRelative,        
	int nFull,                    
	char *zFull                   
) {
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
	DWORD nByte;
	void *zConverted;
	char *zOut;
#endif

	
	if (zRelative[0] == '/' && winIsDriveLetterAndColon(zRelative + 1)) {
		zRelative++;
	}

#if defined(__CYGWIN__)
	SimulateIOError(return SQLITE_ERROR);
	UNUSED_PARAMETER(nFull);
	assert(nFull >= pVfs->mxPathname);
	if (sqlite3_data_directory && !winIsVerbatimPathname(zRelative)) {
		
		char *zOut = sqlite3MallocZero(pVfs->mxPathname + 1);
		if (!zOut) {
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		if (cygwin_conv_path(
			(osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A) |
			CCP_RELATIVE, zRelative, zOut, pVfs->mxPathname + 1)<0) {
			sqlite3_free(zOut);
			return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,
				"winFullPathname1", zRelative);
		}
		else {
			char *zUtf8 = winConvertToUtf8Filename(zOut);
			if (!zUtf8) {
				sqlite3_free(zOut);
				return SQLITE_IOERR_NOMEM_BKPT;
			}
			sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
				sqlite3_data_directory, winGetDirSep(), zUtf8);
			sqlite3_free(zUtf8);
			sqlite3_free(zOut);
		}
	}
	else {
		char *zOut = sqlite3MallocZero(pVfs->mxPathname + 1);
		if (!zOut) {
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		if (cygwin_conv_path(
			(osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A),
			zRelative, zOut, pVfs->mxPathname + 1)<0) {
			sqlite3_free(zOut);
			return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,
				"winFullPathname2", zRelative);
		}
		else {
			char *zUtf8 = winConvertToUtf8Filename(zOut);
			if (!zUtf8) {
				sqlite3_free(zOut);
				return SQLITE_IOERR_NOMEM_BKPT;
			}
			sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zUtf8);
			sqlite3_free(zUtf8);
			sqlite3_free(zOut);
		}
	}
	return SQLITE_OK;
#endif

#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && !defined(__CYGWIN__)
	SimulateIOError(return SQLITE_ERROR);
	
	
	if (sqlite3_data_directory && !winIsVerbatimPathname(zRelative)) {
		
		sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
			sqlite3_data_directory, winGetDirSep(), zRelative);
	}
	else {
		sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zRelative);
	}
	return SQLITE_OK;
#endif

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
	
	SimulateIOError(return SQLITE_ERROR);
	if (sqlite3_data_directory && !winIsVerbatimPathname(zRelative)) {
		
		sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
			sqlite3_data_directory, winGetDirSep(), zRelative);
		return SQLITE_OK;
	}
	zConverted = winConvertFromUtf8Filename(zRelative);
	if (zConverted == 0) {
		return SQLITE_IOERR_NOMEM_BKPT;
	}
	if (osIsNT()) {
		LPWSTR zTemp;
		nByte = osGetFullPathNameW((LPCWSTR)zConverted, 0, 0, 0);
		if (nByte == 0) {
			sqlite3_free(zConverted);
			return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),
				"winFullPathname1", zRelative);
		}
		nByte += 3;
		zTemp = sqlite3MallocZero(nByte * sizeof(zTemp[0]));
		if (zTemp == 0) {
			sqlite3_free(zConverted);
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		nByte = osGetFullPathNameW((LPCWSTR)zConverted, nByte, zTemp, 0);
		if (nByte == 0) {
			sqlite3_free(zConverted);
			sqlite3_free(zTemp);
			return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),
				"winFullPathname2", zRelative);
		}
		sqlite3_free(zConverted);
		zOut = winUnicodeToUtf8(zTemp);
		sqlite3_free(zTemp);
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		char *zTemp;
		nByte = osGetFullPathNameA((char*)zConverted, 0, 0, 0);
		if (nByte == 0) {
			sqlite3_free(zConverted);
			return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),
				"winFullPathname3", zRelative);
		}
		nByte += 3;
		zTemp = sqlite3MallocZero(nByte * sizeof(zTemp[0]));
		if (zTemp == 0) {
			sqlite3_free(zConverted);
			return SQLITE_IOERR_NOMEM_BKPT;
		}
		nByte = osGetFullPathNameA((char*)zConverted, nByte, zTemp, 0);
		if (nByte == 0) {
			sqlite3_free(zConverted);
			sqlite3_free(zTemp);
			return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),
				"winFullPathname4", zRelative);
		}
		sqlite3_free(zConverted);
		zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());
		sqlite3_free(zTemp);
	}
#endif
	if (zOut) {
		sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zOut);
		sqlite3_free(zOut);
		return SQLITE_OK;
	}
	else {
		return SQLITE_IOERR_NOMEM_BKPT;
	}
#endif
}

#ifndef SQLITE_OMIT_LOAD_EXTENSION

static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename) {
	HANDLE h;
#if defined(__CYGWIN__)
	int nFull = pVfs->mxPathname + 1;
	char *zFull = sqlite3MallocZero(nFull);
	void *zConverted = 0;
	if (zFull == 0) {
		OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));
		return 0;
	}
	if (winFullPathname(pVfs, zFilename, nFull, zFull) != SQLITE_OK) {
		sqlite3_free(zFull);
		OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));
		return 0;
	}
	zConverted = winConvertFromUtf8Filename(zFull);
	sqlite3_free(zFull);
#else
	void *zConverted = winConvertFromUtf8Filename(zFilename);
	UNUSED_PARAMETER(pVfs);
#endif
	if (zConverted == 0) {
		OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));
		return 0;
	}
	if (osIsNT()) {
#if SQLITE_OS_WINRT
		h = osLoadPackagedLibrary((LPCWSTR)zConverted, 0);
#else
		h = osLoadLibraryW((LPCWSTR)zConverted);
#endif
	}
#ifdef SQLITE_WIN32_HAS_ANSI
	else {
		h = osLoadLibraryA((char*)zConverted);
	}
#endif
	OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)h));
	sqlite3_free(zConverted);
	return (void*)h;
}
static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut) {
	UNUSED_PARAMETER(pVfs);
	winGetLastErrorMsg(osGetLastError(), nBuf, zBufOut);
}
static void(*winDlSym(sqlite3_vfs *pVfs, void *pH, const char *zSym))(void) {
	FARPROC proc;
	UNUSED_PARAMETER(pVfs);
	proc = osGetProcAddressA((HANDLE)pH, zSym);
	OSTRACE(("DLSYM handle=%p, symbol=%s, address=%p\n",
		(void*)pH, zSym, (void*)proc));
	return (void(*)(void))proc;
}
static void winDlClose(sqlite3_vfs *pVfs, void *pHandle) {
	UNUSED_PARAMETER(pVfs);
	osFreeLibrary((HANDLE)pHandle);
	OSTRACE(("DLCLOSE handle=%p\n", (void*)pHandle));
}
#else 
#define winDlOpen  0
#define winDlError 0
#define winDlSym   0
#define winDlClose 0
#endif


typedef struct EntropyGatherer EntropyGatherer;
struct EntropyGatherer {
	unsigned char *a;   
	int na;             
	int i;              
	int nXor;           
};

#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)

static void xorMemory(EntropyGatherer *p, unsigned char *x, int sz) {
	int j, k;
	for (j = 0, k = p->i; j<sz; j++) {
		p->a[k++] ^= x[j];
		if (k >= p->na) k = 0;
	}
	p->i = k;
	p->nXor += sz;
}
#endif 


static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf) {
#if defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS)
	UNUSED_PARAMETER(pVfs);
	memset(zBuf, 0, nBuf);
	return nBuf;
#else
	EntropyGatherer e;
	UNUSED_PARAMETER(pVfs);
	memset(zBuf, 0, nBuf);
#if defined(_MSC_VER) && _MSC_VER>=1400 && !SQLITE_OS_WINCE
	rand_s((unsigned int*)zBuf); 
#endif 
	e.a = (unsigned char*)zBuf;
	e.na = nBuf;
	e.nXor = 0;
	e.i = 0;
	{
		SYSTEMTIME x;
		osGetSystemTime(&x);
		xorMemory(&e, (unsigned char*)&x, sizeof(SYSTEMTIME));
	}
	{
		DWORD pid = osGetCurrentProcessId();
		xorMemory(&e, (unsigned char*)&pid, sizeof(DWORD));
	}
#if SQLITE_OS_WINRT
	{
		ULONGLONG cnt = osGetTickCount64();
		xorMemory(&e, (unsigned char*)&cnt, sizeof(ULONGLONG));
	}
#else
	{
		DWORD cnt = osGetTickCount();
		xorMemory(&e, (unsigned char*)&cnt, sizeof(DWORD));
	}
#endif 
	{
		LARGE_INTEGER i;
		osQueryPerformanceCounter(&i);
		xorMemory(&e, (unsigned char*)&i, sizeof(LARGE_INTEGER));
	}
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
	{
		UUID id;
		memset(&id, 0, sizeof(UUID));
		osUuidCreate(&id);
		xorMemory(&e, (unsigned char*)&id, sizeof(UUID));
		memset(&id, 0, sizeof(UUID));
		osUuidCreateSequential(&id);
		xorMemory(&e, (unsigned char*)&id, sizeof(UUID));
	}
#endif 
	return e.nXor>nBuf ? nBuf : e.nXor;
#endif 
}



static int winSleep(sqlite3_vfs *pVfs, int microsec) {
	sqlite3_win32_sleep((microsec + 999) / 1000);
	UNUSED_PARAMETER(pVfs);
	return ((microsec + 999) / 1000) * 1000;
}


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_current_time = 0;  
#endif

										  
static int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow) {
	
	FILETIME ft;
	static const sqlite3_int64 winFiletimeEpoch = 23058135 * (sqlite3_int64)8640000;
#ifdef SQLITE_TEST
	static const sqlite3_int64 unixEpoch = 24405875 * (sqlite3_int64)8640000;
#endif
	
	static const sqlite3_int64 max32BitValue =
		(sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 +
		(sqlite3_int64)294967296;

#if SQLITE_OS_WINCE
	SYSTEMTIME time;
	osGetSystemTime(&time);
	
	if (!osSystemTimeToFileTime(&time, &ft)) {
		return SQLITE_ERROR;
	}
#else
	osGetSystemTimeAsFileTime(&ft);
#endif

	*piNow = winFiletimeEpoch +
		((((sqlite3_int64)ft.dwHighDateTime)*max32BitValue) +
		(sqlite3_int64)ft.dwLowDateTime) / (sqlite3_int64)10000;

#ifdef SQLITE_TEST
	if (sqlite3_current_time) {
		*piNow = 1000 * (sqlite3_int64)sqlite3_current_time + unixEpoch;
	}
#endif
	UNUSED_PARAMETER(pVfs);
	return SQLITE_OK;
}


static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow) {
	int rc;
	sqlite3_int64 i;
	rc = winCurrentTimeInt64(pVfs, &i);
	if (!rc) {
		*prNow = i / 86400000.0;
	}
	return rc;
}


static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf) {
	DWORD e = osGetLastError();
	UNUSED_PARAMETER(pVfs);
	if (nBuf>0) winGetLastErrorMsg(e, nBuf, zBuf);
	return e;
}


SQLITE_API int sqlite3_os_init(void) {
	static sqlite3_vfs winVfs = {
		3,                     
		sizeof(winFile),       
		SQLITE_WIN32_MAX_PATH_BYTES, 
		0,                     
		"win32",               
		&winAppData,           
		winOpen,               
		winDelete,             
		winAccess,             
		winFullPathname,       
		winDlOpen,             
		winDlError,            
		winDlSym,              
		winDlClose,            
		winRandomness,         
		winSleep,              
		winCurrentTime,        
		winGetLastError,       
		winCurrentTimeInt64,   
		winSetSystemCall,      
		winGetSystemCall,      
		winNextSystemCall,     
	};
#if defined(SQLITE_WIN32_HAS_WIDE)
	static sqlite3_vfs winLongPathVfs = {
		3,                     
		sizeof(winFile),       
		SQLITE_WINNT_MAX_PATH_BYTES, 
		0,                     
		"win32-longpath",      
		&winAppData,           
		winOpen,               
		winDelete,             
		winAccess,             
		winFullPathname,       
		winDlOpen,             
		winDlError,            
		winDlSym,              
		winDlClose,            
		winRandomness,         
		winSleep,              
		winCurrentTime,        
		winGetLastError,       
		winCurrentTimeInt64,   
		winSetSystemCall,      
		winGetSystemCall,      
		winNextSystemCall,     
	};
#endif
	static sqlite3_vfs winNolockVfs = {
		3,                     
		sizeof(winFile),       
		SQLITE_WIN32_MAX_PATH_BYTES, 
		0,                     
		"win32-none",          
		&winNolockAppData,     
		winOpen,               
		winDelete,             
		winAccess,             
		winFullPathname,       
		winDlOpen,             
		winDlError,            
		winDlSym,              
		winDlClose,            
		winRandomness,         
		winSleep,              
		winCurrentTime,        
		winGetLastError,       
		winCurrentTimeInt64,   
		winSetSystemCall,      
		winGetSystemCall,      
		winNextSystemCall,     
	};
#if defined(SQLITE_WIN32_HAS_WIDE)
	static sqlite3_vfs winLongPathNolockVfs = {
		3,                     
		sizeof(winFile),       
		SQLITE_WINNT_MAX_PATH_BYTES, 
		0,                     
		"win32-longpath-none", 
		&winNolockAppData,     
		winOpen,               
		winDelete,             
		winAccess,             
		winFullPathname,       
		winDlOpen,             
		winDlError,            
		winDlSym,              
		winDlClose,            
		winRandomness,         
		winSleep,              
		winCurrentTime,        
		winGetLastError,       
		winCurrentTimeInt64,   
		winSetSystemCall,      
		winGetSystemCall,      
		winNextSystemCall,     
	};
#endif

	
	assert(ArraySize(aSyscall) == 80);

	
	memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
#if SQLITE_OS_WINRT
	osGetNativeSystemInfo(&winSysInfo);
#else
	osGetSystemInfo(&winSysInfo);
#endif
	assert(winSysInfo.dwAllocationGranularity>0);
	assert(winSysInfo.dwPageSize>0);

	sqlite3_vfs_register(&winVfs, 1);

#if defined(SQLITE_WIN32_HAS_WIDE)
	sqlite3_vfs_register(&winLongPathVfs, 0);
#endif

	sqlite3_vfs_register(&winNolockVfs, 0);

#if defined(SQLITE_WIN32_HAS_WIDE)
	sqlite3_vfs_register(&winLongPathNolockVfs, 0);
#endif

	return SQLITE_OK;
}

SQLITE_API int sqlite3_os_end(void) {
#if SQLITE_OS_WINRT
	if (sleepObj != NULL) {
		osCloseHandle(sleepObj);
		sleepObj = NULL;
	}
#endif
	return SQLITE_OK;
}

#endif 







#define BITVEC_SZ        512


#define BITVEC_USIZE \
    (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))


#define BITVEC_TELEM     u8

#define BITVEC_SZELEM    8

#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))

#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)


#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))

#define BITVEC_MXHASH    (BITVEC_NINT/2)

#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)

#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))



struct Bitvec {
	u32 iSize;      
	u32 nSet;       
	u32 iDivisor;   
					
					
					
	union {
		BITVEC_TELEM aBitmap[BITVEC_NELEM];    
		u32 aHash[BITVEC_NINT];      
		Bitvec *apSub[BITVEC_NPTR];  
	} u;
};


SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize) {
	Bitvec *p;
	assert(sizeof(*p) == BITVEC_SZ);
	p = sqlite3MallocZero(sizeof(*p));
	if (p) {
		p->iSize = iSize;
	}
	return p;
}


SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec *p, u32 i) {
	assert(p != 0);
	i--;
	if (i >= p->iSize) return 0;
	while (p->iDivisor) {
		u32 bin = i / p->iDivisor;
		i = i%p->iDivisor;
		p = p->u.apSub[bin];
		if (!p) {
			return 0;
		}
	}
	if (p->iSize <= BITVEC_NBIT) {
		return (p->u.aBitmap[i / BITVEC_SZELEM] & (1 << (i&(BITVEC_SZELEM - 1)))) != 0;
	}
	else {
		u32 h = BITVEC_HASH(i++);
		while (p->u.aHash[h]) {
			if (p->u.aHash[h] == i) return 1;
			h = (h + 1) % BITVEC_NINT;
		}
		return 0;
	}
}
SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i) {
	return p != 0 && sqlite3BitvecTestNotNull(p, i);
}


SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i) {
	u32 h;
	if (p == 0) return SQLITE_OK;
	assert(i>0);
	assert(i <= p->iSize);
	i--;
	while ((p->iSize > BITVEC_NBIT) && p->iDivisor) {
		u32 bin = i / p->iDivisor;
		i = i%p->iDivisor;
		if (p->u.apSub[bin] == 0) {
			p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor);
			if (p->u.apSub[bin] == 0) return SQLITE_NOMEM_BKPT;
		}
		p = p->u.apSub[bin];
	}
	if (p->iSize <= BITVEC_NBIT) {
		p->u.aBitmap[i / BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM - 1));
		return SQLITE_OK;
	}
	h = BITVEC_HASH(i++);
	
	
	
	if (!p->u.aHash[h]) {
		if (p->nSet<(BITVEC_NINT - 1)) {
			goto bitvec_set_end;
		}
		else {
			goto bitvec_set_rehash;
		}
	}
	
	
	do {
		if (p->u.aHash[h] == i) return SQLITE_OK;
		h++;
		if (h >= BITVEC_NINT) h = 0;
	} while (p->u.aHash[h]);
	
	
	
bitvec_set_rehash:
	if (p->nSet >= BITVEC_MXHASH) {
		unsigned int j;
		int rc;
		u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));
		if (aiValues == 0) {
			return SQLITE_NOMEM_BKPT;
		}
		else {
			memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
			memset(p->u.apSub, 0, sizeof(p->u.apSub));
			p->iDivisor = (p->iSize + BITVEC_NPTR - 1) / BITVEC_NPTR;
			rc = sqlite3BitvecSet(p, i);
			for (j = 0; j<BITVEC_NINT; j++) {
				if (aiValues[j]) rc |= sqlite3BitvecSet(p, aiValues[j]);
			}
			sqlite3StackFree(0, aiValues);
			return rc;
		}
	}
bitvec_set_end:
	p->nSet++;
	p->u.aHash[h] = i;
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf) {
	if (p == 0) return;
	assert(i>0);
	i--;
	while (p->iDivisor) {
		u32 bin = i / p->iDivisor;
		i = i%p->iDivisor;
		p = p->u.apSub[bin];
		if (!p) {
			return;
		}
	}
	if (p->iSize <= BITVEC_NBIT) {
		p->u.aBitmap[i / BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM - 1)));
	}
	else {
		unsigned int j;
		u32 *aiValues = pBuf;
		memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
		memset(p->u.aHash, 0, sizeof(p->u.aHash));
		p->nSet = 0;
		for (j = 0; j<BITVEC_NINT; j++) {
			if (aiValues[j] && aiValues[j] != (i + 1)) {
				u32 h = BITVEC_HASH(aiValues[j] - 1);
				p->nSet++;
				while (p->u.aHash[h]) {
					h++;
					if (h >= BITVEC_NINT) h = 0;
				}
				p->u.aHash[h] = aiValues[j];
			}
		}
	}
}


SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p) {
	if (p == 0) return;
	if (p->iDivisor) {
		unsigned int i;
		for (i = 0; i<BITVEC_NPTR; i++) {
			sqlite3BitvecDestroy(p->u.apSub[i]);
		}
	}
	sqlite3_free(p);
}


SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec *p) {
	return p->iSize;
}

#ifndef SQLITE_OMIT_BUILTIN_TEST

#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))
#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))
#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0


SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp) {
	Bitvec *pBitvec = 0;
	unsigned char *pV = 0;
	int rc = -1;
	int i, nx, pc, op;
	void *pTmpSpace;

	
	pBitvec = sqlite3BitvecCreate(sz);
	pV = sqlite3MallocZero((sz + 7) / 8 + 1);
	pTmpSpace = sqlite3_malloc64(BITVEC_SZ);
	if (pBitvec == 0 || pV == 0 || pTmpSpace == 0) goto bitvec_end;

	
	sqlite3BitvecSet(0, 1);
	sqlite3BitvecClear(0, 1, pTmpSpace);

	
	pc = 0;
	while ((op = aOp[pc]) != 0) {
		switch (op) {
		case 1:
		case 2:
		case 5: {
			nx = 4;
			i = aOp[pc + 2] - 1;
			aOp[pc + 2] += aOp[pc + 3];
			break;
		}
		case 3:
		case 4:
		default: {
			nx = 2;
			sqlite3_randomness(sizeof(i), &i);
			break;
		}
		}
		if ((--aOp[pc + 1]) > 0) nx = 0;
		pc += nx;
		i = (i & 0x7fffffff) % sz;
		if ((op & 1) != 0) {
			SETBIT(pV, (i + 1));
			if (op != 5) {
				if (sqlite3BitvecSet(pBitvec, i + 1)) goto bitvec_end;
			}
		}
		else {
			CLEARBIT(pV, (i + 1));
			sqlite3BitvecClear(pBitvec, i + 1, pTmpSpace);
		}
	}

	
	rc = sqlite3BitvecTest(0, 0) + sqlite3BitvecTest(pBitvec, sz + 1)
		+ sqlite3BitvecTest(pBitvec, 0)
		+ (sqlite3BitvecSize(pBitvec) - sz);
	for (i = 1; i <= sz; i++) {
		if ((TESTBIT(pV, i)) != sqlite3BitvecTest(pBitvec, i)) {
			rc = i;
			break;
		}
	}

	
bitvec_end:
	sqlite3_free(pTmpSpace);
	sqlite3_free(pV);
	sqlite3BitvecDestroy(pBitvec);
	return rc;
}
#endif 







struct PCache {
	PgHdr *pDirty, *pDirtyTail;         
	PgHdr *pSynced;                     
	int nRefSum;                        
	int szCache;                        
	int szSpill;                        
	int szPage;                         
	int szExtra;                        
	u8 bPurgeable;                      
	u8 eCreate;                         
	int(*xStress)(void*, PgHdr*);       
	void *pStress;                      
	sqlite3_pcache *pCache;             
};



#if defined(SQLITE_DEBUG) && 0
int sqlite3PcacheTrace = 2;       
int sqlite3PcacheMxDump = 9999;   
# define pcacheTrace(X) if(sqlite3PcacheTrace){sqlite3DebugPrintf X;}
void pcacheDump(PCache *pCache) {
	int N;
	int i, j;
	sqlite3_pcache_page *pLower;
	PgHdr *pPg;
	unsigned char *a;

	if (sqlite3PcacheTrace<2) return;
	if (pCache->pCache == 0) return;
	N = sqlite3PcachePagecount(pCache);
	if (N>sqlite3PcacheMxDump) N = sqlite3PcacheMxDump;
	for (i = 1; i <= N; i++) {
		pLower = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, i, 0);
		if (pLower == 0) continue;
		pPg = (PgHdr*)pLower->pExtra;
		printf("%3d: nRef %2d flgs %02x data ", i, pPg->nRef, pPg->flags);
		a = (unsigned char *)pLower->pBuf;
		for (j = 0; j<12; j++) printf("%02x", a[j]);
		printf("\n");
		if (pPg->pPage == 0) {
			sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, pLower, 0);
		}
	}
}
#else
# define pcacheTrace(X)
# define pcacheDump(X)
#endif


#if SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr *pPg) {
	PCache *pCache;
	assert(pPg != 0);
	assert(pPg->pgno>0);    
	pCache = pPg->pCache;
	assert(pCache != 0);      
	if (pPg->flags & PGHDR_CLEAN) {
		assert((pPg->flags & PGHDR_DIRTY) == 0);
		assert(pCache->pDirty != pPg);          
		assert(pCache->pDirtyTail != pPg);
	}
	
	if (pPg->flags & PGHDR_WRITEABLE) {
		assert(pPg->flags & PGHDR_DIRTY);     
	}
	
	return 1;
}
#endif 





#define PCACHE_DIRTYLIST_REMOVE   1    
#define PCACHE_DIRTYLIST_ADD      2    
#define PCACHE_DIRTYLIST_FRONT    3    


static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove) {
	PCache *p = pPage->pCache;

	pcacheTrace(("%p.DIRTYLIST.%s %d\n", p,
		addRemove == 1 ? "REMOVE" : addRemove == 2 ? "ADD" : "FRONT",
		pPage->pgno));
	if (addRemove & PCACHE_DIRTYLIST_REMOVE) {
		assert(pPage->pDirtyNext || pPage == p->pDirtyTail);
		assert(pPage->pDirtyPrev || pPage == p->pDirty);

		
		if (p->pSynced == pPage) {
			p->pSynced = pPage->pDirtyPrev;
		}

		if (pPage->pDirtyNext) {
			pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;
		}
		else {
			assert(pPage == p->pDirtyTail);
			p->pDirtyTail = pPage->pDirtyPrev;
		}
		if (pPage->pDirtyPrev) {
			pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;
		}
		else {
			
			assert(pPage == p->pDirty);
			p->pDirty = pPage->pDirtyNext;
			assert(p->bPurgeable || p->eCreate == 2);
			if (p->pDirty == 0) {         
				assert(p->bPurgeable == 0 || p->eCreate == 1);
				p->eCreate = 2;
			}
		}
		pPage->pDirtyNext = 0;
		pPage->pDirtyPrev = 0;
	}
	if (addRemove & PCACHE_DIRTYLIST_ADD) {
		assert(pPage->pDirtyNext == 0 && pPage->pDirtyPrev == 0 && p->pDirty != pPage);

		pPage->pDirtyNext = p->pDirty;
		if (pPage->pDirtyNext) {
			assert(pPage->pDirtyNext->pDirtyPrev == 0);
			pPage->pDirtyNext->pDirtyPrev = pPage;
		}
		else {
			p->pDirtyTail = pPage;
			if (p->bPurgeable) {
				assert(p->eCreate == 2);
				p->eCreate = 1;
			}
		}
		p->pDirty = pPage;

		
		if (!p->pSynced
			&& 0 == (pPage->flags&PGHDR_NEED_SYNC)   
			) {
			p->pSynced = pPage;
		}
	}
	pcacheDump(p);
}


static void pcacheUnpin(PgHdr *p) {
	if (p->pCache->bPurgeable) {
		pcacheTrace(("%p.UNPIN %d\n", p->pCache, p->pgno));
		sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);
		pcacheDump(p->pCache);
	}
}


static int numberOfCachePages(PCache *p) {
	if (p->szCache >= 0) {
		
		return p->szCache;
	}
	else {
		
		return (int)((-1024 * (i64)p->szCache) / (p->szPage + p->szExtra));
	}
}


SQLITE_PRIVATE int sqlite3PcacheInitialize(void) {
	if (sqlite3GlobalConfig.pcache2.xInit == 0) {
		
		sqlite3PCacheSetDefault();
	}
	return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg);
}
SQLITE_PRIVATE void sqlite3PcacheShutdown(void) {
	if (sqlite3GlobalConfig.pcache2.xShutdown) {
		
		sqlite3GlobalConfig.pcache2.xShutdown(sqlite3GlobalConfig.pcache2.pArg);
	}
}


SQLITE_PRIVATE int sqlite3PcacheSize(void) { return sizeof(PCache); }


SQLITE_PRIVATE int sqlite3PcacheOpen(
	int szPage,                  
	int szExtra,                 
	int bPurgeable,              
	int(*xStress)(void*, PgHdr*),
	void *pStress,               
	PCache *p                    
) {
	memset(p, 0, sizeof(PCache));
	p->szPage = 1;
	p->szExtra = szExtra;
	p->bPurgeable = bPurgeable;
	p->eCreate = 2;
	p->xStress = xStress;
	p->pStress = pStress;
	p->szCache = 100;
	p->szSpill = 1;
	pcacheTrace(("%p.OPEN szPage %d bPurgeable %d\n", p, szPage, bPurgeable));
	return sqlite3PcacheSetPageSize(p, szPage);
}


SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage) {
	assert(pCache->nRefSum == 0 && pCache->pDirty == 0);
	if (pCache->szPage) {
		sqlite3_pcache *pNew;
		pNew = sqlite3GlobalConfig.pcache2.xCreate(
			szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),
			pCache->bPurgeable
		);
		if (pNew == 0) return SQLITE_NOMEM_BKPT;
		sqlite3GlobalConfig.pcache2.xCachesize(pNew, numberOfCachePages(pCache));
		if (pCache->pCache) {
			sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);
		}
		pCache->pCache = pNew;
		pCache->szPage = szPage;
		pcacheTrace(("%p.PAGESIZE %d\n", pCache, szPage));
	}
	return SQLITE_OK;
}


SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(
	PCache *pCache,       
	Pgno pgno,            
	int createFlag        
) {
	int eCreate;
	sqlite3_pcache_page *pRes;

	assert(pCache != 0);
	assert(pCache->pCache != 0);
	assert(createFlag == 3 || createFlag == 0);
	assert(pgno>0);
	assert(pCache->eCreate == ((pCache->bPurgeable && pCache->pDirty) ? 1 : 2));

	
	eCreate = createFlag & pCache->eCreate;
	assert(eCreate == 0 || eCreate == 1 || eCreate == 2);
	assert(createFlag == 0 || pCache->eCreate == eCreate);
	assert(createFlag == 0 || eCreate == 1 + (!pCache->bPurgeable || !pCache->pDirty));
	pRes = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);
	pcacheTrace(("%p.FETCH %d%s (result: %p)\n", pCache, pgno,
		createFlag ? " create" : "", pRes));
	return pRes;
}


SQLITE_PRIVATE int sqlite3PcacheFetchStress(
	PCache *pCache,                 
	Pgno pgno,                      
	sqlite3_pcache_page **ppPage    
) {
	PgHdr *pPg;
	if (pCache->eCreate == 2) return 0;

	if (sqlite3PcachePagecount(pCache)>pCache->szSpill) {
		
		for (pPg = pCache->pSynced;
			pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC));
			pPg = pPg->pDirtyPrev
			);
		pCache->pSynced = pPg;
		if (!pPg) {
			for (pPg = pCache->pDirtyTail; pPg && pPg->nRef; pPg = pPg->pDirtyPrev);
		}
		if (pPg) {
			int rc;
#ifdef SQLITE_LOG_CACHE_SPILL
			sqlite3_log(SQLITE_FULL,
				"spill page %d making room for %d - cache used: %d/%d",
				pPg->pgno, pgno,
				sqlite3GlobalConfig.pcache.xPagecount(pCache->pCache),
				numberOfCachePages(pCache));
#endif
			pcacheTrace(("%p.SPILL %d\n", pCache, pPg->pgno));
			rc = pCache->xStress(pCache->pStress, pPg);
			pcacheDump(pCache);
			if (rc != SQLITE_OK && rc != SQLITE_BUSY) {
				return rc;
			}
		}
	}
	*ppPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2);
	return *ppPage == 0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;
}


static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(
	PCache *pCache,             
	Pgno pgno,                  
	sqlite3_pcache_page *pPage  
) {
	PgHdr *pPgHdr;
	assert(pPage != 0);
	pPgHdr = (PgHdr*)pPage->pExtra;
	assert(pPgHdr->pPage == 0);
	memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr, pDirty));
	pPgHdr->pPage = pPage;
	pPgHdr->pData = pPage->pBuf;
	pPgHdr->pExtra = (void *)&pPgHdr[1];
	memset(pPgHdr->pExtra, 0, pCache->szExtra);
	pPgHdr->pCache = pCache;
	pPgHdr->pgno = pgno;
	pPgHdr->flags = PGHDR_CLEAN;
	return sqlite3PcacheFetchFinish(pCache, pgno, pPage);
}


SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(
	PCache *pCache,             
	Pgno pgno,                  
	sqlite3_pcache_page *pPage  
) {
	PgHdr *pPgHdr;

	assert(pPage != 0);
	pPgHdr = (PgHdr *)pPage->pExtra;

	if (!pPgHdr->pPage) {
		return pcacheFetchFinishWithInit(pCache, pgno, pPage);
	}
	pCache->nRefSum++;
	pPgHdr->nRef++;
	assert(sqlite3PcachePageSanity(pPgHdr));
	return pPgHdr;
}


SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p) {
	assert(p->nRef>0);
	p->pCache->nRefSum--;
	if ((--p->nRef) == 0) {
		if (p->flags&PGHDR_CLEAN) {
			pcacheUnpin(p);
		}
		else if (p->pDirtyPrev != 0) { 
									   
			pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);
		}
	}
}


SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p) {
	assert(p->nRef>0);
	assert(sqlite3PcachePageSanity(p));
	p->nRef++;
	p->pCache->nRefSum++;
}


SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p) {
	assert(p->nRef == 1);
	assert(sqlite3PcachePageSanity(p));
	if (p->flags&PGHDR_DIRTY) {
		pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);
	}
	p->pCache->nRefSum--;
	sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);
}


SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p) {
	assert(p->nRef>0);
	assert(sqlite3PcachePageSanity(p));
	if (p->flags & (PGHDR_CLEAN | PGHDR_DONT_WRITE)) {    
		p->flags &= ~PGHDR_DONT_WRITE;
		if (p->flags & PGHDR_CLEAN) {
			p->flags ^= (PGHDR_DIRTY | PGHDR_CLEAN);
			pcacheTrace(("%p.DIRTY %d\n", p->pCache, p->pgno));
			assert((p->flags & (PGHDR_DIRTY | PGHDR_CLEAN)) == PGHDR_DIRTY);
			pcacheManageDirtyList(p, PCACHE_DIRTYLIST_ADD);
		}
		assert(sqlite3PcachePageSanity(p));
	}
}


SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p) {
	assert(sqlite3PcachePageSanity(p));
	if (ALWAYS((p->flags & PGHDR_DIRTY) != 0)) {
		assert((p->flags & PGHDR_CLEAN) == 0);
		pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);
		p->flags &= ~(PGHDR_DIRTY | PGHDR_NEED_SYNC | PGHDR_WRITEABLE);
		p->flags |= PGHDR_CLEAN;
		pcacheTrace(("%p.CLEAN %d\n", p->pCache, p->pgno));
		assert(sqlite3PcachePageSanity(p));
		if (p->nRef == 0) {
			pcacheUnpin(p);
		}
	}
}


SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache) {
	PgHdr *p;
	pcacheTrace(("%p.CLEAN-ALL\n", pCache));
	while ((p = pCache->pDirty) != 0) {
		sqlite3PcacheMakeClean(p);
	}
}


SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache *pCache) {
	PgHdr *p;
	pcacheTrace(("%p.CLEAR-WRITEABLE\n", pCache));
	for (p = pCache->pDirty; p; p = p->pDirtyNext) {
		p->flags &= ~(PGHDR_NEED_SYNC | PGHDR_WRITEABLE);
	}
	pCache->pSynced = pCache->pDirtyTail;
}


SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache) {
	PgHdr *p;
	for (p = pCache->pDirty; p; p = p->pDirtyNext) {
		p->flags &= ~PGHDR_NEED_SYNC;
	}
	pCache->pSynced = pCache->pDirtyTail;
}


SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno) {
	PCache *pCache = p->pCache;
	assert(p->nRef>0);
	assert(newPgno>0);
	assert(sqlite3PcachePageSanity(p));
	pcacheTrace(("%p.MOVE %d -> %d\n", pCache, p->pgno, newPgno));
	sqlite3GlobalConfig.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno, newPgno);
	p->pgno = newPgno;
	if ((p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC)) {
		pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);
	}
}


SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno) {
	if (pCache->pCache) {
		PgHdr *p;
		PgHdr *pNext;
		pcacheTrace(("%p.TRUNCATE %d\n", pCache, pgno));
		for (p = pCache->pDirty; p; p = pNext) {
			pNext = p->pDirtyNext;
			
			assert(p->pgno>0);
			if (p->pgno>pgno) {
				assert(p->flags&PGHDR_DIRTY);
				sqlite3PcacheMakeClean(p);
			}
		}
		if (pgno == 0 && pCache->nRefSum) {
			sqlite3_pcache_page *pPage1;
			pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, 1, 0);
			if (ALWAYS(pPage1)) {  
				memset(pPage1->pBuf, 0, pCache->szPage);
				pgno = 1;
			}
		}
		sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno + 1);
	}
}


SQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache) {
	assert(pCache->pCache != 0);
	pcacheTrace(("%p.CLOSE\n", pCache));
	sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);
}


SQLITE_PRIVATE void sqlite3PcacheClear(PCache *pCache) {
	sqlite3PcacheTruncate(pCache, 0);
}


static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB) {
	PgHdr result, *pTail;
	pTail = &result;
	assert(pA != 0 && pB != 0);
	for (;;) {
		if (pA->pgno<pB->pgno) {
			pTail->pDirty = pA;
			pTail = pA;
			pA = pA->pDirty;
			if (pA == 0) {
				pTail->pDirty = pB;
				break;
			}
		}
		else {
			pTail->pDirty = pB;
			pTail = pB;
			pB = pB->pDirty;
			if (pB == 0) {
				pTail->pDirty = pA;
				break;
			}
		}
	}
	return result.pDirty;
}


#define N_SORT_BUCKET  32
static PgHdr *pcacheSortDirtyList(PgHdr *pIn) {
	PgHdr *a[N_SORT_BUCKET], *p;
	int i;
	memset(a, 0, sizeof(a));
	while (pIn) {
		p = pIn;
		pIn = p->pDirty;
		p->pDirty = 0;
		for (i = 0; ALWAYS(i<N_SORT_BUCKET - 1); i++) {
			if (a[i] == 0) {
				a[i] = p;
				break;
			}
			else {
				p = pcacheMergeDirtyList(a[i], p);
				a[i] = 0;
			}
		}
		if (NEVER(i == N_SORT_BUCKET - 1)) {
			
			a[i] = pcacheMergeDirtyList(a[i], p);
		}
	}
	p = a[0];
	for (i = 1; i<N_SORT_BUCKET; i++) {
		if (a[i] == 0) continue;
		p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];
	}
	return p;
}


SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache) {
	PgHdr *p;
	for (p = pCache->pDirty; p; p = p->pDirtyNext) {
		p->pDirty = p->pDirtyNext;
	}
	return pcacheSortDirtyList(pCache->pDirty);
}


SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache) {
	return pCache->nRefSum;
}


SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p) {
	return p->nRef;
}


SQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache) {
	assert(pCache->pCache != 0);
	return sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache);
}

#ifdef SQLITE_TEST

SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache) {
	return numberOfCachePages(pCache);
}
#endif


SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage) {
	assert(pCache->pCache != 0);
	pCache->szCache = mxPage;
	sqlite3GlobalConfig.pcache2.xCachesize(pCache->pCache,
		numberOfCachePages(pCache));
}


SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *p, int mxPage) {
	int res;
	assert(p->pCache != 0);
	if (mxPage) {
		if (mxPage<0) {
			mxPage = (int)((-1024 * (i64)mxPage) / (p->szPage + p->szExtra));
		}
		p->szSpill = mxPage;
	}
	res = numberOfCachePages(p);
	if (res<p->szSpill) res = p->szSpill;
	return res;
}


SQLITE_PRIVATE void sqlite3PcacheShrink(PCache *pCache) {
	assert(pCache->pCache != 0);
	sqlite3GlobalConfig.pcache2.xShrink(pCache->pCache);
}


SQLITE_PRIVATE int sqlite3HeaderSizePcache(void) { return ROUND8(sizeof(PgHdr)); }


SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache *pCache) {
	PgHdr *pDirty;
	int nDirty = 0;
	int nCache = numberOfCachePages(pCache);
	for (pDirty = pCache->pDirty; pDirty; pDirty = pDirty->pDirtyNext) nDirty++;
	return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;
}

#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)

SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void(*xIter)(PgHdr *)) {
	PgHdr *pDirty;
	for (pDirty = pCache->pDirty; pDirty; pDirty = pDirty->pDirtyNext) {
		xIter(pDirty);
	}
}
#endif






typedef struct PCache1 PCache1;
typedef struct PgHdr1 PgHdr1;
typedef struct PgFreeslot PgFreeslot;
typedef struct PGroup PGroup;


struct PgHdr1 {
	sqlite3_pcache_page page;      
	unsigned int iKey;             
	u8 isPinned;                   
	u8 isBulkLocal;                
	u8 isAnchor;                   
	PgHdr1 *pNext;                 
	PCache1 *pCache;               
	PgHdr1 *pLruNext;              
	PgHdr1 *pLruPrev;              
};


struct PGroup {
	sqlite3_mutex *mutex;          
	unsigned int nMaxPage;         
	unsigned int nMinPage;         
	unsigned int mxPinned;         
	unsigned int nCurrentPage;     
	PgHdr1 lru;                    
};


struct PCache1 {
	
	PGroup *pGroup;                     
	int szPage;                         
	int szExtra;                        
	int szAlloc;                        
	int bPurgeable;                     
	unsigned int nMin;                  
	unsigned int nMax;                  
	unsigned int n90pct;                
	unsigned int iMaxKey;               

										
	unsigned int nRecyclable;           
	unsigned int nPage;                 
	unsigned int nHash;                 
	PgHdr1 **apHash;                    
	PgHdr1 *pFree;                      
	void *pBulk;                        
};


struct PgFreeslot {
	PgFreeslot *pNext;  
};


static SQLITE_WSD struct PCacheGlobal {
	PGroup grp;                    

								   
	int isInit;                    
	int separateCache;             
	int nInitPage;                 
	int szSlot;                    
	int nSlot;                     
	int nReserve;                  
	void *pStart, *pEnd;           
								   
	sqlite3_mutex *mutex;          
	PgFreeslot *pFree;             
	int nFreeSlot;                 
								   
	int bUnderPressure;            
} pcache1_g;


#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))


#if !defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0
# define pcache1EnterMutex(X)  assert((X)->mutex==0)
# define pcache1LeaveMutex(X)  assert((X)->mutex==0)
# define PCACHE1_MIGHT_USE_GROUP_MUTEX 0
#else
# define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)
# define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)
# define PCACHE1_MIGHT_USE_GROUP_MUTEX 1
#endif






SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n) {
	if (pcache1.isInit) {
		PgFreeslot *p;
		if (pBuf == 0) sz = n = 0;
		sz = ROUNDDOWN8(sz);
		pcache1.szSlot = sz;
		pcache1.nSlot = pcache1.nFreeSlot = n;
		pcache1.nReserve = n>90 ? 10 : (n / 10 + 1);
		pcache1.pStart = pBuf;
		pcache1.pFree = 0;
		pcache1.bUnderPressure = 0;
		while (n--) {
			p = (PgFreeslot*)pBuf;
			p->pNext = pcache1.pFree;
			pcache1.pFree = p;
			pBuf = (void*)&((char*)pBuf)[sz];
		}
		pcache1.pEnd = pBuf;
	}
}


static int pcache1InitBulk(PCache1 *pCache) {
	i64 szBulk;
	char *zBulk;
	if (pcache1.nInitPage == 0) return 0;
	
	if (pCache->nMax<3) return 0;
	sqlite3BeginBenignMalloc();
	if (pcache1.nInitPage>0) {
		szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;
	}
	else {
		szBulk = -1024 * (i64)pcache1.nInitPage;
	}
	if (szBulk > pCache->szAlloc*(i64)pCache->nMax) {
		szBulk = pCache->szAlloc*(i64)pCache->nMax;
	}
	zBulk = pCache->pBulk = sqlite3Malloc(szBulk);
	sqlite3EndBenignMalloc();
	if (zBulk) {
		int nBulk = sqlite3MallocSize(zBulk) / pCache->szAlloc;
		int i;
		for (i = 0; i<nBulk; i++) {
			PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];
			pX->page.pBuf = zBulk;
			pX->page.pExtra = &pX[1];
			pX->isBulkLocal = 1;
			pX->isAnchor = 0;
			pX->pNext = pCache->pFree;
			pCache->pFree = pX;
			zBulk += pCache->szAlloc;
		}
	}
	return pCache->pFree != 0;
}


static void *pcache1Alloc(int nByte) {
	void *p = 0;
	assert(sqlite3_mutex_notheld(pcache1.grp.mutex));
	if (nByte <= pcache1.szSlot) {
		sqlite3_mutex_enter(pcache1.mutex);
		p = (PgHdr1 *)pcache1.pFree;
		if (p) {
			pcache1.pFree = pcache1.pFree->pNext;
			pcache1.nFreeSlot--;
			pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;
			assert(pcache1.nFreeSlot >= 0);
			sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);
			sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);
		}
		sqlite3_mutex_leave(pcache1.mutex);
	}
	if (p == 0) {
		
		p = sqlite3Malloc(nByte);
#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
		if (p) {
			int sz = sqlite3MallocSize(p);
			sqlite3_mutex_enter(pcache1.mutex);
			sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);
			sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);
			sqlite3_mutex_leave(pcache1.mutex);
		}
#endif
		sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);
	}
	return p;
}


static void pcache1Free(void *p) {
	if (p == 0) return;
	if (SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd)) {
		PgFreeslot *pSlot;
		sqlite3_mutex_enter(pcache1.mutex);
		sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);
		pSlot = (PgFreeslot*)p;
		pSlot->pNext = pcache1.pFree;
		pcache1.pFree = pSlot;
		pcache1.nFreeSlot++;
		pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;
		assert(pcache1.nFreeSlot <= pcache1.nSlot);
		sqlite3_mutex_leave(pcache1.mutex);
	}
	else {
		assert(sqlite3MemdebugHasType(p, MEMTYPE_PCACHE));
		sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
		{
			int nFreed = 0;
			nFreed = sqlite3MallocSize(p);
			sqlite3_mutex_enter(pcache1.mutex);
			sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);
			sqlite3_mutex_leave(pcache1.mutex);
		}
#endif
		sqlite3_free(p);
	}
}

#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT

static int pcache1MemSize(void *p) {
	if (p >= pcache1.pStart && p<pcache1.pEnd) {
		return pcache1.szSlot;
	}
	else {
		int iSize;
		assert(sqlite3MemdebugHasType(p, MEMTYPE_PCACHE));
		sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
		iSize = sqlite3MallocSize(p);
		sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);
		return iSize;
	}
}
#endif 


static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc) {
	PgHdr1 *p = 0;
	void *pPg;

	assert(sqlite3_mutex_held(pCache->pGroup->mutex));
	if (pCache->pFree || (pCache->nPage == 0 && pcache1InitBulk(pCache))) {
		p = pCache->pFree;
		pCache->pFree = p->pNext;
		p->pNext = 0;
	}
	else {
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
		
		assert(pcache1.separateCache == 0);
		assert(pCache->pGroup == &pcache1.grp);
		pcache1LeaveMutex(pCache->pGroup);
#endif
		if (benignMalloc) { sqlite3BeginBenignMalloc(); }
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
		pPg = pcache1Alloc(pCache->szPage);
		p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);
		if (!pPg || !p) {
			pcache1Free(pPg);
			sqlite3_free(p);
			pPg = 0;
		}
#else
		pPg = pcache1Alloc(pCache->szAlloc);
		p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];
#endif
		if (benignMalloc) { sqlite3EndBenignMalloc(); }
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
		pcache1EnterMutex(pCache->pGroup);
#endif
		if (pPg == 0) return 0;
		p->page.pBuf = pPg;
		p->page.pExtra = &p[1];
		p->isBulkLocal = 0;
		p->isAnchor = 0;
	}
	if (pCache->bPurgeable) {
		pCache->pGroup->nCurrentPage++;
	}
	return p;
}


static void pcache1FreePage(PgHdr1 *p) {
	PCache1 *pCache;
	assert(p != 0);
	pCache = p->pCache;
	assert(sqlite3_mutex_held(p->pCache->pGroup->mutex));
	if (p->isBulkLocal) {
		p->pNext = pCache->pFree;
		pCache->pFree = p;
	}
	else {
		pcache1Free(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
		sqlite3_free(p);
#endif
	}
	if (pCache->bPurgeable) {
		pCache->pGroup->nCurrentPage--;
	}
}


SQLITE_PRIVATE void *sqlite3PageMalloc(int sz) {
	return pcache1Alloc(sz);
}


SQLITE_PRIVATE void sqlite3PageFree(void *p) {
	pcache1Free(p);
}



static int pcache1UnderMemoryPressure(PCache1 *pCache) {
	if (pcache1.nSlot && (pCache->szPage + pCache->szExtra) <= pcache1.szSlot) {
		return pcache1.bUnderPressure;
	}
	else {
		return sqlite3HeapNearlyFull();
	}
}





static void pcache1ResizeHash(PCache1 *p) {
	PgHdr1 **apNew;
	unsigned int nNew;
	unsigned int i;

	assert(sqlite3_mutex_held(p->pGroup->mutex));

	nNew = p->nHash * 2;
	if (nNew<256) {
		nNew = 256;
	}

	pcache1LeaveMutex(p->pGroup);
	if (p->nHash) { sqlite3BeginBenignMalloc(); }
	apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);
	if (p->nHash) { sqlite3EndBenignMalloc(); }
	pcache1EnterMutex(p->pGroup);
	if (apNew) {
		for (i = 0; i<p->nHash; i++) {
			PgHdr1 *pPage;
			PgHdr1 *pNext = p->apHash[i];
			while ((pPage = pNext) != 0) {
				unsigned int h = pPage->iKey % nNew;
				pNext = pPage->pNext;
				pPage->pNext = apNew[h];
				apNew[h] = pPage;
			}
		}
		sqlite3_free(p->apHash);
		p->apHash = apNew;
		p->nHash = nNew;
	}
}


static PgHdr1 *pcache1PinPage(PgHdr1 *pPage) {
	PCache1 *pCache;

	assert(pPage != 0);
	assert(pPage->isPinned == 0);
	pCache = pPage->pCache;
	assert(pPage->pLruNext);
	assert(pPage->pLruPrev);
	assert(sqlite3_mutex_held(pCache->pGroup->mutex));
	pPage->pLruPrev->pLruNext = pPage->pLruNext;
	pPage->pLruNext->pLruPrev = pPage->pLruPrev;
	pPage->pLruNext = 0;
	pPage->pLruPrev = 0;
	pPage->isPinned = 1;
	assert(pPage->isAnchor == 0);
	assert(pCache->pGroup->lru.isAnchor == 1);
	pCache->nRecyclable--;
	return pPage;
}



static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag) {
	unsigned int h;
	PCache1 *pCache = pPage->pCache;
	PgHdr1 **pp;

	assert(sqlite3_mutex_held(pCache->pGroup->mutex));
	h = pPage->iKey % pCache->nHash;
	for (pp = &pCache->apHash[h]; (*pp) != pPage; pp = &(*pp)->pNext);
	*pp = (*pp)->pNext;

	pCache->nPage--;
	if (freeFlag) pcache1FreePage(pPage);
}


static void pcache1EnforceMaxPage(PCache1 *pCache) {
	PGroup *pGroup = pCache->pGroup;
	PgHdr1 *p;
	assert(sqlite3_mutex_held(pGroup->mutex));
	while (pGroup->nCurrentPage>pGroup->nMaxPage
		&& (p = pGroup->lru.pLruPrev)->isAnchor == 0
		) {
		assert(p->pCache->pGroup == pGroup);
		assert(p->isPinned == 0);
		pcache1PinPage(p);
		pcache1RemoveFromHash(p, 1);
	}
	if (pCache->nPage == 0 && pCache->pBulk) {
		sqlite3_free(pCache->pBulk);
		pCache->pBulk = pCache->pFree = 0;
	}
}


static void pcache1TruncateUnsafe(
	PCache1 *pCache,             
	unsigned int iLimit          
) {
	TESTONLY(int nPage = 0; )  
		unsigned int h, iStop;
	assert(sqlite3_mutex_held(pCache->pGroup->mutex));
	assert(pCache->iMaxKey >= iLimit);
	assert(pCache->nHash > 0);
	if (pCache->iMaxKey - iLimit < pCache->nHash) {
		
		h = iLimit % pCache->nHash;
		iStop = pCache->iMaxKey % pCache->nHash;
		TESTONLY(nPage = -10; )  
	}
	else {
		
		h = pCache->nHash / 2;
		iStop = h - 1;
	}
	for (;;) {
		PgHdr1 **pp;
		PgHdr1 *pPage;
		assert(h<pCache->nHash);
		pp = &pCache->apHash[h];
		while ((pPage = *pp) != 0) {
			if (pPage->iKey >= iLimit) {
				pCache->nPage--;
				*pp = pPage->pNext;
				if (!pPage->isPinned) pcache1PinPage(pPage);
				pcache1FreePage(pPage);
			}
			else {
				pp = &pPage->pNext;
				TESTONLY(if (nPage >= 0) nPage++; )
			}
		}
		if (h == iStop) break;
		h = (h + 1) % pCache->nHash;
	}
	assert(nPage<0 || pCache->nPage == (unsigned)nPage);
}





static int pcache1Init(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	assert(pcache1.isInit == 0);
	memset(&pcache1, 0, sizeof(pcache1));


	
#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)
	pcache1.separateCache = 0;
#elif SQLITE_THREADSAFE
	pcache1.separateCache = sqlite3GlobalConfig.pPage == 0
		|| sqlite3GlobalConfig.bCoreMutex>0;
#else
	pcache1.separateCache = sqlite3GlobalConfig.pPage == 0;
#endif

#if SQLITE_THREADSAFE
	if (sqlite3GlobalConfig.bCoreMutex) {
		pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);
		pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);
	}
#endif
	if (pcache1.separateCache
		&& sqlite3GlobalConfig.nPage != 0
		&& sqlite3GlobalConfig.pPage == 0
		) {
		pcache1.nInitPage = sqlite3GlobalConfig.nPage;
	}
	else {
		pcache1.nInitPage = 0;
	}
	pcache1.grp.mxPinned = 10;
	pcache1.isInit = 1;
	return SQLITE_OK;
}


static void pcache1Shutdown(void *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	assert(pcache1.isInit != 0);
	memset(&pcache1, 0, sizeof(pcache1));
}


static void pcache1Destroy(sqlite3_pcache *p);


static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable) {
	PCache1 *pCache;      
	PGroup *pGroup;       
	int sz;               

	assert((szPage & (szPage - 1)) == 0 && szPage >= 512 && szPage <= 65536);
	assert(szExtra < 300);

	sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;
	pCache = (PCache1 *)sqlite3MallocZero(sz);
	if (pCache) {
		if (pcache1.separateCache) {
			pGroup = (PGroup*)&pCache[1];
			pGroup->mxPinned = 10;
		}
		else {
			pGroup = &pcache1.grp;
		}
		if (pGroup->lru.isAnchor == 0) {
			pGroup->lru.isAnchor = 1;
			pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
		}
		pCache->pGroup = pGroup;
		pCache->szPage = szPage;
		pCache->szExtra = szExtra;
		pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));
		pCache->bPurgeable = (bPurgeable ? 1 : 0);
		pcache1EnterMutex(pGroup);
		pcache1ResizeHash(pCache);
		if (bPurgeable) {
			pCache->nMin = 10;
			pGroup->nMinPage += pCache->nMin;
			pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
		}
		pcache1LeaveMutex(pGroup);
		if (pCache->nHash == 0) {
			pcache1Destroy((sqlite3_pcache*)pCache);
			pCache = 0;
		}
	}
	return (sqlite3_pcache *)pCache;
}


static void pcache1Cachesize(sqlite3_pcache *p, int nMax) {
	PCache1 *pCache = (PCache1 *)p;
	if (pCache->bPurgeable) {
		PGroup *pGroup = pCache->pGroup;
		pcache1EnterMutex(pGroup);
		pGroup->nMaxPage += (nMax - pCache->nMax);
		pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
		pCache->nMax = nMax;
		pCache->n90pct = pCache->nMax * 9 / 10;
		pcache1EnforceMaxPage(pCache);
		pcache1LeaveMutex(pGroup);
	}
}


static void pcache1Shrink(sqlite3_pcache *p) {
	PCache1 *pCache = (PCache1*)p;
	if (pCache->bPurgeable) {
		PGroup *pGroup = pCache->pGroup;
		int savedMaxPage;
		pcache1EnterMutex(pGroup);
		savedMaxPage = pGroup->nMaxPage;
		pGroup->nMaxPage = 0;
		pcache1EnforceMaxPage(pCache);
		pGroup->nMaxPage = savedMaxPage;
		pcache1LeaveMutex(pGroup);
	}
}


static int pcache1Pagecount(sqlite3_pcache *p) {
	int n;
	PCache1 *pCache = (PCache1*)p;
	pcache1EnterMutex(pCache->pGroup);
	n = pCache->nPage;
	pcache1LeaveMutex(pCache->pGroup);
	return n;
}



static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(
	PCache1 *pCache,
	unsigned int iKey,
	int createFlag
) {
	unsigned int nPinned;
	PGroup *pGroup = pCache->pGroup;
	PgHdr1 *pPage = 0;

	
	assert(pCache->nPage >= pCache->nRecyclable);
	nPinned = pCache->nPage - pCache->nRecyclable;
	assert(pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage);
	assert(pCache->n90pct == pCache->nMax * 9 / 10);
	if (createFlag == 1 && (
		nPinned >= pGroup->mxPinned
		|| nPinned >= pCache->n90pct
		|| (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)
		)) {
		return 0;
	}

	if (pCache->nPage >= pCache->nHash) pcache1ResizeHash(pCache);
	assert(pCache->nHash>0 && pCache->apHash);

	
	if (pCache->bPurgeable
		&& !pGroup->lru.pLruPrev->isAnchor
		&& ((pCache->nPage + 1 >= pCache->nMax) || pcache1UnderMemoryPressure(pCache))
		) {
		PCache1 *pOther;
		pPage = pGroup->lru.pLruPrev;
		assert(pPage->isPinned == 0);
		pcache1RemoveFromHash(pPage, 0);
		pcache1PinPage(pPage);
		pOther = pPage->pCache;
		if (pOther->szAlloc != pCache->szAlloc) {
			pcache1FreePage(pPage);
			pPage = 0;
		}
		else {
			pGroup->nCurrentPage -= (pOther->bPurgeable - pCache->bPurgeable);
		}
	}

	
	if (!pPage) {
		pPage = pcache1AllocPage(pCache, createFlag == 1);
	}

	if (pPage) {
		unsigned int h = iKey % pCache->nHash;
		pCache->nPage++;
		pPage->iKey = iKey;
		pPage->pNext = pCache->apHash[h];
		pPage->pCache = pCache;
		pPage->pLruPrev = 0;
		pPage->pLruNext = 0;
		pPage->isPinned = 1;
		*(void **)pPage->page.pExtra = 0;
		pCache->apHash[h] = pPage;
		if (iKey>pCache->iMaxKey) {
			pCache->iMaxKey = iKey;
		}
	}
	return pPage;
}


static PgHdr1 *pcache1FetchNoMutex(
	sqlite3_pcache *p,
	unsigned int iKey,
	int createFlag
) {
	PCache1 *pCache = (PCache1 *)p;
	PgHdr1 *pPage = 0;

	
	pPage = pCache->apHash[iKey % pCache->nHash];
	while (pPage && pPage->iKey != iKey) { pPage = pPage->pNext; }

	
	if (pPage) {
		if (!pPage->isPinned) {
			return pcache1PinPage(pPage);
		}
		else {
			return pPage;
		}
	}
	else if (createFlag) {
		
		return pcache1FetchStage2(pCache, iKey, createFlag);
	}
	else {
		return 0;
	}
}
#if PCACHE1_MIGHT_USE_GROUP_MUTEX
static PgHdr1 *pcache1FetchWithMutex(
	sqlite3_pcache *p,
	unsigned int iKey,
	int createFlag
) {
	PCache1 *pCache = (PCache1 *)p;
	PgHdr1 *pPage;

	pcache1EnterMutex(pCache->pGroup);
	pPage = pcache1FetchNoMutex(p, iKey, createFlag);
	assert(pPage == 0 || pCache->iMaxKey >= iKey);
	pcache1LeaveMutex(pCache->pGroup);
	return pPage;
}
#endif
static sqlite3_pcache_page *pcache1Fetch(
	sqlite3_pcache *p,
	unsigned int iKey,
	int createFlag
) {
#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)
	PCache1 *pCache = (PCache1 *)p;
#endif

	assert(offsetof(PgHdr1, page) == 0);
	assert(pCache->bPurgeable || createFlag != 1);
	assert(pCache->bPurgeable || pCache->nMin == 0);
	assert(pCache->bPurgeable == 0 || pCache->nMin == 10);
	assert(pCache->nMin == 0 || pCache->bPurgeable);
	assert(pCache->nHash>0);
#if PCACHE1_MIGHT_USE_GROUP_MUTEX
	if (pCache->pGroup->mutex) {
		return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);
	}
	else
#endif
	{
		return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);
	}
}



static void pcache1Unpin(
	sqlite3_pcache *p,
	sqlite3_pcache_page *pPg,
	int reuseUnlikely
) {
	PCache1 *pCache = (PCache1 *)p;
	PgHdr1 *pPage = (PgHdr1 *)pPg;
	PGroup *pGroup = pCache->pGroup;

	assert(pPage->pCache == pCache);
	pcache1EnterMutex(pGroup);

	
	assert(pPage->pLruPrev == 0 && pPage->pLruNext == 0);
	assert(pPage->isPinned == 1);

	if (reuseUnlikely || pGroup->nCurrentPage>pGroup->nMaxPage) {
		pcache1RemoveFromHash(pPage, 1);
	}
	else {
		
		PgHdr1 **ppFirst = &pGroup->lru.pLruNext;
		pPage->pLruPrev = &pGroup->lru;
		(pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
		*ppFirst = pPage;
		pCache->nRecyclable++;
		pPage->isPinned = 0;
	}

	pcache1LeaveMutex(pCache->pGroup);
}


static void pcache1Rekey(
	sqlite3_pcache *p,
	sqlite3_pcache_page *pPg,
	unsigned int iOld,
	unsigned int iNew
) {
	PCache1 *pCache = (PCache1 *)p;
	PgHdr1 *pPage = (PgHdr1 *)pPg;
	PgHdr1 **pp;
	unsigned int h;
	assert(pPage->iKey == iOld);
	assert(pPage->pCache == pCache);

	pcache1EnterMutex(pCache->pGroup);

	h = iOld%pCache->nHash;
	pp = &pCache->apHash[h];
	while ((*pp) != pPage) {
		pp = &(*pp)->pNext;
	}
	*pp = pPage->pNext;

	h = iNew%pCache->nHash;
	pPage->iKey = iNew;
	pPage->pNext = pCache->apHash[h];
	pCache->apHash[h] = pPage;
	if (iNew>pCache->iMaxKey) {
		pCache->iMaxKey = iNew;
	}

	pcache1LeaveMutex(pCache->pGroup);
}


static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit) {
	PCache1 *pCache = (PCache1 *)p;
	pcache1EnterMutex(pCache->pGroup);
	if (iLimit <= pCache->iMaxKey) {
		pcache1TruncateUnsafe(pCache, iLimit);
		pCache->iMaxKey = iLimit - 1;
	}
	pcache1LeaveMutex(pCache->pGroup);
}


static void pcache1Destroy(sqlite3_pcache *p) {
	PCache1 *pCache = (PCache1 *)p;
	PGroup *pGroup = pCache->pGroup;
	assert(pCache->bPurgeable || (pCache->nMax == 0 && pCache->nMin == 0));
	pcache1EnterMutex(pGroup);
	if (pCache->nPage) pcache1TruncateUnsafe(pCache, 0);
	assert(pGroup->nMaxPage >= pCache->nMax);
	pGroup->nMaxPage -= pCache->nMax;
	assert(pGroup->nMinPage >= pCache->nMin);
	pGroup->nMinPage -= pCache->nMin;
	pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
	pcache1EnforceMaxPage(pCache);
	pcache1LeaveMutex(pGroup);
	sqlite3_free(pCache->pBulk);
	sqlite3_free(pCache->apHash);
	sqlite3_free(pCache);
}


SQLITE_PRIVATE void sqlite3PCacheSetDefault(void) {
	static const sqlite3_pcache_methods2 defaultMethods = {
		1,                       
		0,                       
		pcache1Init,             
		pcache1Shutdown,         
		pcache1Create,           
		pcache1Cachesize,        
		pcache1Pagecount,        
		pcache1Fetch,            
		pcache1Unpin,            
		pcache1Rekey,            
		pcache1Truncate,         
		pcache1Destroy,          
		pcache1Shrink            
	};
	sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultMethods);
}


SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void) { return ROUND8(sizeof(PgHdr1)); }


SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void) {
	return pcache1.mutex;
}

#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT

SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq) {
	int nFree = 0;
	assert(sqlite3_mutex_notheld(pcache1.grp.mutex));
	assert(sqlite3_mutex_notheld(pcache1.mutex));
	if (sqlite3GlobalConfig.nPage == 0) {
		PgHdr1 *p;
		pcache1EnterMutex(&pcache1.grp);
		while ((nReq<0 || nFree<nReq)
			&& (p = pcache1.grp.lru.pLruPrev) != 0
			&& p->isAnchor == 0
			) {
			nFree += pcache1MemSize(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
			nFree += sqlite3MemSize(p);
#endif
			assert(p->isPinned == 0);
			pcache1PinPage(p);
			pcache1RemoveFromHash(p, 1);
		}
		pcache1LeaveMutex(&pcache1.grp);
	}
	return nFree;
}
#endif 

#ifdef SQLITE_TEST

SQLITE_PRIVATE void sqlite3PcacheStats(
	int *pnCurrent,      
	int *pnMax,          
	int *pnMin,          
	int *pnRecyclable    
) {
	PgHdr1 *p;
	int nRecyclable = 0;
	for (p = pcache1.grp.lru.pLruNext; p && !p->isAnchor; p = p->pLruNext) {
		assert(p->isPinned == 0);
		nRecyclable++;
	}
	*pnCurrent = pcache1.grp.nCurrentPage;
	*pnMax = (int)pcache1.grp.nMaxPage;
	*pnMin = (int)pcache1.grp.nMinPage;
	*pnRecyclable = nRecyclable;
}
#endif








#define ROWSET_ALLOCATION_SIZE 1024


#define ROWSET_ENTRY_PER_CHUNK  \
                       ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))


struct RowSetEntry {
	i64 v;                        
	struct RowSetEntry *pRight;   
	struct RowSetEntry *pLeft;    
};


struct RowSetChunk {
	struct RowSetChunk *pNextChunk;        
	struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; 
};


struct RowSet {
	struct RowSetChunk *pChunk;    
	sqlite3 *db;                   
	struct RowSetEntry *pEntry;    
	struct RowSetEntry *pLast;     
	struct RowSetEntry *pFresh;    
	struct RowSetEntry *pForest;   
	u16 nFresh;                    
	u16 rsFlags;                   
	int iBatch;                    
};


#define ROWSET_SORTED  0x01   
#define ROWSET_NEXT    0x02   


SQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N) {
	RowSet *p;
	assert(N >= ROUND8(sizeof(*p)));
	p = pSpace;
	p->pChunk = 0;
	p->db = db;
	p->pEntry = 0;
	p->pLast = 0;
	p->pForest = 0;
	p->pFresh = (struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);
	p->nFresh = (u16)((N - ROUND8(sizeof(*p))) / sizeof(struct RowSetEntry));
	p->rsFlags = ROWSET_SORTED;
	p->iBatch = 0;
	return p;
}


SQLITE_PRIVATE void sqlite3RowSetClear(RowSet *p) {
	struct RowSetChunk *pChunk, *pNextChunk;
	for (pChunk = p->pChunk; pChunk; pChunk = pNextChunk) {
		pNextChunk = pChunk->pNextChunk;
		sqlite3DbFree(p->db, pChunk);
	}
	p->pChunk = 0;
	p->nFresh = 0;
	p->pEntry = 0;
	p->pLast = 0;
	p->pForest = 0;
	p->rsFlags = ROWSET_SORTED;
}


static struct RowSetEntry *rowSetEntryAlloc(RowSet *p) {
	assert(p != 0);
	if (p->nFresh == 0) {  
						   
		struct RowSetChunk *pNew;
		pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));
		if (pNew == 0) {
			return 0;
		}
		pNew->pNextChunk = p->pChunk;
		p->pChunk = pNew;
		p->pFresh = pNew->aEntry;
		p->nFresh = ROWSET_ENTRY_PER_CHUNK;
	}
	p->nFresh--;
	return p->pFresh++;
}


SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid) {
	struct RowSetEntry *pEntry;  
	struct RowSetEntry *pLast;   

								 
	assert(p != 0 && (p->rsFlags & ROWSET_NEXT) == 0);

	pEntry = rowSetEntryAlloc(p);
	if (pEntry == 0) return;
	pEntry->v = rowid;
	pEntry->pRight = 0;
	pLast = p->pLast;
	if (pLast) {
		if (rowid <= pLast->v) {  
								  
			p->rsFlags &= ~ROWSET_SORTED;
		}
		pLast->pRight = pEntry;
	}
	else {
		p->pEntry = pEntry;
	}
	p->pLast = pEntry;
}


static struct RowSetEntry *rowSetEntryMerge(
	struct RowSetEntry *pA,    
	struct RowSetEntry *pB     
) {
	struct RowSetEntry head;
	struct RowSetEntry *pTail;

	pTail = &head;
	assert(pA != 0 && pB != 0);
	for (;;) {
		assert(pA->pRight == 0 || pA->v <= pA->pRight->v);
		assert(pB->pRight == 0 || pB->v <= pB->pRight->v);
		if (pA->v <= pB->v) {
			if (pA->v<pB->v) pTail = pTail->pRight = pA;
			pA = pA->pRight;
			if (pA == 0) {
				pTail->pRight = pB;
				break;
			}
		}
		else {
			pTail = pTail->pRight = pB;
			pB = pB->pRight;
			if (pB == 0) {
				pTail->pRight = pA;
				break;
			}
		}
	}
	return head.pRight;
}


static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn) {
	unsigned int i;
	struct RowSetEntry *pNext, *aBucket[40];

	memset(aBucket, 0, sizeof(aBucket));
	while (pIn) {
		pNext = pIn->pRight;
		pIn->pRight = 0;
		for (i = 0; aBucket[i]; i++) {
			pIn = rowSetEntryMerge(aBucket[i], pIn);
			aBucket[i] = 0;
		}
		aBucket[i] = pIn;
		pIn = pNext;
	}
	pIn = aBucket[0];
	for (i = 1; i<sizeof(aBucket) / sizeof(aBucket[0]); i++) {
		if (aBucket[i] == 0) continue;
		pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
	}
	return pIn;
}



static void rowSetTreeToList(
	struct RowSetEntry *pIn,         
	struct RowSetEntry **ppFirst,    
	struct RowSetEntry **ppLast      
) {
	assert(pIn != 0);
	if (pIn->pLeft) {
		struct RowSetEntry *p;
		rowSetTreeToList(pIn->pLeft, ppFirst, &p);
		p->pRight = pIn;
	}
	else {
		*ppFirst = pIn;
	}
	if (pIn->pRight) {
		rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);
	}
	else {
		*ppLast = pIn;
	}
	assert((*ppLast)->pRight == 0);
}



static struct RowSetEntry *rowSetNDeepTree(
	struct RowSetEntry **ppList,
	int iDepth
) {
	struct RowSetEntry *p;         
	struct RowSetEntry *pLeft;     
	if (*ppList == 0) { 
						
		return 0;
	}
	if (iDepth>1) {   
					  
		pLeft = rowSetNDeepTree(ppList, iDepth - 1);
		p = *ppList;
		if (p == 0) {     
						  
			return pLeft;
		}
		p->pLeft = pLeft;
		*ppList = p->pRight;
		p->pRight = rowSetNDeepTree(ppList, iDepth - 1);
	}
	else {
		p = *ppList;
		*ppList = p->pRight;
		p->pLeft = p->pRight = 0;
	}
	return p;
}


static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList) {
	int iDepth;           
	struct RowSetEntry *p;       
	struct RowSetEntry *pLeft;   

	assert(pList != 0);
	p = pList;
	pList = p->pRight;
	p->pLeft = p->pRight = 0;
	for (iDepth = 1; pList; iDepth++) {
		pLeft = p;
		p = pList;
		pList = p->pRight;
		p->pLeft = pLeft;
		p->pRight = rowSetNDeepTree(&pList, iDepth);
	}
	return p;
}


SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid) {
	assert(p != 0);
	assert(p->pForest == 0);  

							  
	if ((p->rsFlags & ROWSET_NEXT) == 0) {  
		if ((p->rsFlags & ROWSET_SORTED) == 0) {  
			p->pEntry = rowSetEntrySort(p->pEntry);
		}
		p->rsFlags |= ROWSET_SORTED | ROWSET_NEXT;
	}

	
	if (p->pEntry) {
		*pRowid = p->pEntry->v;
		p->pEntry = p->pEntry->pRight;
		if (p->pEntry == 0) { 
							  
			sqlite3RowSetClear(p);
		}
		return 1;
	}
	else {
		return 0;
	}
}


SQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid) {
	struct RowSetEntry *p, *pTree;

	
	assert(pRowSet != 0 && (pRowSet->rsFlags & ROWSET_NEXT) == 0);

	
	if (iBatch != pRowSet->iBatch) {  
		p = pRowSet->pEntry;
		if (p) {
			struct RowSetEntry **ppPrevTree = &pRowSet->pForest;
			if ((pRowSet->rsFlags & ROWSET_SORTED) == 0) { 
														   
				p = rowSetEntrySort(p);
			}
			for (pTree = pRowSet->pForest; pTree; pTree = pTree->pRight) {
				ppPrevTree = &pTree->pRight;
				if (pTree->pLeft == 0) {
					pTree->pLeft = rowSetListToTree(p);
					break;
				}
				else {
					struct RowSetEntry *pAux, *pTail;
					rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
					pTree->pLeft = 0;
					p = rowSetEntryMerge(pAux, p);
				}
			}
			if (pTree == 0) {
				*ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
				if (pTree) {
					pTree->v = 0;
					pTree->pRight = 0;
					pTree->pLeft = rowSetListToTree(p);
				}
			}
			pRowSet->pEntry = 0;
			pRowSet->pLast = 0;
			pRowSet->rsFlags |= ROWSET_SORTED;
		}
		pRowSet->iBatch = iBatch;
	}

	
	for (pTree = pRowSet->pForest; pTree; pTree = pTree->pRight) {
		p = pTree->pLeft;
		while (p) {
			if (p->v<iRowid) {
				p = p->pRight;
			}
			else if (p->v>iRowid) {
				p = p->pLeft;
			}
			else {
				return 1;
			}
		}
	}
	return 0;
}




#ifndef SQLITE_OMIT_DISKIO





#ifndef SQLITE_WAL_H
#define SQLITE_WAL_H




#define WAL_SYNC_TRANSACTIONS  0x20   
#define SQLITE_SYNC_MASK       0x13   

#ifdef SQLITE_OMIT_WAL
# define sqlite3WalOpen(x,y,z)                   0
# define sqlite3WalLimit(x,y)
# define sqlite3WalClose(w,x,y,z)                0
# define sqlite3WalBeginReadTransaction(y,z)     0
# define sqlite3WalEndReadTransaction(z)
# define sqlite3WalDbsize(y)                     0
# define sqlite3WalBeginWriteTransaction(y)      0
# define sqlite3WalEndWriteTransaction(x)        0
# define sqlite3WalUndo(x,y,z)                   0
# define sqlite3WalSavepoint(y,z)
# define sqlite3WalSavepointUndo(y,z)            0
# define sqlite3WalFrames(u,v,w,x,y,z)           0
# define sqlite3WalCheckpoint(r,s,t,u,v,w,x,y,z) 0
# define sqlite3WalCallback(z)                   0
# define sqlite3WalExclusiveMode(y,z)            0
# define sqlite3WalHeapMemory(z)                 0
# define sqlite3WalFramesize(z)                  0
# define sqlite3WalFindFrame(x,y,z)              0
# define sqlite3WalFile(x)                       0
#else

#define WAL_SAVEPOINT_NDATA 4


typedef struct Wal Wal;


SQLITE_PRIVATE int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**);
SQLITE_PRIVATE int sqlite3WalClose(Wal *pWal, int sync_flags, int, u8 *);


SQLITE_PRIVATE void sqlite3WalLimit(Wal*, i64);


SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *);
SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal);


SQLITE_PRIVATE int sqlite3WalFindFrame(Wal *, Pgno, u32 *);
SQLITE_PRIVATE int sqlite3WalReadFrame(Wal *, u32, int, u8 *);


SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal);


SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal);
SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal);


SQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int(*xUndo)(void *, Pgno), void *pUndoCtx);


SQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);


SQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);


SQLITE_PRIVATE int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);


SQLITE_PRIVATE int sqlite3WalCheckpoint(
	Wal *pWal,                      
	int eMode,                      
	int(*xBusy)(void*),            
	void *pBusyArg,                 
	int sync_flags,                 
	int nBuf,                       
	u8 *zBuf,                       
	int *pnLog,                     
	int *pnCkpt                     
);


SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal);


SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op);


SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal);

#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot);
SQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot);
#endif

#ifdef SQLITE_ENABLE_ZIPVFS

SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal);
#endif


SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal);

#endif 
#endif 








#if 0
int sqlite3PagerTrace = 1;  
#define sqlite3DebugPrintf printf
#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }
#else
#define PAGERTRACE(X)
#endif


#define PAGERID(p) ((int)(p->fd))
#define FILEHANDLEID(fd) ((int)fd)


#define PAGER_OPEN                  0
#define PAGER_READER                1
#define PAGER_WRITER_LOCKED         2
#define PAGER_WRITER_CACHEMOD       3
#define PAGER_WRITER_DBMOD          4
#define PAGER_WRITER_FINISHED       5
#define PAGER_ERROR                 6


#define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1)


#ifdef SQLITE_HAS_CODEC
# define CODEC1(P,D,N,X,E) \
    if( P->xCodec && P->xCodec(P->pCodec,D,N,X)==0 ){ E; }
# define CODEC2(P,D,N,X,E,O) \
    if( P->xCodec==0 ){ O=(char*)D; }else \
    if( (O=(char*)(P->xCodec(P->pCodec,D,N,X)))==0 ){ E; }
#else
# define CODEC1(P,D,N,X,E)   
# define CODEC2(P,D,N,X,E,O) O=(char*)D
#endif


#define MAX_SECTOR_SIZE 0x10000



typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
	i64 iOffset;                 
	i64 iHdrOffset;              
	Bitvec *pInSavepoint;        
	Pgno nOrig;                  
	Pgno iSubRec;                
#ifndef SQLITE_OMIT_WAL
	u32 aWalData[WAL_SAVEPOINT_NDATA];        
#endif
};


#define SPILLFLAG_OFF         0x01 
#define SPILLFLAG_ROLLBACK    0x02 
#define SPILLFLAG_NOSYNC      0x04 


struct Pager {
	sqlite3_vfs *pVfs;          
	u8 exclusiveMode;           
	u8 journalMode;             
	u8 useJournal;              
	u8 noSync;                  
	u8 fullSync;                
	u8 extraSync;               
	u8 ckptSyncFlags;           
	u8 walSyncFlags;            
	u8 syncFlags;               
	u8 tempFile;                
	u8 noLock;                  
	u8 readOnly;                
	u8 memDb;                   

								
	u8 eState;                  
	u8 eLock;                   
	u8 changeCountDone;         
	u8 setMaster;               
	u8 doNotSpill;              
	u8 subjInMemory;            
	u8 bUseFetch;               
	u8 hasHeldSharedLock;       
	Pgno dbSize;                
	Pgno dbOrigSize;            
	Pgno dbFileSize;            
	Pgno dbHintSize;            
	int errCode;                
	int nRec;                   
	u32 cksumInit;              
	u32 nSubRec;                
	Bitvec *pInJournal;         
	sqlite3_file *fd;           
	sqlite3_file *jfd;          
	sqlite3_file *sjfd;         
	i64 journalOff;             
	i64 journalHdr;             
	sqlite3_backup *pBackup;    
	PagerSavepoint *aSavepoint; 
	int nSavepoint;             
	u32 iDataVersion;           
	char dbFileVers[16];        

	int nMmapOut;               
	sqlite3_int64 szMmap;       
	PgHdr *pMmapFreelist;       
								

	u16 nExtra;                 
	i16 nReserve;               
	u32 vfsFlags;               
	u32 sectorSize;             
	int pageSize;               
	Pgno mxPgno;                
	i64 journalSizeLimit;       
	char *zFilename;            
	char *zJournal;             
	int(*xBusyHandler)(void*); 
	void *pBusyHandlerArg;      
	int aStat[3];               
#ifdef SQLITE_TEST
	int nRead;                  
#endif
	void(*xReiniter)(DbPage*); 
#ifdef SQLITE_HAS_CODEC
	void *(*xCodec)(void*, void*, Pgno, int); 
	void(*xCodecSizeChng)(void*, int, int); 
	void(*xCodecFree)(void*);             
	void *pCodec;               
#endif
	char *pTmpSpace;            
	PCache *pPCache;            
#ifndef SQLITE_OMIT_WAL
	Wal *pWal;                  
	char *zWal;                 
#endif
};


#define PAGER_STAT_HIT   0
#define PAGER_STAT_MISS  1
#define PAGER_STAT_WRITE 2


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_pager_readdb_count = 0;    
SQLITE_API int sqlite3_pager_writedb_count = 0;   
SQLITE_API int sqlite3_pager_writej_count = 0;    
# define PAGER_INCR(v)  v++
#else
# define PAGER_INCR(v)
#endif




static const unsigned char aJournalMagic[] = {
	0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
};


#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)


#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)


#ifdef SQLITE_OMIT_MEMORYDB
# define MEMDB 0
#else
# define MEMDB pPager->memDb
#endif


#if SQLITE_MAX_MMAP_SIZE>0
# define USEFETCH(x) ((x)->bUseFetch)
#else
# define USEFETCH(x) 0
#endif


#define PAGER_MAX_PGNO 2147483647


#define isOpen(pFd) ((pFd)->pMethods!=0)


#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3PagerUseWal(Pager *pPager) {
	return (pPager->pWal != 0);
}
# define pagerUseWal(x) sqlite3PagerUseWal(x)
#else
# define pagerUseWal(x) 0
# define pagerRollbackWal(x) 0
# define pagerWalFrames(v,w,x,y) 0
# define pagerOpenWalIfPresent(z) SQLITE_OK
# define pagerBeginReadTransaction(z) SQLITE_OK
#endif

#ifndef NDEBUG 

static int assert_pager_state(Pager *p) {
	Pager *pPager = p;

	
	assert(p->eState == PAGER_OPEN
		|| p->eState == PAGER_READER
		|| p->eState == PAGER_WRITER_LOCKED
		|| p->eState == PAGER_WRITER_CACHEMOD
		|| p->eState == PAGER_WRITER_DBMOD
		|| p->eState == PAGER_WRITER_FINISHED
		|| p->eState == PAGER_ERROR
	);

	
	assert(p->tempFile == 0 || p->eLock == EXCLUSIVE_LOCK);
	assert(p->tempFile == 0 || pPager->changeCountDone);

	
	assert(p->journalMode == PAGER_JOURNALMODE_OFF || p->useJournal);
	assert(p->journalMode != PAGER_JOURNALMODE_OFF || !isOpen(p->jfd));

	
	if (MEMDB) {
		assert(!isOpen(p->fd));
		assert(p->noSync);
		assert(p->journalMode == PAGER_JOURNALMODE_OFF
			|| p->journalMode == PAGER_JOURNALMODE_MEMORY
		);
		assert(p->eState != PAGER_ERROR && p->eState != PAGER_OPEN);
		assert(pagerUseWal(p) == 0);
	}

	
	assert(pPager->changeCountDone == 0 || pPager->eLock >= RESERVED_LOCK);
	assert(p->eLock != PENDING_LOCK);

	switch (p->eState) {
	case PAGER_OPEN:
		assert(!MEMDB);
		assert(pPager->errCode == SQLITE_OK);
		assert(sqlite3PcacheRefCount(pPager->pPCache) == 0 || pPager->tempFile);
		break;

	case PAGER_READER:
		assert(pPager->errCode == SQLITE_OK);
		assert(p->eLock != UNKNOWN_LOCK);
		assert(p->eLock >= SHARED_LOCK);
		break;

	case PAGER_WRITER_LOCKED:
		assert(p->eLock != UNKNOWN_LOCK);
		assert(pPager->errCode == SQLITE_OK);
		if (!pagerUseWal(pPager)) {
			assert(p->eLock >= RESERVED_LOCK);
		}
		assert(pPager->dbSize == pPager->dbOrigSize);
		assert(pPager->dbOrigSize == pPager->dbFileSize);
		assert(pPager->dbOrigSize == pPager->dbHintSize);
		assert(pPager->setMaster == 0);
		break;

	case PAGER_WRITER_CACHEMOD:
		assert(p->eLock != UNKNOWN_LOCK);
		assert(pPager->errCode == SQLITE_OK);
		if (!pagerUseWal(pPager)) {
			
			assert(p->eLock >= RESERVED_LOCK);
			assert(isOpen(p->jfd)
				|| p->journalMode == PAGER_JOURNALMODE_OFF
				|| p->journalMode == PAGER_JOURNALMODE_WAL
			);
		}
		assert(pPager->dbOrigSize == pPager->dbFileSize);
		assert(pPager->dbOrigSize == pPager->dbHintSize);
		break;

	case PAGER_WRITER_DBMOD:
		assert(p->eLock == EXCLUSIVE_LOCK);
		assert(pPager->errCode == SQLITE_OK);
		assert(!pagerUseWal(pPager));
		assert(p->eLock >= EXCLUSIVE_LOCK);
		assert(isOpen(p->jfd)
			|| p->journalMode == PAGER_JOURNALMODE_OFF
			|| p->journalMode == PAGER_JOURNALMODE_WAL
		);
		assert(pPager->dbOrigSize <= pPager->dbHintSize);
		break;

	case PAGER_WRITER_FINISHED:
		assert(p->eLock == EXCLUSIVE_LOCK);
		assert(pPager->errCode == SQLITE_OK);
		assert(!pagerUseWal(pPager));
		assert(isOpen(p->jfd)
			|| p->journalMode == PAGER_JOURNALMODE_OFF
			|| p->journalMode == PAGER_JOURNALMODE_WAL
		);
		break;

	case PAGER_ERROR:
		
		assert(pPager->errCode != SQLITE_OK);
		assert(sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile);
		break;
	}

	return 1;
}
#endif 

#ifdef SQLITE_DEBUG 

static char *print_pager_state(Pager *p) {
	static char zRet[1024];

	sqlite3_snprintf(1024, zRet,
		"Filename:      %s\n"
		"State:         %s errCode=%d\n"
		"Lock:          %s\n"
		"Locking mode:  locking_mode=%s\n"
		"Journal mode:  journal_mode=%s\n"
		"Backing store: tempFile=%d memDb=%d useJournal=%d\n"
		"Journal:       journalOff=%lld journalHdr=%lld\n"
		"Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\n"
		, p->zFilename
		, p->eState == PAGER_OPEN ? "OPEN" :
		p->eState == PAGER_READER ? "READER" :
		p->eState == PAGER_WRITER_LOCKED ? "WRITER_LOCKED" :
		p->eState == PAGER_WRITER_CACHEMOD ? "WRITER_CACHEMOD" :
		p->eState == PAGER_WRITER_DBMOD ? "WRITER_DBMOD" :
		p->eState == PAGER_WRITER_FINISHED ? "WRITER_FINISHED" :
		p->eState == PAGER_ERROR ? "ERROR" : "?error?"
		, (int)p->errCode
		, p->eLock == NO_LOCK ? "NO_LOCK" :
		p->eLock == RESERVED_LOCK ? "RESERVED" :
		p->eLock == EXCLUSIVE_LOCK ? "EXCLUSIVE" :
		p->eLock == SHARED_LOCK ? "SHARED" :
		p->eLock == UNKNOWN_LOCK ? "UNKNOWN" : "?error?"
		, p->exclusiveMode ? "exclusive" : "normal"
		, p->journalMode == PAGER_JOURNALMODE_MEMORY ? "memory" :
		p->journalMode == PAGER_JOURNALMODE_OFF ? "off" :
		p->journalMode == PAGER_JOURNALMODE_DELETE ? "delete" :
		p->journalMode == PAGER_JOURNALMODE_PERSIST ? "persist" :
		p->journalMode == PAGER_JOURNALMODE_TRUNCATE ? "truncate" :
		p->journalMode == PAGER_JOURNALMODE_WAL ? "wal" : "?error?"
		, (int)p->tempFile, (int)p->memDb, (int)p->useJournal
		, p->journalOff, p->journalHdr
		, (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize
	);

	return zRet;
}
#endif


static int subjRequiresPage(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	PagerSavepoint *p;
	Pgno pgno = pPg->pgno;
	int i;
	for (i = 0; i<pPager->nSavepoint; i++) {
		p = &pPager->aSavepoint[i];
		if (p->nOrig >= pgno && 0 == sqlite3BitvecTestNotNull(p->pInSavepoint, pgno)) {
			return 1;
		}
	}
	return 0;
}

#ifdef SQLITE_DEBUG

static int pageInJournal(Pager *pPager, PgHdr *pPg) {
	return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno);
}
#endif


static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes) {
	unsigned char ac[4];
	int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);
	if (rc == SQLITE_OK) {
		*pRes = sqlite3Get4byte(ac);
	}
	return rc;
}


#define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)



static int write32bits(sqlite3_file *fd, i64 offset, u32 val) {
	char ac[4];
	put32bits(ac, val);
	return sqlite3OsWrite(fd, ac, 4, offset);
}


static int pagerUnlockDb(Pager *pPager, int eLock) {
	int rc = SQLITE_OK;

	assert(!pPager->exclusiveMode || pPager->eLock == eLock);
	assert(eLock == NO_LOCK || eLock == SHARED_LOCK);
	assert(eLock != NO_LOCK || pagerUseWal(pPager) == 0);
	if (isOpen(pPager->fd)) {
		assert(pPager->eLock >= eLock);
		rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);
		if (pPager->eLock != UNKNOWN_LOCK) {
			pPager->eLock = (u8)eLock;
		}
		IOTRACE(("UNLOCK %p %d\n", pPager, eLock))
	}
	return rc;
}


static int pagerLockDb(Pager *pPager, int eLock) {
	int rc = SQLITE_OK;

	assert(eLock == SHARED_LOCK || eLock == RESERVED_LOCK || eLock == EXCLUSIVE_LOCK);
	if (pPager->eLock<eLock || pPager->eLock == UNKNOWN_LOCK) {
		rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);
		if (rc == SQLITE_OK && (pPager->eLock != UNKNOWN_LOCK || eLock == EXCLUSIVE_LOCK)) {
			pPager->eLock = (u8)eLock;
			IOTRACE(("LOCK %p %d\n", pPager, eLock))
		}
	}
	return rc;
}


#ifdef SQLITE_ENABLE_ATOMIC_WRITE
static int jrnlBufferSize(Pager *pPager) {
	assert(!MEMDB);
	if (!pPager->tempFile) {
		int dc;                           
		int nSector;                      
		int szPage;                       

		assert(isOpen(pPager->fd));
		dc = sqlite3OsDeviceCharacteristics(pPager->fd);
		nSector = pPager->sectorSize;
		szPage = pPager->pageSize;

		assert(SQLITE_IOCAP_ATOMIC512 == (512 >> 8));
		assert(SQLITE_IOCAP_ATOMIC64K == (65536 >> 8));
		if (0 == (dc&(SQLITE_IOCAP_ATOMIC | (szPage >> 8)) || nSector>szPage)) {
			return 0;
		}
	}

	return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);
}
#else
# define jrnlBufferSize(x) 0
#endif


#ifdef SQLITE_CHECK_PAGES

static u32 pager_datahash(int nByte, unsigned char *pData) {
	u32 hash = 0;
	int i;
	for (i = 0; i<nByte; i++) {
		hash = (hash * 1039) + pData[i];
	}
	return hash;
}
static u32 pager_pagehash(PgHdr *pPage) {
	return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);
}
static void pager_set_pagehash(PgHdr *pPage) {
	pPage->pageHash = pager_pagehash(pPage);
}


#define CHECK_PAGE(x) checkPage(x)
static void checkPage(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	assert(pPager->eState != PAGER_ERROR);
	assert((pPg->flags&PGHDR_DIRTY) || pPg->pageHash == pager_pagehash(pPg));
}

#else
#define pager_datahash(X,Y)  0
#define pager_pagehash(X)  0
#define pager_set_pagehash(X)
#define CHECK_PAGE(x)
#endif  


static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster) {
	int rc;                    
	u32 len;                   
	i64 szJ;                   
	u32 cksum;                 
	u32 u;                     
	unsigned char aMagic[8];   
	zMaster[0] = '\0';

	if (SQLITE_OK != (rc = sqlite3OsFileSize(pJrnl, &szJ))
		|| szJ<16
		|| SQLITE_OK != (rc = read32bits(pJrnl, szJ - 16, &len))
		|| len >= nMaster
		|| len == 0
		|| SQLITE_OK != (rc = read32bits(pJrnl, szJ - 12, &cksum))
		|| SQLITE_OK != (rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ - 8))
		|| memcmp(aMagic, aJournalMagic, 8)
		|| SQLITE_OK != (rc = sqlite3OsRead(pJrnl, zMaster, len, szJ - 16 - len))
		) {
		return rc;
	}

	
	for (u = 0; u<len; u++) {
		cksum -= zMaster[u];
	}
	if (cksum) {
		
		len = 0;
	}
	zMaster[len] = '\0';

	return SQLITE_OK;
}


static i64 journalHdrOffset(Pager *pPager) {
	i64 offset = 0;
	i64 c = pPager->journalOff;
	if (c) {
		offset = ((c - 1) / JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);
	}
	assert(offset%JOURNAL_HDR_SZ(pPager) == 0);
	assert(offset >= c);
	assert((offset - c)<JOURNAL_HDR_SZ(pPager));
	return offset;
}


static int zeroJournalHdr(Pager *pPager, int doTruncate) {
	int rc = SQLITE_OK;                               
	assert(isOpen(pPager->jfd));
	assert(!sqlite3JournalIsInMemory(pPager->jfd));
	if (pPager->journalOff) {
		const i64 iLimit = pPager->journalSizeLimit;    

		IOTRACE(("JZEROHDR %p\n", pPager))
			if (doTruncate || iLimit == 0) {
				rc = sqlite3OsTruncate(pPager->jfd, 0);
			}
			else {
				static const char zeroHdr[28] = { 0 };
				rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
			}
			if (rc == SQLITE_OK && !pPager->noSync) {
				rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY | pPager->syncFlags);
			}

			
			if (rc == SQLITE_OK && iLimit>0) {
				i64 sz;
				rc = sqlite3OsFileSize(pPager->jfd, &sz);
				if (rc == SQLITE_OK && sz>iLimit) {
					rc = sqlite3OsTruncate(pPager->jfd, iLimit);
				}
			}
	}
	return rc;
}


static int writeJournalHdr(Pager *pPager) {
	int rc = SQLITE_OK;                 
	char *zHeader = pPager->pTmpSpace;  
	u32 nHeader = (u32)pPager->pageSize;
	u32 nWrite;                         
	int ii;                             

	assert(isOpen(pPager->jfd));      

	if (nHeader>JOURNAL_HDR_SZ(pPager)) {
		nHeader = JOURNAL_HDR_SZ(pPager);
	}

	
	for (ii = 0; ii<pPager->nSavepoint; ii++) {
		if (pPager->aSavepoint[ii].iHdrOffset == 0) {
			pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
		}
	}

	pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);

	
	assert(isOpen(pPager->fd) || pPager->noSync);
	if (pPager->noSync || (pPager->journalMode == PAGER_JOURNALMODE_MEMORY)
		|| (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND)
		) {
		memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
		put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);
	}
	else {
		memset(zHeader, 0, sizeof(aJournalMagic) + 4);
	}

	
	sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
	put32bits(&zHeader[sizeof(aJournalMagic) + 4], pPager->cksumInit);
	
	put32bits(&zHeader[sizeof(aJournalMagic) + 8], pPager->dbOrigSize);
	
	put32bits(&zHeader[sizeof(aJournalMagic) + 12], pPager->sectorSize);

	
	put32bits(&zHeader[sizeof(aJournalMagic) + 16], pPager->pageSize);

	
	memset(&zHeader[sizeof(aJournalMagic) + 20], 0,
		nHeader - (sizeof(aJournalMagic) + 20));

	
	for (nWrite = 0; rc == SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite += nHeader) {
		IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))
			rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
		assert(pPager->journalHdr <= pPager->journalOff);
		pPager->journalOff += nHeader;
	}

	return rc;
}


static int readJournalHdr(
	Pager *pPager,               
	int isHot,
	i64 journalSize,             
	u32 *pNRec,                  
	u32 *pDbSize                 
) {
	int rc;                      
	unsigned char aMagic[8];     
	i64 iHdrOff;                 

	assert(isOpen(pPager->jfd));      

									  
	pPager->journalOff = journalHdrOffset(pPager);
	if (pPager->journalOff + JOURNAL_HDR_SZ(pPager) > journalSize) {
		return SQLITE_DONE;
	}
	iHdrOff = pPager->journalOff;

	
	if (isHot || iHdrOff != pPager->journalHdr) {
		rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
		if (rc) {
			return rc;
		}
		if (memcmp(aMagic, aJournalMagic, sizeof(aMagic)) != 0) {
			return SQLITE_DONE;
		}
	}

	
	if (SQLITE_OK != (rc = read32bits(pPager->jfd, iHdrOff + 8, pNRec))
		|| SQLITE_OK != (rc = read32bits(pPager->jfd, iHdrOff + 12, &pPager->cksumInit))
		|| SQLITE_OK != (rc = read32bits(pPager->jfd, iHdrOff + 16, pDbSize))
		) {
		return rc;
	}

	if (pPager->journalOff == 0) {
		u32 iPageSize;               
		u32 iSectorSize;             

									 
		if (SQLITE_OK != (rc = read32bits(pPager->jfd, iHdrOff + 20, &iSectorSize))
			|| SQLITE_OK != (rc = read32bits(pPager->jfd, iHdrOff + 24, &iPageSize))
			) {
			return rc;
		}

		
		if (iPageSize == 0) {
			iPageSize = pPager->pageSize;
		}

		
		if (iPageSize<512 || iSectorSize<32
			|| iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZE
			|| ((iPageSize - 1)&iPageSize) != 0 || ((iSectorSize - 1)&iSectorSize) != 0
			) {
			
			return SQLITE_DONE;
		}

		
		rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);
		testcase(rc != SQLITE_OK);

		
		pPager->sectorSize = iSectorSize;
	}

	pPager->journalOff += JOURNAL_HDR_SZ(pPager);
	return rc;
}



static int writeMasterJournal(Pager *pPager, const char *zMaster) {
	int rc;                          
	int nMaster;                     
	i64 iHdrOff;                     
	i64 jrnlSize;                    
	u32 cksum = 0;                   

	assert(pPager->setMaster == 0);
	assert(!pagerUseWal(pPager));

	if (!zMaster
		|| pPager->journalMode == PAGER_JOURNALMODE_MEMORY
		|| !isOpen(pPager->jfd)
		) {
		return SQLITE_OK;
	}
	pPager->setMaster = 1;
	assert(pPager->journalHdr <= pPager->journalOff);

	
	for (nMaster = 0; zMaster[nMaster]; nMaster++) {
		cksum += zMaster[nMaster];
	}

	
	if (pPager->fullSync) {
		pPager->journalOff = journalHdrOffset(pPager);
	}
	iHdrOff = pPager->journalOff;

	
	if ((0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))
		|| (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff + 4)))
		|| (0 != (rc = write32bits(pPager->jfd, iHdrOff + 4 + nMaster, nMaster)))
		|| (0 != (rc = write32bits(pPager->jfd, iHdrOff + 4 + nMaster + 4, cksum)))
		|| (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,
			iHdrOff + 4 + nMaster + 8)))
		) {
		return rc;
	}
	pPager->journalOff += (nMaster + 20);

	
	if (SQLITE_OK == (rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
		&& jrnlSize>pPager->journalOff
		) {
		rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
	}
	return rc;
}


static void pager_reset(Pager *pPager) {
	pPager->iDataVersion++;
	sqlite3BackupRestart(pPager->pBackup);
	sqlite3PcacheClear(pPager->pPCache);
}


SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager *pPager) {
	assert(pPager->eState>PAGER_OPEN);
	return pPager->iDataVersion;
}


static void releaseAllSavepoints(Pager *pPager) {
	int ii;               
	for (ii = 0; ii<pPager->nSavepoint; ii++) {
		sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
	}
	if (!pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd)) {
		sqlite3OsClose(pPager->sjfd);
	}
	sqlite3_free(pPager->aSavepoint);
	pPager->aSavepoint = 0;
	pPager->nSavepoint = 0;
	pPager->nSubRec = 0;
}


static int addToSavepointBitvecs(Pager *pPager, Pgno pgno) {
	int ii;                   
	int rc = SQLITE_OK;       

	for (ii = 0; ii<pPager->nSavepoint; ii++) {
		PagerSavepoint *p = &pPager->aSavepoint[ii];
		if (pgno <= p->nOrig) {
			rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);
			testcase(rc == SQLITE_NOMEM);
			assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
		}
	}
	return rc;
}


static void pager_unlock(Pager *pPager) {

	assert(pPager->eState == PAGER_READER
		|| pPager->eState == PAGER_OPEN
		|| pPager->eState == PAGER_ERROR
	);

	sqlite3BitvecDestroy(pPager->pInJournal);
	pPager->pInJournal = 0;
	releaseAllSavepoints(pPager);

	if (pagerUseWal(pPager)) {
		assert(!isOpen(pPager->jfd));
		sqlite3WalEndReadTransaction(pPager->pWal);
		pPager->eState = PAGER_OPEN;
	}
	else if (!pPager->exclusiveMode) {
		int rc;                       
		int iDc = isOpen(pPager->fd) ? sqlite3OsDeviceCharacteristics(pPager->fd) : 0;

		
		assert((PAGER_JOURNALMODE_MEMORY & 5) != 1);
		assert((PAGER_JOURNALMODE_OFF & 5) != 1);
		assert((PAGER_JOURNALMODE_WAL & 5) != 1);
		assert((PAGER_JOURNALMODE_DELETE & 5) != 1);
		assert((PAGER_JOURNALMODE_TRUNCATE & 5) == 1);
		assert((PAGER_JOURNALMODE_PERSIST & 5) == 1);
		if (0 == (iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)
			|| 1 != (pPager->journalMode & 5)
			) {
			sqlite3OsClose(pPager->jfd);
		}

		
		rc = pagerUnlockDb(pPager, NO_LOCK);
		if (rc != SQLITE_OK && pPager->eState == PAGER_ERROR) {
			pPager->eLock = UNKNOWN_LOCK;
		}

		
		assert(pPager->errCode || pPager->eState != PAGER_ERROR);
		pPager->changeCountDone = 0;
		pPager->eState = PAGER_OPEN;
	}

	
	assert(pPager->errCode == SQLITE_OK || !MEMDB);
	if (pPager->errCode) {
		if (pPager->tempFile == 0) {
			pager_reset(pPager);
			pPager->changeCountDone = 0;
			pPager->eState = PAGER_OPEN;
		}
		else {
			pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);
		}
		if (USEFETCH(pPager)) sqlite3OsUnfetch(pPager->fd, 0, 0);
		pPager->errCode = SQLITE_OK;
	}

	pPager->journalOff = 0;
	pPager->journalHdr = 0;
	pPager->setMaster = 0;
}


static int pager_error(Pager *pPager, int rc) {
	int rc2 = rc & 0xff;
	assert(rc == SQLITE_OK || !MEMDB);
	assert(
		pPager->errCode == SQLITE_FULL ||
		pPager->errCode == SQLITE_OK ||
		(pPager->errCode & 0xff) == SQLITE_IOERR
	);
	if (rc2 == SQLITE_FULL || rc2 == SQLITE_IOERR) {
		pPager->errCode = rc;
		pPager->eState = PAGER_ERROR;
	}
	return rc;
}

static int pager_truncate(Pager *pPager, Pgno nPage);


static int pagerFlushOnCommit(Pager *pPager, int bCommit) {
	if (pPager->tempFile == 0) return 1;
	if (!bCommit) return 0;
	if (!isOpen(pPager->fd)) return 0;
	return (sqlite3PCachePercentDirty(pPager->pPCache) >= 25);
}


static int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit) {
	int rc = SQLITE_OK;      
	int rc2 = SQLITE_OK;     

							 
	assert(assert_pager_state(pPager));
	assert(pPager->eState != PAGER_ERROR);
	if (pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK) {
		return SQLITE_OK;
	}

	releaseAllSavepoints(pPager);
	assert(isOpen(pPager->jfd) || pPager->pInJournal == 0);
	if (isOpen(pPager->jfd)) {
		assert(!pagerUseWal(pPager));

		
		if (sqlite3JournalIsInMemory(pPager->jfd)) {
			
			sqlite3OsClose(pPager->jfd);
		}
		else if (pPager->journalMode == PAGER_JOURNALMODE_TRUNCATE) {
			if (pPager->journalOff == 0) {
				rc = SQLITE_OK;
			}
			else {
				rc = sqlite3OsTruncate(pPager->jfd, 0);
				if (rc == SQLITE_OK && pPager->fullSync) {
					
					rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
				}
			}
			pPager->journalOff = 0;
		}
		else if (pPager->journalMode == PAGER_JOURNALMODE_PERSIST
			|| (pPager->exclusiveMode && pPager->journalMode != PAGER_JOURNALMODE_WAL)
			) {
			rc = zeroJournalHdr(pPager, hasMaster || pPager->tempFile);
			pPager->journalOff = 0;
		}
		else {
			
			int bDelete = !pPager->tempFile;
			assert(sqlite3JournalIsInMemory(pPager->jfd) == 0);
			assert(pPager->journalMode == PAGER_JOURNALMODE_DELETE
				|| pPager->journalMode == PAGER_JOURNALMODE_MEMORY
				|| pPager->journalMode == PAGER_JOURNALMODE_WAL
			);
			sqlite3OsClose(pPager->jfd);
			if (bDelete) {
				rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
			}
		}
	}

#ifdef SQLITE_CHECK_PAGES
	sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);
	if (pPager->dbSize == 0 && sqlite3PcacheRefCount(pPager->pPCache)>0) {
		PgHdr *p = sqlite3PagerLookup(pPager, 1);
		if (p) {
			p->pageHash = 0;
			sqlite3PagerUnrefNotNull(p);
		}
	}
#endif

	sqlite3BitvecDestroy(pPager->pInJournal);
	pPager->pInJournal = 0;
	pPager->nRec = 0;
	if (rc == SQLITE_OK) {
		if (pagerFlushOnCommit(pPager, bCommit)) {
			sqlite3PcacheCleanAll(pPager->pPCache);
		}
		else {
			sqlite3PcacheClearWritable(pPager->pPCache);
		}
		sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
	}

	if (pagerUseWal(pPager)) {
		
		rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
		assert(rc2 == SQLITE_OK);
	}
	else if (rc == SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize) {
		
		assert(pPager->eLock == EXCLUSIVE_LOCK);
		rc = pager_truncate(pPager, pPager->dbSize);
	}

	if (rc == SQLITE_OK && bCommit && isOpen(pPager->fd)) {
		rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);
		if (rc == SQLITE_NOTFOUND) rc = SQLITE_OK;
	}

	if (!pPager->exclusiveMode
		&& (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))
		) {
		rc2 = pagerUnlockDb(pPager, SHARED_LOCK);
		pPager->changeCountDone = 0;
	}
	pPager->eState = PAGER_READER;
	pPager->setMaster = 0;

	return (rc == SQLITE_OK ? rc2 : rc);
}


static void pagerUnlockAndRollback(Pager *pPager) {
	if (pPager->eState != PAGER_ERROR && pPager->eState != PAGER_OPEN) {
		assert(assert_pager_state(pPager));
		if (pPager->eState >= PAGER_WRITER_LOCKED) {
			sqlite3BeginBenignMalloc();
			sqlite3PagerRollback(pPager);
			sqlite3EndBenignMalloc();
		}
		else if (!pPager->exclusiveMode) {
			assert(pPager->eState == PAGER_READER);
			pager_end_transaction(pPager, 0, 0);
		}
	}
	pager_unlock(pPager);
}


static u32 pager_cksum(Pager *pPager, const u8 *aData) {
	u32 cksum = pPager->cksumInit;         
	int i = pPager->pageSize - 200;          
	while (i>0) {
		cksum += aData[i];
		i -= 200;
	}
	return cksum;
}


#ifdef SQLITE_HAS_CODEC
static void pagerReportSize(Pager *pPager) {
	if (pPager->xCodecSizeChng) {
		pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,
			(int)pPager->nReserve);
	}
}
#else
# define pagerReportSize(X)     
#endif

#ifdef SQLITE_HAS_CODEC

SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc) {
	if (pDest->nReserve != pSrc->nReserve) {
		pDest->nReserve = pSrc->nReserve;
		pagerReportSize(pDest);
	}
}
#endif


static int pager_playback_one_page(
	Pager *pPager,                
	i64 *pOffset,                 
	Bitvec *pDone,                
	int isMainJrnl,               
	int isSavepnt                 
) {
	int rc;
	PgHdr *pPg;                   
	Pgno pgno;                    
	u32 cksum;                    
	char *aData;                  
	sqlite3_file *jfd;            
	int isSynced;                 

	assert((isMainJrnl&~1) == 0);      
	assert((isSavepnt&~1) == 0);       
	assert(isMainJrnl || pDone);     
	assert(isSavepnt || pDone == 0);   

	aData = pPager->pTmpSpace;
	assert(aData);         
	assert(pagerUseWal(pPager) == 0 || (!isMainJrnl && isSavepnt));

	
	assert(pPager->eState >= PAGER_WRITER_CACHEMOD
		|| (pPager->eState == PAGER_OPEN && pPager->eLock == EXCLUSIVE_LOCK)
	);
	assert(pPager->eState >= PAGER_WRITER_CACHEMOD || isMainJrnl);

	
	jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
	rc = read32bits(jfd, *pOffset, &pgno);
	if (rc != SQLITE_OK) return rc;
	rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset) + 4);
	if (rc != SQLITE_OK) return rc;
	*pOffset += pPager->pageSize + 4 + isMainJrnl * 4;

	
	if (pgno == 0 || pgno == PAGER_MJ_PGNO(pPager)) {
		assert(!isSavepnt);
		return SQLITE_DONE;
	}
	if (pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno)) {
		return SQLITE_OK;
	}
	if (isMainJrnl) {
		rc = read32bits(jfd, (*pOffset) - 4, &cksum);
		if (rc) return rc;
		if (!isSavepnt && pager_cksum(pPager, (u8*)aData) != cksum) {
			return SQLITE_DONE;
		}
	}

	
	if (pDone && (rc = sqlite3BitvecSet(pDone, pgno)) != SQLITE_OK) {
		return rc;
	}

	
	if (pgno == 1 && pPager->nReserve != ((u8*)aData)[20]) {
		pPager->nReserve = ((u8*)aData)[20];
		pagerReportSize(pPager);
	}

	
	if (pagerUseWal(pPager)) {
		pPg = 0;
	}
	else {
		pPg = sqlite3PagerLookup(pPager, pgno);
	}
	assert(pPg || !MEMDB);
	assert(pPager->eState != PAGER_OPEN || pPg == 0 || pPager->tempFile);
	PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",
		PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),
		(isMainJrnl ? "main-journal" : "sub-journal")
		));
	if (isMainJrnl) {
		isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
	}
	else {
		isSynced = (pPg == 0 || 0 == (pPg->flags & PGHDR_NEED_SYNC));
	}
	if (isOpen(pPager->fd)
		&& (pPager->eState >= PAGER_WRITER_DBMOD || pPager->eState == PAGER_OPEN)
		&& isSynced
		) {
		i64 ofst = (pgno - 1)*(i64)pPager->pageSize;
		testcase(!isSavepnt && pPg != 0 && (pPg->flags&PGHDR_NEED_SYNC) != 0);
		assert(!pagerUseWal(pPager));
		rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);
		if (pgno>pPager->dbFileSize) {
			pPager->dbFileSize = pgno;
		}
		if (pPager->pBackup) {
			CODEC1(pPager, aData, pgno, 3, rc = SQLITE_NOMEM_BKPT);
			sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
			CODEC2(pPager, aData, pgno, 7, rc = SQLITE_NOMEM_BKPT, aData);
		}
	}
	else if (!isMainJrnl && pPg == 0) {
		
		assert(isSavepnt);
		assert((pPager->doNotSpill & SPILLFLAG_ROLLBACK) == 0);
		pPager->doNotSpill |= SPILLFLAG_ROLLBACK;
		rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);
		assert((pPager->doNotSpill & SPILLFLAG_ROLLBACK) != 0);
		pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;
		if (rc != SQLITE_OK) return rc;
		sqlite3PcacheMakeDirty(pPg);
	}
	if (pPg) {
		
		void *pData;
		pData = pPg->pData;
		memcpy(pData, (u8*)aData, pPager->pageSize);
		pPager->xReiniter(pPg);
		
		pager_set_pagehash(pPg);

		
		if (pgno == 1) {
			memcpy(&pPager->dbFileVers, &((u8*)pData)[24], sizeof(pPager->dbFileVers));
		}

		
		CODEC1(pPager, pData, pPg->pgno, 3, rc = SQLITE_NOMEM_BKPT);
		sqlite3PcacheRelease(pPg);
	}
	return rc;
}


static int pager_delmaster(Pager *pPager, const char *zMaster) {
	sqlite3_vfs *pVfs = pPager->pVfs;
	int rc;                   
	sqlite3_file *pMaster;    
	sqlite3_file *pJournal;   
	char *zMasterJournal = 0; 
	i64 nMasterJournal;       
	char *zJournal;           
	char *zMasterPtr;         
	int nMasterPtr;           

							  
	pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);
	pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);
	if (!pMaster) {
		rc = SQLITE_NOMEM_BKPT;
	}
	else {
		const int flags = (SQLITE_OPEN_READONLY | SQLITE_OPEN_MASTER_JOURNAL);
		rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);
	}
	if (rc != SQLITE_OK) goto delmaster_out;

	
	rc = sqlite3OsFileSize(pMaster, &nMasterJournal);
	if (rc != SQLITE_OK) goto delmaster_out;
	nMasterPtr = pVfs->mxPathname + 1;
	zMasterJournal = sqlite3Malloc(nMasterJournal + nMasterPtr + 1);
	if (!zMasterJournal) {
		rc = SQLITE_NOMEM_BKPT;
		goto delmaster_out;
	}
	zMasterPtr = &zMasterJournal[nMasterJournal + 1];
	rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);
	if (rc != SQLITE_OK) goto delmaster_out;
	zMasterJournal[nMasterJournal] = 0;

	zJournal = zMasterJournal;
	while ((zJournal - zMasterJournal)<nMasterJournal) {
		int exists;
		rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);
		if (rc != SQLITE_OK) {
			goto delmaster_out;
		}
		if (exists) {
			
			int c;
			int flags = (SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL);
			rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
			if (rc != SQLITE_OK) {
				goto delmaster_out;
			}

			rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);
			sqlite3OsClose(pJournal);
			if (rc != SQLITE_OK) {
				goto delmaster_out;
			}

			c = zMasterPtr[0] != 0 && strcmp(zMasterPtr, zMaster) == 0;
			if (c) {
				
				goto delmaster_out;
			}
		}
		zJournal += (sqlite3Strlen30(zJournal) + 1);
	}

	sqlite3OsClose(pMaster);
	rc = sqlite3OsDelete(pVfs, zMaster, 0);

delmaster_out:
	sqlite3_free(zMasterJournal);
	if (pMaster) {
		sqlite3OsClose(pMaster);
		assert(!isOpen(pJournal));
		sqlite3_free(pMaster);
	}
	return rc;
}



static int pager_truncate(Pager *pPager, Pgno nPage) {
	int rc = SQLITE_OK;
	assert(pPager->eState != PAGER_ERROR);
	assert(pPager->eState != PAGER_READER);

	if (isOpen(pPager->fd)
		&& (pPager->eState >= PAGER_WRITER_DBMOD || pPager->eState == PAGER_OPEN)
		) {
		i64 currentSize, newSize;
		int szPage = pPager->pageSize;
		assert(pPager->eLock == EXCLUSIVE_LOCK);
		
		rc = sqlite3OsFileSize(pPager->fd, &currentSize);
		newSize = szPage*(i64)nPage;
		if (rc == SQLITE_OK && currentSize != newSize) {
			if (currentSize>newSize) {
				rc = sqlite3OsTruncate(pPager->fd, newSize);
			}
			else if ((currentSize + szPage) <= newSize) {
				char *pTmp = pPager->pTmpSpace;
				memset(pTmp, 0, szPage);
				testcase((newSize - szPage) == currentSize);
				testcase((newSize - szPage) >  currentSize);
				rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize - szPage);
			}
			if (rc == SQLITE_OK) {
				pPager->dbFileSize = nPage;
			}
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *pFile) {
	int iRet = sqlite3OsSectorSize(pFile);
	if (iRet<32) {
		iRet = 512;
	}
	else if (iRet>MAX_SECTOR_SIZE) {
		assert(MAX_SECTOR_SIZE >= 512);
		iRet = MAX_SECTOR_SIZE;
	}
	return iRet;
}


static void setSectorSize(Pager *pPager) {
	assert(isOpen(pPager->fd) || pPager->tempFile);

	if (pPager->tempFile
		|| (sqlite3OsDeviceCharacteristics(pPager->fd) &
			SQLITE_IOCAP_POWERSAFE_OVERWRITE) != 0
		) {
		
		pPager->sectorSize = 512;
	}
	else {
		pPager->sectorSize = sqlite3SectorSize(pPager->fd);
	}
}


static int pager_playback(Pager *pPager, int isHot) {
	sqlite3_vfs *pVfs = pPager->pVfs;
	i64 szJ;                 
	u32 nRec;                
	u32 u;                   
	Pgno mxPg = 0;           
	int rc;                  
	int res = 1;             
	char *zMaster = 0;       
	int needPagerReset;      
	int nPlayback = 0;       

							 
	assert(isOpen(pPager->jfd));
	rc = sqlite3OsFileSize(pPager->jfd, &szJ);
	if (rc != SQLITE_OK) {
		goto end_playback;
	}

	
	zMaster = pPager->pTmpSpace;
	rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname + 1);
	if (rc == SQLITE_OK && zMaster[0]) {
		rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);
	}
	zMaster = 0;
	if (rc != SQLITE_OK || !res) {
		goto end_playback;
	}
	pPager->journalOff = 0;
	needPagerReset = isHot;

	
	while (1) {
		
		rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
		if (rc != SQLITE_OK) {
			if (rc == SQLITE_DONE) {
				rc = SQLITE_OK;
			}
			goto end_playback;
		}

		
		if (nRec == 0xffffffff) {
			assert(pPager->journalOff == JOURNAL_HDR_SZ(pPager));
			nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager)) / JOURNAL_PG_SZ(pPager));
		}

		
		if (nRec == 0 && !isHot &&
			pPager->journalHdr + JOURNAL_HDR_SZ(pPager) == pPager->journalOff) {
			nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
		}

		
		if (pPager->journalOff == JOURNAL_HDR_SZ(pPager)) {
			rc = pager_truncate(pPager, mxPg);
			if (rc != SQLITE_OK) {
				goto end_playback;
			}
			pPager->dbSize = mxPg;
		}

		
		for (u = 0; u<nRec; u++) {
			if (needPagerReset) {
				pager_reset(pPager);
				needPagerReset = 0;
			}
			rc = pager_playback_one_page(pPager, &pPager->journalOff, 0, 1, 0);
			if (rc == SQLITE_OK) {
				nPlayback++;
			}
			else {
				if (rc == SQLITE_DONE) {
					pPager->journalOff = szJ;
					break;
				}
				else if (rc == SQLITE_IOERR_SHORT_READ) {
					
					rc = SQLITE_OK;
					goto end_playback;
				}
				else {
					
					goto end_playback;
				}
			}
		}
	}
	
	assert(0);

end_playback:
	
#ifdef SQLITE_DEBUG
	if (pPager->fd->pMethods) {
		sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_DB_UNCHANGED, 0);
	}
#endif

	
	pPager->changeCountDone = pPager->tempFile;

	if (rc == SQLITE_OK) {
		zMaster = pPager->pTmpSpace;
		rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname + 1);
		testcase(rc != SQLITE_OK);
	}
	if (rc == SQLITE_OK
		&& (pPager->eState >= PAGER_WRITER_DBMOD || pPager->eState == PAGER_OPEN)
		) {
		rc = sqlite3PagerSync(pPager, 0);
	}
	if (rc == SQLITE_OK) {
		rc = pager_end_transaction(pPager, zMaster[0] != '\0', 0);
		testcase(rc != SQLITE_OK);
	}
	if (rc == SQLITE_OK && zMaster[0] && res) {
		
		rc = pager_delmaster(pPager, zMaster);
		testcase(rc != SQLITE_OK);
	}
	if (isHot && nPlayback) {
		sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",
			nPlayback, pPager->zJournal);
	}

	
	setSectorSize(pPager);
	return rc;
}



static int readDbPage(PgHdr *pPg, u32 iFrame) {
	Pager *pPager = pPg->pPager; 
	Pgno pgno = pPg->pgno;       
	int rc = SQLITE_OK;          
	int pgsz = pPager->pageSize; 

	assert(pPager->eState >= PAGER_READER && !MEMDB);
	assert(isOpen(pPager->fd));

#ifndef SQLITE_OMIT_WAL
	if (iFrame) {
		
		rc = sqlite3WalReadFrame(pPager->pWal, iFrame, pgsz, pPg->pData);
	}
	else
#endif
	{
		i64 iOffset = (pgno - 1)*(i64)pPager->pageSize;
		rc = sqlite3OsRead(pPager->fd, pPg->pData, pgsz, iOffset);
		if (rc == SQLITE_IOERR_SHORT_READ) {
			rc = SQLITE_OK;
		}
	}

	if (pgno == 1) {
		if (rc) {
			
			memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
		}
		else {
			u8 *dbFileVers = &((u8*)pPg->pData)[24];
			memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
		}
	}
	CODEC1(pPager, pPg->pData, pgno, 3, rc = SQLITE_NOMEM_BKPT);

	PAGER_INCR(sqlite3_pager_readdb_count);
	PAGER_INCR(pPager->nRead);
	IOTRACE(("PGIN %p %d\n", pPager, pgno));
	PAGERTRACE(("FETCH %d page %d hash(%08x)\n",
		PAGERID(pPager), pgno, pager_pagehash(pPg)));

	return rc;
}


static void pager_write_changecounter(PgHdr *pPg) {
	u32 change_counter;

	
	change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers) + 1;
	put32bits(((char*)pPg->pData) + 24, change_counter);

	
	put32bits(((char*)pPg->pData) + 92, change_counter);
	put32bits(((char*)pPg->pData) + 96, SQLITE_VERSION_NUMBER);
}

#ifndef SQLITE_OMIT_WAL

static int pagerUndoCallback(void *pCtx, Pgno iPg) {
	int rc = SQLITE_OK;
	Pager *pPager = (Pager *)pCtx;
	PgHdr *pPg;

	assert(pagerUseWal(pPager));
	pPg = sqlite3PagerLookup(pPager, iPg);
	if (pPg) {
		if (sqlite3PcachePageRefcount(pPg) == 1) {
			sqlite3PcacheDrop(pPg);
		}
		else {
			u32 iFrame = 0;
			rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);
			if (rc == SQLITE_OK) {
				rc = readDbPage(pPg, iFrame);
			}
			if (rc == SQLITE_OK) {
				pPager->xReiniter(pPg);
			}
			sqlite3PagerUnrefNotNull(pPg);
		}
	}

	
	sqlite3BackupRestart(pPager->pBackup);

	return rc;
}


static int pagerRollbackWal(Pager *pPager) {
	int rc;                         
	PgHdr *pList;                   

									
	pPager->dbSize = pPager->dbOrigSize;
	rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
	pList = sqlite3PcacheDirtyList(pPager->pPCache);
	while (pList && rc == SQLITE_OK) {
		PgHdr *pNext = pList->pDirty;
		rc = pagerUndoCallback((void *)pPager, pList->pgno);
		pList = pNext;
	}

	return rc;
}


static int pagerWalFrames(
	Pager *pPager,                  
	PgHdr *pList,                   
	Pgno nTruncate,                 
	int isCommit                    
) {
	int rc;                         
	int nList;                      
	PgHdr *p;                       

	assert(pPager->pWal);
	assert(pList);
#ifdef SQLITE_DEBUG
	
	for (p = pList; p && p->pDirty; p = p->pDirty) {
		assert(p->pgno < p->pDirty->pgno);
	}
#endif

	assert(pList->pDirty == 0 || isCommit);
	if (isCommit) {
		
		PgHdr **ppNext = &pList;
		nList = 0;
		for (p = pList; (*ppNext = p) != 0; p = p->pDirty) {
			if (p->pgno <= nTruncate) {
				ppNext = &p->pDirty;
				nList++;
			}
		}
		assert(pList);
	}
	else {
		nList = 1;
	}
	pPager->aStat[PAGER_STAT_WRITE] += nList;

	if (pList->pgno == 1) pager_write_changecounter(pList);
	rc = sqlite3WalFrames(pPager->pWal,
		pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
	);
	if (rc == SQLITE_OK && pPager->pBackup) {
		for (p = pList; p; p = p->pDirty) {
			sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
		}
	}

#ifdef SQLITE_CHECK_PAGES
	pList = sqlite3PcacheDirtyList(pPager->pPCache);
	for (p = pList; p; p = p->pDirty) {
		pager_set_pagehash(p);
	}
#endif

	return rc;
}


static int pagerBeginReadTransaction(Pager *pPager) {
	int rc;                         
	int changed = 0;                

	assert(pagerUseWal(pPager));
	assert(pPager->eState == PAGER_OPEN || pPager->eState == PAGER_READER);

	
	sqlite3WalEndReadTransaction(pPager->pWal);

	rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
	if (rc != SQLITE_OK || changed) {
		pager_reset(pPager);
		if (USEFETCH(pPager)) sqlite3OsUnfetch(pPager->fd, 0, 0);
	}

	return rc;
}
#endif


static int pagerPagecount(Pager *pPager, Pgno *pnPage) {
	Pgno nPage;                     

									
	assert(pPager->eState == PAGER_OPEN);
	assert(pPager->eLock >= SHARED_LOCK);
	assert(isOpen(pPager->fd));
	assert(pPager->tempFile == 0);
	nPage = sqlite3WalDbsize(pPager->pWal);

	
	if (nPage == 0 && ALWAYS(isOpen(pPager->fd))) {
		i64 n = 0;                    
		int rc = sqlite3OsFileSize(pPager->fd, &n);
		if (rc != SQLITE_OK) {
			return rc;
		}
		nPage = (Pgno)((n + pPager->pageSize - 1) / pPager->pageSize);
	}

	
	if (nPage>pPager->mxPgno) {
		pPager->mxPgno = (Pgno)nPage;
	}

	*pnPage = nPage;
	return SQLITE_OK;
}

#ifndef SQLITE_OMIT_WAL

static int pagerOpenWalIfPresent(Pager *pPager) {
	int rc = SQLITE_OK;
	assert(pPager->eState == PAGER_OPEN);
	assert(pPager->eLock >= SHARED_LOCK);

	if (!pPager->tempFile) {
		int isWal;                    
		Pgno nPage;                   

		rc = pagerPagecount(pPager, &nPage);
		if (rc) return rc;
		if (nPage == 0) {
			rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
			if (rc == SQLITE_IOERR_DELETE_NOENT) rc = SQLITE_OK;
			isWal = 0;
		}
		else {
			rc = sqlite3OsAccess(
				pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
			);
		}
		if (rc == SQLITE_OK) {
			if (isWal) {
				testcase(sqlite3PcachePagecount(pPager->pPCache) == 0);
				rc = sqlite3PagerOpenWal(pPager, 0);
			}
			else if (pPager->journalMode == PAGER_JOURNALMODE_WAL) {
				pPager->journalMode = PAGER_JOURNALMODE_DELETE;
			}
		}
	}
	return rc;
}
#endif


static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint) {
	i64 szJ;                 
	i64 iHdrOff;             
	int rc = SQLITE_OK;      
	Bitvec *pDone = 0;       

	assert(pPager->eState != PAGER_ERROR);
	assert(pPager->eState >= PAGER_WRITER_LOCKED);

	
	if (pSavepoint) {
		pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
		if (!pDone) {
			return SQLITE_NOMEM_BKPT;
		}
	}

	
	pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
	pPager->changeCountDone = pPager->tempFile;

	if (!pSavepoint && pagerUseWal(pPager)) {
		return pagerRollbackWal(pPager);
	}

	
	szJ = pPager->journalOff;
	assert(pagerUseWal(pPager) == 0 || szJ == 0);

	
	if (pSavepoint && !pagerUseWal(pPager)) {
		iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;
		pPager->journalOff = pSavepoint->iOffset;
		while (rc == SQLITE_OK && pPager->journalOff<iHdrOff) {
			rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
		}
		assert(rc != SQLITE_DONE);
	}
	else {
		pPager->journalOff = 0;
	}

	
	while (rc == SQLITE_OK && pPager->journalOff<szJ) {
		u32 ii;            
		u32 nJRec = 0;     
		u32 dummy;
		rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
		assert(rc != SQLITE_DONE);

		
		if (nJRec == 0
			&& pPager->journalHdr + JOURNAL_HDR_SZ(pPager) == pPager->journalOff
			) {
			nJRec = (u32)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
		}
		for (ii = 0; rc == SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++) {
			rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
		}
		assert(rc != SQLITE_DONE);
	}
	assert(rc != SQLITE_OK || pPager->journalOff >= szJ);

	
	if (pSavepoint) {
		u32 ii;            
		i64 offset = (i64)pSavepoint->iSubRec*(4 + pPager->pageSize);

		if (pagerUseWal(pPager)) {
			rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
		}
		for (ii = pSavepoint->iSubRec; rc == SQLITE_OK && ii<pPager->nSubRec; ii++) {
			assert(offset == (i64)ii*(4 + pPager->pageSize));
			rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);
		}
		assert(rc != SQLITE_DONE);
	}

	sqlite3BitvecDestroy(pDone);
	if (rc == SQLITE_OK) {
		pPager->journalOff = szJ;
	}

	return rc;
}


SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage) {
	sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}


SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage) {
	return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}


static void pagerFixMaplimit(Pager *pPager) {
#if SQLITE_MAX_MMAP_SIZE>0
	sqlite3_file *fd = pPager->fd;
	if (isOpen(fd) && fd->pMethods->iVersion >= 3) {
		sqlite3_int64 sz;
		sz = pPager->szMmap;
		pPager->bUseFetch = (sz>0);
		sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);
	}
#endif
}


SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap) {
	pPager->szMmap = szMmap;
	pagerFixMaplimit(pPager);
}


SQLITE_PRIVATE void sqlite3PagerShrink(Pager *pPager) {
	sqlite3PcacheShrink(pPager->pPCache);
}


#ifndef SQLITE_OMIT_PAGER_PRAGMAS
SQLITE_PRIVATE void sqlite3PagerSetFlags(
	Pager *pPager,        
	unsigned pgFlags      
) {
	unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;
	if (pPager->tempFile) {
		pPager->noSync = 1;
		pPager->fullSync = 0;
		pPager->extraSync = 0;
	}
	else {
		pPager->noSync = level == PAGER_SYNCHRONOUS_OFF ? 1 : 0;
		pPager->fullSync = level >= PAGER_SYNCHRONOUS_FULL ? 1 : 0;
		pPager->extraSync = level == PAGER_SYNCHRONOUS_EXTRA ? 1 : 0;
	}
	if (pPager->noSync) {
		pPager->syncFlags = 0;
		pPager->ckptSyncFlags = 0;
	}
	else if (pgFlags & PAGER_FULLFSYNC) {
		pPager->syncFlags = SQLITE_SYNC_FULL;
		pPager->ckptSyncFlags = SQLITE_SYNC_FULL;
	}
	else if (pgFlags & PAGER_CKPT_FULLFSYNC) {
		pPager->syncFlags = SQLITE_SYNC_NORMAL;
		pPager->ckptSyncFlags = SQLITE_SYNC_FULL;
	}
	else {
		pPager->syncFlags = SQLITE_SYNC_NORMAL;
		pPager->ckptSyncFlags = SQLITE_SYNC_NORMAL;
	}
	pPager->walSyncFlags = pPager->syncFlags;
	if (pPager->fullSync) {
		pPager->walSyncFlags |= WAL_SYNC_TRANSACTIONS;
	}
	if (pgFlags & PAGER_CACHESPILL) {
		pPager->doNotSpill &= ~SPILLFLAG_OFF;
	}
	else {
		pPager->doNotSpill |= SPILLFLAG_OFF;
	}
}
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_opentemp_count = 0;
#endif


static int pagerOpentemp(
	Pager *pPager,        
	sqlite3_file *pFile,  
	int vfsFlags          
) {
	int rc;               

#ifdef SQLITE_TEST
	sqlite3_opentemp_count++;  
#endif

	vfsFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |
		SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;
	rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
	assert(rc != SQLITE_OK || isOpen(pFile));
	return rc;
}


SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(
	Pager *pPager,                       
	int(*xBusyHandler)(void *),         
	void *pBusyHandlerArg                
) {
	pPager->xBusyHandler = xBusyHandler;
	pPager->pBusyHandlerArg = pBusyHandlerArg;

	if (isOpen(pPager->fd)) {
		void **ap = (void **)&pPager->xBusyHandler;
		assert(((int(*)(void *))(ap[0])) == xBusyHandler);
		assert(ap[1] == pBusyHandlerArg);
		sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);
	}
}


SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve) {
	int rc = SQLITE_OK;

	

	u32 pageSize = *pPageSize;
	assert(pageSize == 0 || (pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE));
	if ((pPager->memDb == 0 || pPager->dbSize == 0)
		&& sqlite3PcacheRefCount(pPager->pPCache) == 0
		&& pageSize && pageSize != (u32)pPager->pageSize
		) {
		char *pNew = NULL;             
		i64 nByte = 0;

		if (pPager->eState>PAGER_OPEN && isOpen(pPager->fd)) {
			rc = sqlite3OsFileSize(pPager->fd, &nByte);
		}
		if (rc == SQLITE_OK) {
			pNew = (char *)sqlite3PageMalloc(pageSize);
			if (!pNew) rc = SQLITE_NOMEM_BKPT;
		}

		if (rc == SQLITE_OK) {
			pager_reset(pPager);
			rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
		}
		if (rc == SQLITE_OK) {
			sqlite3PageFree(pPager->pTmpSpace);
			pPager->pTmpSpace = pNew;
			pPager->dbSize = (Pgno)((nByte + pageSize - 1) / pageSize);
			pPager->pageSize = pageSize;
		}
		else {
			sqlite3PageFree(pNew);
		}
	}

	*pPageSize = pPager->pageSize;
	if (rc == SQLITE_OK) {
		if (nReserve<0) nReserve = pPager->nReserve;
		assert(nReserve >= 0 && nReserve<1000);
		pPager->nReserve = (i16)nReserve;
		pagerReportSize(pPager);
		pagerFixMaplimit(pPager);
	}
	return rc;
}


SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager) {
	return pPager->pTmpSpace;
}


SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage) {
	if (mxPage>0) {
		pPager->mxPgno = mxPage;
	}
	assert(pPager->eState != PAGER_OPEN);      
	assert(pPager->mxPgno >= pPager->dbSize);  
	return pPager->mxPgno;
}


#ifdef SQLITE_TEST
SQLITE_API extern int sqlite3_io_error_pending;
SQLITE_API extern int sqlite3_io_error_hit;
static int saved_cnt;
void disable_simulated_io_errors(void) {
	saved_cnt = sqlite3_io_error_pending;
	sqlite3_io_error_pending = -1;
}
void enable_simulated_io_errors(void) {
	sqlite3_io_error_pending = saved_cnt;
}
#else
# define disable_simulated_io_errors()
# define enable_simulated_io_errors()
#endif


SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest) {
	int rc = SQLITE_OK;
	memset(pDest, 0, N);
	assert(isOpen(pPager->fd) || pPager->tempFile);

	
	assert(!pagerUseWal(pPager));

	if (isOpen(pPager->fd)) {
		IOTRACE(("DBHDR %p 0 %d\n", pPager, N))
			rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
		if (rc == SQLITE_IOERR_SHORT_READ) {
			rc = SQLITE_OK;
		}
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3PagerPagecount(Pager *pPager, int *pnPage) {
	assert(pPager->eState >= PAGER_READER);
	assert(pPager->eState != PAGER_WRITER_FINISHED);
	*pnPage = (int)pPager->dbSize;
}



static int pager_wait_on_lock(Pager *pPager, int locktype) {
	int rc;                              

										 
	assert((pPager->eLock >= locktype)
		|| (pPager->eLock == NO_LOCK && locktype == SHARED_LOCK)
		|| (pPager->eLock == RESERVED_LOCK && locktype == EXCLUSIVE_LOCK)
	);

	do {
		rc = pagerLockDb(pPager, locktype);
	} while (rc == SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg));
	return rc;
}


#if defined(SQLITE_DEBUG)
static void assertTruncateConstraintCb(PgHdr *pPg) {
	assert(pPg->flags&PGHDR_DIRTY);
	assert(!subjRequiresPage(pPg) || pPg->pgno <= pPg->pPager->dbSize);
}
static void assertTruncateConstraint(Pager *pPager) {
	sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);
}
#else
# define assertTruncateConstraint(pPager)
#endif


SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage) {
	assert(pPager->dbSize >= nPage);
	assert(pPager->eState >= PAGER_WRITER_CACHEMOD);
	pPager->dbSize = nPage;

	
}



static int pagerSyncHotJournal(Pager *pPager) {
	int rc = SQLITE_OK;
	if (!pPager->noSync) {
		rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
	}
	return rc;
}


static int pagerAcquireMapPage(
	Pager *pPager,                  
	Pgno pgno,                      
	void *pData,                    
	PgHdr **ppPage                  
) {
	PgHdr *p;                       

	if (pPager->pMmapFreelist) {
		*ppPage = p = pPager->pMmapFreelist;
		pPager->pMmapFreelist = p->pDirty;
		p->pDirty = 0;
		memset(p->pExtra, 0, pPager->nExtra);
	}
	else {
		*ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
		if (p == 0) {
			sqlite3OsUnfetch(pPager->fd, (i64)(pgno - 1) * pPager->pageSize, pData);
			return SQLITE_NOMEM_BKPT;
		}
		p->pExtra = (void *)&p[1];
		p->flags = PGHDR_MMAP;
		p->nRef = 1;
		p->pPager = pPager;
	}

	assert(p->pExtra == (void *)&p[1]);
	assert(p->pPage == 0);
	assert(p->flags == PGHDR_MMAP);
	assert(p->pPager == pPager);
	assert(p->nRef == 1);

	p->pgno = pgno;
	p->pData = pData;
	pPager->nMmapOut++;

	return SQLITE_OK;
}


static void pagerReleaseMapPage(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	pPager->nMmapOut--;
	pPg->pDirty = pPager->pMmapFreelist;
	pPager->pMmapFreelist = pPg;

	assert(pPager->fd->pMethods->iVersion >= 3);
	sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno - 1)*pPager->pageSize, pPg->pData);
}


static void pagerFreeMapHdrs(Pager *pPager) {
	PgHdr *p;
	PgHdr *pNext;
	for (p = pPager->pMmapFreelist; p; p = pNext) {
		pNext = p->pDirty;
		sqlite3_free(p);
	}
}



SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager) {
	u8 *pTmp = (u8 *)pPager->pTmpSpace;

	assert(assert_pager_state(pPager));
	disable_simulated_io_errors();
	sqlite3BeginBenignMalloc();
	pagerFreeMapHdrs(pPager);
	
	pPager->exclusiveMode = 0;
#ifndef SQLITE_OMIT_WAL
	sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags, pPager->pageSize, pTmp);
	pPager->pWal = 0;
#endif
	pager_reset(pPager);
	if (MEMDB) {
		pager_unlock(pPager);
	}
	else {
		
		if (isOpen(pPager->jfd)) {
			pager_error(pPager, pagerSyncHotJournal(pPager));
		}
		pagerUnlockAndRollback(pPager);
	}
	sqlite3EndBenignMalloc();
	enable_simulated_io_errors();
	PAGERTRACE(("CLOSE %d\n", PAGERID(pPager)));
	IOTRACE(("CLOSE %p\n", pPager))
		sqlite3OsClose(pPager->jfd);
	sqlite3OsClose(pPager->fd);
	sqlite3PageFree(pTmp);
	sqlite3PcacheClose(pPager->pPCache);

#ifdef SQLITE_HAS_CODEC
	if (pPager->xCodecFree) pPager->xCodecFree(pPager->pCodec);
#endif

	assert(!pPager->aSavepoint && !pPager->pInJournal);
	assert(!isOpen(pPager->jfd) && !isOpen(pPager->sjfd));

	sqlite3_free(pPager);
	return SQLITE_OK;
}

#if !defined(NDEBUG) || defined(SQLITE_TEST)

SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *pPg) {
	return pPg->pgno;
}
#endif


SQLITE_PRIVATE void sqlite3PagerRef(DbPage *pPg) {
	sqlite3PcacheRef(pPg);
}


static int syncJournal(Pager *pPager, int newHdr) {
	int rc;                         

	assert(pPager->eState == PAGER_WRITER_CACHEMOD
		|| pPager->eState == PAGER_WRITER_DBMOD
	);
	assert(assert_pager_state(pPager));
	assert(!pagerUseWal(pPager));

	rc = sqlite3PagerExclusiveLock(pPager);
	if (rc != SQLITE_OK) return rc;

	if (!pPager->noSync) {
		assert(!pPager->tempFile);
		if (isOpen(pPager->jfd) && pPager->journalMode != PAGER_JOURNALMODE_MEMORY) {
			const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
			assert(isOpen(pPager->jfd));

			if (0 == (iDc&SQLITE_IOCAP_SAFE_APPEND)) {
				
				i64 iNextHdrOffset;
				u8 aMagic[8];
				u8 zHeader[sizeof(aJournalMagic) + 4];

				memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
				put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);

				iNextHdrOffset = journalHdrOffset(pPager);
				rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
				if (rc == SQLITE_OK && 0 == memcmp(aMagic, aJournalMagic, 8)) {
					static const u8 zerobyte = 0;
					rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
				}
				if (rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ) {
					return rc;
				}

				
				if (pPager->fullSync && 0 == (iDc&SQLITE_IOCAP_SEQUENTIAL)) {
					PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
					IOTRACE(("JSYNC %p\n", pPager))
						rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
					if (rc != SQLITE_OK) return rc;
				}
				IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));
				rc = sqlite3OsWrite(
					pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
				);
				if (rc != SQLITE_OK) return rc;
			}
			if (0 == (iDc&SQLITE_IOCAP_SEQUENTIAL)) {
				PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
				IOTRACE(("JSYNC %p\n", pPager))
					rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags |
					(pPager->syncFlags == SQLITE_SYNC_FULL ? SQLITE_SYNC_DATAONLY : 0)
					);
				if (rc != SQLITE_OK) return rc;
			}

			pPager->journalHdr = pPager->journalOff;
			if (newHdr && 0 == (iDc&SQLITE_IOCAP_SAFE_APPEND)) {
				pPager->nRec = 0;
				rc = writeJournalHdr(pPager);
				if (rc != SQLITE_OK) return rc;
			}
		}
		else {
			pPager->journalHdr = pPager->journalOff;
		}
	}

	
	sqlite3PcacheClearSyncFlags(pPager->pPCache);
	pPager->eState = PAGER_WRITER_DBMOD;
	assert(assert_pager_state(pPager));
	return SQLITE_OK;
}


static int pager_write_pagelist(Pager *pPager, PgHdr *pList) {
	int rc = SQLITE_OK;                  

										 
	assert(!pagerUseWal(pPager));
	assert(pPager->tempFile || pPager->eState == PAGER_WRITER_DBMOD);
	assert(pPager->eLock == EXCLUSIVE_LOCK);
	assert(isOpen(pPager->fd) || pList->pDirty == 0);

	
	if (!isOpen(pPager->fd)) {
		assert(pPager->tempFile && rc == SQLITE_OK);
		rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
	}

	
	assert(rc != SQLITE_OK || isOpen(pPager->fd));
	if (rc == SQLITE_OK
		&& pPager->dbHintSize<pPager->dbSize
		&& (pList->pDirty || pList->pgno>pPager->dbHintSize)
		) {
		sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
		sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);
		pPager->dbHintSize = pPager->dbSize;
	}

	while (rc == SQLITE_OK && pList) {
		Pgno pgno = pList->pgno;

		
		if (pgno <= pPager->dbSize && 0 == (pList->flags&PGHDR_DONT_WRITE)) {
			i64 offset = (pgno - 1)*(i64)pPager->pageSize;   
			char *pData;                                   

			assert((pList->flags&PGHDR_NEED_SYNC) == 0);
			if (pList->pgno == 1) pager_write_changecounter(pList);

			
			CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM_BKPT, pData);

			
			rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);

			
			if (pgno == 1) {
				memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
			}
			if (pgno>pPager->dbFileSize) {
				pPager->dbFileSize = pgno;
			}
			pPager->aStat[PAGER_STAT_WRITE]++;

			
			sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);

			PAGERTRACE(("STORE %d page %d hash(%08x)\n",
				PAGERID(pPager), pgno, pager_pagehash(pList)));
			IOTRACE(("PGOUT %p %d\n", pPager, pgno));
			PAGER_INCR(sqlite3_pager_writedb_count);
		}
		else {
			PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));
		}
		pager_set_pagehash(pList);
		pList = pList->pDirty;
	}

	return rc;
}


static int openSubJournal(Pager *pPager) {
	int rc = SQLITE_OK;
	if (!isOpen(pPager->sjfd)) {
		const int flags = SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE
			| SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE
			| SQLITE_OPEN_DELETEONCLOSE;
		int nStmtSpill = sqlite3Config.nStmtSpill;
		if (pPager->journalMode == PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory) {
			nStmtSpill = -1;
		}
		rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);
	}
	return rc;
}


static int subjournalPage(PgHdr *pPg) {
	int rc = SQLITE_OK;
	Pager *pPager = pPg->pPager;
	if (pPager->journalMode != PAGER_JOURNALMODE_OFF) {

		
		assert(pPager->useJournal);
		assert(isOpen(pPager->jfd) || pagerUseWal(pPager));
		assert(isOpen(pPager->sjfd) || pPager->nSubRec == 0);
		assert(pagerUseWal(pPager)
			|| pageInJournal(pPager, pPg)
			|| pPg->pgno>pPager->dbOrigSize
		);
		rc = openSubJournal(pPager);

		
		if (rc == SQLITE_OK) {
			void *pData = pPg->pData;
			i64 offset = (i64)pPager->nSubRec*(4 + pPager->pageSize);
			char *pData2;

			CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);
			PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));
			rc = write32bits(pPager->sjfd, offset, pPg->pgno);
			if (rc == SQLITE_OK) {
				rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset + 4);
			}
		}
	}
	if (rc == SQLITE_OK) {
		pPager->nSubRec++;
		assert(pPager->nSavepoint>0);
		rc = addToSavepointBitvecs(pPager, pPg->pgno);
	}
	return rc;
}
static int subjournalPageIfRequired(PgHdr *pPg) {
	if (subjRequiresPage(pPg)) {
		return subjournalPage(pPg);
	}
	else {
		return SQLITE_OK;
	}
}


static int pagerStress(void *p, PgHdr *pPg) {
	Pager *pPager = (Pager *)p;
	int rc = SQLITE_OK;

	assert(pPg->pPager == pPager);
	assert(pPg->flags&PGHDR_DIRTY);

	
	if (NEVER(pPager->errCode)) return SQLITE_OK;
	testcase(pPager->doNotSpill & SPILLFLAG_ROLLBACK);
	testcase(pPager->doNotSpill & SPILLFLAG_OFF);
	testcase(pPager->doNotSpill & SPILLFLAG_NOSYNC);
	if (pPager->doNotSpill
		&& ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK | SPILLFLAG_OFF)) != 0
			|| (pPg->flags & PGHDR_NEED_SYNC) != 0)
		) {
		return SQLITE_OK;
	}

	pPg->pDirty = 0;
	if (pagerUseWal(pPager)) {
		
		rc = subjournalPageIfRequired(pPg);
		if (rc == SQLITE_OK) {
			rc = pagerWalFrames(pPager, pPg, 0, 0);
		}
	}
	else {

		
		if (pPg->flags&PGHDR_NEED_SYNC
			|| pPager->eState == PAGER_WRITER_CACHEMOD
			) {
			rc = syncJournal(pPager, 1);
		}

		
		if (rc == SQLITE_OK) {
			assert((pPg->flags&PGHDR_NEED_SYNC) == 0);
			rc = pager_write_pagelist(pPager, pPg);
		}
	}

	
	if (rc == SQLITE_OK) {
		PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));
		sqlite3PcacheMakeClean(pPg);
	}

	return pager_error(pPager, rc);
}


SQLITE_PRIVATE int sqlite3PagerFlush(Pager *pPager) {
	int rc = pPager->errCode;
	if (!MEMDB) {
		PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
		assert(assert_pager_state(pPager));
		while (rc == SQLITE_OK && pList) {
			PgHdr *pNext = pList->pDirty;
			if (pList->nRef == 0) {
				rc = pagerStress((void*)pPager, pList);
			}
			pList = pNext;
		}
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3PagerOpen(
	sqlite3_vfs *pVfs,       
	Pager **ppPager,         
	const char *zFilename,   
	int nExtra,              
	int flags,               
	int vfsFlags,            
	void(*xReinit)(DbPage*) 
) {
	u8 *pPtr;
	Pager *pPager = 0;       
	int rc = SQLITE_OK;      
	int tempFile = 0;        
	int memDb = 0;           
	int readOnly = 0;        
	int journalFileSize;     
	char *zPathname = 0;     
	int nPathname = 0;       
	int useJournal = (flags & PAGER_OMIT_JOURNAL) == 0; 
	int pcacheSize = sqlite3PcacheSize();       
	u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  
	const char *zUri = 0;    
	int nUri = 0;            

							 
	journalFileSize = ROUND8(sqlite3JournalSize(pVfs));

	
	*ppPager = 0;

#ifndef SQLITE_OMIT_MEMORYDB
	if (flags & PAGER_MEMORY) {
		memDb = 1;
		if (zFilename && zFilename[0]) {
			zPathname = sqlite3DbStrDup(0, zFilename);
			if (zPathname == 0) return SQLITE_NOMEM_BKPT;
			nPathname = sqlite3Strlen30(zPathname);
			zFilename = 0;
		}
	}
#endif

	
	if (zFilename && zFilename[0]) {
		const char *z;
		nPathname = pVfs->mxPathname + 1;
		zPathname = sqlite3DbMallocRaw(0, nPathname * 2);
		if (zPathname == 0) {
			return SQLITE_NOMEM_BKPT;
		}
		zPathname[0] = 0; 
		rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
		nPathname = sqlite3Strlen30(zPathname);
		z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];
		while (*z) {
			z += sqlite3Strlen30(z) + 1;
			z += sqlite3Strlen30(z) + 1;
		}
		nUri = (int)(&z[1] - zUri);
		assert(nUri >= 0);
		if (rc == SQLITE_OK && nPathname + 8>pVfs->mxPathname) {
			
			rc = SQLITE_CANTOPEN_BKPT;
		}
		if (rc != SQLITE_OK) {
			sqlite3DbFree(0, zPathname);
			return rc;
		}
	}

	
	pPtr = (u8 *)sqlite3MallocZero(
		ROUND8(sizeof(*pPager)) +      
		ROUND8(pcacheSize) +           
		ROUND8(pVfs->szOsFile) +       
		journalFileSize * 2 +          
		nPathname + 1 + nUri +         
		nPathname + 8 + 2              
#ifndef SQLITE_OMIT_WAL
		+ nPathname + 4 + 2            
#endif
	);
	assert(EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)));
	if (!pPtr) {
		sqlite3DbFree(0, zPathname);
		return SQLITE_NOMEM_BKPT;
	}
	pPager = (Pager*)(pPtr);
	pPager->pPCache = (PCache*)(pPtr += ROUND8(sizeof(*pPager)));
	pPager->fd = (sqlite3_file*)(pPtr += ROUND8(pcacheSize));
	pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));
	pPager->jfd = (sqlite3_file*)(pPtr += journalFileSize);
	pPager->zFilename = (char*)(pPtr += journalFileSize);
	assert(EIGHT_BYTE_ALIGNMENT(pPager->jfd));

	
	if (zPathname) {
		assert(nPathname>0);
		pPager->zJournal = (char*)(pPtr += nPathname + 1 + nUri);
		memcpy(pPager->zFilename, zPathname, nPathname);
		if (nUri) memcpy(&pPager->zFilename[nPathname + 1], zUri, nUri);
		memcpy(pPager->zJournal, zPathname, nPathname);
		memcpy(&pPager->zJournal[nPathname], "-journal\000", 8 + 2);
		sqlite3FileSuffix3(pPager->zFilename, pPager->zJournal);
#ifndef SQLITE_OMIT_WAL
		pPager->zWal = &pPager->zJournal[nPathname + 8 + 1];
		memcpy(pPager->zWal, zPathname, nPathname);
		memcpy(&pPager->zWal[nPathname], "-wal\000", 4 + 1);
		sqlite3FileSuffix3(pPager->zFilename, pPager->zWal);
#endif
		sqlite3DbFree(0, zPathname);
	}
	pPager->pVfs = pVfs;
	pPager->vfsFlags = vfsFlags;

	
	if (zFilename && zFilename[0]) {
		int fout = 0;                    
		rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
		assert(!memDb);
		readOnly = (fout&SQLITE_OPEN_READONLY);

		
		if (rc == SQLITE_OK) {
			int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
			if (!readOnly) {
				setSectorSize(pPager);
				assert(SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE);
				if (szPageDflt<pPager->sectorSize) {
					if (pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE) {
						szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;
					}
					else {
						szPageDflt = (u32)pPager->sectorSize;
					}
				}
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
				{
					int ii;
					assert(SQLITE_IOCAP_ATOMIC512 == (512 >> 8));
					assert(SQLITE_IOCAP_ATOMIC64K == (65536 >> 8));
					assert(SQLITE_MAX_DEFAULT_PAGE_SIZE <= 65536);
					for (ii = szPageDflt; ii <= SQLITE_MAX_DEFAULT_PAGE_SIZE; ii = ii * 2) {
						if (iDc&(SQLITE_IOCAP_ATOMIC | (ii >> 8))) {
							szPageDflt = ii;
						}
					}
				}
#endif
			}
			pPager->noLock = sqlite3_uri_boolean(zFilename, "nolock", 0);
			if ((iDc & SQLITE_IOCAP_IMMUTABLE) != 0
				|| sqlite3_uri_boolean(zFilename, "immutable", 0)) {
				vfsFlags |= SQLITE_OPEN_READONLY;
				goto act_like_temp_file;
			}
		}
	}
	else {
		
	act_like_temp_file:
		tempFile = 1;
		pPager->eState = PAGER_READER;     
		pPager->eLock = EXCLUSIVE_LOCK;    
		pPager->noLock = 1;                
		readOnly = (vfsFlags&SQLITE_OPEN_READONLY);
	}

	
	if (rc == SQLITE_OK) {
		assert(pPager->memDb == 0);
		rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
		testcase(rc != SQLITE_OK);
	}

	
	if (rc == SQLITE_OK) {
		assert(nExtra<1000);
		nExtra = ROUND8(nExtra);
		rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
			!memDb ? pagerStress : 0, (void *)pPager, pPager->pPCache);
	}

	
	if (rc != SQLITE_OK) {
		sqlite3OsClose(pPager->fd);
		sqlite3PageFree(pPager->pTmpSpace);
		sqlite3_free(pPager);
		return rc;
	}

	PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));
	IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))

		pPager->useJournal = (u8)useJournal;
	
	
	
	
	
	
	pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;
	
	
	pPager->tempFile = (u8)tempFile;
	assert(tempFile == PAGER_LOCKINGMODE_NORMAL
		|| tempFile == PAGER_LOCKINGMODE_EXCLUSIVE);
	assert(PAGER_LOCKINGMODE_EXCLUSIVE == 1);
	pPager->exclusiveMode = (u8)tempFile;
	pPager->changeCountDone = pPager->tempFile;
	pPager->memDb = (u8)memDb;
	pPager->readOnly = (u8)readOnly;
	assert(useJournal || pPager->tempFile);
	pPager->noSync = pPager->tempFile;
	if (pPager->noSync) {
		assert(pPager->fullSync == 0);
		assert(pPager->extraSync == 0);
		assert(pPager->syncFlags == 0);
		assert(pPager->walSyncFlags == 0);
		assert(pPager->ckptSyncFlags == 0);
	}
	else {
		pPager->fullSync = 1;
		pPager->extraSync = 0;
		pPager->syncFlags = SQLITE_SYNC_NORMAL;
		pPager->walSyncFlags = SQLITE_SYNC_NORMAL | WAL_SYNC_TRANSACTIONS;
		pPager->ckptSyncFlags = SQLITE_SYNC_NORMAL;
	}
	
	
	
	pPager->nExtra = (u16)nExtra;
	pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;
	assert(isOpen(pPager->fd) || tempFile);
	setSectorSize(pPager);
	if (!useJournal) {
		pPager->journalMode = PAGER_JOURNALMODE_OFF;
	}
	else if (memDb) {
		pPager->journalMode = PAGER_JOURNALMODE_MEMORY;
	}
	
	
	pPager->xReiniter = xReinit;
	
	

	*ppPager = pPager;
	return SQLITE_OK;
}



static int databaseIsUnmoved(Pager *pPager) {
	int bHasMoved = 0;
	int rc;

	if (pPager->tempFile) return SQLITE_OK;
	if (pPager->dbSize == 0) return SQLITE_OK;
	assert(pPager->zFilename && pPager->zFilename[0]);
	rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);
	if (rc == SQLITE_NOTFOUND) {
		
		rc = SQLITE_OK;
	}
	else if (rc == SQLITE_OK && bHasMoved) {
		rc = SQLITE_READONLY_DBMOVED;
	}
	return rc;
}



static int hasHotJournal(Pager *pPager, int *pExists) {
	sqlite3_vfs * const pVfs = pPager->pVfs;
	int rc = SQLITE_OK;           
	int exists = 1;               
	int jrnlOpen = !!isOpen(pPager->jfd);

	assert(pPager->useJournal);
	assert(isOpen(pPager->fd));
	assert(pPager->eState == PAGER_OPEN);

	assert(jrnlOpen == 0 || (sqlite3OsDeviceCharacteristics(pPager->jfd) &
		SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
		));

	*pExists = 0;
	if (!jrnlOpen) {
		rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);
	}
	if (rc == SQLITE_OK && exists) {
		int locked = 0;             

									
		rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
		if (rc == SQLITE_OK && !locked) {
			Pgno nPage;                 

			assert(pPager->tempFile == 0);
			rc = pagerPagecount(pPager, &nPage);
			if (rc == SQLITE_OK) {
				
				if (nPage == 0 && !jrnlOpen) {
					sqlite3BeginBenignMalloc();
					if (pagerLockDb(pPager, RESERVED_LOCK) == SQLITE_OK) {
						sqlite3OsDelete(pVfs, pPager->zJournal, 0);
						if (!pPager->exclusiveMode) pagerUnlockDb(pPager, SHARED_LOCK);
					}
					sqlite3EndBenignMalloc();
				}
				else {
					
					if (!jrnlOpen) {
						int f = SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL;
						rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
					}
					if (rc == SQLITE_OK) {
						u8 first = 0;
						rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
						if (rc == SQLITE_IOERR_SHORT_READ) {
							rc = SQLITE_OK;
						}
						if (!jrnlOpen) {
							sqlite3OsClose(pPager->jfd);
						}
						*pExists = (first != 0);
					}
					else if (rc == SQLITE_CANTOPEN) {
						
						*pExists = 1;
						rc = SQLITE_OK;
					}
				}
			}
		}
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager) {
	int rc = SQLITE_OK;                

									   
	assert(sqlite3PcacheRefCount(pPager->pPCache) == 0);
	assert(assert_pager_state(pPager));
	assert(pPager->eState == PAGER_OPEN || pPager->eState == PAGER_READER);
	assert(pPager->errCode == SQLITE_OK);

	if (!pagerUseWal(pPager) && pPager->eState == PAGER_OPEN) {
		int bHotJournal = 1;          

		assert(!MEMDB);
		assert(pPager->tempFile == 0 || pPager->eLock == EXCLUSIVE_LOCK);

		rc = pager_wait_on_lock(pPager, SHARED_LOCK);
		if (rc != SQLITE_OK) {
			assert(pPager->eLock == NO_LOCK || pPager->eLock == UNKNOWN_LOCK);
			goto failed;
		}

		
		if (pPager->eLock <= SHARED_LOCK) {
			rc = hasHotJournal(pPager, &bHotJournal);
		}
		if (rc != SQLITE_OK) {
			goto failed;
		}
		if (bHotJournal) {
			if (pPager->readOnly) {
				rc = SQLITE_READONLY_ROLLBACK;
				goto failed;
			}

			
			rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
			if (rc != SQLITE_OK) {
				goto failed;
			}

			
			if (!isOpen(pPager->jfd)) {
				sqlite3_vfs * const pVfs = pPager->pVfs;
				int bExists;              
				rc = sqlite3OsAccess(
					pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);
				if (rc == SQLITE_OK && bExists) {
					int fout = 0;
					int f = SQLITE_OPEN_READWRITE | SQLITE_OPEN_MAIN_JOURNAL;
					assert(!pPager->tempFile);
					rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
					assert(rc != SQLITE_OK || isOpen(pPager->jfd));
					if (rc == SQLITE_OK && fout&SQLITE_OPEN_READONLY) {
						rc = SQLITE_CANTOPEN_BKPT;
						sqlite3OsClose(pPager->jfd);
					}
				}
			}

			
			if (isOpen(pPager->jfd)) {
				assert(rc == SQLITE_OK);
				rc = pagerSyncHotJournal(pPager);
				if (rc == SQLITE_OK) {
					rc = pager_playback(pPager, !pPager->tempFile);
					pPager->eState = PAGER_OPEN;
				}
			}
			else if (!pPager->exclusiveMode) {
				pagerUnlockDb(pPager, SHARED_LOCK);
			}

			if (rc != SQLITE_OK) {
				
				pager_error(pPager, rc);
				goto failed;
			}

			assert(pPager->eState == PAGER_OPEN);
			assert((pPager->eLock == SHARED_LOCK)
				|| (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)
			);
		}

		if (!pPager->tempFile && pPager->hasHeldSharedLock) {
			
			Pgno nPage = 0;
			char dbFileVers[sizeof(pPager->dbFileVers)];

			rc = pagerPagecount(pPager, &nPage);
			if (rc) goto failed;

			if (nPage>0) {
				IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));
				rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
				if (rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ) {
					goto failed;
				}
			}
			else {
				memset(dbFileVers, 0, sizeof(dbFileVers));
			}

			if (memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers)) != 0) {
				pager_reset(pPager);

				
				if (USEFETCH(pPager)) {
					sqlite3OsUnfetch(pPager->fd, 0, 0);
				}
			}
		}

		
		rc = pagerOpenWalIfPresent(pPager);
#ifndef SQLITE_OMIT_WAL
		assert(pPager->pWal == 0 || rc == SQLITE_OK);
#endif
	}

	if (pagerUseWal(pPager)) {
		assert(rc == SQLITE_OK);
		rc = pagerBeginReadTransaction(pPager);
	}

	if (pPager->tempFile == 0 && pPager->eState == PAGER_OPEN && rc == SQLITE_OK) {
		rc = pagerPagecount(pPager, &pPager->dbSize);
	}

failed:
	if (rc != SQLITE_OK) {
		assert(!MEMDB);
		pager_unlock(pPager);
		assert(pPager->eState == PAGER_OPEN);
	}
	else {
		pPager->eState = PAGER_READER;
		pPager->hasHeldSharedLock = 1;
	}
	return rc;
}


static void pagerUnlockIfUnused(Pager *pPager) {
	if (pPager->nMmapOut == 0 && (sqlite3PcacheRefCount(pPager->pPCache) == 0)) {
		pagerUnlockAndRollback(pPager);
	}
}


SQLITE_PRIVATE int sqlite3PagerGet(
	Pager *pPager,      
	Pgno pgno,          
	DbPage **ppPage,    
	int flags           
) {
	int rc = SQLITE_OK;
	PgHdr *pPg = 0;
	u32 iFrame = 0;                 
	const int noContent = (flags & PAGER_GET_NOCONTENT);

	
	const int bMmapOk = (pgno>1 && USEFETCH(pPager)
		&& (pPager->eState == PAGER_READER || (flags & PAGER_GET_READONLY))
#ifdef SQLITE_HAS_CODEC
		&& pPager->xCodec == 0
#endif
		);

	
	if (pgno <= 1 && pgno == 0) {
		return SQLITE_CORRUPT_BKPT;
	}
	assert(pPager->eState >= PAGER_READER);
	assert(assert_pager_state(pPager));
	assert(noContent == 0 || bMmapOk == 0);

	assert(pPager->hasHeldSharedLock == 1);

	
	if (pPager->errCode != SQLITE_OK) {
		rc = pPager->errCode;
	}
	else {
		if (bMmapOk && pagerUseWal(pPager)) {
			rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
			if (rc != SQLITE_OK) goto pager_acquire_err;
		}

		if (bMmapOk && iFrame == 0) {
			void *pData = 0;

			rc = sqlite3OsFetch(pPager->fd,
				(i64)(pgno - 1) * pPager->pageSize, pPager->pageSize, &pData
			);

			if (rc == SQLITE_OK && pData) {
				if (pPager->eState>PAGER_READER || pPager->tempFile) {
					pPg = sqlite3PagerLookup(pPager, pgno);
				}
				if (pPg == 0) {
					rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);
				}
				else {
					sqlite3OsUnfetch(pPager->fd, (i64)(pgno - 1)*pPager->pageSize, pData);
				}
				if (pPg) {
					assert(rc == SQLITE_OK);
					*ppPage = pPg;
					return SQLITE_OK;
				}
			}
			if (rc != SQLITE_OK) {
				goto pager_acquire_err;
			}
		}

		{
			sqlite3_pcache_page *pBase;
			pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
			if (pBase == 0) {
				rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);
				if (rc != SQLITE_OK) goto pager_acquire_err;
				if (pBase == 0) {
					pPg = *ppPage = 0;
					rc = SQLITE_NOMEM_BKPT;
					goto pager_acquire_err;
				}
			}
			pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
			assert(pPg != 0);
		}
	}

	if (rc != SQLITE_OK) {
		
		pPg = 0;
		goto pager_acquire_err;
	}
	assert(pPg == (*ppPage));
	assert(pPg->pgno == pgno);
	assert(pPg->pPager == pPager || pPg->pPager == 0);

	if (pPg->pPager && !noContent) {
		
		assert(pgno <= PAGER_MAX_PGNO && pgno != PAGER_MJ_PGNO(pPager));
		pPager->aStat[PAGER_STAT_HIT]++;
		return SQLITE_OK;

	}
	else {
		

		pPg->pPager = pPager;

		
		if (pgno>PAGER_MAX_PGNO || pgno == PAGER_MJ_PGNO(pPager)) {
			rc = SQLITE_CORRUPT_BKPT;
			goto pager_acquire_err;
		}

		assert(!isOpen(pPager->fd) || !MEMDB);
		if (!isOpen(pPager->fd) || pPager->dbSize<pgno || noContent) {
			if (pgno>pPager->mxPgno) {
				rc = SQLITE_FULL;
				goto pager_acquire_err;
			}
			if (noContent) {
				
				sqlite3BeginBenignMalloc();
				if (pgno <= pPager->dbOrigSize) {
					TESTONLY(rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);
					testcase(rc == SQLITE_NOMEM);
				}
				TESTONLY(rc = ) addToSavepointBitvecs(pPager, pgno);
				testcase(rc == SQLITE_NOMEM);
				sqlite3EndBenignMalloc();
			}
			memset(pPg->pData, 0, pPager->pageSize);
			IOTRACE(("ZERO %p %d\n", pPager, pgno));
		}
		else {
			if (pagerUseWal(pPager) && bMmapOk == 0) {
				rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
				if (rc != SQLITE_OK) goto pager_acquire_err;
			}
			assert(pPg->pPager == pPager);
			pPager->aStat[PAGER_STAT_MISS]++;
			rc = readDbPage(pPg, iFrame);
			if (rc != SQLITE_OK) {
				goto pager_acquire_err;
			}
		}
		pager_set_pagehash(pPg);
	}

	return SQLITE_OK;

pager_acquire_err:
	assert(rc != SQLITE_OK);
	if (pPg) {
		sqlite3PcacheDrop(pPg);
	}
	pagerUnlockIfUnused(pPager);

	*ppPage = 0;
	return rc;
}


SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno) {
	sqlite3_pcache_page *pPage;
	assert(pPager != 0);
	assert(pgno != 0);
	assert(pPager->pPCache != 0);
	pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
	assert(pPage == 0 || pPager->hasHeldSharedLock);
	if (pPage == 0) return 0;
	return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
}


SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage *pPg) {
	Pager *pPager;
	assert(pPg != 0);
	pPager = pPg->pPager;
	if (pPg->flags & PGHDR_MMAP) {
		pagerReleaseMapPage(pPg);
	}
	else {
		sqlite3PcacheRelease(pPg);
	}
	pagerUnlockIfUnused(pPager);
}
SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg) {
	if (pPg) sqlite3PagerUnrefNotNull(pPg);
}


static int pager_open_journal(Pager *pPager) {
	int rc = SQLITE_OK;                        
	sqlite3_vfs * const pVfs = pPager->pVfs;   

	assert(pPager->eState == PAGER_WRITER_LOCKED);
	assert(assert_pager_state(pPager));
	assert(pPager->pInJournal == 0);

	
	if (NEVER(pPager->errCode)) return pPager->errCode;

	if (!pagerUseWal(pPager) && pPager->journalMode != PAGER_JOURNALMODE_OFF) {
		pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
		if (pPager->pInJournal == 0) {
			return SQLITE_NOMEM_BKPT;
		}

		
		if (!isOpen(pPager->jfd)) {
			if (pPager->journalMode == PAGER_JOURNALMODE_MEMORY) {
				sqlite3MemJournalOpen(pPager->jfd);
			}
			else {
				int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
				int nSpill;

				if (pPager->tempFile) {
					flags |= (SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TEMP_JOURNAL);
					nSpill = sqlite3Config.nStmtSpill;
				}
				else {
					flags |= SQLITE_OPEN_MAIN_JOURNAL;
					nSpill = jrnlBufferSize(pPager);
				}

				
				rc = databaseIsUnmoved(pPager);
				if (rc == SQLITE_OK) {
					rc = sqlite3JournalOpen(
						pVfs, pPager->zJournal, pPager->jfd, flags, nSpill
					);
				}
			}
			assert(rc != SQLITE_OK || isOpen(pPager->jfd));
		}


		
		if (rc == SQLITE_OK) {
			
			pPager->nRec = 0;
			pPager->journalOff = 0;
			pPager->setMaster = 0;
			pPager->journalHdr = 0;
			rc = writeJournalHdr(pPager);
		}
	}

	if (rc != SQLITE_OK) {
		sqlite3BitvecDestroy(pPager->pInJournal);
		pPager->pInJournal = 0;
	}
	else {
		assert(pPager->eState == PAGER_WRITER_LOCKED);
		pPager->eState = PAGER_WRITER_CACHEMOD;
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory) {
	int rc = SQLITE_OK;

	if (pPager->errCode) return pPager->errCode;
	assert(pPager->eState >= PAGER_READER && pPager->eState<PAGER_ERROR);
	pPager->subjInMemory = (u8)subjInMemory;

	if (ALWAYS(pPager->eState == PAGER_READER)) {
		assert(pPager->pInJournal == 0);

		if (pagerUseWal(pPager)) {
			
			if (pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1)) {
				rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
				if (rc != SQLITE_OK) {
					return rc;
				}
				(void)sqlite3WalExclusiveMode(pPager->pWal, 1);
			}

			
			rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
		}
		else {
			
			rc = pagerLockDb(pPager, RESERVED_LOCK);
			if (rc == SQLITE_OK && exFlag) {
				rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
			}
		}

		if (rc == SQLITE_OK) {
			
			pPager->eState = PAGER_WRITER_LOCKED;
			pPager->dbHintSize = pPager->dbSize;
			pPager->dbFileSize = pPager->dbSize;
			pPager->dbOrigSize = pPager->dbSize;
			pPager->journalOff = 0;
		}

		assert(rc == SQLITE_OK || pPager->eState == PAGER_READER);
		assert(rc != SQLITE_OK || pPager->eState == PAGER_WRITER_LOCKED);
		assert(assert_pager_state(pPager));
	}

	PAGERTRACE(("TRANSACTION %d\n", PAGERID(pPager)));
	return rc;
}


static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	int rc;
	u32 cksum;
	char *pData2;
	i64 iOff = pPager->journalOff;

	
	assert(pPg->pgno != PAGER_MJ_PGNO(pPager));

	assert(pPager->journalHdr <= pPager->journalOff);
	CODEC2(pPager, pPg->pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);
	cksum = pager_cksum(pPager, (u8*)pData2);

	
	pPg->flags |= PGHDR_NEED_SYNC;

	rc = write32bits(pPager->jfd, iOff, pPg->pgno);
	if (rc != SQLITE_OK) return rc;
	rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff + 4);
	if (rc != SQLITE_OK) return rc;
	rc = write32bits(pPager->jfd, iOff + pPager->pageSize + 4, cksum);
	if (rc != SQLITE_OK) return rc;

	IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,
		pPager->journalOff, pPager->pageSize));
	PAGER_INCR(sqlite3_pager_writej_count);
	PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",
		PAGERID(pPager), pPg->pgno,
		((pPg->flags&PGHDR_NEED_SYNC) ? 1 : 0), pager_pagehash(pPg)));

	pPager->journalOff += 8 + pPager->pageSize;
	pPager->nRec++;
	assert(pPager->pInJournal != 0);
	rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
	testcase(rc == SQLITE_NOMEM);
	assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
	rc |= addToSavepointBitvecs(pPager, pPg->pgno);
	assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
	return rc;
}


static int pager_write(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	int rc = SQLITE_OK;

	
	assert(pPager->eState == PAGER_WRITER_LOCKED
		|| pPager->eState == PAGER_WRITER_CACHEMOD
		|| pPager->eState == PAGER_WRITER_DBMOD
	);
	assert(assert_pager_state(pPager));
	assert(pPager->errCode == 0);
	assert(pPager->readOnly == 0);
	CHECK_PAGE(pPg);

	
	if (pPager->eState == PAGER_WRITER_LOCKED) {
		rc = pager_open_journal(pPager);
		if (rc != SQLITE_OK) return rc;
	}
	assert(pPager->eState >= PAGER_WRITER_CACHEMOD);
	assert(assert_pager_state(pPager));

	
	sqlite3PcacheMakeDirty(pPg);

	
	assert((pPager->pInJournal != 0) == isOpen(pPager->jfd));
	if (pPager->pInJournal != 0
		&& sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno) == 0
		) {
		assert(pagerUseWal(pPager) == 0);
		if (pPg->pgno <= pPager->dbOrigSize) {
			rc = pagerAddPageToRollbackJournal(pPg);
			if (rc != SQLITE_OK) {
				return rc;
			}
		}
		else {
			if (pPager->eState != PAGER_WRITER_DBMOD) {
				pPg->flags |= PGHDR_NEED_SYNC;
			}
			PAGERTRACE(("APPEND %d page %d needSync=%d\n",
				PAGERID(pPager), pPg->pgno,
				((pPg->flags&PGHDR_NEED_SYNC) ? 1 : 0)));
		}
	}

	
	pPg->flags |= PGHDR_WRITEABLE;

	
	if (pPager->nSavepoint>0) {
		rc = subjournalPageIfRequired(pPg);
	}

	
	if (pPager->dbSize<pPg->pgno) {
		pPager->dbSize = pPg->pgno;
	}
	return rc;
}


static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg) {
	int rc = SQLITE_OK;          
	Pgno nPageCount;             
	Pgno pg1;                    
	int nPage = 0;               
	int ii;                      
	int needSync = 0;            
	Pager *pPager = pPg->pPager; 
	Pgno nPagePerSector = (pPager->sectorSize / pPager->pageSize);

	
	assert(!MEMDB);
	assert((pPager->doNotSpill & SPILLFLAG_NOSYNC) == 0);
	pPager->doNotSpill |= SPILLFLAG_NOSYNC;

	
	pg1 = ((pPg->pgno - 1) & ~(nPagePerSector - 1)) + 1;

	nPageCount = pPager->dbSize;
	if (pPg->pgno>nPageCount) {
		nPage = (pPg->pgno - pg1) + 1;
	}
	else if ((pg1 + nPagePerSector - 1)>nPageCount) {
		nPage = nPageCount + 1 - pg1;
	}
	else {
		nPage = nPagePerSector;
	}
	assert(nPage>0);
	assert(pg1 <= pPg->pgno);
	assert((pg1 + nPage)>pPg->pgno);

	for (ii = 0; ii<nPage && rc == SQLITE_OK; ii++) {
		Pgno pg = pg1 + ii;
		PgHdr *pPage;
		if (pg == pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg)) {
			if (pg != PAGER_MJ_PGNO(pPager)) {
				rc = sqlite3PagerGet(pPager, pg, &pPage, 0);
				if (rc == SQLITE_OK) {
					rc = pager_write(pPage);
					if (pPage->flags&PGHDR_NEED_SYNC) {
						needSync = 1;
					}
					sqlite3PagerUnrefNotNull(pPage);
				}
			}
		}
		else if ((pPage = sqlite3PagerLookup(pPager, pg)) != 0) {
			if (pPage->flags&PGHDR_NEED_SYNC) {
				needSync = 1;
			}
			sqlite3PagerUnrefNotNull(pPage);
		}
	}

	
	if (rc == SQLITE_OK && needSync) {
		assert(!MEMDB);
		for (ii = 0; ii<nPage; ii++) {
			PgHdr *pPage = sqlite3PagerLookup(pPager, pg1 + ii);
			if (pPage) {
				pPage->flags |= PGHDR_NEED_SYNC;
				sqlite3PagerUnrefNotNull(pPage);
			}
		}
	}

	assert((pPager->doNotSpill & SPILLFLAG_NOSYNC) != 0);
	pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;
	return rc;
}


SQLITE_PRIVATE int sqlite3PagerWrite(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	assert((pPg->flags & PGHDR_MMAP) == 0);
	assert(pPager->eState >= PAGER_WRITER_LOCKED);
	assert(assert_pager_state(pPager));
	if (pPager->errCode) {
		return pPager->errCode;
	}
	else if ((pPg->flags & PGHDR_WRITEABLE) != 0 && pPager->dbSize >= pPg->pgno) {
		if (pPager->nSavepoint) return subjournalPageIfRequired(pPg);
		return SQLITE_OK;
	}
	else if (pPager->sectorSize > (u32)pPager->pageSize) {
		assert(pPager->tempFile == 0);
		return pagerWriteLargeSector(pPg);
	}
	else {
		return pager_write(pPg);
	}
}


#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg) {
	return pPg->flags & PGHDR_WRITEABLE;
}
#endif


SQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg) {
	Pager *pPager = pPg->pPager;
	if (!pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint == 0) {
		PAGERTRACE(("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)));
		IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))
			pPg->flags |= PGHDR_DONT_WRITE;
		pPg->flags &= ~PGHDR_WRITEABLE;
		testcase(pPg->flags & PGHDR_NEED_SYNC);
		pager_set_pagehash(pPg);
	}
}


static int pager_incr_changecounter(Pager *pPager, int isDirectMode) {
	int rc = SQLITE_OK;

	assert(pPager->eState == PAGER_WRITER_CACHEMOD
		|| pPager->eState == PAGER_WRITER_DBMOD
	);
	assert(assert_pager_state(pPager));

	
#ifndef SQLITE_ENABLE_ATOMIC_WRITE
# define DIRECT_MODE 0
	assert(isDirectMode == 0);
	UNUSED_PARAMETER(isDirectMode);
#else
# define DIRECT_MODE isDirectMode
#endif

	if (!pPager->changeCountDone && ALWAYS(pPager->dbSize>0)) {
		PgHdr *pPgHdr;                

		assert(!pPager->tempFile && isOpen(pPager->fd));

		
		rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);
		assert(pPgHdr == 0 || rc == SQLITE_OK);

		
		if (!DIRECT_MODE && ALWAYS(rc == SQLITE_OK)) {
			rc = sqlite3PagerWrite(pPgHdr);
		}

		if (rc == SQLITE_OK) {
			
			pager_write_changecounter(pPgHdr);

			
			if (DIRECT_MODE) {
				const void *zBuf;
				assert(pPager->dbFileSize>0);
				CODEC2(pPager, pPgHdr->pData, 1, 6, rc = SQLITE_NOMEM_BKPT, zBuf);
				if (rc == SQLITE_OK) {
					rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
					pPager->aStat[PAGER_STAT_WRITE]++;
				}
				if (rc == SQLITE_OK) {
					
					const void *pCopy = (const void *)&((const char *)zBuf)[24];
					memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
					pPager->changeCountDone = 1;
				}
			}
			else {
				pPager->changeCountDone = 1;
			}
		}

		
		sqlite3PagerUnref(pPgHdr);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster) {
	int rc = SQLITE_OK;

	if (isOpen(pPager->fd)) {
		void *pArg = (void*)zMaster;
		rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);
		if (rc == SQLITE_NOTFOUND) rc = SQLITE_OK;
	}
	if (rc == SQLITE_OK && !pPager->noSync) {
		assert(!MEMDB);
		rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager *pPager) {
	int rc = pPager->errCode;
	assert(assert_pager_state(pPager));
	if (rc == SQLITE_OK) {
		assert(pPager->eState == PAGER_WRITER_CACHEMOD
			|| pPager->eState == PAGER_WRITER_DBMOD
			|| pPager->eState == PAGER_WRITER_LOCKED
		);
		assert(assert_pager_state(pPager));
		if (0 == pagerUseWal(pPager)) {
			rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(
	Pager *pPager,                  
	const char *zMaster,            
	int noSync                      
) {
	int rc = SQLITE_OK;             

	assert(pPager->eState == PAGER_WRITER_LOCKED
		|| pPager->eState == PAGER_WRITER_CACHEMOD
		|| pPager->eState == PAGER_WRITER_DBMOD
		|| pPager->eState == PAGER_ERROR
	);
	assert(assert_pager_state(pPager));

	
	if (NEVER(pPager->errCode)) return pPager->errCode;

	
	if (sqlite3FaultSim(400)) return SQLITE_IOERR;

	PAGERTRACE(("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n",
		pPager->zFilename, zMaster, pPager->dbSize));

	
	if (pPager->eState<PAGER_WRITER_CACHEMOD) return SQLITE_OK;

	assert(MEMDB == 0 || pPager->tempFile);
	assert(isOpen(pPager->fd) || pPager->tempFile);
	if (0 == pagerFlushOnCommit(pPager, 1)) {
		
		sqlite3BackupRestart(pPager->pBackup);
	}
	else {
		if (pagerUseWal(pPager)) {
			PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
			PgHdr *pPageOne = 0;
			if (pList == 0) {
				
				rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);
				pList = pPageOne;
				pList->pDirty = 0;
			}
			assert(rc == SQLITE_OK);
			if (ALWAYS(pList)) {
				rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
			}
			sqlite3PagerUnref(pPageOne);
			if (rc == SQLITE_OK) {
				sqlite3PcacheCleanAll(pPager->pPCache);
			}
		}
		else {
			
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
			PgHdr *pPg;
			assert(isOpen(pPager->jfd)
				|| pPager->journalMode == PAGER_JOURNALMODE_OFF
				|| pPager->journalMode == PAGER_JOURNALMODE_WAL
			);
			if (!zMaster && isOpen(pPager->jfd)
				&& pPager->journalOff == jrnlBufferSize(pPager)
				&& pPager->dbSize >= pPager->dbOrigSize
				&& (0 == (pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0 == pPg->pDirty)
				) {
				
				rc = pager_incr_changecounter(pPager, 1);
			}
			else {
				rc = sqlite3JournalCreate(pPager->jfd);
				if (rc == SQLITE_OK) {
					rc = pager_incr_changecounter(pPager, 0);
				}
			}
#else
			rc = pager_incr_changecounter(pPager, 0);
#endif
			if (rc != SQLITE_OK) goto commit_phase_one_exit;

			
			rc = writeMasterJournal(pPager, zMaster);
			if (rc != SQLITE_OK) goto commit_phase_one_exit;

			
			rc = syncJournal(pPager, 0);
			if (rc != SQLITE_OK) goto commit_phase_one_exit;

			rc = pager_write_pagelist(pPager, sqlite3PcacheDirtyList(pPager->pPCache));
			if (rc != SQLITE_OK) {
				assert(rc != SQLITE_IOERR_BLOCKED);
				goto commit_phase_one_exit;
			}
			sqlite3PcacheCleanAll(pPager->pPCache);

			
			if (pPager->dbSize>pPager->dbFileSize) {
				Pgno nNew = pPager->dbSize - (pPager->dbSize == PAGER_MJ_PGNO(pPager));
				assert(pPager->eState == PAGER_WRITER_DBMOD);
				rc = pager_truncate(pPager, nNew);
				if (rc != SQLITE_OK) goto commit_phase_one_exit;
			}

			
			if (!noSync) {
				rc = sqlite3PagerSync(pPager, zMaster);
			}
			IOTRACE(("DBSYNC %p\n", pPager))
		}
	}

commit_phase_one_exit:
	if (rc == SQLITE_OK && !pagerUseWal(pPager)) {
		pPager->eState = PAGER_WRITER_FINISHED;
	}
	return rc;
}



SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager) {
	int rc = SQLITE_OK;                  

										 
	if (NEVER(pPager->errCode)) return pPager->errCode;

	assert(pPager->eState == PAGER_WRITER_LOCKED
		|| pPager->eState == PAGER_WRITER_FINISHED
		|| (pagerUseWal(pPager) && pPager->eState == PAGER_WRITER_CACHEMOD)
	);
	assert(assert_pager_state(pPager));

	
	if (pPager->eState == PAGER_WRITER_LOCKED
		&& pPager->exclusiveMode
		&& pPager->journalMode == PAGER_JOURNALMODE_PERSIST
		) {
		assert(pPager->journalOff == JOURNAL_HDR_SZ(pPager) || !pPager->journalOff);
		pPager->eState = PAGER_READER;
		return SQLITE_OK;
	}

	PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));
	pPager->iDataVersion++;
	rc = pager_end_transaction(pPager, pPager->setMaster, 1);
	return pager_error(pPager, rc);
}


SQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager) {
	int rc = SQLITE_OK;                  
	PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager)));

	
	assert(assert_pager_state(pPager));
	if (pPager->eState == PAGER_ERROR) return pPager->errCode;
	if (pPager->eState <= PAGER_READER) return SQLITE_OK;

	if (pagerUseWal(pPager)) {
		int rc2;
		rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);
		rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);
		if (rc == SQLITE_OK) rc = rc2;
	}
	else if (!isOpen(pPager->jfd) || pPager->eState == PAGER_WRITER_LOCKED) {
		int eState = pPager->eState;
		rc = pager_end_transaction(pPager, 0, 0);
		if (!MEMDB && eState>PAGER_WRITER_LOCKED) {
			
			pPager->errCode = SQLITE_ABORT;
			pPager->eState = PAGER_ERROR;
			return rc;
		}
	}
	else {
		rc = pager_playback(pPager, 0);
	}

	assert(pPager->eState == PAGER_READER || rc != SQLITE_OK);
	assert(rc == SQLITE_OK || rc == SQLITE_FULL || rc == SQLITE_CORRUPT
		|| rc == SQLITE_NOMEM || (rc & 0xFF) == SQLITE_IOERR
		|| rc == SQLITE_CANTOPEN
	);

	
	return pager_error(pPager, rc);
}


SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager) {
	return pPager->readOnly;
}

#ifdef SQLITE_DEBUG

SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager) {
	return sqlite3PcacheRefCount(pPager->pPCache);
}
#endif


SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager *pPager) {
	int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)
		+ 5 * sizeof(void*);
	return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
		+ sqlite3MallocSize(pPager)
		+ pPager->pageSize;
}


SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage) {
	return sqlite3PcachePageRefcount(pPage);
}

#ifdef SQLITE_TEST

SQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager) {
	static int a[11];
	a[0] = sqlite3PcacheRefCount(pPager->pPCache);
	a[1] = sqlite3PcachePagecount(pPager->pPCache);
	a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);
	a[3] = pPager->eState == PAGER_OPEN ? -1 : (int)pPager->dbSize;
	a[4] = pPager->eState;
	a[5] = pPager->errCode;
	a[6] = pPager->aStat[PAGER_STAT_HIT];
	a[7] = pPager->aStat[PAGER_STAT_MISS];
	a[8] = 0;  
	a[9] = pPager->nRead;
	a[10] = pPager->aStat[PAGER_STAT_WRITE];
	return a;
}
#endif


SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal) {

	assert(eStat == SQLITE_DBSTATUS_CACHE_HIT
		|| eStat == SQLITE_DBSTATUS_CACHE_MISS
		|| eStat == SQLITE_DBSTATUS_CACHE_WRITE
	);

	assert(SQLITE_DBSTATUS_CACHE_HIT + 1 == SQLITE_DBSTATUS_CACHE_MISS);
	assert(SQLITE_DBSTATUS_CACHE_HIT + 2 == SQLITE_DBSTATUS_CACHE_WRITE);
	assert(PAGER_STAT_HIT == 0 && PAGER_STAT_MISS == 1 && PAGER_STAT_WRITE == 2);

	*pnVal += pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT];
	if (reset) {
		pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT] = 0;
	}
}


SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager) {
	return pPager->tempFile;
}


static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint) {
	int rc = SQLITE_OK;                       
	int nCurrent = pPager->nSavepoint;        
	int ii;                                   
	PagerSavepoint *aNew;                     

	assert(pPager->eState >= PAGER_WRITER_LOCKED);
	assert(assert_pager_state(pPager));
	assert(nSavepoint>nCurrent && pPager->useJournal);

	
	aNew = (PagerSavepoint *)sqlite3Realloc(
		pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
	);
	if (!aNew) {
		return SQLITE_NOMEM_BKPT;
	}
	memset(&aNew[nCurrent], 0, (nSavepoint - nCurrent) * sizeof(PagerSavepoint));
	pPager->aSavepoint = aNew;

	
	for (ii = nCurrent; ii<nSavepoint; ii++) {
		aNew[ii].nOrig = pPager->dbSize;
		if (isOpen(pPager->jfd) && pPager->journalOff>0) {
			aNew[ii].iOffset = pPager->journalOff;
		}
		else {
			aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);
		}
		aNew[ii].iSubRec = pPager->nSubRec;
		aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
		if (!aNew[ii].pInSavepoint) {
			return SQLITE_NOMEM_BKPT;
		}
		if (pagerUseWal(pPager)) {
			sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
		}
		pPager->nSavepoint = ii + 1;
	}
	assert(pPager->nSavepoint == nSavepoint);
	assertTruncateConstraint(pPager);
	return rc;
}
SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint) {
	assert(pPager->eState >= PAGER_WRITER_LOCKED);
	assert(assert_pager_state(pPager));

	if (nSavepoint>pPager->nSavepoint && pPager->useJournal) {
		return pagerOpenSavepoint(pPager, nSavepoint);
	}
	else {
		return SQLITE_OK;
	}
}



SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint) {
	int rc = pPager->errCode;

#ifdef SQLITE_ENABLE_ZIPVFS
	if (op == SAVEPOINT_RELEASE) rc = SQLITE_OK;
#endif

	assert(op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK);
	assert(iSavepoint >= 0 || op == SAVEPOINT_ROLLBACK);

	if (rc == SQLITE_OK && iSavepoint<pPager->nSavepoint) {
		int ii;            
		int nNew;          

						   
		nNew = iSavepoint + ((op == SAVEPOINT_RELEASE) ? 0 : 1);
		for (ii = nNew; ii<pPager->nSavepoint; ii++) {
			sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
		}
		pPager->nSavepoint = nNew;

		
		if (op == SAVEPOINT_RELEASE) {
			if (nNew == 0 && isOpen(pPager->sjfd)) {
				
				if (sqlite3JournalIsInMemory(pPager->sjfd)) {
					rc = sqlite3OsTruncate(pPager->sjfd, 0);
					assert(rc == SQLITE_OK);
				}
				pPager->nSubRec = 0;
			}
		}
		
		else if (pagerUseWal(pPager) || isOpen(pPager->jfd)) {
			PagerSavepoint *pSavepoint = (nNew == 0) ? 0 : &pPager->aSavepoint[nNew - 1];
			rc = pagerPlaybackSavepoint(pPager, pSavepoint);
			assert(rc != SQLITE_DONE);
		}

#ifdef SQLITE_ENABLE_ZIPVFS
		
		else if (
			pPager->journalMode == PAGER_JOURNALMODE_OFF
			&& pPager->eState >= PAGER_WRITER_CACHEMOD
			) {
			pPager->errCode = SQLITE_ABORT;
			pPager->eState = PAGER_ERROR;
		}
#endif
	}

	return rc;
}


SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager *pPager, int nullIfMemDb) {
	return (nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename;
}


SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager *pPager) {
	return pPager->pVfs;
}


SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager) {
	return pPager->fd;
}


SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager) {
#if SQLITE_OMIT_WAL
	return pPager->jfd;
#else
	return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;
#endif
}


SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager) {
	return pPager->zJournal;
}

#ifdef SQLITE_HAS_CODEC

SQLITE_PRIVATE void sqlite3PagerSetCodec(
	Pager *pPager,
	void *(*xCodec)(void*, void*, Pgno, int),
	void(*xCodecSizeChng)(void*, int, int),
	void(*xCodecFree)(void*),
	void *pCodec
) {
	if (pPager->xCodecFree) pPager->xCodecFree(pPager->pCodec);
	pPager->xCodec = pPager->memDb ? 0 : xCodec;
	pPager->xCodecSizeChng = xCodecSizeChng;
	pPager->xCodecFree = xCodecFree;
	pPager->pCodec = pCodec;
	pagerReportSize(pPager);
}
SQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager) {
	return pPager->pCodec;
}


SQLITE_PRIVATE void *sqlite3PagerCodec(PgHdr *pPg) {
	void *aData = 0;
	CODEC2(pPg->pPager, pPg->pData, pPg->pgno, 6, return 0, aData);
	return aData;
}


SQLITE_PRIVATE int sqlite3PagerState(Pager *pPager) {
	return pPager->eState;
}
#endif 

#ifndef SQLITE_OMIT_AUTOVACUUM

SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit) {
	PgHdr *pPgOld;               
	Pgno needSyncPgno = 0;       
	int rc;                      
	Pgno origPgno;               

	assert(pPg->nRef>0);
	assert(pPager->eState == PAGER_WRITER_CACHEMOD
		|| pPager->eState == PAGER_WRITER_DBMOD
	);
	assert(assert_pager_state(pPager));

	
	assert(pPager->tempFile || !MEMDB);
	if (pPager->tempFile) {
		rc = sqlite3PagerWrite(pPg);
		if (rc) return rc;
	}

	
	if ((pPg->flags & PGHDR_DIRTY) != 0
		&& SQLITE_OK != (rc = subjournalPageIfRequired(pPg))
		) {
		return rc;
	}

	PAGERTRACE(("MOVE %d page %d (needSync=%d) moves to %d\n",
		PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC) ? 1 : 0, pgno));
	IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno))

		
		if ((pPg->flags&PGHDR_NEED_SYNC) && !isCommit) {
			needSyncPgno = pPg->pgno;
			assert(pPager->journalMode == PAGER_JOURNALMODE_OFF ||
				pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize);
			assert(pPg->flags&PGHDR_DIRTY);
		}

	
	pPg->flags &= ~PGHDR_NEED_SYNC;
	pPgOld = sqlite3PagerLookup(pPager, pgno);
	assert(!pPgOld || pPgOld->nRef == 1);
	if (pPgOld) {
		pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);
		if (pPager->tempFile) {
			
			sqlite3PcacheMove(pPgOld, pPager->dbSize + 1);
		}
		else {
			sqlite3PcacheDrop(pPgOld);
		}
	}

	origPgno = pPg->pgno;
	sqlite3PcacheMove(pPg, pgno);
	sqlite3PcacheMakeDirty(pPg);

	
	if (pPager->tempFile && pPgOld) {
		sqlite3PcacheMove(pPgOld, origPgno);
		sqlite3PagerUnrefNotNull(pPgOld);
	}

	if (needSyncPgno) {
		
		PgHdr *pPgHdr;
		rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);
		if (rc != SQLITE_OK) {
			if (needSyncPgno <= pPager->dbOrigSize) {
				assert(pPager->pTmpSpace != 0);
				sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
			}
			return rc;
		}
		pPgHdr->flags |= PGHDR_NEED_SYNC;
		sqlite3PcacheMakeDirty(pPgHdr);
		sqlite3PagerUnrefNotNull(pPgHdr);
	}

	return SQLITE_OK;
}
#endif


SQLITE_PRIVATE void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags) {
	assert(pPg->pgno != iNew);
	pPg->flags = flags;
	sqlite3PcacheMove(pPg, iNew);
}


SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg) {
	assert(pPg->nRef>0 || pPg->pPager->memDb);
	return pPg->pData;
}


SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg) {
	return pPg->pExtra;
}


SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode) {
	assert(eMode == PAGER_LOCKINGMODE_QUERY
		|| eMode == PAGER_LOCKINGMODE_NORMAL
		|| eMode == PAGER_LOCKINGMODE_EXCLUSIVE);
	assert(PAGER_LOCKINGMODE_QUERY<0);
	assert(PAGER_LOCKINGMODE_NORMAL >= 0 && PAGER_LOCKINGMODE_EXCLUSIVE >= 0);
	assert(pPager->exclusiveMode || 0 == sqlite3WalHeapMemory(pPager->pWal));
	if (eMode >= 0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal)) {
		pPager->exclusiveMode = (u8)eMode;
	}
	return (int)pPager->exclusiveMode;
}


SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode) {
	u8 eOld = pPager->journalMode;    

#ifdef SQLITE_DEBUG
									  
	print_pager_state(pPager);
#endif


	
	assert(eMode == PAGER_JOURNALMODE_DELETE
		|| eMode == PAGER_JOURNALMODE_TRUNCATE
		|| eMode == PAGER_JOURNALMODE_PERSIST
		|| eMode == PAGER_JOURNALMODE_OFF
		|| eMode == PAGER_JOURNALMODE_WAL
		|| eMode == PAGER_JOURNALMODE_MEMORY);

	
	assert(pPager->tempFile == 0 || eMode != PAGER_JOURNALMODE_WAL);

	
	if (MEMDB) {
		assert(eOld == PAGER_JOURNALMODE_MEMORY || eOld == PAGER_JOURNALMODE_OFF);
		if (eMode != PAGER_JOURNALMODE_MEMORY && eMode != PAGER_JOURNALMODE_OFF) {
			eMode = eOld;
		}
	}

	if (eMode != eOld) {

		
		assert(pPager->eState != PAGER_ERROR);
		pPager->journalMode = (u8)eMode;

		
		assert((PAGER_JOURNALMODE_TRUNCATE & 5) == 1);
		assert((PAGER_JOURNALMODE_PERSIST & 5) == 1);
		assert((PAGER_JOURNALMODE_DELETE & 5) == 0);
		assert((PAGER_JOURNALMODE_MEMORY & 5) == 4);
		assert((PAGER_JOURNALMODE_OFF & 5) == 0);
		assert((PAGER_JOURNALMODE_WAL & 5) == 5);

		assert(isOpen(pPager->fd) || pPager->exclusiveMode);
		if (!pPager->exclusiveMode && (eOld & 5) == 1 && (eMode & 1) == 0) {

			
			sqlite3OsClose(pPager->jfd);
			if (pPager->eLock >= RESERVED_LOCK) {
				sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
			}
			else {
				int rc = SQLITE_OK;
				int state = pPager->eState;
				assert(state == PAGER_OPEN || state == PAGER_READER);
				if (state == PAGER_OPEN) {
					rc = sqlite3PagerSharedLock(pPager);
				}
				if (pPager->eState == PAGER_READER) {
					assert(rc == SQLITE_OK);
					rc = pagerLockDb(pPager, RESERVED_LOCK);
				}
				if (rc == SQLITE_OK) {
					sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
				}
				if (rc == SQLITE_OK && state == PAGER_READER) {
					pagerUnlockDb(pPager, SHARED_LOCK);
				}
				else if (state == PAGER_OPEN) {
					pager_unlock(pPager);
				}
				assert(state == pPager->eState);
			}
		}
		else if (eMode == PAGER_JOURNALMODE_OFF) {
			sqlite3OsClose(pPager->jfd);
		}
	}

	
	return (int)pPager->journalMode;
}


SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager *pPager) {
	return (int)pPager->journalMode;
}


SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager *pPager) {
	assert(assert_pager_state(pPager));
	if (pPager->eState >= PAGER_WRITER_CACHEMOD) return 0;
	if (NEVER(isOpen(pPager->jfd) && pPager->journalOff>0)) return 0;
	return 1;
}


SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit) {
	if (iLimit >= -1) {
		pPager->journalSizeLimit = iLimit;
		sqlite3WalLimit(pPager->pWal, iLimit);
	}
	return pPager->journalSizeLimit;
}


SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager) {
	return &pPager->pBackup;
}

#ifndef SQLITE_OMIT_VACUUM

SQLITE_PRIVATE void sqlite3PagerClearCache(Pager *pPager) {
	assert(MEMDB == 0 || pPager->tempFile);
	if (pPager->tempFile == 0) pager_reset(pPager);
}
#endif


#ifndef SQLITE_OMIT_WAL

SQLITE_PRIVATE int sqlite3PagerCheckpoint(Pager *pPager, int eMode, int *pnLog, int *pnCkpt) {
	int rc = SQLITE_OK;
	if (pPager->pWal) {
		rc = sqlite3WalCheckpoint(pPager->pWal, eMode,
			(eMode == SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),
			pPager->pBusyHandlerArg,
			pPager->ckptSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
			pnLog, pnCkpt
		);
	}
	return rc;
}

SQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager) {
	return sqlite3WalCallback(pPager->pWal);
}


SQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager) {
	const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
	if (pPager->noLock) return 0;
	return pPager->exclusiveMode || (pMethods->iVersion >= 2 && pMethods->xShmMap);
}


static int pagerExclusiveLock(Pager *pPager) {
	int rc;                         

	assert(pPager->eLock == SHARED_LOCK || pPager->eLock == EXCLUSIVE_LOCK);
	rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
	if (rc != SQLITE_OK) {
		
		pagerUnlockDb(pPager, SHARED_LOCK);
	}

	return rc;
}


static int pagerOpenWal(Pager *pPager) {
	int rc = SQLITE_OK;

	assert(pPager->pWal == 0 && pPager->tempFile == 0);
	assert(pPager->eLock == SHARED_LOCK || pPager->eLock == EXCLUSIVE_LOCK);

	
	if (pPager->exclusiveMode) {
		rc = pagerExclusiveLock(pPager);
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3WalOpen(pPager->pVfs,
			pPager->fd, pPager->zWal, pPager->exclusiveMode,
			pPager->journalSizeLimit, &pPager->pWal
		);
	}
	pagerFixMaplimit(pPager);

	return rc;
}



SQLITE_PRIVATE int sqlite3PagerOpenWal(
	Pager *pPager,                  
	int *pbOpen                     
) {
	int rc = SQLITE_OK;             

	assert(assert_pager_state(pPager));
	assert(pPager->eState == PAGER_OPEN || pbOpen);
	assert(pPager->eState == PAGER_READER || !pbOpen);
	assert(pbOpen == 0 || *pbOpen == 0);
	assert(pbOpen != 0 || (!pPager->tempFile && !pPager->pWal));

	if (!pPager->tempFile && !pPager->pWal) {
		if (!sqlite3PagerWalSupported(pPager)) return SQLITE_CANTOPEN;

		
		sqlite3OsClose(pPager->jfd);

		rc = pagerOpenWal(pPager);
		if (rc == SQLITE_OK) {
			pPager->journalMode = PAGER_JOURNALMODE_WAL;
			pPager->eState = PAGER_OPEN;
		}
	}
	else {
		*pbOpen = 1;
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager) {
	int rc = SQLITE_OK;

	assert(pPager->journalMode == PAGER_JOURNALMODE_WAL);

	
	if (!pPager->pWal) {
		int logexists = 0;
		rc = pagerLockDb(pPager, SHARED_LOCK);
		if (rc == SQLITE_OK) {
			rc = sqlite3OsAccess(
				pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists
			);
		}
		if (rc == SQLITE_OK && logexists) {
			rc = pagerOpenWal(pPager);
		}
	}

	
	if (rc == SQLITE_OK && pPager->pWal) {
		rc = pagerExclusiveLock(pPager);
		if (rc == SQLITE_OK) {
			rc = sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags,
				pPager->pageSize, (u8*)pPager->pTmpSpace);
			pPager->pWal = 0;
			pagerFixMaplimit(pPager);
			if (rc && !pPager->exclusiveMode) pagerUnlockDb(pPager, SHARED_LOCK);
		}
	}
	return rc;
}

#ifdef SQLITE_ENABLE_SNAPSHOT

SQLITE_PRIVATE int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot) {
	int rc = SQLITE_ERROR;
	if (pPager->pWal) {
		rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot) {
	int rc = SQLITE_OK;
	if (pPager->pWal) {
		sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);
	}
	else {
		rc = SQLITE_ERROR;
	}
	return rc;
}
#endif 
#endif 

#ifdef SQLITE_ENABLE_ZIPVFS

SQLITE_PRIVATE int sqlite3PagerWalFramesize(Pager *pPager) {
	assert(pPager->eState >= PAGER_READER);
	return sqlite3WalFramesize(pPager->pWal);
}
#endif

#endif 




#ifndef SQLITE_OMIT_WAL




#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
SQLITE_PRIVATE int sqlite3WalTrace = 0;
# define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X
#else
# define WALTRACE(X)
#endif


#define WAL_MAX_VERSION      3007000
#define WALINDEX_MAX_VERSION 3007000


#define WAL_WRITE_LOCK         0
#define WAL_ALL_BUT_WRITE      1
#define WAL_CKPT_LOCK          1
#define WAL_RECOVER_LOCK       2
#define WAL_READ_LOCK(I)       (3+(I))
#define WAL_NREADER            (SQLITE_SHM_NLOCK-3)



typedef struct WalIndexHdr WalIndexHdr;
typedef struct WalIterator WalIterator;
typedef struct WalCkptInfo WalCkptInfo;



struct WalIndexHdr {
	u32 iVersion;                   
	u32 unused;                     
	u32 iChange;                    
	u8 isInit;                      
	u8 bigEndCksum;                 
	u16 szPage;                     
	u32 mxFrame;                    
	u32 nPage;                      
	u32 aFrameCksum[2];             
	u32 aSalt[2];                   
	u32 aCksum[2];                  
};


struct WalCkptInfo {
	u32 nBackfill;                  
	u32 aReadMark[WAL_NREADER];     
	u8 aLock[SQLITE_SHM_NLOCK];     
	u32 nBackfillAttempted;         
	u32 notUsed0;                   
};
#define READMARK_NOT_USED  0xffffffff



#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))
#define WALINDEX_HDR_SIZE    (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))


#define WAL_FRAME_HDRSIZE 24



#define WAL_HDRSIZE 32


#define WAL_MAGIC 0x377f0682


#define walFrameOffset(iFrame, szPage) (                               \
  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \
)


struct Wal {
	sqlite3_vfs *pVfs;         
	sqlite3_file *pDbFd;       
	sqlite3_file *pWalFd;      
	u32 iCallback;             
	i64 mxWalSize;             
	int nWiData;               
	int szFirstBlock;          
	volatile u32 **apWiData;   
	u32 szPage;                
	i16 readLock;              
	u8 syncFlags;              
	u8 exclusiveMode;          
	u8 writeLock;              
	u8 ckptLock;               
	u8 readOnly;               
	u8 truncateOnCommit;       
	u8 syncHeader;             
	u8 padToSectorBoundary;    
	WalIndexHdr hdr;           
	u32 minFrame;              
	u32 iReCksum;              
	const char *zWalName;      
	u32 nCkpt;                 
#ifdef SQLITE_DEBUG
	u8 lockError;              
#endif
#ifdef SQLITE_ENABLE_SNAPSHOT
	WalIndexHdr *pSnapshot;    
#endif
};


#define WAL_NORMAL_MODE     0
#define WAL_EXCLUSIVE_MODE  1     
#define WAL_HEAPMEMORY_MODE 2


#define WAL_RDWR        0    
#define WAL_RDONLY      1    
#define WAL_SHM_RDONLY  2    


typedef u16 ht_slot;


struct WalIterator {
	int iPrior;                     
	int nSegment;                   
	struct WalSegment {
		int iNext;                    
		ht_slot *aIndex;              
		u32 *aPgno;                   
		int nEntry;                   
		int iZero;                    
	} aSegment[1];                  
};


#define HASHTABLE_NPAGE      4096                 
#define HASHTABLE_HASH_1     383                  
#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  


#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))


#define WALINDEX_PGSZ   (                                         \
    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \
)


static int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage) {
	int rc = SQLITE_OK;

	
	if (pWal->nWiData <= iPage) {
		int nByte = sizeof(u32*)*(iPage + 1);
		volatile u32 **apNew;
		apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal->apWiData, nByte);
		if (!apNew) {
			*ppPage = 0;
			return SQLITE_NOMEM_BKPT;
		}
		memset((void*)&apNew[pWal->nWiData], 0,
			sizeof(u32*)*(iPage + 1 - pWal->nWiData));
		pWal->apWiData = apNew;
		pWal->nWiData = iPage + 1;
	}

	
	if (pWal->apWiData[iPage] == 0) {
		if (pWal->exclusiveMode == WAL_HEAPMEMORY_MODE) {
			pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);
			if (!pWal->apWiData[iPage]) rc = SQLITE_NOMEM_BKPT;
		}
		else {
			rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ,
				pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
			);
			if (rc == SQLITE_READONLY) {
				pWal->readOnly |= WAL_SHM_RDONLY;
				rc = SQLITE_OK;
			}
		}
	}

	*ppPage = pWal->apWiData[iPage];
	assert(iPage == 0 || *ppPage || rc != SQLITE_OK);
	return rc;
}


static volatile WalCkptInfo *walCkptInfo(Wal *pWal) {
	assert(pWal->nWiData>0 && pWal->apWiData[0]);
	return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr) / 2]);
}


static volatile WalIndexHdr *walIndexHdr(Wal *pWal) {
	assert(pWal->nWiData>0 && pWal->apWiData[0]);
	return (volatile WalIndexHdr*)pWal->apWiData[0];
}


#define BYTESWAP32(x) ( \
    (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  \
  + (((x)&0x00FF0000)>>8)  + (((x)&0xFF000000)>>24) \
)


static void walChecksumBytes(
	int nativeCksum, 
	u8 *a,           
	int nByte,       
	const u32 *aIn,  
	u32 *aOut        
) {
	u32 s1, s2;
	u32 *aData = (u32 *)a;
	u32 *aEnd = (u32 *)&a[nByte];

	if (aIn) {
		s1 = aIn[0];
		s2 = aIn[1];
	}
	else {
		s1 = s2 = 0;
	}

	assert(nByte >= 8);
	assert((nByte & 0x00000007) == 0);

	if (nativeCksum) {
		do {
			s1 += *aData++ + s2;
			s2 += *aData++ + s1;
		} while (aData<aEnd);
	}
	else {
		do {
			s1 += BYTESWAP32(aData[0]) + s2;
			s2 += BYTESWAP32(aData[1]) + s1;
			aData += 2;
		} while (aData<aEnd);
	}

	aOut[0] = s1;
	aOut[1] = s2;
}

static void walShmBarrier(Wal *pWal) {
	if (pWal->exclusiveMode != WAL_HEAPMEMORY_MODE) {
		sqlite3OsShmBarrier(pWal->pDbFd);
	}
}


static void walIndexWriteHdr(Wal *pWal) {
	volatile WalIndexHdr *aHdr = walIndexHdr(pWal);
	const int nCksum = offsetof(WalIndexHdr, aCksum);

	assert(pWal->writeLock);
	pWal->hdr.isInit = 1;
	pWal->hdr.iVersion = WALINDEX_MAX_VERSION;
	walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);
	memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
	walShmBarrier(pWal);
	memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
}


static void walEncodeFrame(
	Wal *pWal,                      
	u32 iPage,                      
	u32 nTruncate,                  
	u8 *aData,                      
	u8 *aFrame                      
) {
	int nativeCksum;                
	u32 *aCksum = pWal->hdr.aFrameCksum;
	assert(WAL_FRAME_HDRSIZE == 24);
	sqlite3Put4byte(&aFrame[0], iPage);
	sqlite3Put4byte(&aFrame[4], nTruncate);
	if (pWal->iReCksum == 0) {
		memcpy(&aFrame[8], pWal->hdr.aSalt, 8);

		nativeCksum = (pWal->hdr.bigEndCksum == SQLITE_BIGENDIAN);
		walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
		walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);

		sqlite3Put4byte(&aFrame[16], aCksum[0]);
		sqlite3Put4byte(&aFrame[20], aCksum[1]);
	}
	else {
		memset(&aFrame[8], 0, 16);
	}
}


static int walDecodeFrame(
	Wal *pWal,                      
	u32 *piPage,                    
	u32 *pnTruncate,                
	u8 *aData,                      
	u8 *aFrame                      
) {
	int nativeCksum;                
	u32 *aCksum = pWal->hdr.aFrameCksum;
	u32 pgno;                       
	assert(WAL_FRAME_HDRSIZE == 24);

	
	if (memcmp(&pWal->hdr.aSalt, &aFrame[8], 8) != 0) {
		return 0;
	}

	
	pgno = sqlite3Get4byte(&aFrame[0]);
	if (pgno == 0) {
		return 0;
	}

	
	nativeCksum = (pWal->hdr.bigEndCksum == SQLITE_BIGENDIAN);
	walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
	walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
	if (aCksum[0] != sqlite3Get4byte(&aFrame[16])
		|| aCksum[1] != sqlite3Get4byte(&aFrame[20])
		) {
		
		return 0;
	}

	
	*piPage = pgno;
	*pnTruncate = sqlite3Get4byte(&aFrame[4]);
	return 1;
}


#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)

static const char *walLockName(int lockIdx) {
	if (lockIdx == WAL_WRITE_LOCK) {
		return "WRITE-LOCK";
	}
	else if (lockIdx == WAL_CKPT_LOCK) {
		return "CKPT-LOCK";
	}
	else if (lockIdx == WAL_RECOVER_LOCK) {
		return "RECOVER-LOCK";
	}
	else {
		static char zName[15];
		sqlite3_snprintf(sizeof(zName), zName, "READ-LOCK[%d]",
			lockIdx - WAL_READ_LOCK(0));
		return zName;
	}
}
#endif 



static int walLockShared(Wal *pWal, int lockIdx) {
	int rc;
	if (pWal->exclusiveMode) return SQLITE_OK;
	rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
		SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);
	WALTRACE(("WAL%p: acquire SHARED-%s %s\n", pWal,
		walLockName(lockIdx), rc ? "failed" : "ok"));
	VVA_ONLY(pWal->lockError = (u8)(rc != SQLITE_OK && rc != SQLITE_BUSY); )
		return rc;
}
static void walUnlockShared(Wal *pWal, int lockIdx) {
	if (pWal->exclusiveMode) return;
	(void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
		SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);
	WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));
}
static int walLockExclusive(Wal *pWal, int lockIdx, int n) {
	int rc;
	if (pWal->exclusiveMode) return SQLITE_OK;
	rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
		SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);
	WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,
		walLockName(lockIdx), n, rc ? "failed" : "ok"));
	VVA_ONLY(pWal->lockError = (u8)(rc != SQLITE_OK && rc != SQLITE_BUSY); )
		return rc;
}
static void walUnlockExclusive(Wal *pWal, int lockIdx, int n) {
	if (pWal->exclusiveMode) return;
	(void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
		SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);
	WALTRACE(("WAL%p: release EXCLUSIVE-%s cnt=%d\n", pWal,
		walLockName(lockIdx), n));
}


static int walHash(u32 iPage) {
	assert(iPage>0);
	assert((HASHTABLE_NSLOT & (HASHTABLE_NSLOT - 1)) == 0);
	return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT - 1);
}
static int walNextHash(int iPriorHash) {
	return (iPriorHash + 1)&(HASHTABLE_NSLOT - 1);
}


static int walHashGet(
	Wal *pWal,                      
	int iHash,                      
	volatile ht_slot **paHash,      
	volatile u32 **paPgno,          
	u32 *piZero                     
) {
	int rc;                         
	volatile u32 *aPgno;

	rc = walIndexPage(pWal, iHash, &aPgno);
	assert(rc == SQLITE_OK || iHash>0);

	if (rc == SQLITE_OK) {
		u32 iZero;
		volatile ht_slot *aHash;

		aHash = (volatile ht_slot *)&aPgno[HASHTABLE_NPAGE];
		if (iHash == 0) {
			aPgno = &aPgno[WALINDEX_HDR_SIZE / sizeof(u32)];
			iZero = 0;
		}
		else {
			iZero = HASHTABLE_NPAGE_ONE + (iHash - 1)*HASHTABLE_NPAGE;
		}

		*paPgno = &aPgno[-1];
		*paHash = aHash;
		*piZero = iZero;
	}
	return rc;
}


static int walFramePage(u32 iFrame) {
	int iHash = (iFrame + HASHTABLE_NPAGE - HASHTABLE_NPAGE_ONE - 1) / HASHTABLE_NPAGE;
	assert((iHash == 0 || iFrame>HASHTABLE_NPAGE_ONE)
		&& (iHash >= 1 || iFrame <= HASHTABLE_NPAGE_ONE)
		&& (iHash <= 1 || iFrame>(HASHTABLE_NPAGE_ONE + HASHTABLE_NPAGE))
		&& (iHash >= 2 || iFrame <= HASHTABLE_NPAGE_ONE + HASHTABLE_NPAGE)
		&& (iHash <= 2 || iFrame>(HASHTABLE_NPAGE_ONE + 2 * HASHTABLE_NPAGE))
	);
	return iHash;
}


static u32 walFramePgno(Wal *pWal, u32 iFrame) {
	int iHash = walFramePage(iFrame);
	if (iHash == 0) {
		return pWal->apWiData[0][WALINDEX_HDR_SIZE / sizeof(u32) + iFrame - 1];
	}
	return pWal->apWiData[iHash][(iFrame - 1 - HASHTABLE_NPAGE_ONE) % HASHTABLE_NPAGE];
}


static void walCleanupHash(Wal *pWal) {
	volatile ht_slot *aHash = 0;    
	volatile u32 *aPgno = 0;        
	u32 iZero = 0;                  
	int iLimit = 0;                 
	int nByte;                      
	int i;                          

	assert(pWal->writeLock);
	testcase(pWal->hdr.mxFrame == HASHTABLE_NPAGE_ONE - 1);
	testcase(pWal->hdr.mxFrame == HASHTABLE_NPAGE_ONE);
	testcase(pWal->hdr.mxFrame == HASHTABLE_NPAGE_ONE + 1);

	if (pWal->hdr.mxFrame == 0) return;

	
	assert(pWal->nWiData>walFramePage(pWal->hdr.mxFrame));
	assert(pWal->apWiData[walFramePage(pWal->hdr.mxFrame)]);
	walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &aHash, &aPgno, &iZero);

	
	iLimit = pWal->hdr.mxFrame - iZero;
	assert(iLimit>0);
	for (i = 0; i<HASHTABLE_NSLOT; i++) {
		if (aHash[i]>iLimit) {
			aHash[i] = 0;
		}
	}

	
	nByte = (int)((char *)aHash - (char *)&aPgno[iLimit + 1]);
	memset((void *)&aPgno[iLimit + 1], 0, nByte);

#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
	
	if (iLimit) {
		int j;           
		int iKey;        
		for (j = 1; j <= iLimit; j++) {
			for (iKey = walHash(aPgno[j]); aHash[iKey]; iKey = walNextHash(iKey)) {
				if (aHash[iKey] == j) break;
			}
			assert(aHash[iKey] == j);
		}
	}
#endif 
}



static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage) {
	int rc;                         
	u32 iZero = 0;                  
	volatile u32 *aPgno = 0;        
	volatile ht_slot *aHash = 0;    

	rc = walHashGet(pWal, walFramePage(iFrame), &aHash, &aPgno, &iZero);

	
	if (rc == SQLITE_OK) {
		int iKey;                     
		int idx;                      
		int nCollide;                 

		idx = iFrame - iZero;
		assert(idx <= HASHTABLE_NSLOT / 2 + 1);

		
		if (idx == 1) {
			int nByte = (int)((u8 *)&aHash[HASHTABLE_NSLOT] - (u8 *)&aPgno[1]);
			memset((void*)&aPgno[1], 0, nByte);
		}

		
		if (aPgno[idx]) {
			walCleanupHash(pWal);
			assert(!aPgno[idx]);
		}

		
		nCollide = idx;
		for (iKey = walHash(iPage); aHash[iKey]; iKey = walNextHash(iKey)) {
			if ((nCollide--) == 0) return SQLITE_CORRUPT_BKPT;
		}
		aPgno[idx] = iPage;
		aHash[iKey] = (ht_slot)idx;

#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
		
		{
			int i;           
			int nEntry = 0;  
			for (i = 0; i<HASHTABLE_NSLOT; i++) { if (aHash[i]) nEntry++; }
			assert(nEntry == idx);
		}

		
		if ((idx & 0x3ff) == 0) {
			int i;           
			for (i = 1; i <= idx; i++) {
				for (iKey = walHash(aPgno[i]); aHash[iKey]; iKey = walNextHash(iKey)) {
					if (aHash[iKey] == i) break;
				}
				assert(aHash[iKey] == i);
			}
		}
#endif 
	}


	return rc;
}



static int walIndexRecover(Wal *pWal) {
	int rc;                         
	i64 nSize;                      
	u32 aFrameCksum[2] = { 0, 0 };
	int iLock;                      
	int nLock;                      

									
	assert(pWal->ckptLock == 1 || pWal->ckptLock == 0);
	assert(WAL_ALL_BUT_WRITE == WAL_WRITE_LOCK + 1);
	assert(WAL_CKPT_LOCK == WAL_ALL_BUT_WRITE);
	assert(pWal->writeLock);
	iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;
	nLock = SQLITE_SHM_NLOCK - iLock;
	rc = walLockExclusive(pWal, iLock, nLock);
	if (rc) {
		return rc;
	}
	WALTRACE(("WAL%p: recovery begin...\n", pWal));

	memset(&pWal->hdr, 0, sizeof(WalIndexHdr));

	rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);
	if (rc != SQLITE_OK) {
		goto recovery_error;
	}

	if (nSize>WAL_HDRSIZE) {
		u8 aBuf[WAL_HDRSIZE];         
		u8 *aFrame = 0;               
		int szFrame;                  
		u8 *aData;                    
		int iFrame;                   
		i64 iOffset;                  
		int szPage;                   
		u32 magic;                    
		u32 version;                  
		int isValid;                  

									  
		rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);
		if (rc != SQLITE_OK) {
			goto recovery_error;
		}

		
		magic = sqlite3Get4byte(&aBuf[0]);
		szPage = sqlite3Get4byte(&aBuf[8]);
		if ((magic & 0xFFFFFFFE) != WAL_MAGIC
			|| szPage&(szPage - 1)
			|| szPage>SQLITE_MAX_PAGE_SIZE
			|| szPage<512
			) {
			goto finished;
		}
		pWal->hdr.bigEndCksum = (u8)(magic & 0x00000001);
		pWal->szPage = szPage;
		pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);
		memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);

		
		walChecksumBytes(pWal->hdr.bigEndCksum == SQLITE_BIGENDIAN,
			aBuf, WAL_HDRSIZE - 2 * 4, 0, pWal->hdr.aFrameCksum
		);
		if (pWal->hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24])
			|| pWal->hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])
			) {
			goto finished;
		}

		
		version = sqlite3Get4byte(&aBuf[4]);
		if (version != WAL_MAX_VERSION) {
			rc = SQLITE_CANTOPEN_BKPT;
			goto finished;
		}

		
		szFrame = szPage + WAL_FRAME_HDRSIZE;
		aFrame = (u8 *)sqlite3_malloc64(szFrame);
		if (!aFrame) {
			rc = SQLITE_NOMEM_BKPT;
			goto recovery_error;
		}
		aData = &aFrame[WAL_FRAME_HDRSIZE];

		
		iFrame = 0;
		for (iOffset = WAL_HDRSIZE; (iOffset + szFrame) <= nSize; iOffset += szFrame) {
			u32 pgno;                   
			u32 nTruncate;              

										
			iFrame++;
			rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
			if (rc != SQLITE_OK) break;
			isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);
			if (!isValid) break;
			rc = walIndexAppend(pWal, iFrame, pgno);
			if (rc != SQLITE_OK) break;

			
			if (nTruncate) {
				pWal->hdr.mxFrame = iFrame;
				pWal->hdr.nPage = nTruncate;
				pWal->hdr.szPage = (u16)((szPage & 0xff00) | (szPage >> 16));
				testcase(szPage <= 32768);
				testcase(szPage >= 65536);
				aFrameCksum[0] = pWal->hdr.aFrameCksum[0];
				aFrameCksum[1] = pWal->hdr.aFrameCksum[1];
			}
		}

		sqlite3_free(aFrame);
	}

finished:
	if (rc == SQLITE_OK) {
		volatile WalCkptInfo *pInfo;
		int i;
		pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
		pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
		walIndexWriteHdr(pWal);

		
		pInfo = walCkptInfo(pWal);
		pInfo->nBackfill = 0;
		pInfo->nBackfillAttempted = pWal->hdr.mxFrame;
		pInfo->aReadMark[0] = 0;
		for (i = 1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;
		if (pWal->hdr.mxFrame) pInfo->aReadMark[1] = pWal->hdr.mxFrame;

		
		if (pWal->hdr.nPage) {
			sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,
				"recovered %d frames from WAL file %s",
				pWal->hdr.mxFrame, pWal->zWalName
			);
		}
	}

recovery_error:
	WALTRACE(("WAL%p: recovery %s\n", pWal, rc ? "failed" : "ok"));
	walUnlockExclusive(pWal, iLock, nLock);
	return rc;
}


static void walIndexClose(Wal *pWal, int isDelete) {
	if (pWal->exclusiveMode == WAL_HEAPMEMORY_MODE) {
		int i;
		for (i = 0; i<pWal->nWiData; i++) {
			sqlite3_free((void *)pWal->apWiData[i]);
			pWal->apWiData[i] = 0;
		}
	}
	else {
		sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
	}
}


SQLITE_PRIVATE int sqlite3WalOpen(
	sqlite3_vfs *pVfs,              
	sqlite3_file *pDbFd,            
	const char *zWalName,           
	int bNoShm,                     
	i64 mxWalSize,                  
	Wal **ppWal                     
) {
	int rc;                         
	Wal *pRet;                      
	int flags;                      

	assert(zWalName && zWalName[0]);
	assert(pDbFd);

	
	assert(120 == WALINDEX_LOCK_OFFSET);
	assert(136 == WALINDEX_HDR_SIZE);
#ifdef WIN_SHM_BASE
	assert(WIN_SHM_BASE == WALINDEX_LOCK_OFFSET);
#endif
#ifdef UNIX_SHM_BASE
	assert(UNIX_SHM_BASE == WALINDEX_LOCK_OFFSET);
#endif


	
	*ppWal = 0;
	pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);
	if (!pRet) {
		return SQLITE_NOMEM_BKPT;
	}

	pRet->pVfs = pVfs;
	pRet->pWalFd = (sqlite3_file *)&pRet[1];
	pRet->pDbFd = pDbFd;
	pRet->readLock = -1;
	pRet->mxWalSize = mxWalSize;
	pRet->zWalName = zWalName;
	pRet->syncHeader = 1;
	pRet->padToSectorBoundary = 1;
	pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE : WAL_NORMAL_MODE);

	
	flags = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_WAL);
	rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);
	if (rc == SQLITE_OK && flags&SQLITE_OPEN_READONLY) {
		pRet->readOnly = WAL_RDONLY;
	}

	if (rc != SQLITE_OK) {
		walIndexClose(pRet, 0);
		sqlite3OsClose(pRet->pWalFd);
		sqlite3_free(pRet);
	}
	else {
		int iDC = sqlite3OsDeviceCharacteristics(pDbFd);
		if (iDC & SQLITE_IOCAP_SEQUENTIAL) { pRet->syncHeader = 0; }
		if (iDC & SQLITE_IOCAP_POWERSAFE_OVERWRITE) {
			pRet->padToSectorBoundary = 0;
		}
		*ppWal = pRet;
		WALTRACE(("WAL%d: opened\n", pRet));
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3WalLimit(Wal *pWal, i64 iLimit) {
	if (pWal) pWal->mxWalSize = iLimit;
}


static int walIteratorNext(
	WalIterator *p,               
	u32 *piPage,                  
	u32 *piFrame                  
) {
	u32 iMin;                     
	u32 iRet = 0xFFFFFFFF;        
	int i;                        

	iMin = p->iPrior;
	assert(iMin<0xffffffff);
	for (i = p->nSegment - 1; i >= 0; i--) {
		struct WalSegment *pSegment = &p->aSegment[i];
		while (pSegment->iNext<pSegment->nEntry) {
			u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];
			if (iPg>iMin) {
				if (iPg<iRet) {
					iRet = iPg;
					*piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];
				}
				break;
			}
			pSegment->iNext++;
		}
	}

	*piPage = p->iPrior = iRet;
	return (iRet == 0xFFFFFFFF);
}


static void walMerge(
	const u32 *aContent,            
	ht_slot *aLeft,                 
	int nLeft,                      
	ht_slot **paRight,              
	int *pnRight,                   
	ht_slot *aTmp                   
) {
	int iLeft = 0;                  
	int iRight = 0;                 
	int iOut = 0;                   
	int nRight = *pnRight;
	ht_slot *aRight = *paRight;

	assert(nLeft>0 && nRight>0);
	while (iRight<nRight || iLeft<nLeft) {
		ht_slot logpage;
		Pgno dbpage;

		if ((iLeft<nLeft)
			&& (iRight >= nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])
			) {
			logpage = aLeft[iLeft++];
		}
		else {
			logpage = aRight[iRight++];
		}
		dbpage = aContent[logpage];

		aTmp[iOut++] = logpage;
		if (iLeft<nLeft && aContent[aLeft[iLeft]] == dbpage) iLeft++;

		assert(iLeft >= nLeft || aContent[aLeft[iLeft]]>dbpage);
		assert(iRight >= nRight || aContent[aRight[iRight]]>dbpage);
	}

	*paRight = aLeft;
	*pnRight = iOut;
	memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
}


static void walMergesort(
	const u32 *aContent,            
	ht_slot *aBuffer,               
	ht_slot *aList,                 
	int *pnList                     
) {
	struct Sublist {
		int nList;                    
		ht_slot *aList;               
	};

	const int nList = *pnList;      
	int nMerge = 0;                 
	ht_slot *aMerge = 0;            
	int iList;                      
	u32 iSub = 0;                   
	struct Sublist aSub[13];        

	memset(aSub, 0, sizeof(aSub));
	assert(nList <= HASHTABLE_NPAGE && nList>0);
	assert(HASHTABLE_NPAGE == (1 << (ArraySize(aSub) - 1)));

	for (iList = 0; iList<nList; iList++) {
		nMerge = 1;
		aMerge = &aList[iList];
		for (iSub = 0; iList & (1 << iSub); iSub++) {
			struct Sublist *p;
			assert(iSub<ArraySize(aSub));
			p = &aSub[iSub];
			assert(p->aList && p->nList <= (1 << iSub));
			assert(p->aList == &aList[iList&~((2 << iSub) - 1)]);
			walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
		}
		aSub[iSub].aList = aMerge;
		aSub[iSub].nList = nMerge;
	}

	for (iSub++; iSub<ArraySize(aSub); iSub++) {
		if (nList & (1 << iSub)) {
			struct Sublist *p;
			assert(iSub<ArraySize(aSub));
			p = &aSub[iSub];
			assert(p->nList <= (1 << iSub));
			assert(p->aList == &aList[nList&~((2 << iSub) - 1)]);
			walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
		}
	}
	assert(aMerge == aList);
	*pnList = nMerge;

#ifdef SQLITE_DEBUG
	{
		int i;
		for (i = 1; i<*pnList; i++) {
			assert(aContent[aList[i]] > aContent[aList[i - 1]]);
		}
	}
#endif
}


static void walIteratorFree(WalIterator *p) {
	sqlite3_free(p);
}


static int walIteratorInit(Wal *pWal, WalIterator **pp) {
	WalIterator *p;                 
	int nSegment;                   
	u32 iLast;                      
	int nByte;                      
	int i;                          
	ht_slot *aTmp;                  
	int rc = SQLITE_OK;             

									
	assert(pWal->ckptLock && pWal->hdr.mxFrame>0);
	iLast = pWal->hdr.mxFrame;

	
	nSegment = walFramePage(iLast) + 1;
	nByte = sizeof(WalIterator)
		+ (nSegment - 1) * sizeof(struct WalSegment)
		+ iLast * sizeof(ht_slot);
	p = (WalIterator *)sqlite3_malloc64(nByte);
	if (!p) {
		return SQLITE_NOMEM_BKPT;
	}
	memset(p, 0, nByte);
	p->nSegment = nSegment;

	
	aTmp = (ht_slot *)sqlite3_malloc64(
		sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE ? HASHTABLE_NPAGE : iLast)
	);
	if (!aTmp) {
		rc = SQLITE_NOMEM_BKPT;
	}

	for (i = 0; rc == SQLITE_OK && i<nSegment; i++) {
		volatile ht_slot *aHash;
		u32 iZero;
		volatile u32 *aPgno;

		rc = walHashGet(pWal, i, &aHash, &aPgno, &iZero);
		if (rc == SQLITE_OK) {
			int j;                      
			int nEntry;                 
			ht_slot *aIndex;            

			aPgno++;
			if ((i + 1) == nSegment) {
				nEntry = (int)(iLast - iZero);
			}
			else {
				nEntry = (int)((u32*)aHash - (u32*)aPgno);
			}
			aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[iZero];
			iZero++;

			for (j = 0; j<nEntry; j++) {
				aIndex[j] = (ht_slot)j;
			}
			walMergesort((u32 *)aPgno, aTmp, aIndex, &nEntry);
			p->aSegment[i].iZero = iZero;
			p->aSegment[i].nEntry = nEntry;
			p->aSegment[i].aIndex = aIndex;
			p->aSegment[i].aPgno = (u32 *)aPgno;
		}
	}
	sqlite3_free(aTmp);

	if (rc != SQLITE_OK) {
		walIteratorFree(p);
	}
	*pp = p;
	return rc;
}


static int walBusyLock(
	Wal *pWal,                      
	int(*xBusy)(void*),            
	void *pBusyArg,                 
	int lockIdx,                    
	int n                           
) {
	int rc;
	do {
		rc = walLockExclusive(pWal, lockIdx, n);
	} while (xBusy && rc == SQLITE_BUSY && xBusy(pBusyArg));
	return rc;
}


static int walPagesize(Wal *pWal) {
	return (pWal->hdr.szPage & 0xfe00) + ((pWal->hdr.szPage & 0x0001) << 16);
}


static void walRestartHdr(Wal *pWal, u32 salt1) {
	volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
	int i;                          
	u32 *aSalt = pWal->hdr.aSalt;   
	pWal->nCkpt++;
	pWal->hdr.mxFrame = 0;
	sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));
	memcpy(&pWal->hdr.aSalt[1], &salt1, 4);
	walIndexWriteHdr(pWal);
	pInfo->nBackfill = 0;
	pInfo->nBackfillAttempted = 0;
	pInfo->aReadMark[1] = 0;
	for (i = 2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;
	assert(pInfo->aReadMark[0] == 0);
}


static int walCheckpoint(
	Wal *pWal,                      
	int eMode,                      
	int(*xBusy)(void*),            
	void *pBusyArg,                 
	int sync_flags,                 
	u8 *zBuf                        
) {
	int rc = SQLITE_OK;             
	int szPage;                     
	WalIterator *pIter = 0;         
	u32 iDbpage = 0;                
	u32 iFrame = 0;                 
	u32 mxSafeFrame;                
	u32 mxPage;                     
	int i;                          
	volatile WalCkptInfo *pInfo;    

	szPage = walPagesize(pWal);
	testcase(szPage <= 32768);
	testcase(szPage >= 65536);
	pInfo = walCkptInfo(pWal);
	if (pInfo->nBackfill<pWal->hdr.mxFrame) {

		
		rc = walIteratorInit(pWal, &pIter);
		if (rc != SQLITE_OK) {
			return rc;
		}
		assert(pIter);

		
		assert(eMode != SQLITE_CHECKPOINT_PASSIVE || xBusy == 0);

		
		mxSafeFrame = pWal->hdr.mxFrame;
		mxPage = pWal->hdr.nPage;
		for (i = 1; i<WAL_NREADER; i++) {
			
			u32 y = pInfo->aReadMark[i];
			if (mxSafeFrame>y) {
				assert(y <= pWal->hdr.mxFrame);
				rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);
				if (rc == SQLITE_OK) {
					pInfo->aReadMark[i] = (i == 1 ? mxSafeFrame : READMARK_NOT_USED);
					walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
				}
				else if (rc == SQLITE_BUSY) {
					mxSafeFrame = y;
					xBusy = 0;
				}
				else {
					goto walcheckpoint_out;
				}
			}
		}

		if (pInfo->nBackfill<mxSafeFrame
			&& (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0), 1)) == SQLITE_OK
			) {
			i64 nSize;                    
			u32 nBackfill = pInfo->nBackfill;

			pInfo->nBackfillAttempted = mxSafeFrame;

			
			if (sync_flags) {
				rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
			}

			
			if (rc == SQLITE_OK) {
				i64 nReq = ((i64)mxPage * szPage);
				rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
				if (rc == SQLITE_OK && nSize<nReq) {
					sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);
				}
			}


			
			while (rc == SQLITE_OK && 0 == walIteratorNext(pIter, &iDbpage, &iFrame)) {
				i64 iOffset;
				assert(walFramePgno(pWal, iFrame) == iDbpage);
				if (iFrame <= nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage) {
					continue;
				}
				iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;
				
				rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
				if (rc != SQLITE_OK) break;
				iOffset = (iDbpage - 1)*(i64)szPage;
				testcase(IS_BIG_INT(iOffset));
				rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
				if (rc != SQLITE_OK) break;
			}

			
			if (rc == SQLITE_OK) {
				if (mxSafeFrame == walIndexHdr(pWal)->mxFrame) {
					i64 szDb = pWal->hdr.nPage*(i64)szPage;
					testcase(IS_BIG_INT(szDb));
					rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
					if (rc == SQLITE_OK && sync_flags) {
						rc = sqlite3OsSync(pWal->pDbFd, sync_flags);
					}
				}
				if (rc == SQLITE_OK) {
					pInfo->nBackfill = mxSafeFrame;
				}
			}

			
			walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);
		}

		if (rc == SQLITE_BUSY) {
			
			rc = SQLITE_OK;
		}
	}

	
	if (rc == SQLITE_OK && eMode != SQLITE_CHECKPOINT_PASSIVE) {
		assert(pWal->writeLock);
		if (pInfo->nBackfill<pWal->hdr.mxFrame) {
			rc = SQLITE_BUSY;
		}
		else if (eMode >= SQLITE_CHECKPOINT_RESTART) {
			u32 salt1;
			sqlite3_randomness(4, &salt1);
			assert(pInfo->nBackfill == pWal->hdr.mxFrame);
			rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER - 1);
			if (rc == SQLITE_OK) {
				if (eMode == SQLITE_CHECKPOINT_TRUNCATE) {
					
					walRestartHdr(pWal, salt1);
					rc = sqlite3OsTruncate(pWal->pWalFd, 0);
				}
				walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER - 1);
			}
		}
	}

walcheckpoint_out:
	walIteratorFree(pIter);
	return rc;
}


static void walLimitSize(Wal *pWal, i64 nMax) {
	i64 sz;
	int rx;
	sqlite3BeginBenignMalloc();
	rx = sqlite3OsFileSize(pWal->pWalFd, &sz);
	if (rx == SQLITE_OK && (sz > nMax)) {
		rx = sqlite3OsTruncate(pWal->pWalFd, nMax);
	}
	sqlite3EndBenignMalloc();
	if (rx) {
		sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);
	}
}


SQLITE_PRIVATE int sqlite3WalClose(
	Wal *pWal,                      
	int sync_flags,                 
	int nBuf,
	u8 *zBuf                        
) {
	int rc = SQLITE_OK;
	if (pWal) {
		int isDelete = 0;             

									  
		rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE);
		if (rc == SQLITE_OK) {
			if (pWal->exclusiveMode == WAL_NORMAL_MODE) {
				pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;
			}
			rc = sqlite3WalCheckpoint(
				pWal, SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0
			);
			if (rc == SQLITE_OK) {
				int bPersist = -1;
				sqlite3OsFileControlHint(
					pWal->pDbFd, SQLITE_FCNTL_PERSIST_WAL, &bPersist
				);
				if (bPersist != 1) {
					
					isDelete = 1;
				}
				else if (pWal->mxWalSize >= 0) {
					
					walLimitSize(pWal, 0);
				}
			}
		}

		walIndexClose(pWal, isDelete);
		sqlite3OsClose(pWal->pWalFd);
		if (isDelete) {
			sqlite3BeginBenignMalloc();
			sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
			sqlite3EndBenignMalloc();
		}
		WALTRACE(("WAL%p: closed\n", pWal));
		sqlite3_free((void *)pWal->apWiData);
		sqlite3_free(pWal);
	}
	return rc;
}


static int walIndexTryHdr(Wal *pWal, int *pChanged) {
	u32 aCksum[2];                  
	WalIndexHdr h1, h2;             
	WalIndexHdr volatile *aHdr;     

									
	assert(pWal->nWiData>0 && pWal->apWiData[0]);

	
	aHdr = walIndexHdr(pWal);
	memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
	walShmBarrier(pWal);
	memcpy(&h2, (void *)&aHdr[1], sizeof(h2));

	if (memcmp(&h1, &h2, sizeof(h1)) != 0) {
		return 1;   
	}
	if (h1.isInit == 0) {
		return 1;   
	}
	walChecksumBytes(1, (u8*)&h1, sizeof(h1) - sizeof(h1.aCksum), 0, aCksum);
	if (aCksum[0] != h1.aCksum[0] || aCksum[1] != h1.aCksum[1]) {
		return 1;   
	}

	if (memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr))) {
		*pChanged = 1;
		memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
		pWal->szPage = (pWal->hdr.szPage & 0xfe00) + ((pWal->hdr.szPage & 0x0001) << 16);
		testcase(pWal->szPage <= 32768);
		testcase(pWal->szPage >= 65536);
	}

	
	return 0;
}


static int walIndexReadHdr(Wal *pWal, int *pChanged) {
	int rc;                         
	int badHdr;                     
	volatile u32 *page0;            

									
	assert(pChanged);
	rc = walIndexPage(pWal, 0, &page0);
	if (rc != SQLITE_OK) {
		return rc;
	};
	assert(page0 || pWal->writeLock == 0);

	
	badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);

	
	assert(badHdr == 0 || pWal->writeLock == 0);
	if (badHdr) {
		if (pWal->readOnly & WAL_SHM_RDONLY) {
			if (SQLITE_OK == (rc = walLockShared(pWal, WAL_WRITE_LOCK))) {
				walUnlockShared(pWal, WAL_WRITE_LOCK);
				rc = SQLITE_READONLY_RECOVERY;
			}
		}
		else if (SQLITE_OK == (rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1))) {
			pWal->writeLock = 1;
			if (SQLITE_OK == (rc = walIndexPage(pWal, 0, &page0))) {
				badHdr = walIndexTryHdr(pWal, pChanged);
				if (badHdr) {
					
					rc = walIndexRecover(pWal);
					*pChanged = 1;
				}
			}
			pWal->writeLock = 0;
			walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
		}
	}

	
	if (badHdr == 0 && pWal->hdr.iVersion != WALINDEX_MAX_VERSION) {
		rc = SQLITE_CANTOPEN_BKPT;
	}

	return rc;
}


#define WAL_RETRY  (-1)


static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt) {
	volatile WalCkptInfo *pInfo;    
	u32 mxReadMark;                 
	int mxI;                        
	int i;                          
	int rc = SQLITE_OK;             
	u32 mxFrame;                    

	assert(pWal->readLock<0);     

								  
	if (cnt>5) {
		int nDelay = 1;                      
		if (cnt>100) {
			VVA_ONLY(pWal->lockError = 1; )
				return SQLITE_PROTOCOL;
		}
		if (cnt >= 10) nDelay = (cnt - 9)*(cnt - 9) * 39;
		sqlite3OsSleep(pWal->pVfs, nDelay);
	}

	if (!useWal) {
		rc = walIndexReadHdr(pWal, pChanged);
		if (rc == SQLITE_BUSY) {
			
			if (pWal->apWiData[0] == 0) {
				
				rc = WAL_RETRY;
			}
			else if (SQLITE_OK == (rc = walLockShared(pWal, WAL_RECOVER_LOCK))) {
				walUnlockShared(pWal, WAL_RECOVER_LOCK);
				rc = WAL_RETRY;
			}
			else if (rc == SQLITE_BUSY) {
				rc = SQLITE_BUSY_RECOVERY;
			}
		}
		if (rc != SQLITE_OK) {
			return rc;
		}
	}

	pInfo = walCkptInfo(pWal);
	if (!useWal && pInfo->nBackfill == pWal->hdr.mxFrame
#ifdef SQLITE_ENABLE_SNAPSHOT
		&& (pWal->pSnapshot == 0 || pWal->hdr.mxFrame == 0
			|| 0 == memcmp(&pWal->hdr, pWal->pSnapshot, sizeof(WalIndexHdr)))
#endif
		) {
		
		rc = walLockShared(pWal, WAL_READ_LOCK(0));
		walShmBarrier(pWal);
		if (rc == SQLITE_OK) {
			if (memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))) {
				
				walUnlockShared(pWal, WAL_READ_LOCK(0));
				return WAL_RETRY;
			}
			pWal->readLock = 0;
			return SQLITE_OK;
		}
		else if (rc != SQLITE_BUSY) {
			return rc;
		}
	}

	
	mxReadMark = 0;
	mxI = 0;
	mxFrame = pWal->hdr.mxFrame;
#ifdef SQLITE_ENABLE_SNAPSHOT
	if (pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame) {
		mxFrame = pWal->pSnapshot->mxFrame;
	}
#endif
	for (i = 1; i<WAL_NREADER; i++) {
		u32 thisMark = pInfo->aReadMark[i];
		if (mxReadMark <= thisMark && thisMark <= mxFrame) {
			assert(thisMark != READMARK_NOT_USED);
			mxReadMark = thisMark;
			mxI = i;
		}
	}
	if ((pWal->readOnly & WAL_SHM_RDONLY) == 0
		&& (mxReadMark<mxFrame || mxI == 0)
		) {
		for (i = 1; i<WAL_NREADER; i++) {
			rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);
			if (rc == SQLITE_OK) {
				mxReadMark = pInfo->aReadMark[i] = mxFrame;
				mxI = i;
				walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
				break;
			}
			else if (rc != SQLITE_BUSY) {
				return rc;
			}
		}
	}
	if (mxI == 0) {
		assert(rc == SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY) != 0);
		return rc == SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTLOCK;
	}

	rc = walLockShared(pWal, WAL_READ_LOCK(mxI));
	if (rc) {
		return rc == SQLITE_BUSY ? WAL_RETRY : rc;
	}
	
	pWal->minFrame = pInfo->nBackfill + 1;
	walShmBarrier(pWal);
	if (pInfo->aReadMark[mxI] != mxReadMark
		|| memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))
		) {
		walUnlockShared(pWal, WAL_READ_LOCK(mxI));
		return WAL_RETRY;
	}
	else {
		assert(mxReadMark <= pWal->hdr.mxFrame);
		pWal->readLock = (i16)mxI;
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged) {
	int rc;                         
	int cnt = 0;                    

#ifdef SQLITE_ENABLE_SNAPSHOT
	int bChanged = 0;
	WalIndexHdr *pSnapshot = pWal->pSnapshot;
	if (pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr)) != 0) {
		bChanged = 1;
	}
#endif

	do {
		rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
	} while (rc == WAL_RETRY);
	testcase((rc & 0xff) == SQLITE_BUSY);
	testcase((rc & 0xff) == SQLITE_IOERR);
	testcase(rc == SQLITE_PROTOCOL);
	testcase(rc == SQLITE_OK);

#ifdef SQLITE_ENABLE_SNAPSHOT
	if (rc == SQLITE_OK) {
		if (pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr)) != 0) {
			
			volatile WalCkptInfo *pInfo = walCkptInfo(pWal);

			assert(pWal->readLock>0 || pWal->hdr.mxFrame == 0);
			assert(pInfo->aReadMark[pWal->readLock] <= pSnapshot->mxFrame);

			
			rc = walLockShared(pWal, WAL_CKPT_LOCK);

			if (rc == SQLITE_OK) {
				
				if (!memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))
					&& pSnapshot->mxFrame >= pInfo->nBackfillAttempted
					) {
					assert(pWal->readLock>0);
					memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));
					*pChanged = bChanged;
				}
				else {
					rc = SQLITE_BUSY_SNAPSHOT;
				}

				
				walUnlockShared(pWal, WAL_CKPT_LOCK);
			}


			if (rc != SQLITE_OK) {
				sqlite3WalEndReadTransaction(pWal);
			}
		}
	}
#endif
	return rc;
}


SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal) {
	sqlite3WalEndWriteTransaction(pWal);
	if (pWal->readLock >= 0) {
		walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));
		pWal->readLock = -1;
	}
}


SQLITE_PRIVATE int sqlite3WalFindFrame(
	Wal *pWal,                      
	Pgno pgno,                      
	u32 *piRead                     
) {
	u32 iRead = 0;                  
	u32 iLast = pWal->hdr.mxFrame;  
	int iHash;                      
	int iMinHash;

	
	assert(pWal->readLock >= 0 || pWal->lockError);

	
	if (iLast == 0 || pWal->readLock == 0) {
		*piRead = 0;
		return SQLITE_OK;
	}

	
	iMinHash = walFramePage(pWal->minFrame);
	for (iHash = walFramePage(iLast); iHash >= iMinHash && iRead == 0; iHash--) {
		volatile ht_slot *aHash;      
		volatile u32 *aPgno;          
		u32 iZero;                    
		int iKey;                     
		int nCollide;                 
		int rc;                       

		rc = walHashGet(pWal, iHash, &aHash, &aPgno, &iZero);
		if (rc != SQLITE_OK) {
			return rc;
		}
		nCollide = HASHTABLE_NSLOT;
		for (iKey = walHash(pgno); aHash[iKey]; iKey = walNextHash(iKey)) {
			u32 iFrame = aHash[iKey] + iZero;
			if (iFrame <= iLast && iFrame >= pWal->minFrame && aPgno[aHash[iKey]] == pgno) {
				assert(iFrame>iRead || CORRUPT_DB);
				iRead = iFrame;
			}
			if ((nCollide--) == 0) {
				return SQLITE_CORRUPT_BKPT;
			}
		}
	}

#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
	
	{
		u32 iRead2 = 0;
		u32 iTest;
		assert(pWal->minFrame>0);
		for (iTest = iLast; iTest >= pWal->minFrame; iTest--) {
			if (walFramePgno(pWal, iTest) == pgno) {
				iRead2 = iTest;
				break;
			}
		}
		assert(iRead == iRead2);
	}
#endif

	*piRead = iRead;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3WalReadFrame(
	Wal *pWal,                      
	u32 iRead,                      
	int nOut,                       
	u8 *pOut                        
) {
	int sz;
	i64 iOffset;
	sz = pWal->hdr.szPage;
	sz = (sz & 0xfe00) + ((sz & 0x0001) << 16);
	testcase(sz <= 32768);
	testcase(sz >= 65536);
	iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;
	
	return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);
}


SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal) {
	if (pWal && ALWAYS(pWal->readLock >= 0)) {
		return pWal->hdr.nPage;
	}
	return 0;
}



SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal) {
	int rc;

	
	assert(pWal->readLock >= 0);
	assert(pWal->writeLock == 0 && pWal->iReCksum == 0);

	if (pWal->readOnly) {
		return SQLITE_READONLY;
	}

	
	rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
	if (rc) {
		return rc;
	}
	pWal->writeLock = 1;

	
	if (memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr)) != 0) {
		walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
		pWal->writeLock = 0;
		rc = SQLITE_BUSY_SNAPSHOT;
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal) {
	if (pWal->writeLock) {
		walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
		pWal->writeLock = 0;
		pWal->iReCksum = 0;
		pWal->truncateOnCommit = 0;
	}
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int(*xUndo)(void *, Pgno), void *pUndoCtx) {
	int rc = SQLITE_OK;
	if (ALWAYS(pWal->writeLock)) {
		Pgno iMax = pWal->hdr.mxFrame;
		Pgno iFrame;

		
		memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));

		for (iFrame = pWal->hdr.mxFrame + 1;
			ALWAYS(rc == SQLITE_OK) && iFrame <= iMax;
			iFrame++
			) {
			
			assert(walFramePgno(pWal, iFrame) != 1);
			rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));
		}
		if (iMax != pWal->hdr.mxFrame) walCleanupHash(pWal);
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData) {
	assert(pWal->writeLock);
	aWalData[0] = pWal->hdr.mxFrame;
	aWalData[1] = pWal->hdr.aFrameCksum[0];
	aWalData[2] = pWal->hdr.aFrameCksum[1];
	aWalData[3] = pWal->nCkpt;
}


SQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData) {
	int rc = SQLITE_OK;

	assert(pWal->writeLock);
	assert(aWalData[3] != pWal->nCkpt || aWalData[0] <= pWal->hdr.mxFrame);

	if (aWalData[3] != pWal->nCkpt) {
		
		aWalData[0] = 0;
		aWalData[3] = pWal->nCkpt;
	}

	if (aWalData[0]<pWal->hdr.mxFrame) {
		pWal->hdr.mxFrame = aWalData[0];
		pWal->hdr.aFrameCksum[0] = aWalData[1];
		pWal->hdr.aFrameCksum[1] = aWalData[2];
		walCleanupHash(pWal);
	}

	return rc;
}


static int walRestartLog(Wal *pWal) {
	int rc = SQLITE_OK;
	int cnt;

	if (pWal->readLock == 0) {
		volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
		assert(pInfo->nBackfill == pWal->hdr.mxFrame);
		if (pInfo->nBackfill>0) {
			u32 salt1;
			sqlite3_randomness(4, &salt1);
			rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER - 1);
			if (rc == SQLITE_OK) {
				
				walRestartHdr(pWal, salt1);
				walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER - 1);
			}
			else if (rc != SQLITE_BUSY) {
				return rc;
			}
		}
		walUnlockShared(pWal, WAL_READ_LOCK(0));
		pWal->readLock = -1;
		cnt = 0;
		do {
			int notUsed;
			rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);
		} while (rc == WAL_RETRY);
		assert((rc & 0xff) != SQLITE_BUSY); 
		testcase((rc & 0xff) == SQLITE_IOERR);
		testcase(rc == SQLITE_PROTOCOL);
		testcase(rc == SQLITE_OK);
	}
	return rc;
}


typedef struct WalWriter {
	Wal *pWal;                   
	sqlite3_file *pFd;           
	sqlite3_int64 iSyncPoint;    
	int syncFlags;               
	int szPage;                  
} WalWriter;


static int walWriteToLog(
	WalWriter *p,              
	void *pContent,            
	int iAmt,                  
	sqlite3_int64 iOffset      
) {
	int rc;
	if (iOffset<p->iSyncPoint && iOffset + iAmt >= p->iSyncPoint) {
		int iFirstAmt = (int)(p->iSyncPoint - iOffset);
		rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);
		if (rc) return rc;
		iOffset += iFirstAmt;
		iAmt -= iFirstAmt;
		pContent = (void*)(iFirstAmt + (char*)pContent);
		assert(p->syncFlags & (SQLITE_SYNC_NORMAL | SQLITE_SYNC_FULL));
		rc = sqlite3OsSync(p->pFd, p->syncFlags & SQLITE_SYNC_MASK);
		if (iAmt == 0 || rc) return rc;
	}
	rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);
	return rc;
}


static int walWriteOneFrame(
	WalWriter *p,               
	PgHdr *pPage,               
	int nTruncate,              
	sqlite3_int64 iOffset       
) {
	int rc;                         
	void *pData;                    
	u8 aFrame[WAL_FRAME_HDRSIZE];   
#if defined(SQLITE_HAS_CODEC)
	if ((pData = sqlite3PagerCodec(pPage)) == 0) return SQLITE_NOMEM_BKPT;
#else
	pData = pPage->pData;
#endif
	walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);
	rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);
	if (rc) return rc;
	
	rc = walWriteToLog(p, pData, p->szPage, iOffset + sizeof(aFrame));
	return rc;
}


static int walRewriteChecksums(Wal *pWal, u32 iLast) {
	const int szPage = pWal->szPage;
	int rc = SQLITE_OK;             
	u8 *aBuf;                       
	u8 aFrame[WAL_FRAME_HDRSIZE];   
	u32 iRead;                      
	i64 iCksumOff;

	aBuf = sqlite3_malloc(szPage + WAL_FRAME_HDRSIZE);
	if (aBuf == 0) return SQLITE_NOMEM_BKPT;

	
	assert(pWal->iReCksum>0);
	if (pWal->iReCksum == 1) {
		iCksumOff = 24;
	}
	else {
		iCksumOff = walFrameOffset(pWal->iReCksum - 1, szPage) + 16;
	}
	rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32) * 2, iCksumOff);
	pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);
	pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);

	iRead = pWal->iReCksum;
	pWal->iReCksum = 0;
	for (; rc == SQLITE_OK && iRead <= iLast; iRead++) {
		i64 iOff = walFrameOffset(iRead, szPage);
		rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage + WAL_FRAME_HDRSIZE, iOff);
		if (rc == SQLITE_OK) {
			u32 iPgno, nDbSize;
			iPgno = sqlite3Get4byte(aBuf);
			nDbSize = sqlite3Get4byte(&aBuf[4]);

			walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[WAL_FRAME_HDRSIZE], aFrame);
			rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);
		}
	}

	sqlite3_free(aBuf);
	return rc;
}


SQLITE_PRIVATE int sqlite3WalFrames(
	Wal *pWal,                      
	int szPage,                     
	PgHdr *pList,                   
	Pgno nTruncate,                 
	int isCommit,                   
	int sync_flags                  
) {
	int rc;                         
	u32 iFrame;                     
	PgHdr *p;                       
	PgHdr *pLast = 0;               
	int nExtra = 0;                 
	int szFrame;                    
	i64 iOffset;                    
	WalWriter w;                    
	u32 iFirst = 0;                 
	WalIndexHdr *pLive;             

	assert(pList);
	assert(pWal->writeLock);

	
	assert((isCommit != 0) == (nTruncate != 0));

#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
	{ int cnt; for (cnt = 0, p = pList; p; p = p->pDirty, cnt++) {}
	WALTRACE(("WAL%p: frame write begin. %d frames. mxFrame=%d. %s\n",
		pWal, cnt, pWal->hdr.mxFrame, isCommit ? "Commit" : "Spill"));
	}
#endif

	pLive = (WalIndexHdr*)walIndexHdr(pWal);
	if (memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr)) != 0) {
		iFirst = pLive->mxFrame + 1;
	}

	
	if (SQLITE_OK != (rc = walRestartLog(pWal))) {
		return rc;
	}

	
	iFrame = pWal->hdr.mxFrame;
	if (iFrame == 0) {
		u8 aWalHdr[WAL_HDRSIZE];      
		u32 aCksum[2];                

		sqlite3Put4byte(&aWalHdr[0], (WAL_MAGIC | SQLITE_BIGENDIAN));
		sqlite3Put4byte(&aWalHdr[4], WAL_MAX_VERSION);
		sqlite3Put4byte(&aWalHdr[8], szPage);
		sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);
		if (pWal->nCkpt == 0) sqlite3_randomness(8, pWal->hdr.aSalt);
		memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
		walChecksumBytes(1, aWalHdr, WAL_HDRSIZE - 2 * 4, 0, aCksum);
		sqlite3Put4byte(&aWalHdr[24], aCksum[0]);
		sqlite3Put4byte(&aWalHdr[28], aCksum[1]);

		pWal->szPage = szPage;
		pWal->hdr.bigEndCksum = SQLITE_BIGENDIAN;
		pWal->hdr.aFrameCksum[0] = aCksum[0];
		pWal->hdr.aFrameCksum[1] = aCksum[1];
		pWal->truncateOnCommit = 1;

		rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);
		WALTRACE(("WAL%p: wal-header write %s\n", pWal, rc ? "failed" : "ok"));
		if (rc != SQLITE_OK) {
			return rc;
		}

		
		if (pWal->syncHeader && sync_flags) {
			rc = sqlite3OsSync(pWal->pWalFd, sync_flags & SQLITE_SYNC_MASK);
			if (rc) return rc;
		}
	}
	assert((int)pWal->szPage == szPage);

	
	w.pWal = pWal;
	w.pFd = pWal->pWalFd;
	w.iSyncPoint = 0;
	w.syncFlags = sync_flags;
	w.szPage = szPage;
	iOffset = walFrameOffset(iFrame + 1, szPage);
	szFrame = szPage + WAL_FRAME_HDRSIZE;

	
	for (p = pList; p; p = p->pDirty) {
		int nDbSize;   

					   
		if (iFirst && (p->pDirty || isCommit == 0)) {
			u32 iWrite = 0;
			VVA_ONLY(rc = ) sqlite3WalFindFrame(pWal, p->pgno, &iWrite);
			assert(rc == SQLITE_OK || iWrite == 0);
			if (iWrite >= iFirst) {
				i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;
				void *pData;
				if (pWal->iReCksum == 0 || iWrite<pWal->iReCksum) {
					pWal->iReCksum = iWrite;
				}
#if defined(SQLITE_HAS_CODEC)
				if ((pData = sqlite3PagerCodec(p)) == 0) return SQLITE_NOMEM;
#else
				pData = p->pData;
#endif
				rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);
				if (rc) return rc;
				p->flags &= ~PGHDR_WAL_APPEND;
				continue;
			}
		}

		iFrame++;
		assert(iOffset == walFrameOffset(iFrame, szPage));
		nDbSize = (isCommit && p->pDirty == 0) ? nTruncate : 0;
		rc = walWriteOneFrame(&w, p, nDbSize, iOffset);
		if (rc) return rc;
		pLast = p;
		iOffset += szFrame;
		p->flags |= PGHDR_WAL_APPEND;
	}

	
	if (isCommit && pWal->iReCksum) {
		rc = walRewriteChecksums(pWal, iFrame);
		if (rc) return rc;
	}

	
	if (isCommit && (sync_flags & WAL_SYNC_TRANSACTIONS) != 0) {
		int bSync = 1;
		if (pWal->padToSectorBoundary) {
			int sectorSize = sqlite3SectorSize(pWal->pWalFd);
			w.iSyncPoint = ((iOffset + sectorSize - 1) / sectorSize)*sectorSize;
			bSync = (w.iSyncPoint == iOffset);
			testcase(bSync);
			while (iOffset<w.iSyncPoint) {
				rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);
				if (rc) return rc;
				iOffset += szFrame;
				nExtra++;
			}
		}
		if (bSync) {
			assert(rc == SQLITE_OK);
			rc = sqlite3OsSync(w.pFd, sync_flags & SQLITE_SYNC_MASK);
		}
	}

	
	if (isCommit && pWal->truncateOnCommit && pWal->mxWalSize >= 0) {
		i64 sz = pWal->mxWalSize;
		if (walFrameOffset(iFrame + nExtra + 1, szPage)>pWal->mxWalSize) {
			sz = walFrameOffset(iFrame + nExtra + 1, szPage);
		}
		walLimitSize(pWal, sz);
		pWal->truncateOnCommit = 0;
	}

	
	iFrame = pWal->hdr.mxFrame;
	for (p = pList; p && rc == SQLITE_OK; p = p->pDirty) {
		if ((p->flags & PGHDR_WAL_APPEND) == 0) continue;
		iFrame++;
		rc = walIndexAppend(pWal, iFrame, p->pgno);
	}
	while (rc == SQLITE_OK && nExtra>0) {
		iFrame++;
		nExtra--;
		rc = walIndexAppend(pWal, iFrame, pLast->pgno);
	}

	if (rc == SQLITE_OK) {
		
		pWal->hdr.szPage = (u16)((szPage & 0xff00) | (szPage >> 16));
		testcase(szPage <= 32768);
		testcase(szPage >= 65536);
		pWal->hdr.mxFrame = iFrame;
		if (isCommit) {
			pWal->hdr.iChange++;
			pWal->hdr.nPage = nTruncate;
		}
		
		if (isCommit) {
			walIndexWriteHdr(pWal);
			pWal->iCallback = iFrame;
		}
	}

	WALTRACE(("WAL%p: frame write %s\n", pWal, rc ? "failed" : "ok"));
	return rc;
}


SQLITE_PRIVATE int sqlite3WalCheckpoint(
	Wal *pWal,                      
	int eMode,                      
	int(*xBusy)(void*),            
	void *pBusyArg,                 
	int sync_flags,                 
	int nBuf,                       
	u8 *zBuf,                       
	int *pnLog,                     
	int *pnCkpt                     
) {
	int rc;                         
	int isChanged = 0;              
	int eMode2 = eMode;             
	int(*xBusy2)(void*) = xBusy;   

	assert(pWal->ckptLock == 0);
	assert(pWal->writeLock == 0);

	
	assert(eMode != SQLITE_CHECKPOINT_PASSIVE || xBusy == 0);

	if (pWal->readOnly) return SQLITE_READONLY;
	WALTRACE(("WAL%p: checkpoint begins\n", pWal));

	
	rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);
	if (rc) {
		
		testcase(rc == SQLITE_BUSY);
		testcase(xBusy != 0);
		return rc;
	}
	pWal->ckptLock = 1;

	
	if (eMode != SQLITE_CHECKPOINT_PASSIVE) {
		rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_WRITE_LOCK, 1);
		if (rc == SQLITE_OK) {
			pWal->writeLock = 1;
		}
		else if (rc == SQLITE_BUSY) {
			eMode2 = SQLITE_CHECKPOINT_PASSIVE;
			xBusy2 = 0;
			rc = SQLITE_OK;
		}
	}

	
	if (rc == SQLITE_OK) {
		rc = walIndexReadHdr(pWal, &isChanged);
		if (isChanged && pWal->pDbFd->pMethods->iVersion >= 3) {
			sqlite3OsUnfetch(pWal->pDbFd, 0, 0);
		}
	}

	
	if (rc == SQLITE_OK) {

		if (pWal->hdr.mxFrame && walPagesize(pWal) != nBuf) {
			rc = SQLITE_CORRUPT_BKPT;
		}
		else {
			rc = walCheckpoint(pWal, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);
		}

		
		if (rc == SQLITE_OK || rc == SQLITE_BUSY) {
			if (pnLog) *pnLog = (int)pWal->hdr.mxFrame;
			if (pnCkpt) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);
		}
	}

	if (isChanged) {
		
		memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
	}

	
	sqlite3WalEndWriteTransaction(pWal);
	walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);
	pWal->ckptLock = 0;
	WALTRACE(("WAL%p: checkpoint %s\n", pWal, rc ? "failed" : "ok"));
	return (rc == SQLITE_OK && eMode != eMode2 ? SQLITE_BUSY : rc);
}


SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal) {
	u32 ret = 0;
	if (pWal) {
		ret = pWal->iCallback;
		pWal->iCallback = 0;
	}
	return (int)ret;
}


SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op) {
	int rc;
	assert(pWal->writeLock == 0);
	assert(pWal->exclusiveMode != WAL_HEAPMEMORY_MODE || op == -1);

	
	assert(pWal->readLock >= 0 || pWal->lockError);
	assert(pWal->readLock >= 0 || (op <= 0 && pWal->exclusiveMode == 0));

	if (op == 0) {
		if (pWal->exclusiveMode) {
			pWal->exclusiveMode = 0;
			if (walLockShared(pWal, WAL_READ_LOCK(pWal->readLock)) != SQLITE_OK) {
				pWal->exclusiveMode = 1;
			}
			rc = pWal->exclusiveMode == 0;
		}
		else {
			
			rc = 0;
		}
	}
	else if (op>0) {
		assert(pWal->exclusiveMode == 0);
		assert(pWal->readLock >= 0);
		walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));
		pWal->exclusiveMode = 1;
		rc = 1;
	}
	else {
		rc = pWal->exclusiveMode == 0;
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal) {
	return (pWal && pWal->exclusiveMode == WAL_HEAPMEMORY_MODE);
}

#ifdef SQLITE_ENABLE_SNAPSHOT

SQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot) {
	int rc = SQLITE_OK;
	WalIndexHdr *pRet;

	assert(pWal->readLock >= 0 && pWal->writeLock == 0);

	pRet = (WalIndexHdr*)sqlite3_malloc(sizeof(WalIndexHdr));
	if (pRet == 0) {
		rc = SQLITE_NOMEM_BKPT;
	}
	else {
		memcpy(pRet, &pWal->hdr, sizeof(WalIndexHdr));
		*ppSnapshot = (sqlite3_snapshot*)pRet;
	}

	return rc;
}


SQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot) {
	pWal->pSnapshot = (WalIndexHdr*)pSnapshot;
}


SQLITE_API int sqlite3_snapshot_cmp(sqlite3_snapshot *p1, sqlite3_snapshot *p2) {
	WalIndexHdr *pHdr1 = (WalIndexHdr*)p1;
	WalIndexHdr *pHdr2 = (WalIndexHdr*)p2;

	
	if (pHdr1->aSalt[0]<pHdr2->aSalt[0]) return -1;
	if (pHdr1->aSalt[0]>pHdr2->aSalt[0]) return +1;
	if (pHdr1->mxFrame<pHdr2->mxFrame) return -1;
	if (pHdr1->mxFrame>pHdr2->mxFrame) return +1;
	return 0;
}
#endif 

#ifdef SQLITE_ENABLE_ZIPVFS

SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal) {
	assert(pWal == 0 || pWal->readLock >= 0);
	return (pWal ? pWal->szPage : 0);
}
#endif


SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal) {
	return pWal->pWalFd;
}

#endif 











#define MX_CELL_SIZE(pBt)  ((int)(pBt->pageSize-8))


#define MX_CELL(pBt) ((pBt->pageSize-8)/6)


typedef struct MemPage MemPage;
typedef struct BtLock BtLock;
typedef struct CellInfo CellInfo;


#ifndef SQLITE_FILE_HEADER 
#  define SQLITE_FILE_HEADER "SQLite format 3"
#endif


#define PTF_INTKEY    0x01
#define PTF_ZERODATA  0x02
#define PTF_LEAFDATA  0x04
#define PTF_LEAF      0x08


struct MemPage {
	u8 isInit;           
	u8 nOverflow;        
	u8 intKey;           
	u8 intKeyLeaf;       
	u8 leaf;             
	u8 hdrOffset;        
	u8 childPtrSize;     
	u8 max1bytePayload;  
	u8 bBusy;            
	u16 maxLocal;        
	u16 minLocal;        
	u16 cellOffset;      
	u16 nFree;           
	u16 nCell;           
	u16 maskPage;        
	u16 aiOvfl[5];       
	u8 *apOvfl[5];       
	BtShared *pBt;       
	u8 *aData;           
	u8 *aDataEnd;        
	u8 *aCellIdx;        
	u8 *aDataOfst;       
	DbPage *pDbPage;     
	u16(*xCellSize)(MemPage*, u8*);             
	void(*xParseCell)(MemPage*, u8*, CellInfo*); 
	Pgno pgno;           
};


#define EXTRA_SIZE sizeof(MemPage)


struct BtLock {
	Btree *pBtree;        
	Pgno iTable;          
	u8 eLock;             
	BtLock *pNext;        
};


#define READ_LOCK     1
#define WRITE_LOCK    2


struct Btree {
	sqlite3 *db;       
	BtShared *pBt;     
	u8 inTrans;        
	u8 sharable;       
	u8 locked;         
	u8 hasIncrblobCur; 
	int wantToLock;    
	int nBackup;       
	u32 iDataVersion;  
	Btree *pNext;      
	Btree *pPrev;      
#ifndef SQLITE_OMIT_SHARED_CACHE
	BtLock lock;       
#endif
};


#define TRANS_NONE  0
#define TRANS_READ  1
#define TRANS_WRITE 2


struct BtShared {
	Pager *pPager;        
	sqlite3 *db;          
	BtCursor *pCursor;    
	MemPage *pPage1;      
	u8 openFlags;         
#ifndef SQLITE_OMIT_AUTOVACUUM
	u8 autoVacuum;        
	u8 incrVacuum;        
	u8 bDoTruncate;       
#endif
	u8 inTransaction;     
	u8 max1bytePayload;   
#ifdef SQLITE_HAS_CODEC
	u8 optimalReserve;    
#endif
	u16 btsFlags;         
	u16 maxLocal;         
	u16 minLocal;         
	u16 maxLeaf;          
	u16 minLeaf;          
	u32 pageSize;         
	u32 usableSize;       
	int nTransaction;     
	u32 nPage;            
	void *pSchema;        
	void(*xFreeSchema)(void*);  
	sqlite3_mutex *mutex; 
	Bitvec *pHasContent;  
#ifndef SQLITE_OMIT_SHARED_CACHE
	int nRef;             
	BtShared *pNext;      
	BtLock *pLock;        
	Btree *pWriter;       
#endif
	u8 *pTmpSpace;        
};


#define BTS_READ_ONLY        0x0001   
#define BTS_PAGESIZE_FIXED   0x0002   
#define BTS_SECURE_DELETE    0x0004   
#define BTS_INITIALLY_EMPTY  0x0008   
#define BTS_NO_WAL           0x0010   
#define BTS_EXCLUSIVE        0x0020   
#define BTS_PENDING          0x0040   


struct CellInfo {
	i64 nKey;      
	u8 *pPayload;  
	u32 nPayload;  
	u16 nLocal;    
	u16 nSize;     
};


#define BTCURSOR_MAX_DEPTH 20


struct BtCursor {
	Btree *pBtree;            
	BtShared *pBt;            
	BtCursor *pNext;          
	Pgno *aOverflow;          
	CellInfo info;            
	i64 nKey;                 
	void *pKey;               
	Pgno pgnoRoot;            
	int nOvflAlloc;           
	int skipNext;    
	u8 curFlags;              
	u8 curPagerFlags;         
	u8 eState;                
	u8 hints;                 
							  
	i8 iPage;                 
	u8 curIntKey;             
	struct KeyInfo *pKeyInfo; 
	void *padding1;           
	u16 aiIdx[BTCURSOR_MAX_DEPTH];        
	MemPage *apPage[BTCURSOR_MAX_DEPTH];  
};


#define BTCF_WriteFlag    0x01   
#define BTCF_ValidNKey    0x02   
#define BTCF_ValidOvfl    0x04   
#define BTCF_AtLast       0x08   
#define BTCF_Incrblob     0x10   
#define BTCF_Multiple     0x20   


#define CURSOR_INVALID           0
#define CURSOR_VALID             1
#define CURSOR_SKIPNEXT          2
#define CURSOR_REQUIRESEEK       3
#define CURSOR_FAULT             4


# define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)


#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)
#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1))
#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))


#define PTRMAP_ROOTPAGE 1
#define PTRMAP_FREEPAGE 2
#define PTRMAP_OVERFLOW1 3
#define PTRMAP_OVERFLOW2 4
#define PTRMAP_BTREE 5


#define btreeIntegrity(p) \
  assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); \
  assert( p->pBt->inTransaction>=p->inTrans ); 



#ifndef SQLITE_OMIT_AUTOVACUUM
#define ISAUTOVACUUM (pBt->autoVacuum)
#else
#define ISAUTOVACUUM 0
#endif



typedef struct IntegrityCk IntegrityCk;
struct IntegrityCk {
	BtShared *pBt;    
	Pager *pPager;    
	u8 *aPgRef;       
	Pgno nPage;       
	int mxErr;        
	int nErr;         
	int mallocFailed; 
	const char *zPfx; 
	int v1, v2;       
	StrAccum errMsg;  
	u32 *heap;        
};


#define get2byte(x)   ((x)[0]<<8 | (x)[1])
#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))
#define get4byte sqlite3Get4byte
#define put4byte sqlite3Put4byte


#if SQLITE_BYTEORDER==4321
# define get2byteAligned(x)  (*(u16*)(x))
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && GCC_VERSION>=4008000
# define get2byteAligned(x)  __builtin_bswap16(*(u16*)(x))
#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
    && defined(_MSC_VER) && _MSC_VER>=1300
# define get2byteAligned(x)  _byteswap_ushort(*(u16*)(x))
#else
# define get2byteAligned(x)  ((x)[0]<<8 | (x)[1])
#endif



#ifndef SQLITE_OMIT_SHARED_CACHE
#if SQLITE_THREADSAFE


static void lockBtreeMutex(Btree *p) {
	assert(p->locked == 0);
	assert(sqlite3_mutex_notheld(p->pBt->mutex));
	assert(sqlite3_mutex_held(p->db->mutex));

	sqlite3_mutex_enter(p->pBt->mutex);
	p->pBt->db = p->db;
	p->locked = 1;
}


static void SQLITE_NOINLINE unlockBtreeMutex(Btree *p) {
	BtShared *pBt = p->pBt;
	assert(p->locked == 1);
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(sqlite3_mutex_held(p->db->mutex));
	assert(p->db == pBt->db);

	sqlite3_mutex_leave(pBt->mutex);
	p->locked = 0;
}


static void SQLITE_NOINLINE btreeLockCarefully(Btree *p);


SQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p) {
	
	assert(p->pNext == 0 || p->pNext->pBt>p->pBt);
	assert(p->pPrev == 0 || p->pPrev->pBt<p->pBt);
	assert(p->pNext == 0 || p->pNext->db == p->db);
	assert(p->pPrev == 0 || p->pPrev->db == p->db);
	assert(p->sharable || (p->pNext == 0 && p->pPrev == 0));

	
	assert(!p->locked || p->wantToLock>0);
	assert(p->sharable || p->wantToLock == 0);

	
	assert(sqlite3_mutex_held(p->db->mutex));

	
	assert((p->locked == 0 && p->sharable) || p->pBt->db == p->db);

	if (!p->sharable) return;
	p->wantToLock++;
	if (p->locked) return;
	btreeLockCarefully(p);
}


static void SQLITE_NOINLINE btreeLockCarefully(Btree *p) {
	Btree *pLater;

	
	if (sqlite3_mutex_try(p->pBt->mutex) == SQLITE_OK) {
		p->pBt->db = p->db;
		p->locked = 1;
		return;
	}

	
	for (pLater = p->pNext; pLater; pLater = pLater->pNext) {
		assert(pLater->sharable);
		assert(pLater->pNext == 0 || pLater->pNext->pBt>pLater->pBt);
		assert(!pLater->locked || pLater->wantToLock>0);
		if (pLater->locked) {
			unlockBtreeMutex(pLater);
		}
	}
	lockBtreeMutex(p);
	for (pLater = p->pNext; pLater; pLater = pLater->pNext) {
		if (pLater->wantToLock) {
			lockBtreeMutex(pLater);
		}
	}
}



SQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p) {
	assert(sqlite3_mutex_held(p->db->mutex));
	if (p->sharable) {
		assert(p->wantToLock>0);
		p->wantToLock--;
		if (p->wantToLock == 0) {
			unlockBtreeMutex(p);
		}
	}
}

#ifndef NDEBUG

SQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree *p) {
	assert(p->sharable == 0 || p->locked == 0 || p->wantToLock>0);
	assert(p->sharable == 0 || p->locked == 0 || p->db == p->pBt->db);
	assert(p->sharable == 0 || p->locked == 0 || sqlite3_mutex_held(p->pBt->mutex));
	assert(p->sharable == 0 || p->locked == 0 || sqlite3_mutex_held(p->db->mutex));

	return (p->sharable == 0 || p->locked);
}
#endif



SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db) {
	int i;
	Btree *p;
	assert(sqlite3_mutex_held(db->mutex));
	for (i = 0; i<db->nDb; i++) {
		p = db->aDb[i].pBt;
		if (p) sqlite3BtreeEnter(p);
	}
}
SQLITE_PRIVATE void sqlite3BtreeLeaveAll(sqlite3 *db) {
	int i;
	Btree *p;
	assert(sqlite3_mutex_held(db->mutex));
	for (i = 0; i<db->nDb; i++) {
		p = db->aDb[i].pBt;
		if (p) sqlite3BtreeLeave(p);
	}
}

#ifndef NDEBUG

SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3 *db) {
	int i;
	if (!sqlite3_mutex_held(db->mutex)) {
		return 0;
	}
	for (i = 0; i<db->nDb; i++) {
		Btree *p;
		p = db->aDb[i].pBt;
		if (p && p->sharable &&
			(p->wantToLock == 0 || !sqlite3_mutex_held(p->pBt->mutex))) {
			return 0;
		}
	}
	return 1;
}
#endif 

#ifndef NDEBUG

SQLITE_PRIVATE int sqlite3SchemaMutexHeld(sqlite3 *db, int iDb, Schema *pSchema) {
	Btree *p;
	assert(db != 0);
	if (pSchema) iDb = sqlite3SchemaToIndex(db, pSchema);
	assert(iDb >= 0 && iDb<db->nDb);
	if (!sqlite3_mutex_held(db->mutex)) return 0;
	if (iDb == 1) return 1;
	p = db->aDb[iDb].pBt;
	assert(p != 0);
	return p->sharable == 0 || p->locked == 1;
}
#endif 

#else 


SQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p) {
	p->pBt->db = p->db;
}
SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db) {
	int i;
	for (i = 0; i<db->nDb; i++) {
		Btree *p = db->aDb[i].pBt;
		if (p) {
			p->pBt->db = p->db;
		}
	}
}
#endif 

#ifndef SQLITE_OMIT_INCRBLOB

SQLITE_PRIVATE void sqlite3BtreeEnterCursor(BtCursor *pCur) {
	sqlite3BtreeEnter(pCur->pBtree);
}
# if SQLITE_THREADSAFE
SQLITE_PRIVATE void sqlite3BtreeLeaveCursor(BtCursor *pCur) {
	sqlite3BtreeLeave(pCur->pBtree);
}
# endif
#endif 

#endif 







static const char zMagicHeader[] = SQLITE_FILE_HEADER;


#if 0
int sqlite3BtreeTrace = 1;  
# define TRACE(X)  if(sqlite3BtreeTrace){printf X;fflush(stdout);}
#else
# define TRACE(X)
#endif


#define get2byteNotZero(X)  (((((int)get2byte(X))-1)&0xffff)+1)


#define BTALLOC_ANY   0           
#define BTALLOC_EXACT 1           
#define BTALLOC_LE    2           


#ifndef SQLITE_OMIT_AUTOVACUUM
#define IfNotOmitAV(expr) (expr)
#else
#define IfNotOmitAV(expr) 0
#endif

#ifndef SQLITE_OMIT_SHARED_CACHE

#ifdef SQLITE_TEST
SQLITE_PRIVATE BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;
#else
static BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;
#endif
#endif 

#ifndef SQLITE_OMIT_SHARED_CACHE

SQLITE_API int sqlite3_enable_shared_cache(int enable) {
	sqlite3GlobalConfig.sharedCacheEnabled = enable;
	return SQLITE_OK;
}
#endif



#ifdef SQLITE_OMIT_SHARED_CACHE

#define querySharedCacheTableLock(a,b,c) SQLITE_OK
#define setSharedCacheTableLock(a,b,c) SQLITE_OK
#define clearAllSharedCacheTableLocks(a)
#define downgradeAllSharedCacheTableLocks(a)
#define hasSharedCacheTableLock(a,b,c,d) 1
#define hasReadConflicts(a, b) 0
#endif

#ifndef SQLITE_OMIT_SHARED_CACHE

#ifdef SQLITE_DEBUG

static int hasSharedCacheTableLock(
	Btree *pBtree,         
	Pgno iRoot,            
	int isIndex,           
	int eLockType          
) {
	Schema *pSchema = (Schema *)pBtree->pBt->pSchema;
	Pgno iTab = 0;
	BtLock *pLock;

	
	if ((pBtree->sharable == 0)
		|| (eLockType == READ_LOCK && (pBtree->db->flags & SQLITE_ReadUncommitted))
		) {
		return 1;
	}

	
	if (isIndex && (!pSchema || (pSchema->schemaFlags&DB_SchemaLoaded) == 0)) {
		return 1;
	}

	
	if (isIndex) {
		HashElem *p;
		for (p = sqliteHashFirst(&pSchema->idxHash); p; p = sqliteHashNext(p)) {
			Index *pIdx = (Index *)sqliteHashData(p);
			if (pIdx->tnum == (int)iRoot) {
				if (iTab) {
					
					return 1;
				}
				iTab = pIdx->pTable->tnum;
			}
		}
	}
	else {
		iTab = iRoot;
	}

	
	for (pLock = pBtree->pBt->pLock; pLock; pLock = pLock->pNext) {
		if (pLock->pBtree == pBtree
			&& (pLock->iTable == iTab || (pLock->eLock == WRITE_LOCK && pLock->iTable == 1))
			&& pLock->eLock >= eLockType
			) {
			return 1;
		}
	}

	
	return 0;
}
#endif 

#ifdef SQLITE_DEBUG

static int hasReadConflicts(Btree *pBtree, Pgno iRoot) {
	BtCursor *p;
	for (p = pBtree->pBt->pCursor; p; p = p->pNext) {
		if (p->pgnoRoot == iRoot
			&& p->pBtree != pBtree
			&& 0 == (p->pBtree->db->flags & SQLITE_ReadUncommitted)
			) {
			return 1;
		}
	}
	return 0;
}
#endif    


static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock) {
	BtShared *pBt = p->pBt;
	BtLock *pIter;

	assert(sqlite3BtreeHoldsMutex(p));
	assert(eLock == READ_LOCK || eLock == WRITE_LOCK);
	assert(p->db != 0);
	assert(!(p->db->flags&SQLITE_ReadUncommitted) || eLock == WRITE_LOCK || iTab == 1);

	
	assert(eLock == READ_LOCK || (p == pBt->pWriter && p->inTrans == TRANS_WRITE));
	assert(eLock == READ_LOCK || pBt->inTransaction == TRANS_WRITE);

	
	if (!p->sharable) {
		return SQLITE_OK;
	}

	
	if (pBt->pWriter != p && (pBt->btsFlags & BTS_EXCLUSIVE) != 0) {
		sqlite3ConnectionBlocked(p->db, pBt->pWriter->db);
		return SQLITE_LOCKED_SHAREDCACHE;
	}

	for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {
		
		assert(pIter->eLock == READ_LOCK || pIter->eLock == WRITE_LOCK);
		assert(eLock == READ_LOCK || pIter->pBtree == p || pIter->eLock == READ_LOCK);
		if (pIter->pBtree != p && pIter->iTable == iTab && pIter->eLock != eLock) {
			sqlite3ConnectionBlocked(p->db, pIter->pBtree->db);
			if (eLock == WRITE_LOCK) {
				assert(p == pBt->pWriter);
				pBt->btsFlags |= BTS_PENDING;
			}
			return SQLITE_LOCKED_SHAREDCACHE;
		}
	}
	return SQLITE_OK;
}
#endif 

#ifndef SQLITE_OMIT_SHARED_CACHE

static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock) {
	BtShared *pBt = p->pBt;
	BtLock *pLock = 0;
	BtLock *pIter;

	assert(sqlite3BtreeHoldsMutex(p));
	assert(eLock == READ_LOCK || eLock == WRITE_LOCK);
	assert(p->db != 0);

	
	assert(0 == (p->db->flags&SQLITE_ReadUncommitted) || eLock == WRITE_LOCK);

	
	assert(p->sharable);
	assert(SQLITE_OK == querySharedCacheTableLock(p, iTable, eLock));

	
	for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {
		if (pIter->iTable == iTable && pIter->pBtree == p) {
			pLock = pIter;
			break;
		}
	}

	
	if (!pLock) {
		pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));
		if (!pLock) {
			return SQLITE_NOMEM_BKPT;
		}
		pLock->iTable = iTable;
		pLock->pBtree = p;
		pLock->pNext = pBt->pLock;
		pBt->pLock = pLock;
	}

	
	assert(WRITE_LOCK>READ_LOCK);
	if (eLock>pLock->eLock) {
		pLock->eLock = eLock;
	}

	return SQLITE_OK;
}
#endif 

#ifndef SQLITE_OMIT_SHARED_CACHE

static void clearAllSharedCacheTableLocks(Btree *p) {
	BtShared *pBt = p->pBt;
	BtLock **ppIter = &pBt->pLock;

	assert(sqlite3BtreeHoldsMutex(p));
	assert(p->sharable || 0 == *ppIter);
	assert(p->inTrans>0);

	while (*ppIter) {
		BtLock *pLock = *ppIter;
		assert((pBt->btsFlags & BTS_EXCLUSIVE) == 0 || pBt->pWriter == pLock->pBtree);
		assert(pLock->pBtree->inTrans >= pLock->eLock);
		if (pLock->pBtree == p) {
			*ppIter = pLock->pNext;
			assert(pLock->iTable != 1 || pLock == &p->lock);
			if (pLock->iTable != 1) {
				sqlite3_free(pLock);
			}
		}
		else {
			ppIter = &pLock->pNext;
		}
	}

	assert((pBt->btsFlags & BTS_PENDING) == 0 || pBt->pWriter);
	if (pBt->pWriter == p) {
		pBt->pWriter = 0;
		pBt->btsFlags &= ~(BTS_EXCLUSIVE | BTS_PENDING);
	}
	else if (pBt->nTransaction == 2) {
		
		pBt->btsFlags &= ~BTS_PENDING;
	}
}


static void downgradeAllSharedCacheTableLocks(Btree *p) {
	BtShared *pBt = p->pBt;
	if (pBt->pWriter == p) {
		BtLock *pLock;
		pBt->pWriter = 0;
		pBt->btsFlags &= ~(BTS_EXCLUSIVE | BTS_PENDING);
		for (pLock = pBt->pLock; pLock; pLock = pLock->pNext) {
			assert(pLock->eLock == READ_LOCK || pLock->pBtree == p);
			pLock->eLock = READ_LOCK;
		}
	}
}

#endif 

static void releasePage(MemPage *pPage);  

										  
#ifdef SQLITE_DEBUG
static int cursorHoldsMutex(BtCursor *p) {
	return sqlite3_mutex_held(p->pBt->mutex);
}


static int cursorOwnsBtShared(BtCursor *p) {
	assert(cursorHoldsMutex(p));
	return (p->pBtree->db == p->pBt->db);
}
#endif


#define invalidateOverflowCache(pCur) (pCur->curFlags &= ~BTCF_ValidOvfl)


static void invalidateAllOverflowCache(BtShared *pBt) {
	BtCursor *p;
	assert(sqlite3_mutex_held(pBt->mutex));
	for (p = pBt->pCursor; p; p = p->pNext) {
		invalidateOverflowCache(p);
	}
}

#ifndef SQLITE_OMIT_INCRBLOB

static void invalidateIncrblobCursors(
	Btree *pBtree,          
	i64 iRow,               
	int isClearTable        
) {
	BtCursor *p;
	if (pBtree->hasIncrblobCur == 0) return;
	assert(sqlite3BtreeHoldsMutex(pBtree));
	pBtree->hasIncrblobCur = 0;
	for (p = pBtree->pBt->pCursor; p; p = p->pNext) {
		if ((p->curFlags & BTCF_Incrblob) != 0) {
			pBtree->hasIncrblobCur = 1;
			if (isClearTable || p->info.nKey == iRow) {
				p->eState = CURSOR_INVALID;
			}
		}
	}
}

#else

#define invalidateIncrblobCursors(x,y,z)
#endif 


static int btreeSetHasContent(BtShared *pBt, Pgno pgno) {
	int rc = SQLITE_OK;
	if (!pBt->pHasContent) {
		assert(pgno <= pBt->nPage);
		pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);
		if (!pBt->pHasContent) {
			rc = SQLITE_NOMEM_BKPT;
		}
	}
	if (rc == SQLITE_OK && pgno <= sqlite3BitvecSize(pBt->pHasContent)) {
		rc = sqlite3BitvecSet(pBt->pHasContent, pgno);
	}
	return rc;
}


static int btreeGetHasContent(BtShared *pBt, Pgno pgno) {
	Bitvec *p = pBt->pHasContent;
	return (p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTest(p, pgno)));
}


static void btreeClearHasContent(BtShared *pBt) {
	sqlite3BitvecDestroy(pBt->pHasContent);
	pBt->pHasContent = 0;
}


static void btreeReleaseAllCursorPages(BtCursor *pCur) {
	int i;
	for (i = 0; i <= pCur->iPage; i++) {
		releasePage(pCur->apPage[i]);
		pCur->apPage[i] = 0;
	}
	pCur->iPage = -1;
}


static int saveCursorKey(BtCursor *pCur) {
	int rc = SQLITE_OK;
	assert(CURSOR_VALID == pCur->eState);
	assert(0 == pCur->pKey);
	assert(cursorHoldsMutex(pCur));

	if (pCur->curIntKey) {
		
		pCur->nKey = sqlite3BtreeIntegerKey(pCur);
	}
	else {
		
		void *pKey;
		pCur->nKey = sqlite3BtreePayloadSize(pCur);
		pKey = sqlite3Malloc(pCur->nKey);
		if (pKey) {
			rc = sqlite3BtreeKey(pCur, 0, (int)pCur->nKey, pKey);
			if (rc == SQLITE_OK) {
				pCur->pKey = pKey;
			}
			else {
				sqlite3_free(pKey);
			}
		}
		else {
			rc = SQLITE_NOMEM_BKPT;
		}
	}
	assert(!pCur->curIntKey || !pCur->pKey);
	return rc;
}


static int saveCursorPosition(BtCursor *pCur) {
	int rc;

	assert(CURSOR_VALID == pCur->eState || CURSOR_SKIPNEXT == pCur->eState);
	assert(0 == pCur->pKey);
	assert(cursorHoldsMutex(pCur));

	if (pCur->eState == CURSOR_SKIPNEXT) {
		pCur->eState = CURSOR_VALID;
	}
	else {
		pCur->skipNext = 0;
	}

	rc = saveCursorKey(pCur);
	if (rc == SQLITE_OK) {
		btreeReleaseAllCursorPages(pCur);
		pCur->eState = CURSOR_REQUIRESEEK;
	}

	pCur->curFlags &= ~(BTCF_ValidNKey | BTCF_ValidOvfl | BTCF_AtLast);
	return rc;
}


static int SQLITE_NOINLINE saveCursorsOnList(BtCursor*, Pgno, BtCursor*);


static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept) {
	BtCursor *p;
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(pExcept == 0 || pExcept->pBt == pBt);
	for (p = pBt->pCursor; p; p = p->pNext) {
		if (p != pExcept && (0 == iRoot || p->pgnoRoot == iRoot)) break;
	}
	if (p) return saveCursorsOnList(p, iRoot, pExcept);
	if (pExcept) pExcept->curFlags &= ~BTCF_Multiple;
	return SQLITE_OK;
}


static int SQLITE_NOINLINE saveCursorsOnList(
	BtCursor *p,         
	Pgno iRoot,          
	BtCursor *pExcept    
) {
	do {
		if (p != pExcept && (0 == iRoot || p->pgnoRoot == iRoot)) {
			if (p->eState == CURSOR_VALID || p->eState == CURSOR_SKIPNEXT) {
				int rc = saveCursorPosition(p);
				if (SQLITE_OK != rc) {
					return rc;
				}
			}
			else {
				testcase(p->iPage>0);
				btreeReleaseAllCursorPages(p);
			}
		}
		p = p->pNext;
	} while (p);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *pCur) {
	assert(cursorHoldsMutex(pCur));
	sqlite3_free(pCur->pKey);
	pCur->pKey = 0;
	pCur->eState = CURSOR_INVALID;
}


static int btreeMoveto(
	BtCursor *pCur,     
	const void *pKey,   
	i64 nKey,           
	int bias,           
	int *pRes           
) {
	int rc;                    
	UnpackedRecord *pIdxKey;   
	char aSpace[384];          
	char *pFree = 0;

	if (pKey) {
		assert(nKey == (i64)(int)nKey);
		pIdxKey = sqlite3VdbeAllocUnpackedRecord(
			pCur->pKeyInfo, aSpace, sizeof(aSpace), &pFree
		);
		if (pIdxKey == 0) return SQLITE_NOMEM_BKPT;
		sqlite3VdbeRecordUnpack(pCur->pKeyInfo, (int)nKey, pKey, pIdxKey);
		if (pIdxKey->nField == 0) {
			sqlite3DbFree(pCur->pKeyInfo->db, pFree);
			return SQLITE_CORRUPT_BKPT;
		}
	}
	else {
		pIdxKey = 0;
	}
	rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);
	if (pFree) {
		sqlite3DbFree(pCur->pKeyInfo->db, pFree);
	}
	return rc;
}


static int btreeRestoreCursorPosition(BtCursor *pCur) {
	int rc;
	int skipNext;
	assert(cursorOwnsBtShared(pCur));
	assert(pCur->eState >= CURSOR_REQUIRESEEK);
	if (pCur->eState == CURSOR_FAULT) {
		return pCur->skipNext;
	}
	pCur->eState = CURSOR_INVALID;
	rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);
	if (rc == SQLITE_OK) {
		sqlite3_free(pCur->pKey);
		pCur->pKey = 0;
		assert(pCur->eState == CURSOR_VALID || pCur->eState == CURSOR_INVALID);
		pCur->skipNext |= skipNext;
		if (pCur->skipNext && pCur->eState == CURSOR_VALID) {
			pCur->eState = CURSOR_SKIPNEXT;
		}
	}
	return rc;
}

#define restoreCursorPosition(p) \
  (p->eState>=CURSOR_REQUIRESEEK ? \
         btreeRestoreCursorPosition(p) : \
         SQLITE_OK)


SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor *pCur) {
	return pCur->eState != CURSOR_VALID;
}


SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow) {
	int rc;

	assert(pCur != 0);
	assert(pCur->eState != CURSOR_VALID);
	rc = restoreCursorPosition(pCur);
	if (rc) {
		*pDifferentRow = 1;
		return rc;
	}
	if (pCur->eState != CURSOR_VALID) {
		*pDifferentRow = 1;
	}
	else {
		assert(pCur->skipNext == 0);
		*pDifferentRow = 0;
	}
	return SQLITE_OK;
}

#ifdef SQLITE_ENABLE_CURSOR_HINTS

SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor *pCur, int eHintType, ...) {
	
}
#endif


SQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor *pCur, unsigned x) {
	assert(x == BTREE_SEEK_EQ || x == BTREE_BULKLOAD || x == 0);
	pCur->hints = x;
}


#ifndef SQLITE_OMIT_AUTOVACUUM

static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno) {
	int nPagesPerMapPage;
	Pgno iPtrMap, ret;
	assert(sqlite3_mutex_held(pBt->mutex));
	if (pgno<2) return 0;
	nPagesPerMapPage = (pBt->usableSize / 5) + 1;
	iPtrMap = (pgno - 2) / nPagesPerMapPage;
	ret = (iPtrMap*nPagesPerMapPage) + 2;
	if (ret == PENDING_BYTE_PAGE(pBt)) {
		ret++;
	}
	return ret;
}


static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC) {
	DbPage *pDbPage;  
	u8 *pPtrmap;      
	Pgno iPtrmap;     
	int offset;       
	int rc;           

	if (*pRC) return;

	assert(sqlite3_mutex_held(pBt->mutex));
	
	assert(0 == PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)));

	assert(pBt->autoVacuum);
	if (key == 0) {
		*pRC = SQLITE_CORRUPT_BKPT;
		return;
	}
	iPtrmap = PTRMAP_PAGENO(pBt, key);
	rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
	if (rc != SQLITE_OK) {
		*pRC = rc;
		return;
	}
	offset = PTRMAP_PTROFFSET(iPtrmap, key);
	if (offset<0) {
		*pRC = SQLITE_CORRUPT_BKPT;
		goto ptrmap_exit;
	}
	assert(offset <= (int)pBt->usableSize - 5);
	pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

	if (eType != pPtrmap[offset] || get4byte(&pPtrmap[offset + 1]) != parent) {
		TRACE(("PTRMAP_UPDATE: %d->(%d,%d)\n", key, eType, parent));
		*pRC = rc = sqlite3PagerWrite(pDbPage);
		if (rc == SQLITE_OK) {
			pPtrmap[offset] = eType;
			put4byte(&pPtrmap[offset + 1], parent);
		}
	}

ptrmap_exit:
	sqlite3PagerUnref(pDbPage);
}


static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno) {
	DbPage *pDbPage;   
	int iPtrmap;       
	u8 *pPtrmap;       
	int offset;        
	int rc;

	assert(sqlite3_mutex_held(pBt->mutex));

	iPtrmap = PTRMAP_PAGENO(pBt, key);
	rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
	if (rc != 0) {
		return rc;
	}
	pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

	offset = PTRMAP_PTROFFSET(iPtrmap, key);
	if (offset<0) {
		sqlite3PagerUnref(pDbPage);
		return SQLITE_CORRUPT_BKPT;
	}
	assert(offset <= (int)pBt->usableSize - 5);
	assert(pEType != 0);
	*pEType = pPtrmap[offset];
	if (pPgno) *pPgno = get4byte(&pPtrmap[offset + 1]);

	sqlite3PagerUnref(pDbPage);
	if (*pEType<1 || *pEType>5) return SQLITE_CORRUPT_BKPT;
	return SQLITE_OK;
}

#else 
#define ptrmapPut(w,x,y,z,rc)
#define ptrmapGet(w,x,y,z) SQLITE_OK
#define ptrmapPutOvflPtr(x, y, rc)
#endif


#define findCell(P,I) \
  ((P)->aData + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))
#define findCellPastPtr(P,I) \
  ((P)->aDataOfst + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))



static SQLITE_NOINLINE void btreeParseCellAdjustSizeForOverflow(
	MemPage *pPage,         
	u8 *pCell,              
	CellInfo *pInfo         
) {
	
	int minLocal;  
	int maxLocal;  
	int surplus;   

	minLocal = pPage->minLocal;
	maxLocal = pPage->maxLocal;
	surplus = minLocal + (pInfo->nPayload - minLocal) % (pPage->pBt->usableSize - 4);
	testcase(surplus == maxLocal);
	testcase(surplus == maxLocal + 1);
	if (surplus <= maxLocal) {
		pInfo->nLocal = (u16)surplus;
	}
	else {
		pInfo->nLocal = (u16)minLocal;
	}
	pInfo->nSize = (u16)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4;
}


static void btreeParseCellPtrNoPayload(
	MemPage *pPage,         
	u8 *pCell,              
	CellInfo *pInfo         
) {
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(pPage->leaf == 0);
	assert(pPage->childPtrSize == 4);
#ifndef SQLITE_DEBUG
	UNUSED_PARAMETER(pPage);
#endif
	pInfo->nSize = 4 + getVarint(&pCell[4], (u64*)&pInfo->nKey);
	pInfo->nPayload = 0;
	pInfo->nLocal = 0;
	pInfo->pPayload = 0;
	return;
}
static void btreeParseCellPtr(
	MemPage *pPage,         
	u8 *pCell,              
	CellInfo *pInfo         
) {
	u8 *pIter;              
	u32 nPayload;           
	u64 iKey;               

	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(pPage->leaf == 0 || pPage->leaf == 1);
	assert(pPage->intKeyLeaf);
	assert(pPage->childPtrSize == 0);
	pIter = pCell;

	
	nPayload = *pIter;
	if (nPayload >= 0x80) {
		u8 *pEnd = &pIter[8];
		nPayload &= 0x7f;
		do {
			nPayload = (nPayload << 7) | (*++pIter & 0x7f);
		} while ((*pIter) >= 0x80 && pIter<pEnd);
	}
	pIter++;

	
	iKey = *pIter;
	if (iKey >= 0x80) {
		u8 *pEnd = &pIter[7];
		iKey &= 0x7f;
		while (1) {
			iKey = (iKey << 7) | (*++pIter & 0x7f);
			if ((*pIter)<0x80) break;
			if (pIter >= pEnd) {
				iKey = (iKey << 8) | *++pIter;
				break;
			}
		}
	}
	pIter++;

	pInfo->nKey = *(i64*)&iKey;
	pInfo->nPayload = nPayload;
	pInfo->pPayload = pIter;
	testcase(nPayload == pPage->maxLocal);
	testcase(nPayload == pPage->maxLocal + 1);
	if (nPayload <= pPage->maxLocal) {
		
		pInfo->nSize = nPayload + (u16)(pIter - pCell);
		if (pInfo->nSize<4) pInfo->nSize = 4;
		pInfo->nLocal = (u16)nPayload;
	}
	else {
		btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
	}
}
static void btreeParseCellPtrIndex(
	MemPage *pPage,         
	u8 *pCell,              
	CellInfo *pInfo         
) {
	u8 *pIter;              
	u32 nPayload;           

	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(pPage->leaf == 0 || pPage->leaf == 1);
	assert(pPage->intKeyLeaf == 0);
	pIter = pCell + pPage->childPtrSize;
	nPayload = *pIter;
	if (nPayload >= 0x80) {
		u8 *pEnd = &pIter[8];
		nPayload &= 0x7f;
		do {
			nPayload = (nPayload << 7) | (*++pIter & 0x7f);
		} while (*(pIter) >= 0x80 && pIter<pEnd);
	}
	pIter++;
	pInfo->nKey = nPayload;
	pInfo->nPayload = nPayload;
	pInfo->pPayload = pIter;
	testcase(nPayload == pPage->maxLocal);
	testcase(nPayload == pPage->maxLocal + 1);
	if (nPayload <= pPage->maxLocal) {
		
		pInfo->nSize = nPayload + (u16)(pIter - pCell);
		if (pInfo->nSize<4) pInfo->nSize = 4;
		pInfo->nLocal = (u16)nPayload;
	}
	else {
		btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
	}
}
static void btreeParseCell(
	MemPage *pPage,         
	int iCell,              
	CellInfo *pInfo         
) {
	pPage->xParseCell(pPage, findCell(pPage, iCell), pInfo);
}


static u16 cellSizePtr(MemPage *pPage, u8 *pCell) {
	u8 *pIter = pCell + pPage->childPtrSize; 
	u8 *pEnd;                                
	u32 nSize;                               

#ifdef SQLITE_DEBUG
											 
	CellInfo debuginfo;
	pPage->xParseCell(pPage, pCell, &debuginfo);
#endif

	nSize = *pIter;
	if (nSize >= 0x80) {
		pEnd = &pIter[8];
		nSize &= 0x7f;
		do {
			nSize = (nSize << 7) | (*++pIter & 0x7f);
		} while (*(pIter) >= 0x80 && pIter<pEnd);
	}
	pIter++;
	if (pPage->intKey) {
		
		pEnd = &pIter[9];
		while ((*pIter++) & 0x80 && pIter<pEnd);
	}
	testcase(nSize == pPage->maxLocal);
	testcase(nSize == pPage->maxLocal + 1);
	if (nSize <= pPage->maxLocal) {
		nSize += (u32)(pIter - pCell);
		if (nSize<4) nSize = 4;
	}
	else {
		int minLocal = pPage->minLocal;
		nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
		testcase(nSize == pPage->maxLocal);
		testcase(nSize == pPage->maxLocal + 1);
		if (nSize>pPage->maxLocal) {
			nSize = minLocal;
		}
		nSize += 4 + (u16)(pIter - pCell);
	}
	assert(nSize == debuginfo.nSize || CORRUPT_DB);
	return (u16)nSize;
}
static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell) {
	u8 *pIter = pCell + 4; 
	u8 *pEnd;              

#ifdef SQLITE_DEBUG
						   
	CellInfo debuginfo;
	pPage->xParseCell(pPage, pCell, &debuginfo);
#else
	UNUSED_PARAMETER(pPage);
#endif

	assert(pPage->childPtrSize == 4);
	pEnd = pIter + 9;
	while ((*pIter++) & 0x80 && pIter<pEnd);
	assert(debuginfo.nSize == (u16)(pIter - pCell) || CORRUPT_DB);
	return (u16)(pIter - pCell);
}


#ifdef SQLITE_DEBUG

static u16 cellSize(MemPage *pPage, int iCell) {
	return pPage->xCellSize(pPage, findCell(pPage, iCell));
}
#endif

#ifndef SQLITE_OMIT_AUTOVACUUM

static void ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell, int *pRC) {
	CellInfo info;
	if (*pRC) return;
	assert(pCell != 0);
	pPage->xParseCell(pPage, pCell, &info);
	if (info.nLocal<info.nPayload) {
		Pgno ovfl = get4byte(&pCell[info.nSize - 4]);
		ptrmapPut(pPage->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, pRC);
	}
}
#endif



static int defragmentPage(MemPage *pPage) {
	int i;                     
	int pc;                    
	int hdr;                   
	int size;                  
	int usableSize;            
	int cellOffset;            
	int cbrk;                  
	int nCell;                 
	unsigned char *data;       
	unsigned char *temp;       
	unsigned char *src;        
	int iCellFirst;            
	int iCellLast;             


	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	assert(pPage->pBt != 0);
	assert(pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE);
	assert(pPage->nOverflow == 0);
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	temp = 0;
	src = data = pPage->aData;
	hdr = pPage->hdrOffset;
	cellOffset = pPage->cellOffset;
	nCell = pPage->nCell;
	assert(nCell == get2byte(&data[hdr + 3]));
	usableSize = pPage->pBt->usableSize;
	cbrk = usableSize;
	iCellFirst = cellOffset + 2 * nCell;
	iCellLast = usableSize - 4;
	for (i = 0; i<nCell; i++) {
		u8 *pAddr;     
		pAddr = &data[cellOffset + i * 2];
		pc = get2byte(pAddr);
		testcase(pc == iCellFirst);
		testcase(pc == iCellLast);
		
		if (pc<iCellFirst || pc>iCellLast) {
			return SQLITE_CORRUPT_BKPT;
		}
		assert(pc >= iCellFirst && pc <= iCellLast);
		size = pPage->xCellSize(pPage, &src[pc]);
		cbrk -= size;
		if (cbrk<iCellFirst || pc + size>usableSize) {
			return SQLITE_CORRUPT_BKPT;
		}
		assert(cbrk + size <= usableSize && cbrk >= iCellFirst);
		testcase(cbrk + size == usableSize);
		testcase(pc + size == usableSize);
		put2byte(pAddr, cbrk);
		if (temp == 0) {
			int x;
			if (cbrk == pc) continue;
			temp = sqlite3PagerTempSpace(pPage->pBt->pPager);
			x = get2byte(&data[hdr + 5]);
			memcpy(&temp[x], &data[x], (cbrk + size) - x);
			src = temp;
		}
		memcpy(&data[cbrk], &src[pc], size);
	}
	assert(cbrk >= iCellFirst);
	put2byte(&data[hdr + 5], cbrk);
	data[hdr + 1] = 0;
	data[hdr + 2] = 0;
	data[hdr + 7] = 0;
	memset(&data[iCellFirst], 0, cbrk - iCellFirst);
	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	if (cbrk - iCellFirst != pPage->nFree) {
		return SQLITE_CORRUPT_BKPT;
	}
	return SQLITE_OK;
}


static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc) {
	const int hdr = pPg->hdrOffset;
	u8 * const aData = pPg->aData;
	int iAddr = hdr + 1;
	int pc = get2byte(&aData[iAddr]);
	int x;
	int usableSize = pPg->pBt->usableSize;

	assert(pc>0);
	do {
		int size;            
							 
		if (pc>usableSize - 4 || pc<iAddr + 4) {
			*pRc = SQLITE_CORRUPT_BKPT;
			return 0;
		}
		
		size = get2byte(&aData[pc + 2]);
		if ((x = size - nByte) >= 0) {
			testcase(x == 4);
			testcase(x == 3);
			if (pc < pPg->cellOffset + 2 * pPg->nCell || size + pc > usableSize) {
				*pRc = SQLITE_CORRUPT_BKPT;
				return 0;
			}
			else if (x<4) {
				
				if (aData[hdr + 7]>57) return 0;

				
				memcpy(&aData[iAddr], &aData[pc], 2);
				aData[hdr + 7] += (u8)x;
			}
			else {
				
				put2byte(&aData[pc + 2], x);
			}
			return &aData[pc + x];
		}
		iAddr = pc;
		pc = get2byte(&aData[pc]);
	} while (pc);

	return 0;
}


static int allocateSpace(MemPage *pPage, int nByte, int *pIdx) {
	const int hdr = pPage->hdrOffset;    
	u8 * const data = pPage->aData;      
	int top;                             
	int rc = SQLITE_OK;                  
	int gap;        

	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	assert(pPage->pBt);
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(nByte >= 0);  
	assert(pPage->nFree >= nByte);
	assert(pPage->nOverflow == 0);
	assert(nByte < (int)(pPage->pBt->usableSize - 8));

	assert(pPage->cellOffset == hdr + 12 - 4 * pPage->leaf);
	gap = pPage->cellOffset + 2 * pPage->nCell;
	assert(gap <= 65536);
	
	top = get2byte(&data[hdr + 5]);
	assert(top <= (int)pPage->pBt->usableSize); 
	if (gap>top) {
		if (top == 0 && pPage->pBt->usableSize == 65536) {
			top = 65536;
		}
		else {
			return SQLITE_CORRUPT_BKPT;
		}
	}

	
	testcase(gap + 2 == top);
	testcase(gap + 1 == top);
	testcase(gap == top);
	if ((data[hdr + 2] || data[hdr + 1]) && gap + 2 <= top) {
		u8 *pSpace = pageFindSlot(pPage, nByte, &rc);
		if (pSpace) {
			assert(pSpace >= data && (pSpace - data)<65536);
			*pIdx = (int)(pSpace - data);
			return SQLITE_OK;
		}
		else if (rc) {
			return rc;
		}
	}

	
	testcase(gap + 2 + nByte == top);
	if (gap + 2 + nByte>top) {
		assert(pPage->nCell>0 || CORRUPT_DB);
		rc = defragmentPage(pPage);
		if (rc) return rc;
		top = get2byteNotZero(&data[hdr + 5]);
		assert(gap + nByte <= top);
	}


	
	top -= nByte;
	put2byte(&data[hdr + 5], top);
	assert(top + nByte <= (int)pPage->pBt->usableSize);
	*pIdx = top;
	return SQLITE_OK;
}


static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize) {
	u16 iPtr;                             
	u16 iFreeBlk;                         
	u8 hdr;                               
	u8 nFrag = 0;                         
	u16 iOrigSize = iSize;                
	u32 iLast = pPage->pBt->usableSize - 4; 
	u32 iEnd = iStart + iSize;            
	unsigned char *data = pPage->aData;   

	assert(pPage->pBt != 0);
	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	assert(CORRUPT_DB || iStart >= pPage->hdrOffset + 6 + pPage->childPtrSize);
	assert(CORRUPT_DB || iEnd <= pPage->pBt->usableSize);
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(iSize >= 4);   
	assert(iStart <= iLast);

	
	if (pPage->pBt->btsFlags & BTS_SECURE_DELETE) {
		memset(&data[iStart], 0, iSize);
	}

	
	hdr = pPage->hdrOffset;
	iPtr = hdr + 1;
	if (data[iPtr + 1] == 0 && data[iPtr] == 0) {
		iFreeBlk = 0;  
	}
	else {
		while ((iFreeBlk = get2byte(&data[iPtr]))<iStart) {
			if (iFreeBlk<iPtr + 4) {
				if (iFreeBlk == 0) break;
				return SQLITE_CORRUPT_BKPT;
			}
			iPtr = iFreeBlk;
		}
		if (iFreeBlk>iLast) return SQLITE_CORRUPT_BKPT;
		assert(iFreeBlk>iPtr || iFreeBlk == 0);

		
		if (iFreeBlk && iEnd + 3 >= iFreeBlk) {
			nFrag = iFreeBlk - iEnd;
			if (iEnd>iFreeBlk) return SQLITE_CORRUPT_BKPT;
			iEnd = iFreeBlk + get2byte(&data[iFreeBlk + 2]);
			if (iEnd > pPage->pBt->usableSize) return SQLITE_CORRUPT_BKPT;
			iSize = iEnd - iStart;
			iFreeBlk = get2byte(&data[iFreeBlk]);
		}

		
		if (iPtr>hdr + 1) {
			int iPtrEnd = iPtr + get2byte(&data[iPtr + 2]);
			if (iPtrEnd + 3 >= iStart) {
				if (iPtrEnd>iStart) return SQLITE_CORRUPT_BKPT;
				nFrag += iStart - iPtrEnd;
				iSize = iEnd - iPtr;
				iStart = iPtr;
			}
		}
		if (nFrag>data[hdr + 7]) return SQLITE_CORRUPT_BKPT;
		data[hdr + 7] -= nFrag;
	}
	if (iStart == get2byte(&data[hdr + 5])) {
		
		if (iPtr != hdr + 1) return SQLITE_CORRUPT_BKPT;
		put2byte(&data[hdr + 1], iFreeBlk);
		put2byte(&data[hdr + 5], iEnd);
	}
	else {
		
		put2byte(&data[iPtr], iStart);
		put2byte(&data[iStart], iFreeBlk);
		put2byte(&data[iStart + 2], iSize);
	}
	pPage->nFree += iOrigSize;
	return SQLITE_OK;
}


static int decodeFlags(MemPage *pPage, int flagByte) {
	BtShared *pBt;     

	assert(pPage->hdrOffset == (pPage->pgno == 1 ? 100 : 0));
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	pPage->leaf = (u8)(flagByte >> 3);  assert(PTF_LEAF == 1 << 3);
	flagByte &= ~PTF_LEAF;
	pPage->childPtrSize = 4 - 4 * pPage->leaf;
	pPage->xCellSize = cellSizePtr;
	pBt = pPage->pBt;
	if (flagByte == (PTF_LEAFDATA | PTF_INTKEY)) {
		
		assert((PTF_LEAFDATA | PTF_INTKEY) == 5);
		
		assert((PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF) == 13);
		pPage->intKey = 1;
		if (pPage->leaf) {
			pPage->intKeyLeaf = 1;
			pPage->xParseCell = btreeParseCellPtr;
		}
		else {
			pPage->intKeyLeaf = 0;
			pPage->xCellSize = cellSizePtrNoPayload;
			pPage->xParseCell = btreeParseCellPtrNoPayload;
		}
		pPage->maxLocal = pBt->maxLeaf;
		pPage->minLocal = pBt->minLeaf;
	}
	else if (flagByte == PTF_ZERODATA) {
		
		assert((PTF_ZERODATA) == 2);
		
		assert((PTF_ZERODATA | PTF_LEAF) == 10);
		pPage->intKey = 0;
		pPage->intKeyLeaf = 0;
		pPage->xParseCell = btreeParseCellPtrIndex;
		pPage->maxLocal = pBt->maxLocal;
		pPage->minLocal = pBt->minLocal;
	}
	else {
		
		return SQLITE_CORRUPT_BKPT;
	}
	pPage->max1bytePayload = pBt->max1bytePayload;
	return SQLITE_OK;
}


static int btreeInitPage(MemPage *pPage) {

	assert(pPage->pBt != 0);
	assert(pPage->pBt->db != 0);
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(pPage->pgno == sqlite3PagerPagenumber(pPage->pDbPage));
	assert(pPage == sqlite3PagerGetExtra(pPage->pDbPage));
	assert(pPage->aData == sqlite3PagerGetData(pPage->pDbPage));

	if (!pPage->isInit) {
		u16 pc;            
		u8 hdr;            
		u8 *data;          
		BtShared *pBt;        
		int usableSize;    
		u16 cellOffset;    
		int nFree;         
		int top;           
		int iCellFirst;    
		int iCellLast;     

		pBt = pPage->pBt;

		hdr = pPage->hdrOffset;
		data = pPage->aData;
		
		if (decodeFlags(pPage, data[hdr])) return SQLITE_CORRUPT_BKPT;
		assert(pBt->pageSize >= 512 && pBt->pageSize <= 65536);
		pPage->maskPage = (u16)(pBt->pageSize - 1);
		pPage->nOverflow = 0;
		usableSize = pBt->usableSize;
		pPage->cellOffset = cellOffset = hdr + 8 + pPage->childPtrSize;
		pPage->aDataEnd = &data[usableSize];
		pPage->aCellIdx = &data[cellOffset];
		pPage->aDataOfst = &data[pPage->childPtrSize];
		
		top = get2byteNotZero(&data[hdr + 5]);
		
		pPage->nCell = get2byte(&data[hdr + 3]);
		if (pPage->nCell>MX_CELL(pBt)) {
			
			return SQLITE_CORRUPT_BKPT;
		}
		testcase(pPage->nCell == MX_CELL(pBt));
		
		assert(pPage->nCell>0 || top == usableSize || CORRUPT_DB);

		
		iCellFirst = cellOffset + 2 * pPage->nCell;
		iCellLast = usableSize - 4;
		if (pBt->db->flags & SQLITE_CellSizeCk) {
			int i;            
			int sz;           

			if (!pPage->leaf) iCellLast--;
			for (i = 0; i<pPage->nCell; i++) {
				pc = get2byteAligned(&data[cellOffset + i * 2]);
				testcase(pc == iCellFirst);
				testcase(pc == iCellLast);
				if (pc<iCellFirst || pc>iCellLast) {
					return SQLITE_CORRUPT_BKPT;
				}
				sz = pPage->xCellSize(pPage, &data[pc]);
				testcase(pc + sz == usableSize);
				if (pc + sz>usableSize) {
					return SQLITE_CORRUPT_BKPT;
				}
			}
			if (!pPage->leaf) iCellLast++;
		}

		
		pc = get2byte(&data[hdr + 1]);
		nFree = data[hdr + 7] + top;  
		while (pc>0) {
			u16 next, size;
			if (pc<iCellFirst || pc>iCellLast) {
				
				return SQLITE_CORRUPT_BKPT;
			}
			next = get2byte(&data[pc]);
			size = get2byte(&data[pc + 2]);
			if ((next>0 && next <= pc + size + 3) || pc + size>usableSize) {
				
				return SQLITE_CORRUPT_BKPT;
			}
			nFree = nFree + size;
			pc = next;
		}

		
		if (nFree>usableSize) {
			return SQLITE_CORRUPT_BKPT;
		}
		pPage->nFree = (u16)(nFree - iCellFirst);
		pPage->isInit = 1;
	}
	return SQLITE_OK;
}


static void zeroPage(MemPage *pPage, int flags) {
	unsigned char *data = pPage->aData;
	BtShared *pBt = pPage->pBt;
	u8 hdr = pPage->hdrOffset;
	u16 first;

	assert(sqlite3PagerPagenumber(pPage->pDbPage) == pPage->pgno);
	assert(sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage);
	assert(sqlite3PagerGetData(pPage->pDbPage) == data);
	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	assert(sqlite3_mutex_held(pBt->mutex));
	if (pBt->btsFlags & BTS_SECURE_DELETE) {
		memset(&data[hdr], 0, pBt->usableSize - hdr);
	}
	data[hdr] = (char)flags;
	first = hdr + ((flags&PTF_LEAF) == 0 ? 12 : 8);
	memset(&data[hdr + 1], 0, 4);
	data[hdr + 7] = 0;
	put2byte(&data[hdr + 5], pBt->usableSize);
	pPage->nFree = (u16)(pBt->usableSize - first);
	decodeFlags(pPage, flags);
	pPage->cellOffset = first;
	pPage->aDataEnd = &data[pBt->usableSize];
	pPage->aCellIdx = &data[first];
	pPage->aDataOfst = &data[pPage->childPtrSize];
	pPage->nOverflow = 0;
	assert(pBt->pageSize >= 512 && pBt->pageSize <= 65536);
	pPage->maskPage = (u16)(pBt->pageSize - 1);
	pPage->nCell = 0;
	pPage->isInit = 1;
}



static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt) {
	MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
	if (pgno != pPage->pgno) {
		pPage->aData = sqlite3PagerGetData(pDbPage);
		pPage->pDbPage = pDbPage;
		pPage->pBt = pBt;
		pPage->pgno = pgno;
		pPage->hdrOffset = pgno == 1 ? 100 : 0;
	}
	assert(pPage->aData == sqlite3PagerGetData(pDbPage));
	return pPage;
}


static int btreeGetPage(
	BtShared *pBt,       
	Pgno pgno,           
	MemPage **ppPage,    
	int flags            
) {
	int rc;
	DbPage *pDbPage;

	assert(flags == 0 || flags == PAGER_GET_NOCONTENT || flags == PAGER_GET_READONLY);
	assert(sqlite3_mutex_held(pBt->mutex));
	rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
	if (rc) return rc;
	*ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
	return SQLITE_OK;
}


static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno) {
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
	if (pDbPage) {
		return btreePageFromDbPage(pDbPage, pgno, pBt);
	}
	return 0;
}


static Pgno btreePagecount(BtShared *pBt) {
	return pBt->nPage;
}
SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree *p) {
	assert(sqlite3BtreeHoldsMutex(p));
	assert(((p->pBt->nPage) & 0x8000000) == 0);
	return btreePagecount(p->pBt);
}


static int getAndInitPage(
	BtShared *pBt,                  
	Pgno pgno,                      
	MemPage **ppPage,               
	BtCursor *pCur,                 
	int bReadOnly                   
) {
	int rc;
	DbPage *pDbPage;
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(pCur == 0 || ppPage == &pCur->apPage[pCur->iPage]);
	assert(pCur == 0 || bReadOnly == pCur->curPagerFlags);
	assert(pCur == 0 || pCur->iPage>0);

	if (pgno>btreePagecount(pBt)) {
		rc = SQLITE_CORRUPT_BKPT;
		goto getAndInitPage_error;
	}
	rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);
	if (rc) {
		goto getAndInitPage_error;
	}
	*ppPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
	if ((*ppPage)->isInit == 0) {
		btreePageFromDbPage(pDbPage, pgno, pBt);
		rc = btreeInitPage(*ppPage);
		if (rc != SQLITE_OK) {
			releasePage(*ppPage);
			goto getAndInitPage_error;
		}
	}
	assert((*ppPage)->pgno == pgno);
	assert((*ppPage)->aData == sqlite3PagerGetData(pDbPage));

	
	if (pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey != pCur->curIntKey)) {
		rc = SQLITE_CORRUPT_BKPT;
		releasePage(*ppPage);
		goto getAndInitPage_error;
	}
	return SQLITE_OK;

getAndInitPage_error:
	if (pCur) pCur->iPage--;
	testcase(pgno == 0);
	assert(pgno != 0 || rc == SQLITE_CORRUPT);
	return rc;
}


static void releasePageNotNull(MemPage *pPage) {
	assert(pPage->aData);
	assert(pPage->pBt);
	assert(pPage->pDbPage != 0);
	assert(sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage);
	assert(sqlite3PagerGetData(pPage->pDbPage) == pPage->aData);
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	sqlite3PagerUnrefNotNull(pPage->pDbPage);
}
static void releasePage(MemPage *pPage) {
	if (pPage) releasePageNotNull(pPage);
}


static int btreeGetUnusedPage(
	BtShared *pBt,       
	Pgno pgno,           
	MemPage **ppPage,    
	int flags            
) {
	int rc = btreeGetPage(pBt, pgno, ppPage, flags);
	if (rc == SQLITE_OK) {
		if (sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1) {
			releasePage(*ppPage);
			*ppPage = 0;
			return SQLITE_CORRUPT_BKPT;
		}
		(*ppPage)->isInit = 0;
	}
	else {
		*ppPage = 0;
	}
	return rc;
}



static void pageReinit(DbPage *pData) {
	MemPage *pPage;
	pPage = (MemPage *)sqlite3PagerGetExtra(pData);
	assert(sqlite3PagerPageRefcount(pData)>0);
	if (pPage->isInit) {
		assert(sqlite3_mutex_held(pPage->pBt->mutex));
		pPage->isInit = 0;
		if (sqlite3PagerPageRefcount(pData)>1) {
			
			btreeInitPage(pPage);
		}
	}
}


static int btreeInvokeBusyHandler(void *pArg) {
	BtShared *pBt = (BtShared*)pArg;
	assert(pBt->db);
	assert(sqlite3_mutex_held(pBt->db->mutex));
	return sqlite3InvokeBusyHandler(&pBt->db->busyHandler);
}


SQLITE_PRIVATE int sqlite3BtreeOpen(
	sqlite3_vfs *pVfs,      
	const char *zFilename,  
	sqlite3 *db,            
	Btree **ppBtree,        
	int flags,              
	int vfsFlags            
) {
	BtShared *pBt = 0;             
	Btree *p;                      
	sqlite3_mutex *mutexOpen = 0;  
	int rc = SQLITE_OK;            
	u8 nReserve;                   
	unsigned char zDbHeader[100];  

								   
	const int isTempDb = zFilename == 0 || zFilename[0] == 0;

	
#ifdef SQLITE_OMIT_MEMORYDB
	const int isMemdb = 0;
#else
	const int isMemdb = (zFilename && strcmp(zFilename, ":memory:") == 0)
		|| (isTempDb && sqlite3TempInMemory(db))
		|| (vfsFlags & SQLITE_OPEN_MEMORY) != 0;
#endif

	assert(db != 0);
	assert(pVfs != 0);
	assert(sqlite3_mutex_held(db->mutex));
	assert((flags & 0xff) == flags);   

									   
	assert((flags & BTREE_UNORDERED) == 0 || (flags & BTREE_SINGLE) != 0);

	
	assert((flags & BTREE_SINGLE) == 0 || isTempDb);

	if (isMemdb) {
		flags |= BTREE_MEMORY;
	}
	if ((vfsFlags & SQLITE_OPEN_MAIN_DB) != 0 && (isMemdb || isTempDb)) {
		vfsFlags = (vfsFlags & ~SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB;
	}
	p = sqlite3MallocZero(sizeof(Btree));
	if (!p) {
		return SQLITE_NOMEM_BKPT;
	}
	p->inTrans = TRANS_NONE;
	p->db = db;
#ifndef SQLITE_OMIT_SHARED_CACHE
	p->lock.pBtree = p;
	p->lock.iTable = 1;
#endif

#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
	
	if (isTempDb == 0 && (isMemdb == 0 || (vfsFlags&SQLITE_OPEN_URI) != 0)) {
		if (vfsFlags & SQLITE_OPEN_SHAREDCACHE) {
			int nFilename = sqlite3Strlen30(zFilename) + 1;
			int nFullPathname = pVfs->mxPathname + 1;
			char *zFullPathname = sqlite3Malloc(MAX(nFullPathname, nFilename));
			MUTEX_LOGIC(sqlite3_mutex *mutexShared; )

				p->sharable = 1;
			if (!zFullPathname) {
				sqlite3_free(p);
				return SQLITE_NOMEM_BKPT;
			}
			if (isMemdb) {
				memcpy(zFullPathname, zFilename, nFilename);
			}
			else {
				rc = sqlite3OsFullPathname(pVfs, zFilename,
					nFullPathname, zFullPathname);
				if (rc) {
					sqlite3_free(zFullPathname);
					sqlite3_free(p);
					return rc;
				}
			}
#if SQLITE_THREADSAFE
			mutexOpen = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_OPEN);
			sqlite3_mutex_enter(mutexOpen);
			mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
			sqlite3_mutex_enter(mutexShared);
#endif
			for (pBt = GLOBAL(BtShared*, sqlite3SharedCacheList); pBt; pBt = pBt->pNext) {
				assert(pBt->nRef>0);
				if (0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))
					&& sqlite3PagerVfs(pBt->pPager) == pVfs) {
					int iDb;
					for (iDb = db->nDb - 1; iDb >= 0; iDb--) {
						Btree *pExisting = db->aDb[iDb].pBt;
						if (pExisting && pExisting->pBt == pBt) {
							sqlite3_mutex_leave(mutexShared);
							sqlite3_mutex_leave(mutexOpen);
							sqlite3_free(zFullPathname);
							sqlite3_free(p);
							return SQLITE_CONSTRAINT;
						}
					}
					p->pBt = pBt;
					pBt->nRef++;
					break;
				}
			}
			sqlite3_mutex_leave(mutexShared);
			sqlite3_free(zFullPathname);
		}
#ifdef SQLITE_DEBUG
		else {
			
			p->sharable = 1;
		}
#endif
	}
#endif
	if (pBt == 0) {
		
		assert(sizeof(i64) == 8);
		assert(sizeof(u64) == 8);
		assert(sizeof(u32) == 4);
		assert(sizeof(u16) == 2);
		assert(sizeof(Pgno) == 4);

		pBt = sqlite3MallocZero(sizeof(*pBt));
		if (pBt == 0) {
			rc = SQLITE_NOMEM_BKPT;
			goto btree_open_out;
		}
		rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename,
			EXTRA_SIZE, flags, vfsFlags, pageReinit);
		if (rc == SQLITE_OK) {
			sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);
			rc = sqlite3PagerReadFileheader(pBt->pPager, sizeof(zDbHeader), zDbHeader);
		}
		if (rc != SQLITE_OK) {
			goto btree_open_out;
		}
		pBt->openFlags = (u8)flags;
		pBt->db = db;
		sqlite3PagerSetBusyhandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
		p->pBt = pBt;

		pBt->pCursor = 0;
		pBt->pPage1 = 0;
		if (sqlite3PagerIsreadonly(pBt->pPager)) pBt->btsFlags |= BTS_READ_ONLY;
#ifdef SQLITE_SECURE_DELETE
		pBt->btsFlags |= BTS_SECURE_DELETE;
#endif
		
		pBt->pageSize = (zDbHeader[16] << 8) | (zDbHeader[17] << 16);
		if (pBt->pageSize<512 || pBt->pageSize>SQLITE_MAX_PAGE_SIZE
			|| ((pBt->pageSize - 1)&pBt->pageSize) != 0) {
			pBt->pageSize = 0;
#ifndef SQLITE_OMIT_AUTOVACUUM
			
			if (zFilename && !isMemdb) {
				pBt->autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM ? 1 : 0);
				pBt->incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM == 2 ? 1 : 0);
			}
#endif
			nReserve = 0;
		}
		else {
			
			nReserve = zDbHeader[20];
			pBt->btsFlags |= BTS_PAGESIZE_FIXED;
#ifndef SQLITE_OMIT_AUTOVACUUM
			pBt->autoVacuum = (get4byte(&zDbHeader[36 + 4 * 4]) ? 1 : 0);
			pBt->incrVacuum = (get4byte(&zDbHeader[36 + 7 * 4]) ? 1 : 0);
#endif
		}
		rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
		if (rc) goto btree_open_out;
		pBt->usableSize = pBt->pageSize - nReserve;
		assert((pBt->pageSize & 7) == 0);  

#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
										   
		pBt->nRef = 1;
		if (p->sharable) {
			MUTEX_LOGIC(sqlite3_mutex *mutexShared; )
				MUTEX_LOGIC(mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);)
				if (SQLITE_THREADSAFE && sqlite3GlobalConfig.bCoreMutex) {
					pBt->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST);
					if (pBt->mutex == 0) {
						rc = SQLITE_NOMEM_BKPT;
						goto btree_open_out;
					}
				}
			sqlite3_mutex_enter(mutexShared);
			pBt->pNext = GLOBAL(BtShared*, sqlite3SharedCacheList);
			GLOBAL(BtShared*, sqlite3SharedCacheList) = pBt;
			sqlite3_mutex_leave(mutexShared);
		}
#endif
	}

#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
	
	if (p->sharable) {
		int i;
		Btree *pSib;
		for (i = 0; i<db->nDb; i++) {
			if ((pSib = db->aDb[i].pBt) != 0 && pSib->sharable) {
				while (pSib->pPrev) { pSib = pSib->pPrev; }
				if ((uptr)p->pBt<(uptr)pSib->pBt) {
					p->pNext = pSib;
					p->pPrev = 0;
					pSib->pPrev = p;
				}
				else {
					while (pSib->pNext && (uptr)pSib->pNext->pBt<(uptr)p->pBt) {
						pSib = pSib->pNext;
					}
					p->pNext = pSib->pNext;
					p->pPrev = pSib;
					if (p->pNext) {
						p->pNext->pPrev = p;
					}
					pSib->pNext = p;
				}
				break;
			}
		}
	}
#endif
	*ppBtree = p;

btree_open_out:
	if (rc != SQLITE_OK) {
		if (pBt && pBt->pPager) {
			sqlite3PagerClose(pBt->pPager);
		}
		sqlite3_free(pBt);
		sqlite3_free(p);
		*ppBtree = 0;
	}
	else {
		
		if (sqlite3BtreeSchema(p, 0, 0) == 0) {
			sqlite3PagerSetCachesize(p->pBt->pPager, SQLITE_DEFAULT_CACHE_SIZE);
		}
	}
	if (mutexOpen) {
		assert(sqlite3_mutex_held(mutexOpen));
		sqlite3_mutex_leave(mutexOpen);
	}
	assert(rc != SQLITE_OK || sqlite3BtreeConnectionCount(*ppBtree)>0);
	return rc;
}


static int removeFromSharingList(BtShared *pBt) {
#ifndef SQLITE_OMIT_SHARED_CACHE
	MUTEX_LOGIC(sqlite3_mutex *pMaster; )
		BtShared *pList;
	int removed = 0;

	assert(sqlite3_mutex_notheld(pBt->mutex));
	MUTEX_LOGIC(pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )
		sqlite3_mutex_enter(pMaster);
	pBt->nRef--;
	if (pBt->nRef <= 0) {
		if (GLOBAL(BtShared*, sqlite3SharedCacheList) == pBt) {
			GLOBAL(BtShared*, sqlite3SharedCacheList) = pBt->pNext;
		}
		else {
			pList = GLOBAL(BtShared*, sqlite3SharedCacheList);
			while (ALWAYS(pList) && pList->pNext != pBt) {
				pList = pList->pNext;
			}
			if (ALWAYS(pList)) {
				pList->pNext = pBt->pNext;
			}
		}
		if (SQLITE_THREADSAFE) {
			sqlite3_mutex_free(pBt->mutex);
		}
		removed = 1;
	}
	sqlite3_mutex_leave(pMaster);
	return removed;
#else
	return 1;
#endif
}


static void allocateTempSpace(BtShared *pBt) {
	if (!pBt->pTmpSpace) {
		pBt->pTmpSpace = sqlite3PageMalloc(pBt->pageSize);

		
		if (pBt->pTmpSpace) {
			memset(pBt->pTmpSpace, 0, 8);
			pBt->pTmpSpace += 4;
		}
	}
}


static void freeTempSpace(BtShared *pBt) {
	if (pBt->pTmpSpace) {
		pBt->pTmpSpace -= 4;
		sqlite3PageFree(pBt->pTmpSpace);
		pBt->pTmpSpace = 0;
	}
}


SQLITE_PRIVATE int sqlite3BtreeClose(Btree *p) {
	BtShared *pBt = p->pBt;
	BtCursor *pCur;

	
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	pCur = pBt->pCursor;
	while (pCur) {
		BtCursor *pTmp = pCur;
		pCur = pCur->pNext;
		if (pTmp->pBtree == p) {
			sqlite3BtreeCloseCursor(pTmp);
		}
	}

	
	sqlite3BtreeRollback(p, SQLITE_OK, 0);
	sqlite3BtreeLeave(p);

	
	assert(p->wantToLock == 0 && p->locked == 0);
	if (!p->sharable || removeFromSharingList(pBt)) {
		
		assert(!pBt->pCursor);
		sqlite3PagerClose(pBt->pPager);
		if (pBt->xFreeSchema && pBt->pSchema) {
			pBt->xFreeSchema(pBt->pSchema);
		}
		sqlite3DbFree(0, pBt->pSchema);
		freeTempSpace(pBt);
		sqlite3_free(pBt);
	}

#ifndef SQLITE_OMIT_SHARED_CACHE
	assert(p->wantToLock == 0);
	assert(p->locked == 0);
	if (p->pPrev) p->pPrev->pNext = p->pNext;
	if (p->pNext) p->pNext->pPrev = p->pPrev;
#endif

	sqlite3_free(p);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree *p, int mxPage) {
	BtShared *pBt = p->pBt;
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	sqlite3PagerSetCachesize(pBt->pPager, mxPage);
	sqlite3BtreeLeave(p);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree *p, int mxPage) {
	BtShared *pBt = p->pBt;
	int res;
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);
	sqlite3BtreeLeave(p);
	return res;
}

#if SQLITE_MAX_MMAP_SIZE>0

SQLITE_PRIVATE int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap) {
	BtShared *pBt = p->pBt;
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);
	sqlite3BtreeLeave(p);
	return SQLITE_OK;
}
#endif 


#ifndef SQLITE_OMIT_PAGER_PRAGMAS
SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(
	Btree *p,              
	unsigned pgFlags       
) {
	BtShared *pBt = p->pBt;
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	sqlite3PagerSetFlags(pBt->pPager, pgFlags);
	sqlite3BtreeLeave(p);
	return SQLITE_OK;
}
#endif


SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix) {
	int rc = SQLITE_OK;
	BtShared *pBt = p->pBt;
	assert(nReserve >= -1 && nReserve <= 255);
	sqlite3BtreeEnter(p);
#if SQLITE_HAS_CODEC
	if (nReserve>pBt->optimalReserve) pBt->optimalReserve = (u8)nReserve;
#endif
	if (pBt->btsFlags & BTS_PAGESIZE_FIXED) {
		sqlite3BtreeLeave(p);
		return SQLITE_READONLY;
	}
	if (nReserve<0) {
		nReserve = pBt->pageSize - pBt->usableSize;
	}
	assert(nReserve >= 0 && nReserve <= 255);
	if (pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE &&
		((pageSize - 1)&pageSize) == 0) {
		assert((pageSize & 7) == 0);
		assert(!pBt->pCursor);
		pBt->pageSize = (u32)pageSize;
		freeTempSpace(pBt);
	}
	rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
	pBt->usableSize = pBt->pageSize - (u16)nReserve;
	if (iFix) pBt->btsFlags |= BTS_PAGESIZE_FIXED;
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree *p) {
	return p->pBt->pageSize;
}


SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p) {
	int n;
	assert(sqlite3_mutex_held(p->pBt->mutex));
	n = p->pBt->pageSize - p->pBt->usableSize;
	return n;
}


SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree *p) {
	int n;
	sqlite3BtreeEnter(p);
	n = sqlite3BtreeGetReserveNoMutex(p);
#ifdef SQLITE_HAS_CODEC
	if (n<p->pBt->optimalReserve) n = p->pBt->optimalReserve;
#endif
	sqlite3BtreeLeave(p);
	return n;
}



SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree *p, int mxPage) {
	int n;
	sqlite3BtreeEnter(p);
	n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);
	sqlite3BtreeLeave(p);
	return n;
}


SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree *p, int newFlag) {
	int b;
	if (p == 0) return 0;
	sqlite3BtreeEnter(p);
	if (newFlag >= 0) {
		p->pBt->btsFlags &= ~BTS_SECURE_DELETE;
		if (newFlag) p->pBt->btsFlags |= BTS_SECURE_DELETE;
	}
	b = (p->pBt->btsFlags & BTS_SECURE_DELETE) != 0;
	sqlite3BtreeLeave(p);
	return b;
}


SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum) {
#ifdef SQLITE_OMIT_AUTOVACUUM
	return SQLITE_READONLY;
#else
	BtShared *pBt = p->pBt;
	int rc = SQLITE_OK;
	u8 av = (u8)autoVacuum;

	sqlite3BtreeEnter(p);
	if ((pBt->btsFlags & BTS_PAGESIZE_FIXED) != 0 && (av ? 1 : 0) != pBt->autoVacuum) {
		rc = SQLITE_READONLY;
	}
	else {
		pBt->autoVacuum = av ? 1 : 0;
		pBt->incrVacuum = av == 2 ? 1 : 0;
	}
	sqlite3BtreeLeave(p);
	return rc;
#endif
}


SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *p) {
#ifdef SQLITE_OMIT_AUTOVACUUM
	return BTREE_AUTOVACUUM_NONE;
#else
	int rc;
	sqlite3BtreeEnter(p);
	rc = (
		(!p->pBt->autoVacuum) ? BTREE_AUTOVACUUM_NONE :
		(!p->pBt->incrVacuum) ? BTREE_AUTOVACUUM_FULL :
		BTREE_AUTOVACUUM_INCR
		);
	sqlite3BtreeLeave(p);
	return rc;
#endif
}



static int lockBtree(BtShared *pBt) {
	int rc;              
	MemPage *pPage1;     
	int nPage;           
	int nPageFile = 0;   
	int nPageHeader;     

	assert(sqlite3_mutex_held(pBt->mutex));
	assert(pBt->pPage1 == 0);
	rc = sqlite3PagerSharedLock(pBt->pPager);
	if (rc != SQLITE_OK) return rc;
	rc = btreeGetPage(pBt, 1, &pPage1, 0);
	if (rc != SQLITE_OK) return rc;

	
	nPage = nPageHeader = get4byte(28 + (u8*)pPage1->aData);
	sqlite3PagerPagecount(pBt->pPager, &nPageFile);
	if (nPage == 0 || memcmp(24 + (u8*)pPage1->aData, 92 + (u8*)pPage1->aData, 4) != 0) {
		nPage = nPageFile;
	}
	if (nPage>0) {
		u32 pageSize;
		u32 usableSize;
		u8 *page1 = pPage1->aData;
		rc = SQLITE_NOTADB;
		
		if (memcmp(page1, zMagicHeader, 16) != 0) {
			goto page1_init_failed;
		}

#ifdef SQLITE_OMIT_WAL
		if (page1[18]>1) {
			pBt->btsFlags |= BTS_READ_ONLY;
		}
		if (page1[19]>1) {
			goto page1_init_failed;
		}
#else
		if (page1[18]>2) {
			pBt->btsFlags |= BTS_READ_ONLY;
		}
		if (page1[19]>2) {
			goto page1_init_failed;
		}

		
		if (page1[19] == 2 && (pBt->btsFlags & BTS_NO_WAL) == 0) {
			int isOpen = 0;
			rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);
			if (rc != SQLITE_OK) {
				goto page1_init_failed;
			}
			else {
#if SQLITE_DEFAULT_SYNCHRONOUS!=SQLITE_DEFAULT_WAL_SYNCHRONOUS
				sqlite3 *db;
				Db *pDb;
				if ((db = pBt->db) != 0 && (pDb = db->aDb) != 0) {
					while (pDb->pBt == 0 || pDb->pBt->pBt != pBt) { pDb++; }
					if (pDb->bSyncSet == 0
						&& pDb->safety_level == SQLITE_DEFAULT_SYNCHRONOUS + 1
						) {
						pDb->safety_level = SQLITE_DEFAULT_WAL_SYNCHRONOUS + 1;
						sqlite3PagerSetFlags(pBt->pPager,
							pDb->safety_level | (db->flags & PAGER_FLAGS_MASK));
					}
				}
#endif
				if (isOpen == 0) {
					releasePage(pPage1);
					return SQLITE_OK;
				}
			}
			rc = SQLITE_NOTADB;
		}
#endif

		
		if (memcmp(&page1[21], "\100\040\040", 3) != 0) {
			goto page1_init_failed;
		}
		
		pageSize = (page1[16] << 8) | (page1[17] << 16);
		
		if (((pageSize - 1)&pageSize) != 0
			|| pageSize>SQLITE_MAX_PAGE_SIZE
			|| pageSize <= 256
			) {
			goto page1_init_failed;
		}
		assert((pageSize & 7) == 0);
		
		usableSize = pageSize - page1[20];
		if ((u32)pageSize != pBt->pageSize) {
			
			releasePage(pPage1);
			pBt->usableSize = usableSize;
			pBt->pageSize = pageSize;
			freeTempSpace(pBt);
			rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,
				pageSize - usableSize);
			return rc;
		}
		if ((pBt->db->flags & SQLITE_RecoveryMode) == 0 && nPage>nPageFile) {
			rc = SQLITE_CORRUPT_BKPT;
			goto page1_init_failed;
		}
		
		if (usableSize<480) {
			goto page1_init_failed;
		}
		pBt->pageSize = pageSize;
		pBt->usableSize = usableSize;
#ifndef SQLITE_OMIT_AUTOVACUUM
		pBt->autoVacuum = (get4byte(&page1[36 + 4 * 4]) ? 1 : 0);
		pBt->incrVacuum = (get4byte(&page1[36 + 7 * 4]) ? 1 : 0);
#endif
	}

	
	pBt->maxLocal = (u16)((pBt->usableSize - 12) * 64 / 255 - 23);
	pBt->minLocal = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);
	pBt->maxLeaf = (u16)(pBt->usableSize - 35);
	pBt->minLeaf = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);
	if (pBt->maxLocal>127) {
		pBt->max1bytePayload = 127;
	}
	else {
		pBt->max1bytePayload = (u8)pBt->maxLocal;
	}
	assert(pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt));
	pBt->pPage1 = pPage1;
	pBt->nPage = nPage;
	return SQLITE_OK;

page1_init_failed:
	releasePage(pPage1);
	pBt->pPage1 = 0;
	return rc;
}

#ifndef NDEBUG

static int countValidCursors(BtShared *pBt, int wrOnly) {
	BtCursor *pCur;
	int r = 0;
	for (pCur = pBt->pCursor; pCur; pCur = pCur->pNext) {
		if ((wrOnly == 0 || (pCur->curFlags & BTCF_WriteFlag) != 0)
			&& pCur->eState != CURSOR_FAULT) r++;
	}
	return r;
}
#endif


static void unlockBtreeIfUnused(BtShared *pBt) {
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(countValidCursors(pBt, 0) == 0 || pBt->inTransaction>TRANS_NONE);
	if (pBt->inTransaction == TRANS_NONE && pBt->pPage1 != 0) {
		MemPage *pPage1 = pBt->pPage1;
		assert(pPage1->aData);
		assert(sqlite3PagerRefcount(pBt->pPager) == 1);
		pBt->pPage1 = 0;
		releasePageNotNull(pPage1);
	}
}


static int newDatabase(BtShared *pBt) {
	MemPage *pP1;
	unsigned char *data;
	int rc;

	assert(sqlite3_mutex_held(pBt->mutex));
	if (pBt->nPage>0) {
		return SQLITE_OK;
	}
	pP1 = pBt->pPage1;
	assert(pP1 != 0);
	data = pP1->aData;
	rc = sqlite3PagerWrite(pP1->pDbPage);
	if (rc) return rc;
	memcpy(data, zMagicHeader, sizeof(zMagicHeader));
	assert(sizeof(zMagicHeader) == 16);
	data[16] = (u8)((pBt->pageSize >> 8) & 0xff);
	data[17] = (u8)((pBt->pageSize >> 16) & 0xff);
	data[18] = 1;
	data[19] = 1;
	assert(pBt->usableSize <= pBt->pageSize && pBt->usableSize + 255 >= pBt->pageSize);
	data[20] = (u8)(pBt->pageSize - pBt->usableSize);
	data[21] = 64;
	data[22] = 32;
	data[23] = 32;
	memset(&data[24], 0, 100 - 24);
	zeroPage(pP1, PTF_INTKEY | PTF_LEAF | PTF_LEAFDATA);
	pBt->btsFlags |= BTS_PAGESIZE_FIXED;
#ifndef SQLITE_OMIT_AUTOVACUUM
	assert(pBt->autoVacuum == 1 || pBt->autoVacuum == 0);
	assert(pBt->incrVacuum == 1 || pBt->incrVacuum == 0);
	put4byte(&data[36 + 4 * 4], pBt->autoVacuum);
	put4byte(&data[36 + 7 * 4], pBt->incrVacuum);
#endif
	pBt->nPage = 1;
	data[31] = 1;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p) {
	int rc;
	sqlite3BtreeEnter(p);
	p->pBt->nPage = 0;
	rc = newDatabase(p->pBt);
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag) {
	BtShared *pBt = p->pBt;
	int rc = SQLITE_OK;

	sqlite3BtreeEnter(p);
	btreeIntegrity(p);

	
	if (p->inTrans == TRANS_WRITE || (p->inTrans == TRANS_READ && !wrflag)) {
		goto trans_begun;
	}
	assert(pBt->inTransaction == TRANS_WRITE || IfNotOmitAV(pBt->bDoTruncate) == 0);

	
	if ((pBt->btsFlags & BTS_READ_ONLY) != 0 && wrflag) {
		rc = SQLITE_READONLY;
		goto trans_begun;
	}

#ifndef SQLITE_OMIT_SHARED_CACHE
	{
		sqlite3 *pBlock = 0;
		
		if ((wrflag && pBt->inTransaction == TRANS_WRITE)
			|| (pBt->btsFlags & BTS_PENDING) != 0
			) {
			pBlock = pBt->pWriter->db;
		}
		else if (wrflag>1) {
			BtLock *pIter;
			for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {
				if (pIter->pBtree != p) {
					pBlock = pIter->pBtree->db;
					break;
				}
			}
		}
		if (pBlock) {
			sqlite3ConnectionBlocked(p->db, pBlock);
			rc = SQLITE_LOCKED_SHAREDCACHE;
			goto trans_begun;
		}
	}
#endif

	
	rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);
	if (SQLITE_OK != rc) goto trans_begun;

	pBt->btsFlags &= ~BTS_INITIALLY_EMPTY;
	if (pBt->nPage == 0) pBt->btsFlags |= BTS_INITIALLY_EMPTY;
	do {
		
		while (pBt->pPage1 == 0 && SQLITE_OK == (rc = lockBtree(pBt)));

		if (rc == SQLITE_OK && wrflag) {
			if ((pBt->btsFlags & BTS_READ_ONLY) != 0) {
				rc = SQLITE_READONLY;
			}
			else {
				rc = sqlite3PagerBegin(pBt->pPager, wrflag>1, sqlite3TempInMemory(p->db));
				if (rc == SQLITE_OK) {
					rc = newDatabase(pBt);
				}
			}
		}

		if (rc != SQLITE_OK) {
			unlockBtreeIfUnused(pBt);
		}
	} while ((rc & 0xFF) == SQLITE_BUSY && pBt->inTransaction == TRANS_NONE &&
		btreeInvokeBusyHandler(pBt));

	if (rc == SQLITE_OK) {
		if (p->inTrans == TRANS_NONE) {
			pBt->nTransaction++;
#ifndef SQLITE_OMIT_SHARED_CACHE
			if (p->sharable) {
				assert(p->lock.pBtree == p && p->lock.iTable == 1);
				p->lock.eLock = READ_LOCK;
				p->lock.pNext = pBt->pLock;
				pBt->pLock = &p->lock;
			}
#endif
		}
		p->inTrans = (wrflag ? TRANS_WRITE : TRANS_READ);
		if (p->inTrans>pBt->inTransaction) {
			pBt->inTransaction = p->inTrans;
		}
		if (wrflag) {
			MemPage *pPage1 = pBt->pPage1;
#ifndef SQLITE_OMIT_SHARED_CACHE
			assert(!pBt->pWriter);
			pBt->pWriter = p;
			pBt->btsFlags &= ~BTS_EXCLUSIVE;
			if (wrflag>1) pBt->btsFlags |= BTS_EXCLUSIVE;
#endif

			
			if (pBt->nPage != get4byte(&pPage1->aData[28])) {
				rc = sqlite3PagerWrite(pPage1->pDbPage);
				if (rc == SQLITE_OK) {
					put4byte(&pPage1->aData[28], pBt->nPage);
				}
			}
		}
	}


trans_begun:
	if (rc == SQLITE_OK && wrflag) {
		
		rc = sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint);
	}

	btreeIntegrity(p);
	sqlite3BtreeLeave(p);
	return rc;
}

#ifndef SQLITE_OMIT_AUTOVACUUM


static int setChildPtrmaps(MemPage *pPage) {
	int i;                             
	int nCell;                         
	int rc;                            
	BtShared *pBt = pPage->pBt;
	u8 isInitOrig = pPage->isInit;
	Pgno pgno = pPage->pgno;

	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	rc = btreeInitPage(pPage);
	if (rc != SQLITE_OK) {
		goto set_child_ptrmaps_out;
	}
	nCell = pPage->nCell;

	for (i = 0; i<nCell; i++) {
		u8 *pCell = findCell(pPage, i);

		ptrmapPutOvflPtr(pPage, pCell, &rc);

		if (!pPage->leaf) {
			Pgno childPgno = get4byte(pCell);
			ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);
		}
	}

	if (!pPage->leaf) {
		Pgno childPgno = get4byte(&pPage->aData[pPage->hdrOffset + 8]);
		ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);
	}

set_child_ptrmaps_out:
	pPage->isInit = isInitOrig;
	return rc;
}


static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType) {
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	if (eType == PTRMAP_OVERFLOW2) {
		
		if (get4byte(pPage->aData) != iFrom) {
			return SQLITE_CORRUPT_BKPT;
		}
		put4byte(pPage->aData, iTo);
	}
	else {
		u8 isInitOrig = pPage->isInit;
		int i;
		int nCell;
		int rc;

		rc = btreeInitPage(pPage);
		if (rc) return rc;
		nCell = pPage->nCell;

		for (i = 0; i<nCell; i++) {
			u8 *pCell = findCell(pPage, i);
			if (eType == PTRMAP_OVERFLOW1) {
				CellInfo info;
				pPage->xParseCell(pPage, pCell, &info);
				if (info.nLocal<info.nPayload
					&& pCell + info.nSize - 1 <= pPage->aData + pPage->maskPage
					&& iFrom == get4byte(pCell + info.nSize - 4)
					) {
					put4byte(pCell + info.nSize - 4, iTo);
					break;
				}
			}
			else {
				if (get4byte(pCell) == iFrom) {
					put4byte(pCell, iTo);
					break;
				}
			}
		}

		if (i == nCell) {
			if (eType != PTRMAP_BTREE ||
				get4byte(&pPage->aData[pPage->hdrOffset + 8]) != iFrom) {
				return SQLITE_CORRUPT_BKPT;
			}
			put4byte(&pPage->aData[pPage->hdrOffset + 8], iTo);
		}

		pPage->isInit = isInitOrig;
	}
	return SQLITE_OK;
}



static int relocatePage(
	BtShared *pBt,           
	MemPage *pDbPage,        
	u8 eType,                
	Pgno iPtrPage,           
	Pgno iFreePage,          
	int isCommit             
) {
	MemPage *pPtrPage;   
	Pgno iDbPage = pDbPage->pgno;
	Pager *pPager = pBt->pPager;
	int rc;

	assert(eType == PTRMAP_OVERFLOW2 || eType == PTRMAP_OVERFLOW1 ||
		eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE);
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(pDbPage->pBt == pBt);

	
	TRACE(("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n",
		iDbPage, iFreePage, iPtrPage, eType));
	rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);
	if (rc != SQLITE_OK) {
		return rc;
	}
	pDbPage->pgno = iFreePage;

	
	if (eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE) {
		rc = setChildPtrmaps(pDbPage);
		if (rc != SQLITE_OK) {
			return rc;
		}
	}
	else {
		Pgno nextOvfl = get4byte(pDbPage->aData);
		if (nextOvfl != 0) {
			ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, &rc);
			if (rc != SQLITE_OK) {
				return rc;
			}
		}
	}

	
	if (eType != PTRMAP_ROOTPAGE) {
		rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);
		if (rc != SQLITE_OK) {
			return rc;
		}
		rc = sqlite3PagerWrite(pPtrPage->pDbPage);
		if (rc != SQLITE_OK) {
			releasePage(pPtrPage);
			return rc;
		}
		rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
		releasePage(pPtrPage);
		if (rc == SQLITE_OK) {
			ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);
		}
	}
	return rc;
}


static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);


static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit) {
	Pgno nFreeList;           
	int rc;

	assert(sqlite3_mutex_held(pBt->mutex));
	assert(iLastPg>nFin);

	if (!PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg != PENDING_BYTE_PAGE(pBt)) {
		u8 eType;
		Pgno iPtrPage;

		nFreeList = get4byte(&pBt->pPage1->aData[36]);
		if (nFreeList == 0) {
			return SQLITE_DONE;
		}

		rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
		if (rc != SQLITE_OK) {
			return rc;
		}
		if (eType == PTRMAP_ROOTPAGE) {
			return SQLITE_CORRUPT_BKPT;
		}

		if (eType == PTRMAP_FREEPAGE) {
			if (bCommit == 0) {
				
				Pgno iFreePg;
				MemPage *pFreePg;
				rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);
				if (rc != SQLITE_OK) {
					return rc;
				}
				assert(iFreePg == iLastPg);
				releasePage(pFreePg);
			}
		}
		else {
			Pgno iFreePg;             
			MemPage *pLastPg;
			u8 eMode = BTALLOC_ANY;   
			Pgno iNear = 0;           

			rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
			if (rc != SQLITE_OK) {
				return rc;
			}

			
			if (bCommit == 0) {
				eMode = BTALLOC_LE;
				iNear = nFin;
			}
			do {
				MemPage *pFreePg;
				rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
				if (rc != SQLITE_OK) {
					releasePage(pLastPg);
					return rc;
				}
				releasePage(pFreePg);
			} while (bCommit && iFreePg>nFin);
			assert(iFreePg<iLastPg);

			rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);
			releasePage(pLastPg);
			if (rc != SQLITE_OK) {
				return rc;
			}
		}
	}

	if (bCommit == 0) {
		do {
			iLastPg--;
		} while (iLastPg == PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg));
		pBt->bDoTruncate = 1;
		pBt->nPage = iLastPg;
	}
	return SQLITE_OK;
}


static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree) {
	int nEntry;                     
	Pgno nPtrmap;                   
	Pgno nFin;                      

	nEntry = pBt->usableSize / 5;
	nPtrmap = (nFree - nOrig + PTRMAP_PAGENO(pBt, nOrig) + nEntry) / nEntry;
	nFin = nOrig - nFree - nPtrmap;
	if (nOrig>PENDING_BYTE_PAGE(pBt) && nFin<PENDING_BYTE_PAGE(pBt)) {
		nFin--;
	}
	while (PTRMAP_ISPAGE(pBt, nFin) || nFin == PENDING_BYTE_PAGE(pBt)) {
		nFin--;
	}

	return nFin;
}


SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *p) {
	int rc;
	BtShared *pBt = p->pBt;

	sqlite3BtreeEnter(p);
	assert(pBt->inTransaction == TRANS_WRITE && p->inTrans == TRANS_WRITE);
	if (!pBt->autoVacuum) {
		rc = SQLITE_DONE;
	}
	else {
		Pgno nOrig = btreePagecount(pBt);
		Pgno nFree = get4byte(&pBt->pPage1->aData[36]);
		Pgno nFin = finalDbSize(pBt, nOrig, nFree);

		if (nOrig<nFin) {
			rc = SQLITE_CORRUPT_BKPT;
		}
		else if (nFree>0) {
			rc = saveAllCursors(pBt, 0, 0);
			if (rc == SQLITE_OK) {
				invalidateAllOverflowCache(pBt);
				rc = incrVacuumStep(pBt, nFin, nOrig, 0);
			}
			if (rc == SQLITE_OK) {
				rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
				put4byte(&pBt->pPage1->aData[28], pBt->nPage);
			}
		}
		else {
			rc = SQLITE_DONE;
		}
	}
	sqlite3BtreeLeave(p);
	return rc;
}


static int autoVacuumCommit(BtShared *pBt) {
	int rc = SQLITE_OK;
	Pager *pPager = pBt->pPager;
	VVA_ONLY(int nRef = sqlite3PagerRefcount(pPager); )

		assert(sqlite3_mutex_held(pBt->mutex));
	invalidateAllOverflowCache(pBt);
	assert(pBt->autoVacuum);
	if (!pBt->incrVacuum) {
		Pgno nFin;         
		Pgno nFree;        
		Pgno iFree;        
		Pgno nOrig;        

		nOrig = btreePagecount(pBt);
		if (PTRMAP_ISPAGE(pBt, nOrig) || nOrig == PENDING_BYTE_PAGE(pBt)) {
			
			return SQLITE_CORRUPT_BKPT;
		}

		nFree = get4byte(&pBt->pPage1->aData[36]);
		nFin = finalDbSize(pBt, nOrig, nFree);
		if (nFin>nOrig) return SQLITE_CORRUPT_BKPT;
		if (nFin<nOrig) {
			rc = saveAllCursors(pBt, 0, 0);
		}
		for (iFree = nOrig; iFree>nFin && rc == SQLITE_OK; iFree--) {
			rc = incrVacuumStep(pBt, nFin, iFree, 1);
		}
		if ((rc == SQLITE_DONE || rc == SQLITE_OK) && nFree>0) {
			rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
			put4byte(&pBt->pPage1->aData[32], 0);
			put4byte(&pBt->pPage1->aData[36], 0);
			put4byte(&pBt->pPage1->aData[28], nFin);
			pBt->bDoTruncate = 1;
			pBt->nPage = nFin;
		}
		if (rc != SQLITE_OK) {
			sqlite3PagerRollback(pPager);
		}
	}

	assert(nRef >= sqlite3PagerRefcount(pPager));
	return rc;
}

#else 
# define setChildPtrmaps(x) SQLITE_OK
#endif


SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster) {
	int rc = SQLITE_OK;
	if (p->inTrans == TRANS_WRITE) {
		BtShared *pBt = p->pBt;
		sqlite3BtreeEnter(p);
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (pBt->autoVacuum) {
			rc = autoVacuumCommit(pBt);
			if (rc != SQLITE_OK) {
				sqlite3BtreeLeave(p);
				return rc;
			}
		}
		if (pBt->bDoTruncate) {
			sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
		}
#endif
		rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
		sqlite3BtreeLeave(p);
	}
	return rc;
}


static void btreeEndTransaction(Btree *p) {
	BtShared *pBt = p->pBt;
	sqlite3 *db = p->db;
	assert(sqlite3BtreeHoldsMutex(p));

#ifndef SQLITE_OMIT_AUTOVACUUM
	pBt->bDoTruncate = 0;
#endif
	if (p->inTrans>TRANS_NONE && db->nVdbeRead>1) {
		
		downgradeAllSharedCacheTableLocks(p);
		p->inTrans = TRANS_READ;
	}
	else {
		
		if (p->inTrans != TRANS_NONE) {
			clearAllSharedCacheTableLocks(p);
			pBt->nTransaction--;
			if (0 == pBt->nTransaction) {
				pBt->inTransaction = TRANS_NONE;
			}
		}

		
		p->inTrans = TRANS_NONE;
		unlockBtreeIfUnused(pBt);
	}

	btreeIntegrity(p);
}


SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup) {

	if (p->inTrans == TRANS_NONE) return SQLITE_OK;
	sqlite3BtreeEnter(p);
	btreeIntegrity(p);

	
	if (p->inTrans == TRANS_WRITE) {
		int rc;
		BtShared *pBt = p->pBt;
		assert(pBt->inTransaction == TRANS_WRITE);
		assert(pBt->nTransaction>0);
		rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
		if (rc != SQLITE_OK && bCleanup == 0) {
			sqlite3BtreeLeave(p);
			return rc;
		}
		p->iDataVersion--;  
		pBt->inTransaction = TRANS_READ;
		btreeClearHasContent(pBt);
	}

	btreeEndTransaction(p);
	sqlite3BtreeLeave(p);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3BtreeCommit(Btree *p) {
	int rc;
	sqlite3BtreeEnter(p);
	rc = sqlite3BtreeCommitPhaseOne(p, 0);
	if (rc == SQLITE_OK) {
		rc = sqlite3BtreeCommitPhaseTwo(p, 0);
	}
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly) {
	BtCursor *p;
	int rc = SQLITE_OK;

	assert((writeOnly == 0 || writeOnly == 1) && BTCF_WriteFlag == 1);
	if (pBtree) {
		sqlite3BtreeEnter(pBtree);
		for (p = pBtree->pBt->pCursor; p; p = p->pNext) {
			int i;
			if (writeOnly && (p->curFlags & BTCF_WriteFlag) == 0) {
				if (p->eState == CURSOR_VALID || p->eState == CURSOR_SKIPNEXT) {
					rc = saveCursorPosition(p);
					if (rc != SQLITE_OK) {
						(void)sqlite3BtreeTripAllCursors(pBtree, rc, 0);
						break;
					}
				}
			}
			else {
				sqlite3BtreeClearCursor(p);
				p->eState = CURSOR_FAULT;
				p->skipNext = errCode;
			}
			for (i = 0; i <= p->iPage; i++) {
				releasePage(p->apPage[i]);
				p->apPage[i] = 0;
			}
		}
		sqlite3BtreeLeave(pBtree);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly) {
	int rc;
	BtShared *pBt = p->pBt;
	MemPage *pPage1;

	assert(writeOnly == 1 || writeOnly == 0);
	assert(tripCode == SQLITE_ABORT_ROLLBACK || tripCode == SQLITE_OK);
	sqlite3BtreeEnter(p);
	if (tripCode == SQLITE_OK) {
		rc = tripCode = saveAllCursors(pBt, 0, 0);
		if (rc) writeOnly = 0;
	}
	else {
		rc = SQLITE_OK;
	}
	if (tripCode) {
		int rc2 = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly);
		assert(rc == SQLITE_OK || (writeOnly == 0 && rc2 == SQLITE_OK));
		if (rc2 != SQLITE_OK) rc = rc2;
	}
	btreeIntegrity(p);

	if (p->inTrans == TRANS_WRITE) {
		int rc2;

		assert(TRANS_WRITE == pBt->inTransaction);
		rc2 = sqlite3PagerRollback(pBt->pPager);
		if (rc2 != SQLITE_OK) {
			rc = rc2;
		}

		
		if (btreeGetPage(pBt, 1, &pPage1, 0) == SQLITE_OK) {
			int nPage = get4byte(28 + (u8*)pPage1->aData);
			testcase(nPage == 0);
			if (nPage == 0) sqlite3PagerPagecount(pBt->pPager, &nPage);
			testcase(pBt->nPage != nPage);
			pBt->nPage = nPage;
			releasePage(pPage1);
		}
		assert(countValidCursors(pBt, 1) == 0);
		pBt->inTransaction = TRANS_READ;
		btreeClearHasContent(pBt);
	}

	btreeEndTransaction(p);
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree *p, int iStatement) {
	int rc;
	BtShared *pBt = p->pBt;
	sqlite3BtreeEnter(p);
	assert(p->inTrans == TRANS_WRITE);
	assert((pBt->btsFlags & BTS_READ_ONLY) == 0);
	assert(iStatement>0);
	assert(iStatement>p->db->nSavepoint);
	assert(pBt->inTransaction == TRANS_WRITE);
	
	rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint) {
	int rc = SQLITE_OK;
	if (p && p->inTrans == TRANS_WRITE) {
		BtShared *pBt = p->pBt;
		assert(op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK);
		assert(iSavepoint >= 0 || (iSavepoint == -1 && op == SAVEPOINT_ROLLBACK));
		sqlite3BtreeEnter(p);
		rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);
		if (rc == SQLITE_OK) {
			if (iSavepoint<0 && (pBt->btsFlags & BTS_INITIALLY_EMPTY) != 0) {
				pBt->nPage = 0;
			}
			rc = newDatabase(pBt);
			pBt->nPage = get4byte(28 + pBt->pPage1->aData);

			
			assert(pBt->nPage>0);
		}
		sqlite3BtreeLeave(p);
	}
	return rc;
}


static int btreeCursor(
	Btree *p,                              
	int iTable,                            
	int wrFlag,                            
	struct KeyInfo *pKeyInfo,              
	BtCursor *pCur                         
) {
	BtShared *pBt = p->pBt;                
	BtCursor *pX;                          

	assert(sqlite3BtreeHoldsMutex(p));
	assert(wrFlag == 0
		|| wrFlag == BTREE_WRCSR
		|| wrFlag == (BTREE_WRCSR | BTREE_FORDELETE)
	);

	
	assert(hasSharedCacheTableLock(p, iTable, pKeyInfo != 0, (wrFlag ? 2 : 1)));
	assert(wrFlag == 0 || !hasReadConflicts(p, iTable));

	
	assert(p->inTrans>TRANS_NONE);
	assert(wrFlag == 0 || p->inTrans == TRANS_WRITE);
	assert(pBt->pPage1 && pBt->pPage1->aData);
	assert(wrFlag == 0 || (pBt->btsFlags & BTS_READ_ONLY) == 0);

	if (wrFlag) {
		allocateTempSpace(pBt);
		if (pBt->pTmpSpace == 0) return SQLITE_NOMEM_BKPT;
	}
	if (iTable == 1 && btreePagecount(pBt) == 0) {
		assert(wrFlag == 0);
		iTable = 0;
	}

	
	pCur->pgnoRoot = (Pgno)iTable;
	pCur->iPage = -1;
	pCur->pKeyInfo = pKeyInfo;
	pCur->pBtree = p;
	pCur->pBt = pBt;
	pCur->curFlags = wrFlag ? BTCF_WriteFlag : 0;
	pCur->curPagerFlags = wrFlag ? 0 : PAGER_GET_READONLY;
	
	for (pX = pBt->pCursor; pX; pX = pX->pNext) {
		if (pX->pgnoRoot == (Pgno)iTable) {
			pX->curFlags |= BTCF_Multiple;
			pCur->curFlags |= BTCF_Multiple;
		}
	}
	pCur->pNext = pBt->pCursor;
	pBt->pCursor = pCur;
	pCur->eState = CURSOR_INVALID;
	return SQLITE_OK;
}
SQLITE_PRIVATE int sqlite3BtreeCursor(
	Btree *p,                                   
	int iTable,                                 
	int wrFlag,                                 
	struct KeyInfo *pKeyInfo,                   
	BtCursor *pCur                              
) {
	int rc;
	if (iTable<1) {
		rc = SQLITE_CORRUPT_BKPT;
	}
	else {
		sqlite3BtreeEnter(p);
		rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
		sqlite3BtreeLeave(p);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeCursorSize(void) {
	return ROUND8(sizeof(BtCursor));
}


SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor *p) {
	memset(p, 0, offsetof(BtCursor, iPage));
}


SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor *pCur) {
	Btree *pBtree = pCur->pBtree;
	if (pBtree) {
		int i;
		BtShared *pBt = pCur->pBt;
		sqlite3BtreeEnter(pBtree);
		sqlite3BtreeClearCursor(pCur);
		assert(pBt->pCursor != 0);
		if (pBt->pCursor == pCur) {
			pBt->pCursor = pCur->pNext;
		}
		else {
			BtCursor *pPrev = pBt->pCursor;
			do {
				if (pPrev->pNext == pCur) {
					pPrev->pNext = pCur->pNext;
					break;
				}
				pPrev = pPrev->pNext;
			} while (ALWAYS(pPrev));
		}
		for (i = 0; i <= pCur->iPage; i++) {
			releasePage(pCur->apPage[i]);
		}
		unlockBtreeIfUnused(pBt);
		sqlite3_free(pCur->aOverflow);
		
		sqlite3BtreeLeave(pBtree);
	}
	return SQLITE_OK;
}


#ifndef NDEBUG
static void assertCellInfo(BtCursor *pCur) {
	CellInfo info;
	int iPage = pCur->iPage;
	memset(&info, 0, sizeof(info));
	btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], &info);
	assert(CORRUPT_DB || memcmp(&info, &pCur->info, sizeof(info)) == 0);
}
#else
#define assertCellInfo(x)
#endif
static SQLITE_NOINLINE void getCellInfo(BtCursor *pCur) {
	if (pCur->info.nSize == 0) {
		int iPage = pCur->iPage;
		pCur->curFlags |= BTCF_ValidNKey;
		btreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], &pCur->info);
	}
	else {
		assertCellInfo(pCur);
	}
}

#ifndef NDEBUG  

SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor *pCur) {
	return pCur && pCur->eState == CURSOR_VALID;
}
#endif 


SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor *pCur) {
	assert(cursorHoldsMutex(pCur));
	assert(pCur->eState == CURSOR_VALID);
	assert(pCur->curIntKey);
	getCellInfo(pCur);
	return pCur->info.nKey;
}


SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor *pCur) {
	assert(cursorHoldsMutex(pCur));
	assert(pCur->eState == CURSOR_VALID);
	getCellInfo(pCur);
	return pCur->info.nPayload;
}


static int getOverflowPage(
	BtShared *pBt,               
	Pgno ovfl,                   
	MemPage **ppPage,            
	Pgno *pPgnoNext              
) {
	Pgno next = 0;
	MemPage *pPage = 0;
	int rc = SQLITE_OK;

	assert(sqlite3_mutex_held(pBt->mutex));
	assert(pPgnoNext);

#ifndef SQLITE_OMIT_AUTOVACUUM
	
	if (pBt->autoVacuum) {
		Pgno pgno;
		Pgno iGuess = ovfl + 1;
		u8 eType;

		while (PTRMAP_ISPAGE(pBt, iGuess) || iGuess == PENDING_BYTE_PAGE(pBt)) {
			iGuess++;
		}

		if (iGuess <= btreePagecount(pBt)) {
			rc = ptrmapGet(pBt, iGuess, &eType, &pgno);
			if (rc == SQLITE_OK && eType == PTRMAP_OVERFLOW2 && pgno == ovfl) {
				next = iGuess;
				rc = SQLITE_DONE;
			}
		}
	}
#endif

	assert(next == 0 || rc == SQLITE_DONE);
	if (rc == SQLITE_OK) {
		rc = btreeGetPage(pBt, ovfl, &pPage, (ppPage == 0) ? PAGER_GET_READONLY : 0);
		assert(rc == SQLITE_OK || pPage == 0);
		if (rc == SQLITE_OK) {
			next = get4byte(pPage->aData);
		}
	}

	*pPgnoNext = next;
	if (ppPage) {
		*ppPage = pPage;
	}
	else {
		releasePage(pPage);
	}
	return (rc == SQLITE_DONE ? SQLITE_OK : rc);
}


static int copyPayload(
	void *pPayload,           
	void *pBuf,               
	int nByte,                
	int eOp,                  
	DbPage *pDbPage           
) {
	if (eOp) {
		
		int rc = sqlite3PagerWrite(pDbPage);
		if (rc != SQLITE_OK) {
			return rc;
		}
		memcpy(pPayload, pBuf, nByte);
	}
	else {
		
		memcpy(pBuf, pPayload, nByte);
	}
	return SQLITE_OK;
}


static int accessPayload(
	BtCursor *pCur,      
	u32 offset,          
	u32 amt,             
	unsigned char *pBuf, 
	int eOp              
) {
	unsigned char *aPayload;
	int rc = SQLITE_OK;
	int iIdx = 0;
	MemPage *pPage = pCur->apPage[pCur->iPage]; 
	BtShared *pBt = pCur->pBt;                  
#ifdef SQLITE_DIRECT_OVERFLOW_READ
	unsigned char * const pBufStart = pBuf;
	int bEnd;                                 
#endif

	assert(pPage);
	assert(pCur->eState == CURSOR_VALID);
	assert(pCur->aiIdx[pCur->iPage]<pPage->nCell);
	assert(cursorHoldsMutex(pCur));
	assert(eOp != 2 || offset == 0);    

	getCellInfo(pCur);
	aPayload = pCur->info.pPayload;
#ifdef SQLITE_DIRECT_OVERFLOW_READ
	bEnd = offset + amt == pCur->info.nPayload;
#endif
	assert(offset + amt <= pCur->info.nPayload);

	assert(aPayload > pPage->aData);
	if ((uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal)) {
		
		return SQLITE_CORRUPT_BKPT;
	}

	
	if (offset<pCur->info.nLocal) {
		int a = amt;
		if (a + offset>pCur->info.nLocal) {
			a = pCur->info.nLocal - offset;
		}
		rc = copyPayload(&aPayload[offset], pBuf, a, (eOp & 0x01), pPage->pDbPage);
		offset = 0;
		pBuf += a;
		amt -= a;
	}
	else {
		offset -= pCur->info.nLocal;
	}


	if (rc == SQLITE_OK && amt>0) {
		const u32 ovflSize = pBt->usableSize - 4;  
		Pgno nextPage;

		nextPage = get4byte(&aPayload[pCur->info.nLocal]);

		
		if (eOp != 2 && (pCur->curFlags & BTCF_ValidOvfl) == 0) {
			int nOvfl = (pCur->info.nPayload - pCur->info.nLocal + ovflSize - 1) / ovflSize;
			if (nOvfl>pCur->nOvflAlloc) {
				Pgno *aNew = (Pgno*)sqlite3Realloc(
					pCur->aOverflow, nOvfl * 2 * sizeof(Pgno)
				);
				if (aNew == 0) {
					rc = SQLITE_NOMEM_BKPT;
				}
				else {
					pCur->nOvflAlloc = nOvfl * 2;
					pCur->aOverflow = aNew;
				}
			}
			if (rc == SQLITE_OK) {
				memset(pCur->aOverflow, 0, nOvfl * sizeof(Pgno));
				pCur->curFlags |= BTCF_ValidOvfl;
			}
		}

		
		if ((pCur->curFlags & BTCF_ValidOvfl) != 0
			&& pCur->aOverflow[offset / ovflSize]
			) {
			iIdx = (offset / ovflSize);
			nextPage = pCur->aOverflow[iIdx];
			offset = (offset%ovflSize);
		}

		for (; rc == SQLITE_OK && amt>0 && nextPage; iIdx++) {

			
			if ((pCur->curFlags & BTCF_ValidOvfl) != 0) {
				assert(pCur->aOverflow[iIdx] == 0
					|| pCur->aOverflow[iIdx] == nextPage
					|| CORRUPT_DB);
				pCur->aOverflow[iIdx] = nextPage;
			}

			if (offset >= ovflSize) {
				
				assert(eOp != 2);
				assert(pCur->curFlags & BTCF_ValidOvfl);
				assert(pCur->pBtree->db == pBt->db);
				if (pCur->aOverflow[iIdx + 1]) {
					nextPage = pCur->aOverflow[iIdx + 1];
				}
				else {
					rc = getOverflowPage(pBt, nextPage, 0, &nextPage);
				}
				offset -= ovflSize;
			}
			else {
				
#ifdef SQLITE_DIRECT_OVERFLOW_READ
				sqlite3_file *fd;
#endif
				int a = amt;
				if (a + offset > ovflSize) {
					a = ovflSize - offset;
				}

#ifdef SQLITE_DIRECT_OVERFLOW_READ
				
				if ((eOp & 0x01) == 0                                      
					&& offset == 0                                          
					&& (bEnd || a == ovflSize)                              
					&& pBt->inTransaction == TRANS_READ                     
					&& (fd = sqlite3PagerFile(pBt->pPager))->pMethods     
					&& 0 == sqlite3PagerUseWal(pBt->pPager)                 
					&& &pBuf[-4] >= pBufStart                               
					) {
					u8 aSave[4];
					u8 *aWrite = &pBuf[-4];
					assert(aWrite >= pBufStart);                         
					memcpy(aSave, aWrite, 4);
					rc = sqlite3OsRead(fd, aWrite, a + 4, (i64)pBt->pageSize*(nextPage - 1));
					nextPage = get4byte(aWrite);
					memcpy(aWrite, aSave, 4);
				}
				else
#endif

				{
					DbPage *pDbPage;
					rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,
						((eOp & 0x01) == 0 ? PAGER_GET_READONLY : 0)
					);
					if (rc == SQLITE_OK) {
						aPayload = sqlite3PagerGetData(pDbPage);
						nextPage = get4byte(aPayload);
						rc = copyPayload(&aPayload[offset + 4], pBuf, a, (eOp & 0x01), pDbPage);
						sqlite3PagerUnref(pDbPage);
						offset = 0;
					}
				}
				amt -= a;
				pBuf += a;
			}
		}
	}

	if (rc == SQLITE_OK && amt>0) {
		return SQLITE_CORRUPT_BKPT;
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf) {
	assert(cursorHoldsMutex(pCur));
	assert(pCur->eState == CURSOR_VALID);
	assert(pCur->iPage >= 0 && pCur->apPage[pCur->iPage]);
	assert(pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell);
	return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
}


SQLITE_PRIVATE int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf) {
	int rc;

#ifndef SQLITE_OMIT_INCRBLOB
	if (pCur->eState == CURSOR_INVALID) {
		return SQLITE_ABORT;
	}
#endif

	assert(cursorOwnsBtShared(pCur));
	rc = restoreCursorPosition(pCur);
	if (rc == SQLITE_OK) {
		assert(pCur->eState == CURSOR_VALID);
		assert(pCur->iPage >= 0 && pCur->apPage[pCur->iPage]);
		assert(pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell);
		rc = accessPayload(pCur, offset, amt, pBuf, 0);
	}
	return rc;
}


static const void *fetchPayload(
	BtCursor *pCur,      
	u32 *pAmt            
) {
	u32 amt;
	assert(pCur != 0 && pCur->iPage >= 0 && pCur->apPage[pCur->iPage]);
	assert(pCur->eState == CURSOR_VALID);
	assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));
	assert(cursorOwnsBtShared(pCur));
	assert(pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell);
	assert(pCur->info.nSize>0);
	assert(pCur->info.pPayload>pCur->apPage[pCur->iPage]->aData || CORRUPT_DB);
	assert(pCur->info.pPayload<pCur->apPage[pCur->iPage]->aDataEnd || CORRUPT_DB);
	amt = (int)(pCur->apPage[pCur->iPage]->aDataEnd - pCur->info.pPayload);
	if (pCur->info.nLocal<amt) amt = pCur->info.nLocal;
	*pAmt = amt;
	return (void*)pCur->info.pPayload;
}



SQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt) {
	return fetchPayload(pCur, pAmt);
}



static int moveToChild(BtCursor *pCur, u32 newPgno) {
	BtShared *pBt = pCur->pBt;

	assert(cursorOwnsBtShared(pCur));
	assert(pCur->eState == CURSOR_VALID);
	assert(pCur->iPage<BTCURSOR_MAX_DEPTH);
	assert(pCur->iPage >= 0);
	if (pCur->iPage >= (BTCURSOR_MAX_DEPTH - 1)) {
		return SQLITE_CORRUPT_BKPT;
	}
	pCur->info.nSize = 0;
	pCur->curFlags &= ~(BTCF_ValidNKey | BTCF_ValidOvfl);
	pCur->iPage++;
	pCur->aiIdx[pCur->iPage] = 0;
	return getAndInitPage(pBt, newPgno, &pCur->apPage[pCur->iPage],
		pCur, pCur->curPagerFlags);
}

#if SQLITE_DEBUG

static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild) {
	if (CORRUPT_DB) return;  
	assert(iIdx <= pParent->nCell);
	if (iIdx == pParent->nCell) {
		assert(get4byte(&pParent->aData[pParent->hdrOffset + 8]) == iChild);
	}
	else {
		assert(get4byte(findCell(pParent, iIdx)) == iChild);
	}
}
#else
#  define assertParentIndex(x,y,z) 
#endif


static void moveToParent(BtCursor *pCur) {
	assert(cursorOwnsBtShared(pCur));
	assert(pCur->eState == CURSOR_VALID);
	assert(pCur->iPage>0);
	assert(pCur->apPage[pCur->iPage]);
	assertParentIndex(
		pCur->apPage[pCur->iPage - 1],
		pCur->aiIdx[pCur->iPage - 1],
		pCur->apPage[pCur->iPage]->pgno
	);
	testcase(pCur->aiIdx[pCur->iPage - 1] > pCur->apPage[pCur->iPage - 1]->nCell);
	pCur->info.nSize = 0;
	pCur->curFlags &= ~(BTCF_ValidNKey | BTCF_ValidOvfl);
	releasePageNotNull(pCur->apPage[pCur->iPage--]);
}


static int moveToRoot(BtCursor *pCur) {
	MemPage *pRoot;
	int rc = SQLITE_OK;

	assert(cursorOwnsBtShared(pCur));
	assert(CURSOR_INVALID < CURSOR_REQUIRESEEK);
	assert(CURSOR_VALID   < CURSOR_REQUIRESEEK);
	assert(CURSOR_FAULT   > CURSOR_REQUIRESEEK);
	if (pCur->eState >= CURSOR_REQUIRESEEK) {
		if (pCur->eState == CURSOR_FAULT) {
			assert(pCur->skipNext != SQLITE_OK);
			return pCur->skipNext;
		}
		sqlite3BtreeClearCursor(pCur);
	}

	if (pCur->iPage >= 0) {
		while (pCur->iPage) {
			assert(pCur->apPage[pCur->iPage] != 0);
			releasePageNotNull(pCur->apPage[pCur->iPage--]);
		}
	}
	else if (pCur->pgnoRoot == 0) {
		pCur->eState = CURSOR_INVALID;
		return SQLITE_OK;
	}
	else {
		assert(pCur->iPage == (-1));
		rc = getAndInitPage(pCur->pBtree->pBt, pCur->pgnoRoot, &pCur->apPage[0],
			0, pCur->curPagerFlags);
		if (rc != SQLITE_OK) {
			pCur->eState = CURSOR_INVALID;
			return rc;
		}
		pCur->iPage = 0;
		pCur->curIntKey = pCur->apPage[0]->intKey;
	}
	pRoot = pCur->apPage[0];
	assert(pRoot->pgno == pCur->pgnoRoot);

	
	assert(pRoot->intKey == 1 || pRoot->intKey == 0);
	if (pRoot->isInit == 0 || (pCur->pKeyInfo == 0) != pRoot->intKey) {
		return SQLITE_CORRUPT_BKPT;
	}

	pCur->aiIdx[0] = 0;
	pCur->info.nSize = 0;
	pCur->curFlags &= ~(BTCF_AtLast | BTCF_ValidNKey | BTCF_ValidOvfl);

	if (pRoot->nCell>0) {
		pCur->eState = CURSOR_VALID;
	}
	else if (!pRoot->leaf) {
		Pgno subpage;
		if (pRoot->pgno != 1) return SQLITE_CORRUPT_BKPT;
		subpage = get4byte(&pRoot->aData[pRoot->hdrOffset + 8]);
		pCur->eState = CURSOR_VALID;
		rc = moveToChild(pCur, subpage);
	}
	else {
		pCur->eState = CURSOR_INVALID;
	}
	return rc;
}


static int moveToLeftmost(BtCursor *pCur) {
	Pgno pgno;
	int rc = SQLITE_OK;
	MemPage *pPage;

	assert(cursorOwnsBtShared(pCur));
	assert(pCur->eState == CURSOR_VALID);
	while (rc == SQLITE_OK && !(pPage = pCur->apPage[pCur->iPage])->leaf) {
		assert(pCur->aiIdx[pCur->iPage]<pPage->nCell);
		pgno = get4byte(findCell(pPage, pCur->aiIdx[pCur->iPage]));
		rc = moveToChild(pCur, pgno);
	}
	return rc;
}


static int moveToRightmost(BtCursor *pCur) {
	Pgno pgno;
	int rc = SQLITE_OK;
	MemPage *pPage = 0;

	assert(cursorOwnsBtShared(pCur));
	assert(pCur->eState == CURSOR_VALID);
	while (!(pPage = pCur->apPage[pCur->iPage])->leaf) {
		pgno = get4byte(&pPage->aData[pPage->hdrOffset + 8]);
		pCur->aiIdx[pCur->iPage] = pPage->nCell;
		rc = moveToChild(pCur, pgno);
		if (rc) return rc;
	}
	pCur->aiIdx[pCur->iPage] = pPage->nCell - 1;
	assert(pCur->info.nSize == 0);
	assert((pCur->curFlags & BTCF_ValidNKey) == 0);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes) {
	int rc;

	assert(cursorOwnsBtShared(pCur));
	assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));
	rc = moveToRoot(pCur);
	if (rc == SQLITE_OK) {
		if (pCur->eState == CURSOR_INVALID) {
			assert(pCur->pgnoRoot == 0 || pCur->apPage[pCur->iPage]->nCell == 0);
			*pRes = 1;
		}
		else {
			assert(pCur->apPage[pCur->iPage]->nCell>0);
			*pRes = 0;
			rc = moveToLeftmost(pCur);
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor *pCur, int *pRes) {
	int rc;

	assert(cursorOwnsBtShared(pCur));
	assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));

	
	if (CURSOR_VALID == pCur->eState && (pCur->curFlags & BTCF_AtLast) != 0) {
#ifdef SQLITE_DEBUG
		
		int ii;
		for (ii = 0; ii<pCur->iPage; ii++) {
			assert(pCur->aiIdx[ii] == pCur->apPage[ii]->nCell);
		}
		assert(pCur->aiIdx[pCur->iPage] == pCur->apPage[pCur->iPage]->nCell - 1);
		assert(pCur->apPage[pCur->iPage]->leaf);
#endif
		return SQLITE_OK;
	}

	rc = moveToRoot(pCur);
	if (rc == SQLITE_OK) {
		if (CURSOR_INVALID == pCur->eState) {
			assert(pCur->pgnoRoot == 0 || pCur->apPage[pCur->iPage]->nCell == 0);
			*pRes = 1;
		}
		else {
			assert(pCur->eState == CURSOR_VALID);
			*pRes = 0;
			rc = moveToRightmost(pCur);
			if (rc == SQLITE_OK) {
				pCur->curFlags |= BTCF_AtLast;
			}
			else {
				pCur->curFlags &= ~BTCF_AtLast;
			}

		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
	BtCursor *pCur,          
	UnpackedRecord *pIdxKey, 
	i64 intKey,              
	int biasRight,           
	int *pRes                
) {
	int rc;
	RecordCompare xRecordCompare;

	assert(cursorOwnsBtShared(pCur));
	assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));
	assert(pRes);
	assert((pIdxKey == 0) == (pCur->pKeyInfo == 0));
	assert(pCur->eState != CURSOR_VALID || (pIdxKey == 0) == (pCur->curIntKey != 0));

	
	if (pIdxKey == 0
		&& pCur->eState == CURSOR_VALID && (pCur->curFlags & BTCF_ValidNKey) != 0
		) {
		if (pCur->info.nKey == intKey) {
			*pRes = 0;
			return SQLITE_OK;
		}
		if ((pCur->curFlags & BTCF_AtLast) != 0 && pCur->info.nKey<intKey) {
			*pRes = -1;
			return SQLITE_OK;
		}
	}

	if (pIdxKey) {
		xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
		pIdxKey->errCode = 0;
		assert(pIdxKey->default_rc == 1
			|| pIdxKey->default_rc == 0
			|| pIdxKey->default_rc == -1
		);
	}
	else {
		xRecordCompare = 0; 
	}

	rc = moveToRoot(pCur);
	if (rc) {
		return rc;
	}
	assert(pCur->pgnoRoot == 0 || pCur->apPage[pCur->iPage]);
	assert(pCur->pgnoRoot == 0 || pCur->apPage[pCur->iPage]->isInit);
	assert(pCur->eState == CURSOR_INVALID || pCur->apPage[pCur->iPage]->nCell>0);
	if (pCur->eState == CURSOR_INVALID) {
		*pRes = -1;
		assert(pCur->pgnoRoot == 0 || pCur->apPage[pCur->iPage]->nCell == 0);
		return SQLITE_OK;
	}
	assert(pCur->apPage[0]->intKey == pCur->curIntKey);
	assert(pCur->curIntKey || pIdxKey);
	for (;;) {
		int lwr, upr, idx, c;
		Pgno chldPg;
		MemPage *pPage = pCur->apPage[pCur->iPage];
		u8 *pCell;                          

											
		assert(pPage->nCell>0);
		assert(pPage->intKey == (pIdxKey == 0));
		lwr = 0;
		upr = pPage->nCell - 1;
		assert(biasRight == 0 || biasRight == 1);
		idx = upr >> (1 - biasRight); 
		pCur->aiIdx[pCur->iPage] = (u16)idx;
		if (xRecordCompare == 0) {
			for (;;) {
				i64 nCellKey;
				pCell = findCellPastPtr(pPage, idx);
				if (pPage->intKeyLeaf) {
					while (0x80 <= *(pCell++)) {
						if (pCell >= pPage->aDataEnd) return SQLITE_CORRUPT_BKPT;
					}
				}
				getVarint(pCell, (u64*)&nCellKey);
				if (nCellKey<intKey) {
					lwr = idx + 1;
					if (lwr>upr) { c = -1; break; }
				}
				else if (nCellKey>intKey) {
					upr = idx - 1;
					if (lwr>upr) { c = +1; break; }
				}
				else {
					assert(nCellKey == intKey);
					pCur->curFlags |= BTCF_ValidNKey;
					pCur->info.nKey = nCellKey;
					pCur->aiIdx[pCur->iPage] = (u16)idx;
					if (!pPage->leaf) {
						lwr = idx;
						goto moveto_next_layer;
					}
					else {
						*pRes = 0;
						rc = SQLITE_OK;
						goto moveto_finish;
					}
				}
				assert(lwr + upr >= 0);
				idx = (lwr + upr) >> 1;  
			}
		}
		else {
			for (;;) {
				int nCell;  
				pCell = findCellPastPtr(pPage, idx);

				
				nCell = pCell[0];
				if (nCell <= pPage->max1bytePayload) {
					
					testcase(pCell + nCell + 1 == pPage->aDataEnd);
					c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);
				}
				else if (!(pCell[1] & 0x80)
					&& (nCell = ((nCell & 0x7f) << 7) + pCell[1]) <= pPage->maxLocal
					) {
					
					testcase(pCell + nCell + 2 == pPage->aDataEnd);
					c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);
				}
				else {
					
					void *pCellKey;
					u8 * const pCellBody = pCell - pPage->childPtrSize;
					pPage->xParseCell(pPage, pCellBody, &pCur->info);
					nCell = (int)pCur->info.nKey;
					testcase(nCell<0);   
					testcase(nCell == 0);  
					testcase(nCell == 1);  
					testcase(nCell == 2);  
					if (nCell<2) {
						rc = SQLITE_CORRUPT_BKPT;
						goto moveto_finish;
					}
					pCellKey = sqlite3Malloc(nCell + 18);
					if (pCellKey == 0) {
						rc = SQLITE_NOMEM_BKPT;
						goto moveto_finish;
					}
					pCur->aiIdx[pCur->iPage] = (u16)idx;
					rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 2);
					if (rc) {
						sqlite3_free(pCellKey);
						goto moveto_finish;
					}
					c = xRecordCompare(nCell, pCellKey, pIdxKey);
					sqlite3_free(pCellKey);
				}
				assert(
					(pIdxKey->errCode != SQLITE_CORRUPT || c == 0)
					&& (pIdxKey->errCode != SQLITE_NOMEM || pCur->pBtree->db->mallocFailed)
				);
				if (c<0) {
					lwr = idx + 1;
				}
				else if (c>0) {
					upr = idx - 1;
				}
				else {
					assert(c == 0);
					*pRes = 0;
					rc = SQLITE_OK;
					pCur->aiIdx[pCur->iPage] = (u16)idx;
					if (pIdxKey->errCode) rc = SQLITE_CORRUPT;
					goto moveto_finish;
				}
				if (lwr>upr) break;
				assert(lwr + upr >= 0);
				idx = (lwr + upr) >> 1;  
			}
		}
		assert(lwr == upr + 1 || (pPage->intKey && !pPage->leaf));
		assert(pPage->isInit);
		if (pPage->leaf) {
			assert(pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell);
			pCur->aiIdx[pCur->iPage] = (u16)idx;
			*pRes = c;
			rc = SQLITE_OK;
			goto moveto_finish;
		}
	moveto_next_layer:
		if (lwr >= pPage->nCell) {
			chldPg = get4byte(&pPage->aData[pPage->hdrOffset + 8]);
		}
		else {
			chldPg = get4byte(findCell(pPage, lwr));
		}
		pCur->aiIdx[pCur->iPage] = (u16)lwr;
		rc = moveToChild(pCur, chldPg);
		if (rc) break;
	}
moveto_finish:
	pCur->info.nSize = 0;
	pCur->curFlags &= ~(BTCF_ValidNKey | BTCF_ValidOvfl);
	return rc;
}



SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor *pCur) {
	
	return (CURSOR_VALID != pCur->eState);
}


static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes) {
	int rc;
	int idx;
	MemPage *pPage;

	assert(cursorOwnsBtShared(pCur));
	assert(pCur->skipNext == 0 || pCur->eState != CURSOR_VALID);
	assert(*pRes == 0);
	if (pCur->eState != CURSOR_VALID) {
		assert((pCur->curFlags & BTCF_ValidOvfl) == 0);
		rc = restoreCursorPosition(pCur);
		if (rc != SQLITE_OK) {
			return rc;
		}
		if (CURSOR_INVALID == pCur->eState) {
			*pRes = 1;
			return SQLITE_OK;
		}
		if (pCur->skipNext) {
			assert(pCur->eState == CURSOR_VALID || pCur->eState == CURSOR_SKIPNEXT);
			pCur->eState = CURSOR_VALID;
			if (pCur->skipNext>0) {
				pCur->skipNext = 0;
				return SQLITE_OK;
			}
			pCur->skipNext = 0;
		}
	}

	pPage = pCur->apPage[pCur->iPage];
	idx = ++pCur->aiIdx[pCur->iPage];
	assert(pPage->isInit);

	
	testcase(idx>pPage->nCell);

	if (idx >= pPage->nCell) {
		if (!pPage->leaf) {
			rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset + 8]));
			if (rc) return rc;
			return moveToLeftmost(pCur);
		}
		do {
			if (pCur->iPage == 0) {
				*pRes = 1;
				pCur->eState = CURSOR_INVALID;
				return SQLITE_OK;
			}
			moveToParent(pCur);
			pPage = pCur->apPage[pCur->iPage];
		} while (pCur->aiIdx[pCur->iPage] >= pPage->nCell);
		if (pPage->intKey) {
			return sqlite3BtreeNext(pCur, pRes);
		}
		else {
			return SQLITE_OK;
		}
	}
	if (pPage->leaf) {
		return SQLITE_OK;
	}
	else {
		return moveToLeftmost(pCur);
	}
}
SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes) {
	MemPage *pPage;
	assert(cursorOwnsBtShared(pCur));
	assert(pRes != 0);
	assert(*pRes == 0 || *pRes == 1);
	assert(pCur->skipNext == 0 || pCur->eState != CURSOR_VALID);
	pCur->info.nSize = 0;
	pCur->curFlags &= ~(BTCF_ValidNKey | BTCF_ValidOvfl);
	*pRes = 0;
	if (pCur->eState != CURSOR_VALID) return btreeNext(pCur, pRes);
	pPage = pCur->apPage[pCur->iPage];
	if ((++pCur->aiIdx[pCur->iPage]) >= pPage->nCell) {
		pCur->aiIdx[pCur->iPage]--;
		return btreeNext(pCur, pRes);
	}
	if (pPage->leaf) {
		return SQLITE_OK;
	}
	else {
		return moveToLeftmost(pCur);
	}
}


static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes) {
	int rc;
	MemPage *pPage;

	assert(cursorOwnsBtShared(pCur));
	assert(pRes != 0);
	assert(*pRes == 0);
	assert(pCur->skipNext == 0 || pCur->eState != CURSOR_VALID);
	assert((pCur->curFlags & (BTCF_AtLast | BTCF_ValidOvfl | BTCF_ValidNKey)) == 0);
	assert(pCur->info.nSize == 0);
	if (pCur->eState != CURSOR_VALID) {
		rc = restoreCursorPosition(pCur);
		if (rc != SQLITE_OK) {
			return rc;
		}
		if (CURSOR_INVALID == pCur->eState) {
			*pRes = 1;
			return SQLITE_OK;
		}
		if (pCur->skipNext) {
			assert(pCur->eState == CURSOR_VALID || pCur->eState == CURSOR_SKIPNEXT);
			pCur->eState = CURSOR_VALID;
			if (pCur->skipNext<0) {
				pCur->skipNext = 0;
				return SQLITE_OK;
			}
			pCur->skipNext = 0;
		}
	}

	pPage = pCur->apPage[pCur->iPage];
	assert(pPage->isInit);
	if (!pPage->leaf) {
		int idx = pCur->aiIdx[pCur->iPage];
		rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));
		if (rc) return rc;
		rc = moveToRightmost(pCur);
	}
	else {
		while (pCur->aiIdx[pCur->iPage] == 0) {
			if (pCur->iPage == 0) {
				pCur->eState = CURSOR_INVALID;
				*pRes = 1;
				return SQLITE_OK;
			}
			moveToParent(pCur);
		}
		assert(pCur->info.nSize == 0);
		assert((pCur->curFlags & (BTCF_ValidNKey | BTCF_ValidOvfl)) == 0);

		pCur->aiIdx[pCur->iPage]--;
		pPage = pCur->apPage[pCur->iPage];
		if (pPage->intKey && !pPage->leaf) {
			rc = sqlite3BtreePrevious(pCur, pRes);
		}
		else {
			rc = SQLITE_OK;
		}
	}
	return rc;
}
SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int *pRes) {
	assert(cursorOwnsBtShared(pCur));
	assert(pRes != 0);
	assert(*pRes == 0 || *pRes == 1);
	assert(pCur->skipNext == 0 || pCur->eState != CURSOR_VALID);
	*pRes = 0;
	pCur->curFlags &= ~(BTCF_AtLast | BTCF_ValidOvfl | BTCF_ValidNKey);
	pCur->info.nSize = 0;
	if (pCur->eState != CURSOR_VALID
		|| pCur->aiIdx[pCur->iPage] == 0
		|| pCur->apPage[pCur->iPage]->leaf == 0
		) {
		return btreePrevious(pCur, pRes);
	}
	pCur->aiIdx[pCur->iPage]--;
	return SQLITE_OK;
}


static int allocateBtreePage(
	BtShared *pBt,         
	MemPage **ppPage,      
	Pgno *pPgno,           
	Pgno nearby,           
	u8 eMode               
) {
	MemPage *pPage1;
	int rc;
	u32 n;     
	u32 k;     
	MemPage *pTrunk = 0;
	MemPage *pPrevTrunk = 0;
	Pgno mxPage;     

	assert(sqlite3_mutex_held(pBt->mutex));
	assert(eMode == BTALLOC_ANY || (nearby>0 && IfNotOmitAV(pBt->autoVacuum)));
	pPage1 = pBt->pPage1;
	mxPage = btreePagecount(pBt);
	
	n = get4byte(&pPage1->aData[36]);
	testcase(n == mxPage - 1);
	if (n >= mxPage) {
		return SQLITE_CORRUPT_BKPT;
	}
	if (n>0) {
		
		Pgno iTrunk;
		u8 searchList = 0; 
		u32 nSearch = 0;   

						   
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (eMode == BTALLOC_EXACT) {
			if (nearby <= mxPage) {
				u8 eType;
				assert(nearby>0);
				assert(pBt->autoVacuum);
				rc = ptrmapGet(pBt, nearby, &eType, 0);
				if (rc) return rc;
				if (eType == PTRMAP_FREEPAGE) {
					searchList = 1;
				}
			}
		}
		else if (eMode == BTALLOC_LE) {
			searchList = 1;
		}
#endif

		
		rc = sqlite3PagerWrite(pPage1->pDbPage);
		if (rc) return rc;
		put4byte(&pPage1->aData[36], n - 1);

		
		do {
			pPrevTrunk = pTrunk;
			if (pPrevTrunk) {
				
				iTrunk = get4byte(&pPrevTrunk->aData[0]);
			}
			else {
				
				iTrunk = get4byte(&pPage1->aData[32]);
			}
			testcase(iTrunk == mxPage);
			if (iTrunk>mxPage || nSearch++ > n) {
				rc = SQLITE_CORRUPT_BKPT;
			}
			else {
				rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);
			}
			if (rc) {
				pTrunk = 0;
				goto end_allocate_page;
			}
			assert(pTrunk != 0);
			assert(pTrunk->aData != 0);
			
			k = get4byte(&pTrunk->aData[4]);
			if (k == 0 && !searchList) {
				
				assert(pPrevTrunk == 0);
				rc = sqlite3PagerWrite(pTrunk->pDbPage);
				if (rc) {
					goto end_allocate_page;
				}
				*pPgno = iTrunk;
				memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
				*ppPage = pTrunk;
				pTrunk = 0;
				TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n - 1));
			}
			else if (k>(u32)(pBt->usableSize / 4 - 2)) {
				
				rc = SQLITE_CORRUPT_BKPT;
				goto end_allocate_page;
#ifndef SQLITE_OMIT_AUTOVACUUM
			}
			else if (searchList
				&& (nearby == iTrunk || (iTrunk<nearby && eMode == BTALLOC_LE))
				) {
				
				*pPgno = iTrunk;
				*ppPage = pTrunk;
				searchList = 0;
				rc = sqlite3PagerWrite(pTrunk->pDbPage);
				if (rc) {
					goto end_allocate_page;
				}
				if (k == 0) {
					if (!pPrevTrunk) {
						memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
					}
					else {
						rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
						if (rc != SQLITE_OK) {
							goto end_allocate_page;
						}
						memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
					}
				}
				else {
					
					MemPage *pNewTrunk;
					Pgno iNewTrunk = get4byte(&pTrunk->aData[8]);
					if (iNewTrunk>mxPage) {
						rc = SQLITE_CORRUPT_BKPT;
						goto end_allocate_page;
					}
					testcase(iNewTrunk == mxPage);
					rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);
					if (rc != SQLITE_OK) {
						goto end_allocate_page;
					}
					rc = sqlite3PagerWrite(pNewTrunk->pDbPage);
					if (rc != SQLITE_OK) {
						releasePage(pNewTrunk);
						goto end_allocate_page;
					}
					memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
					put4byte(&pNewTrunk->aData[4], k - 1);
					memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k - 1) * 4);
					releasePage(pNewTrunk);
					if (!pPrevTrunk) {
						assert(sqlite3PagerIswriteable(pPage1->pDbPage));
						put4byte(&pPage1->aData[32], iNewTrunk);
					}
					else {
						rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
						if (rc) {
							goto end_allocate_page;
						}
						put4byte(&pPrevTrunk->aData[0], iNewTrunk);
					}
				}
				pTrunk = 0;
				TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n - 1));
#endif
			}
			else if (k>0) {
				
				u32 closest;
				Pgno iPage;
				unsigned char *aData = pTrunk->aData;
				if (nearby>0) {
					u32 i;
					closest = 0;
					if (eMode == BTALLOC_LE) {
						for (i = 0; i<k; i++) {
							iPage = get4byte(&aData[8 + i * 4]);
							if (iPage <= nearby) {
								closest = i;
								break;
							}
						}
					}
					else {
						int dist;
						dist = sqlite3AbsInt32(get4byte(&aData[8]) - nearby);
						for (i = 1; i<k; i++) {
							int d2 = sqlite3AbsInt32(get4byte(&aData[8 + i * 4]) - nearby);
							if (d2<dist) {
								closest = i;
								dist = d2;
							}
						}
					}
				}
				else {
					closest = 0;
				}

				iPage = get4byte(&aData[8 + closest * 4]);
				testcase(iPage == mxPage);
				if (iPage>mxPage) {
					rc = SQLITE_CORRUPT_BKPT;
					goto end_allocate_page;
				}
				testcase(iPage == mxPage);
				if (!searchList
					|| (iPage == nearby || (iPage<nearby && eMode == BTALLOC_LE))
					) {
					int noContent;
					*pPgno = iPage;
					TRACE(("ALLOCATE: %d was leaf %d of %d on trunk %d"
						": %d more free pages\n",
						*pPgno, closest + 1, k, pTrunk->pgno, n - 1));
					rc = sqlite3PagerWrite(pTrunk->pDbPage);
					if (rc) goto end_allocate_page;
					if (closest<k - 1) {
						memcpy(&aData[8 + closest * 4], &aData[4 + k * 4], 4);
					}
					put4byte(&aData[4], k - 1);
					noContent = !btreeGetHasContent(pBt, *pPgno) ? PAGER_GET_NOCONTENT : 0;
					rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);
					if (rc == SQLITE_OK) {
						rc = sqlite3PagerWrite((*ppPage)->pDbPage);
						if (rc != SQLITE_OK) {
							releasePage(*ppPage);
							*ppPage = 0;
						}
					}
					searchList = 0;
				}
			}
			releasePage(pPrevTrunk);
			pPrevTrunk = 0;
		} while (searchList);
	}
	else {
		
		int bNoContent = (0 == IfNotOmitAV(pBt->bDoTruncate)) ? PAGER_GET_NOCONTENT : 0;

		rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
		if (rc) return rc;
		pBt->nPage++;
		if (pBt->nPage == PENDING_BYTE_PAGE(pBt)) pBt->nPage++;

#ifndef SQLITE_OMIT_AUTOVACUUM
		if (pBt->autoVacuum && PTRMAP_ISPAGE(pBt, pBt->nPage)) {
			
			MemPage *pPg = 0;
			TRACE(("ALLOCATE: %d from end of file (pointer-map page)\n", pBt->nPage));
			assert(pBt->nPage != PENDING_BYTE_PAGE(pBt));
			rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);
			if (rc == SQLITE_OK) {
				rc = sqlite3PagerWrite(pPg->pDbPage);
				releasePage(pPg);
			}
			if (rc) return rc;
			pBt->nPage++;
			if (pBt->nPage == PENDING_BYTE_PAGE(pBt)) { pBt->nPage++; }
		}
#endif
		put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);
		*pPgno = pBt->nPage;

		assert(*pPgno != PENDING_BYTE_PAGE(pBt));
		rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);
		if (rc) return rc;
		rc = sqlite3PagerWrite((*ppPage)->pDbPage);
		if (rc != SQLITE_OK) {
			releasePage(*ppPage);
			*ppPage = 0;
		}
		TRACE(("ALLOCATE: %d from end of file\n", *pPgno));
	}

	assert(*pPgno != PENDING_BYTE_PAGE(pBt));

end_allocate_page:
	releasePage(pTrunk);
	releasePage(pPrevTrunk);
	assert(rc != SQLITE_OK || sqlite3PagerPageRefcount((*ppPage)->pDbPage) <= 1);
	assert(rc != SQLITE_OK || (*ppPage)->isInit == 0);
	return rc;
}


static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage) {
	MemPage *pTrunk = 0;                
	Pgno iTrunk = 0;                    
	MemPage *pPage1 = pBt->pPage1;      
	MemPage *pPage;                     
	int rc;                             
	int nFree;                          

	assert(sqlite3_mutex_held(pBt->mutex));
	assert(CORRUPT_DB || iPage>1);
	assert(!pMemPage || pMemPage->pgno == iPage);

	if (iPage<2) return SQLITE_CORRUPT_BKPT;
	if (pMemPage) {
		pPage = pMemPage;
		sqlite3PagerRef(pPage->pDbPage);
	}
	else {
		pPage = btreePageLookup(pBt, iPage);
	}

	
	rc = sqlite3PagerWrite(pPage1->pDbPage);
	if (rc) goto freepage_out;
	nFree = get4byte(&pPage1->aData[36]);
	put4byte(&pPage1->aData[36], nFree + 1);

	if (pBt->btsFlags & BTS_SECURE_DELETE) {
		
		if ((!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0))
			|| ((rc = sqlite3PagerWrite(pPage->pDbPage)) != 0)
			) {
			goto freepage_out;
		}
		memset(pPage->aData, 0, pPage->pBt->pageSize);
	}

	
	if (ISAUTOVACUUM) {
		ptrmapPut(pBt, iPage, PTRMAP_FREEPAGE, 0, &rc);
		if (rc) goto freepage_out;
	}

	
	if (nFree != 0) {
		u32 nLeaf;                

		iTrunk = get4byte(&pPage1->aData[32]);
		rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);
		if (rc != SQLITE_OK) {
			goto freepage_out;
		}

		nLeaf = get4byte(&pTrunk->aData[4]);
		assert(pBt->usableSize>32);
		if (nLeaf > (u32)pBt->usableSize / 4 - 2) {
			rc = SQLITE_CORRUPT_BKPT;
			goto freepage_out;
		}
		if (nLeaf < (u32)pBt->usableSize / 4 - 8) {
			
			rc = sqlite3PagerWrite(pTrunk->pDbPage);
			if (rc == SQLITE_OK) {
				put4byte(&pTrunk->aData[4], nLeaf + 1);
				put4byte(&pTrunk->aData[8 + nLeaf * 4], iPage);
				if (pPage && (pBt->btsFlags & BTS_SECURE_DELETE) == 0) {
					sqlite3PagerDontWrite(pPage->pDbPage);
				}
				rc = btreeSetHasContent(pBt, iPage);
			}
			TRACE(("FREE-PAGE: %d leaf on trunk page %d\n", pPage->pgno, pTrunk->pgno));
			goto freepage_out;
		}
	}

	
	if (pPage == 0 && SQLITE_OK != (rc = btreeGetPage(pBt, iPage, &pPage, 0))) {
		goto freepage_out;
	}
	rc = sqlite3PagerWrite(pPage->pDbPage);
	if (rc != SQLITE_OK) {
		goto freepage_out;
	}
	put4byte(pPage->aData, iTrunk);
	put4byte(&pPage->aData[4], 0);
	put4byte(&pPage1->aData[32], iPage);
	TRACE(("FREE-PAGE: %d new trunk page replacing %d\n", pPage->pgno, iTrunk));

freepage_out:
	if (pPage) {
		pPage->isInit = 0;
	}
	releasePage(pPage);
	releasePage(pTrunk);
	return rc;
}
static void freePage(MemPage *pPage, int *pRC) {
	if ((*pRC) == SQLITE_OK) {
		*pRC = freePage2(pPage->pBt, pPage, pPage->pgno);
	}
}


static int clearCell(
	MemPage *pPage,          
	unsigned char *pCell,    
	u16 *pnSize              
) {
	BtShared *pBt = pPage->pBt;
	CellInfo info;
	Pgno ovflPgno;
	int rc;
	int nOvfl;
	u32 ovflPageSize;

	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	pPage->xParseCell(pPage, pCell, &info);
	*pnSize = info.nSize;
	if (info.nLocal == info.nPayload) {
		return SQLITE_OK;  
	}
	if (pCell + info.nSize - 1 > pPage->aData + pPage->maskPage) {
		return SQLITE_CORRUPT_BKPT;  
	}
	ovflPgno = get4byte(pCell + info.nSize - 4);
	assert(pBt->usableSize > 4);
	ovflPageSize = pBt->usableSize - 4;
	nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1) / ovflPageSize;
	assert(nOvfl>0 ||
		(CORRUPT_DB && (info.nPayload + ovflPageSize)<ovflPageSize)
	);
	while (nOvfl--) {
		Pgno iNext = 0;
		MemPage *pOvfl = 0;
		if (ovflPgno<2 || ovflPgno>btreePagecount(pBt)) {
			
			return SQLITE_CORRUPT_BKPT;
		}
		if (nOvfl) {
			rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);
			if (rc) return rc;
		}

		if ((pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno)) != 0))
			&& sqlite3PagerPageRefcount(pOvfl->pDbPage) != 1
			) {
			
			rc = SQLITE_CORRUPT_BKPT;
		}
		else {
			rc = freePage2(pBt, pOvfl, ovflPgno);
		}

		if (pOvfl) {
			sqlite3PagerUnref(pOvfl->pDbPage);
		}
		if (rc) return rc;
		ovflPgno = iNext;
	}
	return SQLITE_OK;
}


static int fillInCell(
	MemPage *pPage,                
	unsigned char *pCell,          
	const BtreePayload *pX,        
	int *pnSize                    
) {
	int nPayload;
	const u8 *pSrc;
	int nSrc, n, rc;
	int spaceLeft;
	MemPage *pOvfl = 0;
	MemPage *pToRelease = 0;
	unsigned char *pPrior;
	unsigned char *pPayload;
	BtShared *pBt = pPage->pBt;
	Pgno pgnoOvfl = 0;
	int nHeader;

	assert(sqlite3_mutex_held(pPage->pBt->mutex));

	
	assert(pCell<pPage->aData || pCell >= &pPage->aData[pBt->pageSize]
		|| sqlite3PagerIswriteable(pPage->pDbPage));

	
	nHeader = pPage->childPtrSize;
	if (pPage->intKey) {
		nPayload = pX->nData + pX->nZero;
		pSrc = pX->pData;
		nSrc = pX->nData;
		assert(pPage->intKeyLeaf); 
		nHeader += putVarint32(&pCell[nHeader], nPayload);
		nHeader += putVarint(&pCell[nHeader], *(u64*)&pX->nKey);
	}
	else {
		assert(pX->nKey <= 0x7fffffff && pX->pKey != 0);
		nSrc = nPayload = (int)pX->nKey;
		pSrc = pX->pKey;
		nHeader += putVarint32(&pCell[nHeader], nPayload);
	}

	
	if (nPayload <= pPage->maxLocal) {
		n = nHeader + nPayload;
		testcase(n == 3);
		testcase(n == 4);
		if (n<4) n = 4;
		*pnSize = n;
		spaceLeft = nPayload;
		pPrior = pCell;
	}
	else {
		int mn = pPage->minLocal;
		n = mn + (nPayload - mn) % (pPage->pBt->usableSize - 4);
		testcase(n == pPage->maxLocal);
		testcase(n == pPage->maxLocal + 1);
		if (n > pPage->maxLocal) n = mn;
		spaceLeft = n;
		*pnSize = n + nHeader + 4;
		pPrior = &pCell[nHeader + n];
	}
	pPayload = &pCell[nHeader];

	
#if SQLITE_DEBUG
	{
		CellInfo info;
		pPage->xParseCell(pPage, pCell, &info);
		assert(nHeader == (int)(info.pPayload - pCell));
		assert(info.nKey == pX->nKey);
		assert(*pnSize == info.nSize);
		assert(spaceLeft == info.nLocal);
	}
#endif

	
	while (nPayload>0) {
		if (spaceLeft == 0) {
#ifndef SQLITE_OMIT_AUTOVACUUM
			Pgno pgnoPtrmap = pgnoOvfl; 
			if (pBt->autoVacuum) {
				do {
					pgnoOvfl++;
				} while (
					PTRMAP_ISPAGE(pBt, pgnoOvfl) || pgnoOvfl == PENDING_BYTE_PAGE(pBt)
					);
			}
#endif
			rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
#ifndef SQLITE_OMIT_AUTOVACUUM
			
			if (pBt->autoVacuum && rc == SQLITE_OK) {
				u8 eType = (pgnoPtrmap ? PTRMAP_OVERFLOW2 : PTRMAP_OVERFLOW1);
				ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);
				if (rc) {
					releasePage(pOvfl);
				}
			}
#endif
			if (rc) {
				releasePage(pToRelease);
				return rc;
			}

			
			assert(pToRelease == 0 || sqlite3PagerIswriteable(pToRelease->pDbPage));

			
			assert(pPrior<pPage->aData || pPrior >= &pPage->aData[pBt->pageSize]
				|| sqlite3PagerIswriteable(pPage->pDbPage));

			put4byte(pPrior, pgnoOvfl);
			releasePage(pToRelease);
			pToRelease = pOvfl;
			pPrior = pOvfl->aData;
			put4byte(pPrior, 0);
			pPayload = &pOvfl->aData[4];
			spaceLeft = pBt->usableSize - 4;
		}
		n = nPayload;
		if (n>spaceLeft) n = spaceLeft;

		
		assert(pToRelease == 0 || sqlite3PagerIswriteable(pToRelease->pDbPage));

		
		assert(pPayload<pPage->aData || pPayload >= &pPage->aData[pBt->pageSize]
			|| sqlite3PagerIswriteable(pPage->pDbPage));

		if (nSrc>0) {
			if (n>nSrc) n = nSrc;
			assert(pSrc);
			memcpy(pPayload, pSrc, n);
		}
		else {
			memset(pPayload, 0, n);
		}
		nPayload -= n;
		pPayload += n;
		pSrc += n;
		nSrc -= n;
		spaceLeft -= n;
	}
	releasePage(pToRelease);
	return SQLITE_OK;
}


static void dropCell(MemPage *pPage, int idx, int sz, int *pRC) {
	u32 pc;         
	u8 *data;       
	u8 *ptr;        
	int rc;         
	int hdr;        

	if (*pRC) return;

	assert(idx >= 0 && idx<pPage->nCell);
	assert(CORRUPT_DB || sz == cellSize(pPage, idx));
	assert(sqlite3PagerIswriteable(pPage->pDbPage));
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	data = pPage->aData;
	ptr = &pPage->aCellIdx[2 * idx];
	pc = get2byte(ptr);
	hdr = pPage->hdrOffset;
	testcase(pc == get2byte(&data[hdr + 5]));
	testcase(pc + sz == pPage->pBt->usableSize);
	if (pc < (u32)get2byte(&data[hdr + 5]) || pc + sz > pPage->pBt->usableSize) {
		*pRC = SQLITE_CORRUPT_BKPT;
		return;
	}
	rc = freeSpace(pPage, pc, sz);
	if (rc) {
		*pRC = rc;
		return;
	}
	pPage->nCell--;
	if (pPage->nCell == 0) {
		memset(&data[hdr + 1], 0, 4);
		data[hdr + 7] = 0;
		put2byte(&data[hdr + 5], pPage->pBt->usableSize);
		pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset
			- pPage->childPtrSize - 8;
	}
	else {
		memmove(ptr, ptr + 2, 2 * (pPage->nCell - idx));
		put2byte(&data[hdr + 3], pPage->nCell);
		pPage->nFree += 2;
	}
}


static void insertCell(
	MemPage *pPage,   
	int i,            
	u8 *pCell,        
	int sz,           
	u8 *pTemp,        
	Pgno iChild,      
	int *pRC          
) {
	int idx = 0;      
	int j;            
	u8 *data;         
	u8 *pIns;         

	assert(*pRC == SQLITE_OK);
	assert(i >= 0 && i <= pPage->nCell + pPage->nOverflow);
	assert(MX_CELL(pPage->pBt) <= 10921);
	assert(pPage->nCell <= MX_CELL(pPage->pBt) || CORRUPT_DB);
	assert(pPage->nOverflow <= ArraySize(pPage->apOvfl));
	assert(ArraySize(pPage->apOvfl) == ArraySize(pPage->aiOvfl));
	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	
	assert(sz == pPage->xCellSize(pPage, pCell) || (sz == 8 && iChild>0));
	if (pPage->nOverflow || sz + 2>pPage->nFree) {
		if (pTemp) {
			memcpy(pTemp, pCell, sz);
			pCell = pTemp;
		}
		if (iChild) {
			put4byte(pCell, iChild);
		}
		j = pPage->nOverflow++;
		assert(j<(int)(sizeof(pPage->apOvfl) / sizeof(pPage->apOvfl[0])));
		pPage->apOvfl[j] = pCell;
		pPage->aiOvfl[j] = (u16)i;

		
		assert(j == 0 || pPage->aiOvfl[j - 1]<(u16)i); 
		assert(j == 0 || i == pPage->aiOvfl[j - 1] + 1);   
	}
	else {
		int rc = sqlite3PagerWrite(pPage->pDbPage);
		if (rc != SQLITE_OK) {
			*pRC = rc;
			return;
		}
		assert(sqlite3PagerIswriteable(pPage->pDbPage));
		data = pPage->aData;
		assert(&data[pPage->cellOffset] == pPage->aCellIdx);
		rc = allocateSpace(pPage, sz, &idx);
		if (rc) { *pRC = rc; return; }
		
		assert(idx >= 0);
		assert(idx >= pPage->cellOffset + 2 * pPage->nCell + 2 || CORRUPT_DB);
		assert(idx + sz <= (int)pPage->pBt->usableSize);
		pPage->nFree -= (u16)(2 + sz);
		memcpy(&data[idx], pCell, sz);
		if (iChild) {
			put4byte(&data[idx], iChild);
		}
		pIns = pPage->aCellIdx + i * 2;
		memmove(pIns + 2, pIns, 2 * (pPage->nCell - i));
		put2byte(pIns, idx);
		pPage->nCell++;
		
		if ((++data[pPage->hdrOffset + 4]) == 0) data[pPage->hdrOffset + 3]++;
		assert(get2byte(&data[pPage->hdrOffset + 3]) == pPage->nCell);
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (pPage->pBt->autoVacuum) {
			
			ptrmapPutOvflPtr(pPage, pCell, pRC);
		}
#endif
	}
}


typedef struct CellArray CellArray;
struct CellArray {
	int nCell;              
	MemPage *pRef;          
	u8 **apCell;            
	u16 *szCell;            
};


static void populateCellCache(CellArray *p, int idx, int N) {
	assert(idx >= 0 && idx + N <= p->nCell);
	while (N>0) {
		assert(p->apCell[idx] != 0);
		if (p->szCell[idx] == 0) {
			p->szCell[idx] = p->pRef->xCellSize(p->pRef, p->apCell[idx]);
		}
		else {
			assert(CORRUPT_DB ||
				p->szCell[idx] == p->pRef->xCellSize(p->pRef, p->apCell[idx]));
		}
		idx++;
		N--;
	}
}


static SQLITE_NOINLINE u16 computeCellSize(CellArray *p, int N) {
	assert(N >= 0 && N<p->nCell);
	assert(p->szCell[N] == 0);
	p->szCell[N] = p->pRef->xCellSize(p->pRef, p->apCell[N]);
	return p->szCell[N];
}
static u16 cachedCellSize(CellArray *p, int N) {
	assert(N >= 0 && N<p->nCell);
	if (p->szCell[N]) return p->szCell[N];
	return computeCellSize(p, N);
}


static int rebuildPage(
	MemPage *pPg,                   
	int nCell,                      
	u8 **apCell,                    
	u16 *szCell                     
) {
	const int hdr = pPg->hdrOffset;          
	u8 * const aData = pPg->aData;           
	const int usableSize = pPg->pBt->usableSize;
	u8 * const pEnd = &aData[usableSize];
	int i;
	u8 *pCellptr = pPg->aCellIdx;
	u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);
	u8 *pData;

	i = get2byte(&aData[hdr + 5]);
	memcpy(&pTmp[i], &aData[i], usableSize - i);

	pData = pEnd;
	for (i = 0; i<nCell; i++) {
		u8 *pCell = apCell[i];
		if (SQLITE_WITHIN(pCell, aData, pEnd)) {
			pCell = &pTmp[pCell - aData];
		}
		pData -= szCell[i];
		put2byte(pCellptr, (pData - aData));
		pCellptr += 2;
		if (pData < pCellptr) return SQLITE_CORRUPT_BKPT;
		memcpy(pData, pCell, szCell[i]);
		assert(szCell[i] == pPg->xCellSize(pPg, pCell) || CORRUPT_DB);
		testcase(szCell[i] != pPg->xCellSize(pPg, pCell));
	}

	
	pPg->nCell = nCell;
	pPg->nOverflow = 0;

	put2byte(&aData[hdr + 1], 0);
	put2byte(&aData[hdr + 3], pPg->nCell);
	put2byte(&aData[hdr + 5], pData - aData);
	aData[hdr + 7] = 0x00;
	return SQLITE_OK;
}


static int pageInsertArray(
	MemPage *pPg,                   
	u8 *pBegin,                     
	u8 **ppData,                    
	u8 *pCellptr,                   
	int iFirst,                     
	int nCell,                      
	CellArray *pCArray              
) {
	int i;
	u8 *aData = pPg->aData;
	u8 *pData = *ppData;
	int iEnd = iFirst + nCell;
	assert(CORRUPT_DB || pPg->hdrOffset == 0);    
	for (i = iFirst; i<iEnd; i++) {
		int sz, rc;
		u8 *pSlot;
		sz = cachedCellSize(pCArray, i);
		if ((aData[1] == 0 && aData[2] == 0) || (pSlot = pageFindSlot(pPg, sz, &rc)) == 0) {
			if ((pData - pBegin)<sz) return 1;
			pData -= sz;
			pSlot = pData;
		}
		
		assert((pSlot + sz) <= pCArray->apCell[i]
			|| pSlot >= (pCArray->apCell[i] + sz)
			|| CORRUPT_DB);
		memmove(pSlot, pCArray->apCell[i], sz);
		put2byte(pCellptr, (pSlot - aData));
		pCellptr += 2;
	}
	*ppData = pData;
	return 0;
}


static int pageFreeArray(
	MemPage *pPg,                   
	int iFirst,                     
	int nCell,                      
	CellArray *pCArray              
) {
	u8 * const aData = pPg->aData;
	u8 * const pEnd = &aData[pPg->pBt->usableSize];
	u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];
	int nRet = 0;
	int i;
	int iEnd = iFirst + nCell;
	u8 *pFree = 0;
	int szFree = 0;

	for (i = iFirst; i<iEnd; i++) {
		u8 *pCell = pCArray->apCell[i];
		if (SQLITE_WITHIN(pCell, pStart, pEnd)) {
			int sz;
			
			sz = pCArray->szCell[i];  assert(sz>0);
			if (pFree != (pCell + sz)) {
				if (pFree) {
					assert(pFree>aData && (pFree - aData)<65536);
					freeSpace(pPg, (u16)(pFree - aData), szFree);
				}
				pFree = pCell;
				szFree = sz;
				if (pFree + sz>pEnd) return 0;
			}
			else {
				pFree = pCell;
				szFree += sz;
			}
			nRet++;
		}
	}
	if (pFree) {
		assert(pFree>aData && (pFree - aData)<65536);
		freeSpace(pPg, (u16)(pFree - aData), szFree);
	}
	return nRet;
}


static int editPage(
	MemPage *pPg,                   
	int iOld,                       
	int iNew,                       
	int nNew,                       
	CellArray *pCArray              
) {
	u8 * const aData = pPg->aData;
	const int hdr = pPg->hdrOffset;
	u8 *pBegin = &pPg->aCellIdx[nNew * 2];
	int nCell = pPg->nCell;       
	u8 *pData;
	u8 *pCellptr;
	int i;
	int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;
	int iNewEnd = iNew + nNew;

#ifdef SQLITE_DEBUG
	u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);
	memcpy(pTmp, aData, pPg->pBt->usableSize);
#endif

	
	if (iOld<iNew) {
		int nShift = pageFreeArray(pPg, iOld, iNew - iOld, pCArray);
		memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift * 2], nCell * 2);
		nCell -= nShift;
	}
	if (iNewEnd < iOldEnd) {
		nCell -= pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);
	}

	pData = &aData[get2byteNotZero(&aData[hdr + 5])];
	if (pData<pBegin) goto editpage_fail;

	
	if (iNew<iOld) {
		int nAdd = MIN(nNew, iOld - iNew);
		assert((iOld - iNew)<nNew || nCell == 0 || CORRUPT_DB);
		pCellptr = pPg->aCellIdx;
		memmove(&pCellptr[nAdd * 2], pCellptr, nCell * 2);
		if (pageInsertArray(
			pPg, pBegin, &pData, pCellptr,
			iNew, nAdd, pCArray
		)) goto editpage_fail;
		nCell += nAdd;
	}

	
	for (i = 0; i<pPg->nOverflow; i++) {
		int iCell = (iOld + pPg->aiOvfl[i]) - iNew;
		if (iCell >= 0 && iCell<nNew) {
			pCellptr = &pPg->aCellIdx[iCell * 2];
			memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
			nCell++;
			if (pageInsertArray(
				pPg, pBegin, &pData, pCellptr,
				iCell + iNew, 1, pCArray
			)) goto editpage_fail;
		}
	}

	
	pCellptr = &pPg->aCellIdx[nCell * 2];
	if (pageInsertArray(
		pPg, pBegin, &pData, pCellptr,
		iNew + nCell, nNew - nCell, pCArray
	)) goto editpage_fail;

	pPg->nCell = nNew;
	pPg->nOverflow = 0;

	put2byte(&aData[hdr + 3], pPg->nCell);
	put2byte(&aData[hdr + 5], pData - aData);

#ifdef SQLITE_DEBUG
	for (i = 0; i<nNew && !CORRUPT_DB; i++) {
		u8 *pCell = pCArray->apCell[i + iNew];
		int iOff = get2byteAligned(&pPg->aCellIdx[i * 2]);
		if (SQLITE_WITHIN(pCell, aData, &aData[pPg->pBt->usableSize])) {
			pCell = &pTmp[pCell - aData];
		}
		assert(0 == memcmp(pCell, &aData[iOff],
			pCArray->pRef->xCellSize(pCArray->pRef, pCArray->apCell[i + iNew])));
	}
#endif

	return SQLITE_OK;
editpage_fail:
	
	populateCellCache(pCArray, iNew, nNew);
	return rebuildPage(pPg, nNew, &pCArray->apCell[iNew], &pCArray->szCell[iNew]);
}


#define NN 1             
#define NB (NN*2+1)      


#ifndef SQLITE_OMIT_QUICKBALANCE

static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace) {
	BtShared *const pBt = pPage->pBt;    
	MemPage *pNew;                       
	int rc;                              
	Pgno pgnoNew;                        

	assert(sqlite3_mutex_held(pPage->pBt->mutex));
	assert(sqlite3PagerIswriteable(pParent->pDbPage));
	assert(pPage->nOverflow == 1);

	
	if (NEVER(pPage->nCell == 0)) return SQLITE_CORRUPT_BKPT;

	
	rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);

	if (rc == SQLITE_OK) {

		u8 *pOut = &pSpace[4];
		u8 *pCell = pPage->apOvfl[0];
		u16 szCell = pPage->xCellSize(pPage, pCell);
		u8 *pStop;

		assert(sqlite3PagerIswriteable(pNew->pDbPage));
		assert(pPage->aData[0] == (PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF));
		zeroPage(pNew, PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF);
		rc = rebuildPage(pNew, 1, &pCell, &szCell);
		if (NEVER(rc)) return rc;
		pNew->nFree = pBt->usableSize - pNew->cellOffset - 2 - szCell;

		
		if (ISAUTOVACUUM) {
			ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent->pgno, &rc);
			if (szCell>pNew->minLocal) {
				ptrmapPutOvflPtr(pNew, pCell, &rc);
			}
		}

		
		pCell = findCell(pPage, pPage->nCell - 1);
		pStop = &pCell[9];
		while ((*(pCell++) & 0x80) && pCell<pStop);
		pStop = &pCell[9];
		while (((*(pOut++) = *(pCell++)) & 0x80) && pCell<pStop);

		
		if (rc == SQLITE_OK) {
			insertCell(pParent, pParent->nCell, pSpace, (int)(pOut - pSpace),
				0, pPage->pgno, &rc);
		}

		
		put4byte(&pParent->aData[pParent->hdrOffset + 8], pgnoNew);

		
		releasePage(pNew);
	}

	return rc;
}
#endif 

#if 0

static int ptrmapCheckPages(MemPage **apPage, int nPage) {
	int i, j;
	for (i = 0; i<nPage; i++) {
		Pgno n;
		u8 e;
		MemPage *pPage = apPage[i];
		BtShared *pBt = pPage->pBt;
		assert(pPage->isInit);

		for (j = 0; j<pPage->nCell; j++) {
			CellInfo info;
			u8 *z;

			z = findCell(pPage, j);
			pPage->xParseCell(pPage, z, &info);
			if (info.nLocal<info.nPayload) {
				Pgno ovfl = get4byte(&z[info.nSize - 4]);
				ptrmapGet(pBt, ovfl, &e, &n);
				assert(n == pPage->pgno && e == PTRMAP_OVERFLOW1);
			}
			if (!pPage->leaf) {
				Pgno child = get4byte(z);
				ptrmapGet(pBt, child, &e, &n);
				assert(n == pPage->pgno && e == PTRMAP_BTREE);
			}
		}
		if (!pPage->leaf) {
			Pgno child = get4byte(&pPage->aData[pPage->hdrOffset + 8]);
			ptrmapGet(pBt, child, &e, &n);
			assert(n == pPage->pgno && e == PTRMAP_BTREE);
		}
	}
	return 1;
}
#endif


static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC) {
	if ((*pRC) == SQLITE_OK) {
		BtShared * const pBt = pFrom->pBt;
		u8 * const aFrom = pFrom->aData;
		u8 * const aTo = pTo->aData;
		int const iFromHdr = pFrom->hdrOffset;
		int const iToHdr = ((pTo->pgno == 1) ? 100 : 0);
		int rc;
		int iData;


		assert(pFrom->isInit);
		assert(pFrom->nFree >= iToHdr);
		assert(get2byte(&aFrom[iFromHdr + 5]) <= (int)pBt->usableSize);

		
		iData = get2byte(&aFrom[iFromHdr + 5]);
		memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize - iData);
		memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2 * pFrom->nCell);

		
		pTo->isInit = 0;
		rc = btreeInitPage(pTo);
		if (rc != SQLITE_OK) {
			*pRC = rc;
			return;
		}

		
		if (ISAUTOVACUUM) {
			*pRC = setChildPtrmaps(pTo);
		}
	}
}


static int balance_nonroot(
	MemPage *pParent,               
	int iParentIdx,                 
	u8 *aOvflSpace,                 
	int isRoot,                     
	int bBulk                       
) {
	BtShared *pBt;               
	int nMaxCells = 0;           
	int nNew = 0;                
	int nOld;                    
	int i, j, k;                 
	int nxDiv;                   
	int rc = SQLITE_OK;          
	u16 leafCorrection;          
	int leafData;                
	int usableSpace;             
	int pageFlags;               
	int iSpace1 = 0;             
	int iOvflSpace = 0;          
	int szScratch;               
	MemPage *apOld[NB];          
	MemPage *apNew[NB + 2];        
	u8 *pRight;                  
	u8 *apDiv[NB - 1];             
	int cntNew[NB + 2];            
	int cntOld[NB + 2];            
	int szNew[NB + 2];             
	u8 *aSpace1;                 
	Pgno pgno;                   
	u8 abDone[NB + 2];             
	Pgno aPgno[NB + 2];            
	Pgno aPgOrder[NB + 2];         
	u16 aPgFlags[NB + 2];          
	CellArray b;                  

	memset(abDone, 0, sizeof(abDone));
	b.nCell = 0;
	b.apCell = 0;
	pBt = pParent->pBt;
	assert(sqlite3_mutex_held(pBt->mutex));
	assert(sqlite3PagerIswriteable(pParent->pDbPage));

#if 0
	TRACE(("BALANCE: begin page %d child of %d\n", pPage->pgno, pParent->pgno));
#endif

	
	assert(pParent->nOverflow == 0 || pParent->nOverflow == 1);
	assert(pParent->nOverflow == 0 || pParent->aiOvfl[0] == iParentIdx);

	if (!aOvflSpace) {
		return SQLITE_NOMEM_BKPT;
	}

	
	i = pParent->nOverflow + pParent->nCell;
	if (i<2) {
		nxDiv = 0;
	}
	else {
		assert(bBulk == 0 || bBulk == 1);
		if (iParentIdx == 0) {
			nxDiv = 0;
		}
		else if (iParentIdx == i) {
			nxDiv = i - 2 + bBulk;
		}
		else {
			nxDiv = iParentIdx - 1;
		}
		i = 2 - bBulk;
	}
	nOld = i + 1;
	if ((i + nxDiv - pParent->nOverflow) == pParent->nCell) {
		pRight = &pParent->aData[pParent->hdrOffset + 8];
	}
	else {
		pRight = findCell(pParent, i + nxDiv - pParent->nOverflow);
	}
	pgno = get4byte(pRight);
	while (1) {
		rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);
		if (rc) {
			memset(apOld, 0, (i + 1) * sizeof(MemPage*));
			goto balance_cleanup;
		}
		nMaxCells += 1 + apOld[i]->nCell + apOld[i]->nOverflow;
		if ((i--) == 0) break;

		if (i + nxDiv == pParent->aiOvfl[0] && pParent->nOverflow) {
			apDiv[i] = pParent->apOvfl[0];
			pgno = get4byte(apDiv[i]);
			szNew[i] = pParent->xCellSize(pParent, apDiv[i]);
			pParent->nOverflow = 0;
		}
		else {
			apDiv[i] = findCell(pParent, i + nxDiv - pParent->nOverflow);
			pgno = get4byte(apDiv[i]);
			szNew[i] = pParent->xCellSize(pParent, apDiv[i]);

			
			if (pBt->btsFlags & BTS_SECURE_DELETE) {
				int iOff;

				iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);
				if ((iOff + szNew[i])>(int)pBt->usableSize) {
					rc = SQLITE_CORRUPT_BKPT;
					memset(apOld, 0, (i + 1) * sizeof(MemPage*));
					goto balance_cleanup;
				}
				else {
					memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
					apDiv[i] = &aOvflSpace[apDiv[i] - pParent->aData];
				}
			}
			dropCell(pParent, i + nxDiv - pParent->nOverflow, szNew[i], &rc);
		}
	}

	
	nMaxCells = (nMaxCells + 3)&~3;

	
	szScratch =
		nMaxCells * sizeof(u8*)                       
		+ nMaxCells * sizeof(u16)                       
		+ pBt->pageSize;                              

													  
	assert(szScratch <= 6 * (int)pBt->pageSize);
	b.apCell = sqlite3ScratchMalloc(szScratch);
	if (b.apCell == 0) {
		rc = SQLITE_NOMEM_BKPT;
		goto balance_cleanup;
	}
	b.szCell = (u16*)&b.apCell[nMaxCells];
	aSpace1 = (u8*)&b.szCell[nMaxCells];
	assert(EIGHT_BYTE_ALIGNMENT(aSpace1));

	
	b.pRef = apOld[0];
	leafCorrection = b.pRef->leaf * 4;
	leafData = b.pRef->intKeyLeaf;
	for (i = 0; i<nOld; i++) {
		MemPage *pOld = apOld[i];
		int limit = pOld->nCell;
		u8 *aData = pOld->aData;
		u16 maskPage = pOld->maskPage;
		u8 *piCell = aData + pOld->cellOffset;
		u8 *piEnd;

		
		if (pOld->aData[0] != apOld[0]->aData[0]) {
			rc = SQLITE_CORRUPT_BKPT;
			goto balance_cleanup;
		}

		
		memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit + pOld->nOverflow));
		if (pOld->nOverflow>0) {
			limit = pOld->aiOvfl[0];
			for (j = 0; j<limit; j++) {
				b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));
				piCell += 2;
				b.nCell++;
			}
			for (k = 0; k<pOld->nOverflow; k++) {
				assert(k == 0 || pOld->aiOvfl[k - 1] + 1 == pOld->aiOvfl[k]);
				b.apCell[b.nCell] = pOld->apOvfl[k];
				b.nCell++;
			}
		}
		piEnd = aData + pOld->cellOffset + 2 * pOld->nCell;
		while (piCell<piEnd) {
			assert(b.nCell<nMaxCells);
			b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));
			piCell += 2;
			b.nCell++;
		}

		cntOld[i] = b.nCell;
		if (i<nOld - 1 && !leafData) {
			u16 sz = (u16)szNew[i];
			u8 *pTemp;
			assert(b.nCell<nMaxCells);
			b.szCell[b.nCell] = sz;
			pTemp = &aSpace1[iSpace1];
			iSpace1 += sz;
			assert(sz <= pBt->maxLocal + 23);
			assert(iSpace1 <= (int)pBt->pageSize);
			memcpy(pTemp, apDiv[i], sz);
			b.apCell[b.nCell] = pTemp + leafCorrection;
			assert(leafCorrection == 0 || leafCorrection == 4);
			b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;
			if (!pOld->leaf) {
				assert(leafCorrection == 0);
				assert(pOld->hdrOffset == 0);
				
				memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);
			}
			else {
				assert(leafCorrection == 4);
				while (b.szCell[b.nCell]<4) {
					
					assert(b.szCell[b.nCell] == 3 || CORRUPT_DB);
					assert(b.apCell[b.nCell] == &aSpace1[iSpace1 - 3] || CORRUPT_DB);
					aSpace1[iSpace1++] = 0x00;
					b.szCell[b.nCell]++;
				}
			}
			b.nCell++;
		}
	}

	
	usableSpace = pBt->usableSize - 12 + leafCorrection;
	for (i = 0; i<nOld; i++) {
		MemPage *p = apOld[i];
		szNew[i] = usableSpace - p->nFree;
		if (szNew[i]<0) { rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
		for (j = 0; j<p->nOverflow; j++) {
			szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);
		}
		cntNew[i] = cntOld[i];
	}
	k = nOld;
	for (i = 0; i<k; i++) {
		int sz;
		while (szNew[i]>usableSpace) {
			if (i + 1 >= k) {
				k = i + 2;
				if (k>NB + 2) { rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
				szNew[k - 1] = 0;
				cntNew[k - 1] = b.nCell;
			}
			sz = 2 + cachedCellSize(&b, cntNew[i] - 1);
			szNew[i] -= sz;
			if (!leafData) {
				if (cntNew[i]<b.nCell) {
					sz = 2 + cachedCellSize(&b, cntNew[i]);
				}
				else {
					sz = 0;
				}
			}
			szNew[i + 1] += sz;
			cntNew[i]--;
		}
		while (cntNew[i]<b.nCell) {
			sz = 2 + cachedCellSize(&b, cntNew[i]);
			if (szNew[i] + sz>usableSpace) break;
			szNew[i] += sz;
			cntNew[i]++;
			if (!leafData) {
				if (cntNew[i]<b.nCell) {
					sz = 2 + cachedCellSize(&b, cntNew[i]);
				}
				else {
					sz = 0;
				}
			}
			szNew[i + 1] -= sz;
		}
		if (cntNew[i] >= b.nCell) {
			k = i + 1;
		}
		else if (cntNew[i] <= (i>0 ? cntNew[i - 1] : 0)) {
			rc = SQLITE_CORRUPT_BKPT;
			goto balance_cleanup;
		}
	}

	
	for (i = k - 1; i>0; i--) {
		int szRight = szNew[i];  
		int szLeft = szNew[i - 1]; 
		int r;              
		int d;              

		r = cntNew[i - 1] - 1;
		d = r + 1 - leafData;
		(void)cachedCellSize(&b, d);
		do {
			assert(d<nMaxCells);
			assert(r<nMaxCells);
			(void)cachedCellSize(&b, r);
			if (szRight != 0
				&& (bBulk || szRight + b.szCell[d] + 2 > szLeft - (b.szCell[r] + (i == k - 1 ? 0 : 2)))) {
				break;
			}
			szRight += b.szCell[d] + 2;
			szLeft -= b.szCell[r] + 2;
			cntNew[i - 1] = r;
			r--;
			d--;
		} while (r >= 0);
		szNew[i] = szRight;
		szNew[i - 1] = szLeft;
		if (cntNew[i - 1] <= (i>1 ? cntNew[i - 2] : 0)) {
			rc = SQLITE_CORRUPT_BKPT;
			goto balance_cleanup;
		}
	}

	
	assert(cntNew[0]>0 || (pParent->pgno == 1 && pParent->nCell == 0) || CORRUPT_DB);
	TRACE(("BALANCE: old: %d(nc=%d) %d(nc=%d) %d(nc=%d)\n",
		apOld[0]->pgno, apOld[0]->nCell,
		nOld >= 2 ? apOld[1]->pgno : 0, nOld >= 2 ? apOld[1]->nCell : 0,
		nOld >= 3 ? apOld[2]->pgno : 0, nOld >= 3 ? apOld[2]->nCell : 0
		));

	
	pageFlags = apOld[0]->aData[0];
	for (i = 0; i<k; i++) {
		MemPage *pNew;
		if (i<nOld) {
			pNew = apNew[i] = apOld[i];
			apOld[i] = 0;
			rc = sqlite3PagerWrite(pNew->pDbPage);
			nNew++;
			if (rc) goto balance_cleanup;
		}
		else {
			assert(i>0);
			rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);
			if (rc) goto balance_cleanup;
			zeroPage(pNew, pageFlags);
			apNew[i] = pNew;
			nNew++;
			cntOld[i] = b.nCell;

			
			if (ISAUTOVACUUM) {
				ptrmapPut(pBt, pNew->pgno, PTRMAP_BTREE, pParent->pgno, &rc);
				if (rc != SQLITE_OK) {
					goto balance_cleanup;
				}
			}
		}
	}

	
	for (i = 0; i<nNew; i++) {
		aPgOrder[i] = aPgno[i] = apNew[i]->pgno;
		aPgFlags[i] = apNew[i]->pDbPage->flags;
		for (j = 0; j<i; j++) {
			if (aPgno[j] == aPgno[i]) {
				
				assert(CORRUPT_DB);
				rc = SQLITE_CORRUPT_BKPT;
				goto balance_cleanup;
			}
		}
	}
	for (i = 0; i<nNew; i++) {
		int iBest = 0;                
		for (j = 1; j<nNew; j++) {
			if (aPgOrder[j]<aPgOrder[iBest]) iBest = j;
		}
		pgno = aPgOrder[iBest];
		aPgOrder[iBest] = 0xffffffff;
		if (iBest != i) {
			if (iBest>i) {
				sqlite3PagerRekey(apNew[iBest]->pDbPage, pBt->nPage + iBest + 1, 0);
			}
			sqlite3PagerRekey(apNew[i]->pDbPage, pgno, aPgFlags[iBest]);
			apNew[i]->pgno = pgno;
		}
	}

	TRACE(("BALANCE: new: %d(%d nc=%d) %d(%d nc=%d) %d(%d nc=%d) "
		"%d(%d nc=%d) %d(%d nc=%d)\n",
		apNew[0]->pgno, szNew[0], cntNew[0],
		nNew >= 2 ? apNew[1]->pgno : 0, nNew >= 2 ? szNew[1] : 0,
		nNew >= 2 ? cntNew[1] - cntNew[0] - !leafData : 0,
		nNew >= 3 ? apNew[2]->pgno : 0, nNew >= 3 ? szNew[2] : 0,
		nNew >= 3 ? cntNew[2] - cntNew[1] - !leafData : 0,
		nNew >= 4 ? apNew[3]->pgno : 0, nNew >= 4 ? szNew[3] : 0,
		nNew >= 4 ? cntNew[3] - cntNew[2] - !leafData : 0,
		nNew >= 5 ? apNew[4]->pgno : 0, nNew >= 5 ? szNew[4] : 0,
		nNew >= 5 ? cntNew[4] - cntNew[3] - !leafData : 0
		));

	assert(sqlite3PagerIswriteable(pParent->pDbPage));
	put4byte(pRight, apNew[nNew - 1]->pgno);

	
	if ((pageFlags & PTF_LEAF) == 0 && nOld != nNew) {
		MemPage *pOld = (nNew>nOld ? apNew : apOld)[nOld - 1];
		memcpy(&apNew[nNew - 1]->aData[8], &pOld->aData[8], 4);
	}

	
	if (ISAUTOVACUUM) {
		MemPage *pNew = apNew[0];
		u8 *aOld = pNew->aData;
		int cntOldNext = pNew->nCell + pNew->nOverflow;
		int usableSize = pBt->usableSize;
		int iNew = 0;
		int iOld = 0;

		for (i = 0; i<b.nCell; i++) {
			u8 *pCell = b.apCell[i];
			if (i == cntOldNext) {
				MemPage *pOld = (++iOld)<nNew ? apNew[iOld] : apOld[iOld];
				cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;
				aOld = pOld->aData;
			}
			if (i == cntNew[iNew]) {
				pNew = apNew[++iNew];
				if (!leafData) continue;
			}

			
			if (iOld >= nNew
				|| pNew->pgno != aPgno[iOld]
				|| !SQLITE_WITHIN(pCell, aOld, &aOld[usableSize])
				) {
				if (!leafCorrection) {
					ptrmapPut(pBt, get4byte(pCell), PTRMAP_BTREE, pNew->pgno, &rc);
				}
				if (cachedCellSize(&b, i)>pNew->minLocal) {
					ptrmapPutOvflPtr(pNew, pCell, &rc);
				}
				if (rc) goto balance_cleanup;
			}
		}
	}

	
	for (i = 0; i<nNew - 1; i++) {
		u8 *pCell;
		u8 *pTemp;
		int sz;
		MemPage *pNew = apNew[i];
		j = cntNew[i];

		assert(j<nMaxCells);
		assert(b.apCell[j] != 0);
		pCell = b.apCell[j];
		sz = b.szCell[j] + leafCorrection;
		pTemp = &aOvflSpace[iOvflSpace];
		if (!pNew->leaf) {
			memcpy(&pNew->aData[8], pCell, 4);
		}
		else if (leafData) {
			
			CellInfo info;
			j--;
			pNew->xParseCell(pNew, b.apCell[j], &info);
			pCell = pTemp;
			sz = 4 + putVarint(&pCell[4], info.nKey);
			pTemp = 0;
		}
		else {
			pCell -= 4;
			
			if (b.szCell[j] == 4) {
				assert(leafCorrection == 4);
				sz = pParent->xCellSize(pParent, pCell);
			}
		}
		iOvflSpace += sz;
		assert(sz <= pBt->maxLocal + 23);
		assert(iOvflSpace <= (int)pBt->pageSize);
		insertCell(pParent, nxDiv + i, pCell, sz, pTemp, pNew->pgno, &rc);
		if (rc != SQLITE_OK) goto balance_cleanup;
		assert(sqlite3PagerIswriteable(pParent->pDbPage));
	}

	
	for (i = 1 - nNew; i<nNew; i++) {
		int iPg = i<0 ? -i : i;
		assert(iPg >= 0 && iPg<nNew);
		if (abDone[iPg]) continue;         
		if (i >= 0                            
			|| cntOld[iPg - 1] >= cntNew[iPg - 1]    
			) {
			int iNew;
			int iOld;
			int nNewCell;

			
			assert(iPg == 0 || cntOld[iPg - 1] >= cntNew[iPg - 1] || abDone[iPg - 1]);

			
			assert(cntNew[iPg] >= cntOld[iPg] || abDone[iPg + 1]);

			if (iPg == 0) {
				iNew = iOld = 0;
				nNewCell = cntNew[0];
			}
			else {
				iOld = iPg<nOld ? (cntOld[iPg - 1] + !leafData) : b.nCell;
				iNew = cntNew[iPg - 1] + !leafData;
				nNewCell = cntNew[iPg] - iNew;
			}

			rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);
			if (rc) goto balance_cleanup;
			abDone[iPg]++;
			apNew[iPg]->nFree = usableSpace - szNew[iPg];
			assert(apNew[iPg]->nOverflow == 0);
			assert(apNew[iPg]->nCell == nNewCell);
		}
	}

	
	assert(memcmp(abDone, "\01\01\01\01\01", nNew) == 0);

	assert(nOld>0);
	assert(nNew>0);

	if (isRoot && pParent->nCell == 0 && pParent->hdrOffset <= apNew[0]->nFree) {
		
		assert(nNew == 1 || CORRUPT_DB);
		rc = defragmentPage(apNew[0]);
		testcase(rc != SQLITE_OK);
		assert(apNew[0]->nFree ==
			(get2byte(&apNew[0]->aData[5]) - apNew[0]->cellOffset - apNew[0]->nCell * 2)
			|| rc != SQLITE_OK
		);
		copyNodeContent(apNew[0], pParent, &rc);
		freePage(apNew[0], &rc);
	}
	else if (ISAUTOVACUUM && !leafCorrection) {
		
		for (i = 0; i<nNew; i++) {
			u32 key = get4byte(&apNew[i]->aData[8]);
			ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i]->pgno, &rc);
		}
	}

	assert(pParent->isInit);
	TRACE(("BALANCE: finished: old=%d new=%d cells=%d\n",
		nOld, nNew, b.nCell));

	
	for (i = nNew; i<nOld; i++) {
		freePage(apOld[i], &rc);
	}

#if 0
	if (ISAUTOVACUUM && rc == SQLITE_OK && apNew[0]->isInit) {
		
		ptrmapCheckPages(apNew, nNew);
		ptrmapCheckPages(&pParent, 1);
	}
#endif

	
balance_cleanup:
	sqlite3ScratchFree(b.apCell);
	for (i = 0; i<nOld; i++) {
		releasePage(apOld[i]);
	}
	for (i = 0; i<nNew; i++) {
		releasePage(apNew[i]);
	}

	return rc;
}



static int balance_deeper(MemPage *pRoot, MemPage **ppChild) {
	int rc;                        
	MemPage *pChild = 0;           
	Pgno pgnoChild = 0;            
	BtShared *pBt = pRoot->pBt;    

	assert(pRoot->nOverflow>0);
	assert(sqlite3_mutex_held(pBt->mutex));

	
	rc = sqlite3PagerWrite(pRoot->pDbPage);
	if (rc == SQLITE_OK) {
		rc = allocateBtreePage(pBt, &pChild, &pgnoChild, pRoot->pgno, 0);
		copyNodeContent(pRoot, pChild, &rc);
		if (ISAUTOVACUUM) {
			ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot->pgno, &rc);
		}
	}
	if (rc) {
		*ppChild = 0;
		releasePage(pChild);
		return rc;
	}
	assert(sqlite3PagerIswriteable(pChild->pDbPage));
	assert(sqlite3PagerIswriteable(pRoot->pDbPage));
	assert(pChild->nCell == pRoot->nCell);

	TRACE(("BALANCE: copy root %d into %d\n", pRoot->pgno, pChild->pgno));

	
	memcpy(pChild->aiOvfl, pRoot->aiOvfl,
		pRoot->nOverflow * sizeof(pRoot->aiOvfl[0]));
	memcpy(pChild->apOvfl, pRoot->apOvfl,
		pRoot->nOverflow * sizeof(pRoot->apOvfl[0]));
	pChild->nOverflow = pRoot->nOverflow;

	
	zeroPage(pRoot, pChild->aData[0] & ~PTF_LEAF);
	put4byte(&pRoot->aData[pRoot->hdrOffset + 8], pgnoChild);

	*ppChild = pChild;
	return SQLITE_OK;
}


static int balance(BtCursor *pCur) {
	int rc = SQLITE_OK;
	const int nMin = pCur->pBt->usableSize * 2 / 3;
	u8 aBalanceQuickSpace[13];
	u8 *pFree = 0;

	VVA_ONLY(int balance_quick_called = 0);
	VVA_ONLY(int balance_deeper_called = 0);

	do {
		int iPage = pCur->iPage;
		MemPage *pPage = pCur->apPage[iPage];

		if (iPage == 0) {
			if (pPage->nOverflow) {
				
				assert(balance_deeper_called == 0);
				VVA_ONLY(balance_deeper_called++);
				rc = balance_deeper(pPage, &pCur->apPage[1]);
				if (rc == SQLITE_OK) {
					pCur->iPage = 1;
					pCur->aiIdx[0] = 0;
					pCur->aiIdx[1] = 0;
					assert(pCur->apPage[1]->nOverflow);
				}
			}
			else {
				break;
			}
		}
		else if (pPage->nOverflow == 0 && pPage->nFree <= nMin) {
			break;
		}
		else {
			MemPage * const pParent = pCur->apPage[iPage - 1];
			int const iIdx = pCur->aiIdx[iPage - 1];

			rc = sqlite3PagerWrite(pParent->pDbPage);
			if (rc == SQLITE_OK) {
#ifndef SQLITE_OMIT_QUICKBALANCE
				if (pPage->intKeyLeaf
					&& pPage->nOverflow == 1
					&& pPage->aiOvfl[0] == pPage->nCell
					&& pParent->pgno != 1
					&& pParent->nCell == iIdx
					) {
					
					assert(balance_quick_called == 0);
					VVA_ONLY(balance_quick_called++);
					rc = balance_quick(pParent, pPage, aBalanceQuickSpace);
				}
				else
#endif
				{
					
					u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
					rc = balance_nonroot(pParent, iIdx, pSpace, iPage == 1,
						pCur->hints&BTREE_BULKLOAD);
					if (pFree) {
						
						sqlite3PageFree(pFree);
					}

					
					pFree = pSpace;
				}
			}

			pPage->nOverflow = 0;

			
			releasePage(pPage);
			pCur->iPage--;
			assert(pCur->iPage >= 0);
		}
	} while (rc == SQLITE_OK);

	if (pFree) {
		sqlite3PageFree(pFree);
	}
	return rc;
}



SQLITE_PRIVATE int sqlite3BtreeInsert(
	BtCursor *pCur,                
	const BtreePayload *pX,        
	int appendBias,                
	int seekResult                 
) {
	int rc;
	int loc = seekResult;          
	int szNew = 0;
	int idx;
	MemPage *pPage;
	Btree *p = pCur->pBtree;
	BtShared *pBt = p->pBt;
	unsigned char *oldCell;
	unsigned char *newCell = 0;

	if (pCur->eState == CURSOR_FAULT) {
		assert(pCur->skipNext != SQLITE_OK);
		return pCur->skipNext;
	}

	assert(cursorOwnsBtShared(pCur));
	assert((pCur->curFlags & BTCF_WriteFlag) != 0
		&& pBt->inTransaction == TRANS_WRITE
		&& (pBt->btsFlags & BTS_READ_ONLY) == 0);
	assert(hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo != 0, 2));

	
	assert((pX->pKey == 0) == (pCur->pKeyInfo == 0));

	
	if (pCur->curFlags & BTCF_Multiple) {
		rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
		if (rc) return rc;
	}

	if (pCur->pKeyInfo == 0) {
		assert(pX->pKey == 0);
		
		invalidateIncrblobCursors(p, pX->nKey, 0);

		
		if ((pCur->curFlags&BTCF_ValidNKey) != 0 && pX->nKey>0
			&& pCur->info.nKey == pX->nKey - 1) {
			loc = -1;
		}
		else if (loc == 0) {
			rc = sqlite3BtreeMovetoUnpacked(pCur, 0, pX->nKey, appendBias, &loc);
			if (rc) return rc;
		}
	}
	else if (loc == 0) {
		rc = btreeMoveto(pCur, pX->pKey, pX->nKey, appendBias, &loc);
		if (rc) return rc;
	}
	assert(pCur->eState == CURSOR_VALID || (pCur->eState == CURSOR_INVALID && loc));

	pPage = pCur->apPage[pCur->iPage];
	assert(pPage->intKey || pX->nKey >= 0);
	assert(pPage->leaf || !pPage->intKey);

	TRACE(("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n",
		pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,
		loc == 0 ? "overwrite" : "new entry"));
	assert(pPage->isInit);
	newCell = pBt->pTmpSpace;
	assert(newCell != 0);
	rc = fillInCell(pPage, newCell, pX, &szNew);
	if (rc) goto end_insert;
	assert(szNew == pPage->xCellSize(pPage, newCell));
	assert(szNew <= MX_CELL_SIZE(pBt));
	idx = pCur->aiIdx[pCur->iPage];
	if (loc == 0) {
		u16 szOld;
		assert(idx<pPage->nCell);
		rc = sqlite3PagerWrite(pPage->pDbPage);
		if (rc) {
			goto end_insert;
		}
		oldCell = findCell(pPage, idx);
		if (!pPage->leaf) {
			memcpy(newCell, oldCell, 4);
		}
		rc = clearCell(pPage, oldCell, &szOld);
		dropCell(pPage, idx, szOld, &rc);
		if (rc) goto end_insert;
	}
	else if (loc<0 && pPage->nCell>0) {
		assert(pPage->leaf);
		idx = ++pCur->aiIdx[pCur->iPage];
	}
	else {
		assert(pPage->leaf);
	}
	insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);
	assert(pPage->nOverflow == 0 || rc == SQLITE_OK);
	assert(rc != SQLITE_OK || pPage->nCell>0 || pPage->nOverflow>0);

	
	pCur->info.nSize = 0;
	if (pPage->nOverflow) {
		assert(rc == SQLITE_OK);
		pCur->curFlags &= ~(BTCF_ValidNKey);
		rc = balance(pCur);

		
		pCur->apPage[pCur->iPage]->nOverflow = 0;
		pCur->eState = CURSOR_INVALID;
	}
	assert(pCur->apPage[pCur->iPage]->nOverflow == 0);

end_insert:
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags) {
	Btree *p = pCur->pBtree;
	BtShared *pBt = p->pBt;
	int rc;                              
	MemPage *pPage;                      
	unsigned char *pCell;                
	int iCellIdx;                        
	int iCellDepth;                      
	u16 szCell;                          
	int bSkipnext = 0;                   
	u8 bPreserve = flags & BTREE_SAVEPOSITION;  

	assert(cursorOwnsBtShared(pCur));
	assert(pBt->inTransaction == TRANS_WRITE);
	assert((pBt->btsFlags & BTS_READ_ONLY) == 0);
	assert(pCur->curFlags & BTCF_WriteFlag);
	assert(hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo != 0, 2));
	assert(!hasReadConflicts(p, pCur->pgnoRoot));
	assert(pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell);
	assert(pCur->eState == CURSOR_VALID);
	assert((flags & ~(BTREE_SAVEPOSITION | BTREE_AUXDELETE)) == 0);

	iCellDepth = pCur->iPage;
	iCellIdx = pCur->aiIdx[iCellDepth];
	pPage = pCur->apPage[iCellDepth];
	pCell = findCell(pPage, iCellIdx);

	
	if (bPreserve) {
		if (!pPage->leaf
			|| (pPage->nFree + cellSizePtr(pPage, pCell) + 2)>(int)(pBt->usableSize * 2 / 3)
			) {
			
			rc = saveCursorKey(pCur);
			if (rc) return rc;
		}
		else {
			bSkipnext = 1;
		}
	}

	
	if (!pPage->leaf) {
		int notUsed = 0;
		rc = sqlite3BtreePrevious(pCur, &notUsed);
		if (rc) return rc;
	}

	
	if (pCur->curFlags & BTCF_Multiple) {
		rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
		if (rc) return rc;
	}

	
	if (pCur->pKeyInfo == 0) {
		invalidateIncrblobCursors(p, pCur->info.nKey, 0);
	}

	
	rc = sqlite3PagerWrite(pPage->pDbPage);
	if (rc) return rc;
	rc = clearCell(pPage, pCell, &szCell);
	dropCell(pPage, iCellIdx, szCell, &rc);
	if (rc) return rc;

	
	if (!pPage->leaf) {
		MemPage *pLeaf = pCur->apPage[pCur->iPage];
		int nCell;
		Pgno n = pCur->apPage[iCellDepth + 1]->pgno;
		unsigned char *pTmp;

		pCell = findCell(pLeaf, pLeaf->nCell - 1);
		if (pCell<&pLeaf->aData[4]) return SQLITE_CORRUPT_BKPT;
		nCell = pLeaf->xCellSize(pLeaf, pCell);
		assert(MX_CELL_SIZE(pBt) >= nCell);
		pTmp = pBt->pTmpSpace;
		assert(pTmp != 0);
		rc = sqlite3PagerWrite(pLeaf->pDbPage);
		if (rc == SQLITE_OK) {
			insertCell(pPage, iCellIdx, pCell - 4, nCell + 4, pTmp, n, &rc);
		}
		dropCell(pLeaf, pLeaf->nCell - 1, nCell, &rc);
		if (rc) return rc;
	}

	
	rc = balance(pCur);
	if (rc == SQLITE_OK && pCur->iPage>iCellDepth) {
		while (pCur->iPage>iCellDepth) {
			releasePage(pCur->apPage[pCur->iPage--]);
		}
		rc = balance(pCur);
	}

	if (rc == SQLITE_OK) {
		if (bSkipnext) {
			assert(bPreserve && (pCur->iPage == iCellDepth || CORRUPT_DB));
			assert(pPage == pCur->apPage[pCur->iPage] || CORRUPT_DB);
			assert((pPage->nCell>0 || CORRUPT_DB) && iCellIdx <= pPage->nCell);
			pCur->eState = CURSOR_SKIPNEXT;
			if (iCellIdx >= pPage->nCell) {
				pCur->skipNext = -1;
				pCur->aiIdx[iCellDepth] = pPage->nCell - 1;
			}
			else {
				pCur->skipNext = 1;
			}
		}
		else {
			rc = moveToRoot(pCur);
			if (bPreserve) {
				pCur->eState = CURSOR_REQUIRESEEK;
			}
		}
	}
	return rc;
}


static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags) {
	BtShared *pBt = p->pBt;
	MemPage *pRoot;
	Pgno pgnoRoot;
	int rc;
	int ptfFlags;          

	assert(sqlite3BtreeHoldsMutex(p));
	assert(pBt->inTransaction == TRANS_WRITE);
	assert((pBt->btsFlags & BTS_READ_ONLY) == 0);

#ifdef SQLITE_OMIT_AUTOVACUUM
	rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);
	if (rc) {
		return rc;
	}
#else
	if (pBt->autoVacuum) {
		Pgno pgnoMove;      
		MemPage *pPageMove; 

							
		invalidateAllOverflowCache(pBt);

		
		sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &pgnoRoot);
		pgnoRoot++;

		
		while (pgnoRoot == PTRMAP_PAGENO(pBt, pgnoRoot) ||
			pgnoRoot == PENDING_BYTE_PAGE(pBt)) {
			pgnoRoot++;
		}
		assert(pgnoRoot >= 3 || CORRUPT_DB);
		testcase(pgnoRoot<3);

		
		rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, BTALLOC_EXACT);
		if (rc != SQLITE_OK) {
			return rc;
		}

		if (pgnoMove != pgnoRoot) {
			
			u8 eType = 0;
			Pgno iPtrPage = 0;

			
			rc = saveAllCursors(pBt, 0, 0);
			releasePage(pPageMove);
			if (rc != SQLITE_OK) {
				return rc;
			}

			
			rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
			if (rc != SQLITE_OK) {
				return rc;
			}
			rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);
			if (eType == PTRMAP_ROOTPAGE || eType == PTRMAP_FREEPAGE) {
				rc = SQLITE_CORRUPT_BKPT;
			}
			if (rc != SQLITE_OK) {
				releasePage(pRoot);
				return rc;
			}
			assert(eType != PTRMAP_ROOTPAGE);
			assert(eType != PTRMAP_FREEPAGE);
			rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
			releasePage(pRoot);

			
			if (rc != SQLITE_OK) {
				return rc;
			}
			rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
			if (rc != SQLITE_OK) {
				return rc;
			}
			rc = sqlite3PagerWrite(pRoot->pDbPage);
			if (rc != SQLITE_OK) {
				releasePage(pRoot);
				return rc;
			}
		}
		else {
			pRoot = pPageMove;
		}

		
		ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, &rc);
		if (rc) {
			releasePage(pRoot);
			return rc;
		}

		
		assert(sqlite3PagerIswriteable(pBt->pPage1->pDbPage));
		rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);
		if (NEVER(rc)) {
			releasePage(pRoot);
			return rc;
		}

	}
	else {
		rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);
		if (rc) return rc;
	}
#endif
	assert(sqlite3PagerIswriteable(pRoot->pDbPage));
	if (createTabFlags & BTREE_INTKEY) {
		ptfFlags = PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF;
	}
	else {
		ptfFlags = PTF_ZERODATA | PTF_LEAF;
	}
	zeroPage(pRoot, ptfFlags);
	sqlite3PagerUnref(pRoot->pDbPage);
	assert((pBt->openFlags & BTREE_SINGLE) == 0 || pgnoRoot == 2);
	*piTable = (int)pgnoRoot;
	return SQLITE_OK;
}
SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags) {
	int rc;
	sqlite3BtreeEnter(p);
	rc = btreeCreateTable(p, piTable, flags);
	sqlite3BtreeLeave(p);
	return rc;
}


static int clearDatabasePage(
	BtShared *pBt,           
	Pgno pgno,               
	int freePageFlag,        
	int *pnChange            
) {
	MemPage *pPage;
	int rc;
	unsigned char *pCell;
	int i;
	int hdr;
	u16 szCell;

	assert(sqlite3_mutex_held(pBt->mutex));
	if (pgno>btreePagecount(pBt)) {
		return SQLITE_CORRUPT_BKPT;
	}
	rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);
	if (rc) return rc;
	if (pPage->bBusy) {
		rc = SQLITE_CORRUPT_BKPT;
		goto cleardatabasepage_out;
	}
	pPage->bBusy = 1;
	hdr = pPage->hdrOffset;
	for (i = 0; i<pPage->nCell; i++) {
		pCell = findCell(pPage, i);
		if (!pPage->leaf) {
			rc = clearDatabasePage(pBt, get4byte(pCell), 1, pnChange);
			if (rc) goto cleardatabasepage_out;
		}
		rc = clearCell(pPage, pCell, &szCell);
		if (rc) goto cleardatabasepage_out;
	}
	if (!pPage->leaf) {
		rc = clearDatabasePage(pBt, get4byte(&pPage->aData[hdr + 8]), 1, pnChange);
		if (rc) goto cleardatabasepage_out;
	}
	else if (pnChange) {
		assert(pPage->intKey || CORRUPT_DB);
		testcase(!pPage->intKey);
		*pnChange += pPage->nCell;
	}
	if (freePageFlag) {
		freePage(pPage, &rc);
	}
	else if ((rc = sqlite3PagerWrite(pPage->pDbPage)) == 0) {
		zeroPage(pPage, pPage->aData[hdr] | PTF_LEAF);
	}

cleardatabasepage_out:
	pPage->bBusy = 0;
	releasePage(pPage);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange) {
	int rc;
	BtShared *pBt = p->pBt;
	sqlite3BtreeEnter(p);
	assert(p->inTrans == TRANS_WRITE);

	rc = saveAllCursors(pBt, (Pgno)iTable, 0);

	if (SQLITE_OK == rc) {
		
		invalidateIncrblobCursors(p, 0, 1);
		rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);
	}
	sqlite3BtreeLeave(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor *pCur) {
	return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0);
}


static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved) {
	int rc;
	MemPage *pPage = 0;
	BtShared *pBt = p->pBt;

	assert(sqlite3BtreeHoldsMutex(p));
	assert(p->inTrans == TRANS_WRITE);

	
	if (NEVER(pBt->pCursor)) {
		sqlite3ConnectionBlocked(p->db, pBt->pCursor->pBtree->db);
		return SQLITE_LOCKED_SHAREDCACHE;
	}

	
	if (NEVER(iTable<2)) {
		return SQLITE_CORRUPT_BKPT;
	}

	rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);
	if (rc) return rc;
	rc = sqlite3BtreeClearTable(p, iTable, 0);
	if (rc) {
		releasePage(pPage);
		return rc;
	}

	*piMoved = 0;

#ifdef SQLITE_OMIT_AUTOVACUUM
	freePage(pPage, &rc);
	releasePage(pPage);
#else
	if (pBt->autoVacuum) {
		Pgno maxRootPgno;
		sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &maxRootPgno);

		if (iTable == maxRootPgno) {
			
			freePage(pPage, &rc);
			releasePage(pPage);
			if (rc != SQLITE_OK) {
				return rc;
			}
		}
		else {
			
			MemPage *pMove;
			releasePage(pPage);
			rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
			if (rc != SQLITE_OK) {
				return rc;
			}
			rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0);
			releasePage(pMove);
			if (rc != SQLITE_OK) {
				return rc;
			}
			pMove = 0;
			rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
			freePage(pMove, &rc);
			releasePage(pMove);
			if (rc != SQLITE_OK) {
				return rc;
			}
			*piMoved = maxRootPgno;
		}

		
		maxRootPgno--;
		while (maxRootPgno == PENDING_BYTE_PAGE(pBt)
			|| PTRMAP_ISPAGE(pBt, maxRootPgno)) {
			maxRootPgno--;
		}
		assert(maxRootPgno != PENDING_BYTE_PAGE(pBt));

		rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);
	}
	else {
		freePage(pPage, &rc);
		releasePage(pPage);
	}
#endif
	return rc;
}
SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved) {
	int rc;
	sqlite3BtreeEnter(p);
	rc = btreeDropTable(p, iTable, piMoved);
	sqlite3BtreeLeave(p);
	return rc;
}



SQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta) {
	BtShared *pBt = p->pBt;

	sqlite3BtreeEnter(p);
	assert(p->inTrans>TRANS_NONE);
	assert(SQLITE_OK == querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK));
	assert(pBt->pPage1);
	assert(idx >= 0 && idx <= 15);

	if (idx == BTREE_DATA_VERSION) {
		*pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iDataVersion;
	}
	else {
		*pMeta = get4byte(&pBt->pPage1->aData[36 + idx * 4]);
	}

	
#ifdef SQLITE_OMIT_AUTOVACUUM
	if (idx == BTREE_LARGEST_ROOT_PAGE && *pMeta>0) {
		pBt->btsFlags |= BTS_READ_ONLY;
	}
#endif

	sqlite3BtreeLeave(p);
}


SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta) {
	BtShared *pBt = p->pBt;
	unsigned char *pP1;
	int rc;
	assert(idx >= 1 && idx <= 15);
	sqlite3BtreeEnter(p);
	assert(p->inTrans == TRANS_WRITE);
	assert(pBt->pPage1 != 0);
	pP1 = pBt->pPage1->aData;
	rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
	if (rc == SQLITE_OK) {
		put4byte(&pP1[36 + idx * 4], iMeta);
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (idx == BTREE_INCR_VACUUM) {
			assert(pBt->autoVacuum || iMeta == 0);
			assert(iMeta == 0 || iMeta == 1);
			pBt->incrVacuum = (u8)iMeta;
		}
#endif
	}
	sqlite3BtreeLeave(p);
	return rc;
}

#ifndef SQLITE_OMIT_BTREECOUNT

SQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry) {
	i64 nEntry = 0;                      
	int rc;                              

	if (pCur->pgnoRoot == 0) {
		*pnEntry = 0;
		return SQLITE_OK;
	}
	rc = moveToRoot(pCur);

	
	while (rc == SQLITE_OK) {
		int iIdx;                          
		MemPage *pPage;                    

										   
		pPage = pCur->apPage[pCur->iPage];
		if (pPage->leaf || !pPage->intKey) {
			nEntry += pPage->nCell;
		}

		
		if (pPage->leaf) {
			do {
				if (pCur->iPage == 0) {
					
					*pnEntry = nEntry;
					return moveToRoot(pCur);
				}
				moveToParent(pCur);
			} while (pCur->aiIdx[pCur->iPage] >= pCur->apPage[pCur->iPage]->nCell);

			pCur->aiIdx[pCur->iPage]++;
			pPage = pCur->apPage[pCur->iPage];
		}

		
		iIdx = pCur->aiIdx[pCur->iPage];
		if (iIdx == pPage->nCell) {
			rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset + 8]));
		}
		else {
			rc = moveToChild(pCur, get4byte(findCell(pPage, iIdx)));
		}
	}

	
	return rc;
}
#endif


SQLITE_PRIVATE Pager *sqlite3BtreePager(Btree *p) {
	return p->pBt->pPager;
}

#ifndef SQLITE_OMIT_INTEGRITY_CHECK

static void checkAppendMsg(
	IntegrityCk *pCheck,
	const char *zFormat,
	...
) {
	va_list ap;
	if (!pCheck->mxErr) return;
	pCheck->mxErr--;
	pCheck->nErr++;
	va_start(ap, zFormat);
	if (pCheck->errMsg.nChar) {
		sqlite3StrAccumAppend(&pCheck->errMsg, "\n", 1);
	}
	if (pCheck->zPfx) {
		sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
	}
	sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
	va_end(ap);
	if (pCheck->errMsg.accError == STRACCUM_NOMEM) {
		pCheck->mallocFailed = 1;
	}
}
#endif 

#ifndef SQLITE_OMIT_INTEGRITY_CHECK


static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg) {
	assert(iPg <= pCheck->nPage && sizeof(pCheck->aPgRef[0]) == 1);
	return (pCheck->aPgRef[iPg / 8] & (1 << (iPg & 0x07)));
}


static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg) {
	assert(iPg <= pCheck->nPage && sizeof(pCheck->aPgRef[0]) == 1);
	pCheck->aPgRef[iPg / 8] |= (1 << (iPg & 0x07));
}



static int checkRef(IntegrityCk *pCheck, Pgno iPage) {
	if (iPage == 0) return 1;
	if (iPage>pCheck->nPage) {
		checkAppendMsg(pCheck, "invalid page number %d", iPage);
		return 1;
	}
	if (getPageReferenced(pCheck, iPage)) {
		checkAppendMsg(pCheck, "2nd reference to page %d", iPage);
		return 1;
	}
	setPageReferenced(pCheck, iPage);
	return 0;
}

#ifndef SQLITE_OMIT_AUTOVACUUM

static void checkPtrmap(
	IntegrityCk *pCheck,   
	Pgno iChild,           
	u8 eType,              
	Pgno iParent           
) {
	int rc;
	u8 ePtrmapType;
	Pgno iPtrmapParent;

	rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
	if (rc != SQLITE_OK) {
		if (rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM) pCheck->mallocFailed = 1;
		checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", iChild);
		return;
	}

	if (ePtrmapType != eType || iPtrmapParent != iParent) {
		checkAppendMsg(pCheck,
			"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",
			iChild, eType, iParent, ePtrmapType, iPtrmapParent);
	}
}
#endif


static void checkList(
	IntegrityCk *pCheck,  
	int isFreeList,       
	int iPage,            
	int N                 
) {
	int i;
	int expected = N;
	int iFirst = iPage;
	while (N-- > 0 && pCheck->mxErr) {
		DbPage *pOvflPage;
		unsigned char *pOvflData;
		if (iPage<1) {
			checkAppendMsg(pCheck,
				"%d of %d pages missing from overflow list starting at %d",
				N + 1, expected, iFirst);
			break;
		}
		if (checkRef(pCheck, iPage)) break;
		if (sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0)) {
			checkAppendMsg(pCheck, "failed to get page %d", iPage);
			break;
		}
		pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);
		if (isFreeList) {
			int n = get4byte(&pOvflData[4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
			if (pCheck->pBt->autoVacuum) {
				checkPtrmap(pCheck, iPage, PTRMAP_FREEPAGE, 0);
			}
#endif
			if (n>(int)pCheck->pBt->usableSize / 4 - 2) {
				checkAppendMsg(pCheck,
					"freelist leaf count too big on page %d", iPage);
				N--;
			}
			else {
				for (i = 0; i<n; i++) {
					Pgno iFreePage = get4byte(&pOvflData[8 + i * 4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
					if (pCheck->pBt->autoVacuum) {
						checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0);
					}
#endif
					checkRef(pCheck, iFreePage);
				}
				N -= n;
			}
		}
#ifndef SQLITE_OMIT_AUTOVACUUM
		else {
			
			if (pCheck->pBt->autoVacuum && N>0) {
				i = get4byte(pOvflData);
				checkPtrmap(pCheck, i, PTRMAP_OVERFLOW2, iPage);
			}
		}
#endif
		iPage = get4byte(pOvflData);
		sqlite3PagerUnref(pOvflPage);

		if (isFreeList && N<(iPage != 0)) {
			checkAppendMsg(pCheck, "free-page count in header is too small");
		}
	}
}
#endif 


static void btreeHeapInsert(u32 *aHeap, u32 x) {
	u32 j, i = ++aHeap[0];
	aHeap[i] = x;
	while ((j = i / 2)>0 && aHeap[j]>aHeap[i]) {
		x = aHeap[j];
		aHeap[j] = aHeap[i];
		aHeap[i] = x;
		i = j;
	}
}
static int btreeHeapPull(u32 *aHeap, u32 *pOut) {
	u32 j, i, x;
	if ((x = aHeap[0]) == 0) return 0;
	*pOut = aHeap[1];
	aHeap[1] = aHeap[x];
	aHeap[x] = 0xffffffff;
	aHeap[0]--;
	i = 1;
	while ((j = i * 2) <= aHeap[0]) {
		if (aHeap[j]>aHeap[j + 1]) j++;
		if (aHeap[i]<aHeap[j]) break;
		x = aHeap[i];
		aHeap[i] = aHeap[j];
		aHeap[j] = x;
		i = j;
	}
	return 1;
}

#ifndef SQLITE_OMIT_INTEGRITY_CHECK

static int checkTreePage(
	IntegrityCk *pCheck,  
	int iPage,            
	i64 *piMinKey,        
	i64 maxKey            
) {
	MemPage *pPage = 0;      
	int i;                   
	int rc;                  
	int depth = -1, d2;      
	int pgno;                
	int nFrag;               
	int hdr;                 
	int cellStart;           
	int nCell;               
	int doCoverageCheck = 1; 
	int keyCanBeEqual = 1;   
	u8 *data;                
	u8 *pCell;               
	u8 *pCellIdx;            
	BtShared *pBt;           
	u32 pc;                  
	u32 usableSize;          
	u32 contentOffset;       
	u32 *heap = 0;           
	u32 x, prev = 0;         
	const char *saved_zPfx = pCheck->zPfx;
	int saved_v1 = pCheck->v1;
	int saved_v2 = pCheck->v2;
	u8 savedIsInit = 0;

	
	pBt = pCheck->pBt;
	usableSize = pBt->usableSize;
	if (iPage == 0) return 0;
	if (checkRef(pCheck, iPage)) return 0;
	pCheck->zPfx = "Page %d: ";
	pCheck->v1 = iPage;
	if ((rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0)) != 0) {
		checkAppendMsg(pCheck,
			"unable to get the page. error code=%d", rc);
		goto end_of_check;
	}

	
	savedIsInit = pPage->isInit;
	pPage->isInit = 0;
	if ((rc = btreeInitPage(pPage)) != 0) {
		assert(rc == SQLITE_CORRUPT);  
		checkAppendMsg(pCheck,
			"btreeInitPage() returns error code %d", rc);
		goto end_of_check;
	}
	data = pPage->aData;
	hdr = pPage->hdrOffset;

	
	pCheck->zPfx = "On tree page %d cell %d: ";
	contentOffset = get2byteNotZero(&data[hdr + 5]);
	assert(contentOffset <= usableSize);  

										  
	nCell = get2byte(&data[hdr + 3]);
	assert(pPage->nCell == nCell);

	
	cellStart = hdr + 12 - 4 * pPage->leaf;
	assert(pPage->aCellIdx == &data[cellStart]);
	pCellIdx = &data[cellStart + 2 * (nCell - 1)];

	if (!pPage->leaf) {
		
		pgno = get4byte(&data[hdr + 8]);
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (pBt->autoVacuum) {
			pCheck->zPfx = "On page %d at right child: ";
			checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);
		}
#endif
		depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);
		keyCanBeEqual = 0;
	}
	else {
		
		heap = pCheck->heap;
		heap[0] = 0;
	}

	
	for (i = nCell - 1; i >= 0 && pCheck->mxErr; i--) {
		CellInfo info;

		
		pCheck->v2 = i;
		assert(pCellIdx == &data[cellStart + i * 2]);
		pc = get2byteAligned(pCellIdx);
		pCellIdx -= 2;
		if (pc<contentOffset || pc>usableSize - 4) {
			checkAppendMsg(pCheck, "Offset %d out of range %d..%d",
				pc, contentOffset, usableSize - 4);
			doCoverageCheck = 0;
			continue;
		}
		pCell = &data[pc];
		pPage->xParseCell(pPage, pCell, &info);
		if (pc + info.nSize>usableSize) {
			checkAppendMsg(pCheck, "Extends off end of page");
			doCoverageCheck = 0;
			continue;
		}

		
		if (pPage->intKey) {
			if (keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey)) {
				checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);
			}
			maxKey = info.nKey;
		}

		
		if (info.nPayload>info.nLocal) {
			int nPage;       
			Pgno pgnoOvfl;   
			assert(pc + info.nSize - 4 <= usableSize);
			nPage = (info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4);
			pgnoOvfl = get4byte(&pCell[info.nSize - 4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
			if (pBt->autoVacuum) {
				checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, iPage);
			}
#endif
			checkList(pCheck, 0, pgnoOvfl, nPage);
		}

		if (!pPage->leaf) {
			
			pgno = get4byte(pCell);
#ifndef SQLITE_OMIT_AUTOVACUUM
			if (pBt->autoVacuum) {
				checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);
			}
#endif
			d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);
			keyCanBeEqual = 0;
			if (d2 != depth) {
				checkAppendMsg(pCheck, "Child page depth differs");
				depth = d2;
			}
		}
		else {
			
			btreeHeapInsert(heap, (pc << 16) | (pc + info.nSize - 1));
		}
	}
	*piMinKey = maxKey;

	
	pCheck->zPfx = 0;
	if (doCoverageCheck && pCheck->mxErr>0) {
		
		if (!pPage->leaf) {
			heap = pCheck->heap;
			heap[0] = 0;
			for (i = nCell - 1; i >= 0; i--) {
				u32 size;
				pc = get2byteAligned(&data[cellStart + i * 2]);
				size = pPage->xCellSize(pPage, &data[pc]);
				btreeHeapInsert(heap, (pc << 16) | (pc + size - 1));
			}
		}
		
		i = get2byte(&data[hdr + 1]);
		while (i>0) {
			int size, j;
			assert((u32)i <= usableSize - 4);     
			size = get2byte(&data[i + 2]);
			assert((u32)(i + size) <= usableSize);  
			btreeHeapInsert(heap, (((u32)i) << 16) | (i + size - 1));
			
			j = get2byte(&data[i]);
			
			assert(j == 0 || j>i + size);  
			assert((u32)j <= usableSize - 4);   
			i = j;
		}
		
		nFrag = 0;
		prev = contentOffset - 1;   
		while (btreeHeapPull(heap, &x)) {
			if ((prev & 0xffff) >= (x >> 16)) {
				checkAppendMsg(pCheck,
					"Multiple uses for byte %u of page %d", x >> 16, iPage);
				break;
			}
			else {
				nFrag += (x >> 16) - (prev & 0xffff) - 1;
				prev = x;
			}
		}
		nFrag += usableSize - (prev & 0xffff) - 1;
		
		if (heap[0] == 0 && nFrag != data[hdr + 7]) {
			checkAppendMsg(pCheck,
				"Fragmentation of %d bytes reported as %d on page %d",
				nFrag, data[hdr + 7], iPage);
		}
	}

end_of_check:
	if (!doCoverageCheck) pPage->isInit = savedIsInit;
	releasePage(pPage);
	pCheck->zPfx = saved_zPfx;
	pCheck->v1 = saved_v1;
	pCheck->v2 = saved_v2;
	return depth + 1;
}
#endif 

#ifndef SQLITE_OMIT_INTEGRITY_CHECK

SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(
	Btree *p,     
	int *aRoot,   
	int nRoot,    
	int mxErr,    
	int *pnErr    
) {
	Pgno i;
	IntegrityCk sCheck;
	BtShared *pBt = p->pBt;
	int savedDbFlags = pBt->db->flags;
	char zErr[100];
	VVA_ONLY(int nRef);

	sqlite3BtreeEnter(p);
	assert(p->inTrans>TRANS_NONE && pBt->inTransaction>TRANS_NONE);
	VVA_ONLY(nRef = sqlite3PagerRefcount(pBt->pPager));
	assert(nRef >= 0);
	sCheck.pBt = pBt;
	sCheck.pPager = pBt->pPager;
	sCheck.nPage = btreePagecount(sCheck.pBt);
	sCheck.mxErr = mxErr;
	sCheck.nErr = 0;
	sCheck.mallocFailed = 0;
	sCheck.zPfx = 0;
	sCheck.v1 = 0;
	sCheck.v2 = 0;
	sCheck.aPgRef = 0;
	sCheck.heap = 0;
	sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof(zErr), SQLITE_MAX_LENGTH);
	sCheck.errMsg.printfFlags = SQLITE_PRINTF_INTERNAL;
	if (sCheck.nPage == 0) {
		goto integrity_ck_cleanup;
	}

	sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8) + 1);
	if (!sCheck.aPgRef) {
		sCheck.mallocFailed = 1;
		goto integrity_ck_cleanup;
	}
	sCheck.heap = (u32*)sqlite3PageMalloc(pBt->pageSize);
	if (sCheck.heap == 0) {
		sCheck.mallocFailed = 1;
		goto integrity_ck_cleanup;
	}

	i = PENDING_BYTE_PAGE(pBt);
	if (i <= sCheck.nPage) setPageReferenced(&sCheck, i);

	
	sCheck.zPfx = "Main freelist: ";
	checkList(&sCheck, 1, get4byte(&pBt->pPage1->aData[32]),
		get4byte(&pBt->pPage1->aData[36]));
	sCheck.zPfx = 0;

	
	testcase(pBt->db->flags & SQLITE_CellSizeCk);
	pBt->db->flags &= ~SQLITE_CellSizeCk;
	for (i = 0; (int)i<nRoot && sCheck.mxErr; i++) {
		i64 notUsed;
		if (aRoot[i] == 0) continue;
#ifndef SQLITE_OMIT_AUTOVACUUM
		if (pBt->autoVacuum && aRoot[i]>1) {
			checkPtrmap(&sCheck, aRoot[i], PTRMAP_ROOTPAGE, 0);
		}
#endif
		checkTreePage(&sCheck, aRoot[i], &notUsed, LARGEST_INT64);
	}
	pBt->db->flags = savedDbFlags;

	
	for (i = 1; i <= sCheck.nPage && sCheck.mxErr; i++) {
#ifdef SQLITE_OMIT_AUTOVACUUM
		if (getPageReferenced(&sCheck, i) == 0) {
			checkAppendMsg(&sCheck, "Page %d is never used", i);
		}
#else
		
		if (getPageReferenced(&sCheck, i) == 0 &&
			(PTRMAP_PAGENO(pBt, i) != i || !pBt->autoVacuum)) {
			checkAppendMsg(&sCheck, "Page %d is never used", i);
		}
		if (getPageReferenced(&sCheck, i) != 0 &&
			(PTRMAP_PAGENO(pBt, i) == i && pBt->autoVacuum)) {
			checkAppendMsg(&sCheck, "Pointer map page %d is referenced", i);
		}
#endif
	}

	
integrity_ck_cleanup:
	sqlite3PageFree(sCheck.heap);
	sqlite3_free(sCheck.aPgRef);
	if (sCheck.mallocFailed) {
		sqlite3StrAccumReset(&sCheck.errMsg);
		sCheck.nErr++;
	}
	*pnErr = sCheck.nErr;
	if (sCheck.nErr == 0) sqlite3StrAccumReset(&sCheck.errMsg);
	
	assert(nRef == sqlite3PagerRefcount(pBt->pPager));
	sqlite3BtreeLeave(p);
	return sqlite3StrAccumFinish(&sCheck.errMsg);
}
#endif 


SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *p) {
	assert(p->pBt->pPager != 0);
	return sqlite3PagerFilename(p->pBt->pPager, 1);
}


SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *p) {
	assert(p->pBt->pPager != 0);
	return sqlite3PagerJournalname(p->pBt->pPager);
}


SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree *p) {
	assert(p == 0 || sqlite3_mutex_held(p->db->mutex));
	return (p && (p->inTrans == TRANS_WRITE));
}

#ifndef SQLITE_OMIT_WAL

SQLITE_PRIVATE int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt) {
	int rc = SQLITE_OK;
	if (p) {
		BtShared *pBt = p->pBt;
		sqlite3BtreeEnter(p);
		if (pBt->inTransaction != TRANS_NONE) {
			rc = SQLITE_LOCKED;
		}
		else {
			rc = sqlite3PagerCheckpoint(pBt->pPager, eMode, pnLog, pnCkpt);
		}
		sqlite3BtreeLeave(p);
	}
	return rc;
}
#endif


SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree *p) {
	assert(p);
	assert(sqlite3_mutex_held(p->db->mutex));
	return p->inTrans != TRANS_NONE;
}

SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree *p) {
	assert(p);
	assert(sqlite3_mutex_held(p->db->mutex));
	return p->nBackup != 0;
}


SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)) {
	BtShared *pBt = p->pBt;
	sqlite3BtreeEnter(p);
	if (!pBt->pSchema && nBytes) {
		pBt->pSchema = sqlite3DbMallocZero(0, nBytes);
		pBt->xFreeSchema = xFree;
	}
	sqlite3BtreeLeave(p);
	return pBt->pSchema;
}


SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *p) {
	int rc;
	assert(sqlite3_mutex_held(p->db->mutex));
	sqlite3BtreeEnter(p);
	rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);
	assert(rc == SQLITE_OK || rc == SQLITE_LOCKED_SHAREDCACHE);
	sqlite3BtreeLeave(p);
	return rc;
}


#ifndef SQLITE_OMIT_SHARED_CACHE

SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock) {
	int rc = SQLITE_OK;
	assert(p->inTrans != TRANS_NONE);
	if (p->sharable) {
		u8 lockType = READ_LOCK + isWriteLock;
		assert(READ_LOCK + 1 == WRITE_LOCK);
		assert(isWriteLock == 0 || isWriteLock == 1);

		sqlite3BtreeEnter(p);
		rc = querySharedCacheTableLock(p, iTab, lockType);
		if (rc == SQLITE_OK) {
			rc = setSharedCacheTableLock(p, iTab, lockType);
		}
		sqlite3BtreeLeave(p);
	}
	return rc;
}
#endif

#ifndef SQLITE_OMIT_INCRBLOB

SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z) {
	int rc;
	assert(cursorOwnsBtShared(pCsr));
	assert(sqlite3_mutex_held(pCsr->pBtree->db->mutex));
	assert(pCsr->curFlags & BTCF_Incrblob);

	rc = restoreCursorPosition(pCsr);
	if (rc != SQLITE_OK) {
		return rc;
	}
	assert(pCsr->eState != CURSOR_REQUIRESEEK);
	if (pCsr->eState != CURSOR_VALID) {
		return SQLITE_ABORT;
	}

	
	VVA_ONLY(rc = ) saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
	assert(rc == SQLITE_OK);

	
	if ((pCsr->curFlags & BTCF_WriteFlag) == 0) {
		return SQLITE_READONLY;
	}
	assert((pCsr->pBt->btsFlags & BTS_READ_ONLY) == 0
		&& pCsr->pBt->inTransaction == TRANS_WRITE);
	assert(hasSharedCacheTableLock(pCsr->pBtree, pCsr->pgnoRoot, 0, 2));
	assert(!hasReadConflicts(pCsr->pBtree, pCsr->pgnoRoot));
	assert(pCsr->apPage[pCsr->iPage]->intKey);

	return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
}


SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *pCur) {
	pCur->curFlags |= BTCF_Incrblob;
	pCur->pBtree->hasIncrblobCur = 1;
}
#endif


SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion) {
	BtShared *pBt = pBtree->pBt;
	int rc;                         

	assert(iVersion == 1 || iVersion == 2);

	
	pBt->btsFlags &= ~BTS_NO_WAL;
	if (iVersion == 1) pBt->btsFlags |= BTS_NO_WAL;

	rc = sqlite3BtreeBeginTrans(pBtree, 0);
	if (rc == SQLITE_OK) {
		u8 *aData = pBt->pPage1->aData;
		if (aData[18] != (u8)iVersion || aData[19] != (u8)iVersion) {
			rc = sqlite3BtreeBeginTrans(pBtree, 2);
			if (rc == SQLITE_OK) {
				rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
				if (rc == SQLITE_OK) {
					aData[18] = (u8)iVersion;
					aData[19] = (u8)iVersion;
				}
			}
		}
	}

	pBt->btsFlags &= ~BTS_NO_WAL;
	return rc;
}


SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask) {
	return (pCsr->hints & mask) != 0;
}


SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *p) {
	return (p->pBt->btsFlags & BTS_READ_ONLY) != 0;
}


SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void) { return ROUND8(sizeof(MemPage)); }

#if !defined(SQLITE_OMIT_SHARED_CACHE)

SQLITE_PRIVATE int sqlite3BtreeSharable(Btree *p) {
	return p->sharable;
}


SQLITE_PRIVATE int sqlite3BtreeConnectionCount(Btree *p) {
	testcase(p->sharable);
	return p->pBt->nRef;
}
#endif








struct sqlite3_backup {
	sqlite3* pDestDb;        
	Btree *pDest;            
	u32 iDestSchema;         
	int bDestLocked;         

	Pgno iNext;              
	sqlite3* pSrcDb;         
	Btree *pSrc;             

	int rc;                  

							 
	Pgno nRemaining;         
	Pgno nPagecount;         

	int isAttached;          
	sqlite3_backup *pNext;   
};




static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb) {
	int i = sqlite3FindDbName(pDb, zDb);

	if (i == 1) {
		Parse sParse;
		int rc = 0;
		memset(&sParse, 0, sizeof(sParse));
		sParse.db = pDb;
		if (sqlite3OpenTempDatabase(&sParse)) {
			sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);
			rc = SQLITE_ERROR;
		}
		sqlite3DbFree(pErrorDb, sParse.zErrMsg);
		sqlite3ParserReset(&sParse);
		if (rc) {
			return 0;
		}
	}

	if (i<0) {
		sqlite3ErrorWithMsg(pErrorDb, SQLITE_ERROR, "unknown database %s", zDb);
		return 0;
	}

	return pDb->aDb[i].pBt;
}


static int setDestPgsz(sqlite3_backup *p) {
	int rc;
	rc = sqlite3BtreeSetPageSize(p->pDest, sqlite3BtreeGetPageSize(p->pSrc), -1, 0);
	return rc;
}


static int checkReadTransaction(sqlite3 *db, Btree *p) {
	if (sqlite3BtreeIsInReadTrans(p)) {
		sqlite3ErrorWithMsg(db, SQLITE_ERROR, "destination database is in use");
		return SQLITE_ERROR;
	}
	return SQLITE_OK;
}


SQLITE_API sqlite3_backup *sqlite3_backup_init(
	sqlite3* pDestDb,                     
	const char *zDestDb,                  
	sqlite3* pSrcDb,                      
	const char *zSrcDb                    
) {
	sqlite3_backup *p;                    

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(pSrcDb) || !sqlite3SafetyCheckOk(pDestDb)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif

	
	sqlite3_mutex_enter(pSrcDb->mutex);
	sqlite3_mutex_enter(pDestDb->mutex);

	if (pSrcDb == pDestDb) {
		sqlite3ErrorWithMsg(
			pDestDb, SQLITE_ERROR, "source and destination must be distinct"
		);
		p = 0;
	}
	else {
		
		p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));
		if (!p) {
			sqlite3Error(pDestDb, SQLITE_NOMEM_BKPT);
		}
	}

	
	if (p) {
		p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
		p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
		p->pDestDb = pDestDb;
		p->pSrcDb = pSrcDb;
		p->iNext = 1;
		p->isAttached = 0;

		if (0 == p->pSrc || 0 == p->pDest
			|| checkReadTransaction(pDestDb, p->pDest) != SQLITE_OK
			) {
			
			sqlite3_free(p);
			p = 0;
		}
	}
	if (p) {
		p->pSrc->nBackup++;
	}

	sqlite3_mutex_leave(pDestDb->mutex);
	sqlite3_mutex_leave(pSrcDb->mutex);
	return p;
}


static int isFatalError(int rc) {
	return (rc != SQLITE_OK && rc != SQLITE_BUSY && ALWAYS(rc != SQLITE_LOCKED));
}


static int backupOnePage(
	sqlite3_backup *p,              
	Pgno iSrcPg,                    
	const u8 *zSrcData,             
	int bUpdate                     
) {
	Pager * const pDestPager = sqlite3BtreePager(p->pDest);
	const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);
	int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);
	const int nCopy = MIN(nSrcPgsz, nDestPgsz);
	const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;
#ifdef SQLITE_HAS_CODEC
	
	int nSrcReserve = sqlite3BtreeGetReserveNoMutex(p->pSrc);
	int nDestReserve = sqlite3BtreeGetOptimalReserve(p->pDest);
#endif
	int rc = SQLITE_OK;
	i64 iOff;

	assert(sqlite3BtreeGetReserveNoMutex(p->pSrc) >= 0);
	assert(p->bDestLocked);
	assert(!isFatalError(p->rc));
	assert(iSrcPg != PENDING_BYTE_PAGE(p->pSrc->pBt));
	assert(zSrcData);

	
	if (nSrcPgsz != nDestPgsz && sqlite3PagerIsMemdb(pDestPager)) {
		rc = SQLITE_READONLY;
	}

#ifdef SQLITE_HAS_CODEC
	
	if (nSrcPgsz != nDestPgsz && sqlite3PagerGetCodec(pDestPager) != 0) {
		rc = SQLITE_READONLY;
	}

	
	if (nSrcReserve != nDestReserve) {
		u32 newPgsz = nSrcPgsz;
		rc = sqlite3PagerSetPagesize(pDestPager, &newPgsz, nSrcReserve);
		if (rc == SQLITE_OK && newPgsz != nSrcPgsz) rc = SQLITE_READONLY;
	}
#endif

	
	for (iOff = iEnd - (i64)nSrcPgsz; rc == SQLITE_OK && iOff<iEnd; iOff += nDestPgsz) {
		DbPage *pDestPg = 0;
		Pgno iDest = (Pgno)(iOff / nDestPgsz) + 1;
		if (iDest == PENDING_BYTE_PAGE(p->pDest->pBt)) continue;
		if (SQLITE_OK == (rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))
			&& SQLITE_OK == (rc = sqlite3PagerWrite(pDestPg))
			) {
			const u8 *zIn = &zSrcData[iOff%nSrcPgsz];
			u8 *zDestData = sqlite3PagerGetData(pDestPg);
			u8 *zOut = &zDestData[iOff%nDestPgsz];

			
			memcpy(zOut, zIn, nCopy);
			((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;
			if (iOff == 0 && bUpdate == 0) {
				sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));
			}
		}
		sqlite3PagerUnref(pDestPg);
	}

	return rc;
}


static int backupTruncateFile(sqlite3_file *pFile, i64 iSize) {
	i64 iCurrent;
	int rc = sqlite3OsFileSize(pFile, &iCurrent);
	if (rc == SQLITE_OK && iCurrent>iSize) {
		rc = sqlite3OsTruncate(pFile, iSize);
	}
	return rc;
}


static void attachBackupObject(sqlite3_backup *p) {
	sqlite3_backup **pp;
	assert(sqlite3BtreeHoldsMutex(p->pSrc));
	pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
	p->pNext = *pp;
	*pp = p;
	p->isAttached = 1;
}


SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
	int rc;
	int destMode;       
	int pgszSrc = 0;    
	int pgszDest = 0;   

#ifdef SQLITE_ENABLE_API_ARMOR
	if (p == 0) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(p->pSrcDb->mutex);
	sqlite3BtreeEnter(p->pSrc);
	if (p->pDestDb) {
		sqlite3_mutex_enter(p->pDestDb->mutex);
	}

	rc = p->rc;
	if (!isFatalError(rc)) {
		Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);     
		Pager * const pDestPager = sqlite3BtreePager(p->pDest);   
		int ii;                            
		int nSrcPage = -1;                 
		int bCloseTrans = 0;               

										   
		if (p->pDestDb && p->pSrc->pBt->inTransaction == TRANS_WRITE) {
			rc = SQLITE_BUSY;
		}
		else {
			rc = SQLITE_OK;
		}

		
		if (rc == SQLITE_OK && 0 == sqlite3BtreeIsInReadTrans(p->pSrc)) {
			rc = sqlite3BtreeBeginTrans(p->pSrc, 0);
			bCloseTrans = 1;
		}

		
		if (p->bDestLocked == 0 && rc == SQLITE_OK && setDestPgsz(p) == SQLITE_NOMEM) {
			rc = SQLITE_NOMEM;
		}

		
		if (SQLITE_OK == rc && p->bDestLocked == 0
			&& SQLITE_OK == (rc = sqlite3BtreeBeginTrans(p->pDest, 2))
			) {
			p->bDestLocked = 1;
			sqlite3BtreeGetMeta(p->pDest, BTREE_SCHEMA_VERSION, &p->iDestSchema);
		}

		
		pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
		pgszDest = sqlite3BtreeGetPageSize(p->pDest);
		destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));
		if (SQLITE_OK == rc && destMode == PAGER_JOURNALMODE_WAL && pgszSrc != pgszDest) {
			rc = SQLITE_READONLY;
		}

		
		nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);
		assert(nSrcPage >= 0);
		for (ii = 0; (nPage<0 || ii<nPage) && p->iNext <= (Pgno)nSrcPage && !rc; ii++) {
			const Pgno iSrcPg = p->iNext;                 
			if (iSrcPg != PENDING_BYTE_PAGE(p->pSrc->pBt)) {
				DbPage *pSrcPg;                             
				rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, PAGER_GET_READONLY);
				if (rc == SQLITE_OK) {
					rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);
					sqlite3PagerUnref(pSrcPg);
				}
			}
			p->iNext++;
		}
		if (rc == SQLITE_OK) {
			p->nPagecount = nSrcPage;
			p->nRemaining = nSrcPage + 1 - p->iNext;
			if (p->iNext>(Pgno)nSrcPage) {
				rc = SQLITE_DONE;
			}
			else if (!p->isAttached) {
				attachBackupObject(p);
			}
		}

		
		if (rc == SQLITE_DONE) {
			if (nSrcPage == 0) {
				rc = sqlite3BtreeNewDb(p->pDest);
				nSrcPage = 1;
			}
			if (rc == SQLITE_OK || rc == SQLITE_DONE) {
				rc = sqlite3BtreeUpdateMeta(p->pDest, 1, p->iDestSchema + 1);
			}
			if (rc == SQLITE_OK) {
				if (p->pDestDb) {
					sqlite3ResetAllSchemasOfConnection(p->pDestDb);
				}
				if (destMode == PAGER_JOURNALMODE_WAL) {
					rc = sqlite3BtreeSetVersion(p->pDest, 2);
				}
			}
			if (rc == SQLITE_OK) {
				int nDestTruncate;
				
				assert(pgszSrc == sqlite3BtreeGetPageSize(p->pSrc));
				assert(pgszDest == sqlite3BtreeGetPageSize(p->pDest));
				if (pgszSrc<pgszDest) {
					int ratio = pgszDest / pgszSrc;
					nDestTruncate = (nSrcPage + ratio - 1) / ratio;
					if (nDestTruncate == (int)PENDING_BYTE_PAGE(p->pDest->pBt)) {
						nDestTruncate--;
					}
				}
				else {
					nDestTruncate = nSrcPage * (pgszSrc / pgszDest);
				}
				assert(nDestTruncate>0);

				if (pgszSrc<pgszDest) {
					
					const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
					sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
					Pgno iPg;
					int nDstPage;
					i64 iOff;
					i64 iEnd;

					assert(pFile);
					assert(nDestTruncate == 0
						|| (i64)nDestTruncate*(i64)pgszDest >= iSize || (
							nDestTruncate == (int)(PENDING_BYTE_PAGE(p->pDest->pBt) - 1)
							&& iSize >= PENDING_BYTE && iSize <= PENDING_BYTE + pgszDest
							));

					
					sqlite3PagerPagecount(pDestPager, &nDstPage);
					for (iPg = nDestTruncate; rc == SQLITE_OK && iPg <= (Pgno)nDstPage; iPg++) {
						if (iPg != PENDING_BYTE_PAGE(p->pDest->pBt)) {
							DbPage *pPg;
							rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);
							if (rc == SQLITE_OK) {
								rc = sqlite3PagerWrite(pPg);
								sqlite3PagerUnref(pPg);
							}
						}
					}
					if (rc == SQLITE_OK) {
						rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);
					}

					
					iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
					for (
						iOff = PENDING_BYTE + pgszSrc;
						rc == SQLITE_OK && iOff<iEnd;
						iOff += pgszSrc
						) {
						PgHdr *pSrcPg = 0;
						const Pgno iSrcPg = (Pgno)((iOff / pgszSrc) + 1);
						rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);
						if (rc == SQLITE_OK) {
							u8 *zData = sqlite3PagerGetData(pSrcPg);
							rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
						}
						sqlite3PagerUnref(pSrcPg);
					}
					if (rc == SQLITE_OK) {
						rc = backupTruncateFile(pFile, iSize);
					}

					
					if (rc == SQLITE_OK) {
						rc = sqlite3PagerSync(pDestPager, 0);
					}
				}
				else {
					sqlite3PagerTruncateImage(pDestPager, nDestTruncate);
					rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);
				}

				
				if (SQLITE_OK == rc
					&& SQLITE_OK == (rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))
					) {
					rc = SQLITE_DONE;
				}
			}
		}

		
		if (bCloseTrans) {
			TESTONLY(int rc2);
			TESTONLY(rc2 = ) sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
			TESTONLY(rc2 |= ) sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
			assert(rc2 == SQLITE_OK);
		}

		if (rc == SQLITE_IOERR_NOMEM) {
			rc = SQLITE_NOMEM_BKPT;
		}
		p->rc = rc;
	}
	if (p->pDestDb) {
		sqlite3_mutex_leave(p->pDestDb->mutex);
	}
	sqlite3BtreeLeave(p->pSrc);
	sqlite3_mutex_leave(p->pSrcDb->mutex);
	return rc;
}


SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p) {
	sqlite3_backup **pp;                 
	sqlite3 *pSrcDb;                     
	int rc;                              

										 
	if (p == 0) return SQLITE_OK;
	pSrcDb = p->pSrcDb;
	sqlite3_mutex_enter(pSrcDb->mutex);
	sqlite3BtreeEnter(p->pSrc);
	if (p->pDestDb) {
		sqlite3_mutex_enter(p->pDestDb->mutex);
	}

	
	if (p->pDestDb) {
		p->pSrc->nBackup--;
	}
	if (p->isAttached) {
		pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
		while (*pp != p) {
			pp = &(*pp)->pNext;
		}
		*pp = p->pNext;
	}

	
	sqlite3BtreeRollback(p->pDest, SQLITE_OK, 0);

	
	rc = (p->rc == SQLITE_DONE) ? SQLITE_OK : p->rc;
	if (p->pDestDb) {
		sqlite3Error(p->pDestDb, rc);

		
		sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
	}
	sqlite3BtreeLeave(p->pSrc);
	if (p->pDestDb) {
		
		sqlite3_free(p);
	}
	sqlite3LeaveMutexAndCloseZombie(pSrcDb);
	return rc;
}


SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (p == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return p->nRemaining;
}


SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (p == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return p->nPagecount;
}


static SQLITE_NOINLINE void backupUpdate(
	sqlite3_backup *p,
	Pgno iPage,
	const u8 *aData
) {
	assert(p != 0);
	do {
		assert(sqlite3_mutex_held(p->pSrc->pBt->mutex));
		if (!isFatalError(p->rc) && iPage<p->iNext) {
			
			int rc;
			assert(p->pDestDb);
			sqlite3_mutex_enter(p->pDestDb->mutex);
			rc = backupOnePage(p, iPage, aData, 1);
			sqlite3_mutex_leave(p->pDestDb->mutex);
			assert(rc != SQLITE_BUSY && rc != SQLITE_LOCKED);
			if (rc != SQLITE_OK) {
				p->rc = rc;
			}
		}
	} while ((p = p->pNext) != 0);
}
SQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData) {
	if (pBackup) backupUpdate(pBackup, iPage, aData);
}


SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *pBackup) {
	sqlite3_backup *p;                   
	for (p = pBackup; p; p = p->pNext) {
		assert(sqlite3_mutex_held(p->pSrc->pBt->mutex));
		p->iNext = 1;
	}
}

#ifndef SQLITE_OMIT_VACUUM

SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom) {
	int rc;
	sqlite3_file *pFd;              
	sqlite3_backup b;
	sqlite3BtreeEnter(pTo);
	sqlite3BtreeEnter(pFrom);

	assert(sqlite3BtreeIsInTrans(pTo));
	pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
	if (pFd->pMethods) {
		i64 nByte = sqlite3BtreeGetPageSize(pFrom)*(i64)sqlite3BtreeLastPage(pFrom);
		rc = sqlite3OsFileControl(pFd, SQLITE_FCNTL_OVERWRITE, &nByte);
		if (rc == SQLITE_NOTFOUND) rc = SQLITE_OK;
		if (rc) goto copy_finished;
	}

	
	memset(&b, 0, sizeof(b));
	b.pSrcDb = pFrom->db;
	b.pSrc = pFrom;
	b.pDest = pTo;
	b.iNext = 1;

#ifdef SQLITE_HAS_CODEC
	sqlite3PagerAlignReserve(sqlite3BtreePager(pTo), sqlite3BtreePager(pFrom));
#endif

	
	sqlite3_backup_step(&b, 0x7FFFFFFF);
	assert(b.rc != SQLITE_OK);

	rc = sqlite3_backup_finish(&b);
	if (rc == SQLITE_OK) {
		pTo->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
	}
	else {
		sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
	}

	assert(sqlite3BtreeIsInTrans(pTo) == 0);
copy_finished:
	sqlite3BtreeLeave(pFrom);
	sqlite3BtreeLeave(pTo);
	return rc;
}
#endif 







#ifdef SQLITE_DEBUG

SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem *p) {
	
	assert((p->flags & MEM_Dyn) == 0 || p->xDel != 0);

	
	assert((p->flags & MEM_Dyn) == 0 || p->szMalloc == 0);

	
	assert((p->flags & (MEM_Int | MEM_Real)) != (MEM_Int | MEM_Real));

	
	assert(p->szMalloc == 0
		|| p->szMalloc == sqlite3DbMallocSize(p->db, p->zMalloc));

	
	if ((p->flags & (MEM_Str | MEM_Blob)) && p->n>0) {
		assert(
			((p->szMalloc>0 && p->z == p->zMalloc) ? 1 : 0) +
			((p->flags&MEM_Dyn) != 0 ? 1 : 0) +
			((p->flags&MEM_Ephem) != 0 ? 1 : 0) +
			((p->flags&MEM_Static) != 0 ? 1 : 0) == 1
		);
	}
	return 1;
}
#endif



SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc) {
#ifndef SQLITE_OMIT_UTF16
	int rc;
#endif
	assert((pMem->flags&MEM_RowSet) == 0);
	assert(desiredEnc == SQLITE_UTF8 || desiredEnc == SQLITE_UTF16LE
		|| desiredEnc == SQLITE_UTF16BE);
	if (!(pMem->flags&MEM_Str) || pMem->enc == desiredEnc) {
		return SQLITE_OK;
	}
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
#ifdef SQLITE_OMIT_UTF16
	return SQLITE_ERROR;
#else

	
	rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
	assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
	assert(rc == SQLITE_OK || pMem->enc != desiredEnc);
	assert(rc == SQLITE_NOMEM || pMem->enc == desiredEnc);
	return rc;
#endif
}


SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve) {
	assert(sqlite3VdbeCheckMemInvariants(pMem));
	assert((pMem->flags&MEM_RowSet) == 0);
	testcase(pMem->db == 0);

	
	assert(bPreserve == 0 || pMem->flags&(MEM_Blob | MEM_Str));
	testcase(bPreserve && pMem->z == 0);

	assert(pMem->szMalloc == 0
		|| pMem->szMalloc == sqlite3DbMallocSize(pMem->db, pMem->zMalloc));
	if (pMem->szMalloc<n) {
		if (n<32) n = 32;
		if (bPreserve && pMem->szMalloc>0 && pMem->z == pMem->zMalloc) {
			pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
			bPreserve = 0;
		}
		else {
			if (pMem->szMalloc>0) sqlite3DbFree(pMem->db, pMem->zMalloc);
			pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
		}
		if (pMem->zMalloc == 0) {
			sqlite3VdbeMemSetNull(pMem);
			pMem->z = 0;
			pMem->szMalloc = 0;
			return SQLITE_NOMEM_BKPT;
		}
		else {
			pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
		}
	}

	if (bPreserve && pMem->z && pMem->z != pMem->zMalloc) {
		memcpy(pMem->zMalloc, pMem->z, pMem->n);
	}
	if ((pMem->flags&MEM_Dyn) != 0) {
		assert(pMem->xDel != 0 && pMem->xDel != SQLITE_DYNAMIC);
		pMem->xDel((void *)(pMem->z));
	}

	pMem->z = pMem->zMalloc;
	pMem->flags &= ~(MEM_Dyn | MEM_Ephem | MEM_Static);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew) {
	assert(szNew>0);
	assert((pMem->flags & MEM_Dyn) == 0 || pMem->szMalloc == 0);
	if (pMem->szMalloc<szNew) {
		return sqlite3VdbeMemGrow(pMem, szNew, 0);
	}
	assert((pMem->flags & MEM_Dyn) == 0);
	pMem->z = pMem->zMalloc;
	pMem->flags &= (MEM_Null | MEM_Int | MEM_Real);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem) {
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert((pMem->flags&MEM_RowSet) == 0);
	if ((pMem->flags & (MEM_Str | MEM_Blob)) != 0) {
		if (ExpandBlob(pMem)) return SQLITE_NOMEM;
		if (pMem->szMalloc == 0 || pMem->z != pMem->zMalloc) {
			if (sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1)) {
				return SQLITE_NOMEM_BKPT;
			}
			pMem->z[pMem->n] = 0;
			pMem->z[pMem->n + 1] = 0;
			pMem->flags |= MEM_Term;
		}
	}
	pMem->flags &= ~MEM_Ephem;
#ifdef SQLITE_DEBUG
	pMem->pScopyFrom = 0;
#endif

	return SQLITE_OK;
}


#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *pMem) {
	int nByte;
	assert(pMem->flags & MEM_Zero);
	assert(pMem->flags&MEM_Blob);
	assert((pMem->flags&MEM_RowSet) == 0);
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));

	
	nByte = pMem->n + pMem->u.nZero;
	if (nByte <= 0) {
		nByte = 1;
	}
	if (sqlite3VdbeMemGrow(pMem, nByte, 1)) {
		return SQLITE_NOMEM_BKPT;
	}

	memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
	pMem->n += pMem->u.nZero;
	pMem->flags &= ~(MEM_Zero | MEM_Term);
	return SQLITE_OK;
}
#endif


static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem) {
	if (sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1)) {
		return SQLITE_NOMEM_BKPT;
	}
	pMem->z[pMem->n] = 0;
	pMem->z[pMem->n + 1] = 0;
	pMem->flags |= MEM_Term;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem *pMem) {
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	testcase((pMem->flags & (MEM_Term | MEM_Str)) == (MEM_Term | MEM_Str));
	testcase((pMem->flags & (MEM_Term | MEM_Str)) == 0);
	if ((pMem->flags & (MEM_Term | MEM_Str)) != MEM_Str) {
		return SQLITE_OK;   
	}
	else {
		return vdbeMemAddTerminator(pMem);
	}
}


SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce) {
	int fg = pMem->flags;
	const int nByte = 32;

	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(!(fg&MEM_Zero));
	assert(!(fg&(MEM_Str | MEM_Blob)));
	assert(fg&(MEM_Int | MEM_Real));
	assert((pMem->flags&MEM_RowSet) == 0);
	assert(EIGHT_BYTE_ALIGNMENT(pMem));


	if (sqlite3VdbeMemClearAndResize(pMem, nByte)) {
		pMem->enc = 0;
		return SQLITE_NOMEM_BKPT;
	}

	
	if (fg & MEM_Int) {
		sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i);
	}
	else {
		assert(fg & MEM_Real);
		sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->u.r);
	}
	pMem->n = sqlite3Strlen30(pMem->z);
	pMem->enc = SQLITE_UTF8;
	pMem->flags |= MEM_Str | MEM_Term;
	if (bForce) pMem->flags &= ~(MEM_Int | MEM_Real);
	sqlite3VdbeChangeEncoding(pMem, enc);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc) {
	int rc = SQLITE_OK;
	if (ALWAYS(pFunc && pFunc->xFinalize)) {
		sqlite3_context ctx;
		Mem t;
		assert((pMem->flags & MEM_Null) != 0 || pFunc == pMem->u.pDef);
		assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
		memset(&ctx, 0, sizeof(ctx));
		memset(&t, 0, sizeof(t));
		t.flags = MEM_Null;
		t.db = pMem->db;
		ctx.pOut = &t;
		ctx.pMem = pMem;
		ctx.pFunc = pFunc;
		pFunc->xFinalize(&ctx); 
		assert((pMem->flags & MEM_Dyn) == 0);
		if (pMem->szMalloc>0) sqlite3DbFree(pMem->db, pMem->zMalloc);
		memcpy(pMem, &t, sizeof(t));
		rc = ctx.isError;
	}
	return rc;
}


static SQLITE_NOINLINE void vdbeMemClearExternAndSetNull(Mem *p) {
	assert(p->db == 0 || sqlite3_mutex_held(p->db->mutex));
	assert(VdbeMemDynamic(p));
	if (p->flags&MEM_Agg) {
		sqlite3VdbeMemFinalize(p, p->u.pDef);
		assert((p->flags & MEM_Agg) == 0);
		testcase(p->flags & MEM_Dyn);
	}
	if (p->flags&MEM_Dyn) {
		assert((p->flags&MEM_RowSet) == 0);
		assert(p->xDel != SQLITE_DYNAMIC && p->xDel != 0);
		p->xDel((void *)p->z);
	}
	else if (p->flags&MEM_RowSet) {
		sqlite3RowSetClear(p->u.pRowSet);
	}
	else if (p->flags&MEM_Frame) {
		VdbeFrame *pFrame = p->u.pFrame;
		pFrame->pParent = pFrame->v->pDelFrame;
		pFrame->v->pDelFrame = pFrame;
	}
	p->flags = MEM_Null;
}


static SQLITE_NOINLINE void vdbeMemClear(Mem *p) {
	if (VdbeMemDynamic(p)) {
		vdbeMemClearExternAndSetNull(p);
	}
	if (p->szMalloc) {
		sqlite3DbFree(p->db, p->zMalloc);
		p->szMalloc = 0;
	}
	p->z = 0;
}


SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p) {
	assert(sqlite3VdbeCheckMemInvariants(p));
	if (VdbeMemDynamic(p) || p->szMalloc) {
		vdbeMemClear(p);
	}
}


static i64 doubleToInt64(double r) {
#ifdef SQLITE_OMIT_FLOATING_POINT
	
	return r;
#else
	
	static const i64 maxInt = LARGEST_INT64;
	static const i64 minInt = SMALLEST_INT64;

	if (r <= (double)minInt) {
		return minInt;
	}
	else if (r >= (double)maxInt) {
		return maxInt;
	}
	else {
		return (i64)r;
	}
#endif
}


SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem) {
	int flags;
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(EIGHT_BYTE_ALIGNMENT(pMem));
	flags = pMem->flags;
	if (flags & MEM_Int) {
		return pMem->u.i;
	}
	else if (flags & MEM_Real) {
		return doubleToInt64(pMem->u.r);
	}
	else if (flags & (MEM_Str | MEM_Blob)) {
		i64 value = 0;
		assert(pMem->z || pMem->n == 0);
		sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
		return value;
	}
	else {
		return 0;
	}
}


SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem) {
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(EIGHT_BYTE_ALIGNMENT(pMem));
	if (pMem->flags & MEM_Real) {
		return pMem->u.r;
	}
	else if (pMem->flags & MEM_Int) {
		return (double)pMem->u.i;
	}
	else if (pMem->flags & (MEM_Str | MEM_Blob)) {
		
		double val = (double)0;
		sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
		return val;
	}
	else {
		
		return (double)0;
	}
}


SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem *pMem) {
	i64 ix;
	assert(pMem->flags & MEM_Real);
	assert((pMem->flags & MEM_RowSet) == 0);
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(EIGHT_BYTE_ALIGNMENT(pMem));

	ix = doubleToInt64(pMem->u.r);

	
	if (pMem->u.r == ix && ix>SMALLEST_INT64 && ix<LARGEST_INT64) {
		pMem->u.i = ix;
		MemSetTypeFlag(pMem, MEM_Int);
	}
}


SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem *pMem) {
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert((pMem->flags & MEM_RowSet) == 0);
	assert(EIGHT_BYTE_ALIGNMENT(pMem));

	pMem->u.i = sqlite3VdbeIntValue(pMem);
	MemSetTypeFlag(pMem, MEM_Int);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem *pMem) {
	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert(EIGHT_BYTE_ALIGNMENT(pMem));

	pMem->u.r = sqlite3VdbeRealValue(pMem);
	MemSetTypeFlag(pMem, MEM_Real);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem *pMem) {
	if ((pMem->flags & (MEM_Int | MEM_Real | MEM_Null)) == 0) {
		assert((pMem->flags & (MEM_Blob | MEM_Str)) != 0);
		assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
		if (0 == sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc)) {
			MemSetTypeFlag(pMem, MEM_Int);
		}
		else {
			pMem->u.r = sqlite3VdbeRealValue(pMem);
			MemSetTypeFlag(pMem, MEM_Real);
			sqlite3VdbeIntegerAffinity(pMem);
		}
	}
	assert((pMem->flags & (MEM_Int | MEM_Real | MEM_Null)) != 0);
	pMem->flags &= ~(MEM_Str | MEM_Blob | MEM_Zero);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding) {
	if (pMem->flags & MEM_Null) return;
	switch (aff) {
	case SQLITE_AFF_BLOB: {   
		if ((pMem->flags & MEM_Blob) == 0) {
			sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);
			assert(pMem->flags & MEM_Str || pMem->db->mallocFailed);
			if (pMem->flags & MEM_Str) MemSetTypeFlag(pMem, MEM_Blob);
		}
		else {
			pMem->flags &= ~(MEM_TypeMask&~MEM_Blob);
		}
		break;
	}
	case SQLITE_AFF_NUMERIC: {
		sqlite3VdbeMemNumerify(pMem);
		break;
	}
	case SQLITE_AFF_INTEGER: {
		sqlite3VdbeMemIntegerify(pMem);
		break;
	}
	case SQLITE_AFF_REAL: {
		sqlite3VdbeMemRealify(pMem);
		break;
	}
	default: {
		assert(aff == SQLITE_AFF_TEXT);
		assert(MEM_Str == (MEM_Blob >> 3));
		pMem->flags |= (pMem->flags&MEM_Blob) >> 3;
		sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);
		assert(pMem->flags & MEM_Str || pMem->db->mallocFailed);
		pMem->flags &= ~(MEM_Int | MEM_Real | MEM_Blob | MEM_Zero);
		break;
	}
	}
}


SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags) {
	assert((flags & ~MEM_TypeMask) == 0);
	pMem->flags = flags;
	pMem->db = db;
	pMem->szMalloc = 0;
}



SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem *pMem) {
	if (VdbeMemDynamic(pMem)) {
		vdbeMemClearExternAndSetNull(pMem);
	}
	else {
		pMem->flags = MEM_Null;
	}
}
SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value *p) {
	sqlite3VdbeMemSetNull((Mem*)p);
}


SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n) {
	sqlite3VdbeMemRelease(pMem);
	pMem->flags = MEM_Blob | MEM_Zero;
	pMem->n = 0;
	if (n<0) n = 0;
	pMem->u.nZero = n;
	pMem->enc = SQLITE_UTF8;
	pMem->z = 0;
}


static SQLITE_NOINLINE void vdbeReleaseAndSetInt64(Mem *pMem, i64 val) {
	sqlite3VdbeMemSetNull(pMem);
	pMem->u.i = val;
	pMem->flags = MEM_Int;
}


SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val) {
	if (VdbeMemDynamic(pMem)) {
		vdbeReleaseAndSetInt64(pMem, val);
	}
	else {
		pMem->u.i = val;
		pMem->flags = MEM_Int;
	}
}

#ifndef SQLITE_OMIT_FLOATING_POINT

SQLITE_PRIVATE void sqlite3VdbeMemSetDouble(Mem *pMem, double val) {
	sqlite3VdbeMemSetNull(pMem);
	if (!sqlite3IsNaN(val)) {
		pMem->u.r = val;
		pMem->flags = MEM_Real;
	}
}
#endif


SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem *pMem) {
	sqlite3 *db = pMem->db;
	assert(db != 0);
	assert((pMem->flags & MEM_RowSet) == 0);
	sqlite3VdbeMemRelease(pMem);
	pMem->zMalloc = sqlite3DbMallocRawNN(db, 64);
	if (db->mallocFailed) {
		pMem->flags = MEM_Null;
		pMem->szMalloc = 0;
	}
	else {
		assert(pMem->zMalloc);
		pMem->szMalloc = sqlite3DbMallocSize(db, pMem->zMalloc);
		pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc, pMem->szMalloc);
		assert(pMem->u.pRowSet != 0);
		pMem->flags = MEM_RowSet;
	}
}


SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem *p) {
	assert(p->db != 0);
	if (p->flags & (MEM_Str | MEM_Blob)) {
		int n = p->n;
		if (p->flags & MEM_Zero) {
			n += p->u.nZero;
		}
		return n>p->db->aLimit[SQLITE_LIMIT_LENGTH];
	}
	return 0;
}

#ifdef SQLITE_DEBUG

SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe *pVdbe, Mem *pMem) {
	int i;
	Mem *pX;
	for (i = 0, pX = pVdbe->aMem; i<pVdbe->nMem; i++, pX++) {
		if (pX->pScopyFrom == pMem) {
			pX->flags |= MEM_Undefined;
			pX->pScopyFrom = 0;
		}
	}
	pMem->pScopyFrom = 0;
}
#endif 



static SQLITE_NOINLINE void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType) {
	vdbeMemClearExternAndSetNull(pTo);
	assert(!VdbeMemDynamic(pTo));
	sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);
}
SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType) {
	assert((pFrom->flags & MEM_RowSet) == 0);
	assert(pTo->db == pFrom->db);
	if (VdbeMemDynamic(pTo)) { vdbeClrCopy(pTo, pFrom, srcType); return; }
	memcpy(pTo, pFrom, MEMCELLSIZE);
	if ((pFrom->flags&MEM_Static) == 0) {
		pTo->flags &= ~(MEM_Dyn | MEM_Static | MEM_Ephem);
		assert(srcType == MEM_Ephem || srcType == MEM_Static);
		pTo->flags |= srcType;
	}
}


SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom) {
	int rc = SQLITE_OK;

	assert((pFrom->flags & MEM_RowSet) == 0);
	if (VdbeMemDynamic(pTo)) vdbeMemClearExternAndSetNull(pTo);
	memcpy(pTo, pFrom, MEMCELLSIZE);
	pTo->flags &= ~MEM_Dyn;
	if (pTo->flags&(MEM_Str | MEM_Blob)) {
		if (0 == (pFrom->flags&MEM_Static)) {
			pTo->flags |= MEM_Ephem;
			rc = sqlite3VdbeMemMakeWriteable(pTo);
		}
	}

	return rc;
}


SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom) {
	assert(pFrom->db == 0 || sqlite3_mutex_held(pFrom->db->mutex));
	assert(pTo->db == 0 || sqlite3_mutex_held(pTo->db->mutex));
	assert(pFrom->db == 0 || pTo->db == 0 || pFrom->db == pTo->db);

	sqlite3VdbeMemRelease(pTo);
	memcpy(pTo, pFrom, sizeof(Mem));
	pFrom->flags = MEM_Null;
	pFrom->szMalloc = 0;
}


SQLITE_PRIVATE int sqlite3VdbeMemSetStr(
	Mem *pMem,          
	const char *z,      
	int n,              
	u8 enc,             
	void(*xDel)(void*) 
) {
	int nByte = n;      
	int iLimit;         
	u16 flags = 0;      

	assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));
	assert((pMem->flags & MEM_RowSet) == 0);

	
	if (!z) {
		sqlite3VdbeMemSetNull(pMem);
		return SQLITE_OK;
	}

	if (pMem->db) {
		iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH];
	}
	else {
		iLimit = SQLITE_MAX_LENGTH;
	}
	flags = (enc == 0 ? MEM_Blob : MEM_Str);
	if (nByte<0) {
		assert(enc != 0);
		if (enc == SQLITE_UTF8) {
			nByte = sqlite3Strlen30(z);
			if (nByte>iLimit) nByte = iLimit + 1;
		}
		else {
			for (nByte = 0; nByte <= iLimit && (z[nByte] | z[nByte + 1]); nByte += 2) {}
		}
		flags |= MEM_Term;
	}

	
	if (xDel == SQLITE_TRANSIENT) {
		int nAlloc = nByte;
		if (flags&MEM_Term) {
			nAlloc += (enc == SQLITE_UTF8 ? 1 : 2);
		}
		if (nByte>iLimit) {
			return SQLITE_TOOBIG;
		}
		testcase(nAlloc == 0);
		testcase(nAlloc == 31);
		testcase(nAlloc == 32);
		if (sqlite3VdbeMemClearAndResize(pMem, MAX(nAlloc, 32))) {
			return SQLITE_NOMEM_BKPT;
		}
		memcpy(pMem->z, z, nAlloc);
	}
	else if (xDel == SQLITE_DYNAMIC) {
		sqlite3VdbeMemRelease(pMem);
		pMem->zMalloc = pMem->z = (char *)z;
		pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
	}
	else {
		sqlite3VdbeMemRelease(pMem);
		pMem->z = (char *)z;
		pMem->xDel = xDel;
		flags |= ((xDel == SQLITE_STATIC) ? MEM_Static : MEM_Dyn);
	}

	pMem->n = nByte;
	pMem->flags = flags;
	pMem->enc = (enc == 0 ? SQLITE_UTF8 : enc);

#ifndef SQLITE_OMIT_UTF16
	if (pMem->enc != SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem)) {
		return SQLITE_NOMEM_BKPT;
	}
#endif

	if (nByte>iLimit) {
		return SQLITE_TOOBIG;
	}

	return SQLITE_OK;
}


static SQLITE_NOINLINE int vdbeMemFromBtreeResize(
	BtCursor *pCur,   
	u32 offset,       
	u32 amt,          
	int key,          
	Mem *pMem         
) {
	int rc;
	pMem->flags = MEM_Null;
	if (SQLITE_OK == (rc = sqlite3VdbeMemClearAndResize(pMem, amt + 2))) {
		if (key) {
			rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z);
		}
		else {
			rc = sqlite3BtreeData(pCur, offset, amt, pMem->z);
		}
		if (rc == SQLITE_OK) {
			pMem->z[amt] = 0;
			pMem->z[amt + 1] = 0;
			pMem->flags = MEM_Blob | MEM_Term;
			pMem->n = (int)amt;
		}
		else {
			sqlite3VdbeMemRelease(pMem);
		}
	}
	return rc;
}
SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(
	BtCursor *pCur,   
	u32 offset,       
	u32 amt,          
	int key,          
	Mem *pMem         
) {
	char *zData;        
	u32 available = 0;  
	int rc = SQLITE_OK; 

	assert(sqlite3BtreeCursorIsValid(pCur));
	assert(!VdbeMemDynamic(pMem));

	
	assert((pMem->flags & MEM_RowSet) == 0);
	zData = (char *)sqlite3BtreePayloadFetch(pCur, &available);
	assert(zData != 0);

	if (offset + amt <= available) {
		pMem->z = &zData[offset];
		pMem->flags = MEM_Blob | MEM_Ephem;
		pMem->n = (int)amt;
	}
	else {
		rc = vdbeMemFromBtreeResize(pCur, offset, amt, key, pMem);
	}

	return rc;
}


static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc) {
	assert(pVal != 0);
	assert(pVal->db == 0 || sqlite3_mutex_held(pVal->db->mutex));
	assert((enc & 3) == (enc&~SQLITE_UTF16_ALIGNED));
	assert((pVal->flags & MEM_RowSet) == 0);
	assert((pVal->flags & (MEM_Null)) == 0);
	if (pVal->flags & (MEM_Blob | MEM_Str)) {
		pVal->flags |= MEM_Str;
		if (pVal->enc != (enc & ~SQLITE_UTF16_ALIGNED)) {
			sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);
		}
		if ((enc & SQLITE_UTF16_ALIGNED) != 0 && 1 == (1 & SQLITE_PTR_TO_INT(pVal->z))) {
			assert((pVal->flags & (MEM_Ephem | MEM_Static)) != 0);
			if (sqlite3VdbeMemMakeWriteable(pVal) != SQLITE_OK) {
				return 0;
			}
		}
		sqlite3VdbeMemNulTerminate(pVal); 
	}
	else {
		sqlite3VdbeMemStringify(pVal, enc, 0);
		assert(0 == (1 & SQLITE_PTR_TO_INT(pVal->z)));
	}
	assert(pVal->enc == (enc & ~SQLITE_UTF16_ALIGNED) || pVal->db == 0
		|| pVal->db->mallocFailed);
	if (pVal->enc == (enc & ~SQLITE_UTF16_ALIGNED)) {
		return pVal->z;
	}
	else {
		return 0;
	}
}


SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc) {
	if (!pVal) return 0;
	assert(pVal->db == 0 || sqlite3_mutex_held(pVal->db->mutex));
	assert((enc & 3) == (enc&~SQLITE_UTF16_ALIGNED));
	assert((pVal->flags & MEM_RowSet) == 0);
	if ((pVal->flags&(MEM_Str | MEM_Term)) == (MEM_Str | MEM_Term) && pVal->enc == enc) {
		return pVal->z;
	}
	if (pVal->flags&MEM_Null) {
		return 0;
	}
	return valueToText(pVal, enc);
}


SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *db) {
	Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
	if (p) {
		p->flags = MEM_Null;
		p->db = db;
	}
	return p;
}


struct ValueNewStat4Ctx {
	Parse *pParse;
	Index *pIdx;
	UnpackedRecord **ppRec;
	int iVal;
};


static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p) {
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (p) {
		UnpackedRecord *pRec = p->ppRec[0];

		if (pRec == 0) {
			Index *pIdx = p->pIdx;      
			int nByte;                  
			int i;                      
			int nCol = pIdx->nColumn;   

			nByte = sizeof(Mem) * nCol + ROUND8(sizeof(UnpackedRecord));
			pRec = (UnpackedRecord*)sqlite3DbMallocZero(db, nByte);
			if (pRec) {
				pRec->pKeyInfo = sqlite3KeyInfoOfIndex(p->pParse, pIdx);
				if (pRec->pKeyInfo) {
					assert(pRec->pKeyInfo->nField + pRec->pKeyInfo->nXField == nCol);
					assert(pRec->pKeyInfo->enc == ENC(db));
					pRec->aMem = (Mem *)((u8*)pRec + ROUND8(sizeof(UnpackedRecord)));
					for (i = 0; i<nCol; i++) {
						pRec->aMem[i].flags = MEM_Null;
						pRec->aMem[i].db = db;
					}
				}
				else {
					sqlite3DbFree(db, pRec);
					pRec = 0;
				}
			}
			if (pRec == 0) return 0;
			p->ppRec[0] = pRec;
		}

		pRec->nField = p->iVal + 1;
		return &pRec->aMem[p->iVal];
	}
#else
	UNUSED_PARAMETER(p);
#endif 
	return sqlite3ValueNew(db);
}


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
static int valueFromFunction(
	sqlite3 *db,                    
	Expr *p,                        
	u8 enc,                         
	u8 aff,                         
	sqlite3_value **ppVal,          
	struct ValueNewStat4Ctx *pCtx   
) {
	sqlite3_context ctx;            
	sqlite3_value **apVal = 0;      
	int nVal = 0;                   
	FuncDef *pFunc = 0;             
	sqlite3_value *pVal = 0;        
	int rc = SQLITE_OK;             
	ExprList *pList = 0;            
	int i;                          

	assert(pCtx != 0);
	assert((p->flags & EP_TokenOnly) == 0);
	pList = p->x.pList;
	if (pList) nVal = pList->nExpr;
	pFunc = sqlite3FindFunction(db, p->u.zToken, nVal, enc, 0);
	assert(pFunc);
	if ((pFunc->funcFlags & (SQLITE_FUNC_CONSTANT | SQLITE_FUNC_SLOCHNG)) == 0
		|| (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)
		) {
		return SQLITE_OK;
	}

	if (pList) {
		apVal = (sqlite3_value**)sqlite3DbMallocZero(db, sizeof(apVal[0]) * nVal);
		if (apVal == 0) {
			rc = SQLITE_NOMEM_BKPT;
			goto value_from_function_out;
		}
		for (i = 0; i<nVal; i++) {
			rc = sqlite3ValueFromExpr(db, pList->a[i].pExpr, enc, aff, &apVal[i]);
			if (apVal[i] == 0 || rc != SQLITE_OK) goto value_from_function_out;
		}
	}

	pVal = valueNew(db, pCtx);
	if (pVal == 0) {
		rc = SQLITE_NOMEM_BKPT;
		goto value_from_function_out;
	}

	assert(pCtx->pParse->rc == SQLITE_OK);
	memset(&ctx, 0, sizeof(ctx));
	ctx.pOut = pVal;
	ctx.pFunc = pFunc;
	pFunc->xSFunc(&ctx, nVal, apVal);
	if (ctx.isError) {
		rc = ctx.isError;
		sqlite3ErrorMsg(pCtx->pParse, "%s", sqlite3_value_text(pVal));
	}
	else {
		sqlite3ValueApplyAffinity(pVal, aff, SQLITE_UTF8);
		assert(rc == SQLITE_OK);
		rc = sqlite3VdbeChangeEncoding(pVal, enc);
		if (rc == SQLITE_OK && sqlite3VdbeMemTooBig(pVal)) {
			rc = SQLITE_TOOBIG;
			pCtx->pParse->nErr++;
		}
	}
	pCtx->pParse->rc = rc;

value_from_function_out:
	if (rc != SQLITE_OK) {
		pVal = 0;
	}
	if (apVal) {
		for (i = 0; i<nVal; i++) {
			sqlite3ValueFree(apVal[i]);
		}
		sqlite3DbFree(db, apVal);
	}

	*ppVal = pVal;
	return rc;
}
#else
# define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
#endif 


static int valueFromExpr(
	sqlite3 *db,                    
	Expr *pExpr,                    
	u8 enc,                         
	u8 affinity,                    
	sqlite3_value **ppVal,          
	struct ValueNewStat4Ctx *pCtx   
) {
	int op;
	char *zVal = 0;
	sqlite3_value *pVal = 0;
	int negInt = 1;
	const char *zNeg = "";
	int rc = SQLITE_OK;

	assert(pExpr != 0);
	while ((op = pExpr->op) == TK_UPLUS || op == TK_SPAN) pExpr = pExpr->pLeft;
	if (NEVER(op == TK_REGISTER)) op = pExpr->op2;

	
	assert((pExpr->flags & EP_TokenOnly) == 0 || pCtx == 0);

	if (op == TK_CAST) {
		u8 aff = sqlite3AffinityType(pExpr->u.zToken, 0);
		rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
		testcase(rc != SQLITE_OK);
		if (*ppVal) {
			sqlite3VdbeMemCast(*ppVal, aff, SQLITE_UTF8);
			sqlite3ValueApplyAffinity(*ppVal, affinity, SQLITE_UTF8);
		}
		return rc;
	}

	
	if (op == TK_UMINUS
		&& (pExpr->pLeft->op == TK_INTEGER || pExpr->pLeft->op == TK_FLOAT)) {
		pExpr = pExpr->pLeft;
		op = pExpr->op;
		negInt = -1;
		zNeg = "-";
	}

	if (op == TK_STRING || op == TK_FLOAT || op == TK_INTEGER) {
		pVal = valueNew(db, pCtx);
		if (pVal == 0) goto no_mem;
		if (ExprHasProperty(pExpr, EP_IntValue)) {
			sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
		}
		else {
			zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
			if (zVal == 0) goto no_mem;
			sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);
		}
		if ((op == TK_INTEGER || op == TK_FLOAT) && affinity == SQLITE_AFF_BLOB) {
			sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);
		}
		else {
			sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);
		}
		if (pVal->flags & (MEM_Int | MEM_Real)) pVal->flags &= ~MEM_Str;
		if (enc != SQLITE_UTF8) {
			rc = sqlite3VdbeChangeEncoding(pVal, enc);
		}
	}
	else if (op == TK_UMINUS) {
		
		if (SQLITE_OK == sqlite3ValueFromExpr(db, pExpr->pLeft, enc, affinity, &pVal)
			&& pVal != 0
			) {
			sqlite3VdbeMemNumerify(pVal);
			if (pVal->flags & MEM_Real) {
				pVal->u.r = -pVal->u.r;
			}
			else if (pVal->u.i == SMALLEST_INT64) {
				pVal->u.r = -(double)SMALLEST_INT64;
				MemSetTypeFlag(pVal, MEM_Real);
			}
			else {
				pVal->u.i = -pVal->u.i;
			}
			sqlite3ValueApplyAffinity(pVal, affinity, enc);
		}
	}
	else if (op == TK_NULL) {
		pVal = valueNew(db, pCtx);
		if (pVal == 0) goto no_mem;
	}
#ifndef SQLITE_OMIT_BLOB_LITERAL
	else if (op == TK_BLOB) {
		int nVal;
		assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');
		assert(pExpr->u.zToken[1] == '\'');
		pVal = valueNew(db, pCtx);
		if (!pVal) goto no_mem;
		zVal = &pExpr->u.zToken[2];
		nVal = sqlite3Strlen30(zVal) - 1;
		assert(zVal[nVal] == '\'');
		sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal / 2,
			0, SQLITE_DYNAMIC);
	}
#endif

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	else if (op == TK_FUNCTION && pCtx != 0) {
		rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);
	}
#endif

	*ppVal = pVal;
	return rc;

no_mem:
	sqlite3OomFault(db);
	sqlite3DbFree(db, zVal);
	assert(*ppVal == 0);
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (pCtx == 0) sqlite3ValueFree(pVal);
#else
	assert(pCtx == 0); sqlite3ValueFree(pVal);
#endif
	return SQLITE_NOMEM_BKPT;
}


SQLITE_PRIVATE int sqlite3ValueFromExpr(
	sqlite3 *db,              
	Expr *pExpr,              
	u8 enc,                   
	u8 affinity,              
	sqlite3_value **ppVal     
) {
	return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0;
}

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static void recordFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const int file_format = 1;
	u32 iSerial;                    
	int nSerial;                    
	u32 nVal;                       
	int nRet;
	sqlite3 *db;
	u8 *aRet;

	UNUSED_PARAMETER(argc);
	iSerial = sqlite3VdbeSerialType(argv[0], file_format, &nVal);
	nSerial = sqlite3VarintLen(iSerial);
	db = sqlite3_context_db_handle(context);

	nRet = 1 + nSerial + nVal;
	aRet = sqlite3DbMallocRawNN(db, nRet);
	if (aRet == 0) {
		sqlite3_result_error_nomem(context);
	}
	else {
		aRet[0] = nSerial + 1;
		putVarint32(&aRet[1], iSerial);
		sqlite3VdbeSerialPut(&aRet[1 + nSerial], argv[0], iSerial);
		sqlite3_result_blob(context, aRet, nRet, SQLITE_TRANSIENT);
		sqlite3DbFree(db, aRet);
	}
}


SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void) {
	static FuncDef aAnalyzeTableFuncs[] = {
		FUNCTION(sqlite_record,   1, 0, 0, recordFunc),
	};
	sqlite3InsertBuiltinFuncs(aAnalyzeTableFuncs, ArraySize(aAnalyzeTableFuncs));
}


static int stat4ValueFromExpr(
	Parse *pParse,                  
	Expr *pExpr,                    
	u8 affinity,                    
	struct ValueNewStat4Ctx *pAlloc,
	sqlite3_value **ppVal           
) {
	int rc = SQLITE_OK;
	sqlite3_value *pVal = 0;
	sqlite3 *db = pParse->db;

	
	pExpr = sqlite3ExprSkipCollate(pExpr);

	if (!pExpr) {
		pVal = valueNew(db, pAlloc);
		if (pVal) {
			sqlite3VdbeMemSetNull((Mem*)pVal);
		}
	}
	else if (pExpr->op == TK_VARIABLE
		|| NEVER(pExpr->op == TK_REGISTER && pExpr->op2 == TK_VARIABLE)
		) {
		Vdbe *v;
		int iBindVar = pExpr->iColumn;
		sqlite3VdbeSetVarmask(pParse->pVdbe, iBindVar);
		if ((v = pParse->pReprepare) != 0) {
			pVal = valueNew(db, pAlloc);
			if (pVal) {
				rc = sqlite3VdbeMemCopy((Mem*)pVal, &v->aVar[iBindVar - 1]);
				if (rc == SQLITE_OK) {
					sqlite3ValueApplyAffinity(pVal, affinity, ENC(db));
				}
				pVal->db = pParse->db;
			}
		}
	}
	else {
		rc = valueFromExpr(db, pExpr, ENC(db), affinity, &pVal, pAlloc);
	}

	assert(pVal == 0 || pVal->db == db);
	*ppVal = pVal;
	return rc;
}


SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(
	Parse *pParse,                  
	Index *pIdx,                    
	UnpackedRecord **ppRec,         
	Expr *pExpr,                    
	int nElem,                      
	int iVal,                       
	int *pnExtract                  
) {
	int rc = SQLITE_OK;
	int nExtract = 0;

	if (pExpr == 0 || pExpr->op != TK_SELECT) {
		int i;
		struct ValueNewStat4Ctx alloc;

		alloc.pParse = pParse;
		alloc.pIdx = pIdx;
		alloc.ppRec = ppRec;

		for (i = 0; i<nElem; i++) {
			sqlite3_value *pVal = 0;
			Expr *pElem = (pExpr ? sqlite3VectorFieldSubexpr(pExpr, i) : 0);
			u8 aff = sqlite3IndexColumnAffinity(pParse->db, pIdx, iVal + i);
			alloc.iVal = iVal + i;
			rc = stat4ValueFromExpr(pParse, pElem, aff, &alloc, &pVal);
			if (!pVal) break;
			nExtract++;
		}
	}

	*pnExtract = nExtract;
	return rc;
}


SQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(
	Parse *pParse,                  
	Expr *pExpr,                    
	u8 affinity,                    
	sqlite3_value **ppVal           
) {
	return stat4ValueFromExpr(pParse, pExpr, affinity, 0, ppVal);
}


SQLITE_PRIVATE int sqlite3Stat4Column(
	sqlite3 *db,                    
	const void *pRec,               
	int nRec,                       
	int iCol,                       
	sqlite3_value **ppVal           
) {
	u32 t;                          
	int nHdr;                       
	int iHdr;                       
	int iField;                     
	int szField;                    
	int i;                          
	u8 *a = (u8*)pRec;              
	Mem *pMem = *ppVal;             

	assert(iCol>0);
	iHdr = getVarint32(a, nHdr);
	if (nHdr>nRec || iHdr >= nHdr) return SQLITE_CORRUPT_BKPT;
	iField = nHdr;
	for (i = 0; i <= iCol; i++) {
		iHdr += getVarint32(&a[iHdr], t);
		testcase(iHdr == nHdr);
		testcase(iHdr == nHdr + 1);
		if (iHdr>nHdr) return SQLITE_CORRUPT_BKPT;
		szField = sqlite3VdbeSerialTypeLen(t);
		iField += szField;
	}
	testcase(iField == nRec);
	testcase(iField == nRec + 1);
	if (iField>nRec) return SQLITE_CORRUPT_BKPT;
	if (pMem == 0) {
		pMem = *ppVal = sqlite3ValueNew(db);
		if (pMem == 0) return SQLITE_NOMEM_BKPT;
	}
	sqlite3VdbeSerialGet(&a[iField - szField], t, pMem);
	pMem->enc = ENC(db);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord *pRec) {
	if (pRec) {
		int i;
		int nCol = pRec->pKeyInfo->nField + pRec->pKeyInfo->nXField;
		Mem *aMem = pRec->aMem;
		sqlite3 *db = aMem[0].db;
		for (i = 0; i<nCol; i++) {
			sqlite3VdbeMemRelease(&aMem[i]);
		}
		sqlite3KeyInfoUnref(pRec->pKeyInfo);
		sqlite3DbFree(db, pRec);
	}
}
#endif 


SQLITE_PRIVATE void sqlite3ValueSetStr(
	sqlite3_value *v,     
	int n,                
	const void *z,        
	u8 enc,               
	void(*xDel)(void*)   
) {
	if (v) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}


SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v) {
	if (!v) return;
	sqlite3VdbeMemRelease((Mem *)v);
	sqlite3DbFree(((Mem*)v)->db, v);
}


static SQLITE_NOINLINE int valueBytes(sqlite3_value *pVal, u8 enc) {
	return valueToText(pVal, enc) != 0 ? pVal->n : 0;
}
SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc) {
	Mem *p = (Mem*)pVal;
	assert((p->flags & MEM_Null) == 0 || (p->flags & (MEM_Str | MEM_Blob)) == 0);
	if ((p->flags & MEM_Str) != 0 && pVal->enc == enc) {
		return p->n;
	}
	if ((p->flags & MEM_Blob) != 0) {
		if (p->flags & MEM_Zero) {
			return p->n + p->u.nZero;
		}
		else {
			return p->n;
		}
	}
	if (p->flags & MEM_Null) return 0;
	return valueBytes(pVal, enc);
}








SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse *pParse) {
	sqlite3 *db = pParse->db;
	Vdbe *p;
	p = sqlite3DbMallocRawNN(db, sizeof(Vdbe));
	if (p == 0) return 0;
	memset(&p->aOp, 0, sizeof(Vdbe) - offsetof(Vdbe, aOp));
	p->db = db;
	if (db->pVdbe) {
		db->pVdbe->pPrev = p;
	}
	p->pNext = db->pVdbe;
	p->pPrev = 0;
	db->pVdbe = p;
	p->magic = VDBE_MAGIC_INIT;
	p->pParse = pParse;
	assert(pParse->aLabel == 0);
	assert(pParse->nLabel == 0);
	assert(pParse->nOpAlloc == 0);
	assert(pParse->szOpAlloc == 0);
	return p;
}


SQLITE_PRIVATE void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...) {
	va_list ap;
	sqlite3DbFree(p->db, p->zErrMsg);
	va_start(ap, zFormat);
	p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);
	va_end(ap);
}


SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepareV2) {
	assert(isPrepareV2 == 1 || isPrepareV2 == 0);
	if (p == 0) return;
#if defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_ENABLE_SQLLOG)
	if (!isPrepareV2) return;
#endif
	assert(p->zSql == 0);
	p->zSql = sqlite3DbStrNDup(p->db, z, n);
	p->isPrepareV2 = (u8)isPrepareV2;
}


SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB) {
	Vdbe tmp, *pTmp;
	char *zTmp;
	assert(pA->db == pB->db);
	tmp = *pA;
	*pA = *pB;
	*pB = tmp;
	pTmp = pA->pNext;
	pA->pNext = pB->pNext;
	pB->pNext = pTmp;
	pTmp = pA->pPrev;
	pA->pPrev = pB->pPrev;
	pB->pPrev = pTmp;
	zTmp = pA->zSql;
	pA->zSql = pB->zSql;
	pB->zSql = zTmp;
	pB->isPrepareV2 = pA->isPrepareV2;
}


static int growOpArray(Vdbe *v, int nOp) {
	VdbeOp *pNew;
	Parse *p = v->pParse;

	
#ifdef SQLITE_TEST_REALLOC_STRESS
	int nNew = (p->nOpAlloc >= 512 ? p->nOpAlloc * 2 : p->nOpAlloc + nOp);
#else
	int nNew = (p->nOpAlloc ? p->nOpAlloc * 2 : (int)(1024 / sizeof(Op)));
	UNUSED_PARAMETER(nOp);
#endif

	assert(nOp <= (1024 / sizeof(Op)));
	assert(nNew >= (p->nOpAlloc + nOp));
	pNew = sqlite3DbRealloc(p->db, v->aOp, nNew * sizeof(Op));
	if (pNew) {
		p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);
		p->nOpAlloc = p->szOpAlloc / sizeof(Op);
		v->aOp = pNew;
	}
	return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT);
}

#ifdef SQLITE_DEBUG

static void test_addop_breakpoint(void) {
	static int n = 0;
	n++;
}
#endif


static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3) {
	assert(p->pParse->nOpAlloc <= p->nOp);
	if (growOpArray(p, 1)) return 1;
	assert(p->pParse->nOpAlloc>p->nOp);
	return sqlite3VdbeAddOp3(p, op, p1, p2, p3);
}
SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3) {
	int i;
	VdbeOp *pOp;

	i = p->nOp;
	assert(p->magic == VDBE_MAGIC_INIT);
	assert(op >= 0 && op<0xff);
	if (p->pParse->nOpAlloc <= i) {
		return growOp3(p, op, p1, p2, p3);
	}
	p->nOp++;
	pOp = &p->aOp[i];
	pOp->opcode = (u8)op;
	pOp->p5 = 0;
	pOp->p1 = p1;
	pOp->p2 = p2;
	pOp->p3 = p3;
	pOp->p4.p = 0;
	pOp->p4type = P4_NOTUSED;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
	pOp->zComment = 0;
#endif
#ifdef SQLITE_DEBUG
	if (p->db->flags & SQLITE_VdbeAddopTrace) {
		int jj, kk;
		Parse *pParse = p->pParse;
		for (jj = kk = 0; jj<pParse->nColCache; jj++) {
			struct yColCache *x = pParse->aColCache + jj;
			printf(" r[%d]={%d:%d}", x->iReg, x->iTable, x->iColumn);
			kk++;
		}
		if (kk) printf("\n");
		sqlite3VdbePrintOp(0, i, &p->aOp[i]);
		test_addop_breakpoint();
	}
#endif
#ifdef VDBE_PROFILE
	pOp->cycles = 0;
	pOp->cnt = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
	pOp->iSrcLine = 0;
#endif
	return i;
}
SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op) {
	return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1) {
	return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2) {
	return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}


SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe *p, int iDest) {
	return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0);
}


SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr) {
	return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0);
}


SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...) {
	va_list ap;
	int i;
	char c;
	va_start(ap, zTypes);
	for (i = 0; (c = zTypes[i]) != 0; i++) {
		if (c == 's') {
			const char *z = va_arg(ap, const char*);
			sqlite3VdbeAddOp4(p, z == 0 ? OP_Null : OP_String8, 0, iDest++, 0, z, 0);
		}
		else {
			assert(c == 'i');
			sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest++);
		}
	}
	va_end(ap);
}


SQLITE_PRIVATE int sqlite3VdbeAddOp4(
	Vdbe *p,            
	int op,             
	int p1,             
	int p2,             
	int p3,             
	const char *zP4,    
	int p4type          
) {
	int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
	sqlite3VdbeChangeP4(p, addr, zP4, p4type);
	return addr;
}


SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(
	Vdbe *p,            
	int op,             
	int p1,             
	int p2,             
	int p3,             
	const u8 *zP4,      
	int p4type          
) {
	char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);
	if (p4copy) memcpy(p4copy, zP4, 8);
	return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);
}


SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere) {
	int j;
	sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);
	for (j = 0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);
}


SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(
	Vdbe *p,            
	int op,             
	int p1,             
	int p2,             
	int p3,             
	int p4              
) {
	int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
	sqlite3VdbeChangeP4(p, addr, SQLITE_INT_TO_PTR(p4), P4_INT32);
	return addr;
}


SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe *v, int regYield) {
	sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);

	
	v->pParse->nTempReg = 0;
	v->pParse->nRangeReg = 0;
}


SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe *v) {
	Parse *p = v->pParse;
	int i = p->nLabel++;
	assert(v->magic == VDBE_MAGIC_INIT);
	if ((i & (i - 1)) == 0) {
		p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,
			(i * 2 + 1) * sizeof(p->aLabel[0]));
	}
	if (p->aLabel) {
		p->aLabel[i] = -1;
	}
	return ADDR(i);
}


SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe *v, int x) {
	Parse *p = v->pParse;
	int j = ADDR(x);
	assert(v->magic == VDBE_MAGIC_INIT);
	assert(j<p->nLabel);
	assert(j >= 0);
	if (p->aLabel) {
		p->aLabel[j] = v->nOp;
	}
}


SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe *p) {
	p->runOnlyOnce = 1;
}


SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe *p) {
	p->runOnlyOnce = 0;
}

#ifdef SQLITE_DEBUG 


typedef struct VdbeOpIter VdbeOpIter;
struct VdbeOpIter {
	Vdbe *v;                   
	SubProgram **apSub;        
	int nSub;                  
	int iAddr;                 
	int iSub;                  
};
static Op *opIterNext(VdbeOpIter *p) {
	Vdbe *v = p->v;
	Op *pRet = 0;
	Op *aOp;
	int nOp;

	if (p->iSub <= p->nSub) {

		if (p->iSub == 0) {
			aOp = v->aOp;
			nOp = v->nOp;
		}
		else {
			aOp = p->apSub[p->iSub - 1]->aOp;
			nOp = p->apSub[p->iSub - 1]->nOp;
		}
		assert(p->iAddr<nOp);

		pRet = &aOp[p->iAddr];
		p->iAddr++;
		if (p->iAddr == nOp) {
			p->iSub++;
			p->iAddr = 0;
		}

		if (pRet->p4type == P4_SUBPROGRAM) {
			int nByte = (p->nSub + 1) * sizeof(SubProgram*);
			int j;
			for (j = 0; j<p->nSub; j++) {
				if (p->apSub[j] == pRet->p4.pProgram) break;
			}
			if (j == p->nSub) {
				p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);
				if (!p->apSub) {
					pRet = 0;
				}
				else {
					p->apSub[p->nSub++] = pRet->p4.pProgram;
				}
			}
		}
	}

	return pRet;
}


SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort) {
	int hasAbort = 0;
	int hasFkCounter = 0;
	int hasCreateTable = 0;
	int hasInitCoroutine = 0;
	Op *pOp;
	VdbeOpIter sIter;
	memset(&sIter, 0, sizeof(sIter));
	sIter.v = v;

	while ((pOp = opIterNext(&sIter)) != 0) {
		int opcode = pOp->opcode;
		if (opcode == OP_Destroy || opcode == OP_VUpdate || opcode == OP_VRename
			|| ((opcode == OP_Halt || opcode == OP_HaltIfNull)
				&& ((pOp->p1 & 0xff) == SQLITE_CONSTRAINT && pOp->p2 == OE_Abort))
			) {
			hasAbort = 1;
			break;
		}
		if (opcode == OP_CreateTable) hasCreateTable = 1;
		if (opcode == OP_InitCoroutine) hasInitCoroutine = 1;
#ifndef SQLITE_OMIT_FOREIGN_KEY
		if (opcode == OP_FkCounter && pOp->p1 == 0 && pOp->p2 == 1) {
			hasFkCounter = 1;
		}
#endif
	}
	sqlite3DbFree(v->db, sIter.apSub);

	
	return (v->db->mallocFailed || hasAbort == mayAbort || hasFkCounter
		|| (hasCreateTable && hasInitCoroutine));
}
#endif 


static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs) {
	int nMaxArgs = *pMaxFuncArgs;
	Op *pOp;
	Parse *pParse = p->pParse;
	int *aLabel = pParse->aLabel;
	p->readOnly = 1;
	p->bIsReader = 0;
	pOp = &p->aOp[p->nOp - 1];
	while (1) {

		
		if (pOp->opcode <= SQLITE_MX_JUMP_OPCODE) {
			
			switch (pOp->opcode) {
			case OP_Transaction: {
				if (pOp->p2 != 0) p->readOnly = 0;
				
			}
			case OP_AutoCommit:
			case OP_Savepoint: {
				p->bIsReader = 1;
				break;
			}
#ifndef SQLITE_OMIT_WAL
			case OP_Checkpoint:
#endif
			case OP_Vacuum:
			case OP_JournalMode: {
				p->readOnly = 0;
				p->bIsReader = 1;
				break;
			}
#ifndef SQLITE_OMIT_VIRTUALTABLE
			case OP_VUpdate: {
				if (pOp->p2>nMaxArgs) nMaxArgs = pOp->p2;
				break;
			}
			case OP_VFilter: {
				int n;
				assert((pOp - p->aOp) >= 3);
				assert(pOp[-1].opcode == OP_Integer);
				n = pOp[-1].p1;
				if (n>nMaxArgs) nMaxArgs = n;
				break;
			}
#endif
			case OP_Next:
			case OP_NextIfOpen:
			case OP_SorterNext: {
				pOp->p4.xAdvance = sqlite3BtreeNext;
				pOp->p4type = P4_ADVANCE;
				break;
			}
			case OP_Prev:
			case OP_PrevIfOpen: {
				pOp->p4.xAdvance = sqlite3BtreePrevious;
				pOp->p4type = P4_ADVANCE;
				break;
			}
			}
			if ((sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP) != 0 && pOp->p2<0) {
				assert(ADDR(pOp->p2)<pParse->nLabel);
				pOp->p2 = aLabel[ADDR(pOp->p2)];
			}
		}
		if (pOp == p->aOp) break;
		pOp--;
	}
	sqlite3DbFree(p->db, pParse->aLabel);
	pParse->aLabel = 0;
	pParse->nLabel = 0;
	*pMaxFuncArgs = nMaxArgs;
	assert(p->bIsReader != 0 || DbMaskAllZero(p->btreeMask));
}


SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe *p) {
	assert(p->magic == VDBE_MAGIC_INIT);
	return p->nOp;
}


#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
SQLITE_PRIVATE void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N) {
	assert(p->nOp + N <= p->pParse->nOpAlloc);
}
#endif


SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg) {
	VdbeOp *aOp = p->aOp;
	assert(aOp && !p->db->mallocFailed);

	
	assert(DbMaskAllZero(p->btreeMask));

	resolveP2Values(p, pnMaxArg);
	*pnOp = p->nOp;
	p->aOp = 0;
	return aOp;
}


SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(
	Vdbe *p,                     
	int nOp,                     
	VdbeOpList const *aOp,       
	int iLineno                  
) {
	int i;
	VdbeOp *pOut, *pFirst;
	assert(nOp>0);
	assert(p->magic == VDBE_MAGIC_INIT);
	if (p->nOp + nOp > p->pParse->nOpAlloc && growOpArray(p, nOp)) {
		return 0;
	}
	pFirst = pOut = &p->aOp[p->nOp];
	for (i = 0; i<nOp; i++, aOp++, pOut++) {
		pOut->opcode = aOp->opcode;
		pOut->p1 = aOp->p1;
		pOut->p2 = aOp->p2;
		assert(aOp->p2 >= 0);
		if ((sqlite3OpcodeProperty[aOp->opcode] & OPFLG_JUMP) != 0 && aOp->p2>0) {
			pOut->p2 += p->nOp;
		}
		pOut->p3 = aOp->p3;
		pOut->p4type = P4_NOTUSED;
		pOut->p4.p = 0;
		pOut->p5 = 0;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
		pOut->zComment = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
		pOut->iSrcLine = iLineno + i;
#else
		(void)iLineno;
#endif
#ifdef SQLITE_DEBUG
		if (p->db->flags & SQLITE_VdbeAddopTrace) {
			sqlite3VdbePrintOp(0, i + p->nOp, &p->aOp[i + p->nOp]);
		}
#endif
	}
	p->nOp += nOp;
	return pFirst;
}

#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)

SQLITE_PRIVATE void sqlite3VdbeScanStatus(
	Vdbe *p,                        
	int addrExplain,                
	int addrLoop,                   
	int addrVisit,                  
	LogEst nEst,                    
	const char *zName               
) {
	int nByte = (p->nScan + 1) * sizeof(ScanStatus);
	ScanStatus *aNew;
	aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);
	if (aNew) {
		ScanStatus *pNew = &aNew[p->nScan++];
		pNew->addrExplain = addrExplain;
		pNew->addrLoop = addrLoop;
		pNew->addrVisit = addrVisit;
		pNew->nEst = nEst;
		pNew->zName = sqlite3DbStrDup(p->db, zName);
		p->aScan = aNew;
	}
}
#endif



SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe *p, u32 addr, u8 iNewOpcode) {
	sqlite3VdbeGetOp(p, addr)->opcode = iNewOpcode;
}
SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, u32 addr, int val) {
	sqlite3VdbeGetOp(p, addr)->p1 = val;
}
SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, u32 addr, int val) {
	sqlite3VdbeGetOp(p, addr)->p2 = val;
}
SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, u32 addr, int val) {
	sqlite3VdbeGetOp(p, addr)->p3 = val;
}
SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 p5) {
	assert(p->nOp>0 || p->db->mallocFailed);
	if (p->nOp>0) p->aOp[p->nOp - 1].p5 = p5;
}


SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr) {
	sqlite3VdbeChangeP2(p, addr, p->nOp);
}



static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef) {
	if ((pDef->funcFlags & SQLITE_FUNC_EPHEM) != 0) {
		sqlite3DbFree(db, pDef);
	}
}

static void vdbeFreeOpArray(sqlite3 *, Op *, int);


static SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p) {
	if (p->szMalloc) sqlite3DbFree(db, p->zMalloc);
	sqlite3DbFree(db, p);
}
static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p) {
	freeEphemeralFunction(db, p->pFunc);
	sqlite3DbFree(db, p);
}
static void freeP4(sqlite3 *db, int p4type, void *p4) {
	assert(db);
	switch (p4type) {
	case P4_FUNCCTX: {
		freeP4FuncCtx(db, (sqlite3_context*)p4);
		break;
	}
	case P4_REAL:
	case P4_INT64:
	case P4_DYNAMIC:
	case P4_INTARRAY: {
		sqlite3DbFree(db, p4);
		break;
	}
	case P4_KEYINFO: {
		if (db->pnBytesFreed == 0) sqlite3KeyInfoUnref((KeyInfo*)p4);
		break;
	}
#ifdef SQLITE_ENABLE_CURSOR_HINTS
	case P4_EXPR: {
		sqlite3ExprDelete(db, (Expr*)p4);
		break;
	}
#endif
	case P4_MPRINTF: {
		if (db->pnBytesFreed == 0) sqlite3_free(p4);
		break;
	}
	case P4_FUNCDEF: {
		freeEphemeralFunction(db, (FuncDef*)p4);
		break;
	}
	case P4_MEM: {
		if (db->pnBytesFreed == 0) {
			sqlite3ValueFree((sqlite3_value*)p4);
		}
		else {
			freeP4Mem(db, (Mem*)p4);
		}
		break;
	}
	case P4_VTAB: {
		if (db->pnBytesFreed == 0) sqlite3VtabUnlock((VTable *)p4);
		break;
	}
	}
}


static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp) {
	if (aOp) {
		Op *pOp;
		for (pOp = aOp; pOp<&aOp[nOp]; pOp++) {
			if (pOp->p4type) freeP4(db, pOp->p4type, pOp->p4.p);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
			sqlite3DbFree(db, pOp->zComment);
#endif     
		}
	}
	sqlite3DbFree(db, aOp);
}


SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p) {
	p->pNext = pVdbe->pProgram;
	pVdbe->pProgram = p;
}


SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe *p, int addr) {
	VdbeOp *pOp;
	if (p->db->mallocFailed) return 0;
	assert(addr >= 0 && addr<p->nOp);
	pOp = &p->aOp[addr];
	freeP4(p->db, pOp->p4type, pOp->p4.p);
	pOp->p4type = P4_NOTUSED;
	pOp->p4.z = 0;
	pOp->opcode = OP_Noop;
	return 1;
}


SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op) {
	if (p->nOp>0 && p->aOp[p->nOp - 1].opcode == op) {
		return sqlite3VdbeChangeToNoop(p, p->nOp - 1);
	}
	else {
		return 0;
	}
}


static void SQLITE_NOINLINE vdbeChangeP4Full(
	Vdbe *p,
	Op *pOp,
	const char *zP4,
	int n
) {
	if (pOp->p4type) {
		freeP4(p->db, pOp->p4type, pOp->p4.p);
		pOp->p4type = 0;
		pOp->p4.p = 0;
	}
	if (n<0) {
		sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);
	}
	else {
		if (n == 0) n = sqlite3Strlen30(zP4);
		pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);
		pOp->p4type = P4_DYNAMIC;
	}
}
SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n) {
	Op *pOp;
	sqlite3 *db;
	assert(p != 0);
	db = p->db;
	assert(p->magic == VDBE_MAGIC_INIT);
	assert(p->aOp != 0 || db->mallocFailed);
	if (db->mallocFailed) {
		if (n != P4_VTAB) freeP4(db, n, (void*)*(char**)&zP4);
		return;
	}
	assert(p->nOp>0);
	assert(addr<p->nOp);
	if (addr<0) {
		addr = p->nOp - 1;
	}
	pOp = &p->aOp[addr];
	if (n >= 0 || pOp->p4type) {
		vdbeChangeP4Full(p, pOp, zP4, n);
		return;
	}
	if (n == P4_INT32) {
		
		pOp->p4.i = SQLITE_PTR_TO_INT(zP4);
		pOp->p4type = P4_INT32;
	}
	else if (zP4 != 0) {
		assert(n<0);
		pOp->p4.p = (void*)zP4;
		pOp->p4type = (signed char)n;
		if (n == P4_VTAB) sqlite3VtabLock((VTable*)zP4);
	}
}


SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx) {
	Vdbe *v = pParse->pVdbe;
	assert(v != 0);
	assert(pIdx != 0);
	sqlite3VdbeChangeP4(v, -1, (char*)sqlite3KeyInfoOfIndex(pParse, pIdx),
		P4_KEYINFO);
}

#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS

static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap) {
	assert(p->nOp>0 || p->aOp == 0);
	assert(p->aOp == 0 || p->aOp[p->nOp - 1].zComment == 0 || p->db->mallocFailed);
	if (p->nOp) {
		assert(p->aOp);
		sqlite3DbFree(p->db, p->aOp[p->nOp - 1].zComment);
		p->aOp[p->nOp - 1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);
	}
}
SQLITE_PRIVATE void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...) {
	va_list ap;
	if (p) {
		va_start(ap, zFormat);
		vdbeVComment(p, zFormat, ap);
		va_end(ap);
	}
}
SQLITE_PRIVATE void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...) {
	va_list ap;
	if (p) {
		sqlite3VdbeAddOp0(p, OP_Noop);
		va_start(ap, zFormat);
		vdbeVComment(p, zFormat, ap);
		va_end(ap);
	}
}
#endif  

#ifdef SQLITE_VDBE_COVERAGE

SQLITE_PRIVATE void sqlite3VdbeSetLineNumber(Vdbe *v, int iLine) {
	sqlite3VdbeGetOp(v, -1)->iSrcLine = iLine;
}
#endif 


SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr) {
	
	static VdbeOp dummy;  
	assert(p->magic == VDBE_MAGIC_INIT);
	if (addr<0) {
		addr = p->nOp - 1;
	}
	assert((addr >= 0 && addr<p->nOp) || p->db->mallocFailed);
	if (p->db->mallocFailed) {
		return (VdbeOp*)&dummy;
	}
	else {
		return &p->aOp[addr];
	}
}

#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)

static int translateP(char c, const Op *pOp) {
	if (c == '1') return pOp->p1;
	if (c == '2') return pOp->p2;
	if (c == '3') return pOp->p3;
	if (c == '4') return pOp->p4.i;
	return pOp->p5;
}


static int displayComment(
	const Op *pOp,     
	const char *zP4,   
	char *zTemp,       
	int nTemp          
) {
	const char *zOpName;
	const char *zSynopsis;
	int nOpName;
	int ii, jj;
	char zAlt[50];
	zOpName = sqlite3OpcodeName(pOp->opcode);
	nOpName = sqlite3Strlen30(zOpName);
	if (zOpName[nOpName + 1]) {
		int seenCom = 0;
		char c;
		zSynopsis = zOpName += nOpName + 1;
		if (strncmp(zSynopsis, "IF ", 3) == 0) {
			if (pOp->p5 & SQLITE_STOREP2) {
				sqlite3_snprintf(sizeof(zAlt), zAlt, "r[P2] = (%s)", zSynopsis + 3);
			}
			else {
				sqlite3_snprintf(sizeof(zAlt), zAlt, "if %s goto P2", zSynopsis + 3);
			}
			zSynopsis = zAlt;
		}
		for (ii = jj = 0; jj<nTemp - 1 && (c = zSynopsis[ii]) != 0; ii++) {
			if (c == 'P') {
				c = zSynopsis[++ii];
				if (c == '4') {
					sqlite3_snprintf(nTemp - jj, zTemp + jj, "%s", zP4);
				}
				else if (c == 'X') {
					sqlite3_snprintf(nTemp - jj, zTemp + jj, "%s", pOp->zComment);
					seenCom = 1;
				}
				else {
					int v1 = translateP(c, pOp);
					int v2;
					sqlite3_snprintf(nTemp - jj, zTemp + jj, "%d", v1);
					if (strncmp(zSynopsis + ii + 1, "@P", 2) == 0) {
						ii += 3;
						jj += sqlite3Strlen30(zTemp + jj);
						v2 = translateP(zSynopsis[ii], pOp);
						if (strncmp(zSynopsis + ii + 1, "+1", 2) == 0) {
							ii += 2;
							v2++;
						}
						if (v2>1) {
							sqlite3_snprintf(nTemp - jj, zTemp + jj, "..%d", v1 + v2 - 1);
						}
					}
					else if (strncmp(zSynopsis + ii + 1, "..P3", 4) == 0 && pOp->p3 == 0) {
						ii += 4;
					}
				}
				jj += sqlite3Strlen30(zTemp + jj);
			}
			else {
				zTemp[jj++] = c;
			}
		}
		if (!seenCom && jj<nTemp - 5 && pOp->zComment) {
			sqlite3_snprintf(nTemp - jj, zTemp + jj, "; %s", pOp->zComment);
			jj += sqlite3Strlen30(zTemp + jj);
		}
		if (jj<nTemp) zTemp[jj] = 0;
	}
	else if (pOp->zComment) {
		sqlite3_snprintf(nTemp, zTemp, "%s", pOp->zComment);
		jj = sqlite3Strlen30(zTemp);
	}
	else {
		zTemp[0] = 0;
		jj = 0;
	}
	return jj;
}
#endif 

#if VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS)

static void displayP4Expr(StrAccum *p, Expr *pExpr) {
	const char *zOp = 0;
	switch (pExpr->op) {
	case TK_STRING:
		sqlite3XPrintf(p, "%Q", pExpr->u.zToken);
		break;
	case TK_INTEGER:
		sqlite3XPrintf(p, "%d", pExpr->u.iValue);
		break;
	case TK_NULL:
		sqlite3XPrintf(p, "NULL");
		break;
	case TK_REGISTER: {
		sqlite3XPrintf(p, "r[%d]", pExpr->iTable);
		break;
	}
	case TK_COLUMN: {
		if (pExpr->iColumn<0) {
			sqlite3XPrintf(p, "rowid");
		}
		else {
			sqlite3XPrintf(p, "c%d", (int)pExpr->iColumn);
		}
		break;
	}
	case TK_LT:      zOp = "LT";      break;
	case TK_LE:      zOp = "LE";      break;
	case TK_GT:      zOp = "GT";      break;
	case TK_GE:      zOp = "GE";      break;
	case TK_NE:      zOp = "NE";      break;
	case TK_EQ:      zOp = "EQ";      break;
	case TK_IS:      zOp = "IS";      break;
	case TK_ISNOT:   zOp = "ISNOT";   break;
	case TK_AND:     zOp = "AND";     break;
	case TK_OR:      zOp = "OR";      break;
	case TK_PLUS:    zOp = "ADD";     break;
	case TK_STAR:    zOp = "MUL";     break;
	case TK_MINUS:   zOp = "SUB";     break;
	case TK_REM:     zOp = "REM";     break;
	case TK_BITAND:  zOp = "BITAND";  break;
	case TK_BITOR:   zOp = "BITOR";   break;
	case TK_SLASH:   zOp = "DIV";     break;
	case TK_LSHIFT:  zOp = "LSHIFT";  break;
	case TK_RSHIFT:  zOp = "RSHIFT";  break;
	case TK_CONCAT:  zOp = "CONCAT";  break;
	case TK_UMINUS:  zOp = "MINUS";   break;
	case TK_UPLUS:   zOp = "PLUS";    break;
	case TK_BITNOT:  zOp = "BITNOT";  break;
	case TK_NOT:     zOp = "NOT";     break;
	case TK_ISNULL:  zOp = "ISNULL";  break;
	case TK_NOTNULL: zOp = "NOTNULL"; break;

	default:
		sqlite3XPrintf(p, "%s", "expr");
		break;
	}

	if (zOp) {
		sqlite3XPrintf(p, "%s(", zOp);
		displayP4Expr(p, pExpr->pLeft);
		if (pExpr->pRight) {
			sqlite3StrAccumAppend(p, ",", 1);
			displayP4Expr(p, pExpr->pRight);
		}
		sqlite3StrAccumAppend(p, ")", 1);
	}
}
#endif 


#if VDBE_DISPLAY_P4

static char *displayP4(Op *pOp, char *zTemp, int nTemp) {
	char *zP4 = zTemp;
	StrAccum x;
	assert(nTemp >= 20);
	sqlite3StrAccumInit(&x, 0, zTemp, nTemp, 0);
	switch (pOp->p4type) {
	case P4_KEYINFO: {
		int j;
		KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
		assert(pKeyInfo->aSortOrder != 0);
		sqlite3XPrintf(&x, "k(%d", pKeyInfo->nField);
		for (j = 0; j<pKeyInfo->nField; j++) {
			CollSeq *pColl = pKeyInfo->aColl[j];
			const char *zColl = pColl ? pColl->zName : "";
			if (strcmp(zColl, "BINARY") == 0) zColl = "B";
			sqlite3XPrintf(&x, ",%s%s", pKeyInfo->aSortOrder[j] ? "-" : "", zColl);
		}
		sqlite3StrAccumAppend(&x, ")", 1);
		break;
	}
#ifdef SQLITE_ENABLE_CURSOR_HINTS
	case P4_EXPR: {
		displayP4Expr(&x, pOp->p4.pExpr);
		break;
	}
#endif
	case P4_COLLSEQ: {
		CollSeq *pColl = pOp->p4.pColl;
		sqlite3XPrintf(&x, "(%.20s)", pColl->zName);
		break;
	}
	case P4_FUNCDEF: {
		FuncDef *pDef = pOp->p4.pFunc;
		sqlite3XPrintf(&x, "%s(%d)", pDef->zName, pDef->nArg);
		break;
	}
#ifdef SQLITE_DEBUG
	case P4_FUNCCTX: {
		FuncDef *pDef = pOp->p4.pCtx->pFunc;
		sqlite3XPrintf(&x, "%s(%d)", pDef->zName, pDef->nArg);
		break;
	}
#endif
	case P4_INT64: {
		sqlite3XPrintf(&x, "%lld", *pOp->p4.pI64);
		break;
	}
	case P4_INT32: {
		sqlite3XPrintf(&x, "%d", pOp->p4.i);
		break;
	}
	case P4_REAL: {
		sqlite3XPrintf(&x, "%.16g", *pOp->p4.pReal);
		break;
	}
	case P4_MEM: {
		Mem *pMem = pOp->p4.pMem;
		if (pMem->flags & MEM_Str) {
			zP4 = pMem->z;
		}
		else if (pMem->flags & MEM_Int) {
			sqlite3XPrintf(&x, "%lld", pMem->u.i);
		}
		else if (pMem->flags & MEM_Real) {
			sqlite3XPrintf(&x, "%.16g", pMem->u.r);
		}
		else if (pMem->flags & MEM_Null) {
			zP4 = "NULL";
		}
		else {
			assert(pMem->flags & MEM_Blob);
			zP4 = "(blob)";
		}
		break;
	}
#ifndef SQLITE_OMIT_VIRTUALTABLE
	case P4_VTAB: {
		sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
		sqlite3XPrintf(&x, "vtab:%p", pVtab);
		break;
	}
#endif
	case P4_INTARRAY: {
		int i;
		int *ai = pOp->p4.ai;
		int n = ai[0];   
		for (i = 1; i<n; i++) {
			sqlite3XPrintf(&x, ",%d", ai[i]);
		}
		zTemp[0] = '[';
		sqlite3StrAccumAppend(&x, "]", 1);
		break;
	}
	case P4_SUBPROGRAM: {
		sqlite3XPrintf(&x, "program");
		break;
	}
	case P4_ADVANCE: {
		zTemp[0] = 0;
		break;
	}
	case P4_TABLE: {
		sqlite3XPrintf(&x, "%s", pOp->p4.pTab->zName);
		break;
	}
	default: {
		zP4 = pOp->p4.z;
		if (zP4 == 0) {
			zP4 = zTemp;
			zTemp[0] = 0;
		}
	}
	}
	sqlite3StrAccumFinish(&x);
	assert(zP4 != 0);
	return zP4;
}
#endif 


SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe *p, int i) {
	assert(i >= 0 && i<p->db->nDb && i<(int)sizeof(yDbMask) * 8);
	assert(i<(int)sizeof(p->btreeMask) * 8);
	DbMaskSet(p->btreeMask, i);
	if (i != 1 && sqlite3BtreeSharable(p->db->aDb[i].pBt)) {
		DbMaskSet(p->lockMask, i);
	}
}

#if !defined(SQLITE_OMIT_SHARED_CACHE)

SQLITE_PRIVATE void sqlite3VdbeEnter(Vdbe *p) {
	int i;
	sqlite3 *db;
	Db *aDb;
	int nDb;
	if (DbMaskAllZero(p->lockMask)) return;  
	db = p->db;
	aDb = db->aDb;
	nDb = db->nDb;
	for (i = 0; i<nDb; i++) {
		if (i != 1 && DbMaskTest(p->lockMask, i) && ALWAYS(aDb[i].pBt != 0)) {
			sqlite3BtreeEnter(aDb[i].pBt);
		}
	}
}
#endif

#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0

static SQLITE_NOINLINE void vdbeLeave(Vdbe *p) {
	int i;
	sqlite3 *db;
	Db *aDb;
	int nDb;
	db = p->db;
	aDb = db->aDb;
	nDb = db->nDb;
	for (i = 0; i<nDb; i++) {
		if (i != 1 && DbMaskTest(p->lockMask, i) && ALWAYS(aDb[i].pBt != 0)) {
			sqlite3BtreeLeave(aDb[i].pBt);
		}
	}
}
SQLITE_PRIVATE void sqlite3VdbeLeave(Vdbe *p) {
	if (DbMaskAllZero(p->lockMask)) return;  
	vdbeLeave(p);
}
#endif

#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)

SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp) {
	char *zP4;
	char zPtr[50];
	char zCom[100];
	static const char *zFormat1 = "%4d %-13s %4d %4d %4d %-13s %.2X %s\n";
	if (pOut == 0) pOut = stdout;
	zP4 = displayP4(pOp, zPtr, sizeof(zPtr));
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
	displayComment(pOp, zP4, zCom, sizeof(zCom));
#else
	zCom[0] = 0;
#endif
	
	fprintf(pOut, zFormat1, pc,
		sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5,
		zCom
	);
	fflush(pOut);
}
#endif


static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags) {
	while ((N--)>0) {
		p->db = db;
		p->flags = flags;
		p->szMalloc = 0;
#ifdef SQLITE_DEBUG
		p->pScopyFrom = 0;
#endif
		p++;
	}
}


static void releaseMemArray(Mem *p, int N) {
	if (p && N) {
		Mem *pEnd = &p[N];
		sqlite3 *db = p->db;
		if (db->pnBytesFreed) {
			do {
				if (p->szMalloc) sqlite3DbFree(db, p->zMalloc);
			} while ((++p)<pEnd);
			return;
		}
		do {
			assert((&p[1]) == pEnd || p[0].db == p[1].db);
			assert(sqlite3VdbeCheckMemInvariants(p));

			
			testcase(p->flags & MEM_Agg);
			testcase(p->flags & MEM_Dyn);
			testcase(p->flags & MEM_Frame);
			testcase(p->flags & MEM_RowSet);
			if (p->flags&(MEM_Agg | MEM_Dyn | MEM_Frame | MEM_RowSet)) {
				sqlite3VdbeMemRelease(p);
			}
			else if (p->szMalloc) {
				sqlite3DbFree(db, p->zMalloc);
				p->szMalloc = 0;
			}

			p->flags = MEM_Undefined;
		} while ((++p)<pEnd);
	}
}


SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p) {
	int i;
	Mem *aMem = VdbeFrameMem(p);
	VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
	for (i = 0; i<p->nChildCsr; i++) {
		sqlite3VdbeFreeCursor(p->v, apCsr[i]);
	}
	releaseMemArray(aMem, p->nChildMem);
	sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);
	sqlite3DbFree(p->v->db, p);
}

#ifndef SQLITE_OMIT_EXPLAIN

SQLITE_PRIVATE int sqlite3VdbeList(
	Vdbe *p                   
) {
	int nRow;                            
	int nSub = 0;                        
	SubProgram **apSub = 0;              
	Mem *pSub = 0;                       
	sqlite3 *db = p->db;                 
	int i;                               
	int rc = SQLITE_OK;                  
	Mem *pMem = &p->aMem[1];             

	assert(p->explain);
	assert(p->magic == VDBE_MAGIC_RUN);
	assert(p->rc == SQLITE_OK || p->rc == SQLITE_BUSY || p->rc == SQLITE_NOMEM);

	
	releaseMemArray(pMem, 8);
	p->pResultSet = 0;

	if (p->rc == SQLITE_NOMEM_BKPT) {
		
		sqlite3OomFault(db);
		return SQLITE_ERROR;
	}

	
	nRow = p->nOp;
	if (p->explain == 1) {
		
		assert(p->nMem>9);
		pSub = &p->aMem[9];
		if (pSub->flags&MEM_Blob) {
			
			nSub = pSub->n / sizeof(Vdbe*);
			apSub = (SubProgram **)pSub->z;
		}
		for (i = 0; i<nSub; i++) {
			nRow += apSub[i]->nOp;
		}
	}

	do {
		i = p->pc++;
	} while (i<nRow && p->explain == 2 && p->aOp[i].opcode != OP_Explain);
	if (i >= nRow) {
		p->rc = SQLITE_OK;
		rc = SQLITE_DONE;
	}
	else if (db->u1.isInterrupted) {
		p->rc = SQLITE_INTERRUPT;
		rc = SQLITE_ERROR;
		sqlite3VdbeError(p, sqlite3ErrStr(p->rc));
	}
	else {
		char *zP4;
		Op *pOp;
		if (i<p->nOp) {
			
			pOp = &p->aOp[i];
		}
		else {
			
			int j;
			i -= p->nOp;
			for (j = 0; i >= apSub[j]->nOp; j++) {
				i -= apSub[j]->nOp;
			}
			pOp = &apSub[j]->aOp[i];
		}
		if (p->explain == 1) {
			pMem->flags = MEM_Int;
			pMem->u.i = i;                                
			pMem++;

			pMem->flags = MEM_Static | MEM_Str | MEM_Term;
			pMem->z = (char*)sqlite3OpcodeName(pOp->opcode); 
			assert(pMem->z != 0);
			pMem->n = sqlite3Strlen30(pMem->z);
			pMem->enc = SQLITE_UTF8;
			pMem++;

			
			if (pOp->p4type == P4_SUBPROGRAM) {
				int nByte = (nSub + 1) * sizeof(SubProgram*);
				int j;
				for (j = 0; j<nSub; j++) {
					if (apSub[j] == pOp->p4.pProgram) break;
				}
				if (j == nSub && SQLITE_OK == sqlite3VdbeMemGrow(pSub, nByte, nSub != 0)) {
					apSub = (SubProgram **)pSub->z;
					apSub[nSub++] = pOp->p4.pProgram;
					pSub->flags |= MEM_Blob;
					pSub->n = nSub * sizeof(SubProgram*);
				}
			}
		}

		pMem->flags = MEM_Int;
		pMem->u.i = pOp->p1;                          
		pMem++;

		pMem->flags = MEM_Int;
		pMem->u.i = pOp->p2;                          
		pMem++;

		pMem->flags = MEM_Int;
		pMem->u.i = pOp->p3;                          
		pMem++;

		if (sqlite3VdbeMemClearAndResize(pMem, 100)) { 
			assert(p->db->mallocFailed);
			return SQLITE_ERROR;
		}
		pMem->flags = MEM_Str | MEM_Term;
		zP4 = displayP4(pOp, pMem->z, pMem->szMalloc);
		if (zP4 != pMem->z) {
			pMem->n = 0;
			sqlite3VdbeMemSetStr(pMem, zP4, -1, SQLITE_UTF8, 0);
		}
		else {
			assert(pMem->z != 0);
			pMem->n = sqlite3Strlen30(pMem->z);
			pMem->enc = SQLITE_UTF8;
		}
		pMem++;

		if (p->explain == 1) {
			if (sqlite3VdbeMemClearAndResize(pMem, 4)) {
				assert(p->db->mallocFailed);
				return SQLITE_ERROR;
			}
			pMem->flags = MEM_Str | MEM_Term;
			pMem->n = 2;
			sqlite3_snprintf(3, pMem->z, "%.2x", pOp->p5);   
			pMem->enc = SQLITE_UTF8;
			pMem++;

#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
			if (sqlite3VdbeMemClearAndResize(pMem, 500)) {
				assert(p->db->mallocFailed);
				return SQLITE_ERROR;
			}
			pMem->flags = MEM_Str | MEM_Term;
			pMem->n = displayComment(pOp, zP4, pMem->z, 500);
			pMem->enc = SQLITE_UTF8;
#else
			pMem->flags = MEM_Null;                       
#endif
		}

		p->nResColumn = 8 - 4 * (p->explain - 1);
		p->pResultSet = &p->aMem[1];
		p->rc = SQLITE_OK;
		rc = SQLITE_ROW;
	}
	return rc;
}
#endif 

#ifdef SQLITE_DEBUG

SQLITE_PRIVATE void sqlite3VdbePrintSql(Vdbe *p) {
	const char *z = 0;
	if (p->zSql) {
		z = p->zSql;
	}
	else if (p->nOp >= 1) {
		const VdbeOp *pOp = &p->aOp[0];
		if (pOp->opcode == OP_Init && pOp->p4.z != 0) {
			z = pOp->p4.z;
			while (sqlite3Isspace(*z)) z++;
		}
	}
	if (z) printf("SQL: [%s]\n", z);
}
#endif

#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)

SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p) {
	int nOp = p->nOp;
	VdbeOp *pOp;
	if (sqlite3IoTrace == 0) return;
	if (nOp<1) return;
	pOp = &p->aOp[0];
	if (pOp->opcode == OP_Init && pOp->p4.z != 0) {
		int i, j;
		char z[1000];
		sqlite3_snprintf(sizeof(z), z, "%s", pOp->p4.z);
		for (i = 0; sqlite3Isspace(z[i]); i++) {}
		for (j = 0; z[i]; i++) {
			if (sqlite3Isspace(z[i])) {
				if (z[i - 1] != ' ') {
					z[j++] = ' ';
				}
			}
			else {
				z[j++] = z[i];
			}
		}
		z[j] = 0;
		sqlite3IoTrace("SQL %s\n", z);
	}
}
#endif 


struct ReusableSpace {
	u8 *pSpace;          
	int nFree;           
	int nNeeded;         
};


static void *allocSpace(
	struct ReusableSpace *p,  
	void *pBuf,               
	int nByte                 
) {
	assert(EIGHT_BYTE_ALIGNMENT(p->pSpace));
	if (pBuf == 0) {
		nByte = ROUND8(nByte);
		if (nByte <= p->nFree) {
			p->nFree -= nByte;
			pBuf = &p->pSpace[p->nFree];
		}
		else {
			p->nNeeded += nByte;
		}
	}
	assert(EIGHT_BYTE_ALIGNMENT(pBuf));
	return pBuf;
}


SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe *p) {
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
	int i;
#endif
	assert(p != 0);
	assert(p->magic == VDBE_MAGIC_INIT || p->magic == VDBE_MAGIC_RESET);

	
	assert(p->nOp>0);

	
	p->magic = VDBE_MAGIC_RUN;

#ifdef SQLITE_DEBUG
	for (i = 0; i<p->nMem; i++) {
		assert(p->aMem[i].db == p->db);
	}
#endif
	p->pc = -1;
	p->rc = SQLITE_OK;
	p->errorAction = OE_Abort;
	p->nChange = 0;
	p->cacheCtr = 1;
	p->minWriteFileFormat = 255;
	p->iStatement = 0;
	p->nFkConstraint = 0;
#ifdef VDBE_PROFILE
	for (i = 0; i<p->nOp; i++) {
		p->aOp[i].cnt = 0;
		p->aOp[i].cycles = 0;
	}
#endif
}


SQLITE_PRIVATE void sqlite3VdbeMakeReady(
	Vdbe *p,                       
	Parse *pParse                  
) {
	sqlite3 *db;                   
	int nVar;                      
	int nMem;                      
	int nCursor;                   
	int nArg;                      
	int n;                         
	struct ReusableSpace x;        

	assert(p != 0);
	assert(p->nOp>0);
	assert(pParse != 0);
	assert(p->magic == VDBE_MAGIC_INIT);
	assert(pParse == p->pParse);
	db = p->db;
	assert(db->mallocFailed == 0);
	nVar = pParse->nVar;
	nMem = pParse->nMem;
	nCursor = pParse->nTab;
	nArg = pParse->nMaxArg;

	
	nMem += nCursor;
	if (nCursor == 0 && nMem>0) nMem++;  

										 
	n = ROUND8(sizeof(Op)*p->nOp);              
	x.pSpace = &((u8*)p->aOp)[n];               
	assert(EIGHT_BYTE_ALIGNMENT(x.pSpace));
	x.nFree = ROUNDDOWN8(pParse->szOpAlloc - n);  
	assert(x.nFree >= 0);
	assert(EIGHT_BYTE_ALIGNMENT(&x.pSpace[x.nFree]));

	resolveP2Values(p, &nArg);
	p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);
	if (pParse->explain && nMem<10) {
		nMem = 10;
	}
	p->expired = 0;

	
	do {
		x.nNeeded = 0;
		p->aMem = allocSpace(&x, p->aMem, nMem * sizeof(Mem));
		p->aVar = allocSpace(&x, p->aVar, nVar * sizeof(Mem));
		p->apArg = allocSpace(&x, p->apArg, nArg * sizeof(Mem*));
		p->apCsr = allocSpace(&x, p->apCsr, nCursor * sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
		p->anExec = allocSpace(&x, p->anExec, p->nOp * sizeof(i64));
#endif
		if (x.nNeeded == 0) break;
		x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);
		x.nFree = x.nNeeded;
	} while (!db->mallocFailed);

	p->nzVar = pParse->nzVar;
	p->azVar = pParse->azVar;
	pParse->nzVar = 0;
	pParse->azVar = 0;
	p->explain = pParse->explain;
	if (db->mallocFailed) {
		p->nVar = 0;
		p->nCursor = 0;
		p->nMem = 0;
	}
	else {
		p->nCursor = nCursor;
		p->nVar = (ynVar)nVar;
		initMemArray(p->aVar, nVar, db, MEM_Null);
		p->nMem = nMem;
		initMemArray(p->aMem, nMem, db, MEM_Undefined);
		memset(p->apCsr, 0, nCursor * sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
		memset(p->anExec, 0, p->nOp * sizeof(i64));
#endif
	}
	sqlite3VdbeRewind(p);
}


SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx) {
	if (pCx == 0) {
		return;
	}
	assert(pCx->pBt == 0 || pCx->eCurType == CURTYPE_BTREE);
	switch (pCx->eCurType) {
	case CURTYPE_SORTER: {
		sqlite3VdbeSorterClose(p->db, pCx);
		break;
	}
	case CURTYPE_BTREE: {
		if (pCx->pBt) {
			sqlite3BtreeClose(pCx->pBt);
			
		}
		else {
			assert(pCx->uc.pCursor != 0);
			sqlite3BtreeCloseCursor(pCx->uc.pCursor);
		}
		break;
	}
#ifndef SQLITE_OMIT_VIRTUALTABLE
	case CURTYPE_VTAB: {
		sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;
		const sqlite3_module *pModule = pVCur->pVtab->pModule;
		assert(pVCur->pVtab->nRef>0);
		pVCur->pVtab->nRef--;
		pModule->xClose(pVCur);
		break;
	}
#endif
	}
}


static void closeCursorsInFrame(Vdbe *p) {
	if (p->apCsr) {
		int i;
		for (i = 0; i<p->nCursor; i++) {
			VdbeCursor *pC = p->apCsr[i];
			if (pC) {
				sqlite3VdbeFreeCursor(p, pC);
				p->apCsr[i] = 0;
			}
		}
	}
}


SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *pFrame) {
	Vdbe *v = pFrame->v;
	closeCursorsInFrame(v);
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
	v->anExec = pFrame->anExec;
#endif
	v->aOp = pFrame->aOp;
	v->nOp = pFrame->nOp;
	v->aMem = pFrame->aMem;
	v->nMem = pFrame->nMem;
	v->apCsr = pFrame->apCsr;
	v->nCursor = pFrame->nCursor;
	v->db->lastRowid = pFrame->lastRowid;
	v->nChange = pFrame->nChange;
	v->db->nChange = pFrame->nDbChange;
	sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);
	v->pAuxData = pFrame->pAuxData;
	pFrame->pAuxData = 0;
	return pFrame->pc;
}


static void closeAllCursors(Vdbe *p) {
	if (p->pFrame) {
		VdbeFrame *pFrame;
		for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent);
		sqlite3VdbeFrameRestore(pFrame);
		p->pFrame = 0;
		p->nFrame = 0;
	}
	assert(p->nFrame == 0);
	closeCursorsInFrame(p);
	if (p->aMem) {
		releaseMemArray(p->aMem, p->nMem);
	}
	while (p->pDelFrame) {
		VdbeFrame *pDel = p->pDelFrame;
		p->pDelFrame = pDel->pParent;
		sqlite3VdbeFrameDelete(pDel);
	}

	
	if (p->pAuxData) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);
	assert(p->pAuxData == 0);
}


static void Cleanup(Vdbe *p) {
	sqlite3 *db = p->db;

#ifdef SQLITE_DEBUG
	
	int i;
	if (p->apCsr) for (i = 0; i<p->nCursor; i++) assert(p->apCsr[i] == 0);
	if (p->aMem) {
		for (i = 0; i<p->nMem; i++) assert(p->aMem[i].flags == MEM_Undefined);
	}
#endif

	sqlite3DbFree(db, p->zErrMsg);
	p->zErrMsg = 0;
	p->pResultSet = 0;
}


SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn) {
	Mem *pColName;
	int n;
	sqlite3 *db = p->db;

	releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
	sqlite3DbFree(db, p->aColName);
	n = nResColumn*COLNAME_N;
	p->nResColumn = (u16)nResColumn;
	p->aColName = pColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n);
	if (p->aColName == 0) return;
	initMemArray(p->aColName, n, p->db, MEM_Null);
}


SQLITE_PRIVATE int sqlite3VdbeSetColName(
	Vdbe *p,                         
	int idx,                         
	int var,                         
	const char *zName,               
	void(*xDel)(void*)              
) {
	int rc;
	Mem *pColName;
	assert(idx<p->nResColumn);
	assert(var<COLNAME_N);
	if (p->db->mallocFailed) {
		assert(!zName || xDel != SQLITE_DYNAMIC);
		return SQLITE_NOMEM_BKPT;
	}
	assert(p->aColName != 0);
	pColName = &(p->aColName[idx + var*p->nResColumn]);
	rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);
	assert(rc != 0 || !zName || (pColName->flags&MEM_Term) != 0);
	return rc;
}


static int vdbeCommit(sqlite3 *db, Vdbe *p) {
	int i;
	int nTrans = 0;  
	int rc = SQLITE_OK;
	int needXcommit = 0;

#ifdef SQLITE_OMIT_VIRTUALTABLE
	
	UNUSED_PARAMETER(p);
#endif

	
	rc = sqlite3VtabSync(db, p);

	
	for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
		Btree *pBt = db->aDb[i].pBt;
		if (sqlite3BtreeIsInTrans(pBt)) {
			
			static const u8 aMJNeeded[] = {
				  1,
				 1,
				 0,
				 1,
				 0,
				 0
			};
			Pager *pPager;   
			needXcommit = 1;
			sqlite3BtreeEnter(pBt);
			pPager = sqlite3BtreePager(pBt);
			if (db->aDb[i].safety_level != PAGER_SYNCHRONOUS_OFF
				&& aMJNeeded[sqlite3PagerGetJournalMode(pPager)]
				) {
				assert(i != 1);
				nTrans++;
			}
			rc = sqlite3PagerExclusiveLock(pPager);
			sqlite3BtreeLeave(pBt);
		}
	}
	if (rc != SQLITE_OK) {
		return rc;
	}

	
	if (needXcommit && db->xCommitCallback) {
		rc = db->xCommitCallback(db->pCommitArg);
		if (rc) {
			return SQLITE_CONSTRAINT_COMMITHOOK;
		}
	}

	
	if (0 == sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))
		|| nTrans <= 1
		) {
		for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				rc = sqlite3BtreeCommitPhaseOne(pBt, 0);
			}
		}

		
		for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);
			}
		}
		if (rc == SQLITE_OK) {
			sqlite3VtabCommit(db);
		}
	}

	
#ifndef SQLITE_OMIT_DISKIO
	else {
		sqlite3_vfs *pVfs = db->pVfs;
		char *zMaster = 0;   
		char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
		sqlite3_file *pMaster = 0;
		i64 offset = 0;
		int res;
		int retryCount = 0;
		int nMainFile;

		
		nMainFile = sqlite3Strlen30(zMainFile);
		zMaster = sqlite3MPrintf(db, "%s-mjXXXXXX9XXz", zMainFile);
		if (zMaster == 0) return SQLITE_NOMEM_BKPT;
		do {
			u32 iRandom;
			if (retryCount) {
				if (retryCount>100) {
					sqlite3_log(SQLITE_FULL, "MJ delete: %s", zMaster);
					sqlite3OsDelete(pVfs, zMaster, 0);
					break;
				}
				else if (retryCount == 1) {
					sqlite3_log(SQLITE_FULL, "MJ collide: %s", zMaster);
				}
			}
			retryCount++;
			sqlite3_randomness(sizeof(iRandom), &iRandom);
			sqlite3_snprintf(13, &zMaster[nMainFile], "-mj%06X9%02X",
				(iRandom >> 8) & 0xffffff, iRandom & 0xff);
			
			assert(zMaster[sqlite3Strlen30(zMaster) - 3] == '9');
			sqlite3FileSuffix3(zMainFile, zMaster);
			rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);
		} while (rc == SQLITE_OK && res);
		if (rc == SQLITE_OK) {
			
			rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster,
				SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |
				SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_MASTER_JOURNAL, 0
			);
		}
		if (rc != SQLITE_OK) {
			sqlite3DbFree(db, zMaster);
			return rc;
		}

		
		for (i = 0; i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (sqlite3BtreeIsInTrans(pBt)) {
				char const *zFile = sqlite3BtreeGetJournalname(pBt);
				if (zFile == 0) {
					continue;  
				}
				assert(zFile[0] != 0);
				rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile) + 1, offset);
				offset += sqlite3Strlen30(zFile) + 1;
				if (rc != SQLITE_OK) {
					sqlite3OsCloseFree(pMaster);
					sqlite3OsDelete(pVfs, zMaster, 0);
					sqlite3DbFree(db, zMaster);
					return rc;
				}
			}
		}

		
		if (0 == (sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)
			&& SQLITE_OK != (rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))
			) {
			sqlite3OsCloseFree(pMaster);
			sqlite3OsDelete(pVfs, zMaster, 0);
			sqlite3DbFree(db, zMaster);
			return rc;
		}

		
		for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);
			}
		}
		sqlite3OsCloseFree(pMaster);
		assert(rc != SQLITE_BUSY);
		if (rc != SQLITE_OK) {
			sqlite3DbFree(db, zMaster);
			return rc;
		}

		
		rc = sqlite3OsDelete(pVfs, zMaster, 1);
		sqlite3DbFree(db, zMaster);
		zMaster = 0;
		if (rc) {
			return rc;
		}

		
		disable_simulated_io_errors();
		sqlite3BeginBenignMalloc();
		for (i = 0; i<db->nDb; i++) {
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				sqlite3BtreeCommitPhaseTwo(pBt, 1);
			}
		}
		sqlite3EndBenignMalloc();
		enable_simulated_io_errors();

		sqlite3VtabCommit(db);
	}
#endif

	return rc;
}


#ifndef NDEBUG
static void checkActiveVdbeCnt(sqlite3 *db) {
	Vdbe *p;
	int cnt = 0;
	int nWrite = 0;
	int nRead = 0;
	p = db->pVdbe;
	while (p) {
		if (sqlite3_stmt_busy((sqlite3_stmt*)p)) {
			cnt++;
			if (p->readOnly == 0) nWrite++;
			if (p->bIsReader) nRead++;
		}
		p = p->pNext;
	}
	assert(cnt == db->nVdbeActive);
	assert(nWrite == db->nVdbeWrite);
	assert(nRead == db->nVdbeRead);
}
#else
#define checkActiveVdbeCnt(x)
#endif


SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *p, int eOp) {
	sqlite3 *const db = p->db;
	int rc = SQLITE_OK;

	
	if (db->nStatement && p->iStatement) {
		int i;
		const int iSavepoint = p->iStatement - 1;

		assert(eOp == SAVEPOINT_ROLLBACK || eOp == SAVEPOINT_RELEASE);
		assert(db->nStatement>0);
		assert(p->iStatement == (db->nStatement + db->nSavepoint));

		for (i = 0; i<db->nDb; i++) {
			int rc2 = SQLITE_OK;
			Btree *pBt = db->aDb[i].pBt;
			if (pBt) {
				if (eOp == SAVEPOINT_ROLLBACK) {
					rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);
				}
				if (rc2 == SQLITE_OK) {
					rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);
				}
				if (rc == SQLITE_OK) {
					rc = rc2;
				}
			}
		}
		db->nStatement--;
		p->iStatement = 0;

		if (rc == SQLITE_OK) {
			if (eOp == SAVEPOINT_ROLLBACK) {
				rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);
			}
			if (rc == SQLITE_OK) {
				rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);
			}
		}

		
		if (eOp == SAVEPOINT_ROLLBACK) {
			db->nDeferredCons = p->nStmtDefCons;
			db->nDeferredImmCons = p->nStmtDefImmCons;
		}
	}
	return rc;
}


#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *p, int deferred) {
	sqlite3 *db = p->db;
	if ((deferred && (db->nDeferredCons + db->nDeferredImmCons)>0)
		|| (!deferred && p->nFkConstraint>0)
		) {
		p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;
		p->errorAction = OE_Abort;
		sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
		return SQLITE_ERROR;
	}
	return SQLITE_OK;
}
#endif


SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p) {
	int rc;                         
	sqlite3 *db = p->db;

	

	if (db->mallocFailed) {
		p->rc = SQLITE_NOMEM_BKPT;
	}
	closeAllCursors(p);
	if (p->magic != VDBE_MAGIC_RUN) {
		return SQLITE_OK;
	}
	checkActiveVdbeCnt(db);

	
	if (p->pc >= 0 && p->bIsReader) {
		int mrc;   
		int eStatementOp = 0;
		int isSpecialError;            

									   
		sqlite3VdbeEnter(p);

		
		mrc = p->rc & 0xff;
		isSpecialError = mrc == SQLITE_NOMEM || mrc == SQLITE_IOERR
			|| mrc == SQLITE_INTERRUPT || mrc == SQLITE_FULL;
		if (isSpecialError) {
			
			if (!p->readOnly || mrc != SQLITE_INTERRUPT) {
				if ((mrc == SQLITE_NOMEM || mrc == SQLITE_FULL) && p->usesStmtJournal) {
					eStatementOp = SAVEPOINT_ROLLBACK;
				}
				else {
					
					sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
					sqlite3CloseSavepoints(db);
					db->autoCommit = 1;
					p->nChange = 0;
				}
			}
		}

		
		if (p->rc == SQLITE_OK) {
			sqlite3VdbeCheckFk(p, 0);
		}

		
		if (!sqlite3VtabInSync(db)
			&& db->autoCommit
			&& db->nVdbeWrite == (p->readOnly == 0)
			) {
			if (p->rc == SQLITE_OK || (p->errorAction == OE_Fail && !isSpecialError)) {
				rc = sqlite3VdbeCheckFk(p, 1);
				if (rc != SQLITE_OK) {
					if (NEVER(p->readOnly)) {
						sqlite3VdbeLeave(p);
						return SQLITE_ERROR;
					}
					rc = SQLITE_CONSTRAINT_FOREIGNKEY;
				}
				else {
					
					rc = vdbeCommit(db, p);
				}
				if (rc == SQLITE_BUSY && p->readOnly) {
					sqlite3VdbeLeave(p);
					return SQLITE_BUSY;
				}
				else if (rc != SQLITE_OK) {
					p->rc = rc;
					sqlite3RollbackAll(db, SQLITE_OK);
					p->nChange = 0;
				}
				else {
					db->nDeferredCons = 0;
					db->nDeferredImmCons = 0;
					db->flags &= ~SQLITE_DeferFKs;
					sqlite3CommitInternalChanges(db);
				}
			}
			else {
				sqlite3RollbackAll(db, SQLITE_OK);
				p->nChange = 0;
			}
			db->nStatement = 0;
		}
		else if (eStatementOp == 0) {
			if (p->rc == SQLITE_OK || p->errorAction == OE_Fail) {
				eStatementOp = SAVEPOINT_RELEASE;
			}
			else if (p->errorAction == OE_Abort) {
				eStatementOp = SAVEPOINT_ROLLBACK;
			}
			else {
				sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
				sqlite3CloseSavepoints(db);
				db->autoCommit = 1;
				p->nChange = 0;
			}
		}

		
		if (eStatementOp) {
			rc = sqlite3VdbeCloseStatement(p, eStatementOp);
			if (rc) {
				if (p->rc == SQLITE_OK || (p->rc & 0xff) == SQLITE_CONSTRAINT) {
					p->rc = rc;
					sqlite3DbFree(db, p->zErrMsg);
					p->zErrMsg = 0;
				}
				sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
				sqlite3CloseSavepoints(db);
				db->autoCommit = 1;
				p->nChange = 0;
			}
		}

		
		if (p->changeCntOn) {
			if (eStatementOp != SAVEPOINT_ROLLBACK) {
				sqlite3VdbeSetChanges(db, p->nChange);
			}
			else {
				sqlite3VdbeSetChanges(db, 0);
			}
			p->nChange = 0;
		}

		
		sqlite3VdbeLeave(p);
	}

	
	if (p->pc >= 0) {
		db->nVdbeActive--;
		if (!p->readOnly) db->nVdbeWrite--;
		if (p->bIsReader) db->nVdbeRead--;
		assert(db->nVdbeActive >= db->nVdbeRead);
		assert(db->nVdbeRead >= db->nVdbeWrite);
		assert(db->nVdbeWrite >= 0);
	}
	p->magic = VDBE_MAGIC_HALT;
	checkActiveVdbeCnt(db);
	if (db->mallocFailed) {
		p->rc = SQLITE_NOMEM_BKPT;
	}

	
	if (db->autoCommit) {
		sqlite3ConnectionUnlocked(db);
	}

	assert(db->nVdbeActive>0 || db->autoCommit == 0 || db->nStatement == 0);
	return (p->rc == SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK);
}



SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe *p) {
	p->rc = SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p) {
	sqlite3 *db = p->db;
	int rc = p->rc;
	if (p->zErrMsg) {
		db->bBenignMalloc++;
		sqlite3BeginBenignMalloc();
		if (db->pErr == 0) db->pErr = sqlite3ValueNew(db);
		sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
		sqlite3EndBenignMalloc();
		db->bBenignMalloc--;
		db->errCode = rc;
	}
	else {
		sqlite3Error(db, rc);
	}
	return rc;
}

#ifdef SQLITE_ENABLE_SQLLOG

static void vdbeInvokeSqllog(Vdbe *v) {
	if (sqlite3GlobalConfig.xSqllog && v->rc == SQLITE_OK && v->zSql && v->pc >= 0) {
		char *zExpanded = sqlite3VdbeExpandSql(v, v->zSql);
		assert(v->db->init.busy == 0);
		if (zExpanded) {
			sqlite3GlobalConfig.xSqllog(
				sqlite3GlobalConfig.pSqllogArg, v->db, zExpanded, 1
			);
			sqlite3DbFree(v->db, zExpanded);
		}
	}
}
#else
# define vdbeInvokeSqllog(x)
#endif


SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p) {
	sqlite3 *db;
	db = p->db;

	
	sqlite3VdbeHalt(p);

	
	if (p->pc >= 0) {
		vdbeInvokeSqllog(p);
		sqlite3VdbeTransferError(p);
		sqlite3DbFree(db, p->zErrMsg);
		p->zErrMsg = 0;
		if (p->runOnlyOnce) p->expired = 1;
	}
	else if (p->rc && p->expired) {
		
		sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? "%s" : 0, p->zErrMsg);
		sqlite3DbFree(db, p->zErrMsg);
		p->zErrMsg = 0;
	}

	
	Cleanup(p);

	
#ifdef VDBE_PROFILE
	{
		FILE *out = fopen("vdbe_profile.out", "a");
		if (out) {
			int i;
			fprintf(out, "---- ");
			for (i = 0; i<p->nOp; i++) {
				fprintf(out, "%02x", p->aOp[i].opcode);
			}
			fprintf(out, "\n");
			if (p->zSql) {
				char c, pc = 0;
				fprintf(out, "-- ");
				for (i = 0; (c = p->zSql[i]) != 0; i++) {
					if (pc == '\n') fprintf(out, "-- ");
					putc(c, out);
					pc = c;
				}
				if (pc != '\n') fprintf(out, "\n");
			}
			for (i = 0; i<p->nOp; i++) {
				char zHdr[100];
				sqlite3_snprintf(sizeof(zHdr), zHdr, "%6u %12llu %8llu ",
					p->aOp[i].cnt,
					p->aOp[i].cycles,
					p->aOp[i].cnt>0 ? p->aOp[i].cycles / p->aOp[i].cnt : 0
				);
				fprintf(out, "%s", zHdr);
				sqlite3VdbePrintOp(out, i, &p->aOp[i]);
			}
			fclose(out);
		}
	}
#endif
	p->iCurrentTime = 0;
	p->magic = VDBE_MAGIC_RESET;
	return p->rc & db->errMask;
}


SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe *p) {
	int rc = SQLITE_OK;
	if (p->magic == VDBE_MAGIC_RUN || p->magic == VDBE_MAGIC_HALT) {
		rc = sqlite3VdbeReset(p);
		assert((rc & p->db->errMask) == rc);
	}
	sqlite3VdbeDelete(p);
	return rc;
}


SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask) {
	while (*pp) {
		AuxData *pAux = *pp;
		if ((iOp<0)
			|| (pAux->iOp == iOp && (pAux->iArg>31 || !(mask & MASKBIT32(pAux->iArg))))
			) {
			testcase(pAux->iArg == 31);
			if (pAux->xDelete) {
				pAux->xDelete(pAux->pAux);
			}
			*pp = pAux->pNext;
			sqlite3DbFree(db, pAux);
		}
		else {
			pp = &pAux->pNext;
		}
	}
}


SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p) {
	SubProgram *pSub, *pNext;
	int i;
	assert(p->db == 0 || p->db == db);
	releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
	for (pSub = p->pProgram; pSub; pSub = pNext) {
		pNext = pSub->pNext;
		vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
		sqlite3DbFree(db, pSub);
	}
	if (p->magic != VDBE_MAGIC_INIT) {
		releaseMemArray(p->aVar, p->nVar);
		for (i = p->nzVar - 1; i >= 0; i--) sqlite3DbFree(db, p->azVar[i]);
		sqlite3DbFree(db, p->azVar);
		sqlite3DbFree(db, p->pFree);
	}
	vdbeFreeOpArray(db, p->aOp, p->nOp);
	sqlite3DbFree(db, p->aColName);
	sqlite3DbFree(db, p->zSql);
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
	for (i = 0; i<p->nScan; i++) {
		sqlite3DbFree(db, p->aScan[i].zName);
	}
	sqlite3DbFree(db, p->aScan);
#endif
}


SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p) {
	sqlite3 *db;

	if (NEVER(p == 0)) return;
	db = p->db;
	assert(sqlite3_mutex_held(db->mutex));
	sqlite3VdbeClearObject(db, p);
	if (p->pPrev) {
		p->pPrev->pNext = p->pNext;
	}
	else {
		assert(db->pVdbe == p);
		db->pVdbe = p->pNext;
	}
	if (p->pNext) {
		p->pNext->pPrev = p->pPrev;
	}
	p->magic = VDBE_MAGIC_DEAD;
	p->db = 0;
	sqlite3DbFree(db, p);
}


static int SQLITE_NOINLINE handleDeferredMoveto(VdbeCursor *p) {
	int res, rc;
#ifdef SQLITE_TEST
	extern int sqlite3_search_count;
#endif
	assert(p->deferredMoveto);
	assert(p->isTable);
	assert(p->eCurType == CURTYPE_BTREE);
	rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);
	if (rc) return rc;
	if (res != 0) return SQLITE_CORRUPT_BKPT;
#ifdef SQLITE_TEST
	sqlite3_search_count++;
#endif
	p->deferredMoveto = 0;
	p->cacheStatus = CACHE_STALE;
	return SQLITE_OK;
}


static int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p) {
	int isDifferentRow, rc;
	assert(p->eCurType == CURTYPE_BTREE);
	assert(p->uc.pCursor != 0);
	assert(sqlite3BtreeCursorHasMoved(p->uc.pCursor));
	rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);
	p->cacheStatus = CACHE_STALE;
	if (isDifferentRow) p->nullRow = 1;
	return rc;
}


SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor *p) {
	assert(p->eCurType == CURTYPE_BTREE);
	if (sqlite3BtreeCursorHasMoved(p->uc.pCursor)) {
		return handleMovedCursor(p);
	}
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol) {
	VdbeCursor *p = *pp;
	if (p->eCurType == CURTYPE_BTREE) {
		if (p->deferredMoveto) {
			int iMap;
			if (p->aAltMap && (iMap = p->aAltMap[1 + *piCol])>0) {
				*pp = p->pAltCursor;
				*piCol = iMap - 1;
				return SQLITE_OK;
			}
			return handleDeferredMoveto(p);
		}
		if (sqlite3BtreeCursorHasMoved(p->uc.pCursor)) {
			return handleMovedCursor(p);
		}
	}
	return SQLITE_OK;
}




SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen) {
	int flags = pMem->flags;
	u32 n;

	assert(pLen != 0);
	if (flags&MEM_Null) {
		*pLen = 0;
		return 0;
	}
	if (flags&MEM_Int) {
		
#   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)
		i64 i = pMem->u.i;
		u64 u;
		if (i<0) {
			u = ~i;
		}
		else {
			u = i;
		}
		if (u <= 127) {
			if ((i & 1) == i && file_format >= 4) {
				*pLen = 0;
				return 8 + (u32)u;
			}
			else {
				*pLen = 1;
				return 1;
			}
		}
		if (u <= 32767) { *pLen = 2; return 2; }
		if (u <= 8388607) { *pLen = 3; return 3; }
		if (u <= 2147483647) { *pLen = 4; return 4; }
		if (u <= MAX_6BYTE) { *pLen = 6; return 5; }
		*pLen = 8;
		return 6;
	}
	if (flags&MEM_Real) {
		*pLen = 8;
		return 7;
	}
	assert(pMem->db->mallocFailed || flags&(MEM_Str | MEM_Blob));
	assert(pMem->n >= 0);
	n = (u32)pMem->n;
	if (flags & MEM_Zero) {
		n += pMem->u.nZero;
	}
	*pLen = n;
	return ((n * 2) + 12 + ((flags&MEM_Str) != 0));
}


static const u8 sqlite3SmallTypeSizes[] = {
	
	   0,  1,  2,  3,  4,  6,  8,  8,  0,  0,
	   0,  0,  0,  0,  1,  1,  2,  2,  3,  3,
	   4,  4,  5,  5,  6,  6,  7,  7,  8,  8,
	   9,  9, 10, 10, 11, 11, 12, 12, 13, 13,
	  14, 14, 15, 15, 16, 16, 17, 17, 18, 18,
	  19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
	  24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
	  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
	  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
	  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
	  44, 44, 45, 45, 46, 46, 47, 47, 48, 48,
	  49, 49, 50, 50, 51, 51, 52, 52, 53, 53,
	  54, 54, 55, 55, 56, 56, 57, 57
};


SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32 serial_type) {
	if (serial_type >= 128) {
		return (serial_type - 12) / 2;
	}
	else {
		assert(serial_type<12
			|| sqlite3SmallTypeSizes[serial_type] == (serial_type - 12) / 2);
		return sqlite3SmallTypeSizes[serial_type];
	}
}
SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type) {
	assert(serial_type<128);
	return sqlite3SmallTypeSizes[serial_type];
}


#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
static u64 floatSwap(u64 in) {
	union {
		u64 r;
		u32 i[2];
	} u;
	u32 t;

	u.r = in;
	t = u.i[0];
	u.i[0] = u.i[1];
	u.i[1] = t;
	return u.r;
}
# define swapMixedEndianFloat(X)  X = floatSwap(X)
#else
# define swapMixedEndianFloat(X)
#endif


SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type) {
	u32 len;

	
	if (serial_type <= 7 && serial_type>0) {
		u64 v;
		u32 i;
		if (serial_type == 7) {
			assert(sizeof(v) == sizeof(pMem->u.r));
			memcpy(&v, &pMem->u.r, sizeof(v));
			swapMixedEndianFloat(v);
		}
		else {
			v = pMem->u.i;
		}
		len = i = sqlite3SmallTypeSizes[serial_type];
		assert(i>0);
		do {
			buf[--i] = (u8)(v & 0xFF);
			v >>= 8;
		} while (i);
		return len;
	}

	
	if (serial_type >= 12) {
		assert(pMem->n + ((pMem->flags & MEM_Zero) ? pMem->u.nZero : 0)
			== (int)sqlite3VdbeSerialTypeLen(serial_type));
		len = pMem->n;
		if (len>0) memcpy(buf, pMem->z, len);
		return len;
	}

	
	return 0;
}


#define ONE_BYTE_INT(x)    ((i8)(x)[0])
#define TWO_BYTE_INT(x)    (256*(i8)((x)[0])|(x)[1])
#define THREE_BYTE_INT(x)  (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])
#define FOUR_BYTE_UINT(x)  (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])


static u32 SQLITE_NOINLINE serialGet(
	const unsigned char *buf,     
	u32 serial_type,              
	Mem *pMem                     
) {
	u64 x = FOUR_BYTE_UINT(buf);
	u32 y = FOUR_BYTE_UINT(buf + 4);
	x = (x << 32) + y;
	if (serial_type == 6) {
		
		pMem->u.i = *(i64*)&x;
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
	}
	else {
		
#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)
		
		static const u64 t1 = ((u64)0x3ff00000) << 32;
		static const double r1 = 1.0;
		u64 t2 = t1;
		swapMixedEndianFloat(t2);
		assert(sizeof(r1) == sizeof(t2) && memcmp(&r1, &t2, sizeof(r1)) == 0);
#endif
		assert(sizeof(x) == 8 && sizeof(pMem->u.r) == 8);
		swapMixedEndianFloat(x);
		memcpy(&pMem->u.r, &x, sizeof(x));
		pMem->flags = sqlite3IsNaN(pMem->u.r) ? MEM_Null : MEM_Real;
	}
	return 8;
}
SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(
	const unsigned char *buf,     
	u32 serial_type,              
	Mem *pMem                     
) {
	switch (serial_type) {
	case 10:   
	case 11:   
	case 0: {  
			   
		pMem->flags = MEM_Null;
		break;
	}
	case 1: {
		
		pMem->u.i = ONE_BYTE_INT(buf);
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
		return 1;
	}
	case 2: { 
			  
		pMem->u.i = TWO_BYTE_INT(buf);
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
		return 2;
	}
	case 3: { 
			  
		pMem->u.i = THREE_BYTE_INT(buf);
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
		return 3;
	}
	case 4: { 
			  
		pMem->u.i = FOUR_BYTE_INT(buf);
#ifdef __HP_cc 
		
		if (buf[0] & 0x80) pMem->u.i |= 0xffffffff80000000LL;
#endif
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
		return 4;
	}
	case 5: { 
			  
		pMem->u.i = FOUR_BYTE_UINT(buf + 2) + (((i64)1) << 32)*TWO_BYTE_INT(buf);
		pMem->flags = MEM_Int;
		testcase(pMem->u.i<0);
		return 6;
	}
	case 6:   
	case 7: { 
			  
		return serialGet(buf, serial_type, pMem);
	}
	case 8:    
	case 9: {  
			   
			   
		pMem->u.i = serial_type - 8;
		pMem->flags = MEM_Int;
		return 0;
	}
	default: {
		
		static const u16 aFlag[] = { MEM_Blob | MEM_Ephem, MEM_Str | MEM_Ephem };
		pMem->z = (char *)buf;
		pMem->n = (serial_type - 12) / 2;
		pMem->flags = aFlag[serial_type & 1];
		return pMem->n;
	}
	}
	return 0;
}

SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(
	KeyInfo *pKeyInfo,              
	char *pSpace,                   
	int szSpace,                    
	char **ppFree                   
) {
	UnpackedRecord *p;              
	int nOff;                       
	int nByte;                      

									
	nOff = (8 - (SQLITE_PTR_TO_INT(pSpace) & 7)) & 7;
	nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nField + 1);
	if (nByte>szSpace + nOff) {
		p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
		*ppFree = (char *)p;
		if (!p) return 0;
	}
	else {
		p = (UnpackedRecord*)&pSpace[nOff];
		*ppFree = 0;
	}

	p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];
	assert(pKeyInfo->aSortOrder != 0);
	p->pKeyInfo = pKeyInfo;
	p->nField = pKeyInfo->nField + 1;
	return p;
}


SQLITE_PRIVATE void sqlite3VdbeRecordUnpack(
	KeyInfo *pKeyInfo,     
	int nKey,              
	const void *pKey,      
	UnpackedRecord *p      
) {
	const unsigned char *aKey = (const unsigned char *)pKey;
	int d;
	u32 idx;                        
	u16 u;                          
	u32 szHdr;
	Mem *pMem = p->aMem;

	p->default_rc = 0;
	assert(EIGHT_BYTE_ALIGNMENT(pMem));
	idx = getVarint32(aKey, szHdr);
	d = szHdr;
	u = 0;
	while (idx<szHdr && d <= nKey) {
		u32 serial_type;

		idx += getVarint32(&aKey[idx], serial_type);
		pMem->enc = pKeyInfo->enc;
		pMem->db = pKeyInfo->db;
		
		pMem->szMalloc = 0;
		pMem->z = 0;
		d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);
		pMem++;
		if ((++u) >= p->nField) break;
	}
	assert(u <= pKeyInfo->nField + 1);
	p->nField = u;
}

#if SQLITE_DEBUG

static int vdbeRecordCompareDebug(
	int nKey1, const void *pKey1, 
	const UnpackedRecord *pPKey2, 
	int desiredResult             
) {
	u32 d1;            
	u32 idx1;          
	u32 szHdr1;        
	int i = 0;
	int rc = 0;
	const unsigned char *aKey1 = (const unsigned char *)pKey1;
	KeyInfo *pKeyInfo;
	Mem mem1;

	pKeyInfo = pPKey2->pKeyInfo;
	if (pKeyInfo->db == 0) return 1;
	mem1.enc = pKeyInfo->enc;
	mem1.db = pKeyInfo->db;
	
	VVA_ONLY(mem1.szMalloc = 0; ) 

								  
								  

		idx1 = getVarint32(aKey1, szHdr1);
	if (szHdr1>98307) return SQLITE_CORRUPT;
	d1 = szHdr1;
	assert(pKeyInfo->nField + pKeyInfo->nXField >= pPKey2->nField || CORRUPT_DB);
	assert(pKeyInfo->aSortOrder != 0);
	assert(pKeyInfo->nField>0);
	assert(idx1 <= szHdr1 || CORRUPT_DB);
	do {
		u32 serial_type1;

		
		idx1 += getVarint32(aKey1 + idx1, serial_type1);

		
		if (d1 + serial_type1 + 2>(u32)nKey1
			&& d1 + sqlite3VdbeSerialTypeLen(serial_type1)>(u32)nKey1
			) {
			break;
		}

		
		d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);

		
		rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i], pKeyInfo->aColl[i]);
		if (rc != 0) {
			assert(mem1.szMalloc == 0);  
			if (pKeyInfo->aSortOrder[i]) {
				rc = -rc;  
			}
			goto debugCompareEnd;
		}
		i++;
	} while (idx1<szHdr1 && i<pPKey2->nField);

	
	assert(mem1.szMalloc == 0);

	
	rc = pPKey2->default_rc;

debugCompareEnd:
	if (desiredResult == 0 && rc == 0) return 1;
	if (desiredResult<0 && rc<0) return 1;
	if (desiredResult>0 && rc>0) return 1;
	if (CORRUPT_DB) return 1;
	if (pKeyInfo->db->mallocFailed) return 1;
	return 0;
}
#endif

#if SQLITE_DEBUG

static void vdbeAssertFieldCountWithinLimits(
	int nKey, const void *pKey,   
	const KeyInfo *pKeyInfo       
) {
	int nField = 0;
	u32 szHdr;
	u32 idx;
	u32 notUsed;
	const unsigned char *aKey = (const unsigned char*)pKey;

	if (CORRUPT_DB) return;
	idx = getVarint32(aKey, szHdr);
	assert(nKey >= 0);
	assert(szHdr <= (u32)nKey);
	while (idx<szHdr) {
		idx += getVarint32(aKey + idx, notUsed);
		nField++;
	}
	assert(nField <= pKeyInfo->nField + pKeyInfo->nXField);
}
#else
# define vdbeAssertFieldCountWithinLimits(A,B,C)
#endif


static int vdbeCompareMemString(
	const Mem *pMem1,
	const Mem *pMem2,
	const CollSeq *pColl,
	u8 *prcErr                      
) {
	if (pMem1->enc == pColl->enc) {
		
		return pColl->xCmp(pColl->pUser, pMem1->n, pMem1->z, pMem2->n, pMem2->z);
	}
	else {
		int rc;
		const void *v1, *v2;
		int n1, n2;
		Mem c1;
		Mem c2;
		sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);
		sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);
		sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);
		sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);
		v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
		n1 = v1 == 0 ? 0 : c1.n;
		v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
		n2 = v2 == 0 ? 0 : c2.n;
		rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);
		if ((v1 == 0 || v2 == 0) && prcErr) *prcErr = SQLITE_NOMEM_BKPT;
		sqlite3VdbeMemRelease(&c1);
		sqlite3VdbeMemRelease(&c2);
		return rc;
	}
}


static int isAllZero(const char *z, int n) {
	int i;
	for (i = 0; i<n; i++) {
		if (z[i]) return 0;
	}
	return 1;
}


static SQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2) {
	int c;
	int n1 = pB1->n;
	int n2 = pB2->n;

	
	assert((pB1->flags & MEM_Zero) == 0 || n1 == 0);
	assert((pB2->flags & MEM_Zero) == 0 || n2 == 0);

	if ((pB1->flags | pB2->flags) & MEM_Zero) {
		if (pB1->flags & pB2->flags & MEM_Zero) {
			return pB1->u.nZero - pB2->u.nZero;
		}
		else if (pB1->flags & MEM_Zero) {
			if (!isAllZero(pB2->z, pB2->n)) return -1;
			return pB1->u.nZero - n2;
		}
		else {
			if (!isAllZero(pB1->z, pB1->n)) return +1;
			return n1 - pB2->u.nZero;
		}
	}
	c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);
	if (c) return c;
	return n1 - n2;
}


static int sqlite3IntFloatCompare(i64 i, double r) {
	if (sizeof(LONGDOUBLE_TYPE)>8) {
		LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;
		if (x<r) return -1;
		if (x>r) return +1;
		return 0;
	}
	else {
		i64 y;
		double s;
		if (r<-9223372036854775808.0) return +1;
		if (r>9223372036854775807.0) return -1;
		y = (i64)r;
		if (i<y) return -1;
		if (i>y) {
			if (y == SMALLEST_INT64 && r>0.0) return -1;
			return +1;
		}
		s = (double)i;
		if (s<r) return -1;
		if (s>r) return +1;
		return 0;
	}
}


SQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl) {
	int f1, f2;
	int combined_flags;

	f1 = pMem1->flags;
	f2 = pMem2->flags;
	combined_flags = f1 | f2;
	assert((combined_flags & MEM_RowSet) == 0);

	
	if (combined_flags&MEM_Null) {
		return (f2&MEM_Null) - (f1&MEM_Null);
	}

	
	if (combined_flags&(MEM_Int | MEM_Real)) {
		if ((f1 & f2 & MEM_Int) != 0) {
			if (pMem1->u.i < pMem2->u.i) return -1;
			if (pMem1->u.i > pMem2->u.i) return +1;
			return 0;
		}
		if ((f1 & f2 & MEM_Real) != 0) {
			if (pMem1->u.r < pMem2->u.r) return -1;
			if (pMem1->u.r > pMem2->u.r) return +1;
			return 0;
		}
		if ((f1&MEM_Int) != 0) {
			if ((f2&MEM_Real) != 0) {
				return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);
			}
			else {
				return -1;
			}
		}
		if ((f1&MEM_Real) != 0) {
			if ((f2&MEM_Int) != 0) {
				return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);
			}
			else {
				return -1;
			}
		}
		return +1;
	}

	
	if (combined_flags&MEM_Str) {
		if ((f1 & MEM_Str) == 0) {
			return 1;
		}
		if ((f2 & MEM_Str) == 0) {
			return -1;
		}

		assert(pMem1->enc == pMem2->enc || pMem1->db->mallocFailed);
		assert(pMem1->enc == SQLITE_UTF8 ||
			pMem1->enc == SQLITE_UTF16LE || pMem1->enc == SQLITE_UTF16BE);

		
		assert(!pColl || pColl->xCmp);

		if (pColl) {
			return vdbeCompareMemString(pMem1, pMem2, pColl, 0);
		}
		
	}

	
	return sqlite3BlobCompare(pMem1, pMem2);
}



static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey) {
	u32 y;
	assert(CORRUPT_DB || (serial_type >= 1 && serial_type <= 9 && serial_type != 7));
	switch (serial_type) {
	case 0:
	case 1:
		testcase(aKey[0] & 0x80);
		return ONE_BYTE_INT(aKey);
	case 2:
		testcase(aKey[0] & 0x80);
		return TWO_BYTE_INT(aKey);
	case 3:
		testcase(aKey[0] & 0x80);
		return THREE_BYTE_INT(aKey);
	case 4: {
		testcase(aKey[0] & 0x80);
		y = FOUR_BYTE_UINT(aKey);
		return (i64)*(int*)&y;
	}
	case 5: {
		testcase(aKey[0] & 0x80);
		return FOUR_BYTE_UINT(aKey + 2) + (((i64)1) << 32)*TWO_BYTE_INT(aKey);
	}
	case 6: {
		u64 x = FOUR_BYTE_UINT(aKey);
		testcase(aKey[0] & 0x80);
		x = (x << 32) | FOUR_BYTE_UINT(aKey + 4);
		return (i64)*(i64*)&x;
	}
	}

	return (serial_type - 8);
}


SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(
	int nKey1, const void *pKey1,   
	UnpackedRecord *pPKey2,         
	int bSkip                       
) {
	u32 d1;                         
	int i;                          
	u32 szHdr1;                     
	u32 idx1;                       
	int rc = 0;                     
	Mem *pRhs = pPKey2->aMem;       
	KeyInfo *pKeyInfo = pPKey2->pKeyInfo;
	const unsigned char *aKey1 = (const unsigned char *)pKey1;
	Mem mem1;

	
	if (bSkip) {
		u32 s1;
		idx1 = 1 + getVarint32(&aKey1[1], s1);
		szHdr1 = aKey1[0];
		d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);
		i = 1;
		pRhs++;
	}
	else {
		idx1 = getVarint32(aKey1, szHdr1);
		d1 = szHdr1;
		if (d1>(unsigned)nKey1) {
			pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
			return 0;  
		}
		i = 0;
	}

	VVA_ONLY(mem1.szMalloc = 0; ) 
		assert(pPKey2->pKeyInfo->nField + pPKey2->pKeyInfo->nXField >= pPKey2->nField
			|| CORRUPT_DB);
	assert(pPKey2->pKeyInfo->aSortOrder != 0);
	assert(pPKey2->pKeyInfo->nField>0);
	assert(idx1 <= szHdr1 || CORRUPT_DB);
	do {
		u32 serial_type;

		
		if (pRhs->flags & MEM_Int) {
			serial_type = aKey1[idx1];
			testcase(serial_type == 12);
			if (serial_type >= 10) {
				rc = +1;
			}
			else if (serial_type == 0) {
				rc = -1;
			}
			else if (serial_type == 7) {
				sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
				rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);
			}
			else {
				i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);
				i64 rhs = pRhs->u.i;
				if (lhs<rhs) {
					rc = -1;
				}
				else if (lhs>rhs) {
					rc = +1;
				}
			}
		}

		
		else if (pRhs->flags & MEM_Real) {
			serial_type = aKey1[idx1];
			if (serial_type >= 10) {
				
				rc = +1;
			}
			else if (serial_type == 0) {
				rc = -1;
			}
			else {
				sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
				if (serial_type == 7) {
					if (mem1.u.r<pRhs->u.r) {
						rc = -1;
					}
					else if (mem1.u.r>pRhs->u.r) {
						rc = +1;
					}
				}
				else {
					rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);
				}
			}
		}

		
		else if (pRhs->flags & MEM_Str) {
			getVarint32(&aKey1[idx1], serial_type);
			testcase(serial_type == 12);
			if (serial_type<12) {
				rc = -1;
			}
			else if (!(serial_type & 0x01)) {
				rc = +1;
			}
			else {
				mem1.n = (serial_type - 12) / 2;
				testcase((d1 + mem1.n) == (unsigned)nKey1);
				testcase((d1 + mem1.n + 1) == (unsigned)nKey1);
				if ((d1 + mem1.n) >(unsigned)nKey1) {
					pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
					return 0;                
				}
				else if (pKeyInfo->aColl[i]) {
					mem1.enc = pKeyInfo->enc;
					mem1.db = pKeyInfo->db;
					mem1.flags = MEM_Str;
					mem1.z = (char*)&aKey1[d1];
					rc = vdbeCompareMemString(
						&mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode
					);
				}
				else {
					int nCmp = MIN(mem1.n, pRhs->n);
					rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
					if (rc == 0) rc = mem1.n - pRhs->n;
				}
			}
		}

		
		else if (pRhs->flags & MEM_Blob) {
			assert((pRhs->flags & MEM_Zero) == 0 || pRhs->n == 0);
			getVarint32(&aKey1[idx1], serial_type);
			testcase(serial_type == 12);
			if (serial_type<12 || (serial_type & 0x01)) {
				rc = -1;
			}
			else {
				int nStr = (serial_type - 12) / 2;
				testcase((d1 + nStr) == (unsigned)nKey1);
				testcase((d1 + nStr + 1) == (unsigned)nKey1);
				if ((d1 + nStr) >(unsigned)nKey1) {
					pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
					return 0;                
				}
				else if (pRhs->flags & MEM_Zero) {
					if (!isAllZero((const char*)&aKey1[d1], nStr)) {
						rc = 1;
					}
					else {
						rc = nStr - pRhs->u.nZero;
					}
				}
				else {
					int nCmp = MIN(nStr, pRhs->n);
					rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
					if (rc == 0) rc = nStr - pRhs->n;
				}
			}
		}

		
		else {
			serial_type = aKey1[idx1];
			rc = (serial_type != 0);
		}

		if (rc != 0) {
			if (pKeyInfo->aSortOrder[i]) {
				rc = -rc;
			}
			assert(vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc));
			assert(mem1.szMalloc == 0);  
			return rc;
		}

		i++;
		pRhs++;
		d1 += sqlite3VdbeSerialTypeLen(serial_type);
		idx1 += sqlite3VarintLen(serial_type);
	} while (idx1<(unsigned)szHdr1 && i<pPKey2->nField && d1 <= (unsigned)nKey1);

	
	assert(mem1.szMalloc == 0);

	
	assert(CORRUPT_DB
		|| vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, pPKey2->default_rc)
		|| pKeyInfo->db->mallocFailed
	);
	pPKey2->eqSeen = 1;
	return pPKey2->default_rc;
}
SQLITE_PRIVATE int sqlite3VdbeRecordCompare(
	int nKey1, const void *pKey1,   
	UnpackedRecord *pPKey2          
) {
	return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
}



static int vdbeRecordCompareInt(
	int nKey1, const void *pKey1, 
	UnpackedRecord *pPKey2        
) {
	const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];
	int serial_type = ((const u8*)pKey1)[1];
	int res;
	u32 y;
	u64 x;
	i64 v;
	i64 lhs;

	vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
	assert((*(u8*)pKey1) <= 0x3F || CORRUPT_DB);
	switch (serial_type) {
	case 1: { 
		lhs = ONE_BYTE_INT(aKey);
		testcase(lhs<0);
		break;
	}
	case 2: { 
		lhs = TWO_BYTE_INT(aKey);
		testcase(lhs<0);
		break;
	}
	case 3: { 
		lhs = THREE_BYTE_INT(aKey);
		testcase(lhs<0);
		break;
	}
	case 4: { 
		y = FOUR_BYTE_UINT(aKey);
		lhs = (i64)*(int*)&y;
		testcase(lhs<0);
		break;
	}
	case 5: { 
		lhs = FOUR_BYTE_UINT(aKey + 2) + (((i64)1) << 32)*TWO_BYTE_INT(aKey);
		testcase(lhs<0);
		break;
	}
	case 6: { 
		x = FOUR_BYTE_UINT(aKey);
		x = (x << 32) | FOUR_BYTE_UINT(aKey + 4);
		lhs = *(i64*)&x;
		testcase(lhs<0);
		break;
	}
	case 8:
		lhs = 0;
		break;
	case 9:
		lhs = 1;
		break;

		
	case 0: case 7:
		return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);

	default:
		return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
	}

	v = pPKey2->aMem[0].u.i;
	if (v>lhs) {
		res = pPKey2->r1;
	}
	else if (v<lhs) {
		res = pPKey2->r2;
	}
	else if (pPKey2->nField>1) {
		
		res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
	}
	else {
		
		res = pPKey2->default_rc;
		pPKey2->eqSeen = 1;
	}

	assert(vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res));
	return res;
}


static int vdbeRecordCompareString(
	int nKey1, const void *pKey1, 
	UnpackedRecord *pPKey2        
) {
	const u8 *aKey1 = (const u8*)pKey1;
	int serial_type;
	int res;

	assert(pPKey2->aMem[0].flags & MEM_Str);
	vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
	getVarint32(&aKey1[1], serial_type);
	if (serial_type<12) {
		res = pPKey2->r1;      
	}
	else if (!(serial_type & 0x01)) {
		res = pPKey2->r2;      
	}
	else {
		int nCmp;
		int nStr;
		int szHdr = aKey1[0];

		nStr = (serial_type - 12) / 2;
		if ((szHdr + nStr) > nKey1) {
			pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
			return 0;    
		}
		nCmp = MIN(pPKey2->aMem[0].n, nStr);
		res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);

		if (res == 0) {
			res = nStr - pPKey2->aMem[0].n;
			if (res == 0) {
				if (pPKey2->nField>1) {
					res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
				}
				else {
					res = pPKey2->default_rc;
					pPKey2->eqSeen = 1;
				}
			}
			else if (res>0) {
				res = pPKey2->r2;
			}
			else {
				res = pPKey2->r1;
			}
		}
		else if (res>0) {
			res = pPKey2->r2;
		}
		else {
			res = pPKey2->r1;
		}
	}

	assert(vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)
		|| CORRUPT_DB
		|| pPKey2->pKeyInfo->db->mallocFailed
	);
	return res;
}


SQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p) {
	
	if ((p->pKeyInfo->nField + p->pKeyInfo->nXField) <= 13) {
		int flags = p->aMem[0].flags;
		if (p->pKeyInfo->aSortOrder[0]) {
			p->r1 = 1;
			p->r2 = -1;
		}
		else {
			p->r1 = -1;
			p->r2 = 1;
		}
		if ((flags & MEM_Int)) {
			return vdbeRecordCompareInt;
		}
		testcase(flags & MEM_Real);
		testcase(flags & MEM_Null);
		testcase(flags & MEM_Blob);
		if ((flags & (MEM_Real | MEM_Null | MEM_Blob)) == 0 && p->pKeyInfo->aColl[0] == 0) {
			assert(flags & MEM_Str);
			return vdbeRecordCompareString;
		}
	}

	return sqlite3VdbeRecordCompare;
}


SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid) {
	i64 nCellKey = 0;
	int rc;
	u32 szHdr;        
	u32 typeRowid;    
	u32 lenRowid;     
	Mem m, v;

	
	assert(sqlite3BtreeCursorIsValid(pCur));
	nCellKey = sqlite3BtreePayloadSize(pCur);
	assert((nCellKey & SQLITE_MAX_U32) == (u64)nCellKey);

	
	sqlite3VdbeMemInit(&m, db, 0);
	rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, 1, &m);
	if (rc) {
		return rc;
	}

	
	(void)getVarint32((u8*)m.z, szHdr);
	testcase(szHdr == 3);
	testcase(szHdr == m.n);
	if (unlikely(szHdr<3 || (int)szHdr>m.n)) {
		goto idx_rowid_corruption;
	}

	
	(void)getVarint32((u8*)&m.z[szHdr - 1], typeRowid);
	testcase(typeRowid == 1);
	testcase(typeRowid == 2);
	testcase(typeRowid == 3);
	testcase(typeRowid == 4);
	testcase(typeRowid == 5);
	testcase(typeRowid == 6);
	testcase(typeRowid == 8);
	testcase(typeRowid == 9);
	if (unlikely(typeRowid<1 || typeRowid>9 || typeRowid == 7)) {
		goto idx_rowid_corruption;
	}
	lenRowid = sqlite3SmallTypeSizes[typeRowid];
	testcase((u32)m.n == szHdr + lenRowid);
	if (unlikely((u32)m.n<szHdr + lenRowid)) {
		goto idx_rowid_corruption;
	}

	
	sqlite3VdbeSerialGet((u8*)&m.z[m.n - lenRowid], typeRowid, &v);
	*rowid = v.u.i;
	sqlite3VdbeMemRelease(&m);
	return SQLITE_OK;

	
idx_rowid_corruption:
	testcase(m.szMalloc != 0);
	sqlite3VdbeMemRelease(&m);
	return SQLITE_CORRUPT_BKPT;
}


SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(
	sqlite3 *db,                     
	VdbeCursor *pC,                  
	UnpackedRecord *pUnpacked,       
	int *res                         
) {
	i64 nCellKey = 0;
	int rc;
	BtCursor *pCur;
	Mem m;

	assert(pC->eCurType == CURTYPE_BTREE);
	pCur = pC->uc.pCursor;
	assert(sqlite3BtreeCursorIsValid(pCur));
	nCellKey = sqlite3BtreePayloadSize(pCur);
	
	if (nCellKey <= 0 || nCellKey>0x7fffffff) {
		*res = 0;
		return SQLITE_CORRUPT_BKPT;
	}
	sqlite3VdbeMemInit(&m, db, 0);
	rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, 1, &m);
	if (rc) {
		return rc;
	}
	*res = sqlite3VdbeRecordCompare(m.n, m.z, pUnpacked);
	sqlite3VdbeMemRelease(&m);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, int nChange) {
	assert(sqlite3_mutex_held(db->mutex));
	db->nChange = nChange;
	db->nTotalChange += nChange;
}


SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe *v) {
	v->changeCntOn = 1;
}


SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db) {
	Vdbe *p;
	for (p = db->pVdbe; p; p = p->pNext) {
		p->expired = 1;
	}
}


SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe *v) {
	return v->db;
}


SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff) {
	assert(iVar>0);
	if (v) {
		Mem *pMem = &v->aVar[iVar - 1];
		if (0 == (pMem->flags & MEM_Null)) {
			sqlite3_value *pRet = sqlite3ValueNew(v->db);
			if (pRet) {
				sqlite3VdbeMemCopy((Mem *)pRet, pMem);
				sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);
			}
			return pRet;
		}
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe *v, int iVar) {
	assert(iVar>0);
	if (iVar>32) {
		v->expmask = 0xffffffff;
	}
	else {
		v->expmask |= ((u32)1 << (iVar - 1));
	}
}

#ifndef SQLITE_OMIT_VIRTUALTABLE

SQLITE_PRIVATE void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab) {
	if (pVtab->zErrMsg) {
		sqlite3 *db = p->db;
		sqlite3DbFree(db, p->zErrMsg);
		p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
		sqlite3_free(pVtab->zErrMsg);
		pVtab->zErrMsg = 0;
	}
}
#endif 

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK


static void vdbeFreeUnpacked(sqlite3 *db, UnpackedRecord *p) {
	if (p) {
		int i;
		for (i = 0; i<p->nField; i++) {
			Mem *pMem = &p->aMem[i];
			if (pMem->zMalloc) sqlite3VdbeMemRelease(pMem);
		}
		sqlite3DbFree(db, p);
	}
}
#endif 

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(
	Vdbe *v,                        
	VdbeCursor *pCsr,               
	int op,                         
	const char *zDb,                
	Table *pTab,                    
	i64 iKey1,                      
	int iReg                        
) {
	sqlite3 *db = v->db;
	i64 iKey2;
	PreUpdate preupdate;
	const char *zTbl = pTab->zName;
	static const u8 fakeSortOrder = 0;

	assert(db->pPreUpdate == 0);
	memset(&preupdate, 0, sizeof(PreUpdate));
	if (op == SQLITE_UPDATE) {
		iKey2 = v->aMem[iReg].u.i;
	}
	else {
		iKey2 = iKey1;
	}

	assert(pCsr->nField == pTab->nCol
		|| (pCsr->nField == pTab->nCol + 1 && op == SQLITE_DELETE && iReg == -1)
	);

	preupdate.v = v;
	preupdate.pCsr = pCsr;
	preupdate.op = op;
	preupdate.iNewReg = iReg;
	preupdate.keyinfo.db = db;
	preupdate.keyinfo.enc = ENC(db);
	preupdate.keyinfo.nField = pTab->nCol;
	preupdate.keyinfo.aSortOrder = (u8*)&fakeSortOrder;
	preupdate.iKey1 = iKey1;
	preupdate.iKey2 = iKey2;
	preupdate.pTab = pTab;

	db->pPreUpdate = &preupdate;
	db->xPreUpdateCallback(db->pPreUpdateArg, db, op, zDb, zTbl, iKey1, iKey2);
	db->pPreUpdate = 0;
	sqlite3DbFree(db, preupdate.aRecord);
	vdbeFreeUnpacked(db, preupdate.pUnpacked);
	vdbeFreeUnpacked(db, preupdate.pNewUnpacked);
	if (preupdate.aNew) {
		int i;
		for (i = 0; i<pCsr->nField; i++) {
			sqlite3VdbeMemRelease(&preupdate.aNew[i]);
		}
		sqlite3DbFree(db, preupdate.aNew);
	}
}
#endif 







#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt) {
	Vdbe *p = (Vdbe*)pStmt;
	return p == 0 || p->expired;
}
#endif


static int vdbeSafety(Vdbe *p) {
	if (p->db == 0) {
		sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");
		return 1;
	}
	else {
		return 0;
	}
}
static int vdbeSafetyNotNull(Vdbe *p) {
	if (p == 0) {
		sqlite3_log(SQLITE_MISUSE, "API called with NULL prepared statement");
		return 1;
	}
	else {
		return vdbeSafety(p);
	}
}

#ifndef SQLITE_OMIT_TRACE

static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p) {
	sqlite3_int64 iNow;
	sqlite3_int64 iElapse;
	assert(p->startTime>0);
	assert(db->xProfile != 0 || (db->mTrace & SQLITE_TRACE_PROFILE) != 0);
	assert(db->init.busy == 0);
	assert(p->zSql != 0);
	sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
	iElapse = (iNow - p->startTime) * 1000000;
	if (db->xProfile) {
		db->xProfile(db->pProfileArg, p->zSql, iElapse);
	}
	if (db->mTrace & SQLITE_TRACE_PROFILE) {
		db->xTrace(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);
	}
	p->startTime = 0;
}

# define checkProfileCallback(DB,P) \
   if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }
#else
# define checkProfileCallback(DB,P)  
#endif


SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt) {
	int rc;
	if (pStmt == 0) {
		
		rc = SQLITE_OK;
	}
	else {
		Vdbe *v = (Vdbe*)pStmt;
		sqlite3 *db = v->db;
		if (vdbeSafety(v)) return SQLITE_MISUSE_BKPT;
		sqlite3_mutex_enter(db->mutex);
		checkProfileCallback(db, v);
		rc = sqlite3VdbeFinalize(v);
		rc = sqlite3ApiExit(db, rc);
		sqlite3LeaveMutexAndCloseZombie(db);
	}
	return rc;
}


SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt) {
	int rc;
	if (pStmt == 0) {
		rc = SQLITE_OK;
	}
	else {
		Vdbe *v = (Vdbe*)pStmt;
		sqlite3 *db = v->db;
		sqlite3_mutex_enter(db->mutex);
		checkProfileCallback(db, v);
		rc = sqlite3VdbeReset(v);
		sqlite3VdbeRewind(v);
		assert((rc & (db->errMask)) == rc);
		rc = sqlite3ApiExit(db, rc);
		sqlite3_mutex_leave(db->mutex);
	}
	return rc;
}


SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt) {
	int i;
	int rc = SQLITE_OK;
	Vdbe *p = (Vdbe*)pStmt;
#if SQLITE_THREADSAFE
	sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;
#endif
	sqlite3_mutex_enter(mutex);
	for (i = 0; i<p->nVar; i++) {
		sqlite3VdbeMemRelease(&p->aVar[i]);
		p->aVar[i].flags = MEM_Null;
	}
	if (p->isPrepareV2 && p->expmask) {
		p->expired = 1;
	}
	sqlite3_mutex_leave(mutex);
	return rc;
}



SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal) {
	Mem *p = (Mem*)pVal;
	if (p->flags & (MEM_Blob | MEM_Str)) {
		if (ExpandBlob(p) != SQLITE_OK) {
			assert(p->flags == MEM_Null && p->z == 0);
			return 0;
		}
		p->flags |= MEM_Blob;
		return p->n ? p->z : 0;
	}
	else {
		return sqlite3_value_text(pVal);
	}
}
SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal) {
	return sqlite3ValueBytes(pVal, SQLITE_UTF8);
}
SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal) {
	return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);
}
SQLITE_API double sqlite3_value_double(sqlite3_value *pVal) {
	return sqlite3VdbeRealValue((Mem*)pVal);
}
SQLITE_API int sqlite3_value_int(sqlite3_value *pVal) {
	return (int)sqlite3VdbeIntValue((Mem*)pVal);
}
SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal) {
	return sqlite3VdbeIntValue((Mem*)pVal);
}
SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value *pVal) {
	Mem *pMem = (Mem*)pVal;
	return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0);
}
SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal) {
	return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal) {
	return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);
}
SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal) {
	return sqlite3ValueText(pVal, SQLITE_UTF16BE);
}
SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal) {
	return sqlite3ValueText(pVal, SQLITE_UTF16LE);
}
#endif 

SQLITE_API int sqlite3_value_type(sqlite3_value* pVal) {
	static const u8 aType[] = {
		SQLITE_BLOB,     
		SQLITE_NULL,     
		SQLITE_TEXT,     
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_FLOAT,    
		SQLITE_NULL,     
		SQLITE_FLOAT,    
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_BLOB,     
		SQLITE_NULL,     
		SQLITE_TEXT,     
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_FLOAT,    
		SQLITE_NULL,     
		SQLITE_FLOAT,    
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
		SQLITE_INTEGER,  
		SQLITE_NULL,     
	};
	return aType[pVal->flags&MEM_AffMask];
}


SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig) {
	sqlite3_value *pNew;
	if (pOrig == 0) return 0;
	pNew = sqlite3_malloc(sizeof(*pNew));
	if (pNew == 0) return 0;
	memset(pNew, 0, sizeof(*pNew));
	memcpy(pNew, pOrig, MEMCELLSIZE);
	pNew->flags &= ~MEM_Dyn;
	pNew->db = 0;
	if (pNew->flags&(MEM_Str | MEM_Blob)) {
		pNew->flags &= ~(MEM_Static | MEM_Dyn);
		pNew->flags |= MEM_Ephem;
		if (sqlite3VdbeMemMakeWriteable(pNew) != SQLITE_OK) {
			sqlite3ValueFree(pNew);
			pNew = 0;
		}
	}
	return pNew;
}


SQLITE_API void sqlite3_value_free(sqlite3_value *pOld) {
	sqlite3ValueFree(pOld);
}



static void setResultStrOrError(
	sqlite3_context *pCtx,  
	const char *z,          
	int n,                  
	u8 enc,                 
	void(*xDel)(void*)     
) {
	if (sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel) == SQLITE_TOOBIG) {
		sqlite3_result_error_toobig(pCtx);
	}
}
static int invokeValueDestructor(
	const void *p,             
	void(*xDel)(void*),       
	sqlite3_context *pCtx      
) {
	assert(xDel != SQLITE_DYNAMIC);
	if (xDel == 0) {
		
	}
	else if (xDel == SQLITE_TRANSIENT) {
		
	}
	else {
		xDel((void*)p);
	}
	if (pCtx) sqlite3_result_error_toobig(pCtx);
	return SQLITE_TOOBIG;
}
SQLITE_API void sqlite3_result_blob(
	sqlite3_context *pCtx,
	const void *z,
	int n,
	void(*xDel)(void *)
) {
	assert(n >= 0);
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	setResultStrOrError(pCtx, z, n, 0, xDel);
}
SQLITE_API void sqlite3_result_blob64(
	sqlite3_context *pCtx,
	const void *z,
	sqlite3_uint64 n,
	void(*xDel)(void *)
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	assert(xDel != SQLITE_DYNAMIC);
	if (n>0x7fffffff) {
		(void)invokeValueDestructor(z, xDel, pCtx);
	}
	else {
		setResultStrOrError(pCtx, z, (int)n, 0, xDel);
	}
}
SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
}
SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	pCtx->isError = SQLITE_ERROR;
	pCtx->fErrorOrAux = 1;
	sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	pCtx->isError = SQLITE_ERROR;
	pCtx->fErrorOrAux = 1;
	sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);
}
#endif
SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);
}
SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
}
SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetNull(pCtx->pOut);
}
SQLITE_API void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype) {
	Mem *pOut = pCtx->pOut;
	assert(sqlite3_mutex_held(pOut->db->mutex));
	pOut->eSubtype = eSubtype & 0xff;
	pOut->flags |= MEM_Subtype;
}
SQLITE_API void sqlite3_result_text(
	sqlite3_context *pCtx,
	const char *z,
	int n,
	void(*xDel)(void *)
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);
}
SQLITE_API void sqlite3_result_text64(
	sqlite3_context *pCtx,
	const char *z,
	sqlite3_uint64 n,
	void(*xDel)(void *),
	unsigned char enc
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	assert(xDel != SQLITE_DYNAMIC);
	if (enc == SQLITE_UTF16) enc = SQLITE_UTF16NATIVE;
	if (n>0x7fffffff) {
		(void)invokeValueDestructor(z, xDel, pCtx);
	}
	else {
		setResultStrOrError(pCtx, z, (int)n, enc, xDel);
	}
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API void sqlite3_result_text16(
	sqlite3_context *pCtx,
	const void *z,
	int n,
	void(*xDel)(void *)
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel);
}
SQLITE_API void sqlite3_result_text16be(
	sqlite3_context *pCtx,
	const void *z,
	int n,
	void(*xDel)(void *)
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel);
}
SQLITE_API void sqlite3_result_text16le(
	sqlite3_context *pCtx,
	const void *z,
	int n,
	void(*xDel)(void *)
) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel);
}
#endif 
SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemCopy(pCtx->pOut, pValue);
}
SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
}
SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n) {
	Mem *pOut = pCtx->pOut;
	assert(sqlite3_mutex_held(pOut->db->mutex));
	if (n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH]) {
		return SQLITE_TOOBIG;
	}
	sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
	return SQLITE_OK;
}
SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode) {
	pCtx->isError = errCode;
	pCtx->fErrorOrAux = 1;
#ifdef SQLITE_DEBUG
	if (pCtx->pVdbe) pCtx->pVdbe->rcApp = errCode;
#endif
	if (pCtx->pOut->flags & MEM_Null) {
		sqlite3VdbeMemSetStr(pCtx->pOut, sqlite3ErrStr(errCode), -1,
			SQLITE_UTF8, SQLITE_STATIC);
	}
}


SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	pCtx->isError = SQLITE_TOOBIG;
	pCtx->fErrorOrAux = 1;
	sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1,
		SQLITE_UTF8, SQLITE_STATIC);
}


SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx) {
	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	sqlite3VdbeMemSetNull(pCtx->pOut);
	pCtx->isError = SQLITE_NOMEM_BKPT;
	pCtx->fErrorOrAux = 1;
	sqlite3OomFault(pCtx->pOut->db);
}


static int doWalCallbacks(sqlite3 *db) {
	int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_WAL
	int i;
	for (i = 0; i<db->nDb; i++) {
		Btree *pBt = db->aDb[i].pBt;
		if (pBt) {
			int nEntry;
			sqlite3BtreeEnter(pBt);
			nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
			sqlite3BtreeLeave(pBt);
			if (db->xWalCallback && nEntry>0 && rc == SQLITE_OK) {
				rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);
			}
		}
	}
#endif
	return rc;
}



static int sqlite3Step(Vdbe *p) {
	sqlite3 *db;
	int rc;

	assert(p);
	if (p->magic != VDBE_MAGIC_RUN) {
		
#ifdef SQLITE_OMIT_AUTORESET
		if ((rc = p->rc & 0xff) == SQLITE_BUSY || rc == SQLITE_LOCKED) {
			sqlite3_reset((sqlite3_stmt*)p);
		}
		else {
			return SQLITE_MISUSE_BKPT;
		}
#else
		sqlite3_reset((sqlite3_stmt*)p);
#endif
	}

	
	db = p->db;
	if (db->mallocFailed) {
		p->rc = SQLITE_NOMEM;
		return SQLITE_NOMEM_BKPT;
	}

	if (p->pc <= 0 && p->expired) {
		p->rc = SQLITE_SCHEMA;
		rc = SQLITE_ERROR;
		goto end_of_step;
	}
	if (p->pc<0) {
		
		if (db->nVdbeActive == 0) {
			db->u1.isInterrupted = 0;
		}

		assert(db->nVdbeWrite>0 || db->autoCommit == 0
			|| (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)
		);

#ifndef SQLITE_OMIT_TRACE
		if ((db->xProfile || (db->mTrace & SQLITE_TRACE_PROFILE) != 0)
			&& !db->init.busy && p->zSql) {
			sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);
		}
		else {
			assert(p->startTime == 0);
		}
#endif

		db->nVdbeActive++;
		if (p->readOnly == 0) db->nVdbeWrite++;
		if (p->bIsReader) db->nVdbeRead++;
		p->pc = 0;
	}
#ifdef SQLITE_DEBUG
	p->rcApp = SQLITE_OK;
#endif
#ifndef SQLITE_OMIT_EXPLAIN
	if (p->explain) {
		rc = sqlite3VdbeList(p);
	}
	else
#endif 
	{
		db->nVdbeExec++;
		rc = sqlite3VdbeExec(p);
		db->nVdbeExec--;
	}

#ifndef SQLITE_OMIT_TRACE
	
	if (rc != SQLITE_ROW) checkProfileCallback(db, p);
#endif

	if (rc == SQLITE_DONE) {
		assert(p->rc == SQLITE_OK);
		p->rc = doWalCallbacks(db);
		if (p->rc != SQLITE_OK) {
			rc = SQLITE_ERROR;
		}
	}

	db->errCode = rc;
	if (SQLITE_NOMEM == sqlite3ApiExit(p->db, p->rc)) {
		p->rc = SQLITE_NOMEM_BKPT;
	}
end_of_step:
	
	assert(rc == SQLITE_ROW || rc == SQLITE_DONE || rc == SQLITE_ERROR
		|| (rc & 0xff) == SQLITE_BUSY || rc == SQLITE_MISUSE
	);
	assert((p->rc != SQLITE_ROW && p->rc != SQLITE_DONE) || p->rc == p->rcApp);
	if (p->isPrepareV2 && rc != SQLITE_ROW && rc != SQLITE_DONE) {
		
		rc = sqlite3VdbeTransferError(p);
	}
	return (rc&db->errMask);
}


SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt) {
	int rc = SQLITE_OK;      
	int rc2 = SQLITE_OK;     
	Vdbe *v = (Vdbe*)pStmt;  
	int cnt = 0;             
	sqlite3 *db;             

	if (vdbeSafetyNotNull(v)) {
		return SQLITE_MISUSE_BKPT;
	}
	db = v->db;
	sqlite3_mutex_enter(db->mutex);
	v->doingRerun = 0;
	while ((rc = sqlite3Step(v)) == SQLITE_SCHEMA
		&& cnt++ < SQLITE_MAX_SCHEMA_RETRY) {
		int savedPc = v->pc;
		rc2 = rc = sqlite3Reprepare(v);
		if (rc != SQLITE_OK) break;
		sqlite3_reset(pStmt);
		if (savedPc >= 0) v->doingRerun = 1;
		assert(v->expired == 0);
	}
	if (rc2 != SQLITE_OK) {
		
		const char *zErr = (const char *)sqlite3_value_text(db->pErr);
		sqlite3DbFree(db, v->zErrMsg);
		if (!db->mallocFailed) {
			v->zErrMsg = sqlite3DbStrDup(db, zErr);
			v->rc = rc2;
		}
		else {
			v->zErrMsg = 0;
			v->rc = rc = SQLITE_NOMEM_BKPT;
		}
	}
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}



SQLITE_API void *sqlite3_user_data(sqlite3_context *p) {
	assert(p && p->pFunc);
	return p->pFunc->pUserData;
}


SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p) {
	assert(p && p->pOut);
	return p->pOut->db;
}


SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p) {
	int rc;
#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
	sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
	assert(p->pVdbe != 0);
#else
	sqlite3_int64 iTime = 0;
	sqlite3_int64 *piTime = p->pVdbe != 0 ? &p->pVdbe->iCurrentTime : &iTime;
#endif
	if (*piTime == 0) {
		rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);
		if (rc) *piTime = 0;
	}
	return *piTime;
}


SQLITE_PRIVATE void sqlite3InvalidFunction(
	sqlite3_context *context,  
	int NotUsed,               
	sqlite3_value **NotUsed2   
) {
	const char *zName = context->pFunc->zName;
	char *zErr;
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	zErr = sqlite3_mprintf(
		"unable to use function %s in the requested context", zName);
	sqlite3_result_error(context, zErr, -1);
	sqlite3_free(zErr);
}


static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte) {
	Mem *pMem = p->pMem;
	assert((pMem->flags & MEM_Agg) == 0);
	if (nByte <= 0) {
		sqlite3VdbeMemSetNull(pMem);
		pMem->z = 0;
	}
	else {
		sqlite3VdbeMemClearAndResize(pMem, nByte);
		pMem->flags = MEM_Agg;
		pMem->u.pDef = p->pFunc;
		if (pMem->z) {
			memset(pMem->z, 0, nByte);
		}
	}
	return (void*)pMem->z;
}


SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte) {
	assert(p && p->pFunc && p->pFunc->xFinalize);
	assert(sqlite3_mutex_held(p->pOut->db->mutex));
	testcase(nByte<0);
	if ((p->pMem->flags & MEM_Agg) == 0) {
		return createAggContext(p, nByte);
	}
	else {
		return (void*)p->pMem->z;
	}
}


SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg) {
	AuxData *pAuxData;

	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
#if SQLITE_ENABLE_STAT3_OR_STAT4
	if (pCtx->pVdbe == 0) return 0;
#else
	assert(pCtx->pVdbe != 0);
#endif
	for (pAuxData = pCtx->pVdbe->pAuxData; pAuxData; pAuxData = pAuxData->pNext) {
		if (pAuxData->iOp == pCtx->iOp && pAuxData->iArg == iArg) break;
	}

	return (pAuxData ? pAuxData->pAux : 0);
}


SQLITE_API void sqlite3_set_auxdata(
	sqlite3_context *pCtx,
	int iArg,
	void *pAux,
	void(*xDelete)(void*)
) {
	AuxData *pAuxData;
	Vdbe *pVdbe = pCtx->pVdbe;

	assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));
	if (iArg<0) goto failed;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (pVdbe == 0) goto failed;
#else
	assert(pVdbe != 0);
#endif

	for (pAuxData = pVdbe->pAuxData; pAuxData; pAuxData = pAuxData->pNext) {
		if (pAuxData->iOp == pCtx->iOp && pAuxData->iArg == iArg) break;
	}
	if (pAuxData == 0) {
		pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));
		if (!pAuxData) goto failed;
		pAuxData->iOp = pCtx->iOp;
		pAuxData->iArg = iArg;
		pAuxData->pNext = pVdbe->pAuxData;
		pVdbe->pAuxData = pAuxData;
		if (pCtx->fErrorOrAux == 0) {
			pCtx->isError = 0;
			pCtx->fErrorOrAux = 1;
		}
	}
	else if (pAuxData->xDelete) {
		pAuxData->xDelete(pAuxData->pAux);
	}

	pAuxData->pAux = pAux;
	pAuxData->xDelete = xDelete;
	return;

failed:
	if (xDelete) {
		xDelete(pAux);
	}
}

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p) {
	assert(p && p->pMem && p->pFunc && p->pFunc->xFinalize);
	return p->pMem->n;
}
#endif


SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt) {
	Vdbe *pVm = (Vdbe *)pStmt;
	return pVm ? pVm->nResColumn : 0;
}


SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt) {
	Vdbe *pVm = (Vdbe *)pStmt;
	if (pVm == 0 || pVm->pResultSet == 0) return 0;
	return pVm->nResColumn;
}


static const Mem *columnNullValue(void) {
	
	static const Mem nullMem
#if defined(SQLITE_DEBUG) && defined(__GNUC__)
		__attribute__((aligned(8)))
#endif
		= {
		{ 0 },
		 (u16)MEM_Null,
		 (u8)0,
		 (u8)0,
		 (int)0,
		 (char*)0,
		 (char*)0,
		 (int)0,
		 (u32)0,
		 (sqlite3*)0,
		 (void(*)(void*))0,
#ifdef SQLITE_DEBUG
		(Mem*)0,
		 (void*)0,
#endif
	};
	return &nullMem;
}


static Mem *columnMem(sqlite3_stmt *pStmt, int i) {
	Vdbe *pVm;
	Mem *pOut;

	pVm = (Vdbe *)pStmt;
	if (pVm == 0) return (Mem*)columnNullValue();
	assert(pVm->db);
	sqlite3_mutex_enter(pVm->db->mutex);
	if (pVm->pResultSet != 0 && i<pVm->nResColumn && i >= 0) {
		pOut = &pVm->pResultSet[i];
	}
	else {
		sqlite3Error(pVm->db, SQLITE_RANGE);
		pOut = (Mem*)columnNullValue();
	}
	return pOut;
}


static void columnMallocFailure(sqlite3_stmt *pStmt)
{
	
	Vdbe *p = (Vdbe *)pStmt;
	if (p) {
		assert(p->db != 0);
		assert(sqlite3_mutex_held(p->db->mutex));
		p->rc = sqlite3ApiExit(p->db, p->rc);
		sqlite3_mutex_leave(p->db->mutex);
	}
}


SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i) {
	const void *val;
	val = sqlite3_value_blob(columnMem(pStmt, i));
	
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i) {
	int val = sqlite3_value_bytes(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i) {
	int val = sqlite3_value_bytes16(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i) {
	double val = sqlite3_value_double(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i) {
	int val = sqlite3_value_int(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i) {
	sqlite_int64 val = sqlite3_value_int64(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i) {
	const unsigned char *val = sqlite3_value_text(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i) {
	Mem *pOut = columnMem(pStmt, i);
	if (pOut->flags&MEM_Static) {
		pOut->flags &= ~MEM_Static;
		pOut->flags |= MEM_Ephem;
	}
	columnMallocFailure(pStmt);
	return (sqlite3_value *)pOut;
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i) {
	const void *val = sqlite3_value_text16(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return val;
}
#endif 
SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i) {
	int iType = sqlite3_value_type(columnMem(pStmt, i));
	columnMallocFailure(pStmt);
	return iType;
}


static const void *columnName(
	sqlite3_stmt *pStmt,
	int N,
	const void *(*xFunc)(Mem*),
	int useType
) {
	const void *ret;
	Vdbe *p;
	int n;
	sqlite3 *db;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (pStmt == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	ret = 0;
	p = (Vdbe *)pStmt;
	db = p->db;
	assert(db != 0);
	n = sqlite3_column_count(pStmt);
	if (N<n && N >= 0) {
		N += useType*n;
		sqlite3_mutex_enter(db->mutex);
		assert(db->mallocFailed == 0);
		ret = xFunc(&p->aColName[N]);
		
		if (db->mallocFailed) {
			sqlite3OomClear(db);
			ret = 0;
		}
		sqlite3_mutex_leave(db->mutex);
	}
	return ret;
}


SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_NAME);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_NAME);
}
#endif


#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA)
# error "Must not define both SQLITE_OMIT_DECLTYPE \
         and SQLITE_ENABLE_COLUMN_METADATA"
#endif

#ifndef SQLITE_OMIT_DECLTYPE

SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);
}
#endif 
#endif 

#ifdef SQLITE_ENABLE_COLUMN_METADATA

SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);
}
#endif 


SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);
}
#endif 


SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN);
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N) {
	return columnName(
		pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);
}
#endif 
#endif 




static int vdbeUnbind(Vdbe *p, int i) {
	Mem *pVar;
	if (vdbeSafetyNotNull(p)) {
		return SQLITE_MISUSE_BKPT;
	}
	sqlite3_mutex_enter(p->db->mutex);
	if (p->magic != VDBE_MAGIC_RUN || p->pc >= 0) {
		sqlite3Error(p->db, SQLITE_MISUSE);
		sqlite3_mutex_leave(p->db->mutex);
		sqlite3_log(SQLITE_MISUSE,
			"bind on a busy prepared statement: [%s]", p->zSql);
		return SQLITE_MISUSE_BKPT;
	}
	if (i<1 || i>p->nVar) {
		sqlite3Error(p->db, SQLITE_RANGE);
		sqlite3_mutex_leave(p->db->mutex);
		return SQLITE_RANGE;
	}
	i--;
	pVar = &p->aVar[i];
	sqlite3VdbeMemRelease(pVar);
	pVar->flags = MEM_Null;
	sqlite3Error(p->db, SQLITE_OK);

	
	if (p->isPrepareV2 &&
		((i<32 && p->expmask & ((u32)1 << i)) || p->expmask == 0xffffffff)
		) {
		p->expired = 1;
	}
	return SQLITE_OK;
}


static int bindText(
	sqlite3_stmt *pStmt,   
	int i,                 
	const void *zData,     
	int nData,             
	void(*xDel)(void*),   
	u8 encoding            
) {
	Vdbe *p = (Vdbe *)pStmt;
	Mem *pVar;
	int rc;

	rc = vdbeUnbind(p, i);
	if (rc == SQLITE_OK) {
		if (zData != 0) {
			pVar = &p->aVar[i - 1];
			rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
			if (rc == SQLITE_OK && encoding != 0) {
				rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));
			}
			sqlite3Error(p->db, rc);
			rc = sqlite3ApiExit(p->db, rc);
		}
		sqlite3_mutex_leave(p->db->mutex);
	}
	else if (xDel != SQLITE_STATIC && xDel != SQLITE_TRANSIENT) {
		xDel((void*)zData);
	}
	return rc;
}



SQLITE_API int sqlite3_bind_blob(
	sqlite3_stmt *pStmt,
	int i,
	const void *zData,
	int nData,
	void(*xDel)(void*)
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (nData<0) return SQLITE_MISUSE_BKPT;
#endif
	return bindText(pStmt, i, zData, nData, xDel, 0);
}
SQLITE_API int sqlite3_bind_blob64(
	sqlite3_stmt *pStmt,
	int i,
	const void *zData,
	sqlite3_uint64 nData,
	void(*xDel)(void*)
) {
	assert(xDel != SQLITE_DYNAMIC);
	if (nData>0x7fffffff) {
		return invokeValueDestructor(zData, xDel, 0);
	}
	else {
		return bindText(pStmt, i, zData, (int)nData, xDel, 0);
	}
}
SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue) {
	int rc;
	Vdbe *p = (Vdbe *)pStmt;
	rc = vdbeUnbind(p, i);
	if (rc == SQLITE_OK) {
		sqlite3VdbeMemSetDouble(&p->aVar[i - 1], rValue);
		sqlite3_mutex_leave(p->db->mutex);
	}
	return rc;
}
SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue) {
	return sqlite3_bind_int64(p, i, (i64)iValue);
}
SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue) {
	int rc;
	Vdbe *p = (Vdbe *)pStmt;
	rc = vdbeUnbind(p, i);
	if (rc == SQLITE_OK) {
		sqlite3VdbeMemSetInt64(&p->aVar[i - 1], iValue);
		sqlite3_mutex_leave(p->db->mutex);
	}
	return rc;
}
SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i) {
	int rc;
	Vdbe *p = (Vdbe*)pStmt;
	rc = vdbeUnbind(p, i);
	if (rc == SQLITE_OK) {
		sqlite3_mutex_leave(p->db->mutex);
	}
	return rc;
}
SQLITE_API int sqlite3_bind_text(
	sqlite3_stmt *pStmt,
	int i,
	const char *zData,
	int nData,
	void(*xDel)(void*)
) {
	return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}
SQLITE_API int sqlite3_bind_text64(
	sqlite3_stmt *pStmt,
	int i,
	const char *zData,
	sqlite3_uint64 nData,
	void(*xDel)(void*),
	unsigned char enc
) {
	assert(xDel != SQLITE_DYNAMIC);
	if (nData>0x7fffffff) {
		return invokeValueDestructor(zData, xDel, 0);
	}
	else {
		if (enc == SQLITE_UTF16) enc = SQLITE_UTF16NATIVE;
		return bindText(pStmt, i, zData, (int)nData, xDel, enc);
	}
}
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_bind_text16(
	sqlite3_stmt *pStmt,
	int i,
	const void *zData,
	int nData,
	void(*xDel)(void*)
) {
	return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);
}
#endif 
SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue) {
	int rc;
	switch (sqlite3_value_type((sqlite3_value*)pValue)) {
	case SQLITE_INTEGER: {
		rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
		break;
	}
	case SQLITE_FLOAT: {
		rc = sqlite3_bind_double(pStmt, i, pValue->u.r);
		break;
	}
	case SQLITE_BLOB: {
		if (pValue->flags & MEM_Zero) {
			rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);
		}
		else {
			rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n, SQLITE_TRANSIENT);
		}
		break;
	}
	case SQLITE_TEXT: {
		rc = bindText(pStmt, i, pValue->z, pValue->n, SQLITE_TRANSIENT,
			pValue->enc);
		break;
	}
	default: {
		rc = sqlite3_bind_null(pStmt, i);
		break;
	}
	}
	return rc;
}
SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n) {
	int rc;
	Vdbe *p = (Vdbe *)pStmt;
	rc = vdbeUnbind(p, i);
	if (rc == SQLITE_OK) {
		sqlite3VdbeMemSetZeroBlob(&p->aVar[i - 1], n);
		sqlite3_mutex_leave(p->db->mutex);
	}
	return rc;
}
SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n) {
	int rc;
	Vdbe *p = (Vdbe *)pStmt;
	sqlite3_mutex_enter(p->db->mutex);
	if (n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH]) {
		rc = SQLITE_TOOBIG;
	}
	else {
		assert((n & 0x7FFFFFFF) == n);
		rc = sqlite3_bind_zeroblob(pStmt, i, n);
	}
	rc = sqlite3ApiExit(p->db, rc);
	sqlite3_mutex_leave(p->db->mutex);
	return rc;
}


SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt) {
	Vdbe *p = (Vdbe*)pStmt;
	return p ? p->nVar : 0;
}


SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i) {
	Vdbe *p = (Vdbe*)pStmt;
	if (p == 0 || i<1 || i>p->nzVar) {
		return 0;
	}
	return p->azVar[i - 1];
}


SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName) {
	int i;
	if (p == 0) {
		return 0;
	}
	if (zName) {
		for (i = 0; i<p->nzVar; i++) {
			const char *z = p->azVar[i];
			if (z && strncmp(z, zName, nName) == 0 && z[nName] == 0) {
				return i + 1;
			}
		}
	}
	return 0;
}
SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName) {
	return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}


SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt) {
	Vdbe *pFrom = (Vdbe*)pFromStmt;
	Vdbe *pTo = (Vdbe*)pToStmt;
	int i;
	assert(pTo->db == pFrom->db);
	assert(pTo->nVar == pFrom->nVar);
	sqlite3_mutex_enter(pTo->db->mutex);
	for (i = 0; i<pFrom->nVar; i++) {
		sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);
	}
	sqlite3_mutex_leave(pTo->db->mutex);
	return SQLITE_OK;
}

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt) {
	Vdbe *pFrom = (Vdbe*)pFromStmt;
	Vdbe *pTo = (Vdbe*)pToStmt;
	if (pFrom->nVar != pTo->nVar) {
		return SQLITE_ERROR;
	}
	if (pTo->isPrepareV2 && pTo->expmask) {
		pTo->expired = 1;
	}
	if (pFrom->isPrepareV2 && pFrom->expmask) {
		pFrom->expired = 1;
	}
	return sqlite3TransferBindings(pFromStmt, pToStmt);
}
#endif


SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt) {
	return pStmt ? ((Vdbe*)pStmt)->db : 0;
}


SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt) {
	return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
}


SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt) {
	Vdbe *v = (Vdbe*)pStmt;
	return v != 0 && v->magic == VDBE_MAGIC_RUN && v->pc >= 0;
}


SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt) {
	sqlite3_stmt *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(pDb)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(pDb->mutex);
	if (pStmt == 0) {
		pNext = (sqlite3_stmt*)pDb->pVdbe;
	}
	else {
		pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;
	}
	sqlite3_mutex_leave(pDb->mutex);
	return pNext;
}


SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag) {
	Vdbe *pVdbe = (Vdbe*)pStmt;
	u32 v;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!pStmt) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	v = pVdbe->aCounter[op];
	if (resetFlag) pVdbe->aCounter[op] = 0;
	return (int)v;
}


SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt) {
	Vdbe *p = (Vdbe *)pStmt;
	return p ? p->zSql : 0;
}


SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
#ifdef SQLITE_OMIT_TRACE
	return 0;
#else
	char *z = 0;
	const char *zSql = sqlite3_sql(pStmt);
	if (zSql) {
		Vdbe *p = (Vdbe *)pStmt;
		sqlite3_mutex_enter(p->db->mutex);
		z = sqlite3VdbeExpandSql(p, zSql);
		sqlite3_mutex_leave(p->db->mutex);
	}
	return z;
#endif
}

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

static UnpackedRecord *vdbeUnpackRecord(
	KeyInfo *pKeyInfo,
	int nKey,
	const void *pKey
) {
	char *dummy;                    
	UnpackedRecord *pRet;           

	pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo, 0, 0, &dummy);
	if (pRet) {
		memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nField + 1));
		sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, pRet);
	}
	return pRet;
}


SQLITE_API int sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue) {
	PreUpdate *p = db->pPreUpdate;
	int rc = SQLITE_OK;

	
	if (!p || p->op == SQLITE_INSERT) {
		rc = SQLITE_MISUSE_BKPT;
		goto preupdate_old_out;
	}
	if (iIdx >= p->pCsr->nField || iIdx<0) {
		rc = SQLITE_RANGE;
		goto preupdate_old_out;
	}

	
	if (p->pUnpacked == 0) {
		u32 nRec;
		u8 *aRec;

		nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);
		aRec = sqlite3DbMallocRaw(db, nRec);
		if (!aRec) goto preupdate_old_out;
		rc = sqlite3BtreeData(p->pCsr->uc.pCursor, 0, nRec, aRec);
		if (rc == SQLITE_OK) {
			p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);
			if (!p->pUnpacked) rc = SQLITE_NOMEM;
		}
		if (rc != SQLITE_OK) {
			sqlite3DbFree(db, aRec);
			goto preupdate_old_out;
		}
		p->aRecord = aRec;
	}

	if (iIdx >= p->pUnpacked->nField) {
		*ppValue = (sqlite3_value *)columnNullValue();
	}
	else {
		Mem *pMem = *ppValue = &p->pUnpacked->aMem[iIdx];
		*ppValue = &p->pUnpacked->aMem[iIdx];
		if (iIdx == p->pTab->iPKey) {
			sqlite3VdbeMemSetInt64(pMem, p->iKey1);
		}
		else if (p->pTab->aCol[iIdx].affinity == SQLITE_AFF_REAL) {
			if (pMem->flags & MEM_Int) {
				sqlite3VdbeMemRealify(pMem);
			}
		}
	}

preupdate_old_out:
	sqlite3Error(db, rc);
	return sqlite3ApiExit(db, rc);
}
#endif 

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

SQLITE_API int sqlite3_preupdate_count(sqlite3 *db) {
	PreUpdate *p = db->pPreUpdate;
	return (p ? p->keyinfo.nField : 0);
}
#endif 

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

SQLITE_API int sqlite3_preupdate_depth(sqlite3 *db) {
	PreUpdate *p = db->pPreUpdate;
	return (p ? p->v->nFrame : 0);
}
#endif 

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

SQLITE_API int sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue) {
	PreUpdate *p = db->pPreUpdate;
	int rc = SQLITE_OK;
	Mem *pMem;

	if (!p || p->op == SQLITE_DELETE) {
		rc = SQLITE_MISUSE_BKPT;
		goto preupdate_new_out;
	}
	if (iIdx >= p->pCsr->nField || iIdx<0) {
		rc = SQLITE_RANGE;
		goto preupdate_new_out;
	}

	if (p->op == SQLITE_INSERT) {
		
		UnpackedRecord *pUnpack = p->pNewUnpacked;
		if (!pUnpack) {
			Mem *pData = &p->v->aMem[p->iNewReg];
			rc = ExpandBlob(pData);
			if (rc != SQLITE_OK) goto preupdate_new_out;
			pUnpack = vdbeUnpackRecord(&p->keyinfo, pData->n, pData->z);
			if (!pUnpack) {
				rc = SQLITE_NOMEM;
				goto preupdate_new_out;
			}
			p->pNewUnpacked = pUnpack;
		}
		if (iIdx >= pUnpack->nField) {
			pMem = (sqlite3_value *)columnNullValue();
		}
		else {
			pMem = &pUnpack->aMem[iIdx];
			if (iIdx == p->pTab->iPKey) {
				sqlite3VdbeMemSetInt64(pMem, p->iKey2);
			}
		}
	}
	else {
		
		assert(p->op == SQLITE_UPDATE);
		if (!p->aNew) {
			p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p->pCsr->nField);
			if (!p->aNew) {
				rc = SQLITE_NOMEM;
				goto preupdate_new_out;
			}
		}
		assert(iIdx >= 0 && iIdx<p->pCsr->nField);
		pMem = &p->aNew[iIdx];
		if (pMem->flags == 0) {
			if (iIdx == p->pTab->iPKey) {
				sqlite3VdbeMemSetInt64(pMem, p->iKey2);
			}
			else {
				rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg + 1 + iIdx]);
				if (rc != SQLITE_OK) goto preupdate_new_out;
			}
		}
	}
	*ppValue = pMem;

preupdate_new_out:
	sqlite3Error(db, rc);
	return sqlite3ApiExit(db, rc);
}
#endif 

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS

SQLITE_API int sqlite3_stmt_scanstatus(
	sqlite3_stmt *pStmt,            
	int idx,                        
	int iScanStatusOp,              
	void *pOut                      
) {
	Vdbe *p = (Vdbe*)pStmt;
	ScanStatus *pScan;
	if (idx<0 || idx >= p->nScan) return 1;
	pScan = &p->aScan[idx];
	switch (iScanStatusOp) {
	case SQLITE_SCANSTAT_NLOOP: {
		*(sqlite3_int64*)pOut = p->anExec[pScan->addrLoop];
		break;
	}
	case SQLITE_SCANSTAT_NVISIT: {
		*(sqlite3_int64*)pOut = p->anExec[pScan->addrVisit];
		break;
	}
	case SQLITE_SCANSTAT_EST: {
		double r = 1.0;
		LogEst x = pScan->nEst;
		while (x<100) {
			x += 10;
			r *= 0.5;
		}
		*(double*)pOut = r*sqlite3LogEstToInt(x);
		break;
	}
	case SQLITE_SCANSTAT_NAME: {
		*(const char**)pOut = pScan->zName;
		break;
	}
	case SQLITE_SCANSTAT_EXPLAIN: {
		if (pScan->addrExplain) {
			*(const char**)pOut = p->aOp[pScan->addrExplain].p4.z;
		}
		else {
			*(const char**)pOut = 0;
		}
		break;
	}
	case SQLITE_SCANSTAT_SELECTID: {
		if (pScan->addrExplain) {
			*(int*)pOut = p->aOp[pScan->addrExplain].p1;
		}
		else {
			*(int*)pOut = -1;
		}
		break;
	}
	default: {
		return 1;
	}
	}
	return 0;
}


SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt) {
	Vdbe *p = (Vdbe*)pStmt;
	memset(p->anExec, 0, p->nOp * sizeof(i64));
}
#endif 







#ifndef SQLITE_OMIT_TRACE


static int findNextHostParameter(const char *zSql, int *pnToken) {
	int tokenType;
	int nTotal = 0;
	int n;

	*pnToken = 0;
	while (zSql[0]) {
		n = sqlite3GetToken((u8*)zSql, &tokenType);
		assert(n>0 && tokenType != TK_ILLEGAL);
		if (tokenType == TK_VARIABLE) {
			*pnToken = n;
			break;
		}
		nTotal += n;
		zSql += n;
	}
	return nTotal;
}


SQLITE_PRIVATE char *sqlite3VdbeExpandSql(
	Vdbe *p,                 
	const char *zRawSql      
) {
	sqlite3 *db;             
	int idx = 0;             
	int nextIndex = 1;       
	int n;                   
	int nToken;              
	int i;                   
	Mem *pVar;               
	StrAccum out;            
#ifndef SQLITE_OMIT_UTF16
	Mem utf8;                
#endif
	char zBase[100];         

	db = p->db;
	sqlite3StrAccumInit(&out, 0, zBase, sizeof(zBase),
		db->aLimit[SQLITE_LIMIT_LENGTH]);
	if (db->nVdbeExec>1) {
		while (*zRawSql) {
			const char *zStart = zRawSql;
			while (*(zRawSql++) != '\n' && *zRawSql);
			sqlite3StrAccumAppend(&out, "-- ", 3);
			assert((zRawSql - zStart) > 0);
			sqlite3StrAccumAppend(&out, zStart, (int)(zRawSql - zStart));
		}
	}
	else if (p->nVar == 0) {
		sqlite3StrAccumAppend(&out, zRawSql, sqlite3Strlen30(zRawSql));
	}
	else {
		while (zRawSql[0]) {
			n = findNextHostParameter(zRawSql, &nToken);
			assert(n>0);
			sqlite3StrAccumAppend(&out, zRawSql, n);
			zRawSql += n;
			assert(zRawSql[0] || nToken == 0);
			if (nToken == 0) break;
			if (zRawSql[0] == '?') {
				if (nToken>1) {
					assert(sqlite3Isdigit(zRawSql[1]));
					sqlite3GetInt32(&zRawSql[1], &idx);
				}
				else {
					idx = nextIndex;
				}
			}
			else {
				assert(zRawSql[0] == ':' || zRawSql[0] == '$' ||
					zRawSql[0] == '@' || zRawSql[0] == '#');
				testcase(zRawSql[0] == ':');
				testcase(zRawSql[0] == '$');
				testcase(zRawSql[0] == '@');
				testcase(zRawSql[0] == '#');
				idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
				assert(idx>0);
			}
			zRawSql += nToken;
			nextIndex = idx + 1;
			assert(idx>0 && idx <= p->nVar);
			pVar = &p->aVar[idx - 1];
			if (pVar->flags & MEM_Null) {
				sqlite3StrAccumAppend(&out, "NULL", 4);
			}
			else if (pVar->flags & MEM_Int) {
				sqlite3XPrintf(&out, "%lld", pVar->u.i);
			}
			else if (pVar->flags & MEM_Real) {
				sqlite3XPrintf(&out, "%!.15g", pVar->u.r);
			}
			else if (pVar->flags & MEM_Str) {
				int nOut;  
#ifndef SQLITE_OMIT_UTF16
				u8 enc = ENC(db);
				if (enc != SQLITE_UTF8) {
					memset(&utf8, 0, sizeof(utf8));
					utf8.db = db;
					sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);
					if (SQLITE_NOMEM == sqlite3VdbeChangeEncoding(&utf8, SQLITE_UTF8)) {
						out.accError = STRACCUM_NOMEM;
						out.nAlloc = 0;
					}
					pVar = &utf8;
				}
#endif
				nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
				if (nOut>SQLITE_TRACE_SIZE_LIMIT) {
					nOut = SQLITE_TRACE_SIZE_LIMIT;
					while (nOut<pVar->n && (pVar->z[nOut] & 0xc0) == 0x80) { nOut++; }
				}
#endif    
				sqlite3XPrintf(&out, "'%.*q'", nOut, pVar->z);
#ifdef SQLITE_TRACE_SIZE_LIMIT
				if (nOut<pVar->n) {
					sqlite3XPrintf(&out, "/*+%d bytes*/", pVar->n - nOut);
				}
#endif
#ifndef SQLITE_OMIT_UTF16
				if (enc != SQLITE_UTF8) sqlite3VdbeMemRelease(&utf8);
#endif
			}
			else if (pVar->flags & MEM_Zero) {
				sqlite3XPrintf(&out, "zeroblob(%d)", pVar->u.nZero);
			}
			else {
				int nOut;  
				assert(pVar->flags & MEM_Blob);
				sqlite3StrAccumAppend(&out, "x'", 2);
				nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
				if (nOut>SQLITE_TRACE_SIZE_LIMIT) nOut = SQLITE_TRACE_SIZE_LIMIT;
#endif
				for (i = 0; i<nOut; i++) {
					sqlite3XPrintf(&out, "%02x", pVar->z[i] & 0xff);
				}
				sqlite3StrAccumAppend(&out, "'", 1);
#ifdef SQLITE_TRACE_SIZE_LIMIT
				if (nOut<pVar->n) {
					sqlite3XPrintf(&out, "/*+%d bytes*/", pVar->n - nOut);
				}
#endif
			}
		}
	}
	if (out.accError) sqlite3StrAccumReset(&out);
	return sqlite3StrAccumFinish(&out);
}

#endif 








#ifdef SQLITE_DEBUG
# define memAboutToChange(P,M) sqlite3VdbeMemAboutToChange(P,M)
#else
# define memAboutToChange(P,M)
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_search_count = 0;
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_interrupt_count = 0;
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_sort_count = 0;
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_max_blobsize = 0;
static void updateMaxBlobsize(Mem *p) {
	if ((p->flags & (MEM_Str | MEM_Blob)) != 0 && p->n>sqlite3_max_blobsize) {
		sqlite3_max_blobsize = p->n;
	}
}
#endif


#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
# define HAS_UPDATE_HOOK(DB) ((DB)->xPreUpdateCallback||(DB)->xUpdateCallback)
#else
# define HAS_UPDATE_HOOK(DB) ((DB)->xUpdateCallback)
#endif


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_found_count = 0;
#endif


#if defined(SQLITE_TEST) && !defined(SQLITE_OMIT_BUILTIN_TEST)
# define UPDATE_MAX_BLOBSIZE(P)  updateMaxBlobsize(P)
#else
# define UPDATE_MAX_BLOBSIZE(P)
#endif


#if !defined(SQLITE_VDBE_COVERAGE)
# define VdbeBranchTaken(I,M)
#else
# define VdbeBranchTaken(I,M) vdbeTakeBranch(pOp->iSrcLine,I,M)
static void vdbeTakeBranch(int iSrcLine, u8 I, u8 M) {
	if (iSrcLine <= 2 && ALWAYS(iSrcLine>0)) {
		M = iSrcLine;
		
		assert((M & I) == I);
	}
	else {
		if (sqlite3GlobalConfig.xVdbeBranch == 0) return;  
		sqlite3GlobalConfig.xVdbeBranch(sqlite3GlobalConfig.pVdbeBranchArg,
			iSrcLine, I, M);
	}
}
#endif


#define Stringify(P, enc) \
   if(((P)->flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc,0)) \
     { goto no_mem; }


#define Deephemeralize(P) \
   if( ((P)->flags&MEM_Ephem)!=0 \
       && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}


#define isSorter(x) ((x)->eCurType==CURTYPE_SORTER)


static VdbeCursor *allocateCursor(
	Vdbe *p,              
	int iCur,             
	int nField,           
	int iDb,              
	u8 eCurType           
) {
	
	Mem *pMem = iCur>0 ? &p->aMem[p->nMem - iCur] : p->aMem;

	int nByte;
	VdbeCursor *pCx = 0;
	nByte =
		ROUND8(sizeof(VdbeCursor)) + 2 * sizeof(u32)*nField +
		(eCurType == CURTYPE_BTREE ? sqlite3BtreeCursorSize() : 0);

	assert(iCur >= 0 && iCur<p->nCursor);
	if (p->apCsr[iCur]) { 
		sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);
		p->apCsr[iCur] = 0;
	}
	if (SQLITE_OK == sqlite3VdbeMemClearAndResize(pMem, nByte)) {
		p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
		memset(pCx, 0, sizeof(VdbeCursor));
		pCx->eCurType = eCurType;
		pCx->iDb = iDb;
		pCx->nField = nField;
		pCx->aOffset = &pCx->aType[nField];
		if (eCurType == CURTYPE_BTREE) {
			pCx->uc.pCursor = (BtCursor*)
				&pMem->z[ROUND8(sizeof(VdbeCursor)) + 2 * sizeof(u32)*nField];
			sqlite3BtreeCursorZero(pCx->uc.pCursor);
		}
	}
	return pCx;
}


static void applyNumericAffinity(Mem *pRec, int bTryForInt) {
	double rValue;
	i64 iValue;
	u8 enc = pRec->enc;
	assert((pRec->flags & (MEM_Str | MEM_Int | MEM_Real)) == MEM_Str);
	if (sqlite3AtoF(pRec->z, &rValue, pRec->n, enc) == 0) return;
	if (0 == sqlite3Atoi64(pRec->z, &iValue, pRec->n, enc)) {
		pRec->u.i = iValue;
		pRec->flags |= MEM_Int;
	}
	else {
		pRec->u.r = rValue;
		pRec->flags |= MEM_Real;
		if (bTryForInt) sqlite3VdbeIntegerAffinity(pRec);
	}
}


static void applyAffinity(
	Mem *pRec,          
	char affinity,      
	u8 enc              
) {
	if (affinity >= SQLITE_AFF_NUMERIC) {
		assert(affinity == SQLITE_AFF_INTEGER || affinity == SQLITE_AFF_REAL
			|| affinity == SQLITE_AFF_NUMERIC);
		if ((pRec->flags & MEM_Int) == 0) { 
			if ((pRec->flags & MEM_Real) == 0) {
				if (pRec->flags & MEM_Str) applyNumericAffinity(pRec, 1);
			}
			else {
				sqlite3VdbeIntegerAffinity(pRec);
			}
		}
	}
	else if (affinity == SQLITE_AFF_TEXT) {
		
		if (0 == (pRec->flags&MEM_Str)) { 
			if ((pRec->flags&(MEM_Real | MEM_Int))) {
				sqlite3VdbeMemStringify(pRec, enc, 1);
			}
		}
		pRec->flags &= ~(MEM_Real | MEM_Int);
	}
}


SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal) {
	int eType = sqlite3_value_type(pVal);
	if (eType == SQLITE_TEXT) {
		Mem *pMem = (Mem*)pVal;
		applyNumericAffinity(pMem, 0);
		eType = sqlite3_value_type(pVal);
	}
	return eType;
}


SQLITE_PRIVATE void sqlite3ValueApplyAffinity(
	sqlite3_value *pVal,
	u8 affinity,
	u8 enc
) {
	applyAffinity((Mem *)pVal, affinity, enc);
}


static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem) {
	assert((pMem->flags & (MEM_Int | MEM_Real)) == 0);
	assert((pMem->flags & (MEM_Str | MEM_Blob)) != 0);
	if (sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc) == 0) {
		return 0;
	}
	if (sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc) == SQLITE_OK) {
		return MEM_Int;
	}
	return MEM_Real;
}


static u16 numericType(Mem *pMem) {
	if (pMem->flags & (MEM_Int | MEM_Real)) {
		return pMem->flags & (MEM_Int | MEM_Real);
	}
	if (pMem->flags & (MEM_Str | MEM_Blob)) {
		return computeNumericType(pMem);
	}
	return 0;
}

#ifdef SQLITE_DEBUG

SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf) {
	char *zCsr = zBuf;
	int f = pMem->flags;

	static const char *const encnames[] = { "(X)", "(8)", "(16LE)", "(16BE)" };

	if (f&MEM_Blob) {
		int i;
		char c;
		if (f & MEM_Dyn) {
			c = 'z';
			assert((f & (MEM_Static | MEM_Ephem)) == 0);
		}
		else if (f & MEM_Static) {
			c = 't';
			assert((f & (MEM_Dyn | MEM_Ephem)) == 0);
		}
		else if (f & MEM_Ephem) {
			c = 'e';
			assert((f & (MEM_Static | MEM_Dyn)) == 0);
		}
		else {
			c = 's';
		}

		sqlite3_snprintf(100, zCsr, "%c", c);
		zCsr += sqlite3Strlen30(zCsr);
		sqlite3_snprintf(100, zCsr, "%d[", pMem->n);
		zCsr += sqlite3Strlen30(zCsr);
		for (i = 0; i<16 && i<pMem->n; i++) {
			sqlite3_snprintf(100, zCsr, "%02X", ((int)pMem->z[i] & 0xFF));
			zCsr += sqlite3Strlen30(zCsr);
		}
		for (i = 0; i<16 && i<pMem->n; i++) {
			char z = pMem->z[i];
			if (z<32 || z>126) *zCsr++ = '.';
			else *zCsr++ = z;
		}

		sqlite3_snprintf(100, zCsr, "]%s", encnames[pMem->enc]);
		zCsr += sqlite3Strlen30(zCsr);
		if (f & MEM_Zero) {
			sqlite3_snprintf(100, zCsr, "+%dz", pMem->u.nZero);
			zCsr += sqlite3Strlen30(zCsr);
		}
		*zCsr = '\0';
	}
	else if (f & MEM_Str) {
		int j, k;
		zBuf[0] = ' ';
		if (f & MEM_Dyn) {
			zBuf[1] = 'z';
			assert((f & (MEM_Static | MEM_Ephem)) == 0);
		}
		else if (f & MEM_Static) {
			zBuf[1] = 't';
			assert((f & (MEM_Dyn | MEM_Ephem)) == 0);
		}
		else if (f & MEM_Ephem) {
			zBuf[1] = 'e';
			assert((f & (MEM_Static | MEM_Dyn)) == 0);
		}
		else {
			zBuf[1] = 's';
		}
		k = 2;
		sqlite3_snprintf(100, &zBuf[k], "%d", pMem->n);
		k += sqlite3Strlen30(&zBuf[k]);
		zBuf[k++] = '[';
		for (j = 0; j<15 && j<pMem->n; j++) {
			u8 c = pMem->z[j];
			if (c >= 0x20 && c<0x7f) {
				zBuf[k++] = c;
			}
			else {
				zBuf[k++] = '.';
			}
		}
		zBuf[k++] = ']';
		sqlite3_snprintf(100, &zBuf[k], encnames[pMem->enc]);
		k += sqlite3Strlen30(&zBuf[k]);
		zBuf[k++] = 0;
	}
}
#endif

#ifdef SQLITE_DEBUG

static void memTracePrint(Mem *p) {
	if (p->flags & MEM_Undefined) {
		printf(" undefined");
	}
	else if (p->flags & MEM_Null) {
		printf(" NULL");
	}
	else if ((p->flags & (MEM_Int | MEM_Str)) == (MEM_Int | MEM_Str)) {
		printf(" si:%lld", p->u.i);
	}
	else if (p->flags & MEM_Int) {
		printf(" i:%lld", p->u.i);
#ifndef SQLITE_OMIT_FLOATING_POINT
	}
	else if (p->flags & MEM_Real) {
		printf(" r:%g", p->u.r);
#endif
	}
	else if (p->flags & MEM_RowSet) {
		printf(" (rowset)");
	}
	else {
		char zBuf[200];
		sqlite3VdbeMemPrettyPrint(p, zBuf);
		printf(" %s", zBuf);
	}
	if (p->flags & MEM_Subtype) printf(" subtype=0x%02x", p->eSubtype);
}
static void registerTrace(int iReg, Mem *p) {
	printf("REG[%d] = ", iReg);
	memTracePrint(p);
	printf("\n");
}
#endif

#ifdef SQLITE_DEBUG
#  define REGISTER_TRACE(R,M) if(db->flags&SQLITE_VdbeTrace)registerTrace(R,M)
#else
#  define REGISTER_TRACE(R,M)
#endif


#ifdef VDBE_PROFILE





#ifndef SQLITE_HWTIME_H
#define SQLITE_HWTIME_H


#if (defined(__GNUC__) || defined(_MSC_VER)) && \
      (defined(i386) || defined(__i386__) || defined(_M_IX86))

#if defined(__GNUC__)

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned int lo, hi;
	__asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
	return (sqlite_uint64)hi << 32 | lo;
}

#elif defined(_MSC_VER)

__declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void) {
	__asm {
		rdtsc
		ret; return value at EDX : EAX
	}
}

#endif

#elif (defined(__GNUC__) && defined(__x86_64__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long val;
	__asm__ __volatile__("rdtsc" : "=A" (val));
	return val;
}

#elif (defined(__GNUC__) && defined(__ppc__))

__inline__ sqlite_uint64 sqlite3Hwtime(void) {
	unsigned long long retval;
	unsigned long junk;
	__asm__ __volatile__("\n\
          1:      mftbu   %1\n\
                  mftb    %L0\n\
                  mftbu   %0\n\
                  cmpw    %0,%1\n\
                  bne     1b"
		: "=r" (retval), "=r" (junk));
	return retval;
}

#else

#error Need implementation of sqlite3Hwtime() for your platform.


SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void) { return ((sqlite_uint64)0); }

#endif

#endif 




#endif

#ifndef NDEBUG

static int checkSavepointCount(sqlite3 *db) {
	int n = 0;
	Savepoint *p;
	for (p = db->pSavepoint; p; p = p->pNext) n++;
	assert(n == (db->nSavepoint + db->isTransactionSavepoint));
	return 1;
}
#endif


static SQLITE_NOINLINE Mem *out2PrereleaseWithClear(Mem *pOut) {
	sqlite3VdbeMemSetNull(pOut);
	pOut->flags = MEM_Int;
	return pOut;
}
static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp) {
	Mem *pOut;
	assert(pOp->p2>0);
	assert(pOp->p2 <= (p->nMem + 1 - p->nCursor));
	pOut = &p->aMem[pOp->p2];
	memAboutToChange(p, pOut);
	if (VdbeMemDynamic(pOut)) { 
		return out2PrereleaseWithClear(pOut);
	}
	else {
		pOut->flags = MEM_Int;
		return pOut;
	}
}



SQLITE_PRIVATE int sqlite3VdbeExec(
	Vdbe *p                    
) {
	Op *aOp = p->aOp;          
	Op *pOp = aOp;             
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
	Op *pOrigOp;               
#endif
#ifdef SQLITE_DEBUG
	int nExtraDelete = 0;      
#endif
	int rc = SQLITE_OK;        
	sqlite3 *db = p->db;       
	u8 resetSchemaOnFault = 0; 
	u8 encoding = ENC(db);     
	int iCompare = 0;          
	unsigned nVmStep = 0;      
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
	unsigned nProgressLimit = 0;
#endif
	Mem *aMem = p->aMem;       
	Mem *pIn1 = 0;             
	Mem *pIn2 = 0;             
	Mem *pIn3 = 0;             
	Mem *pOut = 0;             
	int *aPermute = 0;         
	i64 lastRowid = db->lastRowid;  
#ifdef VDBE_PROFILE
	u64 start;                 
#endif
							   

	assert(p->magic == VDBE_MAGIC_RUN);  
	sqlite3VdbeEnter(p);
	if (p->rc == SQLITE_NOMEM) {
		
		goto no_mem;
	}
	assert(p->rc == SQLITE_OK || (p->rc & 0xff) == SQLITE_BUSY);
	assert(p->bIsReader || p->readOnly != 0);
	p->rc = SQLITE_OK;
	p->iCurrentTime = 0;
	assert(p->explain == 0);
	p->pResultSet = 0;
	db->busyHandler.nBusy = 0;
	if (db->u1.isInterrupted) goto abort_due_to_interrupt;
	sqlite3VdbeIOTraceSql(p);
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
	if (db->xProgress) {
		u32 iPrior = p->aCounter[SQLITE_STMTSTATUS_VM_STEP];
		assert(0 < db->nProgressOps);
		nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);
	}
#endif
#ifdef SQLITE_DEBUG
	sqlite3BeginBenignMalloc();
	if (p->pc == 0
		&& (p->db->flags & (SQLITE_VdbeListing | SQLITE_VdbeEQP | SQLITE_VdbeTrace)) != 0
		) {
		int i;
		int once = 1;
		sqlite3VdbePrintSql(p);
		if (p->db->flags & SQLITE_VdbeListing) {
			printf("VDBE Program Listing:\n");
			for (i = 0; i<p->nOp; i++) {
				sqlite3VdbePrintOp(stdout, i, &aOp[i]);
			}
		}
		if (p->db->flags & SQLITE_VdbeEQP) {
			for (i = 0; i<p->nOp; i++) {
				if (aOp[i].opcode == OP_Explain) {
					if (once) printf("VDBE Query Plan:\n");
					printf("%s\n", aOp[i].p4.z);
					once = 0;
				}
			}
		}
		if (p->db->flags & SQLITE_VdbeTrace)  printf("VDBE Trace:\n");
	}
	sqlite3EndBenignMalloc();
#endif
	for (pOp = &aOp[p->pc]; 1; pOp++) {
		
		assert(rc == SQLITE_OK);

		assert(pOp >= aOp && pOp<&aOp[p->nOp]);
#ifdef VDBE_PROFILE
		start = sqlite3Hwtime();
#endif
		nVmStep++;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
		if (p->anExec) p->anExec[(int)(pOp - aOp)]++;
#endif

		
#ifdef SQLITE_DEBUG
		if (db->flags & SQLITE_VdbeTrace) {
			sqlite3VdbePrintOp(stdout, (int)(pOp - aOp), pOp);
		}
#endif


		
#ifdef SQLITE_TEST
		if (sqlite3_interrupt_count>0) {
			sqlite3_interrupt_count--;
			if (sqlite3_interrupt_count == 0) {
				sqlite3_interrupt(db);
			}
		}
#endif

		
#ifdef SQLITE_DEBUG
		{
			u8 opProperty = sqlite3OpcodeProperty[pOp->opcode];
			if ((opProperty & OPFLG_IN1) != 0) {
				assert(pOp->p1>0);
				assert(pOp->p1 <= (p->nMem + 1 - p->nCursor));
				assert(memIsValid(&aMem[pOp->p1]));
				assert(sqlite3VdbeCheckMemInvariants(&aMem[pOp->p1]));
				REGISTER_TRACE(pOp->p1, &aMem[pOp->p1]);
			}
			if ((opProperty & OPFLG_IN2) != 0) {
				assert(pOp->p2>0);
				assert(pOp->p2 <= (p->nMem + 1 - p->nCursor));
				assert(memIsValid(&aMem[pOp->p2]));
				assert(sqlite3VdbeCheckMemInvariants(&aMem[pOp->p2]));
				REGISTER_TRACE(pOp->p2, &aMem[pOp->p2]);
			}
			if ((opProperty & OPFLG_IN3) != 0) {
				assert(pOp->p3>0);
				assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));
				assert(memIsValid(&aMem[pOp->p3]));
				assert(sqlite3VdbeCheckMemInvariants(&aMem[pOp->p3]));
				REGISTER_TRACE(pOp->p3, &aMem[pOp->p3]);
			}
			if ((opProperty & OPFLG_OUT2) != 0) {
				assert(pOp->p2>0);
				assert(pOp->p2 <= (p->nMem + 1 - p->nCursor));
				memAboutToChange(p, &aMem[pOp->p2]);
			}
			if ((opProperty & OPFLG_OUT3) != 0) {
				assert(pOp->p3>0);
				assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));
				memAboutToChange(p, &aMem[pOp->p3]);
			}
		}
#endif
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
		pOrigOp = pOp;
#endif

		switch (pOp->opcode) {

			

			
		case OP_Goto: {             
		jump_to_p2_and_check_for_interrupt:
			pOp = &aOp[pOp->p2 - 1];

			
		check_for_interrupt:
			if (db->u1.isInterrupted) goto abort_due_to_interrupt;
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
			
			if (db->xProgress != 0 && nVmStep >= nProgressLimit) {
				assert(db->nProgressOps != 0);
				nProgressLimit = nVmStep + db->nProgressOps - (nVmStep%db->nProgressOps);
				if (db->xProgress(db->pProgressArg)) {
					rc = SQLITE_INTERRUPT;
					goto abort_due_to_error;
				}
			}
#endif

			break;
		}

					  
		case OP_Gosub: {            
			assert(pOp->p1>0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));
			pIn1 = &aMem[pOp->p1];
			assert(VdbeMemDynamic(pIn1) == 0);
			memAboutToChange(p, pIn1);
			pIn1->flags = MEM_Int;
			pIn1->u.i = (int)(pOp - aOp);
			REGISTER_TRACE(pOp->p1, pIn1);

			
		jump_to_p2:
			pOp = &aOp[pOp->p2 - 1];
			break;
		}

					   
		case OP_Return: {           
			pIn1 = &aMem[pOp->p1];
			assert(pIn1->flags == MEM_Int);
			pOp = &aOp[pIn1->u.i];
			pIn1->flags = MEM_Undefined;
			break;
		}

						
		case OP_InitCoroutine: {     
			assert(pOp->p1>0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));
			assert(pOp->p2 >= 0 && pOp->p2<p->nOp);
			assert(pOp->p3 >= 0 && pOp->p3<p->nOp);
			pOut = &aMem[pOp->p1];
			assert(!VdbeMemDynamic(pOut));
			pOut->u.i = pOp->p3 - 1;
			pOut->flags = MEM_Int;
			if (pOp->p2) goto jump_to_p2;
			break;
		}

							   
		case OP_EndCoroutine: {           
			VdbeOp *pCaller;
			pIn1 = &aMem[pOp->p1];
			assert(pIn1->flags == MEM_Int);
			assert(pIn1->u.i >= 0 && pIn1->u.i<p->nOp);
			pCaller = &aOp[pIn1->u.i];
			assert(pCaller->opcode == OP_Yield);
			assert(pCaller->p2 >= 0 && pCaller->p2<p->nOp);
			pOp = &aOp[pCaller->p2 - 1];
			pIn1->flags = MEM_Undefined;
			break;
		}

							  
		case OP_Yield: {            
			int pcDest;
			pIn1 = &aMem[pOp->p1];
			assert(VdbeMemDynamic(pIn1) == 0);
			pIn1->flags = MEM_Int;
			pcDest = (int)pIn1->u.i;
			pIn1->u.i = (int)(pOp - aOp);
			REGISTER_TRACE(pOp->p1, pIn1);
			pOp = &aOp[pcDest];
			break;
		}

					   
		case OP_HaltIfNull: {      
			pIn3 = &aMem[pOp->p3];
			if ((pIn3->flags & MEM_Null) == 0) break;
			
		}

							
		case OP_Halt: {
			VdbeFrame *pFrame;
			int pcx;

			pcx = (int)(pOp - aOp);
			if (pOp->p1 == SQLITE_OK && p->pFrame) {
				
				pFrame = p->pFrame;
				p->pFrame = pFrame->pParent;
				p->nFrame--;
				sqlite3VdbeSetChanges(db, p->nChange);
				pcx = sqlite3VdbeFrameRestore(pFrame);
				lastRowid = db->lastRowid;
				if (pOp->p2 == OE_Ignore) {
					
					pcx = p->aOp[pcx].p2 - 1;
				}
				aOp = p->aOp;
				aMem = p->aMem;
				pOp = &aOp[pcx];
				break;
			}
			p->rc = pOp->p1;
			p->errorAction = (u8)pOp->p2;
			p->pc = pcx;
			assert(pOp->p5 >= 0 && pOp->p5 <= 4);
			if (p->rc) {
				if (pOp->p5) {
					static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK",
						"FOREIGN KEY" };
					testcase(pOp->p5 == 1);
					testcase(pOp->p5 == 2);
					testcase(pOp->p5 == 3);
					testcase(pOp->p5 == 4);
					sqlite3VdbeError(p, "%s constraint failed", azType[pOp->p5 - 1]);
					if (pOp->p4.z) {
						p->zErrMsg = sqlite3MPrintf(db, "%z: %s", p->zErrMsg, pOp->p4.z);
					}
				}
				else {
					sqlite3VdbeError(p, "%s", pOp->p4.z);
				}
				sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pcx, p->zSql, p->zErrMsg);
			}
			rc = sqlite3VdbeHalt(p);
			assert(rc == SQLITE_BUSY || rc == SQLITE_OK || rc == SQLITE_ERROR);
			if (rc == SQLITE_BUSY) {
				p->rc = SQLITE_BUSY;
			}
			else {
				assert(rc == SQLITE_OK || (p->rc & 0xff) == SQLITE_CONSTRAINT);
				assert(rc == SQLITE_OK || db->nDeferredCons>0 || db->nDeferredImmCons>0);
				rc = p->rc ? SQLITE_ERROR : SQLITE_DONE;
			}
			goto vdbe_return;
		}

					  
		case OP_Integer: {         
			pOut = out2Prerelease(p, pOp);
			pOut->u.i = pOp->p1;
			break;
		}

						 
		case OP_Int64: {           
			pOut = out2Prerelease(p, pOp);
			assert(pOp->p4.pI64 != 0);
			pOut->u.i = *pOp->p4.pI64;
			break;
		}

#ifndef SQLITE_OMIT_FLOATING_POINT
					   
		case OP_Real: {            
			pOut = out2Prerelease(p, pOp);
			pOut->flags = MEM_Real;
			assert(!sqlite3IsNaN(*pOp->p4.pReal));
			pOut->u.r = *pOp->p4.pReal;
			break;
		}
#endif

					  
		case OP_String8: {         
			assert(pOp->p4.z != 0);
			pOut = out2Prerelease(p, pOp);
			pOp->opcode = OP_String;
			pOp->p1 = sqlite3Strlen30(pOp->p4.z);

#ifndef SQLITE_OMIT_UTF16
			if (encoding != SQLITE_UTF8) {
				rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC);
				assert(rc == SQLITE_OK || rc == SQLITE_TOOBIG);
				if (SQLITE_OK != sqlite3VdbeChangeEncoding(pOut, encoding)) goto no_mem;
				assert(pOut->szMalloc>0 && pOut->zMalloc == pOut->z);
				assert(VdbeMemDynamic(pOut) == 0);
				pOut->szMalloc = 0;
				pOut->flags |= MEM_Static;
				if (pOp->p4type == P4_DYNAMIC) {
					sqlite3DbFree(db, pOp->p4.z);
				}
				pOp->p4type = P4_DYNAMIC;
				pOp->p4.z = pOut->z;
				pOp->p1 = pOut->n;
			}
			testcase(rc == SQLITE_TOOBIG);
#endif
			if (pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH]) {
				goto too_big;
			}
			assert(rc == SQLITE_OK);
			
		}

						 
		case OP_String: {          
			assert(pOp->p4.z != 0);
			pOut = out2Prerelease(p, pOp);
			pOut->flags = MEM_Str | MEM_Static | MEM_Term;
			pOut->z = pOp->p4.z;
			pOut->n = pOp->p1;
			pOut->enc = encoding;
			UPDATE_MAX_BLOBSIZE(pOut);
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
			if (pOp->p3>0) {
				assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));
				pIn3 = &aMem[pOp->p3];
				assert(pIn3->flags & MEM_Int);
				if (pIn3->u.i == pOp->p5) pOut->flags = MEM_Blob | MEM_Static | MEM_Term;
			}
#endif
			break;
		}

						
		case OP_Null: {           
			int cnt;
			u16 nullFlag;
			pOut = out2Prerelease(p, pOp);
			cnt = pOp->p3 - pOp->p2;
			assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));
			pOut->flags = nullFlag = pOp->p1 ? (MEM_Null | MEM_Cleared) : MEM_Null;
			pOut->n = 0;
			while (cnt>0) {
				pOut++;
				memAboutToChange(p, pOut);
				sqlite3VdbeMemSetNull(pOut);
				pOut->flags = nullFlag;
				pOut->n = 0;
				cnt--;
			}
			break;
		}

					  
		case OP_SoftNull: {
			assert(pOp->p1>0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));
			pOut = &aMem[pOp->p1];
			pOut->flags = (pOut->flags | MEM_Null)&~MEM_Undefined;
			break;
		}

						  
		case OP_Blob: {                
			assert(pOp->p1 <= SQLITE_MAX_LENGTH);
			pOut = out2Prerelease(p, pOp);
			sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
			pOut->enc = encoding;
			UPDATE_MAX_BLOBSIZE(pOut);
			break;
		}

					  
		case OP_Variable: {            
			Mem *pVar;       

			assert(pOp->p1>0 && pOp->p1 <= p->nVar);
			assert(pOp->p4.z == 0 || pOp->p4.z == p->azVar[pOp->p1 - 1]);
			pVar = &p->aVar[pOp->p1 - 1];
			if (sqlite3VdbeMemTooBig(pVar)) {
				goto too_big;
			}
			pOut = out2Prerelease(p, pOp);
			sqlite3VdbeMemShallowCopy(pOut, pVar, MEM_Static);
			UPDATE_MAX_BLOBSIZE(pOut);
			break;
		}

						  
		case OP_Move: {
			int n;           
			int p1;          
			int p2;          

			n = pOp->p3;
			p1 = pOp->p1;
			p2 = pOp->p2;
			assert(n>0 && p1>0 && p2>0);
			assert(p1 + n <= p2 || p2 + n <= p1);

			pIn1 = &aMem[p1];
			pOut = &aMem[p2];
			do {
				assert(pOut <= &aMem[(p->nMem + 1 - p->nCursor)]);
				assert(pIn1 <= &aMem[(p->nMem + 1 - p->nCursor)]);
				assert(memIsValid(pIn1));
				memAboutToChange(p, pOut);
				sqlite3VdbeMemMove(pOut, pIn1);
#ifdef SQLITE_DEBUG
				if (pOut->pScopyFrom >= &aMem[p1] && pOut->pScopyFrom<pOut) {
					pOut->pScopyFrom += pOp->p2 - p1;
				}
#endif
				Deephemeralize(pOut);
				REGISTER_TRACE(p2++, pOut);
				pIn1++;
				pOut++;
			} while (--n);
			break;
		}

					  
		case OP_Copy: {
			int n;

			n = pOp->p3;
			pIn1 = &aMem[pOp->p1];
			pOut = &aMem[pOp->p2];
			assert(pOut != pIn1);
			while (1) {
				sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);
				Deephemeralize(pOut);
#ifdef SQLITE_DEBUG
				pOut->pScopyFrom = 0;
#endif
				REGISTER_TRACE(pOp->p2 + pOp->p3 - n, pOut);
				if ((n--) == 0) break;
				pOut++;
				pIn1++;
			}
			break;
		}

					  
		case OP_SCopy: {            
			pIn1 = &aMem[pOp->p1];
			pOut = &aMem[pOp->p2];
			assert(pOut != pIn1);
			sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);
#ifdef SQLITE_DEBUG
			if (pOut->pScopyFrom == 0) pOut->pScopyFrom = pIn1;
#endif
			break;
		}

					   
		case OP_IntCopy: {            
			pIn1 = &aMem[pOp->p1];
			assert((pIn1->flags & MEM_Int) != 0);
			pOut = &aMem[pOp->p2];
			sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);
			break;
		}

						 
		case OP_ResultRow: {
			Mem *pMem;
			int i;
			assert(p->nResColumn == pOp->p2);
			assert(pOp->p1>0);
			assert(pOp->p1 + pOp->p2 <= (p->nMem + 1 - p->nCursor) + 1);

#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
			
			if (db->xProgress != 0
				&& nVmStep >= nProgressLimit
				&& db->xProgress(db->pProgressArg) != 0
				) {
				rc = SQLITE_INTERRUPT;
				goto abort_due_to_error;
			}
#endif

			
			if (SQLITE_OK != (rc = sqlite3VdbeCheckFk(p, 0))) {
				assert(db->flags&SQLITE_CountRows);
				assert(p->usesStmtJournal);
				goto abort_due_to_error;
			}

			
			assert(p->iStatement == 0 || db->flags&SQLITE_CountRows);
			rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE);
			assert(rc == SQLITE_OK);

			
			p->cacheCtr = (p->cacheCtr + 2) | 1;

			
			pMem = p->pResultSet = &aMem[pOp->p1];
			for (i = 0; i<pOp->p2; i++) {
				assert(memIsValid(&pMem[i]));
				Deephemeralize(&pMem[i]);
				assert((pMem[i].flags & MEM_Ephem) == 0
					|| (pMem[i].flags & (MEM_Str | MEM_Blob)) == 0);
				sqlite3VdbeMemNulTerminate(&pMem[i]);
				REGISTER_TRACE(pOp->p1 + i, &pMem[i]);
			}
			if (db->mallocFailed) goto no_mem;

			if (db->mTrace & SQLITE_TRACE_ROW) {
				db->xTrace(SQLITE_TRACE_ROW, db->pTraceArg, p, 0);
			}

			
			p->pc = (int)(pOp - aOp) + 1;
			rc = SQLITE_ROW;
			goto vdbe_return;
		}

						   
		case OP_Concat: {           
			i64 nByte;

			pIn1 = &aMem[pOp->p1];
			pIn2 = &aMem[pOp->p2];
			pOut = &aMem[pOp->p3];
			assert(pIn1 != pOut);
			if ((pIn1->flags | pIn2->flags) & MEM_Null) {
				sqlite3VdbeMemSetNull(pOut);
				break;
			}
			if (ExpandBlob(pIn1) || ExpandBlob(pIn2)) goto no_mem;
			Stringify(pIn1, encoding);
			Stringify(pIn2, encoding);
			nByte = pIn1->n + pIn2->n;
			if (nByte>db->aLimit[SQLITE_LIMIT_LENGTH]) {
				goto too_big;
			}
			if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {
				goto no_mem;
			}
			MemSetTypeFlag(pOut, MEM_Str);
			if (pOut != pIn2) {
				memcpy(pOut->z, pIn2->z, pIn2->n);
			}
			memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
			pOut->z[nByte] = 0;
			pOut->z[nByte + 1] = 0;
			pOut->flags |= MEM_Term;
			pOut->n = (int)nByte;
			pOut->enc = encoding;
			UPDATE_MAX_BLOBSIZE(pOut);
			break;
		}

						
						
						
						
						
		case OP_Add:                   
		case OP_Subtract:              
		case OP_Multiply:              
		case OP_Divide:                
		case OP_Remainder: {           
			char bIntint;   
			u16 flags;      
			u16 type1;      
			u16 type2;      
			i64 iA;         
			i64 iB;         
			double rA;      
			double rB;      

			pIn1 = &aMem[pOp->p1];
			type1 = numericType(pIn1);
			pIn2 = &aMem[pOp->p2];
			type2 = numericType(pIn2);
			pOut = &aMem[pOp->p3];
			flags = pIn1->flags | pIn2->flags;
			if ((flags & MEM_Null) != 0) goto arithmetic_result_is_null;
			if ((type1 & type2 & MEM_Int) != 0) {
				iA = pIn1->u.i;
				iB = pIn2->u.i;
				bIntint = 1;
				switch (pOp->opcode) {
				case OP_Add:       if (sqlite3AddInt64(&iB, iA)) goto fp_math;  break;
				case OP_Subtract:  if (sqlite3SubInt64(&iB, iA)) goto fp_math;  break;
				case OP_Multiply:  if (sqlite3MulInt64(&iB, iA)) goto fp_math;  break;
				case OP_Divide: {
					if (iA == 0) goto arithmetic_result_is_null;
					if (iA == -1 && iB == SMALLEST_INT64) goto fp_math;
					iB /= iA;
					break;
				}
				default: {
					if (iA == 0) goto arithmetic_result_is_null;
					if (iA == -1) iA = 1;
					iB %= iA;
					break;
				}
				}
				pOut->u.i = iB;
				MemSetTypeFlag(pOut, MEM_Int);
			}
			else {
				bIntint = 0;
			fp_math:
				rA = sqlite3VdbeRealValue(pIn1);
				rB = sqlite3VdbeRealValue(pIn2);
				switch (pOp->opcode) {
				case OP_Add:         rB += rA;       break;
				case OP_Subtract:    rB -= rA;       break;
				case OP_Multiply:    rB *= rA;       break;
				case OP_Divide: {
					
					if (rA == (double)0) goto arithmetic_result_is_null;
					rB /= rA;
					break;
				}
				default: {
					iA = (i64)rA;
					iB = (i64)rB;
					if (iA == 0) goto arithmetic_result_is_null;
					if (iA == -1) iA = 1;
					rB = (double)(iB % iA);
					break;
				}
				}
#ifdef SQLITE_OMIT_FLOATING_POINT
				pOut->u.i = rB;
				MemSetTypeFlag(pOut, MEM_Int);
#else
				if (sqlite3IsNaN(rB)) {
					goto arithmetic_result_is_null;
				}
				pOut->u.r = rB;
				MemSetTypeFlag(pOut, MEM_Real);
				if (((type1 | type2)&MEM_Real) == 0 && !bIntint) {
					sqlite3VdbeIntegerAffinity(pOut);
				}
#endif
			}
			break;

		arithmetic_result_is_null:
			sqlite3VdbeMemSetNull(pOut);
			break;
		}

						   
		case OP_CollSeq: {
			assert(pOp->p4type == P4_COLLSEQ);
			if (pOp->p1) {
				sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);
			}
			break;
		}

						 
						 
		case OP_Function0: {
			int n;
			sqlite3_context *pCtx;

			assert(pOp->p4type == P4_FUNCDEF);
			n = pOp->p5;
			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			assert(n == 0 || (pOp->p2>0 && pOp->p2 + n <= (p->nMem + 1 - p->nCursor) + 1));
			assert(pOp->p3<pOp->p2 || pOp->p3 >= pOp->p2 + n);
			pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n - 1) * sizeof(sqlite3_value*));
			if (pCtx == 0) goto no_mem;
			pCtx->pOut = 0;
			pCtx->pFunc = pOp->p4.pFunc;
			pCtx->iOp = (int)(pOp - aOp);
			pCtx->pVdbe = p;
			pCtx->argc = n;
			pOp->p4type = P4_FUNCCTX;
			pOp->p4.pCtx = pCtx;
			pOp->opcode = OP_Function;
			
		}
		case OP_Function: {
			int i;
			sqlite3_context *pCtx;

			assert(pOp->p4type == P4_FUNCCTX);
			pCtx = pOp->p4.pCtx;

			
			pOut = &aMem[pOp->p3];
			if (pCtx->pOut != pOut) {
				pCtx->pOut = pOut;
				for (i = pCtx->argc - 1; i >= 0; i--) pCtx->argv[i] = &aMem[pOp->p2 + i];
			}

			memAboutToChange(p, pCtx->pOut);
#ifdef SQLITE_DEBUG
			for (i = 0; i<pCtx->argc; i++) {
				assert(memIsValid(pCtx->argv[i]));
				REGISTER_TRACE(pOp->p2 + i, pCtx->argv[i]);
			}
#endif
			MemSetTypeFlag(pCtx->pOut, MEM_Null);
			pCtx->fErrorOrAux = 0;
			db->lastRowid = lastRowid;
			(*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);
			lastRowid = db->lastRowid;  

										
			if (pCtx->fErrorOrAux) {
				if (pCtx->isError) {
					sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx->pOut));
					rc = pCtx->isError;
				}
				sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
				if (rc) goto abort_due_to_error;
			}

			
			if (pOut->flags & (MEM_Str | MEM_Blob)) {
				sqlite3VdbeChangeEncoding(pCtx->pOut, encoding);
				if (sqlite3VdbeMemTooBig(pCtx->pOut)) goto too_big;
			}

			REGISTER_TRACE(pOp->p3, pCtx->pOut);
			UPDATE_MAX_BLOBSIZE(pCtx->pOut);
			break;
		}

						  
						  
						  
						  
		case OP_BitAnd:                 
		case OP_BitOr:                  
		case OP_ShiftLeft:              
		case OP_ShiftRight: {           
			i64 iA;
			u64 uA;
			i64 iB;
			u8 op;

			pIn1 = &aMem[pOp->p1];
			pIn2 = &aMem[pOp->p2];
			pOut = &aMem[pOp->p3];
			if ((pIn1->flags | pIn2->flags) & MEM_Null) {
				sqlite3VdbeMemSetNull(pOut);
				break;
			}
			iA = sqlite3VdbeIntValue(pIn2);
			iB = sqlite3VdbeIntValue(pIn1);
			op = pOp->opcode;
			if (op == OP_BitAnd) {
				iA &= iB;
			}
			else if (op == OP_BitOr) {
				iA |= iB;
			}
			else if (iB != 0) {
				assert(op == OP_ShiftRight || op == OP_ShiftLeft);

				
				if (iB<0) {
					assert(OP_ShiftRight == OP_ShiftLeft + 1);
					op = 2 * OP_ShiftLeft + 1 - op;
					iB = iB>(-64) ? -iB : 64;
				}

				if (iB >= 64) {
					iA = (iA >= 0 || op == OP_ShiftLeft) ? 0 : -1;
				}
				else {
					memcpy(&uA, &iA, sizeof(uA));
					if (op == OP_ShiftLeft) {
						uA <<= iB;
					}
					else {
						uA >>= iB;
						
						if (iA<0) uA |= ((((u64)0xffffffff) << 32) | 0xffffffff) << (64 - iB);
					}
					memcpy(&iA, &uA, sizeof(iA));
				}
			}
			pOut->u.i = iA;
			MemSetTypeFlag(pOut, MEM_Int);
			break;
		}

							
		case OP_AddImm: {            
			pIn1 = &aMem[pOp->p1];
			memAboutToChange(p, pIn1);
			sqlite3VdbeMemIntegerify(pIn1);
			pIn1->u.i += pOp->p2;
			break;
		}

						
		case OP_MustBeInt: {            
			pIn1 = &aMem[pOp->p1];
			if ((pIn1->flags & MEM_Int) == 0) {
				applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding);
				VdbeBranchTaken((pIn1->flags&MEM_Int) == 0, 2);
				if ((pIn1->flags & MEM_Int) == 0) {
					if (pOp->p2 == 0) {
						rc = SQLITE_MISMATCH;
						goto abort_due_to_error;
					}
					else {
						goto jump_to_p2;
					}
				}
			}
			MemSetTypeFlag(pIn1, MEM_Int);
			break;
		}

#ifndef SQLITE_OMIT_FLOATING_POINT
						   
		case OP_RealAffinity: {                  
			pIn1 = &aMem[pOp->p1];
			if (pIn1->flags & MEM_Int) {
				sqlite3VdbeMemRealify(pIn1);
			}
			break;
		}
#endif

#ifndef SQLITE_OMIT_CAST
							  
		case OP_Cast: {                  
			assert(pOp->p2 >= SQLITE_AFF_BLOB && pOp->p2 <= SQLITE_AFF_REAL);
			testcase(pOp->p2 == SQLITE_AFF_TEXT);
			testcase(pOp->p2 == SQLITE_AFF_BLOB);
			testcase(pOp->p2 == SQLITE_AFF_NUMERIC);
			testcase(pOp->p2 == SQLITE_AFF_INTEGER);
			testcase(pOp->p2 == SQLITE_AFF_REAL);
			pIn1 = &aMem[pOp->p1];
			memAboutToChange(p, pIn1);
			rc = ExpandBlob(pIn1);
			sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);
			UPDATE_MAX_BLOBSIZE(pIn1);
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

					  
					  
					  
					  
					  
					  
		case OP_Eq:               
		case OP_Ne:               
		case OP_Lt:               
		case OP_Le:               
		case OP_Gt:               
		case OP_Ge: {             
			int res, res2;      
			char affinity;      
			u16 flags1;         
			u16 flags3;         

			pIn1 = &aMem[pOp->p1];
			pIn3 = &aMem[pOp->p3];
			flags1 = pIn1->flags;
			flags3 = pIn3->flags;
			if ((flags1 | flags3)&MEM_Null) {
				
				if (pOp->p5 & SQLITE_NULLEQ) {
					
					assert(pOp->opcode == OP_Eq || pOp->opcode == OP_Ne);
					assert((flags1 & MEM_Cleared) == 0);
					assert((pOp->p5 & SQLITE_JUMPIFNULL) == 0);
					if ((flags1&MEM_Null) != 0
						&& (flags3&MEM_Null) != 0
						&& (flags3&MEM_Cleared) == 0
						) {
						res = 0;  
					}
					else {
						res = 1;  
					}
				}
				else {
					
					if (pOp->p5 & SQLITE_STOREP2) {
						pOut = &aMem[pOp->p2];
						iCompare = 1;    
						memAboutToChange(p, pOut);
						MemSetTypeFlag(pOut, MEM_Null);
						REGISTER_TRACE(pOp->p2, pOut);
					}
					else {
						VdbeBranchTaken(2, 3);
						if (pOp->p5 & SQLITE_JUMPIFNULL) {
							goto jump_to_p2;
						}
					}
					break;
				}
			}
			else {
				
				affinity = pOp->p5 & SQLITE_AFF_MASK;
				if (affinity >= SQLITE_AFF_NUMERIC) {
					if ((flags1 | flags3)&MEM_Str) {
						if ((flags1 & (MEM_Int | MEM_Real | MEM_Str)) == MEM_Str) {
							applyNumericAffinity(pIn1, 0);
							testcase(flags3 != pIn3->flags); 
							flags3 = pIn3->flags;
						}
						if ((flags3 & (MEM_Int | MEM_Real | MEM_Str)) == MEM_Str) {
							applyNumericAffinity(pIn3, 0);
						}
					}
					
					if ((pIn1->flags & pIn3->flags & MEM_Int) != 0) {
						if (pIn3->u.i > pIn1->u.i) { res = +1; goto compare_op; }
						if (pIn3->u.i < pIn1->u.i) { res = -1; goto compare_op; }
						res = 0;
						goto compare_op;
					}
				}
				else if (affinity == SQLITE_AFF_TEXT) {
					if ((flags1 & MEM_Str) == 0 && (flags1 & (MEM_Int | MEM_Real)) != 0) {
						testcase(pIn1->flags & MEM_Int);
						testcase(pIn1->flags & MEM_Real);
						sqlite3VdbeMemStringify(pIn1, encoding, 1);
						testcase((flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn));
						flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);
						assert(pIn1 != pIn3);
					}
					if ((flags3 & MEM_Str) == 0 && (flags3 & (MEM_Int | MEM_Real)) != 0) {
						testcase(pIn3->flags & MEM_Int);
						testcase(pIn3->flags & MEM_Real);
						sqlite3VdbeMemStringify(pIn3, encoding, 1);
						testcase((flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn));
						flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);
					}
				}
				assert(pOp->p4type == P4_COLLSEQ || pOp->p4.pColl == 0);
				res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);
			}
		compare_op:
			switch (pOp->opcode) {
			case OP_Eq:    res2 = res == 0;     break;
			case OP_Ne:    res2 = res;        break;
			case OP_Lt:    res2 = res<0;      break;
			case OP_Le:    res2 = res <= 0;     break;
			case OP_Gt:    res2 = res>0;      break;
			default:       res2 = res >= 0;     break;
			}

			
			assert((pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn));
			pIn1->flags = flags1;
			assert((pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn));
			pIn3->flags = flags3;

			if (pOp->p5 & SQLITE_STOREP2) {
				pOut = &aMem[pOp->p2];
				iCompare = res;
				res2 = res2 != 0;  
				if ((pOp->p5 & SQLITE_KEEPNULL) != 0) {
					
					assert(pOp->opcode == OP_Ne || pOp->opcode == OP_Eq);
					assert(res2 == 0 || res2 == 1);
					testcase(res2 == 0 && pOp->opcode == OP_Eq);
					testcase(res2 == 1 && pOp->opcode == OP_Eq);
					testcase(res2 == 0 && pOp->opcode == OP_Ne);
					testcase(res2 == 1 && pOp->opcode == OP_Ne);
					if ((pOp->opcode == OP_Eq) == res2) break;
				}
				memAboutToChange(p, pOut);
				MemSetTypeFlag(pOut, MEM_Int);
				pOut->u.i = res2;
				REGISTER_TRACE(pOp->p2, pOut);
			}
			else {
				VdbeBranchTaken(res != 0, (pOp->p5 & SQLITE_NULLEQ) ? 2 : 3);
				if (res2) {
					goto jump_to_p2;
				}
			}
			break;
		}

					
		case OP_ElseNotEq: {       
			assert(pOp>aOp);
			assert(pOp[-1].opcode == OP_Lt || pOp[-1].opcode == OP_Gt);
			assert(pOp[-1].p5 & SQLITE_STOREP2);
			VdbeBranchTaken(iCompare != 0, 2);
			if (iCompare != 0) goto jump_to_p2;
			break;
		}


						   
		case OP_Permutation: {
			assert(pOp->p4type == P4_INTARRAY);
			assert(pOp->p4.ai);
			aPermute = pOp->p4.ai + 1;
			break;
		}

							 
		case OP_Compare: {
			int n;
			int i;
			int p1;
			int p2;
			const KeyInfo *pKeyInfo;
			int idx;
			CollSeq *pColl;    
			int bRev;          

			if ((pOp->p5 & OPFLAG_PERMUTE) == 0) aPermute = 0;
			n = pOp->p3;
			pKeyInfo = pOp->p4.pKeyInfo;
			assert(n>0);
			assert(pKeyInfo != 0);
			p1 = pOp->p1;
			p2 = pOp->p2;
#if SQLITE_DEBUG
			if (aPermute) {
				int k, mx = 0;
				for (k = 0; k<n; k++) if (aPermute[k]>mx) mx = aPermute[k];
				assert(p1>0 && p1 + mx <= (p->nMem + 1 - p->nCursor) + 1);
				assert(p2>0 && p2 + mx <= (p->nMem + 1 - p->nCursor) + 1);
			}
			else {
				assert(p1>0 && p1 + n <= (p->nMem + 1 - p->nCursor) + 1);
				assert(p2>0 && p2 + n <= (p->nMem + 1 - p->nCursor) + 1);
			}
#endif 
			for (i = 0; i<n; i++) {
				idx = aPermute ? aPermute[i] : i;
				assert(memIsValid(&aMem[p1 + idx]));
				assert(memIsValid(&aMem[p2 + idx]));
				REGISTER_TRACE(p1 + idx, &aMem[p1 + idx]);
				REGISTER_TRACE(p2 + idx, &aMem[p2 + idx]);
				assert(i<pKeyInfo->nField);
				pColl = pKeyInfo->aColl[i];
				bRev = pKeyInfo->aSortOrder[i];
				iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);
				if (iCompare) {
					if (bRev) iCompare = -iCompare;
					break;
				}
			}
			aPermute = 0;
			break;
		}

						 
		case OP_Jump: {             
			if (iCompare<0) {
				VdbeBranchTaken(0, 3); pOp = &aOp[pOp->p1 - 1];
			}
			else if (iCompare == 0) {
				VdbeBranchTaken(1, 3); pOp = &aOp[pOp->p2 - 1];
			}
			else {
				VdbeBranchTaken(2, 3); pOp = &aOp[pOp->p3 - 1];
			}
			break;
		}

					  
					  
		case OP_And:              
		case OP_Or: {             
			int v1;    
			int v2;    

			pIn1 = &aMem[pOp->p1];
			if (pIn1->flags & MEM_Null) {
				v1 = 2;
			}
			else {
				v1 = sqlite3VdbeIntValue(pIn1) != 0;
			}
			pIn2 = &aMem[pOp->p2];
			if (pIn2->flags & MEM_Null) {
				v2 = 2;
			}
			else {
				v2 = sqlite3VdbeIntValue(pIn2) != 0;
			}
			if (pOp->opcode == OP_And) {
				static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
				v1 = and_logic[v1 * 3 + v2];
			}
			else {
				static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };
				v1 = or_logic[v1 * 3 + v2];
			}
			pOut = &aMem[pOp->p3];
			if (v1 == 2) {
				MemSetTypeFlag(pOut, MEM_Null);
			}
			else {
				pOut->u.i = v1;
				MemSetTypeFlag(pOut, MEM_Int);
			}
			break;
		}

					
		case OP_Not: {                
			pIn1 = &aMem[pOp->p1];
			pOut = &aMem[pOp->p2];
			sqlite3VdbeMemSetNull(pOut);
			if ((pIn1->flags & MEM_Null) == 0) {
				pOut->flags = MEM_Int;
				pOut->u.i = !sqlite3VdbeIntValue(pIn1);
			}
			break;
		}

					 
		case OP_BitNot: {             
			pIn1 = &aMem[pOp->p1];
			pOut = &aMem[pOp->p2];
			sqlite3VdbeMemSetNull(pOut);
			if ((pIn1->flags & MEM_Null) == 0) {
				pOut->flags = MEM_Int;
				pOut->u.i = ~sqlite3VdbeIntValue(pIn1);
			}
			break;
		}

						
		case OP_Once: {             
			assert(p->aOp[0].opcode == OP_Init);
			VdbeBranchTaken(p->aOp[0].p1 == pOp->p1, 2);
			if (p->aOp[0].p1 == pOp->p1) {
				goto jump_to_p2;
			}
			else {
				pOp->p1 = p->aOp[0].p1;
			}
			break;
		}

					  
					  
		case OP_If:                 
		case OP_IfNot: {            
			int c;
			pIn1 = &aMem[pOp->p1];
			if (pIn1->flags & MEM_Null) {
				c = pOp->p3;
			}
			else {
#ifdef SQLITE_OMIT_FLOATING_POINT
				c = sqlite3VdbeIntValue(pIn1) != 0;
#else
				c = sqlite3VdbeRealValue(pIn1) != 0.0;
#endif
				if (pOp->opcode == OP_IfNot) c = !c;
			}
			VdbeBranchTaken(c != 0, 2);
			if (c) {
				goto jump_to_p2;
			}
			break;
		}

					   
		case OP_IsNull: {            
			pIn1 = &aMem[pOp->p1];
			VdbeBranchTaken((pIn1->flags & MEM_Null) != 0, 2);
			if ((pIn1->flags & MEM_Null) != 0) {
				goto jump_to_p2;
			}
			break;
		}

						
		case OP_NotNull: {            
			pIn1 = &aMem[pOp->p1];
			VdbeBranchTaken((pIn1->flags & MEM_Null) == 0, 2);
			if ((pIn1->flags & MEM_Null) == 0) {
				goto jump_to_p2;
			}
			break;
		}

						 
		case OP_Column: {
			int p2;            
			VdbeCursor *pC;    
			BtCursor *pCrsr;   
			u32 *aOffset;      
			int len;           
			int i;             
			Mem *pDest;        
			Mem sMem;          
			const u8 *zData;   
			const u8 *zHdr;    
			const u8 *zEndHdr; 
			u32 offset;        
			u64 offset64;      
			u32 avail;         
			u32 t;             
			Mem *pReg;         

			pC = p->apCsr[pOp->p1];
			p2 = pOp->p2;

			
			rc = sqlite3VdbeCursorMoveto(&pC, &p2);
			if (rc) goto abort_due_to_error;

			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			pDest = &aMem[pOp->p3];
			memAboutToChange(p, pDest);
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(pC != 0);
			assert(p2<pC->nField);
			aOffset = pC->aOffset;
			assert(pC->eCurType != CURTYPE_VTAB);
			assert(pC->eCurType != CURTYPE_PSEUDO || pC->nullRow);
			assert(pC->eCurType != CURTYPE_SORTER);
			pCrsr = pC->uc.pCursor;

			if (pC->cacheStatus != p->cacheCtr) {                
				if (pC->nullRow) {
					if (pC->eCurType == CURTYPE_PSEUDO) {
						assert(pC->uc.pseudoTableReg>0);
						pReg = &aMem[pC->uc.pseudoTableReg];
						assert(pReg->flags & MEM_Blob);
						assert(memIsValid(pReg));
						pC->payloadSize = pC->szRow = avail = pReg->n;
						pC->aRow = (u8*)pReg->z;
					}
					else {
						sqlite3VdbeMemSetNull(pDest);
						goto op_column_out;
					}
				}
				else {
					assert(pC->eCurType == CURTYPE_BTREE);
					assert(pCrsr);
					assert(sqlite3BtreeCursorIsValid(pCrsr));
					pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);
					pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &avail);
					assert(avail <= 65536);  
					if (pC->payloadSize <= (u32)avail) {
						pC->szRow = pC->payloadSize;
					}
					else if (pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH]) {
						goto too_big;
					}
					else {
						pC->szRow = avail;
					}
				}
				pC->cacheStatus = p->cacheCtr;
				pC->iHdrOffset = getVarint32(pC->aRow, offset);
				pC->nHdrParsed = 0;
				aOffset[0] = offset;


				if (avail<offset) {      
										 
					pC->aRow = 0;
					pC->szRow = 0;

					
					if (offset > 98307 || offset > pC->payloadSize) {
						rc = SQLITE_CORRUPT_BKPT;
						goto abort_due_to_error;
					}
				}
				else if (offset>0) { 
									 
					zData = pC->aRow;
					assert(pC->nHdrParsed <= p2);         
					goto op_column_read_header;
				}
			}

			
			if (pC->nHdrParsed <= p2) {
				
				if (pC->iHdrOffset<aOffset[0]) {
					
					if (pC->aRow == 0) {
						memset(&sMem, 0, sizeof(sMem));
						rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem);
						if (rc != SQLITE_OK) goto abort_due_to_error;
						zData = (u8*)sMem.z;
					}
					else {
						zData = pC->aRow;
					}

					
				op_column_read_header:
					i = pC->nHdrParsed;
					offset64 = aOffset[i];
					zHdr = zData + pC->iHdrOffset;
					zEndHdr = zData + aOffset[0];
					do {
						if ((t = zHdr[0])<0x80) {
							zHdr++;
							offset64 += sqlite3VdbeOneByteSerialTypeLen(t);
						}
						else {
							zHdr += sqlite3GetVarint32(zHdr, &t);
							offset64 += sqlite3VdbeSerialTypeLen(t);
						}
						pC->aType[i++] = t;
						aOffset[i] = (u32)(offset64 & 0xffffffff);
					} while (i <= p2 && zHdr<zEndHdr);

					
					if ((zHdr >= zEndHdr && (zHdr>zEndHdr || offset64 != pC->payloadSize))
						|| (offset64 > pC->payloadSize)
						) {
						if (pC->aRow == 0) sqlite3VdbeMemRelease(&sMem);
						rc = SQLITE_CORRUPT_BKPT;
						goto abort_due_to_error;
					}

					pC->nHdrParsed = i;
					pC->iHdrOffset = (u32)(zHdr - zData);
					if (pC->aRow == 0) sqlite3VdbeMemRelease(&sMem);
				}
				else {
					t = 0;
				}

				
				if (pC->nHdrParsed <= p2) {
					if (pOp->p4type == P4_MEM) {
						sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, MEM_Static);
					}
					else {
						sqlite3VdbeMemSetNull(pDest);
					}
					goto op_column_out;
				}
			}
			else {
				t = pC->aType[p2];
			}

			
			assert(p2<pC->nHdrParsed);
			assert(rc == SQLITE_OK);
			assert(sqlite3VdbeCheckMemInvariants(pDest));
			if (VdbeMemDynamic(pDest)) {
				sqlite3VdbeMemSetNull(pDest);
			}
			assert(t == pC->aType[p2]);
			if (pC->szRow >= aOffset[p2 + 1]) {
				
				zData = pC->aRow + aOffset[p2];
				if (t<12) {
					sqlite3VdbeSerialGet(zData, t, pDest);
				}
				else {
					
					static const u16 aFlag[] = { MEM_Blob, MEM_Str | MEM_Term };
					pDest->n = len = (t - 12) / 2;
					pDest->enc = encoding;
					if (pDest->szMalloc < len + 2) {
						pDest->flags = MEM_Null;
						if (sqlite3VdbeMemGrow(pDest, len + 2, 0)) goto no_mem;
					}
					else {
						pDest->z = pDest->zMalloc;
					}
					memcpy(pDest->z, zData, len);
					pDest->z[len] = 0;
					pDest->z[len + 1] = 0;
					pDest->flags = aFlag[t & 1];
				}
			}
			else {
				pDest->enc = encoding;
				
				if (((pOp->p5 & (OPFLAG_LENGTHARG | OPFLAG_TYPEOFARG)) != 0
					&& ((t >= 12 && (t & 1) == 0) || (pOp->p5 & OPFLAG_TYPEOFARG) != 0))
					|| (len = sqlite3VdbeSerialTypeLen(t)) == 0
					) {
					
					static u8 aZero[8];  
					sqlite3VdbeSerialGet(aZero, t, pDest);
				}
				else {
					rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable,
						pDest);
					if (rc != SQLITE_OK) goto abort_due_to_error;
					sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);
					pDest->flags &= ~MEM_Ephem;
				}
			}

		op_column_out:
			UPDATE_MAX_BLOBSIZE(pDest);
			REGISTER_TRACE(pOp->p3, pDest);
			break;
		}

						
		case OP_Affinity: {
			const char *zAffinity;   
			char cAff;               

			zAffinity = pOp->p4.z;
			assert(zAffinity != 0);
			assert(zAffinity[pOp->p2] == 0);
			pIn1 = &aMem[pOp->p1];
			while ((cAff = *(zAffinity++)) != 0) {
				assert(pIn1 <= &p->aMem[(p->nMem + 1 - p->nCursor)]);
				assert(memIsValid(pIn1));
				applyAffinity(pIn1, cAff, encoding);
				pIn1++;
			}
			break;
		}

						  
		case OP_MakeRecord: {
			u8 *zNewRecord;        
			Mem *pRec;             
			u64 nData;             
			int nHdr;              
			i64 nByte;             
			i64 nZero;             
			int nVarint;           
			u32 serial_type;       
			Mem *pData0;           
			Mem *pLast;            
			int nField;            
			char *zAffinity;       
			int file_format;       
			int i;                 
			int j;                 
			u32 len;               

								   
			nData = 0;         
			nHdr = 0;          
			nZero = 0;         
			nField = pOp->p1;
			zAffinity = pOp->p4.z;
			assert(nField>0 && pOp->p2>0 && pOp->p2 + nField <= (p->nMem + 1 - p->nCursor) + 1);
			pData0 = &aMem[nField];
			nField = pOp->p2;
			pLast = &pData0[nField - 1];
			file_format = p->minWriteFileFormat;

			
			assert(pOp->p3<pOp->p1 || pOp->p3 >= pOp->p1 + pOp->p2);
			pOut = &aMem[pOp->p3];
			memAboutToChange(p, pOut);

			
			assert(pData0 <= pLast);
			if (zAffinity) {
				pRec = pData0;
				do {
					applyAffinity(pRec++, *(zAffinity++), encoding);
					assert(zAffinity[0] == 0 || pRec <= pLast);
				} while (zAffinity[0]);
			}

			
			pRec = pLast;
			do {
				assert(memIsValid(pRec));
				pRec->uTemp = serial_type = sqlite3VdbeSerialType(pRec, file_format, &len);
				if (pRec->flags & MEM_Zero) {
					if (nData) {
						if (sqlite3VdbeMemExpandBlob(pRec)) goto no_mem;
					}
					else {
						nZero += pRec->u.nZero;
						len -= pRec->u.nZero;
					}
				}
				nData += len;
				testcase(serial_type == 127);
				testcase(serial_type == 128);
				nHdr += serial_type <= 127 ? 1 : sqlite3VarintLen(serial_type);
				if (pRec == pData0) break;
				pRec--;
			} while (1);

			
			testcase(nHdr == 126);
			testcase(nHdr == 127);
			if (nHdr <= 126) {
				
				nHdr += 1;
			}
			else {
				
				nVarint = sqlite3VarintLen(nHdr);
				nHdr += nVarint;
				if (nVarint<sqlite3VarintLen(nHdr)) nHdr++;
			}
			nByte = nHdr + nData;
			if (nByte + nZero>db->aLimit[SQLITE_LIMIT_LENGTH]) {
				goto too_big;
			}

			
			if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {
				goto no_mem;
			}
			zNewRecord = (u8 *)pOut->z;

			
			i = putVarint32(zNewRecord, nHdr);
			j = nHdr;
			assert(pData0 <= pLast);
			pRec = pData0;
			do {
				serial_type = pRec->uTemp;
				
				i += putVarint32(&zNewRecord[i], serial_type);            
																		  
				j += sqlite3VdbeSerialPut(&zNewRecord[j], pRec, serial_type); 
			} while ((++pRec) <= pLast);
			assert(i == nHdr);
			assert(j == nByte);

			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			pOut->n = (int)nByte;
			pOut->flags = MEM_Blob;
			if (nZero) {
				pOut->u.nZero = nZero;
				pOut->flags |= MEM_Zero;
			}
			pOut->enc = SQLITE_UTF8;  
			REGISTER_TRACE(pOp->p3, pOut);
			UPDATE_MAX_BLOBSIZE(pOut);
			break;
		}

							
#ifndef SQLITE_OMIT_BTREECOUNT
		case OP_Count: {         
			i64 nEntry;
			BtCursor *pCrsr;

			assert(p->apCsr[pOp->p1]->eCurType == CURTYPE_BTREE);
			pCrsr = p->apCsr[pOp->p1]->uc.pCursor;
			assert(pCrsr);
			nEntry = 0;  
			rc = sqlite3BtreeCount(pCrsr, &nEntry);
			if (rc) goto abort_due_to_error;
			pOut = out2Prerelease(p, pOp);
			pOut->u.i = nEntry;
			break;
		}
#endif

					   
		case OP_Savepoint: {
			int p1;                         
			char *zName;                    
			int nName;
			Savepoint *pNew;
			Savepoint *pSavepoint;
			Savepoint *pTmp;
			int iSavepoint;
			int ii;

			p1 = pOp->p1;
			zName = pOp->p4.z;

			
			assert(db->pSavepoint == 0 || db->autoCommit == 0);
			assert(p1 == SAVEPOINT_BEGIN || p1 == SAVEPOINT_RELEASE || p1 == SAVEPOINT_ROLLBACK);
			assert(db->pSavepoint || db->isTransactionSavepoint == 0);
			assert(checkSavepointCount(db));
			assert(p->bIsReader);

			if (p1 == SAVEPOINT_BEGIN) {
				if (db->nVdbeWrite>0) {
					
					sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress");
					rc = SQLITE_BUSY;
				}
				else {
					nName = sqlite3Strlen30(zName);

#ifndef SQLITE_OMIT_VIRTUALTABLE
					
					assert(db->autoCommit == 0 || db->nVTrans == 0);
					rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN,
						db->nStatement + db->nSavepoint);
					if (rc != SQLITE_OK) goto abort_due_to_error;
#endif

					
					pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);
					if (pNew) {
						pNew->zName = (char *)&pNew[1];
						memcpy(pNew->zName, zName, nName + 1);

						
						if (db->autoCommit) {
							db->autoCommit = 0;
							db->isTransactionSavepoint = 1;
						}
						else {
							db->nSavepoint++;
						}

						
						pNew->pNext = db->pSavepoint;
						db->pSavepoint = pNew;
						pNew->nDeferredCons = db->nDeferredCons;
						pNew->nDeferredImmCons = db->nDeferredImmCons;
					}
				}
			}
			else {
				iSavepoint = 0;

				
				for (
					pSavepoint = db->pSavepoint;
					pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName);
					pSavepoint = pSavepoint->pNext
					) {
					iSavepoint++;
				}
				if (!pSavepoint) {
					sqlite3VdbeError(p, "no such savepoint: %s", zName);
					rc = SQLITE_ERROR;
				}
				else if (db->nVdbeWrite>0 && p1 == SAVEPOINT_RELEASE) {
					
					sqlite3VdbeError(p, "cannot release savepoint - "
						"SQL statements in progress");
					rc = SQLITE_BUSY;
				}
				else {

					
					int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;
					if (isTransaction && p1 == SAVEPOINT_RELEASE) {
						if ((rc = sqlite3VdbeCheckFk(p, 1)) != SQLITE_OK) {
							goto vdbe_return;
						}
						db->autoCommit = 1;
						if (sqlite3VdbeHalt(p) == SQLITE_BUSY) {
							p->pc = (int)(pOp - aOp);
							db->autoCommit = 0;
							p->rc = rc = SQLITE_BUSY;
							goto vdbe_return;
						}
						db->isTransactionSavepoint = 0;
						rc = p->rc;
					}
					else {
						int isSchemaChange;
						iSavepoint = db->nSavepoint - iSavepoint - 1;
						if (p1 == SAVEPOINT_ROLLBACK) {
							isSchemaChange = (db->flags & SQLITE_InternChanges) != 0;
							for (ii = 0; ii<db->nDb; ii++) {
								rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt,
									SQLITE_ABORT_ROLLBACK,
									isSchemaChange == 0);
								if (rc != SQLITE_OK) goto abort_due_to_error;
							}
						}
						else {
							isSchemaChange = 0;
						}
						for (ii = 0; ii<db->nDb; ii++) {
							rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);
							if (rc != SQLITE_OK) {
								goto abort_due_to_error;
							}
						}
						if (isSchemaChange) {
							sqlite3ExpirePreparedStatements(db);
							sqlite3ResetAllSchemasOfConnection(db);
							db->flags = (db->flags | SQLITE_InternChanges);
						}
					}

					
					while (db->pSavepoint != pSavepoint) {
						pTmp = db->pSavepoint;
						db->pSavepoint = pTmp->pNext;
						sqlite3DbFree(db, pTmp);
						db->nSavepoint--;
					}

					
					if (p1 == SAVEPOINT_RELEASE) {
						assert(pSavepoint == db->pSavepoint);
						db->pSavepoint = pSavepoint->pNext;
						sqlite3DbFree(db, pSavepoint);
						if (!isTransaction) {
							db->nSavepoint--;
						}
					}
					else {
						db->nDeferredCons = pSavepoint->nDeferredCons;
						db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
					}

					if (!isTransaction || p1 == SAVEPOINT_ROLLBACK) {
						rc = sqlite3VtabSavepoint(db, p1, iSavepoint);
						if (rc != SQLITE_OK) goto abort_due_to_error;
					}
				}
			}
			if (rc) goto abort_due_to_error;

			break;
		}

						   
		case OP_AutoCommit: {
			int desiredAutoCommit;
			int iRollback;

			desiredAutoCommit = pOp->p1;
			iRollback = pOp->p2;
			assert(desiredAutoCommit == 1 || desiredAutoCommit == 0);
			assert(desiredAutoCommit == 1 || iRollback == 0);
			assert(db->nVdbeActive>0);  
			assert(p->bIsReader);

			if (desiredAutoCommit != db->autoCommit) {
				if (iRollback) {
					assert(desiredAutoCommit == 1);
					sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
					db->autoCommit = 1;
				}
				else if (desiredAutoCommit && db->nVdbeWrite>0) {
					
					sqlite3VdbeError(p, "cannot commit transaction - "
						"SQL statements in progress");
					rc = SQLITE_BUSY;
					goto abort_due_to_error;
				}
				else if ((rc = sqlite3VdbeCheckFk(p, 1)) != SQLITE_OK) {
					goto vdbe_return;
				}
				else {
					db->autoCommit = (u8)desiredAutoCommit;
				}
				if (sqlite3VdbeHalt(p) == SQLITE_BUSY) {
					p->pc = (int)(pOp - aOp);
					db->autoCommit = (u8)(1 - desiredAutoCommit);
					p->rc = rc = SQLITE_BUSY;
					goto vdbe_return;
				}
				assert(db->nStatement == 0);
				sqlite3CloseSavepoints(db);
				if (p->rc == SQLITE_OK) {
					rc = SQLITE_DONE;
				}
				else {
					rc = SQLITE_ERROR;
				}
				goto vdbe_return;
			}
			else {
				sqlite3VdbeError(p,
					(!desiredAutoCommit) ? "cannot start a transaction within a transaction" : (
					(iRollback) ? "cannot rollback - no transaction is active" :
						"cannot commit - no transaction is active"));

				rc = SQLITE_ERROR;
				goto abort_due_to_error;
			}
			break;
		}

							
		case OP_Transaction: {
			Btree *pBt;
			int iMeta;
			int iGen;

			assert(p->bIsReader);
			assert(p->readOnly == 0 || pOp->p2 == 0);
			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			assert(DbMaskTest(p->btreeMask, pOp->p1));
			if (pOp->p2 && (db->flags & SQLITE_QueryOnly) != 0) {
				rc = SQLITE_READONLY;
				goto abort_due_to_error;
			}
			pBt = db->aDb[pOp->p1].pBt;

			if (pBt) {
				rc = sqlite3BtreeBeginTrans(pBt, pOp->p2);
				testcase(rc == SQLITE_BUSY_SNAPSHOT);
				testcase(rc == SQLITE_BUSY_RECOVERY);
				if (rc != SQLITE_OK) {
					if ((rc & 0xff) == SQLITE_BUSY) {
						p->pc = (int)(pOp - aOp);
						p->rc = rc;
						goto vdbe_return;
					}
					goto abort_due_to_error;
				}

				if (pOp->p2 && p->usesStmtJournal
					&& (db->autoCommit == 0 || db->nVdbeRead>1)
					) {
					assert(sqlite3BtreeIsInTrans(pBt));
					if (p->iStatement == 0) {
						assert(db->nStatement >= 0 && db->nSavepoint >= 0);
						db->nStatement++;
						p->iStatement = db->nSavepoint + db->nStatement;
					}

					rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, p->iStatement - 1);
					if (rc == SQLITE_OK) {
						rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);
					}

					
					p->nStmtDefCons = db->nDeferredCons;
					p->nStmtDefImmCons = db->nDeferredImmCons;
				}

				
				sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&iMeta);
				iGen = db->aDb[pOp->p1].pSchema->iGeneration;
			}
			else {
				iGen = iMeta = 0;
			}
			assert(pOp->p5 == 0 || pOp->p4type == P4_INT32);
			if (pOp->p5 && (iMeta != pOp->p3 || iGen != pOp->p4.i)) {
				sqlite3DbFree(db, p->zErrMsg);
				p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
				
				if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {
					sqlite3ResetOneSchema(db, pOp->p1);
				}
				p->expired = 1;
				rc = SQLITE_SCHEMA;
			}
			if (rc) goto abort_due_to_error;
			break;
		}

							 
		case OP_ReadCookie: {               
			int iMeta;
			int iDb;
			int iCookie;

			assert(p->bIsReader);
			iDb = pOp->p1;
			iCookie = pOp->p3;
			assert(pOp->p3<SQLITE_N_BTREE_META);
			assert(iDb >= 0 && iDb<db->nDb);
			assert(db->aDb[iDb].pBt != 0);
			assert(DbMaskTest(p->btreeMask, iDb));

			sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);
			pOut = out2Prerelease(p, pOp);
			pOut->u.i = iMeta;
			break;
		}

							
		case OP_SetCookie: {
			Db *pDb;
			assert(pOp->p2<SQLITE_N_BTREE_META);
			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			assert(DbMaskTest(p->btreeMask, pOp->p1));
			assert(p->readOnly == 0);
			pDb = &db->aDb[pOp->p1];
			assert(pDb->pBt != 0);
			assert(sqlite3SchemaMutexHeld(db, pOp->p1, 0));
			
			rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);
			if (pOp->p2 == BTREE_SCHEMA_VERSION) {
				
				pDb->pSchema->schema_cookie = pOp->p3;
				db->flags |= SQLITE_InternChanges;
			}
			else if (pOp->p2 == BTREE_FILE_FORMAT) {
				
				pDb->pSchema->file_format = pOp->p3;
			}
			if (pOp->p1 == 1) {
				
				sqlite3ExpirePreparedStatements(db);
				p->expired = 0;
			}
			if (rc) goto abort_due_to_error;
			break;
		}

						   
						   
						   
		case OP_ReopenIdx: {
			int nField;
			KeyInfo *pKeyInfo;
			int p2;
			int iDb;
			int wrFlag;
			Btree *pX;
			VdbeCursor *pCur;
			Db *pDb;

			assert(pOp->p5 == 0 || pOp->p5 == OPFLAG_SEEKEQ);
			assert(pOp->p4type == P4_KEYINFO);
			pCur = p->apCsr[pOp->p1];
			if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {
				assert(pCur->iDb == pOp->p3);      
				goto open_cursor_set_hints;
			}
			
		case OP_OpenRead:
		case OP_OpenWrite:

			assert(pOp->opcode == OP_OpenWrite || pOp->p5 == 0 || pOp->p5 == OPFLAG_SEEKEQ);
			assert(p->bIsReader);
			assert(pOp->opcode == OP_OpenRead || pOp->opcode == OP_ReopenIdx
				|| p->readOnly == 0);

			if (p->expired) {
				rc = SQLITE_ABORT_ROLLBACK;
				goto abort_due_to_error;
			}

			nField = 0;
			pKeyInfo = 0;
			p2 = pOp->p2;
			iDb = pOp->p3;
			assert(iDb >= 0 && iDb<db->nDb);
			assert(DbMaskTest(p->btreeMask, iDb));
			pDb = &db->aDb[iDb];
			pX = pDb->pBt;
			assert(pX != 0);
			if (pOp->opcode == OP_OpenWrite) {
				assert(OPFLAG_FORDELETE == BTREE_FORDELETE);
				wrFlag = BTREE_WRCSR | (pOp->p5 & OPFLAG_FORDELETE);
				assert(sqlite3SchemaMutexHeld(db, iDb, 0));
				if (pDb->pSchema->file_format < p->minWriteFileFormat) {
					p->minWriteFileFormat = pDb->pSchema->file_format;
				}
			}
			else {
				wrFlag = 0;
			}
			if (pOp->p5 & OPFLAG_P2ISREG) {
				assert(p2>0);
				assert(p2 <= (p->nMem + 1 - p->nCursor));
				pIn2 = &aMem[p2];
				assert(memIsValid(pIn2));
				assert((pIn2->flags & MEM_Int) != 0);
				sqlite3VdbeMemIntegerify(pIn2);
				p2 = (int)pIn2->u.i;
				
				assert(p2 >= 2);
			}
			if (pOp->p4type == P4_KEYINFO) {
				pKeyInfo = pOp->p4.pKeyInfo;
				assert(pKeyInfo->enc == ENC(db));
				assert(pKeyInfo->db == db);
				nField = pKeyInfo->nField + pKeyInfo->nXField;
			}
			else if (pOp->p4type == P4_INT32) {
				nField = pOp->p4.i;
			}
			assert(pOp->p1 >= 0);
			assert(nField >= 0);
			testcase(nField == 0);  
			pCur = allocateCursor(p, pOp->p1, nField, iDb, CURTYPE_BTREE);
			if (pCur == 0) goto no_mem;
			pCur->nullRow = 1;
			pCur->isOrdered = 1;
			pCur->pgnoRoot = p2;
#ifdef SQLITE_DEBUG
			pCur->wrFlag = wrFlag;
#endif
			rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);
			pCur->pKeyInfo = pKeyInfo;
			
			pCur->isTable = pOp->p4type != P4_KEYINFO;

		open_cursor_set_hints:
			assert(OPFLAG_BULKCSR == BTREE_BULKLOAD);
			assert(OPFLAG_SEEKEQ == BTREE_SEEK_EQ);
			testcase(pOp->p5 & OPFLAG_BULKCSR);
#ifdef SQLITE_ENABLE_CURSOR_HINTS
			testcase(pOp->p2 & OPFLAG_SEEKEQ);
#endif
			sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
				(pOp->p5 & (OPFLAG_BULKCSR | OPFLAG_SEEKEQ)));
			if (rc) goto abort_due_to_error;
			break;
		}

						   
						   
		case OP_OpenAutoindex:
		case OP_OpenEphemeral: {
			VdbeCursor *pCx;
			KeyInfo *pKeyInfo;

			static const int vfsFlags =
				SQLITE_OPEN_READWRITE |
				SQLITE_OPEN_CREATE |
				SQLITE_OPEN_EXCLUSIVE |
				SQLITE_OPEN_DELETEONCLOSE |
				SQLITE_OPEN_TRANSIENT_DB;
			assert(pOp->p1 >= 0);
			assert(pOp->p2 >= 0);
			pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);
			if (pCx == 0) goto no_mem;
			pCx->nullRow = 1;
			pCx->isEphemeral = 1;
			rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBt,
				BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);
			if (rc == SQLITE_OK) {
				rc = sqlite3BtreeBeginTrans(pCx->pBt, 1);
			}
			if (rc == SQLITE_OK) {
				
				if ((pKeyInfo = pOp->p4.pKeyInfo) != 0) {
					int pgno;
					assert(pOp->p4type == P4_KEYINFO);
					rc = sqlite3BtreeCreateTable(pCx->pBt, &pgno, BTREE_BLOBKEY | pOp->p5);
					if (rc == SQLITE_OK) {
						assert(pgno == MASTER_ROOT + 1);
						assert(pKeyInfo->db == db);
						assert(pKeyInfo->enc == ENC(db));
						pCx->pKeyInfo = pKeyInfo;
						rc = sqlite3BtreeCursor(pCx->pBt, pgno, BTREE_WRCSR,
							pKeyInfo, pCx->uc.pCursor);
					}
					pCx->isTable = 0;
				}
				else {
					rc = sqlite3BtreeCursor(pCx->pBt, MASTER_ROOT, BTREE_WRCSR,
						0, pCx->uc.pCursor);
					pCx->isTable = 1;
				}
			}
			if (rc) goto abort_due_to_error;
			pCx->isOrdered = (pOp->p5 != BTREE_UNORDERED);
			break;
		}

							   
		case OP_SorterOpen: {
			VdbeCursor *pCx;

			assert(pOp->p1 >= 0);
			assert(pOp->p2 >= 0);
			pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_SORTER);
			if (pCx == 0) goto no_mem;
			pCx->pKeyInfo = pOp->p4.pKeyInfo;
			assert(pCx->pKeyInfo->db == db);
			assert(pCx->pKeyInfo->enc == ENC(db));
			rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);
			if (rc) goto abort_due_to_error;
			break;
		}

							
		case OP_SequenceTest: {
			VdbeCursor *pC;
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(isSorter(pC));
			if ((pC->seqCount++) == 0) {
				goto jump_to_p2;
			}
			break;
		}

							  
		case OP_OpenPseudo: {
			VdbeCursor *pCx;

			assert(pOp->p1 >= 0);
			assert(pOp->p3 >= 0);
			pCx = allocateCursor(p, pOp->p1, pOp->p3, -1, CURTYPE_PSEUDO);
			if (pCx == 0) goto no_mem;
			pCx->nullRow = 1;
			pCx->uc.pseudoTableReg = pOp->p2;
			pCx->isTable = 1;
			assert(pOp->p5 == 0);
			break;
		}

							
		case OP_Close: {
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
			p->apCsr[pOp->p1] = 0;
			break;
		}

#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
					   
		case OP_ColumnsUsed: {
			VdbeCursor *pC;
			pC = p->apCsr[pOp->p1];
			assert(pC->eCurType == CURTYPE_BTREE);
			pC->maskUsed = *(u64*)pOp->p4.pI64;
			break;
		}
#endif

							 
							 
							 
							 
		case OP_SeekLT:         
		case OP_SeekLE:         
		case OP_SeekGE:         
		case OP_SeekGT: {       
			int res;           
			int oc;            
			VdbeCursor *pC;    
			UnpackedRecord r;  
			int nField;        
			i64 iKey;          
			int eqOnly;        

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(pOp->p2 != 0);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(OP_SeekLE == OP_SeekLT + 1);
			assert(OP_SeekGE == OP_SeekLT + 2);
			assert(OP_SeekGT == OP_SeekLT + 3);
			assert(pC->isOrdered);
			assert(pC->uc.pCursor != 0);
			oc = pOp->opcode;
			eqOnly = 0;
			pC->nullRow = 0;
#ifdef SQLITE_DEBUG
			pC->seekOp = pOp->opcode;
#endif

			if (pC->isTable) {
				
				assert(sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ) == 0);

				
				pIn3 = &aMem[pOp->p3];
				if ((pIn3->flags & (MEM_Int | MEM_Real | MEM_Str)) == MEM_Str) {
					applyNumericAffinity(pIn3, 0);
				}
				iKey = sqlite3VdbeIntValue(pIn3);

				
				if ((pIn3->flags & MEM_Int) == 0) {
					if ((pIn3->flags & MEM_Real) == 0) {
						
						VdbeBranchTaken(1, 2); goto jump_to_p2;
						break;
					}

					
					if (pIn3->u.r<(double)iKey) {
						assert(OP_SeekGE == (OP_SeekGT - 1));
						assert(OP_SeekLT == (OP_SeekLE - 1));
						assert((OP_SeekLE & 0x0001) == (OP_SeekGT & 0x0001));
						if ((oc & 0x0001) == (OP_SeekGT & 0x0001)) oc--;
					}

					
					else if (pIn3->u.r>(double)iKey) {
						assert(OP_SeekLE == (OP_SeekLT + 1));
						assert(OP_SeekGT == (OP_SeekGE + 1));
						assert((OP_SeekLT & 0x0001) == (OP_SeekGE & 0x0001));
						if ((oc & 0x0001) == (OP_SeekLT & 0x0001)) oc++;
					}
				}
				rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
				pC->movetoTarget = iKey;  
				if (rc != SQLITE_OK) {
					goto abort_due_to_error;
				}
			}
			else {
				
				if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ)) {
					eqOnly = 1;
					assert(pOp->opcode == OP_SeekGE || pOp->opcode == OP_SeekLE);
					assert(pOp[1].opcode == OP_IdxLT || pOp[1].opcode == OP_IdxGT);
					assert(pOp[1].p1 == pOp[0].p1);
					assert(pOp[1].p2 == pOp[0].p2);
					assert(pOp[1].p3 == pOp[0].p3);
					assert(pOp[1].p4.i == pOp[0].p4.i);
				}

				nField = pOp->p4.i;
				assert(pOp->p4type == P4_INT32);
				assert(nField>0);
				r.pKeyInfo = pC->pKeyInfo;
				r.nField = (u16)nField;

				
				r.default_rc = ((1 & (oc - OP_SeekLT)) ? -1 : +1);
				assert(oc != OP_SeekGT || r.default_rc == -1);
				assert(oc != OP_SeekLE || r.default_rc == -1);
				assert(oc != OP_SeekGE || r.default_rc == +1);
				assert(oc != OP_SeekLT || r.default_rc == +1);

				r.aMem = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
				{ int i; for (i = 0; i<r.nField; i++) assert(memIsValid(&r.aMem[i])); }
#endif
				r.eqSeen = 0;
				rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);
				if (rc != SQLITE_OK) {
					goto abort_due_to_error;
				}
				if (eqOnly && r.eqSeen == 0) {
					assert(res != 0);
					goto seek_not_found;
				}
			}
			pC->deferredMoveto = 0;
			pC->cacheStatus = CACHE_STALE;
#ifdef SQLITE_TEST
			sqlite3_search_count++;
#endif
			if (oc >= OP_SeekGE) {
				assert(oc == OP_SeekGE || oc == OP_SeekGT);
				if (res<0 || (res == 0 && oc == OP_SeekGT)) {
					res = 0;
					rc = sqlite3BtreeNext(pC->uc.pCursor, &res);
					if (rc != SQLITE_OK) goto abort_due_to_error;
				}
				else {
					res = 0;
				}
			}
			else {
				assert(oc == OP_SeekLT || oc == OP_SeekLE);
				if (res>0 || (res == 0 && oc == OP_SeekLT)) {
					res = 0;
					rc = sqlite3BtreePrevious(pC->uc.pCursor, &res);
					if (rc != SQLITE_OK) goto abort_due_to_error;
				}
				else {
					
					res = sqlite3BtreeEof(pC->uc.pCursor);
				}
			}
		seek_not_found:
			assert(pOp->p2>0);
			VdbeBranchTaken(res != 0, 2);
			if (res) {
				goto jump_to_p2;
			}
			else if (eqOnly) {
				assert(pOp[1].opcode == OP_IdxLT || pOp[1].opcode == OP_IdxGT);
				pOp++; 
			}
			break;
		}

						
						
						
		case OP_NoConflict:     
		case OP_NotFound:       
		case OP_Found: {        
			int alreadyExists;
			int takeJump;
			int ii;
			VdbeCursor *pC;
			int res;
			char *pFree;
			UnpackedRecord *pIdxKey;
			UnpackedRecord r;
			char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem) * 4 + 7];

#ifdef SQLITE_TEST
			if (pOp->opcode != OP_NoConflict) sqlite3_found_count++;
#endif

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(pOp->p4type == P4_INT32);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
#ifdef SQLITE_DEBUG
			pC->seekOp = pOp->opcode;
#endif
			pIn3 = &aMem[pOp->p3];
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			assert(pC->isTable == 0);
			pFree = 0;
			if (pOp->p4.i>0) {
				r.pKeyInfo = pC->pKeyInfo;
				r.nField = (u16)pOp->p4.i;
				r.aMem = pIn3;
#ifdef SQLITE_DEBUG
				for (ii = 0; ii<r.nField; ii++) {
					assert(memIsValid(&r.aMem[ii]));
					assert((r.aMem[ii].flags & MEM_Zero) == 0 || r.aMem[ii].n == 0);
					if (ii) REGISTER_TRACE(pOp->p3 + ii, &r.aMem[ii]);
				}
#endif
				pIdxKey = &r;
			}
			else {
				pIdxKey = sqlite3VdbeAllocUnpackedRecord(
					pC->pKeyInfo, aTempRec, sizeof(aTempRec), &pFree
				);
				if (pIdxKey == 0) goto no_mem;
				assert(pIn3->flags & MEM_Blob);
				(void)ExpandBlob(pIn3);
				sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);
			}
			pIdxKey->default_rc = 0;
			takeJump = 0;
			if (pOp->opcode == OP_NoConflict) {
				
				for (ii = 0; ii<pIdxKey->nField; ii++) {
					if (pIdxKey->aMem[ii].flags & MEM_Null) {
						takeJump = 1;
						break;
					}
				}
			}
			rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
			sqlite3DbFree(db, pFree);
			if (rc != SQLITE_OK) {
				goto abort_due_to_error;
			}
			pC->seekResult = res;
			alreadyExists = (res == 0);
			pC->nullRow = 1 - alreadyExists;
			pC->deferredMoveto = 0;
			pC->cacheStatus = CACHE_STALE;
			if (pOp->opcode == OP_Found) {
				VdbeBranchTaken(alreadyExists != 0, 2);
				if (alreadyExists) goto jump_to_p2;
			}
			else {
				VdbeBranchTaken(takeJump || alreadyExists == 0, 2);
				if (takeJump || !alreadyExists) goto jump_to_p2;
			}
			break;
		}

					   
					   
		case OP_SeekRowid: {        
			VdbeCursor *pC;
			BtCursor *pCrsr;
			int res;
			u64 iKey;

			pIn3 = &aMem[pOp->p3];
			if ((pIn3->flags & MEM_Int) == 0) {
				applyAffinity(pIn3, SQLITE_AFF_NUMERIC, encoding);
				if ((pIn3->flags & MEM_Int) == 0) goto jump_to_p2;
			}
			
		case OP_NotExists:          
			pIn3 = &aMem[pOp->p3];
			assert(pIn3->flags & MEM_Int);
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
#ifdef SQLITE_DEBUG
			pC->seekOp = 0;
#endif
			assert(pC->isTable);
			assert(pC->eCurType == CURTYPE_BTREE);
			pCrsr = pC->uc.pCursor;
			assert(pCrsr != 0);
			res = 0;
			iKey = pIn3->u.i;
			rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
			assert(rc == SQLITE_OK || res == 0);
			pC->movetoTarget = iKey;  
			pC->nullRow = 0;
			pC->cacheStatus = CACHE_STALE;
			pC->deferredMoveto = 0;
			VdbeBranchTaken(res != 0, 2);
			pC->seekResult = res;
			if (res != 0) {
				assert(rc == SQLITE_OK);
				if (pOp->p2 == 0) {
					rc = SQLITE_CORRUPT_BKPT;
				}
				else {
					goto jump_to_p2;
				}
			}
			if (rc) goto abort_due_to_error;
			break;
		}

						   
		case OP_Sequence: {           
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(p->apCsr[pOp->p1] != 0);
			assert(p->apCsr[pOp->p1]->eCurType != CURTYPE_VTAB);
			pOut = out2Prerelease(p, pOp);
			pOut->u.i = p->apCsr[pOp->p1]->seqCount++;
			break;
		}


						  
		case OP_NewRowid: {           
			i64 v;                 
			VdbeCursor *pC;        
			int res;               
			int cnt;               
			Mem *pMem;             
			VdbeFrame *pFrame;     

			v = 0;
			res = 0;
			pOut = out2Prerelease(p, pOp);
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			{
				
				assert(pC->isTable);

#ifdef SQLITE_32BIT_ROWID
#   define MAX_ROWID 0x7fffffff
#else
				
#   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
#endif

				if (!pC->useRandomRowid) {
					rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
					if (rc != SQLITE_OK) {
						goto abort_due_to_error;
					}
					if (res) {
						v = 1;   
					}
					else {
						assert(sqlite3BtreeCursorIsValid(pC->uc.pCursor));
						v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
						if (v >= MAX_ROWID) {
							pC->useRandomRowid = 1;
						}
						else {
							v++;   
						}
					}
				}

#ifndef SQLITE_OMIT_AUTOINCREMENT
				if (pOp->p3) {
					
					assert(pOp->p3>0);
					if (p->pFrame) {
						for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent);
						
						assert(pOp->p3 <= pFrame->nMem);
						pMem = &pFrame->aMem[pOp->p3];
					}
					else {
						
						assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));
						pMem = &aMem[pOp->p3];
						memAboutToChange(p, pMem);
					}
					assert(memIsValid(pMem));

					REGISTER_TRACE(pOp->p3, pMem);
					sqlite3VdbeMemIntegerify(pMem);
					assert((pMem->flags & MEM_Int) != 0);  
					if (pMem->u.i == MAX_ROWID || pC->useRandomRowid) {
						rc = SQLITE_FULL;   
						goto abort_due_to_error;
					}
					if (v<pMem->u.i + 1) {
						v = pMem->u.i + 1;
					}
					pMem->u.i = v;
				}
#endif
				if (pC->useRandomRowid) {
					
					assert(pOp->p3 == 0);  
					cnt = 0;
					do {
						sqlite3_randomness(sizeof(v), &v);
						v &= (MAX_ROWID >> 1); v++;  
					} while (((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
						0, &res)) == SQLITE_OK)
						&& (res == 0)
						&& (++cnt<100));
					if (rc) goto abort_due_to_error;
					if (res == 0) {
						rc = SQLITE_FULL;   
						goto abort_due_to_error;
					}
					assert(v>0);  
				}
				pC->deferredMoveto = 0;
				pC->cacheStatus = CACHE_STALE;
			}
			pOut->u.i = v;
			break;
		}

						  
						  
		case OP_Insert:
		case OP_InsertInt: {
			Mem *pData;       
			Mem *pKey;        
			VdbeCursor *pC;   
			int seekResult;   
			const char *zDb;  
			Table *pTab;      
			int op;           
			BtreePayload x;   

			op = 0;
			pData = &aMem[pOp->p2];
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(memIsValid(pData));
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			assert(pC->isTable);
			assert(pOp->p4type == P4_TABLE || pOp->p4type >= P4_STATIC);
			REGISTER_TRACE(pOp->p2, pData);

			if (pOp->opcode == OP_Insert) {
				pKey = &aMem[pOp->p3];
				assert(pKey->flags & MEM_Int);
				assert(memIsValid(pKey));
				REGISTER_TRACE(pOp->p3, pKey);
				x.nKey = pKey->u.i;
			}
			else {
				assert(pOp->opcode == OP_InsertInt);
				x.nKey = pOp->p3;
			}

			if (pOp->p4type == P4_TABLE && HAS_UPDATE_HOOK(db)) {
				assert(pC->isTable);
				assert(pC->iDb >= 0);
				zDb = db->aDb[pC->iDb].zDbSName;
				pTab = pOp->p4.pTab;
				assert(HasRowid(pTab));
				op = ((pOp->p5 & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT);
			}
			else {
				pTab = 0; 
				zDb = 0;  
			}

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
			
			if (db->xPreUpdateCallback
				&& pOp->p4type == P4_TABLE
				&& !(pOp->p5 & OPFLAG_ISUPDATE)
				) {
				sqlite3VdbePreUpdateHook(p, pC, SQLITE_INSERT, zDb, pTab, x.nKey, pOp->p2);
			}
#endif

			if (pOp->p5 & OPFLAG_NCHANGE) p->nChange++;
			if (pOp->p5 & OPFLAG_LASTROWID) db->lastRowid = lastRowid = x.nKey;
			if (pData->flags & MEM_Null) {
				x.pData = 0;
				x.nData = 0;
			}
			else {
				assert(pData->flags & (MEM_Blob | MEM_Str));
				x.pData = pData->z;
				x.nData = pData->n;
			}
			seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
			if (pData->flags & MEM_Zero) {
				x.nZero = pData->u.nZero;
			}
			else {
				x.nZero = 0;
			}
			x.pKey = 0;
			rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
				(pOp->p5 & OPFLAG_APPEND) != 0, seekResult
			);
			pC->deferredMoveto = 0;
			pC->cacheStatus = CACHE_STALE;

			
			if (rc) goto abort_due_to_error;
			if (db->xUpdateCallback && op) {
				db->xUpdateCallback(db->pUpdateArg, op, zDb, pTab->zName, x.nKey);
			}
			break;
		}

						   
		case OP_Delete: {
			VdbeCursor *pC;
			const char *zDb;
			Table *pTab;
			int opflags;

			opflags = pOp->p2;
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			assert(pC->deferredMoveto == 0);

#ifdef SQLITE_DEBUG
			if (pOp->p4type == P4_TABLE && HasRowid(pOp->p4.pTab) && pOp->p5 == 0) {
				
				i64 iKey = sqlite3BtreeIntegerKey(pC->uc.pCursor);
				assert(pC->movetoTarget == iKey);
			}
#endif

			
			if (pOp->p4type == P4_TABLE && HAS_UPDATE_HOOK(db)) {
				assert(pC->iDb >= 0);
				assert(pOp->p4.pTab != 0);
				zDb = db->aDb[pC->iDb].zDbSName;
				pTab = pOp->p4.pTab;
				if ((pOp->p5 & OPFLAG_SAVEPOSITION) != 0 && pC->isTable) {
					pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);
				}
			}
			else {
				zDb = 0;   
				pTab = 0;  
			}

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
			
			if (db->xPreUpdateCallback && pOp->p4.pTab && HasRowid(pTab)) {
				assert(!(opflags & OPFLAG_ISUPDATE) || (aMem[pOp->p3].flags & MEM_Int));
				sqlite3VdbePreUpdateHook(p, pC,
					(opflags & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_DELETE,
					zDb, pTab, pC->movetoTarget,
					pOp->p3
				);
			}
			if (opflags & OPFLAG_ISNOOP) break;
#endif

			
			assert((pOp->p5 & ~(OPFLAG_SAVEPOSITION | OPFLAG_AUXDELETE)) == 0);
			assert(OPFLAG_SAVEPOSITION == BTREE_SAVEPOSITION);
			assert(OPFLAG_AUXDELETE == BTREE_AUXDELETE);

#ifdef SQLITE_DEBUG
			if (p->pFrame == 0) {
				if (pC->isEphemeral == 0
					&& (pOp->p5 & OPFLAG_AUXDELETE) == 0
					&& (pC->wrFlag & OPFLAG_FORDELETE) == 0
					) {
					nExtraDelete++;
				}
				if (pOp->p2 & OPFLAG_NCHANGE) {
					nExtraDelete--;
				}
			}
#endif

			rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
			pC->cacheStatus = CACHE_STALE;
			if (rc) goto abort_due_to_error;

			
			if (opflags & OPFLAG_NCHANGE) {
				p->nChange++;
				if (db->xUpdateCallback && HasRowid(pTab)) {
					db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE, zDb, pTab->zName,
						pC->movetoTarget);
					assert(pC->iDb >= 0);
				}
			}

			break;
		}
						
		case OP_ResetCount: {
			sqlite3VdbeSetChanges(db, p->nChange);
			p->nChange = 0;
			break;
		}

							
		case OP_SorterCompare: {
			VdbeCursor *pC;
			int res;
			int nKeyCol;

			pC = p->apCsr[pOp->p1];
			assert(isSorter(pC));
			assert(pOp->p4type == P4_INT32);
			pIn3 = &aMem[pOp->p3];
			nKeyCol = pOp->p4.i;
			res = 0;
			rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);
			VdbeBranchTaken(res != 0, 2);
			if (rc) goto abort_due_to_error;
			if (res) goto jump_to_p2;
			break;
		};

							   
		case OP_SorterData: {
			VdbeCursor *pC;

			pOut = &aMem[pOp->p2];
			pC = p->apCsr[pOp->p1];
			assert(isSorter(pC));
			rc = sqlite3VdbeSorterRowkey(pC, pOut);
			assert(rc != SQLITE_OK || (pOut->flags & MEM_Blob));
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			if (rc) goto abort_due_to_error;
			p->apCsr[pOp->p3]->cacheStatus = CACHE_STALE;
			break;
		}

							
							
		case OP_RowKey:
		case OP_RowData: {
			VdbeCursor *pC;
			BtCursor *pCrsr;
			u32 n;

			pOut = &aMem[pOp->p2];
			memAboutToChange(p, pOut);

			
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(isSorter(pC) == 0);
			assert(pC->isTable || pOp->opcode != OP_RowData);
			assert(pC->isTable == 0 || pOp->opcode == OP_RowData);
			assert(pC->nullRow == 0);
			assert(pC->uc.pCursor != 0);
			pCrsr = pC->uc.pCursor;

			
			assert(pC->deferredMoveto == 0);
			assert(sqlite3BtreeCursorIsValid(pCrsr));
#if 0  
			rc = sqlite3VdbeCursorMoveto(pC);
			if (rc != SQLITE_OK) goto abort_due_to_error;
#endif

			n = sqlite3BtreePayloadSize(pCrsr);
			if (n>(u32)db->aLimit[SQLITE_LIMIT_LENGTH]) {
				goto too_big;
			}
			testcase(n == 0);
			if (sqlite3VdbeMemClearAndResize(pOut, MAX(n, 32))) {
				goto no_mem;
			}
			pOut->n = n;
			MemSetTypeFlag(pOut, MEM_Blob);
			if (pC->isTable == 0) {
				rc = sqlite3BtreeKey(pCrsr, 0, n, pOut->z);
			}
			else {
				rc = sqlite3BtreeData(pCrsr, 0, n, pOut->z);
			}
			if (rc) goto abort_due_to_error;
			pOut->enc = SQLITE_UTF8;  
			UPDATE_MAX_BLOBSIZE(pOut);
			REGISTER_TRACE(pOp->p2, pOut);
			break;
		}

						 
		case OP_Rowid: {                 
			VdbeCursor *pC;
			i64 v;
			sqlite3_vtab *pVtab;
			const sqlite3_module *pModule;

			pOut = out2Prerelease(p, pOp);
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType != CURTYPE_PSEUDO || pC->nullRow);
			if (pC->nullRow) {
				pOut->flags = MEM_Null;
				break;
			}
			else if (pC->deferredMoveto) {
				v = pC->movetoTarget;
#ifndef SQLITE_OMIT_VIRTUALTABLE
			}
			else if (pC->eCurType == CURTYPE_VTAB) {
				assert(pC->uc.pVCur != 0);
				pVtab = pC->uc.pVCur->pVtab;
				pModule = pVtab->pModule;
				assert(pModule->xRowid);
				rc = pModule->xRowid(pC->uc.pVCur, &v);
				sqlite3VtabImportErrmsg(p, pVtab);
				if (rc) goto abort_due_to_error;
#endif 
			}
			else {
				assert(pC->eCurType == CURTYPE_BTREE);
				assert(pC->uc.pCursor != 0);
				rc = sqlite3VdbeCursorRestore(pC);
				if (rc) goto abort_due_to_error;
				if (pC->nullRow) {
					pOut->flags = MEM_Null;
					break;
				}
				v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
			}
			pOut->u.i = v;
			break;
		}

					   
		case OP_NullRow: {
			VdbeCursor *pC;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			pC->nullRow = 1;
			pC->cacheStatus = CACHE_STALE;
			if (pC->eCurType == CURTYPE_BTREE) {
				assert(pC->uc.pCursor != 0);
				sqlite3BtreeClearCursor(pC->uc.pCursor);
			}
			break;
		}

						 
		case OP_Last: {        
			VdbeCursor *pC;
			BtCursor *pCrsr;
			int res;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			pCrsr = pC->uc.pCursor;
			res = 0;
			assert(pCrsr != 0);
			rc = sqlite3BtreeLast(pCrsr, &res);
			pC->nullRow = (u8)res;
			pC->deferredMoveto = 0;
			pC->cacheStatus = CACHE_STALE;
			pC->seekResult = pOp->p3;
#ifdef SQLITE_DEBUG
			pC->seekOp = OP_Last;
#endif
			if (rc) goto abort_due_to_error;
			if (pOp->p2>0) {
				VdbeBranchTaken(res != 0, 2);
				if (res) goto jump_to_p2;
			}
			break;
		}


					  
		case OP_SorterSort:    
		case OP_Sort: {        
#ifdef SQLITE_TEST
			sqlite3_sort_count++;
			sqlite3_search_count--;
#endif
			p->aCounter[SQLITE_STMTSTATUS_SORT]++;
			
		}
					  
		case OP_Rewind: {        
			VdbeCursor *pC;
			BtCursor *pCrsr;
			int res;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(isSorter(pC) == (pOp->opcode == OP_SorterSort));
			res = 1;
#ifdef SQLITE_DEBUG
			pC->seekOp = OP_Rewind;
#endif
			if (isSorter(pC)) {
				rc = sqlite3VdbeSorterRewind(pC, &res);
			}
			else {
				assert(pC->eCurType == CURTYPE_BTREE);
				pCrsr = pC->uc.pCursor;
				assert(pCrsr);
				rc = sqlite3BtreeFirst(pCrsr, &res);
				pC->deferredMoveto = 0;
				pC->cacheStatus = CACHE_STALE;
			}
			if (rc) goto abort_due_to_error;
			pC->nullRow = (u8)res;
			assert(pOp->p2>0 && pOp->p2<p->nOp);
			VdbeBranchTaken(res != 0, 2);
			if (res) goto jump_to_p2;
			break;
		}

						
						
						
						
		case OP_SorterNext: {  
			VdbeCursor *pC;
			int res;

			pC = p->apCsr[pOp->p1];
			assert(isSorter(pC));
			res = 0;
			rc = sqlite3VdbeSorterNext(db, pC, &res);
			goto next_tail;
		case OP_PrevIfOpen:    
		case OP_NextIfOpen:    
			if (p->apCsr[pOp->p1] == 0) break;
			
		case OP_Prev:          
		case OP_Next:          
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(pOp->p5<ArraySize(p->aCounter));
			pC = p->apCsr[pOp->p1];
			res = pOp->p3;
			assert(pC != 0);
			assert(pC->deferredMoveto == 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(res == 0 || (res == 1 && pC->isTable == 0));
			testcase(res == 1);
			assert(pOp->opcode != OP_Next || pOp->p4.xAdvance == sqlite3BtreeNext);
			assert(pOp->opcode != OP_Prev || pOp->p4.xAdvance == sqlite3BtreePrevious);
			assert(pOp->opcode != OP_NextIfOpen || pOp->p4.xAdvance == sqlite3BtreeNext);
			assert(pOp->opcode != OP_PrevIfOpen || pOp->p4.xAdvance == sqlite3BtreePrevious);

			
			assert(pOp->opcode != OP_Next || pOp->opcode != OP_NextIfOpen
				|| pC->seekOp == OP_SeekGT || pC->seekOp == OP_SeekGE
				|| pC->seekOp == OP_Rewind || pC->seekOp == OP_Found);
			assert(pOp->opcode != OP_Prev || pOp->opcode != OP_PrevIfOpen
				|| pC->seekOp == OP_SeekLT || pC->seekOp == OP_SeekLE
				|| pC->seekOp == OP_Last);

			rc = pOp->p4.xAdvance(pC->uc.pCursor, &res);
		next_tail:
			pC->cacheStatus = CACHE_STALE;
			VdbeBranchTaken(res == 0, 2);
			if (rc) goto abort_due_to_error;
			if (res == 0) {
				pC->nullRow = 0;
				p->aCounter[pOp->p5]++;
#ifdef SQLITE_TEST
				sqlite3_search_count++;
#endif
				goto jump_to_p2_and_check_for_interrupt;
			}
			else {
				pC->nullRow = 1;
			}
			goto check_for_interrupt;
		}

							
		case OP_SorterInsert:       
		case OP_IdxInsert: {        
			VdbeCursor *pC;
			BtreePayload x;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(isSorter(pC) == (pOp->opcode == OP_SorterInsert));
			pIn2 = &aMem[pOp->p2];
			assert(pIn2->flags & MEM_Blob);
			if (pOp->p5 & OPFLAG_NCHANGE) p->nChange++;
			assert(pC->eCurType == CURTYPE_BTREE || pOp->opcode == OP_SorterInsert);
			assert(pC->isTable == 0);
			rc = ExpandBlob(pIn2);
			if (rc) goto abort_due_to_error;
			if (pOp->opcode == OP_SorterInsert) {
				rc = sqlite3VdbeSorterWrite(pC, pIn2);
			}
			else {
				x.nKey = pIn2->n;
				x.pKey = pIn2->z;
				rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, pOp->p3,
					((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
				);
				assert(pC->deferredMoveto == 0);
				pC->cacheStatus = CACHE_STALE;
			}
			if (rc) goto abort_due_to_error;
			break;
		}

						   
		case OP_IdxDelete: {
			VdbeCursor *pC;
			BtCursor *pCrsr;
			int res;
			UnpackedRecord r;

			assert(pOp->p3>0);
			assert(pOp->p2>0 && pOp->p2 + pOp->p3 <= (p->nMem + 1 - p->nCursor) + 1);
			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			pCrsr = pC->uc.pCursor;
			assert(pCrsr != 0);
			assert(pOp->p5 == 0);
			r.pKeyInfo = pC->pKeyInfo;
			r.nField = (u16)pOp->p3;
			r.default_rc = 0;
			r.aMem = &aMem[pOp->p2];
			rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
			if (rc) goto abort_due_to_error;
			if (res == 0) {
				rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);
				if (rc) goto abort_due_to_error;
			}
			assert(pC->deferredMoveto == 0);
			pC->cacheStatus = CACHE_STALE;
			break;
		}

						   
						   
		case OP_Seek:
		case OP_IdxRowid: {              
			VdbeCursor *pC;                
			VdbeCursor *pTabCur;           
			i64 rowid;                     

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			assert(pC->isTable == 0);
			assert(pC->deferredMoveto == 0);
			assert(!pC->nullRow || pOp->opcode == OP_IdxRowid);

			
			rc = sqlite3VdbeCursorRestore(pC);

			
			if (NEVER(rc != SQLITE_OK)) goto abort_due_to_error;

			if (!pC->nullRow) {
				rowid = 0;  
				rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);
				if (rc != SQLITE_OK) {
					goto abort_due_to_error;
				}
				if (pOp->opcode == OP_Seek) {
					assert(pOp->p3 >= 0 && pOp->p3<p->nCursor);
					pTabCur = p->apCsr[pOp->p3];
					assert(pTabCur != 0);
					assert(pTabCur->eCurType == CURTYPE_BTREE);
					assert(pTabCur->uc.pCursor != 0);
					assert(pTabCur->isTable);
					pTabCur->nullRow = 0;
					pTabCur->movetoTarget = rowid;
					pTabCur->deferredMoveto = 1;
					assert(pOp->p4type == P4_INTARRAY || pOp->p4.ai == 0);
					pTabCur->aAltMap = pOp->p4.ai;
					pTabCur->pAltCursor = pC;
				}
				else {
					pOut = out2Prerelease(p, pOp);
					pOut->u.i = rowid;
					pOut->flags = MEM_Int;
				}
			}
			else {
				assert(pOp->opcode == OP_IdxRowid);
				sqlite3VdbeMemSetNull(&aMem[pOp->p2]);
			}
			break;
		}

						  
						  
						  
						  
		case OP_IdxLE:          
		case OP_IdxGT:          
		case OP_IdxLT:          
		case OP_IdxGE: {       
			VdbeCursor *pC;
			int res;
			UnpackedRecord r;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			assert(pC->isOrdered);
			assert(pC->eCurType == CURTYPE_BTREE);
			assert(pC->uc.pCursor != 0);
			assert(pC->deferredMoveto == 0);
			assert(pOp->p5 == 0 || pOp->p5 == 1);
			assert(pOp->p4type == P4_INT32);
			r.pKeyInfo = pC->pKeyInfo;
			r.nField = (u16)pOp->p4.i;
			if (pOp->opcode<OP_IdxLT) {
				assert(pOp->opcode == OP_IdxLE || pOp->opcode == OP_IdxGT);
				r.default_rc = -1;
			}
			else {
				assert(pOp->opcode == OP_IdxGE || pOp->opcode == OP_IdxLT);
				r.default_rc = 0;
			}
			r.aMem = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
			{ int i; for (i = 0; i<r.nField; i++) assert(memIsValid(&r.aMem[i])); }
#endif
			res = 0;  
			rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);
			assert((OP_IdxLE & 1) == (OP_IdxLT & 1) && (OP_IdxGE & 1) == (OP_IdxGT & 1));
			if ((pOp->opcode & 1) == (OP_IdxLT & 1)) {
				assert(pOp->opcode == OP_IdxLE || pOp->opcode == OP_IdxLT);
				res = -res;
			}
			else {
				assert(pOp->opcode == OP_IdxGE || pOp->opcode == OP_IdxGT);
				res++;
			}
			VdbeBranchTaken(res>0, 2);
			if (rc) goto abort_due_to_error;
			if (res>0) goto jump_to_p2;
			break;
		}

					   
		case OP_Destroy: {     
			int iMoved;
			int iDb;

			assert(p->readOnly == 0);
			assert(pOp->p1>1);
			pOut = out2Prerelease(p, pOp);
			pOut->flags = MEM_Null;
			if (db->nVdbeRead > db->nVDestroy + 1) {
				rc = SQLITE_LOCKED;
				p->errorAction = OE_Abort;
				goto abort_due_to_error;
			}
			else {
				iDb = pOp->p3;
				assert(DbMaskTest(p->btreeMask, iDb));
				iMoved = 0;  
				rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
				pOut->flags = MEM_Int;
				pOut->u.i = iMoved;
				if (rc) goto abort_due_to_error;
#ifndef SQLITE_OMIT_AUTOVACUUM
				if (iMoved != 0) {
					sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);
					
					assert(resetSchemaOnFault == 0 || resetSchemaOnFault == iDb + 1);
					resetSchemaOnFault = iDb + 1;
				}
#endif
			}
			break;
		}

						 
		case OP_Clear: {
			int nChange;

			nChange = 0;
			assert(p->readOnly == 0);
			assert(DbMaskTest(p->btreeMask, pOp->p2));
			rc = sqlite3BtreeClearTable(
				db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
			);
			if (pOp->p3) {
				p->nChange += nChange;
				if (pOp->p3>0) {
					assert(memIsValid(&aMem[pOp->p3]));
					memAboutToChange(p, &aMem[pOp->p3]);
					aMem[pOp->p3].u.i += nChange;
				}
			}
			if (rc) goto abort_due_to_error;
			break;
		}

					   
		case OP_ResetSorter: {
			VdbeCursor *pC;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			pC = p->apCsr[pOp->p1];
			assert(pC != 0);
			if (isSorter(pC)) {
				sqlite3VdbeSorterReset(db, pC->uc.pSorter);
			}
			else {
				assert(pC->eCurType == CURTYPE_BTREE);
				assert(pC->isEphemeral);
				rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);
				if (rc) goto abort_due_to_error;
			}
			break;
		}

							 
							 
		case OP_CreateIndex:            
		case OP_CreateTable: {          
			int pgno;
			int flags;
			Db *pDb;

			pOut = out2Prerelease(p, pOp);
			pgno = 0;
			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			assert(DbMaskTest(p->btreeMask, pOp->p1));
			assert(p->readOnly == 0);
			pDb = &db->aDb[pOp->p1];
			assert(pDb->pBt != 0);
			if (pOp->opcode == OP_CreateTable) {
				
				flags = BTREE_INTKEY;
			}
			else {
				flags = BTREE_BLOBKEY;
			}
			rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, flags);
			if (rc) goto abort_due_to_error;
			pOut->u.i = pgno;
			break;
		}

							 
		case OP_ParseSchema: {
			int iDb;
			const char *zMaster;
			char *zSql;
			InitData initData;

			
#ifdef SQLITE_DEBUG
			for (iDb = 0; iDb<db->nDb; iDb++) {
				assert(iDb == 1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt));
			}
#endif

			iDb = pOp->p1;
			assert(iDb >= 0 && iDb<db->nDb);
			assert(DbHasProperty(db, iDb, DB_SchemaLoaded));
			 {
				zMaster = SCHEMA_TABLE(iDb);
				initData.db = db;
				initData.iDb = pOp->p1;
				initData.pzErrMsg = &p->zErrMsg;
				zSql = sqlite3MPrintf(db,
					"SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid",
					db->aDb[iDb].zDbSName, zMaster, pOp->p4.z);
				if (zSql == 0) {
					rc = SQLITE_NOMEM_BKPT;
				}
				else {
					assert(db->init.busy == 0);
					db->init.busy = 1;
					initData.rc = SQLITE_OK;
					assert(!db->mallocFailed);
					rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
					if (rc == SQLITE_OK) rc = initData.rc;
					sqlite3DbFree(db, zSql);
					db->init.busy = 0;
				}
			}
			if (rc) {
				sqlite3ResetAllSchemasOfConnection(db);
				if (rc == SQLITE_NOMEM) {
					goto no_mem;
				}
				goto abort_due_to_error;
			}
			break;
		}

#if !defined(SQLITE_OMIT_ANALYZE)
							 
		case OP_LoadAnalysis: {
			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			rc = sqlite3AnalysisLoad(db, pOp->p1);
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

							  
		case OP_DropTable: {
			sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
			break;
		}

						   
		case OP_DropIndex: {
			sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
			break;
		}

						   
		case OP_DropTrigger: {
			sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
			break;
		}


#ifndef SQLITE_OMIT_INTEGRITY_CHECK
							 
		case OP_IntegrityCk: {
			int nRoot;      
			int *aRoot;     
			int nErr;       
			char *z;        
			Mem *pnErr;     

			assert(p->bIsReader);
			nRoot = pOp->p2;
			aRoot = pOp->p4.ai;
			assert(nRoot>0);
			assert(aRoot[nRoot] == 0);
			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			pnErr = &aMem[pOp->p3];
			assert((pnErr->flags & MEM_Int) != 0);
			assert((pnErr->flags & (MEM_Str | MEM_Blob)) == 0);
			pIn1 = &aMem[pOp->p1];
			assert(pOp->p5<db->nDb);
			assert(DbMaskTest(p->btreeMask, pOp->p5));
			z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, aRoot, nRoot,
				(int)pnErr->u.i, &nErr);
			pnErr->u.i -= nErr;
			sqlite3VdbeMemSetNull(pIn1);
			if (nErr == 0) {
				assert(z == 0);
			}
			else if (z == 0) {
				goto no_mem;
			}
			else {
				sqlite3VdbeMemSetStr(pIn1, z, -1, SQLITE_UTF8, sqlite3_free);
			}
			UPDATE_MAX_BLOBSIZE(pIn1);
			sqlite3VdbeChangeEncoding(pIn1, encoding);
			break;
		}
#endif 

							 
		case OP_RowSetAdd: {       
			pIn1 = &aMem[pOp->p1];
			pIn2 = &aMem[pOp->p2];
			assert((pIn2->flags & MEM_Int) != 0);
			if ((pIn1->flags & MEM_RowSet) == 0) {
				sqlite3VdbeMemSetRowSet(pIn1);
				if ((pIn1->flags & MEM_RowSet) == 0) goto no_mem;
			}
			sqlite3RowSetInsert(pIn1->u.pRowSet, pIn2->u.i);
			break;
		}

						   
		case OP_RowSetRead: {       
			i64 val;

			pIn1 = &aMem[pOp->p1];
			if ((pIn1->flags & MEM_RowSet) == 0
				|| sqlite3RowSetNext(pIn1->u.pRowSet, &val) == 0
				) {
				
				sqlite3VdbeMemSetNull(pIn1);
				VdbeBranchTaken(1, 2);
				goto jump_to_p2_and_check_for_interrupt;
			}
			else {
				
				VdbeBranchTaken(0, 2);
				sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);
			}
			goto check_for_interrupt;
		}

							
		case OP_RowSetTest: {                     
			int iSet;
			int exists;

			pIn1 = &aMem[pOp->p1];
			pIn3 = &aMem[pOp->p3];
			iSet = pOp->p4.i;
			assert(pIn3->flags&MEM_Int);

			
			if ((pIn1->flags & MEM_RowSet) == 0) {
				sqlite3VdbeMemSetRowSet(pIn1);
				if ((pIn1->flags & MEM_RowSet) == 0) goto no_mem;
			}

			assert(pOp->p4type == P4_INT32);
			assert(iSet == -1 || iSet >= 0);
			if (iSet) {
				exists = sqlite3RowSetTest(pIn1->u.pRowSet, iSet, pIn3->u.i);
				VdbeBranchTaken(exists != 0, 2);
				if (exists) goto jump_to_p2;
			}
			if (iSet >= 0) {
				sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);
			}
			break;
		}


#ifndef SQLITE_OMIT_TRIGGER

							
		case OP_Program: {        
			int nMem;               
			int nByte;              
			Mem *pRt;               
			Mem *pMem;              
			Mem *pEnd;              
			VdbeFrame *pFrame;      
			SubProgram *pProgram;   
			void *t;                

			pProgram = pOp->p4.pProgram;
			pRt = &aMem[pOp->p3];
			assert(pProgram->nOp>0);

			
			if (pOp->p5) {
				t = pProgram->token;
				for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent);
				if (pFrame) break;
			}

			if (p->nFrame >= db->aLimit[SQLITE_LIMIT_TRIGGER_DEPTH]) {
				rc = SQLITE_ERROR;
				sqlite3VdbeError(p, "too many levels of trigger recursion");
				goto abort_due_to_error;
			}

			
			if ((pRt->flags&MEM_Frame) == 0) {
				
				nMem = pProgram->nMem + pProgram->nCsr;
				assert(nMem>0);
				if (pProgram->nCsr == 0) nMem++;
				nByte = ROUND8(sizeof(VdbeFrame))
					+ nMem * sizeof(Mem)
					+ pProgram->nCsr * sizeof(VdbeCursor *);
				pFrame = sqlite3DbMallocZero(db, nByte);
				if (!pFrame) {
					goto no_mem;
				}
				sqlite3VdbeMemRelease(pRt);
				pRt->flags = MEM_Frame;
				pRt->u.pFrame = pFrame;

				pFrame->v = p;
				pFrame->nChildMem = nMem;
				pFrame->nChildCsr = pProgram->nCsr;
				pFrame->pc = (int)(pOp - aOp);
				pFrame->aMem = p->aMem;
				pFrame->nMem = p->nMem;
				pFrame->apCsr = p->apCsr;
				pFrame->nCursor = p->nCursor;
				pFrame->aOp = p->aOp;
				pFrame->nOp = p->nOp;
				pFrame->token = pProgram->token;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
				pFrame->anExec = p->anExec;
#endif

				pEnd = &VdbeFrameMem(pFrame)[pFrame->nChildMem];
				for (pMem = VdbeFrameMem(pFrame); pMem != pEnd; pMem++) {
					pMem->flags = MEM_Undefined;
					pMem->db = db;
				}
			}
			else {
				pFrame = pRt->u.pFrame;
				assert(pProgram->nMem + pProgram->nCsr == pFrame->nChildMem
					|| (pProgram->nCsr == 0 && pProgram->nMem + 1 == pFrame->nChildMem));
				assert(pProgram->nCsr == pFrame->nChildCsr);
				assert((int)(pOp - aOp) == pFrame->pc);
			}

			p->nFrame++;
			pFrame->pParent = p->pFrame;
			pFrame->lastRowid = lastRowid;
			pFrame->nChange = p->nChange;
			pFrame->nDbChange = p->db->nChange;
			assert(pFrame->pAuxData == 0);
			pFrame->pAuxData = p->pAuxData;
			p->pAuxData = 0;
			p->nChange = 0;
			p->pFrame = pFrame;
			p->aMem = aMem = VdbeFrameMem(pFrame);
			p->nMem = pFrame->nChildMem;
			p->nCursor = (u16)pFrame->nChildCsr;
			p->apCsr = (VdbeCursor **)&aMem[p->nMem];
			p->aOp = aOp = pProgram->aOp;
			p->nOp = pProgram->nOp;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
			p->anExec = 0;
#endif
			pOp = &aOp[-1];

			break;
		}

						 
		case OP_Param: {           
			VdbeFrame *pFrame;
			Mem *pIn;
			pOut = out2Prerelease(p, pOp);
			pFrame = p->pFrame;
			pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];
			sqlite3VdbeMemShallowCopy(pOut, pIn, MEM_Ephem);
			break;
		}

#endif 

#ifndef SQLITE_OMIT_FOREIGN_KEY
					   
		case OP_FkCounter: {
			if (db->flags & SQLITE_DeferFKs) {
				db->nDeferredImmCons += pOp->p2;
			}
			else if (pOp->p1) {
				db->nDeferredCons += pOp->p2;
			}
			else {
				p->nFkConstraint += pOp->p2;
			}
			break;
		}

						   
		case OP_FkIfZero: {         
			if (pOp->p1) {
				VdbeBranchTaken(db->nDeferredCons == 0 && db->nDeferredImmCons == 0, 2);
				if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0) goto jump_to_p2;
			}
			else {
				VdbeBranchTaken(p->nFkConstraint == 0 && db->nDeferredImmCons == 0, 2);
				if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0) goto jump_to_p2;
			}
			break;
		}
#endif 

#ifndef SQLITE_OMIT_AUTOINCREMENT
						  
		case OP_MemMax: {        
			VdbeFrame *pFrame;
			if (p->pFrame) {
				for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent);
				pIn1 = &pFrame->aMem[pOp->p1];
			}
			else {
				pIn1 = &aMem[pOp->p1];
			}
			assert(memIsValid(pIn1));
			sqlite3VdbeMemIntegerify(pIn1);
			pIn2 = &aMem[pOp->p2];
			sqlite3VdbeMemIntegerify(pIn2);
			if (pIn1->u.i<pIn2->u.i) {
				pIn1->u.i = pIn2->u.i;
			}
			break;
		}
#endif 

						
		case OP_IfPos: {        
			pIn1 = &aMem[pOp->p1];
			assert(pIn1->flags&MEM_Int);
			VdbeBranchTaken(pIn1->u.i>0, 2);
			if (pIn1->u.i>0) {
				pIn1->u.i -= pOp->p3;
				goto jump_to_p2;
			}
			break;
		}

					   
		case OP_OffsetLimit: {    
			pIn1 = &aMem[pOp->p1];
			pIn3 = &aMem[pOp->p3];
			pOut = out2Prerelease(p, pOp);
			assert(pIn1->flags & MEM_Int);
			assert(pIn3->flags & MEM_Int);
			pOut->u.i = pIn1->u.i <= 0 ? -1 : pIn1->u.i + (pIn3->u.i>0 ? pIn3->u.i : 0);
			break;
		}

							 
		case OP_IfNotZero: {        
			pIn1 = &aMem[pOp->p1];
			assert(pIn1->flags&MEM_Int);
			VdbeBranchTaken(pIn1->u.i<0, 2);
			if (pIn1->u.i) {
				pIn1->u.i -= pOp->p3;
				goto jump_to_p2;
			}
			break;
		}

						   
		case OP_DecrJumpZero: {      
			pIn1 = &aMem[pOp->p1];
			assert(pIn1->flags&MEM_Int);
			pIn1->u.i--;
			VdbeBranchTaken(pIn1->u.i == 0, 2);
			if (pIn1->u.i == 0) goto jump_to_p2;
			break;
		}


							  
							  
		case OP_AggStep0: {
			int n;
			sqlite3_context *pCtx;

			assert(pOp->p4type == P4_FUNCDEF);
			n = pOp->p5;
			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			assert(n == 0 || (pOp->p2>0 && pOp->p2 + n <= (p->nMem + 1 - p->nCursor) + 1));
			assert(pOp->p3<pOp->p2 || pOp->p3 >= pOp->p2 + n);
			pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n - 1) * sizeof(sqlite3_value*));
			if (pCtx == 0) goto no_mem;
			pCtx->pMem = 0;
			pCtx->pFunc = pOp->p4.pFunc;
			pCtx->iOp = (int)(pOp - aOp);
			pCtx->pVdbe = p;
			pCtx->argc = n;
			pOp->p4type = P4_FUNCCTX;
			pOp->p4.pCtx = pCtx;
			pOp->opcode = OP_AggStep;
			
		}
		case OP_AggStep: {
			int i;
			sqlite3_context *pCtx;
			Mem *pMem;
			Mem t;

			assert(pOp->p4type == P4_FUNCCTX);
			pCtx = pOp->p4.pCtx;
			pMem = &aMem[pOp->p3];

			
			if (pCtx->pMem != pMem) {
				pCtx->pMem = pMem;
				for (i = pCtx->argc - 1; i >= 0; i--) pCtx->argv[i] = &aMem[pOp->p2 + i];
			}

#ifdef SQLITE_DEBUG
			for (i = 0; i<pCtx->argc; i++) {
				assert(memIsValid(pCtx->argv[i]));
				REGISTER_TRACE(pOp->p2 + i, pCtx->argv[i]);
			}
#endif

			pMem->n++;
			sqlite3VdbeMemInit(&t, db, MEM_Null);
			pCtx->pOut = &t;
			pCtx->fErrorOrAux = 0;
			pCtx->skipFlag = 0;
			(pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv); 
			if (pCtx->fErrorOrAux) {
				if (pCtx->isError) {
					sqlite3VdbeError(p, "%s", sqlite3_value_text(&t));
					rc = pCtx->isError;
				}
				sqlite3VdbeMemRelease(&t);
				if (rc) goto abort_due_to_error;
			}
			else {
				assert(t.flags == MEM_Null);
			}
			if (pCtx->skipFlag) {
				assert(pOp[-1].opcode == OP_CollSeq);
				i = pOp[-1].p1;
				if (i) sqlite3VdbeMemSetInt64(&aMem[i], 1);
			}
			break;
		}

						 
		case OP_AggFinal: {
			Mem *pMem;
			assert(pOp->p1>0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));
			pMem = &aMem[pOp->p1];
			assert((pMem->flags & ~(MEM_Null | MEM_Agg)) == 0);
			rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);
			if (rc) {
				sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem));
				goto abort_due_to_error;
			}
			sqlite3VdbeChangeEncoding(pMem, encoding);
			UPDATE_MAX_BLOBSIZE(pMem);
			if (sqlite3VdbeMemTooBig(pMem)) {
				goto too_big;
			}
			break;
		}

#ifndef SQLITE_OMIT_WAL
						  
		case OP_Checkpoint: {
			int i;                          
			int aRes[3];                    
			Mem *pMem;                      

			assert(p->readOnly == 0);
			aRes[0] = 0;
			aRes[1] = aRes[2] = -1;
			assert(pOp->p2 == SQLITE_CHECKPOINT_PASSIVE
				|| pOp->p2 == SQLITE_CHECKPOINT_FULL
				|| pOp->p2 == SQLITE_CHECKPOINT_RESTART
				|| pOp->p2 == SQLITE_CHECKPOINT_TRUNCATE
			);
			rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);
			if (rc) {
				if (rc != SQLITE_BUSY) goto abort_due_to_error;
				rc = SQLITE_OK;
				aRes[0] = 1;
			}
			for (i = 0, pMem = &aMem[pOp->p3]; i<3; i++, pMem++) {
				sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);
			}
			break;
		};
#endif

#ifndef SQLITE_OMIT_PRAGMA
							
		case OP_JournalMode: {    
			Btree *pBt;                     
			Pager *pPager;                  
			int eNew;                       
			int eOld;                       
#ifndef SQLITE_OMIT_WAL
			const char *zFilename;          
#endif

			pOut = out2Prerelease(p, pOp);
			eNew = pOp->p3;
			assert(eNew == PAGER_JOURNALMODE_DELETE
				|| eNew == PAGER_JOURNALMODE_TRUNCATE
				|| eNew == PAGER_JOURNALMODE_PERSIST
				|| eNew == PAGER_JOURNALMODE_OFF
				|| eNew == PAGER_JOURNALMODE_MEMORY
				|| eNew == PAGER_JOURNALMODE_WAL
				|| eNew == PAGER_JOURNALMODE_QUERY
			);
			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			assert(p->readOnly == 0);

			pBt = db->aDb[pOp->p1].pBt;
			pPager = sqlite3BtreePager(pBt);
			eOld = sqlite3PagerGetJournalMode(pPager);
			if (eNew == PAGER_JOURNALMODE_QUERY) eNew = eOld;
			if (!sqlite3PagerOkToChangeJournalMode(pPager)) eNew = eOld;

#ifndef SQLITE_OMIT_WAL
			zFilename = sqlite3PagerFilename(pPager, 1);

			
			if (eNew == PAGER_JOURNALMODE_WAL
				&& (sqlite3Strlen30(zFilename) == 0           
					|| !sqlite3PagerWalSupported(pPager))   
				) {
				eNew = eOld;
			}

			if ((eNew != eOld)
				&& (eOld == PAGER_JOURNALMODE_WAL || eNew == PAGER_JOURNALMODE_WAL)
				) {
				if (!db->autoCommit || db->nVdbeRead>1) {
					rc = SQLITE_ERROR;
					sqlite3VdbeError(p,
						"cannot change %s wal mode from within a transaction",
						(eNew == PAGER_JOURNALMODE_WAL ? "into" : "out of")
					);
					goto abort_due_to_error;
				}
				else {

					if (eOld == PAGER_JOURNALMODE_WAL) {
						
						rc = sqlite3PagerCloseWal(pPager);
						if (rc == SQLITE_OK) {
							sqlite3PagerSetJournalMode(pPager, eNew);
						}
					}
					else if (eOld == PAGER_JOURNALMODE_MEMORY) {
						
						sqlite3PagerSetJournalMode(pPager, PAGER_JOURNALMODE_OFF);
					}

					
					assert(sqlite3BtreeIsInTrans(pBt) == 0);
					if (rc == SQLITE_OK) {
						rc = sqlite3BtreeSetVersion(pBt, (eNew == PAGER_JOURNALMODE_WAL ? 2 : 1));
					}
				}
			}
#endif 

			if (rc) eNew = eOld;
			eNew = sqlite3PagerSetJournalMode(pPager, eNew);

			pOut->flags = MEM_Str | MEM_Static | MEM_Term;
			pOut->z = (char *)sqlite3JournalModename(eNew);
			pOut->n = sqlite3Strlen30(pOut->z);
			pOut->enc = SQLITE_UTF8;
			sqlite3VdbeChangeEncoding(pOut, encoding);
			if (rc) goto abort_due_to_error;
			break;
		};
#endif 

#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)
							 
		case OP_Vacuum: {
			assert(p->readOnly == 0);
			rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1);
			if (rc) goto abort_due_to_error;
			break;
		}
#endif

#if !defined(SQLITE_OMIT_AUTOVACUUM)
						
		case OP_IncrVacuum: {        
			Btree *pBt;

			assert(pOp->p1 >= 0 && pOp->p1<db->nDb);
			assert(DbMaskTest(p->btreeMask, pOp->p1));
			assert(p->readOnly == 0);
			pBt = db->aDb[pOp->p1].pBt;
			rc = sqlite3BtreeIncrVacuum(pBt);
			VdbeBranchTaken(rc == SQLITE_DONE, 2);
			if (rc) {
				if (rc != SQLITE_DONE) goto abort_due_to_error;
				rc = SQLITE_OK;
				goto jump_to_p2;
			}
			break;
		}
#endif

							
		case OP_Expire: {
			if (!pOp->p1) {
				sqlite3ExpirePreparedStatements(db);
			}
			else {
				p->expired = 1;
			}
			break;
		}

#ifndef SQLITE_OMIT_SHARED_CACHE
						
		case OP_TableLock: {
			u8 isWriteLock = (u8)pOp->p3;
			if (isWriteLock || 0 == (db->flags&SQLITE_ReadUncommitted)) {
				int p1 = pOp->p1;
				assert(p1 >= 0 && p1<db->nDb);
				assert(DbMaskTest(p->btreeMask, p1));
				assert(isWriteLock == 0 || isWriteLock == 1);
				rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
				if (rc) {
					if ((rc & 0xFF) == SQLITE_LOCKED) {
						const char *z = pOp->p4.z;
						sqlite3VdbeError(p, "database table is locked: %s", z);
					}
					goto abort_due_to_error;
				}
			}
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						   
		case OP_VBegin: {
			VTable *pVTab;
			pVTab = pOp->p4.pVtab;
			rc = sqlite3VtabBegin(db, pVTab);
			if (pVTab) sqlite3VtabImportErrmsg(p, pVTab->pVtab);
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						
		case OP_VCreate: {
			Mem sMem;          
			const char *zTab;  

			memset(&sMem, 0, sizeof(sMem));
			sMem.db = db;
			
			assert((aMem[pOp->p2].flags & MEM_Str) != 0);
			assert((aMem[pOp->p2].flags & MEM_Static) != 0);
			rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);
			assert(rc == SQLITE_OK);
			zTab = (const char*)sqlite3_value_text(&sMem);
			assert(zTab || db->mallocFailed);
			if (zTab) {
				rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);
			}
			sqlite3VdbeMemRelease(&sMem);
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						 
		case OP_VDestroy: {
			db->nVDestroy++;
			rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);
			db->nVDestroy--;
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						  
		case OP_VOpen: {
			VdbeCursor *pCur;
			sqlite3_vtab_cursor *pVCur;
			sqlite3_vtab *pVtab;
			const sqlite3_module *pModule;

			assert(p->bIsReader);
			pCur = 0;
			pVCur = 0;
			pVtab = pOp->p4.pVtab->pVtab;
			if (pVtab == 0 || NEVER(pVtab->pModule == 0)) {
				rc = SQLITE_LOCKED;
				goto abort_due_to_error;
			}
			pModule = pVtab->pModule;
			rc = pModule->xOpen(pVtab, &pVCur);
			sqlite3VtabImportErrmsg(p, pVtab);
			if (rc) goto abort_due_to_error;

			
			pVCur->pVtab = pVtab;

			
			pCur = allocateCursor(p, pOp->p1, 0, -1, CURTYPE_VTAB);
			if (pCur) {
				pCur->uc.pVCur = pVCur;
				pVtab->nRef++;
			}
			else {
				assert(db->mallocFailed);
				pModule->xClose(pVCur);
				goto no_mem;
			}
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
					   
		case OP_VFilter: {   
			int nArg;
			int iQuery;
			const sqlite3_module *pModule;
			Mem *pQuery;
			Mem *pArgc;
			sqlite3_vtab_cursor *pVCur;
			sqlite3_vtab *pVtab;
			VdbeCursor *pCur;
			int res;
			int i;
			Mem **apArg;

			pQuery = &aMem[pOp->p3];
			pArgc = &pQuery[1];
			pCur = p->apCsr[pOp->p1];
			assert(memIsValid(pQuery));
			REGISTER_TRACE(pOp->p3, pQuery);
			assert(pCur->eCurType == CURTYPE_VTAB);
			pVCur = pCur->uc.pVCur;
			pVtab = pVCur->pVtab;
			pModule = pVtab->pModule;

			
			assert((pQuery->flags&MEM_Int) != 0 && pArgc->flags == MEM_Int);
			nArg = (int)pArgc->u.i;
			iQuery = (int)pQuery->u.i;

			
			res = 0;
			apArg = p->apArg;
			for (i = 0; i<nArg; i++) {
				apArg[i] = &pArgc[i + 1];
			}
			rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);
			sqlite3VtabImportErrmsg(p, pVtab);
			if (rc) goto abort_due_to_error;
			res = pModule->xEof(pVCur);
			pCur->nullRow = 0;
			VdbeBranchTaken(res != 0, 2);
			if (res) goto jump_to_p2;
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						 
		case OP_VColumn: {
			sqlite3_vtab *pVtab;
			const sqlite3_module *pModule;
			Mem *pDest;
			sqlite3_context sContext;

			VdbeCursor *pCur = p->apCsr[pOp->p1];
			assert(pCur->eCurType == CURTYPE_VTAB);
			assert(pOp->p3>0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));
			pDest = &aMem[pOp->p3];
			memAboutToChange(p, pDest);
			if (pCur->nullRow) {
				sqlite3VdbeMemSetNull(pDest);
				break;
			}
			pVtab = pCur->uc.pVCur->pVtab;
			pModule = pVtab->pModule;
			assert(pModule->xColumn);
			memset(&sContext, 0, sizeof(sContext));
			sContext.pOut = pDest;
			MemSetTypeFlag(pDest, MEM_Null);
			rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);
			sqlite3VtabImportErrmsg(p, pVtab);
			if (sContext.isError) {
				rc = sContext.isError;
			}
			sqlite3VdbeChangeEncoding(pDest, encoding);
			REGISTER_TRACE(pOp->p3, pDest);
			UPDATE_MAX_BLOBSIZE(pDest);

			if (sqlite3VdbeMemTooBig(pDest)) {
				goto too_big;
			}
			if (rc) goto abort_due_to_error;
			break;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
						 
		case OP_VNext: {   
			sqlite3_vtab *pVtab;
			const sqlite3_module *pModule;
			int res;
			VdbeCursor *pCur;

			res = 0;
			pCur = p->apCsr[pOp->p1];
			assert(pCur->eCurType == CURTYPE_VTAB);
			if (pCur->nullRow) {
				break;
			}
			pVtab = pCur->uc.pVCur->pVtab;
			pModule = pVtab->pModule;
			assert(pModule->xNext);

			
			rc = pModule->xNext(pCur->uc.pVCur);
			sqlite3VtabImportErrmsg(p, pVtab);
			if (rc) goto abort_due_to_error;
			res = pModule->xEof(pCur->uc.pVCur);
			VdbeBranchTaken(!res, 2);
			if (!res) {
				
				goto jump_to_p2_and_check_for_interrupt;
			}
			goto check_for_interrupt;
		}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
					   
		case OP_VRename: {
			sqlite3_vtab *pVtab;
			Mem *pName;

			pVtab = pOp->p4.pVtab->pVtab;
			pName = &aMem[pOp->p1];
			assert(pVtab->pModule->xRename);
			assert(memIsValid(pName));
			assert(p->readOnly == 0);
			REGISTER_TRACE(pOp->p1, pName);
			assert(pName->flags & MEM_Str);
			testcase(pName->enc == SQLITE_UTF8);
			testcase(pName->enc == SQLITE_UTF16BE);
			testcase(pName->enc == SQLITE_UTF16LE);
			rc = sqlite3VdbeChangeEncoding(pName, SQLITE_UTF8);
			if (rc) goto abort_due_to_error;
			rc = pVtab->pModule->xRename(pVtab, pName->z);
			sqlite3VtabImportErrmsg(p, pVtab);
			p->expired = 0;
			if (rc) goto abort_due_to_error;
			break;
		}
#endif

#ifndef SQLITE_OMIT_VIRTUALTABLE
						 
		case OP_VUpdate: {
			sqlite3_vtab *pVtab;
			const sqlite3_module *pModule;
			int nArg;
			int i;
			sqlite_int64 rowid;
			Mem **apArg;
			Mem *pX;

			assert(pOp->p2 == 1 || pOp->p5 == OE_Fail || pOp->p5 == OE_Rollback
				|| pOp->p5 == OE_Abort || pOp->p5 == OE_Ignore || pOp->p5 == OE_Replace
			);
			assert(p->readOnly == 0);
			pVtab = pOp->p4.pVtab->pVtab;
			if (pVtab == 0 || NEVER(pVtab->pModule == 0)) {
				rc = SQLITE_LOCKED;
				goto abort_due_to_error;
			}
			pModule = pVtab->pModule;
			nArg = pOp->p2;
			assert(pOp->p4type == P4_VTAB);
			if (ALWAYS(pModule->xUpdate)) {
				u8 vtabOnConflict = db->vtabOnConflict;
				apArg = p->apArg;
				pX = &aMem[pOp->p3];
				for (i = 0; i<nArg; i++) {
					assert(memIsValid(pX));
					memAboutToChange(p, pX);
					apArg[i] = pX;
					pX++;
				}
				db->vtabOnConflict = pOp->p5;
				rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);
				db->vtabOnConflict = vtabOnConflict;
				sqlite3VtabImportErrmsg(p, pVtab);
				if (rc == SQLITE_OK && pOp->p1) {
					assert(nArg>1 && apArg[0] && (apArg[0]->flags&MEM_Null));
					db->lastRowid = lastRowid = rowid;
				}
				if ((rc & 0xff) == SQLITE_CONSTRAINT && pOp->p4.pVtab->bConstraint) {
					if (pOp->p5 == OE_Ignore) {
						rc = SQLITE_OK;
					}
					else {
						p->errorAction = ((pOp->p5 == OE_Replace) ? OE_Abort : pOp->p5);
					}
				}
				else {
					p->nChange++;
				}
				if (rc) goto abort_due_to_error;
			}
			break;
		}
#endif 

#ifndef  SQLITE_OMIT_PAGER_PRAGMAS
						 
		case OP_Pagecount: {            
			pOut = out2Prerelease(p, pOp);
			pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);
			break;
		}
#endif


#ifndef  SQLITE_OMIT_PAGER_PRAGMAS
						   
		case OP_MaxPgcnt: {            
			unsigned int newMax;
			Btree *pBt;

			pOut = out2Prerelease(p, pOp);
			pBt = db->aDb[pOp->p1].pBt;
			newMax = 0;
			if (pOp->p3) {
				newMax = sqlite3BtreeLastPage(pBt);
				if (newMax < (unsigned)pOp->p3) newMax = (unsigned)pOp->p3;
			}
			pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);
			break;
		}
#endif


						  
		case OP_Init: {          
			char *zTrace;
			int i;

			
			assert(pOp->p4.z == 0 || strncmp(pOp->p4.z, "-" "- ", 3) == 0);
			assert(pOp == p->aOp);  

#ifndef SQLITE_OMIT_TRACE
			if ((db->mTrace & (SQLITE_TRACE_STMT | SQLITE_TRACE_LEGACY)) != 0
				&& !p->doingRerun
				&& (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0
				) {
#ifndef SQLITE_OMIT_DEPRECATED
				if (db->mTrace & SQLITE_TRACE_LEGACY) {
					void(*x)(void*, const char*) = (void(*)(void*, const char*))db->xTrace;
					char *z = sqlite3VdbeExpandSql(p, zTrace);
					x(db->pTraceArg, z);
					sqlite3_free(z);
				}
				else
#endif
				{
					(void)db->xTrace(SQLITE_TRACE_STMT, db->pTraceArg, p, zTrace);
				}
			}
#ifdef SQLITE_USE_FCNTL_TRACE
			zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql);
			if (zTrace) {
				int j;
				for (j = 0; j<db->nDb; j++) {
					if (DbMaskTest(p->btreeMask, j) == 0) continue;
					sqlite3_file_control(db, db->aDb[j].zDbSName, SQLITE_FCNTL_TRACE, zTrace);
				}
			}
#endif 
#ifdef SQLITE_DEBUG
			if ((db->flags & SQLITE_SqlTrace) != 0
				&& (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0
				) {
				sqlite3DebugPrintf("SQL-trace: %s\n", zTrace);
			}
#endif 
#endif 
			assert(pOp->p2>0);
			if (pOp->p1 >= sqlite3GlobalConfig.iOnceResetThreshold) {
				for (i = 1; i<p->nOp; i++) {
					if (p->aOp[i].opcode == OP_Once) p->aOp[i].p1 = 0;
				}
				pOp->p1 = 0;
			}
			pOp->p1++;
			goto jump_to_p2;
		}

#ifdef SQLITE_ENABLE_CURSOR_HINTS
					  
		case OP_CursorHint: {
			VdbeCursor *pC;

			assert(pOp->p1 >= 0 && pOp->p1<p->nCursor);
			assert(pOp->p4type == P4_EXPR);
			pC = p->apCsr[pOp->p1];
			if (pC) {
				assert(pC->eCurType == CURTYPE_BTREE);
				sqlite3BtreeCursorHint(pC->uc.pCursor, BTREE_HINT_RANGE,
					pOp->p4.pExpr, aMem);
			}
			break;
		}
#endif 

							
							
		default: {          
			assert(pOp->opcode == OP_Noop || pOp->opcode == OP_Explain);
			break;
		}

				 
		}

#ifdef VDBE_PROFILE
		{
			u64 endTime = sqlite3Hwtime();
			if (endTime>start) pOrigOp->cycles += endTime - start;
			pOrigOp->cnt++;
		}
#endif

		
#ifndef NDEBUG
		assert(pOp >= &aOp[-1] && pOp<&aOp[p->nOp - 1]);

#ifdef SQLITE_DEBUG
		if (db->flags & SQLITE_VdbeTrace) {
			u8 opProperty = sqlite3OpcodeProperty[pOrigOp->opcode];
			if (rc != 0) printf("rc=%d\n", rc);
			if (opProperty & (OPFLG_OUT2)) {
				registerTrace(pOrigOp->p2, &aMem[pOrigOp->p2]);
			}
			if (opProperty & OPFLG_OUT3) {
				registerTrace(pOrigOp->p3, &aMem[pOrigOp->p3]);
			}
		}
#endif  
#endif  
	}  

	   
abort_due_to_error:
	if (db->mallocFailed) rc = SQLITE_NOMEM_BKPT;
	assert(rc);
	if (p->zErrMsg == 0 && rc != SQLITE_IOERR_NOMEM) {
		sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));
	}
	p->rc = rc;
	sqlite3SystemError(db, rc);
	testcase(sqlite3GlobalConfig.xLog != 0);
	sqlite3_log(rc, "statement aborts at %d: [%s] %s",
		(int)(pOp - aOp), p->zSql, p->zErrMsg);
	sqlite3VdbeHalt(p);
	if (rc == SQLITE_IOERR_NOMEM) sqlite3OomFault(db);
	rc = SQLITE_ERROR;
	if (resetSchemaOnFault>0) {
		sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);
	}

	
vdbe_return:
	db->lastRowid = lastRowid;
	testcase(nVmStep>0);
	p->aCounter[SQLITE_STMTSTATUS_VM_STEP] += (int)nVmStep;
	sqlite3VdbeLeave(p);
	assert(rc != SQLITE_OK || nExtraDelete == 0
		|| sqlite3_strlike("DELETE%", p->zSql, 0) != 0
	);
	return rc;

	
too_big:
	sqlite3VdbeError(p, "string or blob too big");
	rc = SQLITE_TOOBIG;
	goto abort_due_to_error;

	
no_mem:
	sqlite3OomFault(db);
	sqlite3VdbeError(p, "out of memory");
	rc = SQLITE_NOMEM_BKPT;
	goto abort_due_to_error;

	
abort_due_to_interrupt:
	assert(db->u1.isInterrupted);
	rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;
	p->rc = rc;
	sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));
	goto abort_due_to_error;
}









#ifndef SQLITE_OMIT_INCRBLOB


typedef struct Incrblob Incrblob;
struct Incrblob {
	int flags;              
	int nByte;              
	int iOffset;            
	int iCol;               
	BtCursor *pCsr;         
	sqlite3_stmt *pStmt;    
	sqlite3 *db;            
	char *zDb;              
	Table *pTab;            
};



static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr) {
	int rc;                         
	char *zErr = 0;                 
	Vdbe *v = (Vdbe *)p->pStmt;

	
	assert(v->aVar[0].flags&MEM_Int);
	v->aVar[0].u.i = iRow;

	rc = sqlite3_step(p->pStmt);
	if (rc == SQLITE_ROW) {
		VdbeCursor *pC = v->apCsr[0];
		u32 type = pC->aType[p->iCol];
		if (type<12) {
			zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",
				type == 0 ? "null" : type == 7 ? "real" : "integer"
			);
			rc = SQLITE_ERROR;
			sqlite3_finalize(p->pStmt);
			p->pStmt = 0;
		}
		else {
			p->iOffset = pC->aType[p->iCol + pC->nField];
			p->nByte = sqlite3VdbeSerialTypeLen(type);
			p->pCsr = pC->uc.pCursor;
			sqlite3BtreeIncrblobCursor(p->pCsr);
		}
	}

	if (rc == SQLITE_ROW) {
		rc = SQLITE_OK;
	}
	else if (p->pStmt) {
		rc = sqlite3_finalize(p->pStmt);
		p->pStmt = 0;
		if (rc == SQLITE_OK) {
			zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
			rc = SQLITE_ERROR;
		}
		else {
			zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
		}
	}

	assert(rc != SQLITE_OK || zErr == 0);
	assert(rc != SQLITE_ROW && rc != SQLITE_DONE);

	*pzErr = zErr;
	return rc;
}


SQLITE_API int sqlite3_blob_open(
	sqlite3* db,            
	const char *zDb,        
	const char *zTable,     
	const char *zColumn,    
	sqlite_int64 iRow,      
	int flags,              
	sqlite3_blob **ppBlob   
) {
	int nAttempt = 0;
	int iCol;               
	int rc = SQLITE_OK;
	char *zErr = 0;
	Table *pTab;
	Parse *pParse = 0;
	Incrblob *pBlob = 0;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (ppBlob == 0) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	*ppBlob = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zTable == 0) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	flags = !!flags;                

	sqlite3_mutex_enter(db->mutex);

	pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
	if (!pBlob) goto blob_open_out;
	pParse = sqlite3StackAllocRaw(db, sizeof(*pParse));
	if (!pParse) goto blob_open_out;

	do {
		memset(pParse, 0, sizeof(Parse));
		pParse->db = db;
		sqlite3DbFree(db, zErr);
		zErr = 0;

		sqlite3BtreeEnterAll(db);
		pTab = sqlite3LocateTable(pParse, 0, zTable, zDb);
		if (pTab && IsVirtual(pTab)) {
			pTab = 0;
			sqlite3ErrorMsg(pParse, "cannot open virtual table: %s", zTable);
		}
		if (pTab && !HasRowid(pTab)) {
			pTab = 0;
			sqlite3ErrorMsg(pParse, "cannot open table without rowid: %s", zTable);
		}
#ifndef SQLITE_OMIT_VIEW
		if (pTab && pTab->pSelect) {
			pTab = 0;
			sqlite3ErrorMsg(pParse, "cannot open view: %s", zTable);
		}
#endif
		if (!pTab) {
			if (pParse->zErrMsg) {
				sqlite3DbFree(db, zErr);
				zErr = pParse->zErrMsg;
				pParse->zErrMsg = 0;
			}
			rc = SQLITE_ERROR;
			sqlite3BtreeLeaveAll(db);
			goto blob_open_out;
		}
		pBlob->pTab = pTab;
		pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;

		
		for (iCol = 0; iCol<pTab->nCol; iCol++) {
			if (sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn) == 0) {
				break;
			}
		}
		if (iCol == pTab->nCol) {
			sqlite3DbFree(db, zErr);
			zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
			rc = SQLITE_ERROR;
			sqlite3BtreeLeaveAll(db);
			goto blob_open_out;
		}

		
		if (flags) {
			const char *zFault = 0;
			Index *pIdx;
#ifndef SQLITE_OMIT_FOREIGN_KEY
			if (db->flags&SQLITE_ForeignKeys) {
				
				FKey *pFKey;
				for (pFKey = pTab->pFKey; pFKey; pFKey = pFKey->pNextFrom) {
					int j;
					for (j = 0; j<pFKey->nCol; j++) {
						if (pFKey->aCol[j].iFrom == iCol) {
							zFault = "foreign key";
						}
					}
				}
			}
#endif
			for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
				int j;
				for (j = 0; j<pIdx->nKeyCol; j++) {
					
					if (pIdx->aiColumn[j] == iCol || pIdx->aiColumn[j] == XN_EXPR) {
						zFault = "indexed";
					}
				}
			}
			if (zFault) {
				sqlite3DbFree(db, zErr);
				zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
				rc = SQLITE_ERROR;
				sqlite3BtreeLeaveAll(db);
				goto blob_open_out;
			}
		}

		pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(pParse);
		assert(pBlob->pStmt || db->mallocFailed);
		if (pBlob->pStmt) {

			
			static const int iLn = VDBE_OFFSET_LINENO(2);
			static const VdbeOpList openBlob[] = {
				{ OP_TableLock,      0, 0, 0 },  
				{ OP_OpenRead,       0, 0, 0 },  
				{ OP_Variable,       1, 1, 0 },  
				{ OP_NotExists,      0, 7, 1 },  
				{ OP_Column,         0, 0, 1 },  
				{ OP_ResultRow,      1, 0, 0 },  
				{ OP_Goto,           0, 2, 0 },  
				{ OP_Close,          0, 0, 0 },  
				{ OP_Halt,           0, 0, 0 },  
			};
			Vdbe *v = (Vdbe *)pBlob->pStmt;
			int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
			VdbeOp *aOp;

			sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, flags,
				pTab->pSchema->schema_cookie,
				pTab->pSchema->iGeneration);
			sqlite3VdbeChangeP5(v, 1);
			aOp = sqlite3VdbeAddOpList(v, ArraySize(openBlob), openBlob, iLn);

			
			sqlite3VdbeUsesBtree(v, iDb);

			if (db->mallocFailed == 0) {
				assert(aOp != 0);
				
#ifdef SQLITE_OMIT_SHARED_CACHE
				aOp[0].opcode = OP_Noop;
#else
				aOp[0].p1 = iDb;
				aOp[0].p2 = pTab->tnum;
				aOp[0].p3 = flags;
				sqlite3VdbeChangeP4(v, 1, pTab->zName, P4_TRANSIENT);
			}
			if (db->mallocFailed == 0) {
#endif

				
				if (flags) aOp[1].opcode = OP_OpenWrite;
				aOp[1].p2 = pTab->tnum;
				aOp[1].p3 = iDb;

				
				aOp[1].p4type = P4_INT32;
				aOp[1].p4.i = pTab->nCol + 1;
				aOp[4].p2 = pTab->nCol;

				pParse->nVar = 1;
				pParse->nMem = 1;
				pParse->nTab = 1;
				sqlite3VdbeMakeReady(v, pParse);
			}
		}

		pBlob->flags = flags;
		pBlob->iCol = iCol;
		pBlob->db = db;
		sqlite3BtreeLeaveAll(db);
		if (db->mallocFailed) {
			goto blob_open_out;
		}
		sqlite3_bind_int64(pBlob->pStmt, 1, iRow);
		rc = blobSeekToRow(pBlob, iRow, &zErr);
	} while ((++nAttempt)<SQLITE_MAX_SCHEMA_RETRY && rc == SQLITE_SCHEMA);

blob_open_out:
	if (rc == SQLITE_OK && db->mallocFailed == 0) {
		*ppBlob = (sqlite3_blob *)pBlob;
	}
	else {
		if (pBlob && pBlob->pStmt) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
		sqlite3DbFree(db, pBlob);
	}
	sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
	sqlite3DbFree(db, zErr);
	sqlite3ParserReset(pParse);
	sqlite3StackFree(db, pParse);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob) {
	Incrblob *p = (Incrblob *)pBlob;
	int rc;
	sqlite3 *db;

	if (p) {
		db = p->db;
		sqlite3_mutex_enter(db->mutex);
		rc = sqlite3_finalize(p->pStmt);
		sqlite3DbFree(db, p);
		sqlite3_mutex_leave(db->mutex);
	}
	else {
		rc = SQLITE_OK;
	}
	return rc;
}


static int blobReadWrite(
	sqlite3_blob *pBlob,
	void *z,
	int n,
	int iOffset,
	int(*xCall)(BtCursor*, u32, u32, void*)
) {
	int rc;
	Incrblob *p = (Incrblob *)pBlob;
	Vdbe *v;
	sqlite3 *db;

	if (p == 0) return SQLITE_MISUSE_BKPT;
	db = p->db;
	sqlite3_mutex_enter(db->mutex);
	v = (Vdbe*)p->pStmt;

	if (n<0 || iOffset<0 || ((sqlite3_int64)iOffset + n)>p->nByte) {
		
		rc = SQLITE_ERROR;
	}
	else if (v == 0) {
		
		rc = SQLITE_ABORT;
	}
	else {
		
		assert(db == v->db);
		sqlite3BtreeEnterCursor(p->pCsr);

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
		if (xCall == sqlite3BtreePutData && db->xPreUpdateCallback) {
			
			sqlite3_int64 iKey;
			iKey = sqlite3BtreeIntegerKey(p->pCsr);
			sqlite3VdbePreUpdateHook(
				v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1
			);
		}
#endif

		rc = xCall(p->pCsr, iOffset + p->iOffset, n, z);
		sqlite3BtreeLeaveCursor(p->pCsr);
		if (rc == SQLITE_ABORT) {
			sqlite3VdbeFinalize(v);
			p->pStmt = 0;
		}
		else {
			v->rc = rc;
		}
	}
	sqlite3Error(db, rc);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset) {
	return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);
}


SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset) {
	return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
}


SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob) {
	Incrblob *p = (Incrblob *)pBlob;
	return (p && p->pStmt) ? p->nByte : 0;
}


SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow) {
	int rc;
	Incrblob *p = (Incrblob *)pBlob;
	sqlite3 *db;

	if (p == 0) return SQLITE_MISUSE_BKPT;
	db = p->db;
	sqlite3_mutex_enter(db->mutex);

	if (p->pStmt == 0) {
		
		rc = SQLITE_ABORT;
	}
	else {
		char *zErr;
		rc = blobSeekToRow(p, iRow, &zErr);
		if (rc != SQLITE_OK) {
			sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
			sqlite3DbFree(db, zErr);
		}
		assert(rc != SQLITE_SCHEMA);
	}

	rc = sqlite3ApiExit(db, rc);
	assert(rc == SQLITE_OK || p->pStmt == 0);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}

#endif 








#if 0
# define SQLITE_DEBUG_SORTER_THREADS 1
#endif


#define SQLITE_MAX_PMASZ    (1<<29)


typedef struct MergeEngine MergeEngine;     
typedef struct PmaReader PmaReader;         
typedef struct PmaWriter PmaWriter;         
typedef struct SorterRecord SorterRecord;   
typedef struct SortSubtask SortSubtask;     
typedef struct SorterFile SorterFile;       
typedef struct SorterList SorterList;       
typedef struct IncrMerger IncrMerger;       

											
struct SorterFile {
	sqlite3_file *pFd;              
	i64 iEof;                       
};


struct SorterList {
	SorterRecord *pList;            
	u8 *aMemory;                    
	int szPMA;                      
};


struct MergeEngine {
	int nTree;                 
	SortSubtask *pTask;        
	int *aTree;                
	PmaReader *aReadr;         
};


typedef int(*SorterCompare)(SortSubtask*, int*, const void*, int, const void*, int);
struct SortSubtask {
	SQLiteThread *pThread;          
	int bDone;                      
	VdbeSorter *pSorter;            
	UnpackedRecord *pUnpacked;      
	SorterList list;                
	int nPMA;                       
	SorterCompare xCompare;         
	SorterFile file;                
	SorterFile file2;               
};



struct VdbeSorter {
	int mnPmaSize;                  
	int mxPmaSize;                  
	int mxKeysize;                  
	int pgsz;                       
	PmaReader *pReader;             
	MergeEngine *pMerger;           
	sqlite3 *db;                    
	KeyInfo *pKeyInfo;              
	UnpackedRecord *pUnpacked;      
	SorterList list;                
	int iMemory;                    
	int nMemory;                    
	u8 bUsePMA;                     
	u8 bUseThreads;                 
	u8 iPrev;                       
	u8 nTask;                       
	u8 typeMask;
	SortSubtask aTask[1];           
};

#define SORTER_TYPE_INTEGER 0x01
#define SORTER_TYPE_TEXT    0x02


struct PmaReader {
	i64 iReadOff;               
	i64 iEof;                   
	int nAlloc;                 
	int nKey;                   
	sqlite3_file *pFd;          
	u8 *aAlloc;                 
	u8 *aKey;                   
	u8 *aBuffer;                
	int nBuffer;                
	u8 *aMap;                   
	IncrMerger *pIncr;          
};


struct IncrMerger {
	SortSubtask *pTask;             
	MergeEngine *pMerger;           
	i64 iStartOff;                  
	int mxSz;                       
	int bEof;                       
	int bUseThread;                 
	SorterFile aFile[2];            
};


struct PmaWriter {
	int eFWErr;                     
	u8 *aBuffer;                    
	int nBuffer;                    
	int iBufStart;                  
	int iBufEnd;                    
	i64 iWriteOff;                  
	sqlite3_file *pFd;              
};


struct SorterRecord {
	int nVal;                       
	union {
		SorterRecord *pNext;          
		int iNext;                    
	} u;
	
};


#define SRVAL(p) ((void*)((SorterRecord*)(p) + 1))



#define SORTER_MAX_MERGE_COUNT 16

static int vdbeIncrSwap(IncrMerger*);
static void vdbeIncrFree(IncrMerger *);


static void vdbePmaReaderClear(PmaReader *pReadr) {
	sqlite3_free(pReadr->aAlloc);
	sqlite3_free(pReadr->aBuffer);
	if (pReadr->aMap) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
	vdbeIncrFree(pReadr->pIncr);
	memset(pReadr, 0, sizeof(PmaReader));
}


static int vdbePmaReadBlob(
	PmaReader *p,                   
	int nByte,                      
	u8 **ppOut                      
) {
	int iBuf;                       
	int nAvail;                     

	if (p->aMap) {
		*ppOut = &p->aMap[p->iReadOff];
		p->iReadOff += nByte;
		return SQLITE_OK;
	}

	assert(p->aBuffer);

	
	iBuf = p->iReadOff % p->nBuffer;
	if (iBuf == 0) {
		int nRead;                    
		int rc;                       

									  
		if ((p->iEof - p->iReadOff) > (i64)p->nBuffer) {
			nRead = p->nBuffer;
		}
		else {
			nRead = (int)(p->iEof - p->iReadOff);
		}
		assert(nRead>0);

		
		rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);
		assert(rc != SQLITE_IOERR_SHORT_READ);
		if (rc != SQLITE_OK) return rc;
	}
	nAvail = p->nBuffer - iBuf;

	if (nByte <= nAvail) {
		
		*ppOut = &p->aBuffer[iBuf];
		p->iReadOff += nByte;
	}
	else {
		
		int nRem;                     

									  
		if (p->nAlloc<nByte) {
			u8 *aNew;
			int nNew = MAX(128, p->nAlloc * 2);
			while (nByte>nNew) nNew = nNew * 2;
			aNew = sqlite3Realloc(p->aAlloc, nNew);
			if (!aNew) return SQLITE_NOMEM_BKPT;
			p->nAlloc = nNew;
			p->aAlloc = aNew;
		}

		
		memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
		p->iReadOff += nAvail;
		nRem = nByte - nAvail;

		
		while (nRem>0) {
			int rc;                     
			int nCopy;                  
			u8 *aNext;                  

			nCopy = nRem;
			if (nRem>p->nBuffer) nCopy = p->nBuffer;
			rc = vdbePmaReadBlob(p, nCopy, &aNext);
			if (rc != SQLITE_OK) return rc;
			assert(aNext != p->aAlloc);
			memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
			nRem -= nCopy;
		}

		*ppOut = p->aAlloc;
	}

	return SQLITE_OK;
}


static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut) {
	int iBuf;

	if (p->aMap) {
		p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);
	}
	else {
		iBuf = p->iReadOff % p->nBuffer;
		if (iBuf && (p->nBuffer - iBuf) >= 9) {
			p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);
		}
		else {
			u8 aVarint[16], *a;
			int i = 0, rc;
			do {
				rc = vdbePmaReadBlob(p, 1, &a);
				if (rc) return rc;
				aVarint[(i++) & 0xf] = a[0];
			} while ((a[0] & 0x80) != 0);
			sqlite3GetVarint(aVarint, pnOut);
		}
	}

	return SQLITE_OK;
}


static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp) {
	int rc = SQLITE_OK;
	if (pFile->iEof <= (i64)(pTask->pSorter->db->nMaxSorterMmap)) {
		sqlite3_file *pFd = pFile->pFd;
		if (pFd->pMethods->iVersion >= 3) {
			rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);
			testcase(rc != SQLITE_OK);
		}
	}
	return rc;
}


static int vdbePmaReaderSeek(
	SortSubtask *pTask,             
	PmaReader *pReadr,              
	SorterFile *pFile,              
	i64 iOff                        
) {
	int rc = SQLITE_OK;

	assert(pReadr->pIncr == 0 || pReadr->pIncr->bEof == 0);

	if (sqlite3FaultSim(201)) return SQLITE_IOERR_READ;
	if (pReadr->aMap) {
		sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
		pReadr->aMap = 0;
	}
	pReadr->iReadOff = iOff;
	pReadr->iEof = pFile->iEof;
	pReadr->pFd = pFile->pFd;

	rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);
	if (rc == SQLITE_OK && pReadr->aMap == 0) {
		int pgsz = pTask->pSorter->pgsz;
		int iBuf = pReadr->iReadOff % pgsz;
		if (pReadr->aBuffer == 0) {
			pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);
			if (pReadr->aBuffer == 0) rc = SQLITE_NOMEM_BKPT;
			pReadr->nBuffer = pgsz;
		}
		if (rc == SQLITE_OK && iBuf) {
			int nRead = pgsz - iBuf;
			if ((pReadr->iReadOff + nRead) > pReadr->iEof) {
				nRead = (int)(pReadr->iEof - pReadr->iReadOff);
			}
			rc = sqlite3OsRead(
				pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff
			);
			testcase(rc != SQLITE_OK);
		}
	}

	return rc;
}


static int vdbePmaReaderNext(PmaReader *pReadr) {
	int rc = SQLITE_OK;             
	u64 nRec = 0;                   


	if (pReadr->iReadOff >= pReadr->iEof) {
		IncrMerger *pIncr = pReadr->pIncr;
		int bEof = 1;
		if (pIncr) {
			rc = vdbeIncrSwap(pIncr);
			if (rc == SQLITE_OK && pIncr->bEof == 0) {
				rc = vdbePmaReaderSeek(
					pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff
				);
				bEof = 0;
			}
		}

		if (bEof) {
			
			vdbePmaReaderClear(pReadr);
			testcase(rc != SQLITE_OK);
			return rc;
		}
	}

	if (rc == SQLITE_OK) {
		rc = vdbePmaReadVarint(pReadr, &nRec);
	}
	if (rc == SQLITE_OK) {
		pReadr->nKey = (int)nRec;
		rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);
		testcase(rc != SQLITE_OK);
	}

	return rc;
}


static int vdbePmaReaderInit(
	SortSubtask *pTask,             
	SorterFile *pFile,              
	i64 iStart,                     
	PmaReader *pReadr,              
	i64 *pnByte                     
) {
	int rc;

	assert(pFile->iEof>iStart);
	assert(pReadr->aAlloc == 0 && pReadr->nAlloc == 0);
	assert(pReadr->aBuffer == 0);
	assert(pReadr->aMap == 0);

	rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
	if (rc == SQLITE_OK) {
		u64 nByte = 0;                 
		rc = vdbePmaReadVarint(pReadr, &nByte);
		pReadr->iEof = pReadr->iReadOff + nByte;
		*pnByte += nByte;
	}

	if (rc == SQLITE_OK) {
		rc = vdbePmaReaderNext(pReadr);
	}
	return rc;
}


static int vdbeSorterCompareTail(
	SortSubtask *pTask,             
	int *pbKey2Cached,              
	const void *pKey1, int nKey1,   
	const void *pKey2, int nKey2    
) {
	UnpackedRecord *r2 = pTask->pUnpacked;
	if (*pbKey2Cached == 0) {
		sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
		*pbKey2Cached = 1;
	}
	return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
}


static int vdbeSorterCompare(
	SortSubtask *pTask,             
	int *pbKey2Cached,              
	const void *pKey1, int nKey1,   
	const void *pKey2, int nKey2    
) {
	UnpackedRecord *r2 = pTask->pUnpacked;
	if (!*pbKey2Cached) {
		sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
		*pbKey2Cached = 1;
	}
	return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
}


static int vdbeSorterCompareText(
	SortSubtask *pTask,             
	int *pbKey2Cached,              
	const void *pKey1, int nKey1,   
	const void *pKey2, int nKey2    
) {
	const u8 * const p1 = (const u8 * const)pKey1;
	const u8 * const p2 = (const u8 * const)pKey2;
	const u8 * const v1 = &p1[p1[0]];   
	const u8 * const v2 = &p2[p2[0]];   

	int n1;
	int n2;
	int res;

	getVarint32(&p1[1], n1); n1 = (n1 - 13) / 2;
	getVarint32(&p2[1], n2); n2 = (n2 - 13) / 2;
	res = memcmp(v1, v2, MIN(n1, n2));
	if (res == 0) {
		res = n1 - n2;
	}

	if (res == 0) {
		if (pTask->pSorter->pKeyInfo->nField>1) {
			res = vdbeSorterCompareTail(
				pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
			);
		}
	}
	else {
		if (pTask->pSorter->pKeyInfo->aSortOrder[0]) {
			res = res * -1;
		}
	}

	return res;
}


static int vdbeSorterCompareInt(
	SortSubtask *pTask,             
	int *pbKey2Cached,              
	const void *pKey1, int nKey1,   
	const void *pKey2, int nKey2    
) {
	const u8 * const p1 = (const u8 * const)pKey1;
	const u8 * const p2 = (const u8 * const)pKey2;
	const int s1 = p1[1];                 
	const int s2 = p2[1];                 
	const u8 * const v1 = &p1[p1[0]];   
	const u8 * const v2 = &p2[p2[0]];   
	int res;                              

	assert((s1>0 && s1<7) || s1 == 8 || s1 == 9);
	assert((s2>0 && s2<7) || s2 == 8 || s2 == 9);

	if (s1>7 && s2>7) {
		res = s1 - s2;
	}
	else {
		if (s1 == s2) {
			if ((*v1 ^ *v2) & 0x80) {
				
				res = (*v1 & 0x80) ? -1 : +1;
			}
			else {
				
				static const u8 aLen[] = { 0, 1, 2, 3, 4, 6, 8 };
				int i;
				res = 0;
				for (i = 0; i<aLen[s1]; i++) {
					if ((res = v1[i] - v2[i])) break;
				}
			}
		}
		else {
			if (s2>7) {
				res = +1;
			}
			else if (s1>7) {
				res = -1;
			}
			else {
				res = s1 - s2;
			}
			assert(res != 0);

			if (res>0) {
				if (*v1 & 0x80) res = -1;
			}
			else {
				if (*v2 & 0x80) res = +1;
			}
		}
	}

	if (res == 0) {
		if (pTask->pSorter->pKeyInfo->nField>1) {
			res = vdbeSorterCompareTail(
				pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
			);
		}
	}
	else if (pTask->pSorter->pKeyInfo->aSortOrder[0]) {
		res = res * -1;
	}

	return res;
}


SQLITE_PRIVATE int sqlite3VdbeSorterInit(
	sqlite3 *db,                    
	int nField,                     
	VdbeCursor *pCsr                
) {
	int pgsz;                       
	int i;                          
	VdbeSorter *pSorter;            
	KeyInfo *pKeyInfo;              
	int szKeyInfo;                  
	int sz;                         
	int rc = SQLITE_OK;
#if SQLITE_MAX_WORKER_THREADS==0
# define nWorker 0
#else
	int nWorker;
#endif

	
#if SQLITE_MAX_WORKER_THREADS>0
	if (sqlite3TempInMemory(db) || sqlite3GlobalConfig.bCoreMutex == 0) {
		nWorker = 0;
	}
	else {
		nWorker = db->aLimit[SQLITE_LIMIT_WORKER_THREADS];
	}
#endif

	
#if SQLITE_MAX_WORKER_THREADS>=SORTER_MAX_MERGE_COUNT
	if (nWorker >= SORTER_MAX_MERGE_COUNT) {
		nWorker = SORTER_MAX_MERGE_COUNT - 1;
	}
#endif

	assert(pCsr->pKeyInfo && pCsr->pBt == 0);
	assert(pCsr->eCurType == CURTYPE_SORTER);
	szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nField - 1) * sizeof(CollSeq*);
	sz = sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask);

	pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);
	pCsr->uc.pSorter = pSorter;
	if (pSorter == 0) {
		rc = SQLITE_NOMEM_BKPT;
	}
	else {
		pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
		memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
		pKeyInfo->db = 0;
		if (nField && nWorker == 0) {
			pKeyInfo->nXField += (pKeyInfo->nField - nField);
			pKeyInfo->nField = nField;
		}
		pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt);
		pSorter->nTask = nWorker + 1;
		pSorter->iPrev = (u8)(nWorker - 1);
		pSorter->bUseThreads = (pSorter->nTask>1);
		pSorter->db = db;
		for (i = 0; i<pSorter->nTask; i++) {
			SortSubtask *pTask = &pSorter->aTask[i];
			pTask->pSorter = pSorter;
		}

		if (!sqlite3TempInMemory(db)) {
			i64 mxCache;                
			u32 szPma = sqlite3GlobalConfig.szPma;
			pSorter->mnPmaSize = szPma * pgsz;

			mxCache = db->aDb[0].pSchema->cache_size;
			if (mxCache<0) {
				
				mxCache = mxCache * -1024;
			}
			else {
				mxCache = mxCache * pgsz;
			}
			mxCache = MIN(mxCache, SQLITE_MAX_PMASZ);
			pSorter->mxPmaSize = MAX(pSorter->mnPmaSize, (int)mxCache);

			
			if (sqlite3GlobalConfig.pScratch == 0) {
				assert(pSorter->iMemory == 0);
				pSorter->nMemory = pgsz;
				pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);
				if (!pSorter->list.aMemory) rc = SQLITE_NOMEM_BKPT;
			}
		}

		if ((pKeyInfo->nField + pKeyInfo->nXField)<13
			&& (pKeyInfo->aColl[0] == 0 || pKeyInfo->aColl[0] == db->pDfltColl)
			) {
			pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;
		}
	}

	return rc;
}
#undef nWorker   


static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord) {
	SorterRecord *p;
	SorterRecord *pNext;
	for (p = pRecord; p; p = pNext) {
		pNext = p->u.pNext;
		sqlite3DbFree(db, p);
	}
}


static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask) {
	sqlite3DbFree(db, pTask->pUnpacked);
#if SQLITE_MAX_WORKER_THREADS>0
	
	if (pTask->list.aMemory) {
		sqlite3_free(pTask->list.aMemory);
	}
	else
#endif
	{
		assert(pTask->list.aMemory == 0);
		vdbeSorterRecordFree(0, pTask->list.pList);
	}
	if (pTask->file.pFd) {
		sqlite3OsCloseFree(pTask->file.pFd);
	}
	if (pTask->file2.pFd) {
		sqlite3OsCloseFree(pTask->file2.pFd);
	}
	memset(pTask, 0, sizeof(SortSubtask));
}

#ifdef SQLITE_DEBUG_SORTER_THREADS
static void vdbeSorterWorkDebug(SortSubtask *pTask, const char *zEvent) {
	i64 t;
	int iTask = (pTask - pTask->pSorter->aTask);
	sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
	fprintf(stderr, "%lld:%d %s\n", t, iTask, zEvent);
}
static void vdbeSorterRewindDebug(const char *zEvent) {
	i64 t;
	sqlite3OsCurrentTimeInt64(sqlite3_vfs_find(0), &t);
	fprintf(stderr, "%lld:X %s\n", t, zEvent);
}
static void vdbeSorterPopulateDebug(
	SortSubtask *pTask,
	const char *zEvent
) {
	i64 t;
	int iTask = (pTask - pTask->pSorter->aTask);
	sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
	fprintf(stderr, "%lld:bg%d %s\n", t, iTask, zEvent);
}
static void vdbeSorterBlockDebug(
	SortSubtask *pTask,
	int bBlocked,
	const char *zEvent
) {
	if (bBlocked) {
		i64 t;
		sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
		fprintf(stderr, "%lld:main %s\n", t, zEvent);
	}
}
#else
# define vdbeSorterWorkDebug(x,y)
# define vdbeSorterRewindDebug(y)
# define vdbeSorterPopulateDebug(x,y)
# define vdbeSorterBlockDebug(x,y,z)
#endif

#if SQLITE_MAX_WORKER_THREADS>0

static int vdbeSorterJoinThread(SortSubtask *pTask) {
	int rc = SQLITE_OK;
	if (pTask->pThread) {
#ifdef SQLITE_DEBUG_SORTER_THREADS
		int bDone = pTask->bDone;
#endif
		void *pRet = SQLITE_INT_TO_PTR(SQLITE_ERROR);
		vdbeSorterBlockDebug(pTask, !bDone, "enter");
		(void)sqlite3ThreadJoin(pTask->pThread, &pRet);
		vdbeSorterBlockDebug(pTask, !bDone, "exit");
		rc = SQLITE_PTR_TO_INT(pRet);
		assert(pTask->bDone == 1);
		pTask->bDone = 0;
		pTask->pThread = 0;
	}
	return rc;
}


static int vdbeSorterCreateThread(
	SortSubtask *pTask,             
	void *(*xTask)(void*),          
	void *pIn                       
) {
	assert(pTask->pThread == 0 && pTask->bDone == 0);
	return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);
}


static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin) {
	int rc = rcin;
	int i;

	
	for (i = pSorter->nTask - 1; i >= 0; i--) {
		SortSubtask *pTask = &pSorter->aTask[i];
		int rc2 = vdbeSorterJoinThread(pTask);
		if (rc == SQLITE_OK) rc = rc2;
	}
	return rc;
}
#else
# define vdbeSorterJoinAll(x,rcin) (rcin)
# define vdbeSorterJoinThread(pTask) SQLITE_OK
#endif


static MergeEngine *vdbeMergeEngineNew(int nReader) {
	int N = 2;                      
	int nByte;                      
	MergeEngine *pNew;              

	assert(nReader <= SORTER_MAX_MERGE_COUNT);

	while (N<nReader) N += N;
	nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));

	pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);
	if (pNew) {
		pNew->nTree = N;
		pNew->pTask = 0;
		pNew->aReadr = (PmaReader*)&pNew[1];
		pNew->aTree = (int*)&pNew->aReadr[N];
	}
	return pNew;
}


static void vdbeMergeEngineFree(MergeEngine *pMerger) {
	int i;
	if (pMerger) {
		for (i = 0; i<pMerger->nTree; i++) {
			vdbePmaReaderClear(&pMerger->aReadr[i]);
		}
	}
	sqlite3_free(pMerger);
}


static void vdbeIncrFree(IncrMerger *pIncr) {
	if (pIncr) {
#if SQLITE_MAX_WORKER_THREADS>0
		if (pIncr->bUseThread) {
			vdbeSorterJoinThread(pIncr->pTask);
			if (pIncr->aFile[0].pFd) sqlite3OsCloseFree(pIncr->aFile[0].pFd);
			if (pIncr->aFile[1].pFd) sqlite3OsCloseFree(pIncr->aFile[1].pFd);
		}
#endif
		vdbeMergeEngineFree(pIncr->pMerger);
		sqlite3_free(pIncr);
	}
}


SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter) {
	int i;
	(void)vdbeSorterJoinAll(pSorter, SQLITE_OK);
	assert(pSorter->bUseThreads || pSorter->pReader == 0);
#if SQLITE_MAX_WORKER_THREADS>0
	if (pSorter->pReader) {
		vdbePmaReaderClear(pSorter->pReader);
		sqlite3DbFree(db, pSorter->pReader);
		pSorter->pReader = 0;
	}
#endif
	vdbeMergeEngineFree(pSorter->pMerger);
	pSorter->pMerger = 0;
	for (i = 0; i<pSorter->nTask; i++) {
		SortSubtask *pTask = &pSorter->aTask[i];
		vdbeSortSubtaskCleanup(db, pTask);
		pTask->pSorter = pSorter;
	}
	if (pSorter->list.aMemory == 0) {
		vdbeSorterRecordFree(0, pSorter->list.pList);
	}
	pSorter->list.pList = 0;
	pSorter->list.szPMA = 0;
	pSorter->bUsePMA = 0;
	pSorter->iMemory = 0;
	pSorter->mxKeysize = 0;
	sqlite3DbFree(db, pSorter->pUnpacked);
	pSorter->pUnpacked = 0;
}


SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr) {
	VdbeSorter *pSorter;
	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	if (pSorter) {
		sqlite3VdbeSorterReset(db, pSorter);
		sqlite3_free(pSorter->list.aMemory);
		sqlite3DbFree(db, pSorter);
		pCsr->uc.pSorter = 0;
	}
}

#if SQLITE_MAX_MMAP_SIZE>0

static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte) {
	if (nByte <= (i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion >= 3) {
		void *p = 0;
		int chunksize = 4 * 1024;
		sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);
		sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);
		sqlite3OsFetch(pFd, 0, (int)nByte, &p);
		sqlite3OsUnfetch(pFd, 0, p);
	}
}
#else
# define vdbeSorterExtendFile(x,y,z)
#endif


static int vdbeSorterOpenTempFile(
	sqlite3 *db,                    
	i64 nExtend,                    
	sqlite3_file **ppFd
) {
	int rc;
	if (sqlite3FaultSim(202)) return SQLITE_IOERR_ACCESS;
	rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
		SQLITE_OPEN_TEMP_JOURNAL |
		SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |
		SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE, &rc
	);
	if (rc == SQLITE_OK) {
		i64 max = SQLITE_MAX_MMAP_SIZE;
		sqlite3OsFileControlHint(*ppFd, SQLITE_FCNTL_MMAP_SIZE, (void*)&max);
		if (nExtend>0) {
			vdbeSorterExtendFile(db, *ppFd, nExtend);
		}
	}
	return rc;
}


static int vdbeSortAllocUnpacked(SortSubtask *pTask) {
	if (pTask->pUnpacked == 0) {
		char *pFree;
		pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(
			pTask->pSorter->pKeyInfo, 0, 0, &pFree
		);
		assert(pTask->pUnpacked == (UnpackedRecord*)pFree);
		if (pFree == 0) return SQLITE_NOMEM_BKPT;
		pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nField;
		pTask->pUnpacked->errCode = 0;
	}
	return SQLITE_OK;
}



static SorterRecord *vdbeSorterMerge(
	SortSubtask *pTask,             
	SorterRecord *p1,               
	SorterRecord *p2                
) {
	SorterRecord *pFinal = 0;
	SorterRecord **pp = &pFinal;
	int bCached = 0;

	assert(p1 != 0 && p2 != 0);
	for (;;) {
		int res;
		res = pTask->xCompare(
			pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
		);

		if (res <= 0) {
			*pp = p1;
			pp = &p1->u.pNext;
			p1 = p1->u.pNext;
			if (p1 == 0) {
				*pp = p2;
				break;
			}
		}
		else {
			*pp = p2;
			pp = &p2->u.pNext;
			p2 = p2->u.pNext;
			bCached = 0;
			if (p2 == 0) {
				*pp = p1;
				break;
			}
		}
	}
	return pFinal;
}


static SorterCompare vdbeSorterGetCompare(VdbeSorter *p) {
	if (p->typeMask == SORTER_TYPE_INTEGER) {
		return vdbeSorterCompareInt;
	}
	else if (p->typeMask == SORTER_TYPE_TEXT) {
		return vdbeSorterCompareText;
	}
	return vdbeSorterCompare;
}


static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList) {
	int i;
	SorterRecord **aSlot;
	SorterRecord *p;
	int rc;

	rc = vdbeSortAllocUnpacked(pTask);
	if (rc != SQLITE_OK) return rc;

	p = pList->pList;
	pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);

	aSlot = (SorterRecord **)sqlite3MallocZero(64 * sizeof(SorterRecord *));
	if (!aSlot) {
		return SQLITE_NOMEM_BKPT;
	}

	while (p) {
		SorterRecord *pNext;
		if (pList->aMemory) {
			if ((u8*)p == pList->aMemory) {
				pNext = 0;
			}
			else {
				assert(p->u.iNext<sqlite3MallocSize(pList->aMemory));
				pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];
			}
		}
		else {
			pNext = p->u.pNext;
		}

		p->u.pNext = 0;
		for (i = 0; aSlot[i]; i++) {
			p = vdbeSorterMerge(pTask, p, aSlot[i]);
			aSlot[i] = 0;
		}
		aSlot[i] = p;
		p = pNext;
	}

	p = 0;
	for (i = 0; i<64; i++) {
		if (aSlot[i] == 0) continue;
		p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
	}
	pList->pList = p;

	sqlite3_free(aSlot);
	assert(pTask->pUnpacked->errCode == SQLITE_OK
		|| pTask->pUnpacked->errCode == SQLITE_NOMEM
	);
	return pTask->pUnpacked->errCode;
}


static void vdbePmaWriterInit(
	sqlite3_file *pFd,              
	PmaWriter *p,                   
	int nBuf,                       
	i64 iStart                      
) {
	memset(p, 0, sizeof(PmaWriter));
	p->aBuffer = (u8*)sqlite3Malloc(nBuf);
	if (!p->aBuffer) {
		p->eFWErr = SQLITE_NOMEM_BKPT;
	}
	else {
		p->iBufEnd = p->iBufStart = (iStart % nBuf);
		p->iWriteOff = iStart - p->iBufStart;
		p->nBuffer = nBuf;
		p->pFd = pFd;
	}
}


static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData) {
	int nRem = nData;
	while (nRem>0 && p->eFWErr == 0) {
		int nCopy = nRem;
		if (nCopy>(p->nBuffer - p->iBufEnd)) {
			nCopy = p->nBuffer - p->iBufEnd;
		}

		memcpy(&p->aBuffer[p->iBufEnd], &pData[nData - nRem], nCopy);
		p->iBufEnd += nCopy;
		if (p->iBufEnd == p->nBuffer) {
			p->eFWErr = sqlite3OsWrite(p->pFd,
				&p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
				p->iWriteOff + p->iBufStart
			);
			p->iBufStart = p->iBufEnd = 0;
			p->iWriteOff += p->nBuffer;
		}
		assert(p->iBufEnd<p->nBuffer);

		nRem -= nCopy;
	}
}


static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof) {
	int rc;
	if (p->eFWErr == 0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart) {
		p->eFWErr = sqlite3OsWrite(p->pFd,
			&p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
			p->iWriteOff + p->iBufStart
		);
	}
	*piEof = (p->iWriteOff + p->iBufEnd);
	sqlite3_free(p->aBuffer);
	rc = p->eFWErr;
	memset(p, 0, sizeof(PmaWriter));
	return rc;
}


static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal) {
	int nByte;
	u8 aByte[10];
	nByte = sqlite3PutVarint(aByte, iVal);
	vdbePmaWriteBlob(p, aByte, nByte);
}


static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList) {
	sqlite3 *db = pTask->pSorter->db;
	int rc = SQLITE_OK;             
	PmaWriter writer;               

#ifdef SQLITE_DEBUG
									
	i64 iSz = pList->szPMA + sqlite3VarintLen(pList->szPMA) + pTask->file.iEof;
#endif

	vdbeSorterWorkDebug(pTask, "enter");
	memset(&writer, 0, sizeof(PmaWriter));
	assert(pList->szPMA>0);

	
	if (pTask->file.pFd == 0) {
		rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);
		assert(rc != SQLITE_OK || pTask->file.pFd);
		assert(pTask->file.iEof == 0);
		assert(pTask->nPMA == 0);
	}

	
	if (rc == SQLITE_OK) {
		vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof + pList->szPMA + 9);
	}

	
	if (rc == SQLITE_OK) {
		rc = vdbeSorterSort(pTask, pList);
	}

	if (rc == SQLITE_OK) {
		SorterRecord *p;
		SorterRecord *pNext = 0;

		vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
			pTask->file.iEof);
		pTask->nPMA++;
		vdbePmaWriteVarint(&writer, pList->szPMA);
		for (p = pList->pList; p; p = pNext) {
			pNext = p->u.pNext;
			vdbePmaWriteVarint(&writer, p->nVal);
			vdbePmaWriteBlob(&writer, SRVAL(p), p->nVal);
			if (pList->aMemory == 0) sqlite3_free(p);
		}
		pList->pList = p;
		rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof);
	}

	vdbeSorterWorkDebug(pTask, "exit");
	assert(rc != SQLITE_OK || pList->pList == 0);
	assert(rc != SQLITE_OK || pTask->file.iEof == iSz);
	return rc;
}


static int vdbeMergeEngineStep(
	MergeEngine *pMerger,      
	int *pbEof                 
) {
	int rc;
	int iPrev = pMerger->aTree[1];
	SortSubtask *pTask = pMerger->pTask;

	
	rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);

	
	if (rc == SQLITE_OK) {
		int i;                      
		PmaReader *pReadr1;         
		PmaReader *pReadr2;         
		int bCached = 0;

		
		pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
		pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];

		for (i = (pMerger->nTree + iPrev) / 2; i>0; i = i / 2) {
			
			int iRes;
			if (pReadr1->pFd == 0) {
				iRes = +1;
			}
			else if (pReadr2->pFd == 0) {
				iRes = -1;
			}
			else {
				iRes = pTask->xCompare(pTask, &bCached,
					pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey
				);
			}

			
			if (iRes<0 || (iRes == 0 && pReadr1<pReadr2)) {
				pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
				pReadr2 = &pMerger->aReadr[pMerger->aTree[i ^ 0x0001]];
				bCached = 0;
			}
			else {
				if (pReadr1->pFd) bCached = 0;
				pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
				pReadr1 = &pMerger->aReadr[pMerger->aTree[i ^ 0x0001]];
			}
		}
		*pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd == 0);
	}

	return (rc == SQLITE_OK ? pTask->pUnpacked->errCode : rc);
}

#if SQLITE_MAX_WORKER_THREADS>0

static void *vdbeSorterFlushThread(void *pCtx) {
	SortSubtask *pTask = (SortSubtask*)pCtx;
	int rc;                         
	assert(pTask->bDone == 0);
	rc = vdbeSorterListToPMA(pTask, &pTask->list);
	pTask->bDone = 1;
	return SQLITE_INT_TO_PTR(rc);
}
#endif 


static int vdbeSorterFlushPMA(VdbeSorter *pSorter) {
#if SQLITE_MAX_WORKER_THREADS==0
	pSorter->bUsePMA = 1;
	return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);
#else
	int rc = SQLITE_OK;
	int i;
	SortSubtask *pTask = 0;    
	int nWorker = (pSorter->nTask - 1);

	
	pSorter->bUsePMA = 1;

	
	for (i = 0; i<nWorker; i++) {
		int iTest = (pSorter->iPrev + i + 1) % nWorker;
		pTask = &pSorter->aTask[iTest];
		if (pTask->bDone) {
			rc = vdbeSorterJoinThread(pTask);
		}
		if (rc != SQLITE_OK || pTask->pThread == 0) break;
	}

	if (rc == SQLITE_OK) {
		if (i == nWorker) {
			
			rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
		}
		else {
			
			u8 *aMem = pTask->list.aMemory;
			void *pCtx = (void*)pTask;

			assert(pTask->pThread == 0 && pTask->bDone == 0);
			assert(pTask->list.pList == 0);
			assert(pTask->list.aMemory == 0 || pSorter->list.aMemory != 0);

			pSorter->iPrev = (u8)(pTask - pSorter->aTask);
			pTask->list = pSorter->list;
			pSorter->list.pList = 0;
			pSorter->list.szPMA = 0;
			if (aMem) {
				pSorter->list.aMemory = aMem;
				pSorter->nMemory = sqlite3MallocSize(aMem);
			}
			else if (pSorter->list.aMemory) {
				pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);
				if (!pSorter->list.aMemory) return SQLITE_NOMEM_BKPT;
			}

			rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);
		}
	}

	return rc;
#endif 
}


SQLITE_PRIVATE int sqlite3VdbeSorterWrite(
	const VdbeCursor *pCsr,         
	Mem *pVal                       
) {
	VdbeSorter *pSorter;
	int rc = SQLITE_OK;             
	SorterRecord *pNew;             
	int bFlush;                     
	int nReq;                       
	int nPMA;                       
	int t;                          

	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	getVarint32((const u8*)&pVal->z[1], t);
	if (t>0 && t<10 && t != 7) {
		pSorter->typeMask &= SORTER_TYPE_INTEGER;
	}
	else if (t>10 && (t & 0x01)) {
		pSorter->typeMask &= SORTER_TYPE_TEXT;
	}
	else {
		pSorter->typeMask = 0;
	}

	assert(pSorter);

	
	nReq = pVal->n + sizeof(SorterRecord);
	nPMA = pVal->n + sqlite3VarintLen(pVal->n);
	if (pSorter->mxPmaSize) {
		if (pSorter->list.aMemory) {
			bFlush = pSorter->iMemory && (pSorter->iMemory + nReq) > pSorter->mxPmaSize;
		}
		else {
			bFlush = (
				(pSorter->list.szPMA > pSorter->mxPmaSize)
				|| (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())
				);
		}
		if (bFlush) {
			rc = vdbeSorterFlushPMA(pSorter);
			pSorter->list.szPMA = 0;
			pSorter->iMemory = 0;
			assert(rc != SQLITE_OK || pSorter->list.pList == 0);
		}
	}

	pSorter->list.szPMA += nPMA;
	if (nPMA>pSorter->mxKeysize) {
		pSorter->mxKeysize = nPMA;
	}

	if (pSorter->list.aMemory) {
		int nMin = pSorter->iMemory + nReq;

		if (nMin>pSorter->nMemory) {
			u8 *aNew;
			int iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
			int nNew = pSorter->nMemory * 2;
			while (nNew < nMin) nNew = nNew * 2;
			if (nNew > pSorter->mxPmaSize) nNew = pSorter->mxPmaSize;
			if (nNew < nMin) nNew = nMin;

			aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);
			if (!aNew) return SQLITE_NOMEM_BKPT;
			pSorter->list.pList = (SorterRecord*)&aNew[iListOff];
			pSorter->list.aMemory = aNew;
			pSorter->nMemory = nNew;
		}

		pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];
		pSorter->iMemory += ROUND8(nReq);
		if (pSorter->list.pList) {
			pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);
		}
	}
	else {
		pNew = (SorterRecord *)sqlite3Malloc(nReq);
		if (pNew == 0) {
			return SQLITE_NOMEM_BKPT;
		}
		pNew->u.pNext = pSorter->list.pList;
	}

	memcpy(SRVAL(pNew), pVal->z, pVal->n);
	pNew->nVal = pVal->n;
	pSorter->list.pList = pNew;

	return rc;
}


static int vdbeIncrPopulate(IncrMerger *pIncr) {
	int rc = SQLITE_OK;
	int rc2;
	i64 iStart = pIncr->iStartOff;
	SorterFile *pOut = &pIncr->aFile[1];
	SortSubtask *pTask = pIncr->pTask;
	MergeEngine *pMerger = pIncr->pMerger;
	PmaWriter writer;
	assert(pIncr->bEof == 0);

	vdbeSorterPopulateDebug(pTask, "enter");

	vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
	while (rc == SQLITE_OK) {
		int dummy;
		PmaReader *pReader = &pMerger->aReadr[pMerger->aTree[1]];
		int nKey = pReader->nKey;
		i64 iEof = writer.iWriteOff + writer.iBufEnd;

		
		if (pReader->pFd == 0) break;
		if ((iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz)) break;

		
		vdbePmaWriteVarint(&writer, nKey);
		vdbePmaWriteBlob(&writer, pReader->aKey, nKey);
		assert(pIncr->pMerger->pTask == pTask);
		rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);
	}

	rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof);
	if (rc == SQLITE_OK) rc = rc2;
	vdbeSorterPopulateDebug(pTask, "exit");
	return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0

static void *vdbeIncrPopulateThread(void *pCtx) {
	IncrMerger *pIncr = (IncrMerger*)pCtx;
	void *pRet = SQLITE_INT_TO_PTR(vdbeIncrPopulate(pIncr));
	pIncr->pTask->bDone = 1;
	return pRet;
}


static int vdbeIncrBgPopulate(IncrMerger *pIncr) {
	void *p = (void*)pIncr;
	assert(pIncr->bUseThread);
	return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);
}
#endif


static int vdbeIncrSwap(IncrMerger *pIncr) {
	int rc = SQLITE_OK;

#if SQLITE_MAX_WORKER_THREADS>0
	if (pIncr->bUseThread) {
		rc = vdbeSorterJoinThread(pIncr->pTask);

		if (rc == SQLITE_OK) {
			SorterFile f0 = pIncr->aFile[0];
			pIncr->aFile[0] = pIncr->aFile[1];
			pIncr->aFile[1] = f0;
		}

		if (rc == SQLITE_OK) {
			if (pIncr->aFile[0].iEof == pIncr->iStartOff) {
				pIncr->bEof = 1;
			}
			else {
				rc = vdbeIncrBgPopulate(pIncr);
			}
		}
	}
	else
#endif
	{
		rc = vdbeIncrPopulate(pIncr);
		pIncr->aFile[0] = pIncr->aFile[1];
		if (pIncr->aFile[0].iEof == pIncr->iStartOff) {
			pIncr->bEof = 1;
		}
	}

	return rc;
}


static int vdbeIncrMergerNew(
	SortSubtask *pTask,     
	MergeEngine *pMerger,   
	IncrMerger **ppOut      
) {
	int rc = SQLITE_OK;
	IncrMerger *pIncr = *ppOut = (IncrMerger*)
		(sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));
	if (pIncr) {
		pIncr->pMerger = pMerger;
		pIncr->pTask = pTask;
		pIncr->mxSz = MAX(pTask->pSorter->mxKeysize + 9, pTask->pSorter->mxPmaSize / 2);
		pTask->file2.iEof += pIncr->mxSz;
	}
	else {
		vdbeMergeEngineFree(pMerger);
		rc = SQLITE_NOMEM_BKPT;
	}
	return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0

static void vdbeIncrMergerSetThreads(IncrMerger *pIncr) {
	pIncr->bUseThread = 1;
	pIncr->pTask->file2.iEof -= pIncr->mxSz;
}
#endif 




static void vdbeMergeEngineCompare(
	MergeEngine *pMerger,  
	int iOut               
) {
	int i1;
	int i2;
	int iRes;
	PmaReader *p1;
	PmaReader *p2;

	assert(iOut<pMerger->nTree && iOut>0);

	if (iOut >= (pMerger->nTree / 2)) {
		i1 = (iOut - pMerger->nTree / 2) * 2;
		i2 = i1 + 1;
	}
	else {
		i1 = pMerger->aTree[iOut * 2];
		i2 = pMerger->aTree[iOut * 2 + 1];
	}

	p1 = &pMerger->aReadr[i1];
	p2 = &pMerger->aReadr[i2];

	if (p1->pFd == 0) {
		iRes = i2;
	}
	else if (p2->pFd == 0) {
		iRes = i1;
	}
	else {
		SortSubtask *pTask = pMerger->pTask;
		int bCached = 0;
		int res;
		assert(pTask->pUnpacked != 0);  
		res = pTask->xCompare(
			pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
		);
		if (res <= 0) {
			iRes = i1;
		}
		else {
			iRes = i2;
		}
	}

	pMerger->aTree[iOut] = iRes;
}


#define INCRINIT_NORMAL 0
#define INCRINIT_TASK   1
#define INCRINIT_ROOT   2


static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);


static int vdbeMergeEngineInit(
	SortSubtask *pTask,             
	MergeEngine *pMerger,           
	int eMode                       
) {
	int rc = SQLITE_OK;             
	int i;                          
	int nTree = pMerger->nTree;

	
	assert(SQLITE_MAX_WORKER_THREADS>0 || eMode == INCRINIT_NORMAL);

	
	assert(pMerger->pTask == 0);
	pMerger->pTask = pTask;

	for (i = 0; i<nTree; i++) {
		if (SQLITE_MAX_WORKER_THREADS>0 && eMode == INCRINIT_ROOT) {
			
			rc = vdbePmaReaderNext(&pMerger->aReadr[nTree - i - 1]);
		}
		else {
			rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);
		}
		if (rc != SQLITE_OK) return rc;
	}

	for (i = pMerger->nTree - 1; i>0; i--) {
		vdbeMergeEngineCompare(pMerger, i);
	}
	return pTask->pUnpacked->errCode;
}


static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode) {
	int rc = SQLITE_OK;
	IncrMerger *pIncr = pReadr->pIncr;
	SortSubtask *pTask = pIncr->pTask;
	sqlite3 *db = pTask->pSorter->db;

	
	assert(SQLITE_MAX_WORKER_THREADS>0 || eMode == INCRINIT_NORMAL);

	rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);

	
	if (rc == SQLITE_OK) {
		int mxSz = pIncr->mxSz;
#if SQLITE_MAX_WORKER_THREADS>0
		if (pIncr->bUseThread) {
			rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
			if (rc == SQLITE_OK) {
				rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
			}
		}
		else
#endif
			 {
			if (pTask->file2.pFd == 0) {
				assert(pTask->file2.iEof>0);
				rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
				pTask->file2.iEof = 0;
			}
			if (rc == SQLITE_OK) {
				pIncr->aFile[1].pFd = pTask->file2.pFd;
				pIncr->iStartOff = pTask->file2.iEof;
				pTask->file2.iEof += mxSz;
			}
		}
	}

#if SQLITE_MAX_WORKER_THREADS>0
	if (rc == SQLITE_OK && pIncr->bUseThread) {
		
		assert(eMode == INCRINIT_ROOT || eMode == INCRINIT_TASK);
		rc = vdbeIncrPopulate(pIncr);
	}
#endif

	if (rc == SQLITE_OK && (SQLITE_MAX_WORKER_THREADS == 0 || eMode != INCRINIT_TASK)) {
		rc = vdbePmaReaderNext(pReadr);
	}

	return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0

static void *vdbePmaReaderBgIncrInit(void *pCtx) {
	PmaReader *pReader = (PmaReader*)pCtx;
	void *pRet = SQLITE_INT_TO_PTR(
		vdbePmaReaderIncrMergeInit(pReader, INCRINIT_TASK)
	);
	pReader->pIncr->pTask->bDone = 1;
	return pRet;
}
#endif


static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode) {
	IncrMerger *pIncr = pReadr->pIncr;   
	int rc = SQLITE_OK;                  
	if (pIncr) {
#if SQLITE_MAX_WORKER_THREADS>0
		assert(pIncr->bUseThread == 0 || eMode == INCRINIT_TASK);
		if (pIncr->bUseThread) {
			void *pCtx = (void*)pReadr;
			rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
		}
		else
#endif
		{
			rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
		}
	}
	return rc;
}


static int vdbeMergeEngineLevel0(
	SortSubtask *pTask,             
	int nPMA,                       
	i64 *piOffset,                  
	MergeEngine **ppOut             
) {
	MergeEngine *pNew;              
	i64 iOff = *piOffset;
	int i;
	int rc = SQLITE_OK;

	*ppOut = pNew = vdbeMergeEngineNew(nPMA);
	if (pNew == 0) rc = SQLITE_NOMEM_BKPT;

	for (i = 0; i<nPMA && rc == SQLITE_OK; i++) {
		i64 nDummy = 0;
		PmaReader *pReadr = &pNew->aReadr[i];
		rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);
		iOff = pReadr->iEof;
	}

	if (rc != SQLITE_OK) {
		vdbeMergeEngineFree(pNew);
		*ppOut = 0;
	}
	*piOffset = iOff;
	return rc;
}


static int vdbeSorterTreeDepth(int nPMA) {
	int nDepth = 0;
	i64 nDiv = SORTER_MAX_MERGE_COUNT;
	while (nDiv < (i64)nPMA) {
		nDiv = nDiv * SORTER_MAX_MERGE_COUNT;
		nDepth++;
	}
	return nDepth;
}


static int vdbeSorterAddToTree(
	SortSubtask *pTask,             
	int nDepth,                     
	int iSeq,                       
	MergeEngine *pRoot,             
	MergeEngine *pLeaf              
) {
	int rc = SQLITE_OK;
	int nDiv = 1;
	int i;
	MergeEngine *p = pRoot;
	IncrMerger *pIncr;

	rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);

	for (i = 1; i<nDepth; i++) {
		nDiv = nDiv * SORTER_MAX_MERGE_COUNT;
	}

	for (i = 1; i<nDepth && rc == SQLITE_OK; i++) {
		int iIter = (iSeq / nDiv) % SORTER_MAX_MERGE_COUNT;
		PmaReader *pReadr = &p->aReadr[iIter];

		if (pReadr->pIncr == 0) {
			MergeEngine *pNew = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);
			if (pNew == 0) {
				rc = SQLITE_NOMEM_BKPT;
			}
			else {
				rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);
			}
		}
		if (rc == SQLITE_OK) {
			p = pReadr->pIncr->pMerger;
			nDiv = nDiv / SORTER_MAX_MERGE_COUNT;
		}
	}

	if (rc == SQLITE_OK) {
		p->aReadr[iSeq % SORTER_MAX_MERGE_COUNT].pIncr = pIncr;
	}
	else {
		vdbeIncrFree(pIncr);
	}
	return rc;
}


static int vdbeSorterMergeTreeBuild(
	VdbeSorter *pSorter,       
	MergeEngine **ppOut        
) {
	MergeEngine *pMain = 0;
	int rc = SQLITE_OK;
	int iTask;

#if SQLITE_MAX_WORKER_THREADS>0
	
	assert(pSorter->bUseThreads || pSorter->nTask == 1);
	if (pSorter->nTask>1) {
		pMain = vdbeMergeEngineNew(pSorter->nTask);
		if (pMain == 0) rc = SQLITE_NOMEM_BKPT;
	}
#endif

	for (iTask = 0; rc == SQLITE_OK && iTask<pSorter->nTask; iTask++) {
		SortSubtask *pTask = &pSorter->aTask[iTask];
		assert(pTask->nPMA>0 || SQLITE_MAX_WORKER_THREADS>0);
		if (SQLITE_MAX_WORKER_THREADS == 0 || pTask->nPMA) {
			MergeEngine *pRoot = 0;     
			int nDepth = vdbeSorterTreeDepth(pTask->nPMA);
			i64 iReadOff = 0;

			if (pTask->nPMA <= SORTER_MAX_MERGE_COUNT) {
				rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);
			}
			else {
				int i;
				int iSeq = 0;
				pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);
				if (pRoot == 0) rc = SQLITE_NOMEM_BKPT;
				for (i = 0; i<pTask->nPMA && rc == SQLITE_OK; i += SORTER_MAX_MERGE_COUNT) {
					MergeEngine *pMerger = 0; 
					int nReader;              

					nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);
					rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);
					if (rc == SQLITE_OK) {
						rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);
					}
				}
			}

			if (rc == SQLITE_OK) {
#if SQLITE_MAX_WORKER_THREADS>0
				if (pMain != 0) {
					rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);
				}
				else
#endif
				{
					assert(pMain == 0);
					pMain = pRoot;
				}
			}
			else {
				vdbeMergeEngineFree(pRoot);
			}
		}
	}

	if (rc != SQLITE_OK) {
		vdbeMergeEngineFree(pMain);
		pMain = 0;
	}
	*ppOut = pMain;
	return rc;
}


static int vdbeSorterSetupMerge(VdbeSorter *pSorter) {
	int rc;                         
	SortSubtask *pTask0 = &pSorter->aTask[0];
	MergeEngine *pMain = 0;
#if SQLITE_MAX_WORKER_THREADS
	sqlite3 *db = pTask0->pSorter->db;
	int i;
	SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
	for (i = 0; i<pSorter->nTask; i++) {
		pSorter->aTask[i].xCompare = xCompare;
	}
#endif

	rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);
	if (rc == SQLITE_OK) {
#if SQLITE_MAX_WORKER_THREADS
		assert(pSorter->bUseThreads == 0 || pSorter->nTask>1);
		if (pSorter->bUseThreads) {
			int iTask;
			PmaReader *pReadr = 0;
			SortSubtask *pLast = &pSorter->aTask[pSorter->nTask - 1];
			rc = vdbeSortAllocUnpacked(pLast);
			if (rc == SQLITE_OK) {
				pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));
				pSorter->pReader = pReadr;
				if (pReadr == 0) rc = SQLITE_NOMEM_BKPT;
			}
			if (rc == SQLITE_OK) {
				rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);
				if (rc == SQLITE_OK) {
					vdbeIncrMergerSetThreads(pReadr->pIncr);
					for (iTask = 0; iTask<(pSorter->nTask - 1); iTask++) {
						IncrMerger *pIncr;
						if ((pIncr = pMain->aReadr[iTask].pIncr)) {
							vdbeIncrMergerSetThreads(pIncr);
							assert(pIncr->pTask != pLast);
						}
					}
					for (iTask = 0; rc == SQLITE_OK && iTask<pSorter->nTask; iTask++) {
						
						PmaReader *p = &pMain->aReadr[iTask];
						assert(p->pIncr == 0 || (
							(p->pIncr->pTask == &pSorter->aTask[iTask])             
							&& (iTask != pSorter->nTask - 1 || p->pIncr->bUseThread == 0)  
							));
						rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);
					}
				}
				pMain = 0;
			}
			if (rc == SQLITE_OK) {
				rc = vdbePmaReaderIncrMergeInit(pReadr, INCRINIT_ROOT);
			}
		}
		else
#endif
		{
			rc = vdbeMergeEngineInit(pTask0, pMain, INCRINIT_NORMAL);
			pSorter->pMerger = pMain;
			pMain = 0;
		}
	}

	if (rc != SQLITE_OK) {
		vdbeMergeEngineFree(pMain);
	}
	return rc;
}



SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof) {
	VdbeSorter *pSorter;
	int rc = SQLITE_OK;             

	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	assert(pSorter);

	
	if (pSorter->bUsePMA == 0) {
		if (pSorter->list.pList) {
			*pbEof = 0;
			rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);
		}
		else {
			*pbEof = 1;
		}
		return rc;
	}

	
	assert(pSorter->list.pList);
	rc = vdbeSorterFlushPMA(pSorter);

	
	rc = vdbeSorterJoinAll(pSorter, rc);

	vdbeSorterRewindDebug("rewind");

	
	assert(pSorter->pReader == 0);
	if (rc == SQLITE_OK) {
		rc = vdbeSorterSetupMerge(pSorter);
		*pbEof = 0;
	}

	vdbeSorterRewindDebug("rewinddone");
	return rc;
}


SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr, int *pbEof) {
	VdbeSorter *pSorter;
	int rc;                         

	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	assert(pSorter->bUsePMA || (pSorter->pReader == 0 && pSorter->pMerger == 0));
	if (pSorter->bUsePMA) {
		assert(pSorter->pReader == 0 || pSorter->pMerger == 0);
		assert(pSorter->bUseThreads == 0 || pSorter->pReader);
		assert(pSorter->bUseThreads == 1 || pSorter->pMerger);
#if SQLITE_MAX_WORKER_THREADS>0
		if (pSorter->bUseThreads) {
			rc = vdbePmaReaderNext(pSorter->pReader);
			*pbEof = (pSorter->pReader->pFd == 0);
		}
		else
#endif
			 {
			assert(pSorter->pMerger != 0);
			assert(pSorter->pMerger->pTask == (&pSorter->aTask[0]));
			rc = vdbeMergeEngineStep(pSorter->pMerger, pbEof);
		}
	}
	else {
		SorterRecord *pFree = pSorter->list.pList;
		pSorter->list.pList = pFree->u.pNext;
		pFree->u.pNext = 0;
		if (pSorter->list.aMemory == 0) vdbeSorterRecordFree(db, pFree);
		*pbEof = !pSorter->list.pList;
		rc = SQLITE_OK;
	}
	return rc;
}


static void *vdbeSorterRowkey(
	const VdbeSorter *pSorter,      
	int *pnKey                      
) {
	void *pKey;
	if (pSorter->bUsePMA) {
		PmaReader *pReader;
#if SQLITE_MAX_WORKER_THREADS>0
		if (pSorter->bUseThreads) {
			pReader = pSorter->pReader;
		}
		else
#endif
			 {
			pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];
		}
		*pnKey = pReader->nKey;
		pKey = pReader->aKey;
	}
	else {
		*pnKey = pSorter->list.pList->nVal;
		pKey = SRVAL(pSorter->list.pList);
	}
	return pKey;
}


SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut) {
	VdbeSorter *pSorter;
	void *pKey; int nKey;           

	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	pKey = vdbeSorterRowkey(pSorter, &nKey);
	if (sqlite3VdbeMemClearAndResize(pOut, nKey)) {
		return SQLITE_NOMEM_BKPT;
	}
	pOut->n = nKey;
	MemSetTypeFlag(pOut, MEM_Blob);
	memcpy(pOut->z, pKey, nKey);

	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VdbeSorterCompare(
	const VdbeCursor *pCsr,         
	Mem *pVal,                      
	int nKeyCol,                    
	int *pRes                       
) {
	VdbeSorter *pSorter;
	UnpackedRecord *r2;
	KeyInfo *pKeyInfo;
	int i;
	void *pKey; int nKey;           

	assert(pCsr->eCurType == CURTYPE_SORTER);
	pSorter = pCsr->uc.pSorter;
	r2 = pSorter->pUnpacked;
	pKeyInfo = pCsr->pKeyInfo;
	if (r2 == 0) {
		char *p;
		r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo, 0, 0, &p);
		assert(pSorter->pUnpacked == (UnpackedRecord*)p);
		if (r2 == 0) return SQLITE_NOMEM_BKPT;
		r2->nField = nKeyCol;
	}
	assert(r2->nField == nKeyCol);

	pKey = vdbeSorterRowkey(pSorter, &nKey);
	sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2);
	for (i = 0; i<nKeyCol; i++) {
		if (r2->aMem[i].flags & MEM_Null) {
			*pRes = -1;
			return SQLITE_OK;
		}
	}

	*pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);
	return SQLITE_OK;
}







typedef struct MemJournal MemJournal;
typedef struct FilePoint FilePoint;
typedef struct FileChunk FileChunk;


struct FileChunk {
	FileChunk *pNext;               
	u8 zChunk[8];                   
};


#define MEMJOURNAL_DFLT_FILECHUNKSIZE 1024


#define fileChunkSize(nChunkSize) (sizeof(FileChunk) + ((nChunkSize)-8))


struct FilePoint {
	sqlite3_int64 iOffset;          
	FileChunk *pChunk;              
};


struct MemJournal {
	const sqlite3_io_methods *pMethod; 
	int nChunkSize;                 

	int nSpill;                     
	int nSize;                      
	FileChunk *pFirst;              
	FilePoint endpoint;             
	FilePoint readpoint;            

	int flags;                      
	sqlite3_vfs *pVfs;              
	const char *zJournal;           
};


static int memjrnlRead(
	sqlite3_file *pJfd,    
	void *zBuf,            
	int iAmt,              
	sqlite_int64 iOfst     
) {
	MemJournal *p = (MemJournal *)pJfd;
	u8 *zOut = zBuf;
	int nRead = iAmt;
	int iChunkOffset;
	FileChunk *pChunk;

#ifdef SQLITE_ENABLE_ATOMIC_WRITE
	if ((iAmt + iOfst)>p->endpoint.iOffset) {
		return SQLITE_IOERR_SHORT_READ;
	}
#endif

	assert((iAmt + iOfst) <= p->endpoint.iOffset);
	assert(p->readpoint.iOffset == 0 || p->readpoint.pChunk != 0);
	if (p->readpoint.iOffset != iOfst || iOfst == 0) {
		sqlite3_int64 iOff = 0;
		for (pChunk = p->pFirst;
			ALWAYS(pChunk) && (iOff + p->nChunkSize) <= iOfst;
			pChunk = pChunk->pNext
			) {
			iOff += p->nChunkSize;
		}
	}
	else {
		pChunk = p->readpoint.pChunk;
		assert(pChunk != 0);
	}

	iChunkOffset = (int)(iOfst%p->nChunkSize);
	do {
		int iSpace = p->nChunkSize - iChunkOffset;
		int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));
		memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
		zOut += nCopy;
		nRead -= iSpace;
		iChunkOffset = 0;
	} while (nRead >= 0 && (pChunk = pChunk->pNext) != 0 && nRead>0);
	p->readpoint.iOffset = pChunk ? iOfst + iAmt : 0;
	p->readpoint.pChunk = pChunk;

	return SQLITE_OK;
}


static void memjrnlFreeChunks(MemJournal *p) {
	FileChunk *pIter;
	FileChunk *pNext;
	for (pIter = p->pFirst; pIter; pIter = pNext) {
		pNext = pIter->pNext;
		sqlite3_free(pIter);
	}
	p->pFirst = 0;
}


static int memjrnlCreateFile(MemJournal *p) {
	int rc;
	sqlite3_file *pReal = (sqlite3_file*)p;
	MemJournal copy = *p;

	memset(p, 0, sizeof(MemJournal));
	rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);
	if (rc == SQLITE_OK) {
		int nChunk = copy.nChunkSize;
		i64 iOff = 0;
		FileChunk *pIter;
		for (pIter = copy.pFirst; pIter; pIter = pIter->pNext) {
			if (iOff + nChunk > copy.endpoint.iOffset) {
				nChunk = copy.endpoint.iOffset - iOff;
			}
			rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);
			if (rc) break;
			iOff += nChunk;
		}
		if (rc == SQLITE_OK) {
			
			memjrnlFreeChunks(&copy);
		}
	}
	if (rc != SQLITE_OK) {
		
		sqlite3OsClose(pReal);
		*p = copy;
	}
	return rc;
}



static int memjrnlWrite(
	sqlite3_file *pJfd,    
	const void *zBuf,      
	int iAmt,              
	sqlite_int64 iOfst     
) {
	MemJournal *p = (MemJournal *)pJfd;
	int nWrite = iAmt;
	u8 *zWrite = (u8 *)zBuf;

	
	if (p->nSpill>0 && (iAmt + iOfst)>p->nSpill) {
		int rc = memjrnlCreateFile(p);
		if (rc == SQLITE_OK) {
			rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);
		}
		return rc;
	}

	
	else {
		
		assert(iOfst == p->endpoint.iOffset || iOfst == 0);
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
		if (iOfst == 0 && p->pFirst) {
			assert(p->nChunkSize>iAmt);
			memcpy((u8*)p->pFirst->zChunk, zBuf, iAmt);
		}
		else
#else
		assert(iOfst>0 || p->pFirst == 0);
#endif
		{
			while (nWrite>0) {
				FileChunk *pChunk = p->endpoint.pChunk;
				int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);
				int iSpace = MIN(nWrite, p->nChunkSize - iChunkOffset);

				if (iChunkOffset == 0) {
					
					FileChunk *pNew = sqlite3_malloc(fileChunkSize(p->nChunkSize));
					if (!pNew) {
						return SQLITE_IOERR_NOMEM_BKPT;
					}
					pNew->pNext = 0;
					if (pChunk) {
						assert(p->pFirst);
						pChunk->pNext = pNew;
					}
					else {
						assert(!p->pFirst);
						p->pFirst = pNew;
					}
					p->endpoint.pChunk = pNew;
				}

				memcpy((u8*)p->endpoint.pChunk->zChunk + iChunkOffset, zWrite, iSpace);
				zWrite += iSpace;
				nWrite -= iSpace;
				p->endpoint.iOffset += iSpace;
			}
			p->nSize = iAmt + iOfst;
		}
	}

	return SQLITE_OK;
}


static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size) {
	MemJournal *p = (MemJournal *)pJfd;
	if (ALWAYS(size == 0)) {
		memjrnlFreeChunks(p);
		p->nSize = 0;
		p->endpoint.pChunk = 0;
		p->endpoint.iOffset = 0;
		p->readpoint.pChunk = 0;
		p->readpoint.iOffset = 0;
	}
	return SQLITE_OK;
}


static int memjrnlClose(sqlite3_file *pJfd) {
	MemJournal *p = (MemJournal *)pJfd;
	memjrnlFreeChunks(p);
	return SQLITE_OK;
}


static int memjrnlSync(sqlite3_file *pJfd, int flags) {
	UNUSED_PARAMETER2(pJfd, flags);
	return SQLITE_OK;
}


static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize) {
	MemJournal *p = (MemJournal *)pJfd;
	*pSize = (sqlite_int64)p->endpoint.iOffset;
	return SQLITE_OK;
}


static const struct sqlite3_io_methods MemJournalMethods = {
	1,                
	memjrnlClose,     
	memjrnlRead,      
	memjrnlWrite,     
	memjrnlTruncate,  
	memjrnlSync,      
	memjrnlFileSize,  
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0,                
	0                 
};


SQLITE_PRIVATE int sqlite3JournalOpen(
	sqlite3_vfs *pVfs,         
	const char *zName,         
	sqlite3_file *pJfd,        
	int flags,                 
	int nSpill                 
) {
	MemJournal *p = (MemJournal*)pJfd;

	
	memset(p, 0, sizeof(MemJournal));
	if (nSpill == 0) {
		return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);
	}

	if (nSpill>0) {
		p->nChunkSize = nSpill;
	}
	else {
		p->nChunkSize = 8 + MEMJOURNAL_DFLT_FILECHUNKSIZE - sizeof(FileChunk);
		assert(MEMJOURNAL_DFLT_FILECHUNKSIZE == fileChunkSize(p->nChunkSize));
	}

	p->pMethod = (const sqlite3_io_methods*)&MemJournalMethods;
	p->nSpill = nSpill;
	p->flags = flags;
	p->zJournal = zName;
	p->pVfs = pVfs;
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *pJfd) {
	sqlite3JournalOpen(0, 0, pJfd, 0, -1);
}

#ifdef SQLITE_ENABLE_ATOMIC_WRITE

SQLITE_PRIVATE int sqlite3JournalCreate(sqlite3_file *p) {
	int rc = SQLITE_OK;
	if (p->pMethods == &MemJournalMethods && ((MemJournal*)p)->nSpill>0) {
		rc = memjrnlCreateFile((MemJournal*)p);
	}
	return rc;
}
#endif


SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p) {
	return p->pMethods == &MemJournalMethods;
}


SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *pVfs) {
	return MAX(pVfs->szOsFile, (int)sizeof(MemJournal));
}










static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr) {
	int rc;
	testcase(ExprHasProperty(pExpr, EP_TokenOnly));
	testcase(ExprHasProperty(pExpr, EP_Reduced));
	rc = pWalker->xExprCallback(pWalker, pExpr);
	if (rc || ExprHasProperty(pExpr, (EP_TokenOnly | EP_Leaf))) {
		return rc & WRC_Abort;
	}
	if (pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft)) return WRC_Abort;
	if (pExpr->pRight && walkExpr(pWalker, pExpr->pRight)) return WRC_Abort;
	if (ExprHasProperty(pExpr, EP_xIsSelect)) {
		if (sqlite3WalkSelect(pWalker, pExpr->x.pSelect)) return WRC_Abort;
	}
	else if (pExpr->x.pList) {
		if (sqlite3WalkExprList(pWalker, pExpr->x.pList)) return WRC_Abort;
	}
	return WRC_Continue;
}
SQLITE_PRIVATE int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr) {
	return pExpr ? walkExpr(pWalker, pExpr) : WRC_Continue;
}


SQLITE_PRIVATE int sqlite3WalkExprList(Walker *pWalker, ExprList *p) {
	int i;
	struct ExprList_item *pItem;
	if (p) {
		for (i = p->nExpr, pItem = p->a; i>0; i--, pItem++) {
			if (sqlite3WalkExpr(pWalker, pItem->pExpr)) return WRC_Abort;
		}
	}
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker *pWalker, Select *p) {
	if (sqlite3WalkExprList(pWalker, p->pEList)) return WRC_Abort;
	if (sqlite3WalkExpr(pWalker, p->pWhere)) return WRC_Abort;
	if (sqlite3WalkExprList(pWalker, p->pGroupBy)) return WRC_Abort;
	if (sqlite3WalkExpr(pWalker, p->pHaving)) return WRC_Abort;
	if (sqlite3WalkExprList(pWalker, p->pOrderBy)) return WRC_Abort;
	if (sqlite3WalkExpr(pWalker, p->pLimit)) return WRC_Abort;
	if (sqlite3WalkExpr(pWalker, p->pOffset)) return WRC_Abort;
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p) {
	SrcList *pSrc;
	int i;
	struct SrcList_item *pItem;

	pSrc = p->pSrc;
	if (ALWAYS(pSrc)) {
		for (i = pSrc->nSrc, pItem = pSrc->a; i>0; i--, pItem++) {
			if (sqlite3WalkSelect(pWalker, pItem->pSelect)) {
				return WRC_Abort;
			}
			if (pItem->fg.isTabFunc
				&& sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)
				) {
				return WRC_Abort;
			}
		}
	}
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p) {
	int rc;
	if (p == 0 || (pWalker->xSelectCallback == 0 && pWalker->xSelectCallback2 == 0)) {
		return WRC_Continue;
	}
	rc = WRC_Continue;
	pWalker->walkerDepth++;
	while (p) {
		if (pWalker->xSelectCallback) {
			rc = pWalker->xSelectCallback(pWalker, p);
			if (rc) break;
		}
		if (sqlite3WalkSelectExpr(pWalker, p)
			|| sqlite3WalkSelectFrom(pWalker, p)
			) {
			pWalker->walkerDepth--;
			return WRC_Abort;
		}
		if (pWalker->xSelectCallback2) {
			pWalker->xSelectCallback2(pWalker, p);
		}
		p = p->pPrior;
	}
	pWalker->walkerDepth--;
	return rc & WRC_Abort;
}









static int incrAggDepth(Walker *pWalker, Expr *pExpr) {
	if (pExpr->op == TK_AGG_FUNCTION) pExpr->op2 += pWalker->u.n;
	return WRC_Continue;
}
static void incrAggFunctionDepth(Expr *pExpr, int N) {
	if (N>0) {
		Walker w;
		memset(&w, 0, sizeof(w));
		w.xExprCallback = incrAggDepth;
		w.u.n = N;
		sqlite3WalkExpr(&w, pExpr);
	}
}


static void resolveAlias(
	Parse *pParse,         
	ExprList *pEList,      
	int iCol,              
	Expr *pExpr,           
	const char *zType,     
	int nSubquery          
) {
	Expr *pOrig;           
	Expr *pDup;            
	sqlite3 *db;           

	assert(iCol >= 0 && iCol<pEList->nExpr);
	pOrig = pEList->a[iCol].pExpr;
	assert(pOrig != 0);
	db = pParse->db;
	pDup = sqlite3ExprDup(db, pOrig, 0);
	if (pDup == 0) return;
	if (zType[0] != 'G') incrAggFunctionDepth(pDup, nSubquery);
	if (pExpr->op == TK_COLLATE) {
		pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
	}
	ExprSetProperty(pDup, EP_Alias);

	
	ExprSetProperty(pExpr, EP_Static);
	sqlite3ExprDelete(db, pExpr);
	memcpy(pExpr, pDup, sizeof(*pExpr));
	if (!ExprHasProperty(pExpr, EP_IntValue) && pExpr->u.zToken != 0) {
		assert((pExpr->flags & (EP_Reduced | EP_TokenOnly)) == 0);
		pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);
		pExpr->flags |= EP_MemToken;
	}
	sqlite3DbFree(db, pDup);
}



static int nameInUsingClause(IdList *pUsing, const char *zCol) {
	if (pUsing) {
		int k;
		for (k = 0; k<pUsing->nId; k++) {
			if (sqlite3StrICmp(pUsing->a[k].zName, zCol) == 0) return 1;
		}
	}
	return 0;
}


SQLITE_PRIVATE int sqlite3MatchSpanName(
	const char *zSpan,
	const char *zCol,
	const char *zTab,
	const char *zDb
) {
	int n;
	for (n = 0; ALWAYS(zSpan[n]) && zSpan[n] != '.'; n++) {}
	if (zDb && (sqlite3StrNICmp(zSpan, zDb, n) != 0 || zDb[n] != 0)) {
		return 0;
	}
	zSpan += n + 1;
	for (n = 0; ALWAYS(zSpan[n]) && zSpan[n] != '.'; n++) {}
	if (zTab && (sqlite3StrNICmp(zSpan, zTab, n) != 0 || zTab[n] != 0)) {
		return 0;
	}
	zSpan += n + 1;
	if (zCol && sqlite3StrICmp(zSpan, zCol) != 0) {
		return 0;
	}
	return 1;
}


static int lookupName(
	Parse *pParse,       
	const char *zDb,     
	const char *zTab,    
	const char *zCol,    
	NameContext *pNC,    
	Expr *pExpr          
) {
	int i, j;                         
	int cnt = 0;                      
	int cntTab = 0;                   
	int nSubquery = 0;                
	sqlite3 *db = pParse->db;         
	struct SrcList_item *pItem;       
	struct SrcList_item *pMatch = 0;  
	NameContext *pTopNC = pNC;        
	Schema *pSchema = 0;              
	int isTrigger = 0;                
	Table *pTab = 0;                  
	Column *pCol;                     

	assert(pNC);     
	assert(zCol);    
	assert(!ExprHasProperty(pExpr, EP_TokenOnly | EP_Reduced));

	
	pExpr->iTable = -1;
	pExpr->pTab = 0;
	ExprSetVVAProperty(pExpr, EP_NoReduce);

	
	if (zDb) {
		testcase(pNC->ncFlags & NC_PartIdx);
		testcase(pNC->ncFlags & NC_IsCheck);
		if ((pNC->ncFlags & (NC_PartIdx | NC_IsCheck)) != 0) {
			
			zDb = 0;
		}
		else {
			for (i = 0; i<db->nDb; i++) {
				assert(db->aDb[i].zDbSName);
				if (sqlite3StrICmp(db->aDb[i].zDbSName, zDb) == 0) {
					pSchema = db->aDb[i].pSchema;
					break;
				}
			}
		}
	}

	
	while (pNC && cnt == 0) {
		ExprList *pEList;
		SrcList *pSrcList = pNC->pSrcList;

		if (pSrcList) {
			for (i = 0, pItem = pSrcList->a; i<pSrcList->nSrc; i++, pItem++) {
				pTab = pItem->pTab;
				assert(pTab != 0 && pTab->zName != 0);
				assert(pTab->nCol>0);
				if (pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom) != 0) {
					int hit = 0;
					pEList = pItem->pSelect->pEList;
					for (j = 0; j<pEList->nExpr; j++) {
						if (sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb)) {
							cnt++;
							cntTab = 2;
							pMatch = pItem;
							pExpr->iColumn = j;
							hit = 1;
						}
					}
					if (hit || zTab == 0) continue;
				}
				if (zDb && pTab->pSchema != pSchema) {
					continue;
				}
				if (zTab) {
					const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;
					assert(zTabName != 0);
					if (sqlite3StrICmp(zTabName, zTab) != 0) {
						continue;
					}
				}
				if (0 == (cntTab++)) {
					pMatch = pItem;
				}
				for (j = 0, pCol = pTab->aCol; j<pTab->nCol; j++, pCol++) {
					if (sqlite3StrICmp(pCol->zName, zCol) == 0) {
						
						if (cnt == 1) {
							if (pItem->fg.jointype & JT_NATURAL) continue;
							if (nameInUsingClause(pItem->pUsing, zCol)) continue;
						}
						cnt++;
						pMatch = pItem;
						
						pExpr->iColumn = j == pTab->iPKey ? -1 : (i16)j;
						break;
					}
				}
			}
			if (pMatch) {
				pExpr->iTable = pMatch->iCursor;
				pExpr->pTab = pMatch->pTab;
				
				assert((pMatch->fg.jointype & JT_RIGHT) == 0);
				if ((pMatch->fg.jointype & JT_LEFT) != 0) {
					ExprSetProperty(pExpr, EP_CanBeNull);
				}
				pSchema = pExpr->pTab->pSchema;
			}
		} 

#ifndef SQLITE_OMIT_TRIGGER
		  
		if (zDb == 0 && zTab != 0 && cntTab == 0 && pParse->pTriggerTab != 0) {
			int op = pParse->eTriggerOp;
			assert(op == TK_DELETE || op == TK_UPDATE || op == TK_INSERT);
			if (op != TK_DELETE && sqlite3StrICmp("new", zTab) == 0) {
				pExpr->iTable = 1;
				pTab = pParse->pTriggerTab;
			}
			else if (op != TK_INSERT && sqlite3StrICmp("old", zTab) == 0) {
				pExpr->iTable = 0;
				pTab = pParse->pTriggerTab;
			}
			else {
				pTab = 0;
			}

			if (pTab) {
				int iCol;
				pSchema = pTab->pSchema;
				cntTab++;
				for (iCol = 0, pCol = pTab->aCol; iCol<pTab->nCol; iCol++, pCol++) {
					if (sqlite3StrICmp(pCol->zName, zCol) == 0) {
						if (iCol == pTab->iPKey) {
							iCol = -1;
						}
						break;
					}
				}
				if (iCol >= pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab)) {
					
					iCol = -1;
				}
				if (iCol<pTab->nCol) {
					cnt++;
					if (iCol<0) {
						pExpr->affinity = SQLITE_AFF_INTEGER;
					}
					else if (pExpr->iTable == 0) {
						testcase(iCol == 31);
						testcase(iCol == 32);
						pParse->oldmask |= (iCol >= 32 ? 0xffffffff : (((u32)1) << iCol));
					}
					else {
						testcase(iCol == 31);
						testcase(iCol == 32);
						pParse->newmask |= (iCol >= 32 ? 0xffffffff : (((u32)1) << iCol));
					}
					pExpr->iColumn = (i16)iCol;
					pExpr->pTab = pTab;
					isTrigger = 1;
				}
			}
		}
#endif 

		
		if (cnt == 0
			&& cntTab == 1
			&& pMatch
			&& (pNC->ncFlags & NC_IdxExpr) == 0
			&& sqlite3IsRowid(zCol)
			&& VisibleRowid(pMatch->pTab)
			) {
			cnt = 1;
			pExpr->iColumn = -1;
			pExpr->affinity = SQLITE_AFF_INTEGER;
		}

		
		if ((pEList = pNC->pEList) != 0
			&& zTab == 0
			&& cnt == 0
			) {
			for (j = 0; j<pEList->nExpr; j++) {
				char *zAs = pEList->a[j].zName;
				if (zAs != 0 && sqlite3StrICmp(zAs, zCol) == 0) {
					Expr *pOrig;
					assert(pExpr->pLeft == 0 && pExpr->pRight == 0);
					assert(pExpr->x.pList == 0);
					assert(pExpr->x.pSelect == 0);
					pOrig = pEList->a[j].pExpr;
					if ((pNC->ncFlags&NC_AllowAgg) == 0 && ExprHasProperty(pOrig, EP_Agg)) {
						sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
						return WRC_Abort;
					}
					if (sqlite3ExprVectorSize(pOrig) != 1) {
						sqlite3ErrorMsg(pParse, "row value misused");
						return WRC_Abort;
					}
					resolveAlias(pParse, pEList, j, pExpr, "", nSubquery);
					cnt = 1;
					pMatch = 0;
					assert(zTab == 0 && zDb == 0);
					goto lookupname_end;
				}
			}
		}

		
		if (cnt == 0) {
			pNC = pNC->pNext;
			nSubquery++;
		}
	}

	
	if (cnt == 0 && zTab == 0 && ExprHasProperty(pExpr, EP_DblQuoted)) {
		pExpr->op = TK_STRING;
		pExpr->pTab = 0;
		return WRC_Prune;
	}

	
	if (cnt != 1) {
		const char *zErr;
		zErr = cnt == 0 ? "no such column" : "ambiguous column name";
		if (zDb) {
			sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
		}
		else if (zTab) {
			sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
		}
		else {
			sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
		}
		pParse->checkSchema = 1;
		pTopNC->nErr++;
	}

	
	if (pExpr->iColumn >= 0 && pMatch != 0) {
		int n = pExpr->iColumn;
		testcase(n == BMS - 1);
		if (n >= BMS) {
			n = BMS - 1;
		}
		assert(pMatch->iCursor == pExpr->iTable);
		pMatch->colUsed |= ((Bitmask)1) << n;
	}

	
	sqlite3ExprDelete(db, pExpr->pLeft);
	pExpr->pLeft = 0;
	sqlite3ExprDelete(db, pExpr->pRight);
	pExpr->pRight = 0;
	pExpr->op = (isTrigger ? TK_TRIGGER : TK_COLUMN);
lookupname_end:
	if (cnt == 1) {
		assert(pNC != 0);
		if (!ExprHasProperty(pExpr, EP_Alias)) {
			sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
		}
		
		for (;;) {
			assert(pTopNC != 0);
			pTopNC->nRef++;
			if (pTopNC == pNC) break;
			pTopNC = pTopNC->pNext;
		}
		return WRC_Prune;
	}
	else {
		return WRC_Abort;
	}
}


SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol) {
	Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);
	if (p) {
		struct SrcList_item *pItem = &pSrc->a[iSrc];
		p->pTab = pItem->pTab;
		p->iTable = pItem->iCursor;
		if (p->pTab->iPKey == iCol) {
			p->iColumn = -1;
		}
		else {
			p->iColumn = (ynVar)iCol;
			testcase(iCol == BMS);
			testcase(iCol == BMS - 1);
			pItem->colUsed |= ((Bitmask)1) << (iCol >= BMS ? BMS - 1 : iCol);
		}
		ExprSetProperty(p, EP_Resolved);
	}
	return p;
}


static void notValid(
	Parse *pParse,       
	NameContext *pNC,    
	const char *zMsg,    
	int validMask        
) {
	assert((validMask&~(NC_IsCheck | NC_PartIdx | NC_IdxExpr)) == 0);
	if ((pNC->ncFlags & validMask) != 0) {
		const char *zIn = "partial index WHERE clauses";
		if (pNC->ncFlags & NC_IdxExpr)      zIn = "index expressions";
#ifndef SQLITE_OMIT_CHECK
		else if (pNC->ncFlags & NC_IsCheck) zIn = "CHECK constraints";
#endif
		sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
	}
}


static int exprProbability(Expr *p) {
	double r = -1.0;
	if (p->op != TK_FLOAT) return -1;
	sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);
	assert(r >= 0.0);
	if (r>1.0) return -1;
	return (int)(r*134217728.0);
}


static int resolveExprStep(Walker *pWalker, Expr *pExpr) {
	NameContext *pNC;
	Parse *pParse;

	pNC = pWalker->u.pNC;
	assert(pNC != 0);
	pParse = pNC->pParse;
	assert(pParse == pWalker->pParse);

	if (ExprHasProperty(pExpr, EP_Resolved)) return WRC_Prune;
	ExprSetProperty(pExpr, EP_Resolved);
#ifndef NDEBUG
	if (pNC->pSrcList && pNC->pSrcList->nAlloc>0) {
		SrcList *pSrcList = pNC->pSrcList;
		int i;
		for (i = 0; i<pNC->pSrcList->nSrc; i++) {
			assert(pSrcList->a[i].iCursor >= 0 && pSrcList->a[i].iCursor<pParse->nTab);
		}
	}
#endif
	switch (pExpr->op) {

#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)
		
	case TK_ROW: {
		SrcList *pSrcList = pNC->pSrcList;
		struct SrcList_item *pItem;
		assert(pSrcList && pSrcList->nSrc == 1);
		pItem = pSrcList->a;
		pExpr->op = TK_COLUMN;
		pExpr->pTab = pItem->pTab;
		pExpr->iTable = pItem->iCursor;
		pExpr->iColumn = -1;
		pExpr->affinity = SQLITE_AFF_INTEGER;
		break;
	}
#endif 

		
	case TK_ID: {
		return lookupName(pParse, 0, 0, pExpr->u.zToken, pNC, pExpr);
	}

				
	case TK_DOT: {
		const char *zColumn;
		const char *zTable;
		const char *zDb;
		Expr *pRight;

		
		notValid(pParse, pNC, "the \".\" operator", NC_IdxExpr);
		pRight = pExpr->pRight;
		if (pRight->op == TK_ID) {
			zDb = 0;
			zTable = pExpr->pLeft->u.zToken;
			zColumn = pRight->u.zToken;
		}
		else {
			assert(pRight->op == TK_DOT);
			zDb = pExpr->pLeft->u.zToken;
			zTable = pRight->pLeft->u.zToken;
			zColumn = pRight->pRight->u.zToken;
		}
		return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
	}

				 
	case TK_FUNCTION: {
		ExprList *pList = pExpr->x.pList;    
		int n = pList ? pList->nExpr : 0;    
		int no_such_func = 0;       
		int wrong_num_args = 0;     
		int is_agg = 0;             
		int nId;                    
		const char *zId;            
		FuncDef *pDef;              
		u8 enc = ENC(pParse->db);   

		assert(!ExprHasProperty(pExpr, EP_xIsSelect));
		zId = pExpr->u.zToken;
		nId = sqlite3Strlen30(zId);
		pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);
		if (pDef == 0) {
			pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);
			if (pDef == 0) {
				no_such_func = 1;
			}
			else {
				wrong_num_args = 1;
			}
		}
		else {
			is_agg = pDef->xFinalize != 0;
			if (pDef->funcFlags & SQLITE_FUNC_UNLIKELY) {
				ExprSetProperty(pExpr, EP_Unlikely | EP_Skip);
				if (n == 2) {
					pExpr->iTable = exprProbability(pList->a[1].pExpr);
					if (pExpr->iTable<0) {
						sqlite3ErrorMsg(pParse,
							"second argument to likelihood() must be a "
							"constant between 0.0 and 1.0");
						pNC->nErr++;
					}
				}
				else {
					
					
					pExpr->iTable = pDef->zName[0] == 'u' ? 8388608 : 125829120;
				}
			}
#ifndef SQLITE_OMIT_AUTHORIZATION
			{
				int auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0, pDef->zName, 0);
				if (auth != SQLITE_OK) {
					if (auth == SQLITE_DENY) {
						sqlite3ErrorMsg(pParse, "not authorized to use function: %s",
							pDef->zName);
						pNC->nErr++;
					}
					pExpr->op = TK_NULL;
					return WRC_Prune;
				}
			}
#endif
			if (pDef->funcFlags & (SQLITE_FUNC_CONSTANT | SQLITE_FUNC_SLOCHNG)) {
				
				ExprSetProperty(pExpr, EP_ConstFunc);
			}
			if ((pDef->funcFlags & SQLITE_FUNC_CONSTANT) == 0) {
				
				notValid(pParse, pNC, "non-deterministic functions",
					NC_IdxExpr | NC_PartIdx);
			}
		}
		if (is_agg && (pNC->ncFlags & NC_AllowAgg) == 0) {
			sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId, zId);
			pNC->nErr++;
			is_agg = 0;
		}
		else if (no_such_func && pParse->db->init.busy == 0
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
			&& pParse->explain == 0
#endif
			) {
			sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
			pNC->nErr++;
		}
		else if (wrong_num_args) {
			sqlite3ErrorMsg(pParse, "wrong number of arguments to function %.*s()",
				nId, zId);
			pNC->nErr++;
		}
		if (is_agg) pNC->ncFlags &= ~NC_AllowAgg;
		sqlite3WalkExprList(pWalker, pList);
		if (is_agg) {
			NameContext *pNC2 = pNC;
			pExpr->op = TK_AGG_FUNCTION;
			pExpr->op2 = 0;
			while (pNC2 && !sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList)) {
				pExpr->op2++;
				pNC2 = pNC2->pNext;
			}
			assert(pDef != 0);
			if (pNC2) {
				assert(SQLITE_FUNC_MINMAX == NC_MinMaxAgg);
				testcase((pDef->funcFlags & SQLITE_FUNC_MINMAX) != 0);
				pNC2->ncFlags |= NC_HasAgg | (pDef->funcFlags & SQLITE_FUNC_MINMAX);

			}
			pNC->ncFlags |= NC_AllowAgg;
		}
		
		return WRC_Prune;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_SELECT:
	case TK_EXISTS:  testcase(pExpr->op == TK_EXISTS);
#endif
	case TK_IN: {
		testcase(pExpr->op == TK_IN);
		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			int nRef = pNC->nRef;
			notValid(pParse, pNC, "subqueries", NC_IsCheck | NC_PartIdx | NC_IdxExpr);
			sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
			assert(pNC->nRef >= nRef);
			if (nRef != pNC->nRef) {
				ExprSetProperty(pExpr, EP_VarSelect);
				pNC->ncFlags |= NC_VarSelect;
			}
		}
		break;
	}
	case TK_VARIABLE: {
		notValid(pParse, pNC, "parameters", NC_IsCheck | NC_PartIdx | NC_IdxExpr);
		break;
	}
	case TK_BETWEEN:
	case TK_EQ:
	case TK_NE:
	case TK_LT:
	case TK_LE:
	case TK_GT:
	case TK_GE:
	case TK_IS:
	case TK_ISNOT: {
		int nLeft, nRight;
		if (pParse->db->mallocFailed) break;
		assert(pExpr->pLeft != 0);
		nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
		if (pExpr->op == TK_BETWEEN) {
			nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);
			if (nRight == nLeft) {
				nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);
			}
		}
		else {
			assert(pExpr->pRight != 0);
			nRight = sqlite3ExprVectorSize(pExpr->pRight);
		}
		if (nLeft != nRight) {
			testcase(pExpr->op == TK_EQ);
			testcase(pExpr->op == TK_NE);
			testcase(pExpr->op == TK_LT);
			testcase(pExpr->op == TK_LE);
			testcase(pExpr->op == TK_GT);
			testcase(pExpr->op == TK_GE);
			testcase(pExpr->op == TK_IS);
			testcase(pExpr->op == TK_ISNOT);
			testcase(pExpr->op == TK_BETWEEN);
			sqlite3ErrorMsg(pParse, "row value misused");
		}
		break;
	}
	}
	return (pParse->nErr || pParse->db->mallocFailed) ? WRC_Abort : WRC_Continue;
}


static int resolveAsName(
	Parse *pParse,     
	ExprList *pEList,  
	Expr *pE           
) {
	int i;             

	UNUSED_PARAMETER(pParse);

	if (pE->op == TK_ID) {
		char *zCol = pE->u.zToken;
		for (i = 0; i<pEList->nExpr; i++) {
			char *zAs = pEList->a[i].zName;
			if (zAs != 0 && sqlite3StrICmp(zAs, zCol) == 0) {
				return i + 1;
			}
		}
	}
	return 0;
}


static int resolveOrderByTermToExprList(
	Parse *pParse,     
	Select *pSelect,   
	Expr *pE           
) {
	int i;             
	ExprList *pEList;  
	NameContext nc;    
	sqlite3 *db;       
	int rc;            
	u8 savedSuppErr;   

	assert(sqlite3ExprIsInteger(pE, &i) == 0);
	pEList = pSelect->pEList;

	
	memset(&nc, 0, sizeof(nc));
	nc.pParse = pParse;
	nc.pSrcList = pSelect->pSrc;
	nc.pEList = pEList;
	nc.ncFlags = NC_AllowAgg;
	nc.nErr = 0;
	db = pParse->db;
	savedSuppErr = db->suppressErr;
	db->suppressErr = 1;
	rc = sqlite3ResolveExprNames(&nc, pE);
	db->suppressErr = savedSuppErr;
	if (rc) return 0;

	
	for (i = 0; i<pEList->nExpr; i++) {
		if (sqlite3ExprCompare(pEList->a[i].pExpr, pE, -1)<2) {
			return i + 1;
		}
	}

	
	return 0;
}


static void resolveOutOfRangeError(
	Parse *pParse,         
	const char *zType,     
	int i,                 
	int mx                 
) {
	sqlite3ErrorMsg(pParse,
		"%r %s BY term out of range - should be "
		"between 1 and %d", i, zType, mx);
}


static int resolveCompoundOrderBy(
	Parse *pParse,        
	Select *pSelect       
) {
	int i;
	ExprList *pOrderBy;
	ExprList *pEList;
	sqlite3 *db;
	int moreToDo = 1;

	pOrderBy = pSelect->pOrderBy;
	if (pOrderBy == 0) return 0;
	db = pParse->db;
#if SQLITE_MAX_COLUMN
	if (pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN]) {
		sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
		return 1;
	}
#endif
	for (i = 0; i<pOrderBy->nExpr; i++) {
		pOrderBy->a[i].done = 0;
	}
	pSelect->pNext = 0;
	while (pSelect->pPrior) {
		pSelect->pPrior->pNext = pSelect;
		pSelect = pSelect->pPrior;
	}
	while (pSelect && moreToDo) {
		struct ExprList_item *pItem;
		moreToDo = 0;
		pEList = pSelect->pEList;
		assert(pEList != 0);
		for (i = 0, pItem = pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++) {
			int iCol = -1;
			Expr *pE, *pDup;
			if (pItem->done) continue;
			pE = sqlite3ExprSkipCollate(pItem->pExpr);
			if (sqlite3ExprIsInteger(pE, &iCol)) {
				if (iCol <= 0 || iCol>pEList->nExpr) {
					resolveOutOfRangeError(pParse, "ORDER", i + 1, pEList->nExpr);
					return 1;
				}
			}
			else {
				iCol = resolveAsName(pParse, pEList, pE);
				if (iCol == 0) {
					pDup = sqlite3ExprDup(db, pE, 0);
					if (!db->mallocFailed) {
						assert(pDup);
						iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
					}
					sqlite3ExprDelete(db, pDup);
				}
			}
			if (iCol>0) {
				
				Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);
				if (pNew == 0) return 1;
				pNew->flags |= EP_IntValue;
				pNew->u.iValue = iCol;
				if (pItem->pExpr == pE) {
					pItem->pExpr = pNew;
				}
				else {
					Expr *pParent = pItem->pExpr;
					assert(pParent->op == TK_COLLATE);
					while (pParent->pLeft->op == TK_COLLATE) pParent = pParent->pLeft;
					assert(pParent->pLeft == pE);
					pParent->pLeft = pNew;
				}
				sqlite3ExprDelete(db, pE);
				pItem->u.x.iOrderByCol = (u16)iCol;
				pItem->done = 1;
			}
			else {
				moreToDo = 1;
			}
		}
		pSelect = pSelect->pNext;
	}
	for (i = 0; i<pOrderBy->nExpr; i++) {
		if (pOrderBy->a[i].done == 0) {
			sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "
				"column in the result set", i + 1);
			return 1;
		}
	}
	return 0;
}


SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(
	Parse *pParse,        
	Select *pSelect,      
	ExprList *pOrderBy,   
	const char *zType     
) {
	int i;
	sqlite3 *db = pParse->db;
	ExprList *pEList;
	struct ExprList_item *pItem;

	if (pOrderBy == 0 || pParse->db->mallocFailed) return 0;
#if SQLITE_MAX_COLUMN
	if (pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN]) {
		sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
		return 1;
	}
#endif
	pEList = pSelect->pEList;
	assert(pEList != 0);  
	for (i = 0, pItem = pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++) {
		if (pItem->u.x.iOrderByCol) {
			if (pItem->u.x.iOrderByCol>pEList->nExpr) {
				resolveOutOfRangeError(pParse, zType, i + 1, pEList->nExpr);
				return 1;
			}
			resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol - 1, pItem->pExpr,
				zType, 0);
		}
	}
	return 0;
}


static int resolveOrderGroupBy(
	NameContext *pNC,     
	Select *pSelect,      
	ExprList *pOrderBy,   
	const char *zType     
) {
	int i, j;                      
	int iCol;                      
	struct ExprList_item *pItem;   
	Parse *pParse;                 
	int nResult;                   

	if (pOrderBy == 0) return 0;
	nResult = pSelect->pEList->nExpr;
	pParse = pNC->pParse;
	for (i = 0, pItem = pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++) {
		Expr *pE = pItem->pExpr;
		Expr *pE2 = sqlite3ExprSkipCollate(pE);
		if (zType[0] != 'G') {
			iCol = resolveAsName(pParse, pSelect->pEList, pE2);
			if (iCol>0) {
				
				pItem->u.x.iOrderByCol = (u16)iCol;
				continue;
			}
		}
		if (sqlite3ExprIsInteger(pE2, &iCol)) {
			
			if (iCol<1 || iCol>0xffff) {
				resolveOutOfRangeError(pParse, zType, i + 1, nResult);
				return 1;
			}
			pItem->u.x.iOrderByCol = (u16)iCol;
			continue;
		}

		
		pItem->u.x.iOrderByCol = 0;
		if (sqlite3ResolveExprNames(pNC, pE)) {
			return 1;
		}
		for (j = 0; j<pSelect->pEList->nExpr; j++) {
			if (sqlite3ExprCompare(pE, pSelect->pEList->a[j].pExpr, -1) == 0) {
				pItem->u.x.iOrderByCol = j + 1;
			}
		}
	}
	return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}


static int resolveSelectStep(Walker *pWalker, Select *p) {
	NameContext *pOuterNC;  
	NameContext sNC;        
	int isCompound;         
	int nCompound;          
	Parse *pParse;          
	int i;                  
	ExprList *pGroupBy;     
	Select *pLeftmost;      
	sqlite3 *db;            


	assert(p != 0);
	if (p->selFlags & SF_Resolved) {
		return WRC_Prune;
	}
	pOuterNC = pWalker->u.pNC;
	pParse = pWalker->pParse;
	db = pParse->db;

	
	if ((p->selFlags & SF_Expanded) == 0) {
		sqlite3SelectPrep(pParse, p, pOuterNC);
		return (pParse->nErr || db->mallocFailed) ? WRC_Abort : WRC_Prune;
	}

	isCompound = p->pPrior != 0;
	nCompound = 0;
	pLeftmost = p;
	while (p) {
		assert((p->selFlags & SF_Expanded) != 0);
		assert((p->selFlags & SF_Resolved) == 0);
		p->selFlags |= SF_Resolved;

		
		memset(&sNC, 0, sizeof(sNC));
		sNC.pParse = pParse;
		if (sqlite3ResolveExprNames(&sNC, p->pLimit) ||
			sqlite3ResolveExprNames(&sNC, p->pOffset)) {
			return WRC_Abort;
		}

		
		if (p->selFlags & SF_Converted) {
			Select *pSub = p->pSrc->a[0].pSelect;
			assert(p->pSrc->nSrc == 1 && p->pOrderBy);
			assert(pSub->pPrior && pSub->pOrderBy == 0);
			pSub->pOrderBy = p->pOrderBy;
			p->pOrderBy = 0;
		}

		
		for (i = 0; i<p->pSrc->nSrc; i++) {
			struct SrcList_item *pItem = &p->pSrc->a[i];
			if (pItem->pSelect) {
				NameContext *pNC;         
				int nRef = 0;             
				const char *zSavedContext = pParse->zAuthContext;

				
				for (pNC = pOuterNC; pNC; pNC = pNC->pNext) nRef += pNC->nRef;

				if (pItem->zName) pParse->zAuthContext = pItem->zName;
				sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
				pParse->zAuthContext = zSavedContext;
				if (pParse->nErr || db->mallocFailed) return WRC_Abort;

				for (pNC = pOuterNC; pNC; pNC = pNC->pNext) nRef -= pNC->nRef;
				assert(pItem->fg.isCorrelated == 0 && nRef <= 0);
				pItem->fg.isCorrelated = (nRef != 0);
			}
		}

		
		sNC.ncFlags = NC_AllowAgg;
		sNC.pSrcList = p->pSrc;
		sNC.pNext = pOuterNC;

		
		if (sqlite3ResolveExprListNames(&sNC, p->pEList)) return WRC_Abort;

		
		assert((p->selFlags & SF_Aggregate) == 0);
		pGroupBy = p->pGroupBy;
		if (pGroupBy || (sNC.ncFlags & NC_HasAgg) != 0) {
			assert(NC_MinMaxAgg == SF_MinMaxAgg);
			p->selFlags |= SF_Aggregate | (sNC.ncFlags&NC_MinMaxAgg);
		}
		else {
			sNC.ncFlags &= ~NC_AllowAgg;
		}

		
		if (p->pHaving && !pGroupBy) {
			sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
			return WRC_Abort;
		}

		
		sNC.pEList = p->pEList;
		if (sqlite3ResolveExprNames(&sNC, p->pHaving)) return WRC_Abort;
		if (sqlite3ResolveExprNames(&sNC, p->pWhere)) return WRC_Abort;

		
		for (i = 0; i<p->pSrc->nSrc; i++) {
			struct SrcList_item *pItem = &p->pSrc->a[i];
			if (pItem->fg.isTabFunc
				&& sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg)
				) {
				return WRC_Abort;
			}
		}

		
		sNC.pNext = 0;
		sNC.ncFlags |= NC_AllowAgg;

		
		if (p->selFlags & SF_Converted) {
			Select *pSub = p->pSrc->a[0].pSelect;
			p->pOrderBy = pSub->pOrderBy;
			pSub->pOrderBy = 0;
		}

		
		if (isCompound <= nCompound  
			&& resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")
			) {
			return WRC_Abort;
		}
		if (db->mallocFailed) {
			return WRC_Abort;
		}

		
		if (pGroupBy) {
			struct ExprList_item *pItem;

			if (resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed) {
				return WRC_Abort;
			}
			for (i = 0, pItem = pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++) {
				if (ExprHasProperty(pItem->pExpr, EP_Agg)) {
					sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "
						"the GROUP BY clause");
					return WRC_Abort;
				}
			}
		}

		
		if (p->pNext && p->pEList->nExpr != p->pNext->pEList->nExpr) {
			sqlite3SelectWrongNumTermsError(pParse, p->pNext);
			return WRC_Abort;
		}

		
		p = p->pPrior;
		nCompound++;
	}

	
	if (isCompound && resolveCompoundOrderBy(pParse, pLeftmost)) {
		return WRC_Abort;
	}

	return WRC_Prune;
}


SQLITE_PRIVATE int sqlite3ResolveExprNames(
	NameContext *pNC,       
	Expr *pExpr             
) {
	u16 savedHasAgg;
	Walker w;

	if (pExpr == 0) return 0;
#if SQLITE_MAX_EXPR_DEPTH>0
	{
		Parse *pParse = pNC->pParse;
		if (sqlite3ExprCheckHeight(pParse, pExpr->nHeight + pNC->pParse->nHeight)) {
			return 1;
		}
		pParse->nHeight += pExpr->nHeight;
	}
#endif
	savedHasAgg = pNC->ncFlags & (NC_HasAgg | NC_MinMaxAgg);
	pNC->ncFlags &= ~(NC_HasAgg | NC_MinMaxAgg);
	w.pParse = pNC->pParse;
	w.xExprCallback = resolveExprStep;
	w.xSelectCallback = resolveSelectStep;
	w.xSelectCallback2 = 0;
	w.walkerDepth = 0;
	w.eCode = 0;
	w.u.pNC = pNC;
	sqlite3WalkExpr(&w, pExpr);
#if SQLITE_MAX_EXPR_DEPTH>0
	pNC->pParse->nHeight -= pExpr->nHeight;
#endif
	if (pNC->nErr>0 || w.pParse->nErr>0) {
		ExprSetProperty(pExpr, EP_Error);
	}
	if (pNC->ncFlags & NC_HasAgg) {
		ExprSetProperty(pExpr, EP_Agg);
	}
	pNC->ncFlags |= savedHasAgg;
	return ExprHasProperty(pExpr, EP_Error);
}


SQLITE_PRIVATE int sqlite3ResolveExprListNames(
	NameContext *pNC,       
	ExprList *pList         
) {
	int i;
	if (pList) {
		for (i = 0; i<pList->nExpr; i++) {
			if (sqlite3ResolveExprNames(pNC, pList->a[i].pExpr)) return WRC_Abort;
		}
	}
	return WRC_Continue;
}


SQLITE_PRIVATE void sqlite3ResolveSelectNames(
	Parse *pParse,         
	Select *p,             
	NameContext *pOuterNC  
) {
	Walker w;

	assert(p != 0);
	memset(&w, 0, sizeof(w));
	w.xExprCallback = resolveExprStep;
	w.xSelectCallback = resolveSelectStep;
	w.pParse = pParse;
	w.u.pNC = pOuterNC;
	sqlite3WalkSelect(&w, p);
}


SQLITE_PRIVATE void sqlite3ResolveSelfReference(
	Parse *pParse,      
	Table *pTab,        
	int type,           
	Expr *pExpr,        
	ExprList *pList     
) {
	SrcList sSrc;                   
	NameContext sNC;                

	assert(type == NC_IsCheck || type == NC_PartIdx || type == NC_IdxExpr);
	memset(&sNC, 0, sizeof(sNC));
	memset(&sSrc, 0, sizeof(sSrc));
	sSrc.nSrc = 1;
	sSrc.a[0].zName = pTab->zName;
	sSrc.a[0].pTab = pTab;
	sSrc.a[0].iCursor = -1;
	sNC.pParse = pParse;
	sNC.pSrcList = &sSrc;
	sNC.ncFlags = type;
	if (sqlite3ResolveExprNames(&sNC, pExpr)) return;
	if (pList) sqlite3ResolveExprListNames(&sNC, pList);
}







static void exprCodeBetween(Parse*, Expr*, int, void(*)(Parse*, Expr*, int, int), int);
static int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);


SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table *pTab, int iCol) {
	assert(iCol<pTab->nCol);
	return iCol >= 0 ? pTab->aCol[iCol].affinity : SQLITE_AFF_INTEGER;
}


SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr) {
	int op;
	pExpr = sqlite3ExprSkipCollate(pExpr);
	if (pExpr->flags & EP_Generic) return 0;
	op = pExpr->op;
	if (op == TK_SELECT) {
		assert(pExpr->flags&EP_xIsSelect);
		return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
	}
	if (op == TK_REGISTER) op = pExpr->op2;
#ifndef SQLITE_OMIT_CAST
	if (op == TK_CAST) {
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		return sqlite3AffinityType(pExpr->u.zToken, 0);
	}
#endif
	if (op == TK_AGG_COLUMN || op == TK_COLUMN) {
		return sqlite3TableColumnAffinity(pExpr->pTab, pExpr->iColumn);
	}
	if (op == TK_SELECT_COLUMN) {
		assert(pExpr->pLeft->flags&EP_xIsSelect);
		return sqlite3ExprAffinity(
			pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
		);
	}
	return pExpr->affinity;
}


SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(
	Parse *pParse,           
	Expr *pExpr,             
	const Token *pCollName,  
	int dequote              
) {
	if (pCollName->n>0) {
		Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);
		if (pNew) {
			pNew->pLeft = pExpr;
			pNew->flags |= EP_Collate | EP_Skip;
			pExpr = pNew;
		}
	}
	return pExpr;
}
SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC) {
	Token s;
	assert(zC != 0);
	sqlite3TokenInit(&s, (char*)zC);
	return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
}


SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr) {
	while (pExpr && ExprHasProperty(pExpr, EP_Skip)) {
		if (ExprHasProperty(pExpr, EP_Unlikely)) {
			assert(!ExprHasProperty(pExpr, EP_xIsSelect));
			assert(pExpr->x.pList->nExpr>0);
			assert(pExpr->op == TK_FUNCTION);
			pExpr = pExpr->x.pList->a[0].pExpr;
		}
		else {
			assert(pExpr->op == TK_COLLATE);
			pExpr = pExpr->pLeft;
		}
	}
	return pExpr;
}


SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr) {
	sqlite3 *db = pParse->db;
	CollSeq *pColl = 0;
	Expr *p = pExpr;
	while (p) {
		int op = p->op;
		if (p->flags & EP_Generic) break;
		if (op == TK_CAST || op == TK_UPLUS) {
			p = p->pLeft;
			continue;
		}
		if (op == TK_COLLATE || (op == TK_REGISTER && p->op2 == TK_COLLATE)) {
			pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);
			break;
		}
		if ((op == TK_AGG_COLUMN || op == TK_COLUMN
			|| op == TK_REGISTER || op == TK_TRIGGER)
			&& p->pTab != 0
			) {
			
			int j = p->iColumn;
			if (j >= 0) {
				const char *zColl = p->pTab->aCol[j].zColl;
				pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);
			}
			break;
		}
		if (p->flags & EP_Collate) {
			if (p->pLeft && (p->pLeft->flags & EP_Collate) != 0) {
				p = p->pLeft;
			}
			else {
				Expr *pNext = p->pRight;
				
				assert(p->x.pList == 0 || p->pRight == 0);
				
				if (p->x.pList != 0 && ALWAYS(!ExprHasProperty(p, EP_xIsSelect))) {
					int i;
					for (i = 0; ALWAYS(i<p->x.pList->nExpr); i++) {
						if (ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate)) {
							pNext = p->x.pList->a[i].pExpr;
							break;
						}
					}
				}
				p = pNext;
			}
		}
		else {
			break;
		}
	}
	if (sqlite3CheckCollSeq(pParse, pColl)) {
		pColl = 0;
	}
	return pColl;
}


SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2) {
	char aff1 = sqlite3ExprAffinity(pExpr);
	if (aff1 && aff2) {
		
		if (sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2)) {
			return SQLITE_AFF_NUMERIC;
		}
		else {
			return SQLITE_AFF_BLOB;
		}
	}
	else if (!aff1 && !aff2) {
		
		return SQLITE_AFF_BLOB;
	}
	else {
		
		assert(aff1 == 0 || aff2 == 0);
		return (aff1 + aff2);
	}
}


static char comparisonAffinity(Expr *pExpr) {
	char aff;
	assert(pExpr->op == TK_EQ || pExpr->op == TK_IN || pExpr->op == TK_LT ||
		pExpr->op == TK_GT || pExpr->op == TK_GE || pExpr->op == TK_LE ||
		pExpr->op == TK_NE || pExpr->op == TK_IS || pExpr->op == TK_ISNOT);
	assert(pExpr->pLeft);
	aff = sqlite3ExprAffinity(pExpr->pLeft);
	if (pExpr->pRight) {
		aff = sqlite3CompareAffinity(pExpr->pRight, aff);
	}
	else if (ExprHasProperty(pExpr, EP_xIsSelect)) {
		aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
	}
	else if (NEVER(aff == 0)) {
		aff = SQLITE_AFF_BLOB;
	}
	return aff;
}


SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity) {
	char aff = comparisonAffinity(pExpr);
	switch (aff) {
	case SQLITE_AFF_BLOB:
		return 1;
	case SQLITE_AFF_TEXT:
		return idx_affinity == SQLITE_AFF_TEXT;
	default:
		return sqlite3IsNumericAffinity(idx_affinity);
	}
}


static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull) {
	u8 aff = (char)sqlite3ExprAffinity(pExpr2);
	aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
	return aff;
}


SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(
	Parse *pParse,
	Expr *pLeft,
	Expr *pRight
) {
	CollSeq *pColl;
	assert(pLeft);
	if (pLeft->flags & EP_Collate) {
		pColl = sqlite3ExprCollSeq(pParse, pLeft);
	}
	else if (pRight && (pRight->flags & EP_Collate) != 0) {
		pColl = sqlite3ExprCollSeq(pParse, pRight);
	}
	else {
		pColl = sqlite3ExprCollSeq(pParse, pLeft);
		if (!pColl) {
			pColl = sqlite3ExprCollSeq(pParse, pRight);
		}
	}
	return pColl;
}


static int codeCompare(
	Parse *pParse,    
	Expr *pLeft,      
	Expr *pRight,     
	int opcode,       
	int in1, int in2, 
	int dest,         
	int jumpIfNull    
) {
	int p5;
	int addr;
	CollSeq *p4;

	p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
	p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
	addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
		(void*)p4, P4_COLLSEQ);
	sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
	return addr;
}


SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr) {
	return sqlite3ExprVectorSize(pExpr)>1;
}


SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr) {
	u8 op = pExpr->op;
	if (op == TK_REGISTER) op = pExpr->op2;
	if (op == TK_VECTOR) {
		return pExpr->x.pList->nExpr;
	}
	else if (op == TK_SELECT) {
		return pExpr->x.pSelect->pEList->nExpr;
	}
	else {
		return 1;
	}
}

#ifndef SQLITE_OMIT_SUBQUERY

SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i) {
	assert(i<sqlite3ExprVectorSize(pVector));
	if (sqlite3ExprIsVector(pVector)) {
		assert(pVector->op2 == 0 || pVector->op == TK_REGISTER);
		if (pVector->op == TK_SELECT || pVector->op2 == TK_SELECT) {
			return pVector->x.pSelect->pEList->a[i].pExpr;
		}
		else {
			return pVector->x.pList->a[i].pExpr;
		}
	}
	return pVector;
}
#endif 

#ifndef SQLITE_OMIT_SUBQUERY

SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(
	Parse *pParse,       
	Expr *pVector,       
	int iField           
) {
	Expr *pRet;
	if (pVector->op == TK_SELECT) {
		assert(pVector->flags & EP_xIsSelect);
		
		pRet = sqlite3PExpr(pParse, TK_SELECT_COLUMN, 0, 0, 0);
		if (pRet) {
			pRet->iColumn = iField;
			pRet->pLeft = pVector;
		}
		assert(pRet == 0 || pRet->iTable == 0);
	}
	else {
		if (pVector->op == TK_VECTOR) pVector = pVector->x.pList->a[iField].pExpr;
		pRet = sqlite3ExprDup(pParse->db, pVector, 0);
	}
	return pRet;
}
#endif 


static int exprCodeSubselect(Parse *pParse, Expr *pExpr) {
	int reg = 0;
#ifndef SQLITE_OMIT_SUBQUERY
	if (pExpr->op == TK_SELECT) {
		reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);
	}
#endif
	return reg;
}


static int exprVectorRegister(
	Parse *pParse,                  
	Expr *pVector,                  
	int iField,                     
	int regSelect,                  
	Expr **ppExpr,                  
	int *pRegFree                   
) {
	u8 op = pVector->op;
	assert(op == TK_VECTOR || op == TK_REGISTER || op == TK_SELECT);
	if (op == TK_REGISTER) {
		*ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);
		return pVector->iTable + iField;
	}
	if (op == TK_SELECT) {
		*ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;
		return regSelect + iField;
	}
	*ppExpr = pVector->x.pList->a[iField].pExpr;
	return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);
}


static void codeVectorCompare(
	Parse *pParse,        
	Expr *pExpr,          
	int dest,             
	u8 op,                
	u8 p5                 
) {
	Vdbe *v = pParse->pVdbe;
	Expr *pLeft = pExpr->pLeft;
	Expr *pRight = pExpr->pRight;
	int nLeft = sqlite3ExprVectorSize(pLeft);
	int i;
	int regLeft = 0;
	int regRight = 0;
	u8 opx = op;
	int addrDone = sqlite3VdbeMakeLabel(v);

	assert(nLeft == sqlite3ExprVectorSize(pRight));
	assert(pExpr->op == TK_EQ || pExpr->op == TK_NE
		|| pExpr->op == TK_IS || pExpr->op == TK_ISNOT
		|| pExpr->op == TK_LT || pExpr->op == TK_GT
		|| pExpr->op == TK_LE || pExpr->op == TK_GE
	);
	assert(pExpr->op == op || (pExpr->op == TK_IS && op == TK_EQ)
		|| (pExpr->op == TK_ISNOT && op == TK_NE));
	assert(p5 == 0 || pExpr->op != op);
	assert(p5 == SQLITE_NULLEQ || pExpr->op == op);

	p5 |= SQLITE_STOREP2;
	if (opx == TK_LE) opx = TK_LT;
	if (opx == TK_GE) opx = TK_GT;

	regLeft = exprCodeSubselect(pParse, pLeft);
	regRight = exprCodeSubselect(pParse, pRight);

	for (i = 0; 1 ; i++) {
		int regFree1 = 0, regFree2 = 0;
		Expr *pL, *pR;
		int r1, r2;
		assert(i >= 0 && i<nLeft);
		if (i>0) sqlite3ExprCachePush(pParse);
		r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);
		r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);
		codeCompare(pParse, pL, pR, opx, r1, r2, dest, p5);
		testcase(op == OP_Lt); VdbeCoverageIf(v, op == OP_Lt);
		testcase(op == OP_Le); VdbeCoverageIf(v, op == OP_Le);
		testcase(op == OP_Gt); VdbeCoverageIf(v, op == OP_Gt);
		testcase(op == OP_Ge); VdbeCoverageIf(v, op == OP_Ge);
		testcase(op == OP_Eq); VdbeCoverageIf(v, op == OP_Eq);
		testcase(op == OP_Ne); VdbeCoverageIf(v, op == OP_Ne);
		sqlite3ReleaseTempReg(pParse, regFree1);
		sqlite3ReleaseTempReg(pParse, regFree2);
		if (i>0) sqlite3ExprCachePop(pParse);
		if (i == nLeft - 1) {
			break;
		}
		if (opx == TK_EQ) {
			sqlite3VdbeAddOp2(v, OP_IfNot, dest, addrDone); VdbeCoverage(v);
			p5 |= SQLITE_KEEPNULL;
		}
		else if (opx == TK_NE) {
			sqlite3VdbeAddOp2(v, OP_If, dest, addrDone); VdbeCoverage(v);
			p5 |= SQLITE_KEEPNULL;
		}
		else {
			assert(op == TK_LT || op == TK_GT || op == TK_LE || op == TK_GE);
			sqlite3VdbeAddOp2(v, OP_ElseNotEq, 0, addrDone);
			VdbeCoverageIf(v, op == TK_LT);
			VdbeCoverageIf(v, op == TK_GT);
			VdbeCoverageIf(v, op == TK_LE);
			VdbeCoverageIf(v, op == TK_GE);
			if (i == nLeft - 2) opx = op;
		}
	}
	sqlite3VdbeResolveLabel(v, addrDone);
}

#if SQLITE_MAX_EXPR_DEPTH>0

SQLITE_PRIVATE int sqlite3ExprCheckHeight(Parse *pParse, int nHeight) {
	int rc = SQLITE_OK;
	int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];
	if (nHeight>mxHeight) {
		sqlite3ErrorMsg(pParse,
			"Expression tree is too large (maximum depth %d)", mxHeight
		);
		rc = SQLITE_ERROR;
	}
	return rc;
}


static void heightOfExpr(Expr *p, int *pnHeight) {
	if (p) {
		if (p->nHeight>*pnHeight) {
			*pnHeight = p->nHeight;
		}
	}
}
static void heightOfExprList(ExprList *p, int *pnHeight) {
	if (p) {
		int i;
		for (i = 0; i<p->nExpr; i++) {
			heightOfExpr(p->a[i].pExpr, pnHeight);
		}
	}
}
static void heightOfSelect(Select *p, int *pnHeight) {
	if (p) {
		heightOfExpr(p->pWhere, pnHeight);
		heightOfExpr(p->pHaving, pnHeight);
		heightOfExpr(p->pLimit, pnHeight);
		heightOfExpr(p->pOffset, pnHeight);
		heightOfExprList(p->pEList, pnHeight);
		heightOfExprList(p->pGroupBy, pnHeight);
		heightOfExprList(p->pOrderBy, pnHeight);
		heightOfSelect(p->pPrior, pnHeight);
	}
}


static void exprSetHeight(Expr *p) {
	int nHeight = 0;
	heightOfExpr(p->pLeft, &nHeight);
	heightOfExpr(p->pRight, &nHeight);
	if (ExprHasProperty(p, EP_xIsSelect)) {
		heightOfSelect(p->x.pSelect, &nHeight);
	}
	else if (p->x.pList) {
		heightOfExprList(p->x.pList, &nHeight);
		p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
	}
	p->nHeight = nHeight + 1;
}


SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p) {
	if (pParse->nErr) return;
	exprSetHeight(p);
	sqlite3ExprCheckHeight(pParse, p->nHeight);
}


SQLITE_PRIVATE int sqlite3SelectExprHeight(Select *p) {
	int nHeight = 0;
	heightOfSelect(p, &nHeight);
	return nHeight;
}
#else 

SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p) {
	if (p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect)) {
		p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
	}
}
#define exprSetHeight(y)
#endif 


SQLITE_PRIVATE Expr *sqlite3ExprAlloc(
	sqlite3 *db,            
	int op,                 
	const Token *pToken,    
	int dequote             
) {
	Expr *pNew;
	int nExtra = 0;
	int iValue = 0;

	assert(db != 0);
	if (pToken) {
		if (op != TK_INTEGER || pToken->z == 0
			|| sqlite3GetInt32(pToken->z, &iValue) == 0) {
			nExtra = pToken->n + 1;
			assert(iValue >= 0);
		}
	}
	pNew = sqlite3DbMallocRawNN(db, sizeof(Expr) + nExtra);
	if (pNew) {
		memset(pNew, 0, sizeof(Expr));
		pNew->op = (u8)op;
		pNew->iAgg = -1;
		if (pToken) {
			if (nExtra == 0) {
				pNew->flags |= EP_IntValue;
				pNew->u.iValue = iValue;
			}
			else {
				pNew->u.zToken = (char*)&pNew[1];
				assert(pToken->z != 0 || pToken->n == 0);
				if (pToken->n) memcpy(pNew->u.zToken, pToken->z, pToken->n);
				pNew->u.zToken[pToken->n] = 0;
				if (dequote && sqlite3Isquote(pNew->u.zToken[0])) {
					if (pNew->u.zToken[0] == '"') pNew->flags |= EP_DblQuoted;
					sqlite3Dequote(pNew->u.zToken);
				}
			}
		}
#if SQLITE_MAX_EXPR_DEPTH>0
		pNew->nHeight = 1;
#endif  
	}
	return pNew;
}


SQLITE_PRIVATE Expr *sqlite3Expr(
	sqlite3 *db,            
	int op,                 
	const char *zToken      
) {
	Token x;
	x.z = zToken;
	x.n = zToken ? sqlite3Strlen30(zToken) : 0;
	return sqlite3ExprAlloc(db, op, &x, 0);
}


SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(
	sqlite3 *db,
	Expr *pRoot,
	Expr *pLeft,
	Expr *pRight
) {
	if (pRoot == 0) {
		assert(db->mallocFailed);
		sqlite3ExprDelete(db, pLeft);
		sqlite3ExprDelete(db, pRight);
	}
	else {
		if (pRight) {
			pRoot->pRight = pRight;
			pRoot->flags |= EP_Propagate & pRight->flags;
		}
		if (pLeft) {
			pRoot->pLeft = pLeft;
			pRoot->flags |= EP_Propagate & pLeft->flags;
		}
		exprSetHeight(pRoot);
	}
}


SQLITE_PRIVATE Expr *sqlite3PExpr(
	Parse *pParse,          
	int op,                 
	Expr *pLeft,            
	Expr *pRight,           
	const Token *pToken     
) {
	Expr *p;
	if (op == TK_AND && pParse->nErr == 0) {
		
		p = sqlite3ExprAnd(pParse->db, pLeft, pRight);
	}
	else {
		p = sqlite3ExprAlloc(pParse->db, op & TKFLG_MASK, pToken, 1);
		sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
	}
	if (p) {
		sqlite3ExprCheckHeight(pParse, p->nHeight);
	}
	return p;
}


SQLITE_PRIVATE void sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect) {
	if (pExpr) {
		pExpr->x.pSelect = pSelect;
		ExprSetProperty(pExpr, EP_xIsSelect | EP_Subquery);
		sqlite3ExprSetHeightAndFlags(pParse, pExpr);
	}
	else {
		assert(pParse->db->mallocFailed);
		sqlite3SelectDelete(pParse->db, pSelect);
	}
}



static int exprAlwaysTrue(Expr *p) {
	int v = 0;
	if (ExprHasProperty(p, EP_FromJoin)) return 0;
	if (!sqlite3ExprIsInteger(p, &v)) return 0;
	return v != 0;
}
static int exprAlwaysFalse(Expr *p) {
	int v = 0;
	if (ExprHasProperty(p, EP_FromJoin)) return 0;
	if (!sqlite3ExprIsInteger(p, &v)) return 0;
	return v == 0;
}


SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight) {
	if (pLeft == 0) {
		return pRight;
	}
	else if (pRight == 0) {
		return pLeft;
	}
	else if (exprAlwaysFalse(pLeft) || exprAlwaysFalse(pRight)) {
		sqlite3ExprDelete(db, pLeft);
		sqlite3ExprDelete(db, pRight);
		return sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[0], 0);
	}
	else {
		Expr *pNew = sqlite3ExprAlloc(db, TK_AND, 0, 0);
		sqlite3ExprAttachSubtrees(db, pNew, pLeft, pRight);
		return pNew;
	}
}


SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken) {
	Expr *pNew;
	sqlite3 *db = pParse->db;
	assert(pToken);
	pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);
	if (pNew == 0) {
		sqlite3ExprListDelete(db, pList); 
		return 0;
	}
	pNew->x.pList = pList;
	assert(!ExprHasProperty(pNew, EP_xIsSelect));
	sqlite3ExprSetHeightAndFlags(pParse, pNew);
	return pNew;
}


SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n) {
	sqlite3 *db = pParse->db;
	const char *z;

	if (pExpr == 0) return;
	assert(!ExprHasProperty(pExpr, EP_IntValue | EP_Reduced | EP_TokenOnly));
	z = pExpr->u.zToken;
	assert(z != 0);
	assert(z[0] != 0);
	assert(n == sqlite3Strlen30(z));
	if (z[1] == 0) {
		
		assert(z[0] == '?');
		pExpr->iColumn = (ynVar)(++pParse->nVar);
	}
	else {
		ynVar x;
		if (z[0] == '?') {
			
			i64 i;
			int bOk = 0 == sqlite3Atoi64(&z[1], &i, n - 1, SQLITE_UTF8);
			x = (ynVar)i;
			testcase(i == 0);
			testcase(i == 1);
			testcase(i == db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] - 1);
			testcase(i == db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);
			if (bOk == 0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]) {
				sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",
					db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);
				return;
			}
			if (i>pParse->nVar) {
				pParse->nVar = (int)i;
			}
		}
		else {
			
			ynVar i;
			for (i = x = 0; i<pParse->nzVar; i++) {
				if (pParse->azVar[i] && strcmp(pParse->azVar[i], z) == 0) {
					x = (ynVar)i + 1;
					break;
				}
			}
			if (x == 0) x = (ynVar)(++pParse->nVar);
		}
		pExpr->iColumn = x;
		if (x>pParse->nzVar) {
			char **a;
			a = sqlite3DbRealloc(db, pParse->azVar, x * sizeof(a[0]));
			if (a == 0) {
				assert(db->mallocFailed); 
				return;
			}
			pParse->azVar = a;
			memset(&a[pParse->nzVar], 0, (x - pParse->nzVar) * sizeof(a[0]));
			pParse->nzVar = x;
		}
		if (pParse->azVar[x - 1] == 0) {
			pParse->azVar[x - 1] = sqlite3DbStrNDup(db, z, n);
		}
	}
	if (pParse->nVar>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]) {
		sqlite3ErrorMsg(pParse, "too many SQL variables");
	}
}


static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p) {
	assert(p != 0);
	
	assert(!ExprHasProperty(p, EP_IntValue) || p->u.iValue >= 0);
#ifdef SQLITE_DEBUG
	if (ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly)) {
		assert(p->pLeft == 0);
		assert(p->pRight == 0);
		assert(p->x.pSelect == 0);
	}
#endif
	if (!ExprHasProperty(p, (EP_TokenOnly | EP_Leaf))) {
		
		assert(p->x.pList == 0 || p->pRight == 0);
		if (p->pLeft && p->op != TK_SELECT_COLUMN) sqlite3ExprDeleteNN(db, p->pLeft);
		sqlite3ExprDelete(db, p->pRight);
		if (ExprHasProperty(p, EP_xIsSelect)) {
			sqlite3SelectDelete(db, p->x.pSelect);
		}
		else {
			sqlite3ExprListDelete(db, p->x.pList);
		}
	}
	if (ExprHasProperty(p, EP_MemToken)) sqlite3DbFree(db, p->u.zToken);
	if (!ExprHasProperty(p, EP_Static)) {
		sqlite3DbFree(db, p);
	}
}
SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p) {
	if (p) sqlite3ExprDeleteNN(db, p);
}


static int exprStructSize(Expr *p) {
	if (ExprHasProperty(p, EP_TokenOnly)) return EXPR_TOKENONLYSIZE;
	if (ExprHasProperty(p, EP_Reduced)) return EXPR_REDUCEDSIZE;
	return EXPR_FULLSIZE;
}


static int dupedExprStructSize(Expr *p, int flags) {
	int nSize;
	assert(flags == EXPRDUP_REDUCE || flags == 0); 
	assert(EXPR_FULLSIZE <= 0xfff);
	assert((0xfff & (EP_Reduced | EP_TokenOnly)) == 0);
	if (0 == flags) {
		nSize = EXPR_FULLSIZE;
	}
	else {
		assert(!ExprHasProperty(p, EP_TokenOnly | EP_Reduced));
		assert(!ExprHasProperty(p, EP_FromJoin));
		assert(!ExprHasProperty(p, EP_MemToken));
		assert(!ExprHasProperty(p, EP_NoReduce));
		if (p->pLeft || p->x.pList) {
			nSize = EXPR_REDUCEDSIZE | EP_Reduced;
		}
		else {
			assert(p->pRight == 0);
			nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;
		}
	}
	return nSize;
}


static int dupedExprNodeSize(Expr *p, int flags) {
	int nByte = dupedExprStructSize(p, flags) & 0xfff;
	if (!ExprHasProperty(p, EP_IntValue) && p->u.zToken) {
		nByte += sqlite3Strlen30(p->u.zToken) + 1;
	}
	return ROUND8(nByte);
}


static int dupedExprSize(Expr *p, int flags) {
	int nByte = 0;
	if (p) {
		nByte = dupedExprNodeSize(p, flags);
		if (flags&EXPRDUP_REDUCE) {
			nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);
		}
	}
	return nByte;
}


static Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer) {
	Expr *pNew;           
	u8 *zAlloc;           
	u32 staticFlag;       

	assert(db != 0);
	assert(p);
	assert(dupFlags == 0 || dupFlags == EXPRDUP_REDUCE);
	assert(pzBuffer == 0 || dupFlags == EXPRDUP_REDUCE);

	
	if (pzBuffer) {
		zAlloc = *pzBuffer;
		staticFlag = EP_Static;
	}
	else {
		zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));
		staticFlag = 0;
	}
	pNew = (Expr *)zAlloc;

	if (pNew) {
		
		const unsigned nStructSize = dupedExprStructSize(p, dupFlags);
		const int nNewSize = nStructSize & 0xfff;
		int nToken;
		if (!ExprHasProperty(p, EP_IntValue) && p->u.zToken) {
			nToken = sqlite3Strlen30(p->u.zToken) + 1;
		}
		else {
			nToken = 0;
		}
		if (dupFlags) {
			assert(ExprHasProperty(p, EP_Reduced) == 0);
			memcpy(zAlloc, p, nNewSize);
		}
		else {
			u32 nSize = (u32)exprStructSize(p);
			memcpy(zAlloc, p, nSize);
			if (nSize<EXPR_FULLSIZE) {
				memset(&zAlloc[nSize], 0, EXPR_FULLSIZE - nSize);
			}
		}

		
		pNew->flags &= ~(EP_Reduced | EP_TokenOnly | EP_Static | EP_MemToken);
		pNew->flags |= nStructSize & (EP_Reduced | EP_TokenOnly);
		pNew->flags |= staticFlag;

		
		if (nToken) {
			char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];
			memcpy(zToken, p->u.zToken, nToken);
		}

		if (0 == ((p->flags | pNew->flags) & (EP_TokenOnly | EP_Leaf))) {
			
			if (ExprHasProperty(p, EP_xIsSelect)) {
				pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);
			}
			else {
				pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);
			}
		}

		
		if (ExprHasProperty(pNew, EP_Reduced | EP_TokenOnly)) {
			zAlloc += dupedExprNodeSize(p, dupFlags);
			if (!ExprHasProperty(pNew, EP_TokenOnly | EP_Leaf)) {
				pNew->pLeft = p->pLeft ?
					exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;
				pNew->pRight = p->pRight ?
					exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;
			}
			if (pzBuffer) {
				*pzBuffer = zAlloc;
			}
		}
		else {
			if (!ExprHasProperty(p, EP_TokenOnly | EP_Leaf)) {
				if (pNew->op == TK_SELECT_COLUMN) {
					pNew->pLeft = p->pLeft;
				}
				else {
					pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
				}
				pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
			}
		}
	}
	return pNew;
}


#ifndef SQLITE_OMIT_CTE
static With *withDup(sqlite3 *db, With *p) {
	With *pRet = 0;
	if (p) {
		int nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte - 1);
		pRet = sqlite3DbMallocZero(db, nByte);
		if (pRet) {
			int i;
			pRet->nCte = p->nCte;
			for (i = 0; i<p->nCte; i++) {
				pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
				pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);
				pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);
			}
		}
	}
	return pRet;
}
#else
# define withDup(x,y) 0
#endif


SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags) {
	assert(flags == 0 || flags == EXPRDUP_REDUCE);
	return p ? exprDup(db, p, flags, 0) : 0;
}
SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags) {
	ExprList *pNew;
	struct ExprList_item *pItem, *pOldItem;
	int i;
	assert(db != 0);
	if (p == 0) return 0;
	pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew));
	if (pNew == 0) return 0;
	pNew->nExpr = i = p->nExpr;
	if ((flags & EXPRDUP_REDUCE) == 0) for (i = 1; i<p->nExpr; i += i) {}
	pNew->a = pItem = sqlite3DbMallocRawNN(db, i * sizeof(p->a[0]));
	if (pItem == 0) {
		sqlite3DbFree(db, pNew);
		return 0;
	}
	pOldItem = p->a;
	for (i = 0; i<p->nExpr; i++, pItem++, pOldItem++) {
		Expr *pOldExpr = pOldItem->pExpr;
		pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
		pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
		pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);
		pItem->sortOrder = pOldItem->sortOrder;
		pItem->done = 0;
		pItem->bSpanIsTab = pOldItem->bSpanIsTab;
		pItem->u = pOldItem->u;
	}
	return pNew;
}


#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \
 || !defined(SQLITE_OMIT_SUBQUERY)
SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags) {
	SrcList *pNew;
	int i;
	int nByte;
	assert(db != 0);
	if (p == 0) return 0;
	nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc - 1) : 0);
	pNew = sqlite3DbMallocRawNN(db, nByte);
	if (pNew == 0) return 0;
	pNew->nSrc = pNew->nAlloc = p->nSrc;
	for (i = 0; i<p->nSrc; i++) {
		struct SrcList_item *pNewItem = &pNew->a[i];
		struct SrcList_item *pOldItem = &p->a[i];
		Table *pTab;
		pNewItem->pSchema = pOldItem->pSchema;
		pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
		pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
		pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
		pNewItem->fg = pOldItem->fg;
		pNewItem->iCursor = pOldItem->iCursor;
		pNewItem->addrFillSub = pOldItem->addrFillSub;
		pNewItem->regReturn = pOldItem->regReturn;
		if (pNewItem->fg.isIndexedBy) {
			pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);
		}
		pNewItem->pIBIndex = pOldItem->pIBIndex;
		if (pNewItem->fg.isTabFunc) {
			pNewItem->u1.pFuncArg =
				sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);
		}
		pTab = pNewItem->pTab = pOldItem->pTab;
		if (pTab) {
			pTab->nRef++;
		}
		pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);
		pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);
		pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);
		pNewItem->colUsed = pOldItem->colUsed;
	}
	return pNew;
}
SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, IdList *p) {
	IdList *pNew;
	int i;
	assert(db != 0);
	if (p == 0) return 0;
	pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew));
	if (pNew == 0) return 0;
	pNew->nId = p->nId;
	pNew->a = sqlite3DbMallocRawNN(db, p->nId * sizeof(p->a[0]));
	if (pNew->a == 0) {
		sqlite3DbFree(db, pNew);
		return 0;
	}
	
	for (i = 0; i<p->nId; i++) {
		struct IdList_item *pNewItem = &pNew->a[i];
		struct IdList_item *pOldItem = &p->a[i];
		pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
		pNewItem->idx = pOldItem->idx;
	}
	return pNew;
}
SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags) {
	Select *pNew, *pPrior;
	assert(db != 0);
	if (p == 0) return 0;
	pNew = sqlite3DbMallocRawNN(db, sizeof(*p));
	if (pNew == 0) return 0;
	pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);
	pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);
	pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);
	pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);
	pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);
	pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);
	pNew->op = p->op;
	pNew->pPrior = pPrior = sqlite3SelectDup(db, p->pPrior, flags);
	if (pPrior) pPrior->pNext = pNew;
	pNew->pNext = 0;
	pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);
	pNew->pOffset = sqlite3ExprDup(db, p->pOffset, flags);
	pNew->iLimit = 0;
	pNew->iOffset = 0;
	pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;
	pNew->addrOpenEphm[0] = -1;
	pNew->addrOpenEphm[1] = -1;
	pNew->nSelectRow = p->nSelectRow;
	pNew->pWith = withDup(db, p->pWith);
	sqlite3SelectSetName(pNew, p->zSelName);
	return pNew;
}
#else
SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags) {
	assert(p == 0);
	return 0;
}
#endif



SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(
	Parse *pParse,          
	ExprList *pList,        
	Expr *pExpr             
) {
	sqlite3 *db = pParse->db;
	assert(db != 0);
	if (pList == 0) {
		pList = sqlite3DbMallocRawNN(db, sizeof(ExprList));
		if (pList == 0) {
			goto no_mem;
		}
		pList->nExpr = 0;
		pList->a = sqlite3DbMallocRawNN(db, sizeof(pList->a[0]));
		if (pList->a == 0) goto no_mem;
	}
	else if ((pList->nExpr & (pList->nExpr - 1)) == 0) {
		struct ExprList_item *a;
		assert(pList->nExpr>0);
		a = sqlite3DbRealloc(db, pList->a, pList->nExpr * 2 * sizeof(pList->a[0]));
		if (a == 0) {
			goto no_mem;
		}
		pList->a = a;
	}
	assert(pList->a != 0);
	if (1) {
		struct ExprList_item *pItem = &pList->a[pList->nExpr++];
		memset(pItem, 0, sizeof(*pItem));
		pItem->pExpr = pExpr;
	}
	return pList;

no_mem:
	
	sqlite3ExprDelete(db, pExpr);
	sqlite3ExprListDelete(db, pList);
	return 0;
}


SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(
	Parse *pParse,         
	ExprList *pList,       
	IdList *pColumns,      
	Expr *pExpr            
) {
	sqlite3 *db = pParse->db;
	int n;
	int i;
	int iFirst = pList ? pList->nExpr : 0;
	
	if (NEVER(pColumns == 0)) goto vector_append_error;
	if (pExpr == 0) goto vector_append_error;
	n = sqlite3ExprVectorSize(pExpr);
	if (pColumns->nId != n) {
		sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
			pColumns->nId, n);
		goto vector_append_error;
	}
	for (i = 0; i<n; i++) {
		Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);
		pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
		if (pList) {
			assert(pList->nExpr == iFirst + i + 1);
			pList->a[pList->nExpr - 1].zName = pColumns->a[i].zName;
			pColumns->a[i].zName = 0;
		}
	}
	if (pExpr->op == TK_SELECT) {
		if (pList && pList->a[iFirst].pExpr) {
			assert(pList->a[iFirst].pExpr->op == TK_SELECT_COLUMN);
			pList->a[iFirst].pExpr->pRight = pExpr;
			pExpr = 0;
		}
	}

vector_append_error:
	sqlite3ExprDelete(db, pExpr);
	sqlite3IdListDelete(db, pColumns);
	return pList;
}


SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder) {
	if (p == 0) return;
	assert(SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC >= 0 && SQLITE_SO_DESC>0);
	assert(p->nExpr>0);
	if (iSortOrder<0) {
		assert(p->a[p->nExpr - 1].sortOrder == SQLITE_SO_ASC);
		return;
	}
	p->a[p->nExpr - 1].sortOrder = (u8)iSortOrder;
}


SQLITE_PRIVATE void sqlite3ExprListSetName(
	Parse *pParse,          
	ExprList *pList,        
	Token *pName,           
	int dequote             
) {
	assert(pList != 0 || pParse->db->mallocFailed != 0);
	if (pList) {
		struct ExprList_item *pItem;
		assert(pList->nExpr>0);
		pItem = &pList->a[pList->nExpr - 1];
		assert(pItem->zName == 0);
		pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);
		if (dequote) sqlite3Dequote(pItem->zName);
	}
}


SQLITE_PRIVATE void sqlite3ExprListSetSpan(
	Parse *pParse,          
	ExprList *pList,        
	ExprSpan *pSpan         
) {
	sqlite3 *db = pParse->db;
	assert(pList != 0 || db->mallocFailed != 0);
	if (pList) {
		struct ExprList_item *pItem = &pList->a[pList->nExpr - 1];
		assert(pList->nExpr>0);
		assert(db->mallocFailed || pItem->pExpr == pSpan->pExpr);
		sqlite3DbFree(db, pItem->zSpan);
		pItem->zSpan = sqlite3DbStrNDup(db, (char*)pSpan->zStart,
			(int)(pSpan->zEnd - pSpan->zStart));
	}
}


SQLITE_PRIVATE void sqlite3ExprListCheckLength(
	Parse *pParse,
	ExprList *pEList,
	const char *zObject
) {
	int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
	testcase(pEList && pEList->nExpr == mx);
	testcase(pEList && pEList->nExpr == mx + 1);
	if (pEList && pEList->nExpr>mx) {
		sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
	}
}


static SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList) {
	int i;
	struct ExprList_item *pItem;
	assert(pList->a != 0 || pList->nExpr == 0);
	for (pItem = pList->a, i = 0; i<pList->nExpr; i++, pItem++) {
		sqlite3ExprDelete(db, pItem->pExpr);
		sqlite3DbFree(db, pItem->zName);
		sqlite3DbFree(db, pItem->zSpan);
	}
	sqlite3DbFree(db, pList->a);
	sqlite3DbFree(db, pList);
}
SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList) {
	if (pList) exprListDeleteNN(db, pList);
}


SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList *pList) {
	int i;
	u32 m = 0;
	if (pList) {
		for (i = 0; i<pList->nExpr; i++) {
			Expr *pExpr = pList->a[i].pExpr;
			assert(pExpr != 0);
			m |= pExpr->flags;
		}
	}
	return m;
}


static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr) {

	
	if (pWalker->eCode == 2 && ExprHasProperty(pExpr, EP_FromJoin)) {
		pWalker->eCode = 0;
		return WRC_Abort;
	}

	switch (pExpr->op) {
		
	case TK_FUNCTION:
		if (pWalker->eCode >= 4 || ExprHasProperty(pExpr, EP_ConstFunc)) {
			return WRC_Continue;
		}
		else {
			pWalker->eCode = 0;
			return WRC_Abort;
		}
	case TK_ID:
	case TK_COLUMN:
	case TK_AGG_FUNCTION:
	case TK_AGG_COLUMN:
		testcase(pExpr->op == TK_ID);
		testcase(pExpr->op == TK_COLUMN);
		testcase(pExpr->op == TK_AGG_FUNCTION);
		testcase(pExpr->op == TK_AGG_COLUMN);
		if (pWalker->eCode == 3 && pExpr->iTable == pWalker->u.iCur) {
			return WRC_Continue;
		}
		else {
			pWalker->eCode = 0;
			return WRC_Abort;
		}
	case TK_VARIABLE:
		if (pWalker->eCode == 5) {
			
			pExpr->op = TK_NULL;
		}
		else if (pWalker->eCode == 4) {
			
			pWalker->eCode = 0;
			return WRC_Abort;
		}
		
	default:
		testcase(pExpr->op == TK_SELECT); 
		testcase(pExpr->op == TK_EXISTS); 
		return WRC_Continue;
	}
}
static int selectNodeIsConstant(Walker *pWalker, Select *NotUsed) {
	UNUSED_PARAMETER(NotUsed);
	pWalker->eCode = 0;
	return WRC_Abort;
}
static int exprIsConst(Expr *p, int initFlag, int iCur) {
	Walker w;
	memset(&w, 0, sizeof(w));
	w.eCode = initFlag;
	w.xExprCallback = exprNodeIsConstant;
	w.xSelectCallback = selectNodeIsConstant;
	w.u.iCur = iCur;
	sqlite3WalkExpr(&w, p);
	return w.eCode;
}


SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr *p) {
	return exprIsConst(p, 1, 0);
}


SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p) {
	return exprIsConst(p, 2, 0);
}


SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr *p, int iCur) {
	return exprIsConst(p, 3, iCur);
}


SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit) {
	assert(isInit == 0 || isInit == 1);
	return exprIsConst(p, 4 + isInit, 0);
}

#ifdef SQLITE_ENABLE_CURSOR_HINTS

SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr *p) {
	Walker w;
	memset(&w, 0, sizeof(w));
	w.eCode = 1;
	w.xExprCallback = sqlite3ExprWalkNoop;
	w.xSelectCallback = selectNodeIsConstant;
	sqlite3WalkExpr(&w, p);
	return w.eCode == 0;
}
#endif


SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr *p, int *pValue) {
	int rc = 0;

	
	assert(p->op != TK_INTEGER || (p->flags & EP_IntValue) != 0
		|| sqlite3GetInt32(p->u.zToken, &rc) == 0);

	if (p->flags & EP_IntValue) {
		*pValue = p->u.iValue;
		return 1;
	}
	switch (p->op) {
	case TK_UPLUS: {
		rc = sqlite3ExprIsInteger(p->pLeft, pValue);
		break;
	}
	case TK_UMINUS: {
		int v;
		if (sqlite3ExprIsInteger(p->pLeft, &v)) {
			assert(v != (-2147483647 - 1));
			*pValue = -v;
			rc = 1;
		}
		break;
	}
	default: break;
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr *p) {
	u8 op;
	while (p->op == TK_UPLUS || p->op == TK_UMINUS) { p = p->pLeft; }
	op = p->op;
	if (op == TK_REGISTER) op = p->op2;
	switch (op) {
	case TK_INTEGER:
	case TK_STRING:
	case TK_FLOAT:
	case TK_BLOB:
		return 0;
	case TK_COLUMN:
		assert(p->pTab != 0);
		return ExprHasProperty(p, EP_CanBeNull) ||
			(p->iColumn >= 0 && p->pTab->aCol[p->iColumn].notNull == 0);
	default:
		return 1;
	}
}


SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff) {
	u8 op;
	if (aff == SQLITE_AFF_BLOB) return 1;
	while (p->op == TK_UPLUS || p->op == TK_UMINUS) { p = p->pLeft; }
	op = p->op;
	if (op == TK_REGISTER) op = p->op2;
	switch (op) {
	case TK_INTEGER: {
		return aff == SQLITE_AFF_INTEGER || aff == SQLITE_AFF_NUMERIC;
	}
	case TK_FLOAT: {
		return aff == SQLITE_AFF_REAL || aff == SQLITE_AFF_NUMERIC;
	}
	case TK_STRING: {
		return aff == SQLITE_AFF_TEXT;
	}
	case TK_BLOB: {
		return 1;
	}
	case TK_COLUMN: {
		assert(p->iTable >= 0);  
		return p->iColumn<0
			&& (aff == SQLITE_AFF_INTEGER || aff == SQLITE_AFF_NUMERIC);
	}
	default: {
		return 0;
	}
	}
}


SQLITE_PRIVATE int sqlite3IsRowid(const char *z) {
	if (sqlite3StrICmp(z, "_ROWID_") == 0) return 1;
	if (sqlite3StrICmp(z, "ROWID") == 0) return 1;
	if (sqlite3StrICmp(z, "OID") == 0) return 1;
	return 0;
}


#ifndef SQLITE_OMIT_SUBQUERY
static Select *isCandidateForInOpt(Expr *pX) {
	Select *p;
	SrcList *pSrc;
	ExprList *pEList;
	Table *pTab;
	int i;
	if (!ExprHasProperty(pX, EP_xIsSelect)) return 0;  
	if (ExprHasProperty(pX, EP_VarSelect)) return 0;  
	p = pX->x.pSelect;
	if (p->pPrior) return 0;              
	if (p->selFlags & (SF_Distinct | SF_Aggregate)) {
		testcase((p->selFlags & (SF_Distinct | SF_Aggregate)) == SF_Distinct);
		testcase((p->selFlags & (SF_Distinct | SF_Aggregate)) == SF_Aggregate);
		return 0; 
	}
	assert(p->pGroupBy == 0);              
	if (p->pLimit) return 0;              
	assert(p->pOffset == 0);               
	if (p->pWhere) return 0;              
	pSrc = p->pSrc;
	assert(pSrc != 0);
	if (pSrc->nSrc != 1) return 0;          
	if (pSrc->a[0].pSelect) return 0;     
	pTab = pSrc->a[0].pTab;
	assert(pTab != 0);
	assert(pTab->pSelect == 0);            
	if (IsVirtual(pTab)) return 0;        
	pEList = p->pEList;
	assert(pEList != 0);
	
	for (i = 0; i<pEList->nExpr; i++) {
		Expr *pRes = pEList->a[i].pExpr;
		if (pRes->op != TK_COLUMN) return 0;
		assert(pRes->iTable == pSrc->a[0].iCursor);  
	}
	return p;
}
#endif 

#ifndef SQLITE_OMIT_SUBQUERY

static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull) {
	int addr1;
	sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);
	addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
	sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);
	sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
	VdbeComment((v, "first_entry_in(%d)", iCur));
	sqlite3VdbeJumpHere(v, addr1);
}
#endif


#ifndef SQLITE_OMIT_SUBQUERY

static int sqlite3InRhsIsConstant(Expr *pIn) {
	Expr *pLHS;
	int res;
	assert(!ExprHasProperty(pIn, EP_xIsSelect));
	pLHS = pIn->pLeft;
	pIn->pLeft = 0;
	res = sqlite3ExprIsConstant(pIn);
	pIn->pLeft = pLHS;
	return res;
}
#endif


#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3FindInIndex(
	Parse *pParse,             
	Expr *pX,                  
	u32 inFlags,               
	int *prRhsHasNull,         
	int *aiMap                 
) {
	Select *p;                            
	int eType = 0;                        
	int iTab = pParse->nTab++;            
	int mustBeUnique;                     
	Vdbe *v = sqlite3GetVdbe(pParse);     

	assert(pX->op == TK_IN);
	mustBeUnique = (inFlags & IN_INDEX_LOOP) != 0;

	
	if (prRhsHasNull && (pX->flags & EP_xIsSelect)) {
		int i;
		ExprList *pEList = pX->x.pSelect->pEList;
		for (i = 0; i<pEList->nExpr; i++) {
			if (sqlite3ExprCanBeNull(pEList->a[i].pExpr)) break;
		}
		if (i == pEList->nExpr) {
			prRhsHasNull = 0;
		}
	}

	
	if (pParse->nErr == 0 && (p = isCandidateForInOpt(pX)) != 0) {
		sqlite3 *db = pParse->db;              
		Table *pTab;                           
		i16 iDb;                               
		ExprList *pEList = p->pEList;
		int nExpr = pEList->nExpr;

		assert(p->pEList != 0);             
		assert(p->pEList->a[0].pExpr != 0); 
		assert(p->pSrc != 0);               
		pTab = p->pSrc->a[0].pTab;

		
		iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
		sqlite3CodeVerifySchema(pParse, iDb);
		sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

		assert(v);  
		if (nExpr == 1 && pEList->a[0].pExpr->iColumn<0) {
			
			int iAddr = sqlite3VdbeAddOp0(v, OP_Once);
			VdbeCoverage(v);

			sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);
			eType = IN_INDEX_ROWID;

			sqlite3VdbeJumpHere(v, iAddr);
		}
		else {
			Index *pIdx;                         
			int affinity_ok = 1;
			int i;

			
			for (i = 0; i<nExpr && affinity_ok; i++) {
				Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
				int iCol = pEList->a[i].pExpr->iColumn;
				char idxaff = sqlite3TableColumnAffinity(pTab, iCol); 
				char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);
				testcase(cmpaff == SQLITE_AFF_BLOB);
				testcase(cmpaff == SQLITE_AFF_TEXT);
				switch (cmpaff) {
				case SQLITE_AFF_BLOB:
					break;
				case SQLITE_AFF_TEXT:
					
					assert(idxaff == SQLITE_AFF_TEXT);
					break;
				default:
					affinity_ok = sqlite3IsNumericAffinity(idxaff);
				}
			}

			if (affinity_ok) {
				
				for (pIdx = pTab->pIndex; pIdx && eType == 0; pIdx = pIdx->pNext) {
					Bitmask colUsed;      
					Bitmask mCol;         
					if (pIdx->nColumn<nExpr) continue;
					
					testcase(pIdx->nColumn == BMS - 2);
					testcase(pIdx->nColumn == BMS - 1);
					if (pIdx->nColumn >= BMS - 1) continue;
					if (mustBeUnique) {
						if (pIdx->nKeyCol>nExpr
							|| (pIdx->nColumn>nExpr && !IsUniqueIndex(pIdx))
							) {
							continue;  
						}
					}

					colUsed = 0;   
					for (i = 0; i<nExpr; i++) {
						Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
						Expr *pRhs = pEList->a[i].pExpr;
						CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
						int j;

						assert(pReq != 0 || pRhs->iColumn == XN_ROWID || pParse->nErr);
						for (j = 0; j<nExpr; j++) {
							if (pIdx->aiColumn[j] != pRhs->iColumn) continue;
							assert(pIdx->azColl[j]);
							if (pReq != 0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j]) != 0) {
								continue;
							}
							break;
						}
						if (j == nExpr) break;
						mCol = MASKBIT(j);
						if (mCol & colUsed) break; 
						colUsed |= mCol;
						if (aiMap) aiMap[i] = j;
					}

					assert(i == nExpr || colUsed != (MASKBIT(nExpr) - 1));
					if (colUsed == (MASKBIT(nExpr) - 1)) {
						
						int iAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
#ifndef SQLITE_OMIT_EXPLAIN
						sqlite3VdbeAddOp4(v, OP_Explain, 0, 0, 0,
							sqlite3MPrintf(db, "USING INDEX %s FOR IN-OPERATOR", pIdx->zName),
							P4_DYNAMIC);
#endif
						sqlite3VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);
						sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
						VdbeComment((v, "%s", pIdx->zName));
						assert(IN_INDEX_INDEX_DESC == IN_INDEX_INDEX_ASC + 1);
						eType = IN_INDEX_INDEX_ASC + pIdx->aSortOrder[0];

						if (prRhsHasNull) {
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
							i64 mask = (1 << nExpr) - 1;
							sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed,
								iTab, 0, 0, (u8*)&mask, P4_INT64);
#endif
							*prRhsHasNull = ++pParse->nMem;
							if (nExpr == 1) {
								sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);
							}
						}
						sqlite3VdbeJumpHere(v, iAddr);
					}
				} 
			} 
		} 
	} 

	  
	if (eType == 0
		&& (inFlags & IN_INDEX_NOOP_OK)
		&& !ExprHasProperty(pX, EP_xIsSelect)
		&& (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr <= 2)
		) {
		eType = IN_INDEX_NOOP;
	}

	if (eType == 0) {
		
		u32 savedNQueryLoop = pParse->nQueryLoop;
		int rMayHaveNull = 0;
		eType = IN_INDEX_EPH;
		if (inFlags & IN_INDEX_LOOP) {
			pParse->nQueryLoop = 0;
			if (pX->pLeft->iColumn<0 && !ExprHasProperty(pX, EP_xIsSelect)) {
				eType = IN_INDEX_ROWID;
			}
		}
		else if (prRhsHasNull) {
			*prRhsHasNull = rMayHaveNull = ++pParse->nMem;
		}
		sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType == IN_INDEX_ROWID);
		pParse->nQueryLoop = savedNQueryLoop;
	}
	else {
		pX->iTable = iTab;
	}

	if (aiMap && eType != IN_INDEX_INDEX_ASC && eType != IN_INDEX_INDEX_DESC) {
		int i, n;
		n = sqlite3ExprVectorSize(pX->pLeft);
		for (i = 0; i<n; i++) aiMap[i] = i;
	}
	return eType;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY

static char *exprINAffinity(Parse *pParse, Expr *pExpr) {
	Expr *pLeft = pExpr->pLeft;
	int nVal = sqlite3ExprVectorSize(pLeft);
	Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;
	char *zRet;

	assert(pExpr->op == TK_IN);
	zRet = sqlite3DbMallocZero(pParse->db, nVal + 1);
	if (zRet) {
		int i;
		for (i = 0; i<nVal; i++) {
			Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);
			char a = sqlite3ExprAffinity(pA);
			if (pSelect) {
				zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);
			}
			else {
				zRet[i] = a;
			}
		}
		zRet[nVal] = '\0';
	}
	return zRet;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY

SQLITE_PRIVATE void sqlite3SubselectError(Parse *pParse, int nActual, int nExpect) {
	const char *zFmt = "sub-select returns %d columns - expected %d";
	sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);
}
#endif


#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3CodeSubselect(
	Parse *pParse,          
	Expr *pExpr,            
	int rHasNullFlag,       
	int isRowid             
) {
	int jmpIfDynamic = -1;                      
	int rReg = 0;                           
	Vdbe *v = sqlite3GetVdbe(pParse);
	if (NEVER(v == 0)) return 0;
	sqlite3ExprCachePush(pParse);

	
	if (!ExprHasProperty(pExpr, EP_VarSelect)) {
		jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
	}

#ifndef SQLITE_OMIT_EXPLAIN
	if (pParse->explain == 2) {
		char *zMsg = sqlite3MPrintf(pParse->db, "EXECUTE %s%s SUBQUERY %d",
			jmpIfDynamic >= 0 ? "" : "CORRELATED ",
			pExpr->op == TK_IN ? "LIST" : "SCALAR",
			pParse->iNextSelectId
		);
		sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);
	}
#endif

	switch (pExpr->op) {
	case TK_IN: {
		int addr;                   
		Expr *pLeft = pExpr->pLeft; 
		KeyInfo *pKeyInfo = 0;      
		int nVal;                   

		nVal = sqlite3ExprVectorSize(pLeft);
		assert(!isRowid || nVal == 1);

		
		pExpr->iTable = pParse->nTab++;
		addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,
			pExpr->iTable, (isRowid ? 0 : nVal));
		pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);

		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			
			Select *pSelect = pExpr->x.pSelect;
			ExprList *pEList = pSelect->pEList;

			assert(!isRowid);
			
			if (ALWAYS(pEList->nExpr == nVal)) {
				SelectDest dest;
				int i;
				sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);
				dest.zAffSdst = exprINAffinity(pParse, pExpr);
				assert((pExpr->iTable & 0x0000FFFF) == pExpr->iTable);
				pSelect->iLimit = 0;
				testcase(pSelect->selFlags & SF_Distinct);
				testcase(pKeyInfo == 0); 
				if (sqlite3Select(pParse, pSelect, &dest)) {
					sqlite3DbFree(pParse->db, dest.zAffSdst);
					sqlite3KeyInfoUnref(pKeyInfo);
					return 0;
				}
				sqlite3DbFree(pParse->db, dest.zAffSdst);
				assert(pKeyInfo != 0); 
				assert(pEList != 0);
				assert(pEList->nExpr>0);
				assert(sqlite3KeyInfoIsWriteable(pKeyInfo));
				for (i = 0; i<nVal; i++) {
					Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);
					pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(
						pParse, p, pEList->a[i].pExpr
					);
				}
			}
		}
		else if (ALWAYS(pExpr->x.pList != 0)) {
			
			char affinity;            
			int i;
			ExprList *pList = pExpr->x.pList;
			struct ExprList_item *pItem;
			int r1, r2, r3;

			affinity = sqlite3ExprAffinity(pLeft);
			if (!affinity) {
				affinity = SQLITE_AFF_BLOB;
			}
			if (pKeyInfo) {
				assert(sqlite3KeyInfoIsWriteable(pKeyInfo));
				pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
			}

			
			r1 = sqlite3GetTempReg(pParse);
			r2 = sqlite3GetTempReg(pParse);
			if (isRowid) sqlite3VdbeAddOp2(v, OP_Null, 0, r2);
			for (i = pList->nExpr, pItem = pList->a; i>0; i--, pItem++) {
				Expr *pE2 = pItem->pExpr;
				int iValToIns;

				
				if (jmpIfDynamic >= 0 && !sqlite3ExprIsConstant(pE2)) {
					sqlite3VdbeChangeToNoop(v, jmpIfDynamic);
					jmpIfDynamic = -1;
				}

				
				if (isRowid && sqlite3ExprIsInteger(pE2, &iValToIns)) {
					sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);
				}
				else {
					r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);
					if (isRowid) {
						sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,
							sqlite3VdbeCurrentAddr(v) + 2);
						VdbeCoverage(v);
						sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);
					}
					else {
						sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);
						sqlite3ExprCacheAffinityChange(pParse, r3, 1);
						sqlite3VdbeAddOp2(v, OP_IdxInsert, pExpr->iTable, r2);
					}
				}
			}
			sqlite3ReleaseTempReg(pParse, r1);
			sqlite3ReleaseTempReg(pParse, r2);
		}
		if (pKeyInfo) {
			sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);
		}
		break;
	}

	case TK_EXISTS:
	case TK_SELECT:
	default: {
		
		Select *pSel;                         
		SelectDest dest;                      
		int nReg;                             

		testcase(pExpr->op == TK_EXISTS);
		testcase(pExpr->op == TK_SELECT);
		assert(pExpr->op == TK_EXISTS || pExpr->op == TK_SELECT);
		assert(ExprHasProperty(pExpr, EP_xIsSelect));

		pSel = pExpr->x.pSelect;
		nReg = pExpr->op == TK_SELECT ? pSel->pEList->nExpr : 1;
		sqlite3SelectDestInit(&dest, 0, pParse->nMem + 1);
		pParse->nMem += nReg;
		if (pExpr->op == TK_SELECT) {
			dest.eDest = SRT_Mem;
			dest.iSdst = dest.iSDParm;
			dest.nSdst = nReg;
			sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm + nReg - 1);
			VdbeComment((v, "Init subquery result"));
		}
		else {
			dest.eDest = SRT_Exists;
			sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);
			VdbeComment((v, "Init EXISTS result"));
		}
		sqlite3ExprDelete(pParse->db, pSel->pLimit);
		pSel->pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,
			&sqlite3IntTokens[1], 0);
		pSel->iLimit = 0;
		pSel->selFlags &= ~SF_MultiValue;
		if (sqlite3Select(pParse, pSel, &dest)) {
			return 0;
		}
		rReg = dest.iSDParm;
		ExprSetVVAProperty(pExpr, EP_NoReduce);
		break;
	}
	}

	if (rHasNullFlag) {
		sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);
	}

	if (jmpIfDynamic >= 0) {
		sqlite3VdbeJumpHere(v, jmpIfDynamic);
	}
	sqlite3ExprCachePop(pParse);

	return rReg;
}
#endif 

#ifndef SQLITE_OMIT_SUBQUERY

SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse *pParse, Expr *pIn) {
	int nVector = sqlite3ExprVectorSize(pIn->pLeft);
	if ((pIn->flags & EP_xIsSelect)) {
		if (nVector != pIn->x.pSelect->pEList->nExpr) {
			sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);
			return 1;
		}
	}
	else if (nVector != 1) {
		if ((pIn->pLeft->flags & EP_xIsSelect)) {
			sqlite3SubselectError(pParse, nVector, 1);
		}
		else {
			sqlite3ErrorMsg(pParse, "row value misused");
		}
		return 1;
	}
	return 0;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY

static void sqlite3ExprCodeIN(
	Parse *pParse,        
	Expr *pExpr,          
	int destIfFalse,      
	int destIfNull        
) {
	int rRhsHasNull = 0;  
	int eType;            
	int rLhs;             
	int rLhsOrig;         
	Vdbe *v;              
	int *aiMap = 0;       
	char *zAff = 0;       
	int nVector;          
	int iDummy;           
	Expr *pLeft;          
	int i;                
	int destStep2;        
	int destStep6 = 0;    
	int addrTruthOp;      
	int destNotNull;      
	int addrTop;          

	pLeft = pExpr->pLeft;
	if (sqlite3ExprCheckIN(pParse, pExpr)) return;
	zAff = exprINAffinity(pParse, pExpr);
	nVector = sqlite3ExprVectorSize(pExpr->pLeft);
	aiMap = (int*)sqlite3DbMallocZero(
		pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1
	);
	if (pParse->db->mallocFailed) goto sqlite3ExprCodeIN_oom_error;

	
	v = pParse->pVdbe;
	assert(v != 0);       
	VdbeNoopComment((v, "begin IN expr"));
	eType = sqlite3FindInIndex(pParse, pExpr,
		IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,
		destIfFalse == destIfNull ? 0 : &rRhsHasNull, aiMap);

	assert(pParse->nErr || nVector == 1 || eType == IN_INDEX_EPH
		|| eType == IN_INDEX_INDEX_ASC || eType == IN_INDEX_INDEX_DESC
	);
#ifdef SQLITE_DEBUG
	
	for (i = 0; i<nVector; i++) {
		int j, cnt;
		for (cnt = j = 0; j<nVector; j++) if (aiMap[j] == i) cnt++;
		assert(cnt == 1);
	}
#endif

	
	sqlite3ExprCachePush(pParse);
	rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);
	for (i = 0; i<nVector && aiMap[i] == i; i++) {} 
	if (i == nVector) {
		
		rLhs = rLhsOrig;
	}
	else {
		
		rLhs = sqlite3GetTempRange(pParse, nVector);
		for (i = 0; i<nVector; i++) {
			sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig + i, rLhs + aiMap[i], 0);
		}
	}

	
	if (eType == IN_INDEX_NOOP) {
		ExprList *pList = pExpr->x.pList;
		CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
		int labelOk = sqlite3VdbeMakeLabel(v);
		int r2, regToFree;
		int regCkNull = 0;
		int ii;
		assert(!ExprHasProperty(pExpr, EP_xIsSelect));
		if (destIfNull != destIfFalse) {
			regCkNull = sqlite3GetTempReg(pParse);
			sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);
		}
		for (ii = 0; ii<pList->nExpr; ii++) {
			r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
			if (regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr)) {
				sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);
			}
			if (ii<pList->nExpr - 1 || destIfNull != destIfFalse) {
				sqlite3VdbeAddOp4(v, OP_Eq, rLhs, labelOk, r2,
					(void*)pColl, P4_COLLSEQ);
				VdbeCoverageIf(v, ii<pList->nExpr - 1);
				VdbeCoverageIf(v, ii == pList->nExpr - 1);
				sqlite3VdbeChangeP5(v, zAff[0]);
			}
			else {
				assert(destIfNull == destIfFalse);
				sqlite3VdbeAddOp4(v, OP_Ne, rLhs, destIfFalse, r2,
					(void*)pColl, P4_COLLSEQ); VdbeCoverage(v);
				sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);
			}
			sqlite3ReleaseTempReg(pParse, regToFree);
		}
		if (regCkNull) {
			sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);
			sqlite3VdbeGoto(v, destIfFalse);
		}
		sqlite3VdbeResolveLabel(v, labelOk);
		sqlite3ReleaseTempReg(pParse, regCkNull);
		goto sqlite3ExprCodeIN_finished;
	}

	
	if (destIfNull == destIfFalse) {
		destStep2 = destIfFalse;
	}
	else {
		destStep2 = destStep6 = sqlite3VdbeMakeLabel(v);
	}
	for (i = 0; i<nVector; i++) {
		Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
		if (sqlite3ExprCanBeNull(p)) {
			sqlite3VdbeAddOp2(v, OP_IsNull, rLhs + i, destStep2);
			VdbeCoverage(v);
		}
	}

	
	if (eType == IN_INDEX_ROWID) {
		
		sqlite3VdbeAddOp3(v, OP_SeekRowid, pExpr->iTable, destIfFalse, rLhs);
		VdbeCoverage(v);
		addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  
	}
	else {
		sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);
		if (destIfFalse == destIfNull) {
			
			sqlite3VdbeAddOp4Int(v, OP_NotFound, pExpr->iTable, destIfFalse,
				rLhs, nVector); VdbeCoverage(v);
			goto sqlite3ExprCodeIN_finished;
		}
		
		addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0,
			rLhs, nVector); VdbeCoverage(v);
	}

	
	if (rRhsHasNull && nVector == 1) {
		sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);
		VdbeCoverage(v);
	}

	
	if (destIfFalse == destIfNull) sqlite3VdbeGoto(v, destIfFalse);

	
	if (destStep6) sqlite3VdbeResolveLabel(v, destStep6);
	addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, pExpr->iTable, destIfFalse);
	VdbeCoverage(v);
	if (nVector>1) {
		destNotNull = sqlite3VdbeMakeLabel(v);
	}
	else {
		
		destNotNull = destIfFalse;
	}
	for (i = 0; i<nVector; i++) {
		Expr *p;
		CollSeq *pColl;
		int r3 = sqlite3GetTempReg(pParse);
		p = sqlite3VectorFieldSubexpr(pLeft, i);
		pColl = sqlite3ExprCollSeq(pParse, p);
		sqlite3VdbeAddOp3(v, OP_Column, pExpr->iTable, i, r3);
		sqlite3VdbeAddOp4(v, OP_Ne, rLhs + i, destNotNull, r3,
			(void*)pColl, P4_COLLSEQ);
		VdbeCoverage(v);
		sqlite3ReleaseTempReg(pParse, r3);
	}
	sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);
	if (nVector>1) {
		sqlite3VdbeResolveLabel(v, destNotNull);
		sqlite3VdbeAddOp2(v, OP_Next, pExpr->iTable, addrTop + 1);
		VdbeCoverage(v);

		
		sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);
	}

	
	sqlite3VdbeJumpHere(v, addrTruthOp);

sqlite3ExprCodeIN_finished:
	if (rLhs != rLhsOrig) sqlite3ReleaseTempReg(pParse, rLhs);
	sqlite3ExprCachePop(pParse);
	VdbeComment((v, "end IN expr"));
sqlite3ExprCodeIN_oom_error:
	sqlite3DbFree(pParse->db, aiMap);
	sqlite3DbFree(pParse->db, zAff);
}
#endif 

#ifndef SQLITE_OMIT_FLOATING_POINT

static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem) {
	if (ALWAYS(z != 0)) {
		double value;
		sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);
		assert(!sqlite3IsNaN(value)); 
		if (negateFlag) value = -value;
		sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);
	}
}
#endif



static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem) {
	Vdbe *v = pParse->pVdbe;
	if (pExpr->flags & EP_IntValue) {
		int i = pExpr->u.iValue;
		assert(i >= 0);
		if (negFlag) i = -i;
		sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);
	}
	else {
		int c;
		i64 value;
		const char *z = pExpr->u.zToken;
		assert(z != 0);
		c = sqlite3DecOrHexToI64(z, &value);
		if (c == 0 || (c == 2 && negFlag)) {
			if (negFlag) { value = c == 2 ? SMALLEST_INT64 : -value; }
			sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);
		}
		else {
#ifdef SQLITE_OMIT_FLOATING_POINT
			sqlite3ErrorMsg(pParse, "oversized integer: %s%s", negFlag ? "-" : "", z);
#else
#ifndef SQLITE_OMIT_HEX_INTEGER
			if (sqlite3_strnicmp(z, "0x", 2) == 0) {
				sqlite3ErrorMsg(pParse, "hex literal too big: %s", z);
			}
			else
#endif
			{
				codeReal(v, z, negFlag, iMem);
			}
#endif
		}
	}
}


static void cacheEntryClear(Parse *pParse, int i) {
	if (pParse->aColCache[i].tempReg) {
		if (pParse->nTempReg<ArraySize(pParse->aTempReg)) {
			pParse->aTempReg[pParse->nTempReg++] = pParse->aColCache[i].iReg;
		}
	}
	pParse->nColCache--;
	if (i<pParse->nColCache) {
		pParse->aColCache[i] = pParse->aColCache[pParse->nColCache];
	}
}



SQLITE_PRIVATE void sqlite3ExprCacheStore(Parse *pParse, int iTab, int iCol, int iReg) {
	int i;
	int minLru;
	int idxLru;
	struct yColCache *p;

	
	assert(iReg>0 || pParse->nErr || pParse->db->mallocFailed);
	assert(iCol >= -1 && iCol<32768);  

									   
	if (OptimizationDisabled(pParse->db, SQLITE_ColumnCache)) return;

	
#ifndef NDEBUG
	for (i = 0, p = pParse->aColCache; i<pParse->nColCache; i++, p++) {
		assert(p->iTable != iTab || p->iColumn != iCol);
	}
#endif

	
	if (pParse->nColCache >= SQLITE_N_COLCACHE) {
		minLru = 0x7fffffff;
		idxLru = -1;
		for (i = 0, p = pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++) {
			if (p->lru<minLru) {
				idxLru = i;
				minLru = p->lru;
			}
		}
		p = &pParse->aColCache[idxLru];
	}
	else {
		p = &pParse->aColCache[pParse->nColCache++];
	}

	
	p->iLevel = pParse->iCacheLevel;
	p->iTable = iTab;
	p->iColumn = iCol;
	p->iReg = iReg;
	p->tempReg = 0;
	p->lru = pParse->iCacheCnt++;
}


SQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse *pParse, int iReg, int nReg) {
	int i = 0;
	while (i<pParse->nColCache) {
		struct yColCache *p = &pParse->aColCache[i];
		if (p->iReg >= iReg && p->iReg < iReg + nReg) {
			cacheEntryClear(pParse, i);
		}
		else {
			i++;
		}
	}
}


SQLITE_PRIVATE void sqlite3ExprCachePush(Parse *pParse) {
	pParse->iCacheLevel++;
#ifdef SQLITE_DEBUG
	if (pParse->db->flags & SQLITE_VdbeAddopTrace) {
		printf("PUSH to %d\n", pParse->iCacheLevel);
	}
#endif
}


SQLITE_PRIVATE void sqlite3ExprCachePop(Parse *pParse) {
	int i = 0;
	assert(pParse->iCacheLevel >= 1);
	pParse->iCacheLevel--;
#ifdef SQLITE_DEBUG
	if (pParse->db->flags & SQLITE_VdbeAddopTrace) {
		printf("POP  to %d\n", pParse->iCacheLevel);
	}
#endif
	while (i<pParse->nColCache) {
		if (pParse->aColCache[i].iLevel>pParse->iCacheLevel) {
			cacheEntryClear(pParse, i);
		}
		else {
			i++;
		}
	}
}


static void sqlite3ExprCachePinRegister(Parse *pParse, int iReg) {
	int i;
	struct yColCache *p;
	for (i = 0, p = pParse->aColCache; i<pParse->nColCache; i++, p++) {
		if (p->iReg == iReg) {
			p->tempReg = 0;
		}
	}
}


SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(
	Parse *pParse,  
	Index *pIdx,    
	int iTabCur,    
	int iIdxCol,    
	int regOut      
) {
	i16 iTabCol = pIdx->aiColumn[iIdxCol];
	if (iTabCol == XN_EXPR) {
		assert(pIdx->aColExpr);
		assert(pIdx->aColExpr->nExpr>iIdxCol);
		pParse->iSelfTab = iTabCur;
		sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
	}
	else {
		sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
			iTabCol, regOut);
	}
}


SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(
	Vdbe *v,        
	Table *pTab,    
	int iTabCur,    
	int iCol,       
	int regOut      
) {
	if (iCol<0 || iCol == pTab->iPKey) {
		sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);
	}
	else {
		int op = IsVirtual(pTab) ? OP_VColumn : OP_Column;
		int x = iCol;
		if (!HasRowid(pTab) && !IsVirtual(pTab)) {
			x = sqlite3ColumnOfIndex(sqlite3PrimaryKeyIndex(pTab), iCol);
		}
		sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);
	}
	if (iCol >= 0) {
		sqlite3ColumnDefault(v, pTab, iCol, regOut);
	}
}


SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(
	Parse *pParse,   
	Table *pTab,     
	int iColumn,     
	int iTable,      
	int iReg,        
	u8 p5            
) {
	Vdbe *v = pParse->pVdbe;
	int i;
	struct yColCache *p;

	for (i = 0, p = pParse->aColCache; i<pParse->nColCache; i++, p++) {
		if (p->iTable == iTable && p->iColumn == iColumn) {
			p->lru = pParse->iCacheCnt++;
			sqlite3ExprCachePinRegister(pParse, p->iReg);
			return p->iReg;
		}
	}
	assert(v != 0);
	sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);
	if (p5) {
		sqlite3VdbeChangeP5(v, p5);
	}
	else {
		sqlite3ExprCacheStore(pParse, iTable, iColumn, iReg);
	}
	return iReg;
}
SQLITE_PRIVATE void sqlite3ExprCodeGetColumnToReg(
	Parse *pParse,   
	Table *pTab,     
	int iColumn,     
	int iTable,      
	int iReg         
) {
	int r1 = sqlite3ExprCodeGetColumn(pParse, pTab, iColumn, iTable, iReg, 0);
	if (r1 != iReg) sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, r1, iReg);
}



SQLITE_PRIVATE void sqlite3ExprCacheClear(Parse *pParse) {
	int i;

#if SQLITE_DEBUG
	if (pParse->db->flags & SQLITE_VdbeAddopTrace) {
		printf("CLEAR\n");
	}
#endif
	for (i = 0; i<pParse->nColCache; i++) {
		if (pParse->aColCache[i].tempReg
			&& pParse->nTempReg<ArraySize(pParse->aTempReg)
			) {
			pParse->aTempReg[pParse->nTempReg++] = pParse->aColCache[i].iReg;
		}
	}
	pParse->nColCache = 0;
}


SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount) {
	sqlite3ExprCacheRemove(pParse, iStart, iCount);
}


SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg) {
	assert(iFrom >= iTo + nReg || iFrom + nReg <= iTo);
	sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);
	sqlite3ExprCacheRemove(pParse, iFrom, nReg);
}

#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)

static int usedAsColumnCache(Parse *pParse, int iFrom, int iTo) {
	int i;
	struct yColCache *p;
	for (i = 0, p = pParse->aColCache; i<pParse->nColCache; i++, p++) {
		int r = p->iReg;
		if (r >= iFrom && r <= iTo) return 1;    
	}
	return 0;
}
#endif 



static void exprToRegister(Expr *p, int iReg) {
	p->op2 = p->op;
	p->op = TK_REGISTER;
	p->iTable = iReg;
	ExprClearProperty(p, EP_Skip);
}


static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable) {
	int iResult;
	int nResult = sqlite3ExprVectorSize(p);
	if (nResult == 1) {
		iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
	}
	else {
		*piFreeable = 0;
		if (p->op == TK_SELECT) {
			iResult = sqlite3CodeSubselect(pParse, p, 0, 0);
		}
		else {
			int i;
			iResult = pParse->nMem + 1;
			pParse->nMem += nResult;
			for (i = 0; i<nResult; i++) {
				sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i + iResult);
			}
		}
	}
	return iResult;
}



SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target) {
	Vdbe *v = pParse->pVdbe;  
	int op;                   
	int inReg = target;       
	int regFree1 = 0;         
	int regFree2 = 0;         
	int r1, r2;               
	Expr tempX;               
	int p5 = 0;

	assert(target>0 && target <= pParse->nMem);
	if (v == 0) {
		assert(pParse->db->mallocFailed);
		return 0;
	}

	if (pExpr == 0) {
		op = TK_NULL;
	}
	else {
		op = pExpr->op;
	}
	switch (op) {
	case TK_AGG_COLUMN: {
		AggInfo *pAggInfo = pExpr->pAggInfo;
		struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];
		if (!pAggInfo->directMode) {
			assert(pCol->iMem>0);
			return pCol->iMem;
		}
		else if (pAggInfo->useSortingIdx) {
			sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,
				pCol->iSorterColumn, target);
			return target;
		}
		
	}
	case TK_COLUMN: {
		int iTab = pExpr->iTable;
		if (iTab<0) {
			if (pParse->ckBase>0) {
				
				return pExpr->iColumn + pParse->ckBase;
			}
			else {
				
				iTab = pParse->iSelfTab;
			}
		}
		return sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,
			pExpr->iColumn, iTab, target,
			pExpr->op2);
	}
	case TK_INTEGER: {
		codeInteger(pParse, pExpr, 0, target);
		return target;
	}
#ifndef SQLITE_OMIT_FLOATING_POINT
	case TK_FLOAT: {
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		codeReal(v, pExpr->u.zToken, 0, target);
		return target;
	}
#endif
	case TK_STRING: {
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
		return target;
	}
	case TK_NULL: {
		sqlite3VdbeAddOp2(v, OP_Null, 0, target);
		return target;
	}
#ifndef SQLITE_OMIT_BLOB_LITERAL
	case TK_BLOB: {
		int n;
		const char *z;
		char *zBlob;
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');
		assert(pExpr->u.zToken[1] == '\'');
		z = &pExpr->u.zToken[2];
		n = sqlite3Strlen30(z) - 1;
		assert(z[n] == '\'');
		zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);
		sqlite3VdbeAddOp4(v, OP_Blob, n / 2, target, 0, zBlob, P4_DYNAMIC);
		return target;
	}
#endif
	case TK_VARIABLE: {
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		assert(pExpr->u.zToken != 0);
		assert(pExpr->u.zToken[0] != 0);
		sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);
		if (pExpr->u.zToken[1] != 0) {
			assert(pExpr->u.zToken[0] == '?'
				|| strcmp(pExpr->u.zToken, pParse->azVar[pExpr->iColumn - 1]) == 0);
			sqlite3VdbeChangeP4(v, -1, pParse->azVar[pExpr->iColumn - 1], P4_STATIC);
		}
		return target;
	}
	case TK_REGISTER: {
		return pExpr->iTable;
	}
#ifndef SQLITE_OMIT_CAST
	case TK_CAST: {
		
		inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
		if (inReg != target) {
			sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);
			inReg = target;
		}
		sqlite3VdbeAddOp2(v, OP_Cast, target,
			sqlite3AffinityType(pExpr->u.zToken, 0));
		testcase(usedAsColumnCache(pParse, inReg, inReg));
		sqlite3ExprCacheAffinityChange(pParse, inReg, 1);
		return inReg;
	}
#endif 
	case TK_IS:
	case TK_ISNOT:
		op = (op == TK_IS) ? TK_EQ : TK_NE;
		p5 = SQLITE_NULLEQ;
		
	case TK_LT:
	case TK_LE:
	case TK_GT:
	case TK_GE:
	case TK_NE:
	case TK_EQ: {
		Expr *pLeft = pExpr->pLeft;
		if (sqlite3ExprIsVector(pLeft)) {
			codeVectorCompare(pParse, pExpr, target, op, p5);
		}
		else {
			r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);
			r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
			codeCompare(pParse, pLeft, pExpr->pRight, op,
				r1, r2, inReg, SQLITE_STOREP2 | p5);
			assert(TK_LT == OP_Lt); testcase(op == OP_Lt); VdbeCoverageIf(v, op == OP_Lt);
			assert(TK_LE == OP_Le); testcase(op == OP_Le); VdbeCoverageIf(v, op == OP_Le);
			assert(TK_GT == OP_Gt); testcase(op == OP_Gt); VdbeCoverageIf(v, op == OP_Gt);
			assert(TK_GE == OP_Ge); testcase(op == OP_Ge); VdbeCoverageIf(v, op == OP_Ge);
			assert(TK_EQ == OP_Eq); testcase(op == OP_Eq); VdbeCoverageIf(v, op == OP_Eq);
			assert(TK_NE == OP_Ne); testcase(op == OP_Ne); VdbeCoverageIf(v, op == OP_Ne);
			testcase(regFree1 == 0);
			testcase(regFree2 == 0);
		}
		break;
	}
	case TK_AND:
	case TK_OR:
	case TK_PLUS:
	case TK_STAR:
	case TK_MINUS:
	case TK_REM:
	case TK_BITAND:
	case TK_BITOR:
	case TK_SLASH:
	case TK_LSHIFT:
	case TK_RSHIFT:
	case TK_CONCAT: {
		assert(TK_AND == OP_And);            testcase(op == TK_AND);
		assert(TK_OR == OP_Or);              testcase(op == TK_OR);
		assert(TK_PLUS == OP_Add);           testcase(op == TK_PLUS);
		assert(TK_MINUS == OP_Subtract);     testcase(op == TK_MINUS);
		assert(TK_REM == OP_Remainder);      testcase(op == TK_REM);
		assert(TK_BITAND == OP_BitAnd);      testcase(op == TK_BITAND);
		assert(TK_BITOR == OP_BitOr);        testcase(op == TK_BITOR);
		assert(TK_SLASH == OP_Divide);       testcase(op == TK_SLASH);
		assert(TK_LSHIFT == OP_ShiftLeft);   testcase(op == TK_LSHIFT);
		assert(TK_RSHIFT == OP_ShiftRight);  testcase(op == TK_RSHIFT);
		assert(TK_CONCAT == OP_Concat);      testcase(op == TK_CONCAT);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
		sqlite3VdbeAddOp3(v, op, r2, r1, target);
		testcase(regFree1 == 0);
		testcase(regFree2 == 0);
		break;
	}
	case TK_UMINUS: {
		Expr *pLeft = pExpr->pLeft;
		assert(pLeft);
		if (pLeft->op == TK_INTEGER) {
			codeInteger(pParse, pLeft, 1, target);
			return target;
#ifndef SQLITE_OMIT_FLOATING_POINT
		}
		else if (pLeft->op == TK_FLOAT) {
			assert(!ExprHasProperty(pExpr, EP_IntValue));
			codeReal(v, pLeft->u.zToken, 1, target);
			return target;
#endif
		}
		else {
			tempX.op = TK_INTEGER;
			tempX.flags = EP_IntValue | EP_TokenOnly;
			tempX.u.iValue = 0;
			r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);
			r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
			sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);
			testcase(regFree2 == 0);
		}
		break;
	}
	case TK_BITNOT:
	case TK_NOT: {
		assert(TK_BITNOT == OP_BitNot);   testcase(op == TK_BITNOT);
		assert(TK_NOT == OP_Not);         testcase(op == TK_NOT);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		testcase(regFree1 == 0);
		sqlite3VdbeAddOp2(v, op, r1, inReg);
		break;
	}
	case TK_ISNULL:
	case TK_NOTNULL: {
		int addr;
		assert(TK_ISNULL == OP_IsNull);   testcase(op == TK_ISNULL);
		assert(TK_NOTNULL == OP_NotNull); testcase(op == TK_NOTNULL);
		sqlite3VdbeAddOp2(v, OP_Integer, 1, target);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		testcase(regFree1 == 0);
		addr = sqlite3VdbeAddOp1(v, op, r1);
		VdbeCoverageIf(v, op == TK_ISNULL);
		VdbeCoverageIf(v, op == TK_NOTNULL);
		sqlite3VdbeAddOp2(v, OP_Integer, 0, target);
		sqlite3VdbeJumpHere(v, addr);
		break;
	}
	case TK_AGG_FUNCTION: {
		AggInfo *pInfo = pExpr->pAggInfo;
		if (pInfo == 0) {
			assert(!ExprHasProperty(pExpr, EP_IntValue));
			sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
		}
		else {
			return pInfo->aFunc[pExpr->iAgg].iMem;
		}
		break;
	}
	case TK_FUNCTION: {
		ExprList *pFarg;       
		int nFarg;             
		FuncDef *pDef;         
		const char *zId;       
		u32 constMask = 0;     
		int i;                 
		sqlite3 *db = pParse->db;  
		u8 enc = ENC(db);      
		CollSeq *pColl = 0;    

		assert(!ExprHasProperty(pExpr, EP_xIsSelect));
		if (ExprHasProperty(pExpr, EP_TokenOnly)) {
			pFarg = 0;
		}
		else {
			pFarg = pExpr->x.pList;
		}
		nFarg = pFarg ? pFarg->nExpr : 0;
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		zId = pExpr->u.zToken;
		pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
		if (pDef == 0 && pParse->explain) {
			pDef = sqlite3FindFunction(db, "unknown", nFarg, enc, 0);
		}
#endif
		if (pDef == 0 || pDef->xFinalize != 0) {
			sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);
			break;
		}

		
		if (pDef->funcFlags & SQLITE_FUNC_COALESCE) {
			int endCoalesce = sqlite3VdbeMakeLabel(v);
			assert(nFarg >= 2);
			sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
			for (i = 1; i<nFarg; i++) {
				sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);
				VdbeCoverage(v);
				sqlite3ExprCacheRemove(pParse, target, 1);
				sqlite3ExprCachePush(pParse);
				sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
				sqlite3ExprCachePop(pParse);
			}
			sqlite3VdbeResolveLabel(v, endCoalesce);
			break;
		}

		
		if (pDef->funcFlags & SQLITE_FUNC_UNLIKELY) {
			assert(nFarg >= 1);
			return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);
		}

		for (i = 0; i<nFarg; i++) {
			if (i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {
				testcase(i == 31);
				constMask |= MASKBIT32(i);
			}
			if ((pDef->funcFlags & SQLITE_FUNC_NEEDCOLL) != 0 && !pColl) {
				pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
			}
		}
		if (pFarg) {
			if (constMask) {
				r1 = pParse->nMem + 1;
				pParse->nMem += nFarg;
			}
			else {
				r1 = sqlite3GetTempRange(pParse, nFarg);
			}

			
			if ((pDef->funcFlags & (SQLITE_FUNC_LENGTH | SQLITE_FUNC_TYPEOF)) != 0) {
				u8 exprOp;
				assert(nFarg == 1);
				assert(pFarg->a[0].pExpr != 0);
				exprOp = pFarg->a[0].pExpr->op;
				if (exprOp == TK_COLUMN || exprOp == TK_AGG_COLUMN) {
					assert(SQLITE_FUNC_LENGTH == OPFLAG_LENGTHARG);
					assert(SQLITE_FUNC_TYPEOF == OPFLAG_TYPEOFARG);
					testcase(pDef->funcFlags & OPFLAG_LENGTHARG);
					pFarg->a[0].pExpr->op2 =
						pDef->funcFlags & (OPFLAG_LENGTHARG | OPFLAG_TYPEOFARG);
				}
			}

			sqlite3ExprCachePush(pParse);     
			sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,
				SQLITE_ECEL_DUP | SQLITE_ECEL_FACTOR);
			sqlite3ExprCachePop(pParse);      
		}
		else {
			r1 = 0;
		}
#ifndef SQLITE_OMIT_VIRTUALTABLE
		
		if (nFarg >= 2 && (pExpr->flags & EP_InfixFunc)) {
			pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
		}
		else if (nFarg>0) {
			pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
		}
#endif
		if (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL) {
			if (!pColl) pColl = db->pDfltColl;
			sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);
		}
		sqlite3VdbeAddOp4(v, OP_Function0, constMask, r1, target,
			(char*)pDef, P4_FUNCDEF);
		sqlite3VdbeChangeP5(v, (u8)nFarg);
		if (nFarg && constMask == 0) {
			sqlite3ReleaseTempRange(pParse, r1, nFarg);
		}
		return target;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_EXISTS:
	case TK_SELECT: {
		int nCol;
		testcase(op == TK_EXISTS);
		testcase(op == TK_SELECT);
		if (op == TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {
			sqlite3SubselectError(pParse, nCol, 1);
		}
		else {
			return sqlite3CodeSubselect(pParse, pExpr, 0, 0);
		}
		break;
	}
	case TK_SELECT_COLUMN: {
		if (pExpr->pLeft->iTable == 0) {
			pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);
		}
		return pExpr->pLeft->iTable + pExpr->iColumn;
	}
	case TK_IN: {
		int destIfFalse = sqlite3VdbeMakeLabel(v);
		int destIfNull = sqlite3VdbeMakeLabel(v);
		sqlite3VdbeAddOp2(v, OP_Null, 0, target);
		sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
		sqlite3VdbeAddOp2(v, OP_Integer, 1, target);
		sqlite3VdbeResolveLabel(v, destIfFalse);
		sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);
		sqlite3VdbeResolveLabel(v, destIfNull);
		return target;
	}
#endif 


				
	case TK_BETWEEN: {
		exprCodeBetween(pParse, pExpr, target, 0, 0);
		return target;
	}
	case TK_SPAN:
	case TK_COLLATE:
	case TK_UPLUS: {
		return sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
	}

	case TK_TRIGGER: {
		
		Table *pTab = pExpr->pTab;
		int p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + pExpr->iColumn;

		assert(pExpr->iTable == 0 || pExpr->iTable == 1);
		assert(pExpr->iColumn >= -1 && pExpr->iColumn<pTab->nCol);
		assert(pTab->iPKey<0 || pExpr->iColumn != pTab->iPKey);
		assert(p1 >= 0 && p1<(pTab->nCol * 2 + 2));

		sqlite3VdbeAddOp2(v, OP_Param, p1, target);
		VdbeComment((v, "%s.%s -> $%d",
			(pExpr->iTable ? "new" : "old"),
			(pExpr->iColumn<0 ? "rowid" : pExpr->pTab->aCol[pExpr->iColumn].zName),
			target
			));

#ifndef SQLITE_OMIT_FLOATING_POINT
		
		if (pExpr->iColumn >= 0
			&& pTab->aCol[pExpr->iColumn].affinity == SQLITE_AFF_REAL
			) {
			sqlite3VdbeAddOp1(v, OP_RealAffinity, target);
		}
#endif
		break;
	}

	case TK_VECTOR: {
		sqlite3ErrorMsg(pParse, "row value misused");
		break;
	}

					
	default: assert(op == TK_CASE); {
		int endLabel;                     
		int nextCase;                     
		int nExpr;                        
		int i;                            
		ExprList *pEList;                 
		struct ExprList_item *aListelem;  
		Expr opCompare;                   
		Expr *pX;                         
		Expr *pTest = 0;                  
		VVA_ONLY(int iCacheLevel = pParse->iCacheLevel; )

			assert(!ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList);
		assert(pExpr->x.pList->nExpr > 0);
		pEList = pExpr->x.pList;
		aListelem = pEList->a;
		nExpr = pEList->nExpr;
		endLabel = sqlite3VdbeMakeLabel(v);
		if ((pX = pExpr->pLeft) != 0) {
			tempX = *pX;
			testcase(pX->op == TK_COLUMN);
			exprToRegister(&tempX, exprCodeVector(pParse, &tempX, &regFree1));
			testcase(regFree1 == 0);
			memset(&opCompare, 0, sizeof(opCompare));
			opCompare.op = TK_EQ;
			opCompare.pLeft = &tempX;
			pTest = &opCompare;
			
			regFree1 = 0;
		}
		for (i = 0; i<nExpr - 1; i = i + 2) {
			sqlite3ExprCachePush(pParse);
			if (pX) {
				assert(pTest != 0);
				opCompare.pRight = aListelem[i].pExpr;
			}
			else {
				pTest = aListelem[i].pExpr;
			}
			nextCase = sqlite3VdbeMakeLabel(v);
			testcase(pTest->op == TK_COLUMN);
			sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);
			testcase(aListelem[i + 1].pExpr->op == TK_COLUMN);
			sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);
			sqlite3VdbeGoto(v, endLabel);
			sqlite3ExprCachePop(pParse);
			sqlite3VdbeResolveLabel(v, nextCase);
		}
		if ((nExpr & 1) != 0) {
			sqlite3ExprCachePush(pParse);
			sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);
			sqlite3ExprCachePop(pParse);
		}
		else {
			sqlite3VdbeAddOp2(v, OP_Null, 0, target);
		}
		assert(pParse->db->mallocFailed || pParse->nErr>0
			|| pParse->iCacheLevel == iCacheLevel);
		sqlite3VdbeResolveLabel(v, endLabel);
		break;
	}
#ifndef SQLITE_OMIT_TRIGGER
	case TK_RAISE: {
		assert(pExpr->affinity == OE_Rollback
			|| pExpr->affinity == OE_Abort
			|| pExpr->affinity == OE_Fail
			|| pExpr->affinity == OE_Ignore
		);
		if (!pParse->pTriggerTab) {
			sqlite3ErrorMsg(pParse,
				"RAISE() may only be used within a trigger-program");
			return 0;
		}
		if (pExpr->affinity == OE_Abort) {
			sqlite3MayAbort(pParse);
		}
		assert(!ExprHasProperty(pExpr, EP_IntValue));
		if (pExpr->affinity == OE_Ignore) {
			sqlite3VdbeAddOp4(
				v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken, 0);
			VdbeCoverage(v);
		}
		else {
			sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,
				pExpr->affinity, pExpr->u.zToken, 0, 0);
		}

		break;
	}
#endif
	}
	sqlite3ReleaseTempReg(pParse, regFree1);
	sqlite3ReleaseTempReg(pParse, regFree2);
	return inReg;
}


SQLITE_PRIVATE void sqlite3ExprCodeAtInit(
	Parse *pParse,    
	Expr *pExpr,      
	int regDest,      
	u8 reusable       
) {
	ExprList *p;
	assert(ConstFactorOk(pParse));
	p = pParse->pConstExpr;
	pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
	p = sqlite3ExprListAppend(pParse, p, pExpr);
	if (p) {
		struct ExprList_item *pItem = &p->a[p->nExpr - 1];
		pItem->u.iConstExprReg = regDest;
		pItem->reusable = reusable;
	}
	pParse->pConstExpr = p;
}


SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg) {
	int r2;
	pExpr = sqlite3ExprSkipCollate(pExpr);
	if (ConstFactorOk(pParse)
		&& pExpr->op != TK_REGISTER
		&& sqlite3ExprIsConstantNotJoin(pExpr)
		) {
		ExprList *p = pParse->pConstExpr;
		int i;
		*pReg = 0;
		if (p) {
			struct ExprList_item *pItem;
			for (pItem = p->a, i = p->nExpr; i>0; pItem++, i--) {
				if (pItem->reusable && sqlite3ExprCompare(pItem->pExpr, pExpr, -1) == 0) {
					return pItem->u.iConstExprReg;
				}
			}
		}
		r2 = ++pParse->nMem;
		sqlite3ExprCodeAtInit(pParse, pExpr, r2, 1);
	}
	else {
		int r1 = sqlite3GetTempReg(pParse);
		r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
		if (r2 == r1) {
			*pReg = r1;
		}
		else {
			sqlite3ReleaseTempReg(pParse, r1);
			*pReg = 0;
		}
	}
	return r2;
}


SQLITE_PRIVATE void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target) {
	int inReg;

	assert(target>0 && target <= pParse->nMem);
	if (pExpr && pExpr->op == TK_REGISTER) {
		sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, pExpr->iTable, target);
	}
	else {
		inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
		assert(pParse->pVdbe != 0 || pParse->db->mallocFailed);
		if (inReg != target && pParse->pVdbe) {
			sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);
		}
	}
}


SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target) {
	sqlite3 *db = pParse->db;
	pExpr = sqlite3ExprDup(db, pExpr, 0);
	if (!db->mallocFailed) sqlite3ExprCode(pParse, pExpr, target);
	sqlite3ExprDelete(db, pExpr);
}


SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target) {
	if (pParse->okConstFactor && sqlite3ExprIsConstant(pExpr)) {
		sqlite3ExprCodeAtInit(pParse, pExpr, target, 0);
	}
	else {
		sqlite3ExprCode(pParse, pExpr, target);
	}
}


SQLITE_PRIVATE void sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target) {
	Vdbe *v = pParse->pVdbe;
	int iMem;

	assert(target>0);
	assert(pExpr->op != TK_REGISTER);
	sqlite3ExprCode(pParse, pExpr, target);
	iMem = ++pParse->nMem;
	sqlite3VdbeAddOp2(v, OP_Copy, target, iMem);
	exprToRegister(pExpr, iMem);
}


SQLITE_PRIVATE int sqlite3ExprCodeExprList(
	Parse *pParse,     
	ExprList *pList,   
	int target,        
	int srcReg,        
	u8 flags           
) {
	struct ExprList_item *pItem;
	int i, j, n;
	u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;
	Vdbe *v = pParse->pVdbe;
	assert(pList != 0);
	assert(target>0);
	assert(pParse->pVdbe != 0);  
	n = pList->nExpr;
	if (!ConstFactorOk(pParse)) flags &= ~SQLITE_ECEL_FACTOR;
	for (pItem = pList->a, i = 0; i<n; i++, pItem++) {
		Expr *pExpr = pItem->pExpr;
		if ((flags & SQLITE_ECEL_REF) != 0 && (j = pList->a[i].u.x.iOrderByCol)>0) {
			sqlite3VdbeAddOp2(v, copyOp, j + srcReg - 1, target + i);
		}
		else if ((flags & SQLITE_ECEL_FACTOR) != 0 && sqlite3ExprIsConstant(pExpr)) {
			sqlite3ExprCodeAtInit(pParse, pExpr, target + i, 0);
		}
		else {
			int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target + i);
			if (inReg != target + i) {
				VdbeOp *pOp;
				if (copyOp == OP_Copy
					&& (pOp = sqlite3VdbeGetOp(v, -1))->opcode == OP_Copy
					&& pOp->p1 + pOp->p3 + 1 == inReg
					&& pOp->p2 + pOp->p3 + 1 == target + i
					) {
					pOp->p3++;
				}
				else {
					sqlite3VdbeAddOp2(v, copyOp, inReg, target + i);
				}
			}
		}
	}
	return n;
}


static void exprCodeBetween(
	Parse *pParse,    
	Expr *pExpr,      
	int dest,         
	void(*xJump)(Parse*, Expr*, int, int), 
	int jumpIfNull    
) {
	Expr exprAnd;     
	Expr compLeft;    
	Expr compRight;   
	Expr exprX;       
	int regFree1 = 0; 


	memset(&compLeft, 0, sizeof(Expr));
	memset(&compRight, 0, sizeof(Expr));
	memset(&exprAnd, 0, sizeof(Expr));

	assert(!ExprHasProperty(pExpr, EP_xIsSelect));
	exprX = *pExpr->pLeft;
	exprAnd.op = TK_AND;
	exprAnd.pLeft = &compLeft;
	exprAnd.pRight = &compRight;
	compLeft.op = TK_GE;
	compLeft.pLeft = &exprX;
	compLeft.pRight = pExpr->x.pList->a[0].pExpr;
	compRight.op = TK_LE;
	compRight.pLeft = &exprX;
	compRight.pRight = pExpr->x.pList->a[1].pExpr;
	exprToRegister(&exprX, exprCodeVector(pParse, &exprX, &regFree1));
	if (xJump) {
		xJump(pParse, &exprAnd, dest, jumpIfNull);
	}
	else {
		exprX.flags |= EP_FromJoin;
		sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
	}
	sqlite3ReleaseTempReg(pParse, regFree1);

	
	testcase(xJump == sqlite3ExprIfTrue  && jumpIfNull == 0 && regFree1 == 0);
	testcase(xJump == sqlite3ExprIfTrue  && jumpIfNull == 0 && regFree1 != 0);
	testcase(xJump == sqlite3ExprIfTrue  && jumpIfNull != 0 && regFree1 == 0);
	testcase(xJump == sqlite3ExprIfTrue  && jumpIfNull != 0 && regFree1 != 0);
	testcase(xJump == sqlite3ExprIfFalse && jumpIfNull == 0 && regFree1 == 0);
	testcase(xJump == sqlite3ExprIfFalse && jumpIfNull == 0 && regFree1 != 0);
	testcase(xJump == sqlite3ExprIfFalse && jumpIfNull != 0 && regFree1 == 0);
	testcase(xJump == sqlite3ExprIfFalse && jumpIfNull != 0 && regFree1 != 0);
	testcase(xJump == 0);
}


SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull) {
	Vdbe *v = pParse->pVdbe;
	int op = 0;
	int regFree1 = 0;
	int regFree2 = 0;
	int r1, r2;

	assert(jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0);
	if (NEVER(v == 0))     return;  
	if (NEVER(pExpr == 0)) return;  
	op = pExpr->op;
	switch (op) {
	case TK_AND: {
		int d2 = sqlite3VdbeMakeLabel(v);
		testcase(jumpIfNull == 0);
		sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL);
		sqlite3ExprCachePush(pParse);
		sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
		sqlite3VdbeResolveLabel(v, d2);
		sqlite3ExprCachePop(pParse);
		break;
	}
	case TK_OR: {
		testcase(jumpIfNull == 0);
		sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
		sqlite3ExprCachePush(pParse);
		sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
		sqlite3ExprCachePop(pParse);
		break;
	}
	case TK_NOT: {
		testcase(jumpIfNull == 0);
		sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
		break;
	}
	case TK_IS:
	case TK_ISNOT:
		testcase(op == TK_IS);
		testcase(op == TK_ISNOT);
		op = (op == TK_IS) ? TK_EQ : TK_NE;
		jumpIfNull = SQLITE_NULLEQ;
		
	case TK_LT:
	case TK_LE:
	case TK_GT:
	case TK_GE:
	case TK_NE:
	case TK_EQ: {
		if (sqlite3ExprIsVector(pExpr->pLeft)) goto default_expr;
		testcase(jumpIfNull == 0);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
		codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
			r1, r2, dest, jumpIfNull);
		assert(TK_LT == OP_Lt); testcase(op == OP_Lt); VdbeCoverageIf(v, op == OP_Lt);
		assert(TK_LE == OP_Le); testcase(op == OP_Le); VdbeCoverageIf(v, op == OP_Le);
		assert(TK_GT == OP_Gt); testcase(op == OP_Gt); VdbeCoverageIf(v, op == OP_Gt);
		assert(TK_GE == OP_Ge); testcase(op == OP_Ge); VdbeCoverageIf(v, op == OP_Ge);
		assert(TK_EQ == OP_Eq); testcase(op == OP_Eq);
		VdbeCoverageIf(v, op == OP_Eq && jumpIfNull == SQLITE_NULLEQ);
		VdbeCoverageIf(v, op == OP_Eq && jumpIfNull != SQLITE_NULLEQ);
		assert(TK_NE == OP_Ne); testcase(op == OP_Ne);
		VdbeCoverageIf(v, op == OP_Ne && jumpIfNull == SQLITE_NULLEQ);
		VdbeCoverageIf(v, op == OP_Ne && jumpIfNull != SQLITE_NULLEQ);
		testcase(regFree1 == 0);
		testcase(regFree2 == 0);
		break;
	}
	case TK_ISNULL:
	case TK_NOTNULL: {
		assert(TK_ISNULL == OP_IsNull);   testcase(op == TK_ISNULL);
		assert(TK_NOTNULL == OP_NotNull); testcase(op == TK_NOTNULL);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		sqlite3VdbeAddOp2(v, op, r1, dest);
		VdbeCoverageIf(v, op == TK_ISNULL);
		VdbeCoverageIf(v, op == TK_NOTNULL);
		testcase(regFree1 == 0);
		break;
	}
	case TK_BETWEEN: {
		testcase(jumpIfNull == 0);
		exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);
		break;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_IN: {
		int destIfFalse = sqlite3VdbeMakeLabel(v);
		int destIfNull = jumpIfNull ? dest : destIfFalse;
		sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
		sqlite3VdbeGoto(v, dest);
		sqlite3VdbeResolveLabel(v, destIfFalse);
		break;
	}
#endif
	default: {
	default_expr:
		if (exprAlwaysTrue(pExpr)) {
			sqlite3VdbeGoto(v, dest);
		}
		else if (exprAlwaysFalse(pExpr)) {
			
		}
		else {
			r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
			sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull != 0);
			VdbeCoverage(v);
			testcase(regFree1 == 0);
			testcase(jumpIfNull == 0);
		}
		break;
	}
	}
	sqlite3ReleaseTempReg(pParse, regFree1);
	sqlite3ReleaseTempReg(pParse, regFree2);
}


SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull) {
	Vdbe *v = pParse->pVdbe;
	int op = 0;
	int regFree1 = 0;
	int regFree2 = 0;
	int r1, r2;

	assert(jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0);
	if (NEVER(v == 0)) return; 
	if (pExpr == 0)    return;

	
	op = ((pExpr->op + (TK_ISNULL & 1)) ^ 1) - (TK_ISNULL & 1);

	
	assert(pExpr->op != TK_ISNULL || op == OP_NotNull);
	assert(pExpr->op != TK_NOTNULL || op == OP_IsNull);
	assert(pExpr->op != TK_NE || op == OP_Eq);
	assert(pExpr->op != TK_EQ || op == OP_Ne);
	assert(pExpr->op != TK_LT || op == OP_Ge);
	assert(pExpr->op != TK_LE || op == OP_Gt);
	assert(pExpr->op != TK_GT || op == OP_Le);
	assert(pExpr->op != TK_GE || op == OP_Lt);

	switch (pExpr->op) {
	case TK_AND: {
		testcase(jumpIfNull == 0);
		sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
		sqlite3ExprCachePush(pParse);
		sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
		sqlite3ExprCachePop(pParse);
		break;
	}
	case TK_OR: {
		int d2 = sqlite3VdbeMakeLabel(v);
		testcase(jumpIfNull == 0);
		sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL);
		sqlite3ExprCachePush(pParse);
		sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
		sqlite3VdbeResolveLabel(v, d2);
		sqlite3ExprCachePop(pParse);
		break;
	}
	case TK_NOT: {
		testcase(jumpIfNull == 0);
		sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
		break;
	}
	case TK_IS:
	case TK_ISNOT:
		testcase(pExpr->op == TK_IS);
		testcase(pExpr->op == TK_ISNOT);
		op = (pExpr->op == TK_IS) ? TK_NE : TK_EQ;
		jumpIfNull = SQLITE_NULLEQ;
		
	case TK_LT:
	case TK_LE:
	case TK_GT:
	case TK_GE:
	case TK_NE:
	case TK_EQ: {
		if (sqlite3ExprIsVector(pExpr->pLeft)) goto default_expr;
		testcase(jumpIfNull == 0);
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
		codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
			r1, r2, dest, jumpIfNull);
		assert(TK_LT == OP_Lt); testcase(op == OP_Lt); VdbeCoverageIf(v, op == OP_Lt);
		assert(TK_LE == OP_Le); testcase(op == OP_Le); VdbeCoverageIf(v, op == OP_Le);
		assert(TK_GT == OP_Gt); testcase(op == OP_Gt); VdbeCoverageIf(v, op == OP_Gt);
		assert(TK_GE == OP_Ge); testcase(op == OP_Ge); VdbeCoverageIf(v, op == OP_Ge);
		assert(TK_EQ == OP_Eq); testcase(op == OP_Eq);
		VdbeCoverageIf(v, op == OP_Eq && jumpIfNull != SQLITE_NULLEQ);
		VdbeCoverageIf(v, op == OP_Eq && jumpIfNull == SQLITE_NULLEQ);
		assert(TK_NE == OP_Ne); testcase(op == OP_Ne);
		VdbeCoverageIf(v, op == OP_Ne && jumpIfNull != SQLITE_NULLEQ);
		VdbeCoverageIf(v, op == OP_Ne && jumpIfNull == SQLITE_NULLEQ);
		testcase(regFree1 == 0);
		testcase(regFree2 == 0);
		break;
	}
	case TK_ISNULL:
	case TK_NOTNULL: {
		r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
		sqlite3VdbeAddOp2(v, op, r1, dest);
		testcase(op == TK_ISNULL);   VdbeCoverageIf(v, op == TK_ISNULL);
		testcase(op == TK_NOTNULL);  VdbeCoverageIf(v, op == TK_NOTNULL);
		testcase(regFree1 == 0);
		break;
	}
	case TK_BETWEEN: {
		testcase(jumpIfNull == 0);
		exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);
		break;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_IN: {
		if (jumpIfNull) {
			sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
		}
		else {
			int destIfNull = sqlite3VdbeMakeLabel(v);
			sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
			sqlite3VdbeResolveLabel(v, destIfNull);
		}
		break;
	}
#endif
	default: {
	default_expr:
		if (exprAlwaysFalse(pExpr)) {
			sqlite3VdbeGoto(v, dest);
		}
		else if (exprAlwaysTrue(pExpr)) {
			
		}
		else {
			r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
			sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull != 0);
			VdbeCoverage(v);
			testcase(regFree1 == 0);
			testcase(jumpIfNull == 0);
		}
		break;
	}
	}
	sqlite3ReleaseTempReg(pParse, regFree1);
	sqlite3ReleaseTempReg(pParse, regFree2);
}


SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull) {
	sqlite3 *db = pParse->db;
	Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);
	if (db->mallocFailed == 0) {
		sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);
	}
	sqlite3ExprDelete(db, pCopy);
}



SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab) {
	u32 combinedFlags;
	if (pA == 0 || pB == 0) {
		return pB == pA ? 0 : 2;
	}
	combinedFlags = pA->flags | pB->flags;
	if (combinedFlags & EP_IntValue) {
		if ((pA->flags&pB->flags&EP_IntValue) != 0 && pA->u.iValue == pB->u.iValue) {
			return 0;
		}
		return 2;
	}
	if (pA->op != pB->op) {
		if (pA->op == TK_COLLATE && sqlite3ExprCompare(pA->pLeft, pB, iTab)<2) {
			return 1;
		}
		if (pB->op == TK_COLLATE && sqlite3ExprCompare(pA, pB->pLeft, iTab)<2) {
			return 1;
		}
		return 2;
	}
	if (pA->op != TK_COLUMN && pA->op != TK_AGG_COLUMN && pA->u.zToken) {
		if (pA->op == TK_FUNCTION) {
			if (sqlite3StrICmp(pA->u.zToken, pB->u.zToken) != 0) return 2;
		}
		else if (strcmp(pA->u.zToken, pB->u.zToken) != 0) {
			return pA->op == TK_COLLATE ? 1 : 2;
		}
	}
	if ((pA->flags & EP_Distinct) != (pB->flags & EP_Distinct)) return 2;
	if (ALWAYS((combinedFlags & EP_TokenOnly) == 0)) {
		if (combinedFlags & EP_xIsSelect) return 2;
		if (sqlite3ExprCompare(pA->pLeft, pB->pLeft, iTab)) return 2;
		if (sqlite3ExprCompare(pA->pRight, pB->pRight, iTab)) return 2;
		if (sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab)) return 2;
		if (ALWAYS((combinedFlags & EP_Reduced) == 0) && pA->op != TK_STRING) {
			if (pA->iColumn != pB->iColumn) return 2;
			if (pA->iTable != pB->iTable
				&& (pA->iTable != iTab || NEVER(pB->iTable >= 0))) return 2;
		}
	}
	return 0;
}


SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab) {
	int i;
	if (pA == 0 && pB == 0) return 0;
	if (pA == 0 || pB == 0) return 1;
	if (pA->nExpr != pB->nExpr) return 1;
	for (i = 0; i<pA->nExpr; i++) {
		Expr *pExprA = pA->a[i].pExpr;
		Expr *pExprB = pB->a[i].pExpr;
		if (pA->a[i].sortOrder != pB->a[i].sortOrder) return 1;
		if (sqlite3ExprCompare(pExprA, pExprB, iTab)) return 1;
	}
	return 0;
}


SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Expr *pE1, Expr *pE2, int iTab) {
	if (sqlite3ExprCompare(pE1, pE2, iTab) == 0) {
		return 1;
	}
	if (pE2->op == TK_OR
		&& (sqlite3ExprImpliesExpr(pE1, pE2->pLeft, iTab)
			|| sqlite3ExprImpliesExpr(pE1, pE2->pRight, iTab))
		) {
		return 1;
	}
	if (pE2->op == TK_NOTNULL
		&& sqlite3ExprCompare(pE1->pLeft, pE2->pLeft, iTab) == 0
		&& (pE1->op != TK_ISNULL && pE1->op != TK_IS)
		) {
		return 1;
	}
	return 0;
}


struct IdxCover {
	Index *pIdx;     
	int iCur;        
};


static int exprIdxCover(Walker *pWalker, Expr *pExpr) {
	if (pExpr->op == TK_COLUMN
		&& pExpr->iTable == pWalker->u.pIdxCover->iCur
		&& sqlite3ColumnOfIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0
		) {
		pWalker->eCode = 1;
		return WRC_Abort;
	}
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(
	Expr *pExpr,        
	int iCur,           
	Index *pIdx         
) {
	Walker w;
	struct IdxCover xcov;
	memset(&w, 0, sizeof(w));
	xcov.iCur = iCur;
	xcov.pIdx = pIdx;
	w.xExprCallback = exprIdxCover;
	w.u.pIdxCover = &xcov;
	sqlite3WalkExpr(&w, pExpr);
	return !w.eCode;
}



struct SrcCount {
	SrcList *pSrc;   
	int nThis;       
	int nOther;      
};


static int exprSrcCount(Walker *pWalker, Expr *pExpr) {
	
	if (pExpr->op == TK_COLUMN || NEVER(pExpr->op == TK_AGG_COLUMN)) {
		int i;
		struct SrcCount *p = pWalker->u.pSrcCount;
		SrcList *pSrc = p->pSrc;
		int nSrc = pSrc ? pSrc->nSrc : 0;
		for (i = 0; i<nSrc; i++) {
			if (pExpr->iTable == pSrc->a[i].iCursor) break;
		}
		if (i<nSrc) {
			p->nThis++;
		}
		else {
			p->nOther++;
		}
	}
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList) {
	Walker w;
	struct SrcCount cnt;
	assert(pExpr->op == TK_AGG_FUNCTION);
	memset(&w, 0, sizeof(w));
	w.xExprCallback = exprSrcCount;
	w.u.pSrcCount = &cnt;
	cnt.pSrc = pSrcList;
	cnt.nThis = 0;
	cnt.nOther = 0;
	sqlite3WalkExprList(&w, pExpr->x.pList);
	return cnt.nThis>0 || cnt.nOther == 0;
}


static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo) {
	int i;
	pInfo->aCol = sqlite3ArrayAllocate(
		db,
		pInfo->aCol,
		sizeof(pInfo->aCol[0]),
		&pInfo->nColumn,
		&i
	);
	return i;
}


static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo) {
	int i;
	pInfo->aFunc = sqlite3ArrayAllocate(
		db,
		pInfo->aFunc,
		sizeof(pInfo->aFunc[0]),
		&pInfo->nFunc,
		&i
	);
	return i;
}


static int analyzeAggregate(Walker *pWalker, Expr *pExpr) {
	int i;
	NameContext *pNC = pWalker->u.pNC;
	Parse *pParse = pNC->pParse;
	SrcList *pSrcList = pNC->pSrcList;
	AggInfo *pAggInfo = pNC->pAggInfo;

	switch (pExpr->op) {
	case TK_AGG_COLUMN:
	case TK_COLUMN: {
		testcase(pExpr->op == TK_AGG_COLUMN);
		testcase(pExpr->op == TK_COLUMN);
		
		if (ALWAYS(pSrcList != 0)) {
			struct SrcList_item *pItem = pSrcList->a;
			for (i = 0; i<pSrcList->nSrc; i++, pItem++) {
				struct AggInfo_col *pCol;
				assert(!ExprHasProperty(pExpr, EP_TokenOnly | EP_Reduced));
				if (pExpr->iTable == pItem->iCursor) {
					
					int k;
					pCol = pAggInfo->aCol;
					for (k = 0; k<pAggInfo->nColumn; k++, pCol++) {
						if (pCol->iTable == pExpr->iTable &&
							pCol->iColumn == pExpr->iColumn) {
							break;
						}
					}
					if ((k >= pAggInfo->nColumn)
						&& (k = addAggInfoColumn(pParse->db, pAggInfo)) >= 0
						) {
						pCol = &pAggInfo->aCol[k];
						pCol->pTab = pExpr->pTab;
						pCol->iTable = pExpr->iTable;
						pCol->iColumn = pExpr->iColumn;
						pCol->iMem = ++pParse->nMem;
						pCol->iSorterColumn = -1;
						pCol->pExpr = pExpr;
						if (pAggInfo->pGroupBy) {
							int j, n;
							ExprList *pGB = pAggInfo->pGroupBy;
							struct ExprList_item *pTerm = pGB->a;
							n = pGB->nExpr;
							for (j = 0; j<n; j++, pTerm++) {
								Expr *pE = pTerm->pExpr;
								if (pE->op == TK_COLUMN && pE->iTable == pExpr->iTable &&
									pE->iColumn == pExpr->iColumn) {
									pCol->iSorterColumn = j;
									break;
								}
							}
						}
						if (pCol->iSorterColumn<0) {
							pCol->iSorterColumn = pAggInfo->nSortingColumn++;
						}
					}
					
					ExprSetVVAProperty(pExpr, EP_NoReduce);
					pExpr->pAggInfo = pAggInfo;
					pExpr->op = TK_AGG_COLUMN;
					pExpr->iAgg = (i16)k;
					break;
				} 
			} 
		}
		return WRC_Prune;
	}
	case TK_AGG_FUNCTION: {
		if ((pNC->ncFlags & NC_InAggFunc) == 0
			&& pWalker->walkerDepth == pExpr->op2
			) {
			
			struct AggInfo_func *pItem = pAggInfo->aFunc;
			for (i = 0; i<pAggInfo->nFunc; i++, pItem++) {
				if (sqlite3ExprCompare(pItem->pExpr, pExpr, -1) == 0) {
					break;
				}
			}
			if (i >= pAggInfo->nFunc) {
				
				u8 enc = ENC(pParse->db);
				i = addAggInfoFunc(pParse->db, pAggInfo);
				if (i >= 0) {
					assert(!ExprHasProperty(pExpr, EP_xIsSelect));
					pItem = &pAggInfo->aFunc[i];
					pItem->pExpr = pExpr;
					pItem->iMem = ++pParse->nMem;
					assert(!ExprHasProperty(pExpr, EP_IntValue));
					pItem->pFunc = sqlite3FindFunction(pParse->db,
						pExpr->u.zToken,
						pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);
					if (pExpr->flags & EP_Distinct) {
						pItem->iDistinct = pParse->nTab++;
					}
					else {
						pItem->iDistinct = -1;
					}
				}
			}
			
			assert(!ExprHasProperty(pExpr, EP_TokenOnly | EP_Reduced));
			ExprSetVVAProperty(pExpr, EP_NoReduce);
			pExpr->iAgg = (i16)i;
			pExpr->pAggInfo = pAggInfo;
			return WRC_Prune;
		}
		else {
			return WRC_Continue;
		}
	}
	}
	return WRC_Continue;
}
static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect) {
	UNUSED_PARAMETER(pWalker);
	UNUSED_PARAMETER(pSelect);
	return WRC_Continue;
}


SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr) {
	Walker w;
	memset(&w, 0, sizeof(w));
	w.xExprCallback = analyzeAggregate;
	w.xSelectCallback = analyzeAggregatesInSelect;
	w.u.pNC = pNC;
	assert(pNC->pSrcList != 0);
	sqlite3WalkExpr(&w, pExpr);
}


SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList) {
	struct ExprList_item *pItem;
	int i;
	if (pList) {
		for (pItem = pList->a, i = 0; i<pList->nExpr; i++, pItem++) {
			sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
		}
	}
}


SQLITE_PRIVATE int sqlite3GetTempReg(Parse *pParse) {
	if (pParse->nTempReg == 0) {
		return ++pParse->nMem;
	}
	return pParse->aTempReg[--pParse->nTempReg];
}


SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse *pParse, int iReg) {
	if (iReg && pParse->nTempReg<ArraySize(pParse->aTempReg)) {
		int i;
		struct yColCache *p;
		for (i = 0, p = pParse->aColCache; i<pParse->nColCache; i++, p++) {
			if (p->iReg == iReg) {
				p->tempReg = 1;
				return;
			}
		}
		pParse->aTempReg[pParse->nTempReg++] = iReg;
	}
}


SQLITE_PRIVATE int sqlite3GetTempRange(Parse *pParse, int nReg) {
	int i, n;
	if (nReg == 1) return sqlite3GetTempReg(pParse);
	i = pParse->iRangeReg;
	n = pParse->nRangeReg;
	if (nReg <= n) {
		assert(!usedAsColumnCache(pParse, i, i + n - 1));
		pParse->iRangeReg += nReg;
		pParse->nRangeReg -= nReg;
	}
	else {
		i = pParse->nMem + 1;
		pParse->nMem += nReg;
	}
	return i;
}
SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg) {
	if (nReg == 1) {
		sqlite3ReleaseTempReg(pParse, iReg);
		return;
	}
	sqlite3ExprCacheRemove(pParse, iReg, nReg);
	if (nReg>pParse->nRangeReg) {
		pParse->nRangeReg = nReg;
		pParse->iRangeReg = iReg;
	}
}


SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse *pParse) {
	pParse->nTempReg = 0;
	pParse->nRangeReg = 0;
}


#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast) {
	int i;
	if (pParse->nRangeReg>0
		&& pParse->iRangeReg + pParse->nRangeReg<iLast
		&& pParse->iRangeReg >= iFirst
		) {
		return 0;
	}
	for (i = 0; i<pParse->nTempReg; i++) {
		if (pParse->aTempReg[i] >= iFirst && pParse->aTempReg[i] <= iLast) {
			return 0;
		}
	}
	return 1;
}
#endif 







#ifndef SQLITE_OMIT_ALTERTABLE



static void renameTableFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	unsigned char const *zSql = sqlite3_value_text(argv[0]);
	unsigned char const *zTableName = sqlite3_value_text(argv[1]);

	int token;
	Token tname;
	unsigned char const *zCsr = zSql;
	int len = 0;
	char *zRet;

	sqlite3 *db = sqlite3_context_db_handle(context);

	UNUSED_PARAMETER(NotUsed);

	
	if (zSql) {
		do {
			if (!*zCsr) {
				
				return;
			}

			
			tname.z = (char*)zCsr;
			tname.n = len;

			
			do {
				zCsr += len;
				len = sqlite3GetToken(zCsr, &token);
			} while (token == TK_SPACE);
			assert(len>0);
		} while (token != TK_LP && token != TK_USING);

		zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", (int)(((u8*)tname.z) - zSql),
			zSql, zTableName, tname.z + tname.n);
		sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);
	}
}


#ifndef SQLITE_OMIT_FOREIGN_KEY
static void renameParentFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	sqlite3 *db = sqlite3_context_db_handle(context);
	char *zOutput = 0;
	char *zResult;
	unsigned char const *zInput = sqlite3_value_text(argv[0]);
	unsigned char const *zOld = sqlite3_value_text(argv[1]);
	unsigned char const *zNew = sqlite3_value_text(argv[2]);

	unsigned const char *z;         
	int n;                          
	int token;                      

	UNUSED_PARAMETER(NotUsed);
	if (zInput == 0 || zOld == 0) return;
	for (z = zInput; *z; z = z + n) {
		n = sqlite3GetToken(z, &token);
		if (token == TK_REFERENCES) {
			char *zParent;
			do {
				z += n;
				n = sqlite3GetToken(z, &token);
			} while (token == TK_SPACE);

			if (token == TK_ILLEGAL) break;
			zParent = sqlite3DbStrNDup(db, (const char *)z, n);
			if (zParent == 0) break;
			sqlite3Dequote(zParent);
			if (0 == sqlite3StrICmp((const char *)zOld, zParent)) {
				char *zOut = sqlite3MPrintf(db, "%s%.*s\"%w\"",
					(zOutput ? zOutput : ""), (int)(z - zInput), zInput, (const char *)zNew
				);
				sqlite3DbFree(db, zOutput);
				zOutput = zOut;
				zInput = &z[n];
			}
			sqlite3DbFree(db, zParent);
		}
	}

	zResult = sqlite3MPrintf(db, "%s%s", (zOutput ? zOutput : ""), zInput),
		sqlite3_result_text(context, zResult, -1, SQLITE_DYNAMIC);
	sqlite3DbFree(db, zOutput);
}
#endif

#ifndef SQLITE_OMIT_TRIGGER

static void renameTriggerFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	unsigned char const *zSql = sqlite3_value_text(argv[0]);
	unsigned char const *zTableName = sqlite3_value_text(argv[1]);

	int token;
	Token tname;
	int dist = 3;
	unsigned char const *zCsr = zSql;
	int len = 0;
	char *zRet;
	sqlite3 *db = sqlite3_context_db_handle(context);

	UNUSED_PARAMETER(NotUsed);

	
	if (zSql) {
		do {

			if (!*zCsr) {
				
				return;
			}

			
			tname.z = (char*)zCsr;
			tname.n = len;

			
			do {
				zCsr += len;
				len = sqlite3GetToken(zCsr, &token);
			} while (token == TK_SPACE);
			assert(len>0);

			
			dist++;
			if (token == TK_DOT || token == TK_ON) {
				dist = 0;
			}
		} while (dist != 2 || (token != TK_WHEN && token != TK_FOR && token != TK_BEGIN));

		
		zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", (int)(((u8*)tname.z) - zSql),
			zSql, zTableName, tname.z + tname.n);
		sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);
	}
}
#endif   


SQLITE_PRIVATE void sqlite3AlterFunctions(void) {
	static FuncDef aAlterTableFuncs[] = {
		FUNCTION(sqlite_rename_table,   2, 0, 0, renameTableFunc),
#ifndef SQLITE_OMIT_TRIGGER
		FUNCTION(sqlite_rename_trigger, 2, 0, 0, renameTriggerFunc),
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
		FUNCTION(sqlite_rename_parent,  3, 0, 0, renameParentFunc),
#endif
	};
	sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ArraySize(aAlterTableFuncs));
}


static char *whereOrName(sqlite3 *db, char *zWhere, char *zConstant) {
	char *zNew;
	if (!zWhere) {
		zNew = sqlite3MPrintf(db, "name=%Q", zConstant);
	}
	else {
		zNew = sqlite3MPrintf(db, "%s OR name=%Q", zWhere, zConstant);
		sqlite3DbFree(db, zWhere);
	}
	return zNew;
}

#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)

static char *whereForeignKeys(Parse *pParse, Table *pTab) {
	FKey *p;
	char *zWhere = 0;
	for (p = sqlite3FkReferences(pTab); p; p = p->pNextTo) {
		zWhere = whereOrName(pParse->db, zWhere, p->pFrom->zName);
	}
	return zWhere;
}
#endif


static char *whereTempTriggers(Parse *pParse, Table *pTab) {
	Trigger *pTrig;
	char *zWhere = 0;
	const Schema *pTempSchema = pParse->db->aDb[1].pSchema; 

															
	if (pTab->pSchema != pTempSchema) {
		sqlite3 *db = pParse->db;
		for (pTrig = sqlite3TriggerList(pParse, pTab); pTrig; pTrig = pTrig->pNext) {
			if (pTrig->pSchema == pTempSchema) {
				zWhere = whereOrName(db, zWhere, pTrig->zName);
			}
		}
	}
	if (zWhere) {
		char *zNew = sqlite3MPrintf(pParse->db, "type='trigger' AND (%s)", zWhere);
		sqlite3DbFree(pParse->db, zWhere);
		zWhere = zNew;
	}
	return zWhere;
}


static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName) {
	Vdbe *v;
	char *zWhere;
	int iDb;                   
#ifndef SQLITE_OMIT_TRIGGER
	Trigger *pTrig;
#endif

	v = sqlite3GetVdbe(pParse);
	if (NEVER(v == 0)) return;
	assert(sqlite3BtreeHoldsAllMutexes(pParse->db));
	iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
	assert(iDb >= 0);

#ifndef SQLITE_OMIT_TRIGGER
	
	for (pTrig = sqlite3TriggerList(pParse, pTab); pTrig; pTrig = pTrig->pNext) {
		int iTrigDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
		assert(iTrigDb == iDb || iTrigDb == 1);
		sqlite3VdbeAddOp4(v, OP_DropTrigger, iTrigDb, 0, 0, pTrig->zName, 0);
	}
#endif

	
	sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);

	
	zWhere = sqlite3MPrintf(pParse->db, "tbl_name=%Q", zName);
	if (!zWhere) return;
	sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);

#ifndef SQLITE_OMIT_TRIGGER
	
	if ((zWhere = whereTempTriggers(pParse, pTab)) != 0) {
		sqlite3VdbeAddParseSchemaOp(v, 1, zWhere);
	}
#endif
}


static int isSystemTable(Parse *pParse, const char *zName) {
	if (sqlite3Strlen30(zName)>6 && 0 == sqlite3StrNICmp(zName, "sqlite_", 7)) {
		sqlite3ErrorMsg(pParse, "table %s may not be altered", zName);
		return 1;
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3AlterRenameTable(
	Parse *pParse,            
	SrcList *pSrc,            
	Token *pName              
) {
	int iDb;                  
	char *zDb;                
	Table *pTab;              
	char *zName = 0;          
	sqlite3 *db = pParse->db; 
	int nTabName;             
	const char *zTabName;     
	Vdbe *v;
#ifndef SQLITE_OMIT_TRIGGER
	char *zWhere = 0;         
#endif
	VTable *pVTab = 0;        
	int savedDbFlags;         

	savedDbFlags = db->flags;
	if (NEVER(db->mallocFailed)) goto exit_rename_table;
	assert(pSrc->nSrc == 1);
	assert(sqlite3BtreeHoldsAllMutexes(pParse->db));

	pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
	if (!pTab) goto exit_rename_table;
	iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
	zDb = db->aDb[iDb].zDbSName;
	db->flags |= SQLITE_PreferBuiltin;

	
	zName = sqlite3NameFromToken(db, pName);
	if (!zName) goto exit_rename_table;

	
	if (sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb)) {
		sqlite3ErrorMsg(pParse,
			"there is already another table or index with this name: %s", zName);
		goto exit_rename_table;
	}

	
	if (SQLITE_OK != isSystemTable(pParse, pTab->zName)) {
		goto exit_rename_table;
	}
	if (SQLITE_OK != sqlite3CheckObjectName(pParse, zName)) {
		goto
			exit_rename_table;
	}

#ifndef SQLITE_OMIT_VIEW
	if (pTab->pSelect) {
		sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
		goto exit_rename_table;
	}
#endif

#ifndef SQLITE_OMIT_AUTHORIZATION
	
	if (sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0)) {
		goto exit_rename_table;
	}
#endif

#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (sqlite3ViewGetColumnNames(pParse, pTab)) {
		goto exit_rename_table;
	}
	if (IsVirtual(pTab)) {
		pVTab = sqlite3GetVTable(db, pTab);
		if (pVTab->pVtab->pModule->xRename == 0) {
			pVTab = 0;
		}
	}
#endif

	
	v = sqlite3GetVdbe(pParse);
	if (v == 0) {
		goto exit_rename_table;
	}
	sqlite3BeginWriteOperation(pParse, pVTab != 0, iDb);
	sqlite3ChangeCookie(pParse, iDb);

	
#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (pVTab) {
		int i = ++pParse->nMem;
		sqlite3VdbeLoadString(v, i, zName);
		sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0, (const char*)pVTab, P4_VTAB);
		sqlite3MayAbort(pParse);
	}
#endif

	
	zTabName = pTab->zName;
	nTabName = sqlite3Utf8CharLen(zTabName, -1);

#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
	if (db->flags&SQLITE_ForeignKeys) {
		
		if ((zWhere = whereForeignKeys(pParse, pTab)) != 0) {
			sqlite3NestedParse(pParse,
				"UPDATE \"%w\".%s SET "
				"sql = sqlite_rename_parent(sql, %Q, %Q) "
				"WHERE %s;", zDb, SCHEMA_TABLE(iDb), zTabName, zName, zWhere);
			sqlite3DbFree(db, zWhere);
		}
	}
#endif

	
	sqlite3NestedParse(pParse,
		"UPDATE %Q.%s SET "
#ifdef SQLITE_OMIT_TRIGGER
		"sql = sqlite_rename_table(sql, %Q), "
#else
		"sql = CASE "
		"WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"
		"ELSE sqlite_rename_table(sql, %Q) END, "
#endif
		"tbl_name = %Q, "
		"name = CASE "
		"WHEN type='table' THEN %Q "
		"WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "
		"'sqlite_autoindex_' || %Q || substr(name,%d+18) "
		"ELSE name END "
		"WHERE tbl_name=%Q COLLATE nocase AND "
		"(type='table' OR type='index' OR type='trigger');",
		zDb, SCHEMA_TABLE(iDb), zName, zName, zName,
#ifndef SQLITE_OMIT_TRIGGER
		zName,
#endif
		zName, nTabName, zTabName
	);

#ifndef SQLITE_OMIT_AUTOINCREMENT
	
	if (sqlite3FindTable(db, "sqlite_sequence", zDb)) {
		sqlite3NestedParse(pParse,
			"UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
			zDb, zName, pTab->zName);
	}
#endif

#ifndef SQLITE_OMIT_TRIGGER
	
	if ((zWhere = whereTempTriggers(pParse, pTab)) != 0) {
		sqlite3NestedParse(pParse,
			"UPDATE sqlite_temp_master SET "
			"sql = sqlite_rename_trigger(sql, %Q), "
			"tbl_name = %Q "
			"WHERE %s;", zName, zName, zWhere);
		sqlite3DbFree(db, zWhere);
	}
#endif

#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
	if (db->flags&SQLITE_ForeignKeys) {
		FKey *p;
		for (p = sqlite3FkReferences(pTab); p; p = p->pNextTo) {
			Table *pFrom = p->pFrom;
			if (pFrom != pTab) {
				reloadTableSchema(pParse, p->pFrom, pFrom->zName);
			}
		}
	}
#endif

	
	reloadTableSchema(pParse, pTab, zName);

exit_rename_table:
	sqlite3SrcListDelete(db, pSrc);
	sqlite3DbFree(db, zName);
	db->flags = savedDbFlags;
}


SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef) {
	Table *pNew;              
	Table *pTab;              
	int iDb;                  
	const char *zDb;          
	const char *zTab;         
	char *zCol;               
	Column *pCol;             
	Expr *pDflt;              
	sqlite3 *db;              
	Vdbe *v = pParse->pVdbe;  
	int r1;                   

	db = pParse->db;
	if (pParse->nErr || db->mallocFailed) return;
	assert(v != 0);
	pNew = pParse->pNewTable;
	assert(pNew);

	assert(sqlite3BtreeHoldsAllMutexes(db));
	iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
	zDb = db->aDb[iDb].zDbSName;
	zTab = &pNew->zName[16];  
	pCol = &pNew->aCol[pNew->nCol - 1];
	pDflt = pCol->pDflt;
	pTab = sqlite3FindTable(db, zTab, zDb);
	assert(pTab);

#ifndef SQLITE_OMIT_AUTHORIZATION
	
	if (sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0)) {
		return;
	}
#endif

	
	assert(pDflt == 0 || pDflt->op == TK_SPAN);
	if (pDflt && pDflt->pLeft->op == TK_NULL) {
		pDflt = 0;
	}

	
	if (pCol->colFlags & COLFLAG_PRIMKEY) {
		sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
		return;
	}
	if (pNew->pIndex) {
		sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
		return;
	}
	if ((db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt) {
		sqlite3ErrorMsg(pParse,
			"Cannot add a REFERENCES column with non-NULL default value");
		return;
	}
	if (pCol->notNull && !pDflt) {
		sqlite3ErrorMsg(pParse,
			"Cannot add a NOT NULL column with default value NULL");
		return;
	}

	
	if (pDflt) {
		sqlite3_value *pVal = 0;
		int rc;
		rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);
		assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
		if (rc != SQLITE_OK) {
			assert(db->mallocFailed == 1);
			return;
		}
		if (!pVal) {
			sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
			return;
		}
		sqlite3ValueFree(pVal);
	}

	
	zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);
	if (zCol) {
		char *zEnd = &zCol[pColDef->n - 1];
		int savedDbFlags = db->flags;
		while (zEnd>zCol && (*zEnd == ';' || sqlite3Isspace(*zEnd))) {
			*zEnd-- = '\0';
		}
		db->flags |= SQLITE_PreferBuiltin;
		sqlite3NestedParse(pParse,
			"UPDATE \"%w\".%s SET "
			"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "
			"WHERE type = 'table' AND name = %Q",
			zDb, SCHEMA_TABLE(iDb), pNew->addColOffset, zCol, pNew->addColOffset + 1,
			zTab
		);
		sqlite3DbFree(db, zCol);
		db->flags = savedDbFlags;
	}

	
	r1 = sqlite3GetTempReg(pParse);
	sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);
	sqlite3VdbeUsesBtree(v, iDb);
	sqlite3VdbeAddOp2(v, OP_AddImm, r1, -2);
	sqlite3VdbeAddOp2(v, OP_IfPos, r1, sqlite3VdbeCurrentAddr(v) + 2);
	VdbeCoverage(v);
	sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, 3);
	sqlite3ReleaseTempReg(pParse, r1);

	
	reloadTableSchema(pParse, pTab, pTab->zName);
}


SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc) {
	Table *pNew;
	Table *pTab;
	Vdbe *v;
	int iDb;
	int i;
	int nAlloc;
	sqlite3 *db = pParse->db;

	
	assert(pParse->pNewTable == 0);
	assert(sqlite3BtreeHoldsAllMutexes(db));
	if (db->mallocFailed) goto exit_begin_add_column;
	pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
	if (!pTab) goto exit_begin_add_column;

#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (IsVirtual(pTab)) {
		sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
		goto exit_begin_add_column;
	}
#endif

	
	if (pTab->pSelect) {
		sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
		goto exit_begin_add_column;
	}
	if (SQLITE_OK != isSystemTable(pParse, pTab->zName)) {
		goto exit_begin_add_column;
	}

	assert(pTab->addColOffset>0);
	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);

	
	pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));
	if (!pNew) goto exit_begin_add_column;
	pParse->pNewTable = pNew;
	pNew->nRef = 1;
	pNew->nCol = pTab->nCol;
	assert(pNew->nCol>0);
	nAlloc = (((pNew->nCol - 1) / 8) * 8) + 8;
	assert(nAlloc >= pNew->nCol && nAlloc % 8 == 0 && nAlloc - pNew->nCol<8);
	pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);
	pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
	if (!pNew->aCol || !pNew->zName) {
		assert(db->mallocFailed);
		goto exit_begin_add_column;
	}
	memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
	for (i = 0; i<pNew->nCol; i++) {
		Column *pCol = &pNew->aCol[i];
		pCol->zName = sqlite3DbStrDup(db, pCol->zName);
		pCol->zColl = 0;
		pCol->pDflt = 0;
	}
	pNew->pSchema = db->aDb[iDb].pSchema;
	pNew->addColOffset = pTab->addColOffset;
	pNew->nRef = 1;

	
	sqlite3BeginWriteOperation(pParse, 0, iDb);
	v = sqlite3GetVdbe(pParse);
	if (!v) goto exit_begin_add_column;
	sqlite3ChangeCookie(pParse, iDb);

exit_begin_add_column:
	sqlite3SrcListDelete(db, pSrc);
	return;
}
#endif  




#ifndef SQLITE_OMIT_ANALYZE


#if defined(SQLITE_ENABLE_STAT4)
# define IsStat4     1
# define IsStat3     0
#elif defined(SQLITE_ENABLE_STAT3)
# define IsStat4     0
# define IsStat3     1
#else
# define IsStat4     0
# define IsStat3     0
# undef SQLITE_STAT4_SAMPLES
# define SQLITE_STAT4_SAMPLES 1
#endif
#define IsStat34    (IsStat3+IsStat4)  


static void openStatTable(
	Parse *pParse,          
	int iDb,                
	int iStatCur,           
	const char *zWhere,     
	const char *zWhereType  
) {
	static const struct {
		const char *zName;
		const char *zCols;
	} aTable[] = {
		{ "sqlite_stat1", "tbl,idx,stat" },
#if defined(SQLITE_ENABLE_STAT4)
		{ "sqlite_stat4", "tbl,idx,neq,nlt,ndlt,sample" },
		{ "sqlite_stat3", 0 },
#elif defined(SQLITE_ENABLE_STAT3)
		{ "sqlite_stat3", "tbl,idx,neq,nlt,ndlt,sample" },
		{ "sqlite_stat4", 0 },
#else
		{ "sqlite_stat3", 0 },
		{ "sqlite_stat4", 0 },
#endif
	};
	int i;
	sqlite3 *db = pParse->db;
	Db *pDb;
	Vdbe *v = sqlite3GetVdbe(pParse);
	int aRoot[ArraySize(aTable)];
	u8 aCreateTbl[ArraySize(aTable)];

	if (v == 0) return;
	assert(sqlite3BtreeHoldsAllMutexes(db));
	assert(sqlite3VdbeDb(v) == db);
	pDb = &db->aDb[iDb];

	
	for (i = 0; i<ArraySize(aTable); i++) {
		const char *zTab = aTable[i].zName;
		Table *pStat;
		if ((pStat = sqlite3FindTable(db, zTab, pDb->zDbSName)) == 0) {
			if (aTable[i].zCols) {
				
				sqlite3NestedParse(pParse,
					"CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab, aTable[i].zCols
				);
				aRoot[i] = pParse->regRoot;
				aCreateTbl[i] = OPFLAG_P2ISREG;
			}
		}
		else {
			
			aRoot[i] = pStat->tnum;
			aCreateTbl[i] = 0;
			sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
			if (zWhere) {
				sqlite3NestedParse(pParse,
					"DELETE FROM %Q.%s WHERE %s=%Q",
					pDb->zDbSName, zTab, zWhereType, zWhere
				);
			}
			else {
				
				sqlite3VdbeAddOp2(v, OP_Clear, aRoot[i], iDb);
			}
		}
	}

	
	for (i = 0; aTable[i].zCols; i++) {
		assert(i<ArraySize(aTable));
		sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur + i, aRoot[i], iDb, 3);
		sqlite3VdbeChangeP5(v, aCreateTbl[i]);
		VdbeComment((v, aTable[i].zName));
	}
}


#ifndef SQLITE_STAT4_SAMPLES
# define SQLITE_STAT4_SAMPLES 24
#endif


typedef struct Stat4Accum Stat4Accum;
typedef struct Stat4Sample Stat4Sample;
struct Stat4Sample {
	tRowcnt *anEq;                  
	tRowcnt *anDLt;                 
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	tRowcnt *anLt;                  
	union {
		i64 iRowid;                     
		u8 *aRowid;                     
	} u;
	u32 nRowid;                     
	u8 isPSample;                   
	int iCol;                       
	u32 iHash;                      
#endif
};
struct Stat4Accum {
	tRowcnt nRow;             
	tRowcnt nPSample;         
	int nCol;                 
	int nKeyCol;              
	int mxSample;             
	Stat4Sample current;      
	u32 iPrn;                 
	Stat4Sample *aBest;       
	int iMin;                 
	int nSample;              
	int iGet;                 
	Stat4Sample *a;           
	sqlite3 *db;              
};


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
static void sampleClear(sqlite3 *db, Stat4Sample *p) {
	assert(db != 0);
	if (p->nRowid) {
		sqlite3DbFree(db, p->u.aRowid);
		p->nRowid = 0;
	}
}
#endif


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
static void sampleSetRowid(sqlite3 *db, Stat4Sample *p, int n, const u8 *pData) {
	assert(db != 0);
	if (p->nRowid) sqlite3DbFree(db, p->u.aRowid);
	p->u.aRowid = sqlite3DbMallocRawNN(db, n);
	if (p->u.aRowid) {
		p->nRowid = n;
		memcpy(p->u.aRowid, pData, n);
	}
	else {
		p->nRowid = 0;
	}
}
#endif


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
static void sampleSetRowidInt64(sqlite3 *db, Stat4Sample *p, i64 iRowid) {
	assert(db != 0);
	if (p->nRowid) sqlite3DbFree(db, p->u.aRowid);
	p->nRowid = 0;
	p->u.iRowid = iRowid;
}
#endif



#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
static void sampleCopy(Stat4Accum *p, Stat4Sample *pTo, Stat4Sample *pFrom) {
	pTo->isPSample = pFrom->isPSample;
	pTo->iCol = pFrom->iCol;
	pTo->iHash = pFrom->iHash;
	memcpy(pTo->anEq, pFrom->anEq, sizeof(tRowcnt)*p->nCol);
	memcpy(pTo->anLt, pFrom->anLt, sizeof(tRowcnt)*p->nCol);
	memcpy(pTo->anDLt, pFrom->anDLt, sizeof(tRowcnt)*p->nCol);
	if (pFrom->nRowid) {
		sampleSetRowid(p->db, pTo, pFrom->nRowid, pFrom->u.aRowid);
	}
	else {
		sampleSetRowidInt64(p->db, pTo, pFrom->u.iRowid);
	}
}
#endif


static void stat4Destructor(void *pOld) {
	Stat4Accum *p = (Stat4Accum*)pOld;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	int i;
	for (i = 0; i<p->nCol; i++) sampleClear(p->db, p->aBest + i);
	for (i = 0; i<p->mxSample; i++) sampleClear(p->db, p->a + i);
	sampleClear(p->db, &p->current);
#endif
	sqlite3DbFree(p->db, p);
}


static void statInit(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	Stat4Accum *p;
	int nCol;                       
	int nKeyCol;                    
	int nColUp;                     
	int n;                          
	sqlite3 *db;                    
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	int mxSample = SQLITE_STAT4_SAMPLES;
#endif

	
	UNUSED_PARAMETER(argc);
	nCol = sqlite3_value_int(argv[0]);
	assert(nCol>0);
	nColUp = sizeof(tRowcnt)<8 ? (nCol + 1)&~1 : nCol;
	nKeyCol = sqlite3_value_int(argv[1]);
	assert(nKeyCol <= nCol);
	assert(nKeyCol>0);

	
	n = sizeof(*p)
		+ sizeof(tRowcnt)*nColUp                  
		+ sizeof(tRowcnt)*nColUp                  
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		+ sizeof(tRowcnt)*nColUp                  
		+ sizeof(Stat4Sample)*(nCol + mxSample)     
		+ sizeof(tRowcnt) * 3 * nColUp*(nCol + mxSample)
#endif
		;
	db = sqlite3_context_db_handle(context);
	p = sqlite3DbMallocZero(db, n);
	if (p == 0) {
		sqlite3_result_error_nomem(context);
		return;
	}

	p->db = db;
	p->nRow = 0;
	p->nCol = nCol;
	p->nKeyCol = nKeyCol;
	p->current.anDLt = (tRowcnt*)&p[1];
	p->current.anEq = &p->current.anDLt[nColUp];

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	{
		u8 *pSpace;                     
		int i;                          

		p->iGet = -1;
		p->mxSample = mxSample;
		p->nPSample = (tRowcnt)(sqlite3_value_int64(argv[2]) / (mxSample / 3 + 1) + 1);
		p->current.anLt = &p->current.anEq[nColUp];
		p->iPrn = 0x689e962d * (u32)nCol ^ 0xd0944565 * (u32)sqlite3_value_int(argv[2]);

		
		p->a = (struct Stat4Sample*)&p->current.anLt[nColUp];
		p->aBest = &p->a[mxSample];
		pSpace = (u8*)(&p->a[mxSample + nCol]);
		for (i = 0; i<(mxSample + nCol); i++) {
			p->a[i].anEq = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);
			p->a[i].anLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);
			p->a[i].anDLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);
		}
		assert((pSpace - (u8*)p) == n);

		for (i = 0; i<nCol; i++) {
			p->aBest[i].iCol = i;
		}
	}
#endif

	
	sqlite3_result_blob(context, p, sizeof(*p), stat4Destructor);
}
static const FuncDef statInitFuncdef = {
	2 + IsStat34,      
	SQLITE_UTF8,     
	0,               
	0,               
	statInit,        
	0,               
	"stat_init",     
	{ 0 }
};

#ifdef SQLITE_ENABLE_STAT4

static int sampleIsBetterPost(
	Stat4Accum *pAccum,
	Stat4Sample *pNew,
	Stat4Sample *pOld
) {
	int nCol = pAccum->nCol;
	int i;
	assert(pNew->iCol == pOld->iCol);
	for (i = pNew->iCol + 1; i<nCol; i++) {
		if (pNew->anEq[i]>pOld->anEq[i]) return 1;
		if (pNew->anEq[i]<pOld->anEq[i]) return 0;
	}
	if (pNew->iHash>pOld->iHash) return 1;
	return 0;
}
#endif

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static int sampleIsBetter(
	Stat4Accum *pAccum,
	Stat4Sample *pNew,
	Stat4Sample *pOld
) {
	tRowcnt nEqNew = pNew->anEq[pNew->iCol];
	tRowcnt nEqOld = pOld->anEq[pOld->iCol];

	assert(pOld->isPSample == 0 && pNew->isPSample == 0);
	assert(IsStat4 || (pNew->iCol == 0 && pOld->iCol == 0));

	if ((nEqNew>nEqOld)) return 1;
#ifdef SQLITE_ENABLE_STAT4
	if (nEqNew == nEqOld) {
		if (pNew->iCol<pOld->iCol) return 1;
		return (pNew->iCol == pOld->iCol && sampleIsBetterPost(pAccum, pNew, pOld));
	}
	return 0;
#else
	return (nEqNew == nEqOld && pNew->iHash>pOld->iHash);
#endif
}


static void sampleInsert(Stat4Accum *p, Stat4Sample *pNew, int nEqZero) {
	Stat4Sample *pSample = 0;
	int i;

	assert(IsStat4 || nEqZero == 0);

#ifdef SQLITE_ENABLE_STAT4
	if (pNew->isPSample == 0) {
		Stat4Sample *pUpgrade = 0;
		assert(pNew->anEq[pNew->iCol]>0);

		
		for (i = p->nSample - 1; i >= 0; i--) {
			Stat4Sample *pOld = &p->a[i];
			if (pOld->anEq[pNew->iCol] == 0) {
				if (pOld->isPSample) return;
				assert(pOld->iCol>pNew->iCol);
				assert(sampleIsBetter(p, pNew, pOld));
				if (pUpgrade == 0 || sampleIsBetter(p, pOld, pUpgrade)) {
					pUpgrade = pOld;
				}
			}
		}
		if (pUpgrade) {
			pUpgrade->iCol = pNew->iCol;
			pUpgrade->anEq[pUpgrade->iCol] = pNew->anEq[pUpgrade->iCol];
			goto find_new_min;
		}
	}
#endif

	
	if (p->nSample >= p->mxSample) {
		Stat4Sample *pMin = &p->a[p->iMin];
		tRowcnt *anEq = pMin->anEq;
		tRowcnt *anLt = pMin->anLt;
		tRowcnt *anDLt = pMin->anDLt;
		sampleClear(p->db, pMin);
		memmove(pMin, &pMin[1], sizeof(p->a[0])*(p->nSample - p->iMin - 1));
		pSample = &p->a[p->nSample - 1];
		pSample->nRowid = 0;
		pSample->anEq = anEq;
		pSample->anDLt = anDLt;
		pSample->anLt = anLt;
		p->nSample = p->mxSample - 1;
	}

	
#ifdef SQLITE_ENABLE_STAT4
	assert(p->nSample == 0
		|| pNew->anLt[p->nCol - 1] > p->a[p->nSample - 1].anLt[p->nCol - 1]);
#endif

	
	pSample = &p->a[p->nSample];
	sampleCopy(p, pSample, pNew);
	p->nSample++;

	
	memset(pSample->anEq, 0, sizeof(tRowcnt)*nEqZero);

#ifdef SQLITE_ENABLE_STAT4
	find_new_min :
#endif
				 if (p->nSample >= p->mxSample) {
					 int iMin = -1;
					 for (i = 0; i<p->mxSample; i++) {
						 if (p->a[i].isPSample) continue;
						 if (iMin<0 || sampleIsBetter(p, &p->a[iMin], &p->a[i])) {
							 iMin = i;
						 }
					 }
					 assert(iMin >= 0);
					 p->iMin = iMin;
				 }
}
#endif 


static void samplePushPrevious(Stat4Accum *p, int iChng) {
#ifdef SQLITE_ENABLE_STAT4
	int i;

	
	for (i = (p->nCol - 2); i >= iChng; i--) {
		Stat4Sample *pBest = &p->aBest[i];
		pBest->anEq[i] = p->current.anEq[i];
		if (p->nSample<p->mxSample || sampleIsBetter(p, pBest, &p->a[p->iMin])) {
			sampleInsert(p, pBest, i);
		}
	}

	
	for (i = p->nSample - 1; i >= 0; i--) {
		int j;
		for (j = iChng; j<p->nCol; j++) {
			if (p->a[i].anEq[j] == 0) p->a[i].anEq[j] = p->current.anEq[j];
		}
	}
#endif

#if defined(SQLITE_ENABLE_STAT3) && !defined(SQLITE_ENABLE_STAT4)
	if (iChng == 0) {
		tRowcnt nLt = p->current.anLt[0];
		tRowcnt nEq = p->current.anEq[0];

		
		if ((nLt / p->nPSample) != (nLt + nEq) / p->nPSample) {
			p->current.isPSample = 1;
			sampleInsert(p, &p->current, 0);
			p->current.isPSample = 0;
		}
		else

			
			if (p->nSample<p->mxSample
				|| sampleIsBetter(p, &p->current, &p->a[p->iMin])
				) {
				sampleInsert(p, &p->current, 0);
			}
	}
#endif

#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
	UNUSED_PARAMETER(p);
	UNUSED_PARAMETER(iChng);
#endif
}


static void statPush(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int i;

	
	Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);
	int iChng = sqlite3_value_int(argv[1]);

	UNUSED_PARAMETER(argc);
	UNUSED_PARAMETER(context);
	assert(p->nCol>0);
	assert(iChng<p->nCol);

	if (p->nRow == 0) {
		
		for (i = 0; i<p->nCol; i++) p->current.anEq[i] = 1;
	}
	else {
		
		samplePushPrevious(p, iChng);

		
		for (i = 0; i<iChng; i++) {
			p->current.anEq[i]++;
		}
		for (i = iChng; i<p->nCol; i++) {
			p->current.anDLt[i]++;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
			p->current.anLt[i] += p->current.anEq[i];
#endif
			p->current.anEq[i] = 1;
		}
	}
	p->nRow++;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (sqlite3_value_type(argv[2]) == SQLITE_INTEGER) {
		sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));
	}
	else {
		sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),
			sqlite3_value_blob(argv[2]));
	}
	p->current.iHash = p->iPrn = p->iPrn * 1103515245 + 12345;
#endif

#ifdef SQLITE_ENABLE_STAT4
	{
		tRowcnt nLt = p->current.anLt[p->nCol - 1];

		
		if ((nLt / p->nPSample) != (nLt + 1) / p->nPSample) {
			p->current.isPSample = 1;
			p->current.iCol = 0;
			sampleInsert(p, &p->current, p->nCol - 1);
			p->current.isPSample = 0;
		}

		
		for (i = 0; i<(p->nCol - 1); i++) {
			p->current.iCol = i;
			if (i >= iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i])) {
				sampleCopy(p, &p->aBest[i], &p->current);
			}
		}
	}
#endif
}
static const FuncDef statPushFuncdef = {
	2 + IsStat34,      
	SQLITE_UTF8,     
	0,               
	0,               
	statPush,        
	0,               
	"stat_push",     
	{ 0 }
};

#define STAT_GET_STAT1 0          
#define STAT_GET_ROWID 1          
#define STAT_GET_NEQ   2          
#define STAT_GET_NLT   3          
#define STAT_GET_NDLT  4          


static void statGet(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	
	int eCall = sqlite3_value_int(argv[1]);
	assert(argc == 2);
	assert(eCall == STAT_GET_STAT1 || eCall == STAT_GET_NEQ
		|| eCall == STAT_GET_ROWID || eCall == STAT_GET_NLT
		|| eCall == STAT_GET_NDLT
	);
	if (eCall == STAT_GET_STAT1)
#else
	assert(argc == 1);
#endif
	{
		
		char *z;
		int i;

		char *zRet = sqlite3MallocZero((p->nKeyCol + 1) * 25);
		if (zRet == 0) {
			sqlite3_result_error_nomem(context);
			return;
		}

		sqlite3_snprintf(24, zRet, "%llu", (u64)p->nRow);
		z = zRet + sqlite3Strlen30(zRet);
		for (i = 0; i<p->nKeyCol; i++) {
			u64 nDistinct = p->current.anDLt[i] + 1;
			u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;
			sqlite3_snprintf(24, z, " %llu", iVal);
			z += sqlite3Strlen30(z);
			assert(p->current.anEq[i]);
		}
		assert(z[0] == '\0' && z>zRet);

		sqlite3_result_text(context, zRet, -1, sqlite3_free);
	}
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
   else if (eCall == STAT_GET_ROWID) {
	   if (p->iGet<0) {
		   samplePushPrevious(p, 0);
		   p->iGet = 0;
	   }
	   if (p->iGet<p->nSample) {
		   Stat4Sample *pS = p->a + p->iGet;
		   if (pS->nRowid == 0) {
			   sqlite3_result_int64(context, pS->u.iRowid);
		   }
		   else {
			   sqlite3_result_blob(context, pS->u.aRowid, pS->nRowid,
				   SQLITE_TRANSIENT);
		   }
	   }
   }
   else {
	   tRowcnt *aCnt = 0;

	   assert(p->iGet<p->nSample);
	   switch (eCall) {
	   case STAT_GET_NEQ:  aCnt = p->a[p->iGet].anEq; break;
	   case STAT_GET_NLT:  aCnt = p->a[p->iGet].anLt; break;
	   default: {
		   aCnt = p->a[p->iGet].anDLt;
		   p->iGet++;
		   break;
	   }
	   }

	   if (IsStat3) {
		   sqlite3_result_int64(context, (i64)aCnt[0]);
	   }
	   else {
		   char *zRet = sqlite3MallocZero(p->nCol * 25);
		   if (zRet == 0) {
			   sqlite3_result_error_nomem(context);
		   }
		   else {
			   int i;
			   char *z = zRet;
			   for (i = 0; i<p->nCol; i++) {
				   sqlite3_snprintf(24, z, "%llu ", (u64)aCnt[i]);
				   z += sqlite3Strlen30(z);
			   }
			   assert(z[0] == '\0' && z>zRet);
			   z[-1] = '\0';
			   sqlite3_result_text(context, zRet, -1, sqlite3_free);
		   }
	   }
   }
#endif 
#ifndef SQLITE_DEBUG
   UNUSED_PARAMETER(argc);
#endif
}
static const FuncDef statGetFuncdef = {
	1 + IsStat34,      
	SQLITE_UTF8,     
	0,               
	0,               
	statGet,         
	0,               
	"stat_get",      
	{ 0 }
};

static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut) {
	assert(regOut != regStat4 && regOut != regStat4 + 1);
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	sqlite3VdbeAddOp2(v, OP_Integer, iParam, regStat4 + 1);
#elif SQLITE_DEBUG
	assert(iParam == STAT_GET_STAT1);
#else
	UNUSED_PARAMETER(iParam);
#endif
	sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4, regOut,
		(char*)&statGetFuncdef, P4_FUNCDEF);
	sqlite3VdbeChangeP5(v, 1 + IsStat34);
}


static void analyzeOneTable(
	Parse *pParse,   
	Table *pTab,     
	Index *pOnlyIdx, 
	int iStatCur,    
	int iMem,        
	int iTab         
) {
	sqlite3 *db = pParse->db;    
	Index *pIdx;                 
	int iIdxCur;                 
	int iTabCur;                 
	Vdbe *v;                     
	int i;                       
	int jZeroRows = -1;          
	int iDb;                     
	u8 needTableCnt = 1;         
	int regNewRowid = iMem++;    
	int regStat4 = iMem++;       
	int regChng = iMem++;        
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	int regRowid = iMem++;       
#endif
	int regTemp = iMem++;        
	int regTabname = iMem++;     
	int regIdxname = iMem++;     
	int regStat1 = iMem++;       
	int regPrev = iMem;          

	pParse->nMem = MAX(pParse->nMem, iMem);
	v = sqlite3GetVdbe(pParse);
	if (v == 0 || NEVER(pTab == 0)) {
		return;
	}
	if (pTab->tnum == 0) {
		
		return;
	}
	if (sqlite3_strlike("sqlite_%", pTab->zName, 0) == 0) {
		
		return;
	}
	assert(sqlite3BtreeHoldsAllMutexes(db));
	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	assert(iDb >= 0);
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
#ifndef SQLITE_OMIT_AUTHORIZATION
	if (sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab->zName, 0,
		db->aDb[iDb].zDbSName)) {
		return;
	}
#endif

	
	sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
	iTabCur = iTab++;
	iIdxCur = iTab++;
	pParse->nTab = MAX(pParse->nTab, iTab);
	sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);
	sqlite3VdbeLoadString(v, regTabname, pTab->zName);

	for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
		int nCol;                     
		int addrRewind;               
		int addrNextRow;              
		const char *zIdxName;         
		int nColTest;                 

		if (pOnlyIdx && pOnlyIdx != pIdx) continue;
		if (pIdx->pPartIdxWhere == 0) needTableCnt = 0;
		if (!HasRowid(pTab) && IsPrimaryKeyIndex(pIdx)) {
			nCol = pIdx->nKeyCol;
			zIdxName = pTab->zName;
			nColTest = nCol - 1;
		}
		else {
			nCol = pIdx->nColumn;
			zIdxName = pIdx->zName;
			nColTest = pIdx->uniqNotNull ? pIdx->nKeyCol - 1 : nCol - 1;
		}

		
		sqlite3VdbeLoadString(v, regIdxname, zIdxName);
		VdbeComment((v, "Analysis for %s.%s", pTab->zName, zIdxName));

		

		
		pParse->nMem = MAX(pParse->nMem, regPrev + nColTest);

		
		assert(iDb == sqlite3SchemaToIndex(db, pIdx->pSchema));
		sqlite3VdbeAddOp3(v, OP_OpenRead, iIdxCur, pIdx->tnum, iDb);
		sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
		VdbeComment((v, "%s", pIdx->zName));

		
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regStat4 + 3);
#endif
		sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4 + 1);
		sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4 + 2);
		sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4 + 1, regStat4,
			(char*)&statInitFuncdef, P4_FUNCDEF);
		sqlite3VdbeChangeP5(v, 2 + IsStat34);

		
		addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);
		VdbeCoverage(v);
		sqlite3VdbeAddOp2(v, OP_Integer, 0, regChng);
		addrNextRow = sqlite3VdbeCurrentAddr(v);

		if (nColTest>0) {
			int endDistinctTest = sqlite3VdbeMakeLabel(v);
			int *aGotoChng;               
			aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);
			if (aGotoChng == 0) continue;

			
			sqlite3VdbeAddOp0(v, OP_Goto);
			addrNextRow = sqlite3VdbeCurrentAddr(v);
			if (nColTest == 1 && pIdx->nKeyCol == 1 && IsUniqueIndex(pIdx)) {
				
				sqlite3VdbeAddOp2(v, OP_NotNull, regPrev, endDistinctTest);
				VdbeCoverage(v);
			}
			for (i = 0; i<nColTest; i++) {
				char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);
				sqlite3VdbeAddOp2(v, OP_Integer, i, regChng);
				sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regTemp);
				aGotoChng[i] =
					sqlite3VdbeAddOp4(v, OP_Ne, regTemp, 0, regPrev + i, pColl, P4_COLLSEQ);
				sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
				VdbeCoverage(v);
			}
			sqlite3VdbeAddOp2(v, OP_Integer, nColTest, regChng);
			sqlite3VdbeGoto(v, endDistinctTest);


			
			sqlite3VdbeJumpHere(v, addrNextRow - 1);
			for (i = 0; i<nColTest; i++) {
				sqlite3VdbeJumpHere(v, aGotoChng[i]);
				sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regPrev + i);
			}
			sqlite3VdbeResolveLabel(v, endDistinctTest);
			sqlite3DbFree(db, aGotoChng);
		}

		
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		assert(regRowid == (regStat4 + 2));
		if (HasRowid(pTab)) {
			sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);
		}
		else {
			Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
			int j, k, regKey;
			regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);
			for (j = 0; j<pPk->nKeyCol; j++) {
				k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);
				assert(k >= 0 && k<pTab->nCol);
				sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey + j);
				VdbeComment((v, "%s", pTab->aCol[pPk->aiColumn[j]].zName));
			}
			sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk->nKeyCol, regRowid);
			sqlite3ReleaseTempRange(pParse, regKey, pPk->nKeyCol);
		}
#endif
		assert(regChng == (regStat4 + 1));
		sqlite3VdbeAddOp4(v, OP_Function0, 1, regStat4, regTemp,
			(char*)&statPushFuncdef, P4_FUNCDEF);
		sqlite3VdbeChangeP5(v, 2 + IsStat34);
		sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);

		
		callStatGet(v, regStat4, STAT_GET_STAT1, regStat1);
		assert("BBB"[0] == SQLITE_AFF_TEXT);
		sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);
		sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);
		sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);
		sqlite3VdbeChangeP5(v, OPFLAG_APPEND);

		
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		{
			int regEq = regStat1;
			int regLt = regStat1 + 1;
			int regDLt = regStat1 + 2;
			int regSample = regStat1 + 3;
			int regCol = regStat1 + 4;
			int regSampleRowid = regCol + nCol;
			int addrNext;
			int addrIsNull;
			u8 seekOp = HasRowid(pTab) ? OP_NotExists : OP_NotFound;

			pParse->nMem = MAX(pParse->nMem, regCol + nCol);

			addrNext = sqlite3VdbeCurrentAddr(v);
			callStatGet(v, regStat4, STAT_GET_ROWID, regSampleRowid);
			addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);
			VdbeCoverage(v);
			callStatGet(v, regStat4, STAT_GET_NEQ, regEq);
			callStatGet(v, regStat4, STAT_GET_NLT, regLt);
			callStatGet(v, regStat4, STAT_GET_NDLT, regDLt);
			sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);
			
			VdbeCoverageNeverTaken(v);
#ifdef SQLITE_ENABLE_STAT3
			sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, 0, regSample);
#else
			for (i = 0; i<nCol; i++) {
				sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol + i);
			}
			sqlite3VdbeAddOp3(v, OP_MakeRecord, regCol, nCol, regSample);
#endif
			sqlite3VdbeAddOp3(v, OP_MakeRecord, regTabname, 6, regTemp);
			sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur + 1, regNewRowid);
			sqlite3VdbeAddOp3(v, OP_Insert, iStatCur + 1, regTemp, regNewRowid);
			sqlite3VdbeAddOp2(v, OP_Goto, 1, addrNext); 
			sqlite3VdbeJumpHere(v, addrIsNull);
		}
#endif 

		
		sqlite3VdbeJumpHere(v, addrRewind);
	}


	
	if (pOnlyIdx == 0 && needTableCnt) {
		VdbeComment((v, "%s", pTab->zName));
		sqlite3VdbeAddOp2(v, OP_Count, iTabCur, regStat1);
		jZeroRows = sqlite3VdbeAddOp1(v, OP_IfNot, regStat1); VdbeCoverage(v);
		sqlite3VdbeAddOp2(v, OP_Null, 0, regIdxname);
		assert("BBB"[0] == SQLITE_AFF_TEXT);
		sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);
		sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);
		sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);
		sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
		sqlite3VdbeJumpHere(v, jZeroRows);
	}
}



static void loadAnalysis(Parse *pParse, int iDb) {
	Vdbe *v = sqlite3GetVdbe(pParse);
	if (v) {
		sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb);
	}
}


static void analyzeDatabase(Parse *pParse, int iDb) {
	sqlite3 *db = pParse->db;
	Schema *pSchema = db->aDb[iDb].pSchema;    
	HashElem *k;
	int iStatCur;
	int iMem;
	int iTab;

	sqlite3BeginWriteOperation(pParse, 0, iDb);
	iStatCur = pParse->nTab;
	pParse->nTab += 3;
	openStatTable(pParse, iDb, iStatCur, 0, 0);
	iMem = pParse->nMem + 1;
	iTab = pParse->nTab;
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	for (k = sqliteHashFirst(&pSchema->tblHash); k; k = sqliteHashNext(k)) {
		Table *pTab = (Table*)sqliteHashData(k);
		analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);
	}
	loadAnalysis(pParse, iDb);
}


static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx) {
	int iDb;
	int iStatCur;

	assert(pTab != 0);
	assert(sqlite3BtreeHoldsAllMutexes(pParse->db));
	iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
	sqlite3BeginWriteOperation(pParse, 0, iDb);
	iStatCur = pParse->nTab;
	pParse->nTab += 3;
	if (pOnlyIdx) {
		openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");
	}
	else {
		openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");
	}
	analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur, pParse->nMem + 1, pParse->nTab);
	loadAnalysis(pParse, iDb);
}


SQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2) {
	sqlite3 *db = pParse->db;
	int iDb;
	int i;
	char *z, *zDb;
	Table *pTab;
	Index *pIdx;
	Token *pTableName;
	Vdbe *v;

	
	assert(sqlite3BtreeHoldsAllMutexes(pParse->db));
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		return;
	}

	assert(pName2 != 0 || pName1 == 0);
	if (pName1 == 0) {
		
		for (i = 0; i<db->nDb; i++) {
			if (i == 1) continue;  
			analyzeDatabase(pParse, i);
		}
	}
	else if (pName2->n == 0) {
		
		iDb = sqlite3FindDb(db, pName1);
		if (iDb >= 0) {
			analyzeDatabase(pParse, iDb);
		}
		else {
			z = sqlite3NameFromToken(db, pName1);
			if (z) {
				if ((pIdx = sqlite3FindIndex(db, z, 0)) != 0) {
					analyzeTable(pParse, pIdx->pTable, pIdx);
				}
				else if ((pTab = sqlite3LocateTable(pParse, 0, z, 0)) != 0) {
					analyzeTable(pParse, pTab, 0);
				}
				sqlite3DbFree(db, z);
			}
		}
	}
	else {
		
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);
		if (iDb >= 0) {
			zDb = db->aDb[iDb].zDbSName;
			z = sqlite3NameFromToken(db, pTableName);
			if (z) {
				if ((pIdx = sqlite3FindIndex(db, z, zDb)) != 0) {
					analyzeTable(pParse, pIdx->pTable, pIdx);
				}
				else if ((pTab = sqlite3LocateTable(pParse, 0, z, zDb)) != 0) {
					analyzeTable(pParse, pTab, 0);
				}
				sqlite3DbFree(db, z);
			}
		}
	}
	v = sqlite3GetVdbe(pParse);
	if (v) sqlite3VdbeAddOp0(v, OP_Expire);
}


typedef struct analysisInfo analysisInfo;
struct analysisInfo {
	sqlite3 *db;
	const char *zDatabase;
};


static void decodeIntArray(
	char *zIntArray,       
	int nOut,              
	tRowcnt *aOut,         
	LogEst *aLog,          
	Index *pIndex          
) {
	char *z = zIntArray;
	int c;
	int i;
	tRowcnt v;

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (z == 0) z = "";
#else
	assert(z != 0);
#endif
	for (i = 0; *z && i<nOut; i++) {
		v = 0;
		while ((c = z[0]) >= '0' && c <= '9') {
			v = v * 10 + c - '0';
			z++;
		}
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		if (aOut) aOut[i] = v;
		if (aLog) aLog[i] = sqlite3LogEst(v);
#else
		assert(aOut == 0);
		UNUSED_PARAMETER(aOut);
		assert(aLog != 0);
		aLog[i] = sqlite3LogEst(v);
#endif
		if (*z == ' ') z++;
	}
#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
	assert(pIndex != 0); {
#else
	if (pIndex) {
#endif
		pIndex->bUnordered = 0;
		pIndex->noSkipScan = 0;
		while (z[0]) {
			if (sqlite3_strglob("unordered*", z) == 0) {
				pIndex->bUnordered = 1;
			}
			else if (sqlite3_strglob("sz=[0-9]*", z) == 0) {
				pIndex->szIdxRow = sqlite3LogEst(sqlite3Atoi(z + 3));
			}
			else if (sqlite3_strglob("noskipscan*", z) == 0) {
				pIndex->noSkipScan = 1;
			}
#ifdef SQLITE_ENABLE_COSTMULT
			else if (sqlite3_strglob("costmult=[0-9]*", z) == 0) {
				pIndex->pTable->costMult = sqlite3LogEst(sqlite3Atoi(z + 9));
			}
#endif
			while (z[0] != 0 && z[0] != ' ') z++;
			while (z[0] == ' ') z++;
		}
	}
	}


static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed) {
	analysisInfo *pInfo = (analysisInfo*)pData;
	Index *pIndex;
	Table *pTable;
	const char *z;

	assert(argc == 3);
	UNUSED_PARAMETER2(NotUsed, argc);

	if (argv == 0 || argv[0] == 0 || argv[2] == 0) {
		return 0;
	}
	pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);
	if (pTable == 0) {
		return 0;
	}
	if (argv[1] == 0) {
		pIndex = 0;
	}
	else if (sqlite3_stricmp(argv[0], argv[1]) == 0) {
		pIndex = sqlite3PrimaryKeyIndex(pTable);
	}
	else {
		pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);
	}
	z = argv[2];

	if (pIndex) {
		tRowcnt *aiRowEst = 0;
		int nCol = pIndex->nKeyCol + 1;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		
		if (pIndex->aiRowEst == 0) {
			pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(sizeof(tRowcnt) * nCol);
			if (pIndex->aiRowEst == 0) sqlite3OomFault(pInfo->db);
		}
		aiRowEst = pIndex->aiRowEst;
#endif
		pIndex->bUnordered = 0;
		decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);
		if (pIndex->pPartIdxWhere == 0) pTable->nRowLogEst = pIndex->aiRowLogEst[0];
	}
	else {
		Index fakeIdx;
		fakeIdx.szIdxRow = pTable->szTabRow;
#ifdef SQLITE_ENABLE_COSTMULT
		fakeIdx.pTable = pTable;
#endif
		decodeIntArray((char*)z, 1, 0, &pTable->nRowLogEst, &fakeIdx);
		pTable->szTabRow = fakeIdx.szIdxRow;
	}

	return 0;
}


SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx) {
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (pIdx->aSample) {
		int j;
		for (j = 0; j<pIdx->nSample; j++) {
			IndexSample *p = &pIdx->aSample[j];
			sqlite3DbFree(db, p->p);
		}
		sqlite3DbFree(db, pIdx->aSample);
	}
	if (db && db->pnBytesFreed == 0) {
		pIdx->nSample = 0;
		pIdx->aSample = 0;
	}
#else
	UNUSED_PARAMETER(db);
	UNUSED_PARAMETER(pIdx);
#endif 
}

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static void initAvgEq(Index *pIdx) {
	if (pIdx) {
		IndexSample *aSample = pIdx->aSample;
		IndexSample *pFinal = &aSample[pIdx->nSample - 1];
		int iCol;
		int nCol = 1;
		if (pIdx->nSampleCol>1) {
			
			nCol = pIdx->nSampleCol - 1;
			pIdx->aAvgEq[nCol] = 1;
		}
		for (iCol = 0; iCol<nCol; iCol++) {
			int nSample = pIdx->nSample;
			int i;                    
			tRowcnt sumEq = 0;        
			tRowcnt avgEq = 0;
			tRowcnt nRow;             
			i64 nSum100 = 0;          
			i64 nDist100;             

			if (!pIdx->aiRowEst || iCol >= pIdx->nKeyCol || pIdx->aiRowEst[iCol + 1] == 0) {
				nRow = pFinal->anLt[iCol];
				nDist100 = (i64)100 * pFinal->anDLt[iCol];
				nSample--;
			}
			else {
				nRow = pIdx->aiRowEst[0];
				nDist100 = ((i64)100 * pIdx->aiRowEst[0]) / pIdx->aiRowEst[iCol + 1];
			}
			pIdx->nRowEst0 = nRow;

			
			for (i = 0; i<nSample; i++) {
				if (i == (pIdx->nSample - 1)
					|| aSample[i].anDLt[iCol] != aSample[i + 1].anDLt[iCol]
					) {
					sumEq += aSample[i].anEq[iCol];
					nSum100 += 100;
				}
			}

			if (nDist100>nSum100) {
				avgEq = ((i64)100 * (nRow - sumEq)) / (nDist100 - nSum100);
			}
			if (avgEq == 0) avgEq = 1;
			pIdx->aAvgEq[iCol] = avgEq;
		}
	}
}


static Index *findIndexOrPrimaryKey(
	sqlite3 *db,
	const char *zName,
	const char *zDb
) {
	Index *pIdx = sqlite3FindIndex(db, zName, zDb);
	if (pIdx == 0) {
		Table *pTab = sqlite3FindTable(db, zName, zDb);
		if (pTab && !HasRowid(pTab)) pIdx = sqlite3PrimaryKeyIndex(pTab);
	}
	return pIdx;
}


static int loadStatTbl(
	sqlite3 *db,                  
	int bStat3,                   
	const char *zSql1,            
	const char *zSql2,            
	const char *zDb               
) {
	int rc;                       
	sqlite3_stmt *pStmt = 0;      
	char *zSql;                   
	Index *pPrevIdx = 0;          
	IndexSample *pSample;         

	assert(db->lookaside.bDisable);
	zSql = sqlite3MPrintf(db, zSql1, zDb);
	if (!zSql) {
		return SQLITE_NOMEM_BKPT;
	}
	rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
	sqlite3DbFree(db, zSql);
	if (rc) return rc;

	while (sqlite3_step(pStmt) == SQLITE_ROW) {
		int nIdxCol = 1;              

		char *zIndex;   
		Index *pIdx;    
		int nSample;    
		int nByte;      
		int i;          
		tRowcnt *pSpace;

		zIndex = (char *)sqlite3_column_text(pStmt, 0);
		if (zIndex == 0) continue;
		nSample = sqlite3_column_int(pStmt, 1);
		pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);
		assert(pIdx == 0 || bStat3 || pIdx->nSample == 0);
		
		if (pIdx == 0 || pIdx->nSample) continue;
		if (bStat3 == 0) {
			assert(!HasRowid(pIdx->pTable) || pIdx->nColumn == pIdx->nKeyCol + 1);
			if (!HasRowid(pIdx->pTable) && IsPrimaryKeyIndex(pIdx)) {
				nIdxCol = pIdx->nKeyCol;
			}
			else {
				nIdxCol = pIdx->nColumn;
			}
		}
		pIdx->nSampleCol = nIdxCol;
		nByte = sizeof(IndexSample) * nSample;
		nByte += sizeof(tRowcnt) * nIdxCol * 3 * nSample;
		nByte += nIdxCol * sizeof(tRowcnt);     

		pIdx->aSample = sqlite3DbMallocZero(db, nByte);
		if (pIdx->aSample == 0) {
			sqlite3_finalize(pStmt);
			return SQLITE_NOMEM_BKPT;
		}
		pSpace = (tRowcnt*)&pIdx->aSample[nSample];
		pIdx->aAvgEq = pSpace; pSpace += nIdxCol;
		for (i = 0; i<nSample; i++) {
			pIdx->aSample[i].anEq = pSpace; pSpace += nIdxCol;
			pIdx->aSample[i].anLt = pSpace; pSpace += nIdxCol;
			pIdx->aSample[i].anDLt = pSpace; pSpace += nIdxCol;
		}
		assert(((u8*)pSpace) - nByte == (u8*)(pIdx->aSample));
	}
	rc = sqlite3_finalize(pStmt);
	if (rc) return rc;

	zSql = sqlite3MPrintf(db, zSql2, zDb);
	if (!zSql) {
		return SQLITE_NOMEM_BKPT;
	}
	rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
	sqlite3DbFree(db, zSql);
	if (rc) return rc;

	while (sqlite3_step(pStmt) == SQLITE_ROW) {
		char *zIndex;                 
		Index *pIdx;                  
		int nCol = 1;                 

		zIndex = (char *)sqlite3_column_text(pStmt, 0);
		if (zIndex == 0) continue;
		pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);
		if (pIdx == 0) continue;
		
		nCol = pIdx->nSampleCol;
		if (bStat3 && nCol>1) continue;
		if (pIdx != pPrevIdx) {
			initAvgEq(pPrevIdx);
			pPrevIdx = pIdx;
		}
		pSample = &pIdx->aSample[pIdx->nSample];
		decodeIntArray((char*)sqlite3_column_text(pStmt, 1), nCol, pSample->anEq, 0, 0);
		decodeIntArray((char*)sqlite3_column_text(pStmt, 2), nCol, pSample->anLt, 0, 0);
		decodeIntArray((char*)sqlite3_column_text(pStmt, 3), nCol, pSample->anDLt, 0, 0);

		
		pSample->n = sqlite3_column_bytes(pStmt, 4);
		pSample->p = sqlite3DbMallocZero(db, pSample->n + 2);
		if (pSample->p == 0) {
			sqlite3_finalize(pStmt);
			return SQLITE_NOMEM_BKPT;
		}
		memcpy(pSample->p, sqlite3_column_blob(pStmt, 4), pSample->n);
		pIdx->nSample++;
	}
	rc = sqlite3_finalize(pStmt);
	if (rc == SQLITE_OK) initAvgEq(pPrevIdx);
	return rc;
}


static int loadStat4(sqlite3 *db, const char *zDb) {
	int rc = SQLITE_OK;             

	assert(db->lookaside.bDisable);
	if (sqlite3FindTable(db, "sqlite_stat4", zDb)) {
		rc = loadStatTbl(db, 0,
			"SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx",
			"SELECT idx,neq,nlt,ndlt,sample FROM %Q.sqlite_stat4",
			zDb
		);
	}

	if (rc == SQLITE_OK && sqlite3FindTable(db, "sqlite_stat3", zDb)) {
		rc = loadStatTbl(db, 1,
			"SELECT idx,count(*) FROM %Q.sqlite_stat3 GROUP BY idx",
			"SELECT idx,neq,nlt,ndlt,sqlite_record(sample) FROM %Q.sqlite_stat3",
			zDb
		);
	}

	return rc;
}
#endif 


SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb) {
	analysisInfo sInfo;
	HashElem *i;
	char *zSql;
	int rc = SQLITE_OK;

	assert(iDb >= 0 && iDb<db->nDb);
	assert(db->aDb[iDb].pBt != 0);

	
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	for (i = sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash); i; i = sqliteHashNext(i)) {
		Index *pIdx = sqliteHashData(i);
		pIdx->aiRowLogEst[0] = 0;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		sqlite3DeleteIndexSamples(db, pIdx);
		pIdx->aSample = 0;
#endif
	}

	
	sInfo.db = db;
	sInfo.zDatabase = db->aDb[iDb].zDbSName;
	if (sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase) != 0) {
		zSql = sqlite3MPrintf(db,
			"SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
		if (zSql == 0) {
			rc = SQLITE_NOMEM_BKPT;
		}
		else {
			rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);
			sqlite3DbFree(db, zSql);
		}
	}

	
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	for (i = sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash); i; i = sqliteHashNext(i)) {
		Index *pIdx = sqliteHashData(i);
		if (pIdx->aiRowLogEst[0] == 0) sqlite3DefaultRowEst(pIdx);
	}

	
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	if (rc == SQLITE_OK && OptimizationEnabled(db, SQLITE_Stat34)) {
		db->lookaside.bDisable++;
		rc = loadStat4(db, sInfo.zDatabase);
		db->lookaside.bDisable--;
	}
	for (i = sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash); i; i = sqliteHashNext(i)) {
		Index *pIdx = sqliteHashData(i);
		sqlite3_free(pIdx->aiRowEst);
		pIdx->aiRowEst = 0;
	}
#endif

	if (rc == SQLITE_NOMEM) {
		sqlite3OomFault(db);
	}
	return rc;
}


#endif 






#ifndef SQLITE_OMIT_ATTACH

static int resolveAttachExpr(NameContext *pName, Expr *pExpr)
{
	int rc = SQLITE_OK;
	if (pExpr) {
		if (pExpr->op != TK_ID) {
			rc = sqlite3ResolveExprNames(pName, pExpr);
		}
		else {
			pExpr->op = TK_STRING;
		}
	}
	return rc;
}


static void attachFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	int i;
	int rc = 0;
	sqlite3 *db = sqlite3_context_db_handle(context);
	const char *zName;
	const char *zFile;
	char *zPath = 0;
	char *zErr = 0;
	unsigned int flags;
	Db *aNew;
	char *zErrDyn = 0;
	sqlite3_vfs *pVfs;

	UNUSED_PARAMETER(NotUsed);

	zFile = (const char *)sqlite3_value_text(argv[0]);
	zName = (const char *)sqlite3_value_text(argv[1]);
	if (zFile == 0) zFile = "";
	if (zName == 0) zName = "";

	
	if (db->nDb >= db->aLimit[SQLITE_LIMIT_ATTACHED] + 2) {
		zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",
			db->aLimit[SQLITE_LIMIT_ATTACHED]
		);
		goto attach_error;
	}
	if (!db->autoCommit) {
		zErrDyn = sqlite3MPrintf(db, "cannot ATTACH database within transaction");
		goto attach_error;
	}
	for (i = 0; i<db->nDb; i++) {
		char *z = db->aDb[i].zDbSName;
		assert(z && zName);
		if (sqlite3StrICmp(z, zName) == 0) {
			zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
			goto attach_error;
		}
	}

	
	if (db->aDb == db->aDbStatic) {
		aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0]) * 3);
		if (aNew == 0) return;
		memcpy(aNew, db->aDb, sizeof(db->aDb[0]) * 2);
	}
	else {
		aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb + 1));
		if (aNew == 0) return;
	}
	db->aDb = aNew;
	aNew = &db->aDb[db->nDb];
	memset(aNew, 0, sizeof(*aNew));

	
	flags = db->openFlags;
	rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
	if (rc != SQLITE_OK) {
		if (rc == SQLITE_NOMEM) sqlite3OomFault(db);
		sqlite3_result_error(context, zErr, -1);
		sqlite3_free(zErr);
		return;
	}
	assert(pVfs);
	flags |= SQLITE_OPEN_MAIN_DB;
	rc = sqlite3BtreeOpen(pVfs, zPath, db, &aNew->pBt, 0, flags);
	sqlite3_free(zPath);
	db->nDb++;
	if (rc == SQLITE_CONSTRAINT) {
		rc = SQLITE_ERROR;
		zErrDyn = sqlite3MPrintf(db, "database is already attached");
	}
	else if (rc == SQLITE_OK) {
		Pager *pPager;
		aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt);
		if (!aNew->pSchema) {
			rc = SQLITE_NOMEM_BKPT;
		}
		else if (aNew->pSchema->file_format && aNew->pSchema->enc != ENC(db)) {
			zErrDyn = sqlite3MPrintf(db,
				"attached databases must use the same text encoding as main database");
			rc = SQLITE_ERROR;
		}
		sqlite3BtreeEnter(aNew->pBt);
		pPager = sqlite3BtreePager(aNew->pBt);
		sqlite3PagerLockingMode(pPager, db->dfltLockMode);
		sqlite3BtreeSecureDelete(aNew->pBt,
			sqlite3BtreeSecureDelete(db->aDb[0].pBt, -1));
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
		sqlite3BtreeSetPagerFlags(aNew->pBt,
			PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));
#endif
		sqlite3BtreeLeave(aNew->pBt);
	}
	aNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS + 1;
	aNew->zDbSName = sqlite3DbStrDup(db, zName);
	if (rc == SQLITE_OK && aNew->zDbSName == 0) {
		rc = SQLITE_NOMEM_BKPT;
	}


#ifdef SQLITE_HAS_CODEC
	if (rc == SQLITE_OK) {
		extern int sqlite3CodecAttach(sqlite3*, int, const void*, int);
		extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);
		int nKey;
		char *zKey;
		int t = sqlite3_value_type(argv[2]);
		switch (t) {
		case SQLITE_INTEGER:
		case SQLITE_FLOAT:
			zErrDyn = sqlite3DbStrDup(db, "Invalid key value");
			rc = SQLITE_ERROR;
			break;

		case SQLITE_TEXT:
		case SQLITE_BLOB:
			nKey = sqlite3_value_bytes(argv[2]);
			zKey = (char *)sqlite3_value_blob(argv[2]);
			rc = sqlite3CodecAttach(db, db->nDb - 1, zKey, nKey);
			break;

		case SQLITE_NULL:
			
			sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);
			if (nKey || sqlite3BtreeGetOptimalReserve(db->aDb[0].pBt)>0) {
				rc = sqlite3CodecAttach(db, db->nDb - 1, zKey, nKey);
			}
			break;
		}
	}
#endif

	
	if (rc == SQLITE_OK) {
		sqlite3BtreeEnterAll(db);
		rc = sqlite3Init(db, &zErrDyn);
		sqlite3BtreeLeaveAll(db);
	}
#ifdef SQLITE_USER_AUTHENTICATION
	if (rc == SQLITE_OK) {
		u8 newAuth = 0;
		rc = sqlite3UserAuthCheckLogin(db, zName, &newAuth);
		if (newAuth<db->auth.authLevel) {
			rc = SQLITE_AUTH_USER;
		}
	}
#endif
	if (rc) {
		int iDb = db->nDb - 1;
		assert(iDb >= 2);
		if (db->aDb[iDb].pBt) {
			sqlite3BtreeClose(db->aDb[iDb].pBt);
			db->aDb[iDb].pBt = 0;
			db->aDb[iDb].pSchema = 0;
		}
		sqlite3ResetAllSchemasOfConnection(db);
		db->nDb = iDb;
		if (rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM) {
			sqlite3OomFault(db);
			sqlite3DbFree(db, zErrDyn);
			zErrDyn = sqlite3MPrintf(db, "out of memory");
		}
		else if (zErrDyn == 0) {
			zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
		}
		goto attach_error;
	}

	return;

attach_error:
	
	if (zErrDyn) {
		sqlite3_result_error(context, zErrDyn, -1);
		sqlite3DbFree(db, zErrDyn);
	}
	if (rc) sqlite3_result_error_code(context, rc);
}


static void detachFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	const char *zName = (const char *)sqlite3_value_text(argv[0]);
	sqlite3 *db = sqlite3_context_db_handle(context);
	int i;
	Db *pDb = 0;
	char zErr[128];

	UNUSED_PARAMETER(NotUsed);

	if (zName == 0) zName = "";
	for (i = 0; i<db->nDb; i++) {
		pDb = &db->aDb[i];
		if (pDb->pBt == 0) continue;
		if (sqlite3StrICmp(pDb->zDbSName, zName) == 0) break;
	}

	if (i >= db->nDb) {
		sqlite3_snprintf(sizeof(zErr), zErr, "no such database: %s", zName);
		goto detach_error;
	}
	if (i<2) {
		sqlite3_snprintf(sizeof(zErr), zErr, "cannot detach database %s", zName);
		goto detach_error;
	}
	if (!db->autoCommit) {
		sqlite3_snprintf(sizeof(zErr), zErr,
			"cannot DETACH database within transaction");
		goto detach_error;
	}
	if (sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt)) {
		sqlite3_snprintf(sizeof(zErr), zErr, "database %s is locked", zName);
		goto detach_error;
	}

	sqlite3BtreeClose(pDb->pBt);
	pDb->pBt = 0;
	pDb->pSchema = 0;
	sqlite3CollapseDatabaseArray(db);
	return;

detach_error:
	sqlite3_result_error(context, zErr, -1);
}


static void codeAttach(
	Parse *pParse,       
	int type,            
	FuncDef const *pFunc,
	Expr *pAuthArg,      
	Expr *pFilename,     
	Expr *pDbname,       
	Expr *pKey           
) {
	int rc;
	NameContext sName;
	Vdbe *v;
	sqlite3* db = pParse->db;
	int regArgs;

	if (pParse->nErr) goto attach_end;
	memset(&sName, 0, sizeof(NameContext));
	sName.pParse = pParse;

	if (
		SQLITE_OK != (rc = resolveAttachExpr(&sName, pFilename)) ||
		SQLITE_OK != (rc = resolveAttachExpr(&sName, pDbname)) ||
		SQLITE_OK != (rc = resolveAttachExpr(&sName, pKey))
		) {
		goto attach_end;
	}

#ifndef SQLITE_OMIT_AUTHORIZATION
	if (pAuthArg) {
		char *zAuthArg;
		if (pAuthArg->op == TK_STRING) {
			zAuthArg = pAuthArg->u.zToken;
		}
		else {
			zAuthArg = 0;
		}
		rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);
		if (rc != SQLITE_OK) {
			goto attach_end;
		}
	}
#endif 


	v = sqlite3GetVdbe(pParse);
	regArgs = sqlite3GetTempRange(pParse, 4);
	sqlite3ExprCode(pParse, pFilename, regArgs);
	sqlite3ExprCode(pParse, pDbname, regArgs + 1);
	sqlite3ExprCode(pParse, pKey, regArgs + 2);

	assert(v || db->mallocFailed);
	if (v) {
		sqlite3VdbeAddOp4(v, OP_Function0, 0, regArgs + 3 - pFunc->nArg, regArgs + 3,
			(char *)pFunc, P4_FUNCDEF);
		assert(pFunc->nArg == -1 || (pFunc->nArg & 0xff) == pFunc->nArg);
		sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));

		
		sqlite3VdbeAddOp1(v, OP_Expire, (type == SQLITE_ATTACH));
	}

attach_end:
	sqlite3ExprDelete(db, pFilename);
	sqlite3ExprDelete(db, pDbname);
	sqlite3ExprDelete(db, pKey);
}


SQLITE_PRIVATE void sqlite3Detach(Parse *pParse, Expr *pDbname) {
	static const FuncDef detach_func = {
		1,                
		SQLITE_UTF8,      
		0,                
		0,                
		detachFunc,       
		0,                
		"sqlite_detach",  
		{ 0 }
	};
	codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);
}


SQLITE_PRIVATE void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey) {
	static const FuncDef attach_func = {
		3,                
		SQLITE_UTF8,      
		0,                
		0,                
		attachFunc,       
		0,                
		"sqlite_attach",  
		{ 0 }
	};
	codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey);
}
#endif 


SQLITE_PRIVATE void sqlite3FixInit(
	DbFixer *pFix,      
	Parse *pParse,      
	int iDb,            
	const char *zType,  
	const Token *pName  
) {
	sqlite3 *db;

	db = pParse->db;
	assert(db->nDb>iDb);
	pFix->pParse = pParse;
	pFix->zDb = db->aDb[iDb].zDbSName;
	pFix->pSchema = db->aDb[iDb].pSchema;
	pFix->zType = zType;
	pFix->pName = pName;
	pFix->bVarOnly = (iDb == 1);
}


SQLITE_PRIVATE int sqlite3FixSrcList(
	DbFixer *pFix,       
	SrcList *pList       
) {
	int i;
	const char *zDb;
	struct SrcList_item *pItem;

	if (NEVER(pList == 0)) return 0;
	zDb = pFix->zDb;
	for (i = 0, pItem = pList->a; i<pList->nSrc; i++, pItem++) {
		if (pFix->bVarOnly == 0) {
			if (pItem->zDatabase && sqlite3StrICmp(pItem->zDatabase, zDb)) {
				sqlite3ErrorMsg(pFix->pParse,
					"%s %T cannot reference objects in database %s",
					pFix->zType, pFix->pName, pItem->zDatabase);
				return 1;
			}
			sqlite3DbFree(pFix->pParse->db, pItem->zDatabase);
			pItem->zDatabase = 0;
			pItem->pSchema = pFix->pSchema;
		}
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
		if (sqlite3FixSelect(pFix, pItem->pSelect)) return 1;
		if (sqlite3FixExpr(pFix, pItem->pOn)) return 1;
#endif
	}
	return 0;
}
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE int sqlite3FixSelect(
	DbFixer *pFix,       
	Select *pSelect      
) {
	while (pSelect) {
		if (sqlite3FixExprList(pFix, pSelect->pEList)) {
			return 1;
		}
		if (sqlite3FixSrcList(pFix, pSelect->pSrc)) {
			return 1;
		}
		if (sqlite3FixExpr(pFix, pSelect->pWhere)) {
			return 1;
		}
		if (sqlite3FixExprList(pFix, pSelect->pGroupBy)) {
			return 1;
		}
		if (sqlite3FixExpr(pFix, pSelect->pHaving)) {
			return 1;
		}
		if (sqlite3FixExprList(pFix, pSelect->pOrderBy)) {
			return 1;
		}
		if (sqlite3FixExpr(pFix, pSelect->pLimit)) {
			return 1;
		}
		if (sqlite3FixExpr(pFix, pSelect->pOffset)) {
			return 1;
		}
		pSelect = pSelect->pPrior;
	}
	return 0;
}
SQLITE_PRIVATE int sqlite3FixExpr(
	DbFixer *pFix,     
	Expr *pExpr        
) {
	while (pExpr) {
		if (pExpr->op == TK_VARIABLE) {
			if (pFix->pParse->db->init.busy) {
				pExpr->op = TK_NULL;
			}
			else {
				sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
				return 1;
			}
		}
		if (ExprHasProperty(pExpr, EP_TokenOnly | EP_Leaf)) break;
		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			if (sqlite3FixSelect(pFix, pExpr->x.pSelect)) return 1;
		}
		else {
			if (sqlite3FixExprList(pFix, pExpr->x.pList)) return 1;
		}
		if (sqlite3FixExpr(pFix, pExpr->pRight)) {
			return 1;
		}
		pExpr = pExpr->pLeft;
	}
	return 0;
}
SQLITE_PRIVATE int sqlite3FixExprList(
	DbFixer *pFix,     
	ExprList *pList    
) {
	int i;
	struct ExprList_item *pItem;
	if (pList == 0) return 0;
	for (i = 0, pItem = pList->a; i<pList->nExpr; i++, pItem++) {
		if (sqlite3FixExpr(pFix, pItem->pExpr)) {
			return 1;
		}
	}
	return 0;
}
#endif

#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE int sqlite3FixTriggerStep(
	DbFixer *pFix,     
	TriggerStep *pStep 
) {
	while (pStep) {
		if (sqlite3FixSelect(pFix, pStep->pSelect)) {
			return 1;
		}
		if (sqlite3FixExpr(pFix, pStep->pWhere)) {
			return 1;
		}
		if (sqlite3FixExprList(pFix, pStep->pExprList)) {
			return 1;
		}
		pStep = pStep->pNext;
	}
	return 0;
}
#endif







#ifndef SQLITE_OMIT_AUTHORIZATION


SQLITE_API int sqlite3_set_authorizer(
	sqlite3 *db,
	int(*xAuth)(void*, int, const char*, const char*, const char*, const char*),
	void *pArg
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	db->xAuth = (sqlite3_xauth)xAuth;
	db->pAuthArg = pArg;
	sqlite3ExpirePreparedStatements(db);
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}


static void sqliteAuthBadReturnCode(Parse *pParse) {
	sqlite3ErrorMsg(pParse, "authorizer malfunction");
	pParse->rc = SQLITE_ERROR;
}


SQLITE_PRIVATE int sqlite3AuthReadCol(
	Parse *pParse,                  
	const char *zTab,               
	const char *zCol,               
	int iDb                         
) {
	sqlite3 *db = pParse->db;          
	char *zDb = db->aDb[iDb].zDbSName; 
	int rc;                            

	if (db->init.busy) return SQLITE_OK;
	rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab, zCol, zDb, pParse->zAuthContext
#ifdef SQLITE_USER_AUTHENTICATION
		, db->auth.zAuthUser
#endif
	);
	if (rc == SQLITE_DENY) {
		if (db->nDb>2 || iDb != 0) {
			sqlite3ErrorMsg(pParse, "access to %s.%s.%s is prohibited", zDb, zTab, zCol);
		}
		else {
			sqlite3ErrorMsg(pParse, "access to %s.%s is prohibited", zTab, zCol);
		}
		pParse->rc = SQLITE_AUTH;
	}
	else if (rc != SQLITE_IGNORE && rc != SQLITE_OK) {
		sqliteAuthBadReturnCode(pParse);
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3AuthRead(
	Parse *pParse,        
	Expr *pExpr,          
	Schema *pSchema,      
	SrcList *pTabList     
) {
	sqlite3 *db = pParse->db;
	Table *pTab = 0;      
	const char *zCol;     
	int iSrc;             
	int iDb;              
	int iCol;             

	if (db->xAuth == 0) return;
	iDb = sqlite3SchemaToIndex(pParse->db, pSchema);
	if (iDb<0) {
		
		return;
	}

	assert(pExpr->op == TK_COLUMN || pExpr->op == TK_TRIGGER);
	if (pExpr->op == TK_TRIGGER) {
		pTab = pParse->pTriggerTab;
	}
	else {
		assert(pTabList);
		for (iSrc = 0; ALWAYS(iSrc<pTabList->nSrc); iSrc++) {
			if (pExpr->iTable == pTabList->a[iSrc].iCursor) {
				pTab = pTabList->a[iSrc].pTab;
				break;
			}
		}
	}
	iCol = pExpr->iColumn;
	if (NEVER(pTab == 0)) return;

	if (iCol >= 0) {
		assert(iCol<pTab->nCol);
		zCol = pTab->aCol[iCol].zName;
	}
	else if (pTab->iPKey >= 0) {
		assert(pTab->iPKey<pTab->nCol);
		zCol = pTab->aCol[pTab->iPKey].zName;
	}
	else {
		zCol = "ROWID";
	}
	assert(iDb >= 0 && iDb<db->nDb);
	if (SQLITE_IGNORE == sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb)) {
		pExpr->op = TK_NULL;
	}
}


SQLITE_PRIVATE int sqlite3AuthCheck(
	Parse *pParse,
	int code,
	const char *zArg1,
	const char *zArg2,
	const char *zArg3
) {
	sqlite3 *db = pParse->db;
	int rc;

	
	if (db->init.busy || IN_DECLARE_VTAB) {
		return SQLITE_OK;
	}

	if (db->xAuth == 0) {
		return SQLITE_OK;
	}
	rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext
#ifdef SQLITE_USER_AUTHENTICATION
		, db->auth.zAuthUser
#endif
	);
	if (rc == SQLITE_DENY) {
		sqlite3ErrorMsg(pParse, "not authorized");
		pParse->rc = SQLITE_AUTH;
	}
	else if (rc != SQLITE_OK && rc != SQLITE_IGNORE) {
		rc = SQLITE_DENY;
		sqliteAuthBadReturnCode(pParse);
	}
	return rc;
}


SQLITE_PRIVATE void sqlite3AuthContextPush(
	Parse *pParse,
	AuthContext *pContext,
	const char *zContext
) {
	assert(pParse);
	pContext->pParse = pParse;
	pContext->zAuthContext = pParse->zAuthContext;
	pParse->zAuthContext = zContext;
}


SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext) {
	if (pContext->pParse) {
		pContext->pParse->zAuthContext = pContext->zAuthContext;
		pContext->pParse = 0;
	}
}

#endif 






#ifndef SQLITE_OMIT_SHARED_CACHE

struct TableLock {
	int iDb;             
	int iTab;            
	u8 isWriteLock;      
	const char *zName;   
};


SQLITE_PRIVATE void sqlite3TableLock(
	Parse *pParse,     
	int iDb,           
	int iTab,          
	u8 isWriteLock,    
	const char *zName  
) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);
	int i;
	int nBytes;
	TableLock *p;
	assert(iDb >= 0);

	for (i = 0; i<pToplevel->nTableLock; i++) {
		p = &pToplevel->aTableLock[i];
		if (p->iDb == iDb && p->iTab == iTab) {
			p->isWriteLock = (p->isWriteLock || isWriteLock);
			return;
		}
	}

	nBytes = sizeof(TableLock) * (pToplevel->nTableLock + 1);
	pToplevel->aTableLock =
		sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);
	if (pToplevel->aTableLock) {
		p = &pToplevel->aTableLock[pToplevel->nTableLock++];
		p->iDb = iDb;
		p->iTab = iTab;
		p->isWriteLock = isWriteLock;
		p->zName = zName;
	}
	else {
		pToplevel->nTableLock = 0;
		sqlite3OomFault(pToplevel->db);
	}
}


static void codeTableLocks(Parse *pParse) {
	int i;
	Vdbe *pVdbe;

	pVdbe = sqlite3GetVdbe(pParse);
	assert(pVdbe != 0); 

	for (i = 0; i<pParse->nTableLock; i++) {
		TableLock *p = &pParse->aTableLock[i];
		int p1 = p->iDb;
		sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,
			p->zName, P4_STATIC);
	}
}
#else
#define codeTableLocks(x)
#endif


#if SQLITE_MAX_ATTACHED>30
SQLITE_PRIVATE int sqlite3DbMaskAllZero(yDbMask m) {
	int i;
	for (i = 0; i<sizeof(yDbMask); i++) if (m[i]) return 0;
	return 1;
}
#endif


SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse) {
	sqlite3 *db;
	Vdbe *v;

	assert(pParse->pToplevel == 0);
	db = pParse->db;
	if (pParse->nested) return;
	if (db->mallocFailed || pParse->nErr) {
		if (pParse->rc == SQLITE_OK) pParse->rc = SQLITE_ERROR;
		return;
	}

	
	v = sqlite3GetVdbe(pParse);
	assert(!pParse->isMultiWrite
		|| sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));
	if (v) {
		sqlite3VdbeAddOp0(v, OP_Halt);

#if SQLITE_USER_AUTHENTICATION
		if (pParse->nTableLock>0 && db->init.busy == 0) {
			sqlite3UserAuthInit(db);
			if (db->auth.authLevel<UAUTH_User) {
				sqlite3ErrorMsg(pParse, "user not authenticated");
				pParse->rc = SQLITE_AUTH_USER;
				return;
			}
		}
#endif

		
		if (db->mallocFailed == 0
			&& (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)
			) {
			int iDb, i;
			assert(sqlite3VdbeGetOp(v, 0)->opcode == OP_Init);
			sqlite3VdbeJumpHere(v, 0);
			for (iDb = 0; iDb<db->nDb; iDb++) {
				Schema *pSchema;
				if (DbMaskTest(pParse->cookieMask, iDb) == 0) continue;
				sqlite3VdbeUsesBtree(v, iDb);
				pSchema = db->aDb[iDb].pSchema;
				sqlite3VdbeAddOp4Int(v,
					OP_Transaction,                    
					iDb,                               
					DbMaskTest(pParse->writeMask, iDb), 
					pSchema->schema_cookie,            
					pSchema->iGeneration               
				);
				if (db->init.busy == 0) sqlite3VdbeChangeP5(v, 1);
				VdbeComment((v,
					"usesStmtJournal=%d", pParse->mayAbort && pParse->isMultiWrite));
			}
#ifndef SQLITE_OMIT_VIRTUALTABLE
			for (i = 0; i<pParse->nVtabLock; i++) {
				char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);
				sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);
			}
			pParse->nVtabLock = 0;
#endif

			
			codeTableLocks(pParse);

			
			sqlite3AutoincrementBegin(pParse);

			
			if (pParse->pConstExpr) {
				ExprList *pEL = pParse->pConstExpr;
				pParse->okConstFactor = 0;
				for (i = 0; i<pEL->nExpr; i++) {
					sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);
				}
			}

			
			sqlite3VdbeGoto(v, 1);
		}
	}


	
	if (v && pParse->nErr == 0 && !db->mallocFailed) {
		assert(pParse->iCacheLevel == 0);  
										   
		if (pParse->pAinc != 0 && pParse->nTab == 0) pParse->nTab = 1;
		sqlite3VdbeMakeReady(v, pParse);
		pParse->rc = SQLITE_DONE;
	}
	else {
		pParse->rc = SQLITE_ERROR;
	}
}


SQLITE_PRIVATE void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...) {
	va_list ap;
	char *zSql;
	char *zErrMsg = 0;
	sqlite3 *db = pParse->db;
	char saveBuf[PARSE_TAIL_SZ];

	if (pParse->nErr) return;
	assert(pParse->nested<10);  
	va_start(ap, zFormat);
	zSql = sqlite3VMPrintf(db, zFormat, ap);
	va_end(ap);
	if (zSql == 0) {
		return;   
	}
	pParse->nested++;
	memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);
	memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);
	sqlite3RunParser(pParse, zSql, &zErrMsg);
	sqlite3DbFree(db, zErrMsg);
	sqlite3DbFree(db, zSql);
	memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);
	pParse->nested--;
}

#if SQLITE_USER_AUTHENTICATION

SQLITE_PRIVATE int sqlite3UserAuthTable(const char *zTable) {
	return sqlite3_stricmp(zTable, "sqlite_user") == 0;
}
#endif


SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase) {
	Table *p = 0;
	int i;

	
	assert(zDatabase != 0 || sqlite3BtreeHoldsAllMutexes(db));
#if SQLITE_USER_AUTHENTICATION
	
	if (db->auth.authLevel<UAUTH_Admin && sqlite3UserAuthTable(zName) != 0) {
		return 0;
	}
#endif
	for (i = OMIT_TEMPDB; i<db->nDb; i++) {
		int j = (i<2) ? i ^ 1 : i;   
		if (zDatabase == 0 || sqlite3StrICmp(zDatabase, db->aDb[j].zDbSName) == 0) {
			assert(sqlite3SchemaMutexHeld(db, j, 0));
			p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName);
			if (p) break;
		}
	}
	return p;
}


SQLITE_PRIVATE Table *sqlite3LocateTable(
	Parse *pParse,         
	u32 flags,             
	const char *zName,     
	const char *zDbase     
) {
	Table *p;

	
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		return 0;
	}

	p = sqlite3FindTable(pParse->db, zName, zDbase);
	if (p == 0) {
		const char *zMsg = flags & LOCATE_VIEW ? "no such view" : "no such table";
#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (sqlite3FindDbName(pParse->db, zDbase)<1) {
			
			Module *pMod = (Module*)sqlite3HashFind(&pParse->db->aModule, zName);
			if (pMod && sqlite3VtabEponymousTableInit(pParse, pMod)) {
				return pMod->pEpoTab;
			}
		}
#endif
		if ((flags & LOCATE_NOERR) == 0) {
			if (zDbase) {
				sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
			}
			else {
				sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
			}
			pParse->checkSchema = 1;
		}
	}

	return p;
}


SQLITE_PRIVATE Table *sqlite3LocateTableItem(
	Parse *pParse,
	u32 flags,
	struct SrcList_item *p
) {
	const char *zDb;
	assert(p->pSchema == 0 || p->zDatabase == 0);
	if (p->pSchema) {
		int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);
		zDb = pParse->db->aDb[iDb].zDbSName;
	}
	else {
		zDb = p->zDatabase;
	}
	return sqlite3LocateTable(pParse, flags, p->zName, zDb);
}


SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb) {
	Index *p = 0;
	int i;
	
	assert(zDb != 0 || sqlite3BtreeHoldsAllMutexes(db));
	for (i = OMIT_TEMPDB; i<db->nDb; i++) {
		int j = (i<2) ? i ^ 1 : i;  
		Schema *pSchema = db->aDb[j].pSchema;
		assert(pSchema);
		if (zDb && sqlite3StrICmp(zDb, db->aDb[j].zDbSName)) continue;
		assert(sqlite3SchemaMutexHeld(db, j, 0));
		p = sqlite3HashFind(&pSchema->idxHash, zName);
		if (p) break;
	}
	return p;
}


static void freeIndex(sqlite3 *db, Index *p) {
#ifndef SQLITE_OMIT_ANALYZE
	sqlite3DeleteIndexSamples(db, p);
#endif
	sqlite3ExprDelete(db, p->pPartIdxWhere);
	sqlite3ExprListDelete(db, p->aColExpr);
	sqlite3DbFree(db, p->zColAff);
	if (p->isResized) sqlite3DbFree(db, (void *)p->azColl);
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	sqlite3_free(p->aiRowEst);
#endif
	sqlite3DbFree(db, p);
}


SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName) {
	Index *pIndex;
	Hash *pHash;

	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	pHash = &db->aDb[iDb].pSchema->idxHash;
	pIndex = sqlite3HashInsert(pHash, zIdxName, 0);
	if (ALWAYS(pIndex)) {
		if (pIndex->pTable->pIndex == pIndex) {
			pIndex->pTable->pIndex = pIndex->pNext;
		}
		else {
			Index *p;
			
			p = pIndex->pTable->pIndex;
			while (ALWAYS(p) && p->pNext != pIndex) { p = p->pNext; }
			if (ALWAYS(p && p->pNext == pIndex)) {
				p->pNext = pIndex->pNext;
			}
		}
		freeIndex(db, pIndex);
	}
	db->flags |= SQLITE_InternChanges;
}


SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3 *db) {
	int i, j;
	for (i = j = 2; i<db->nDb; i++) {
		struct Db *pDb = &db->aDb[i];
		if (pDb->pBt == 0) {
			sqlite3DbFree(db, pDb->zDbSName);
			pDb->zDbSName = 0;
			continue;
		}
		if (j<i) {
			db->aDb[j] = db->aDb[i];
		}
		j++;
	}
	db->nDb = j;
	if (db->nDb <= 2 && db->aDb != db->aDbStatic) {
		memcpy(db->aDbStatic, db->aDb, 2 * sizeof(db->aDb[0]));
		sqlite3DbFree(db, db->aDb);
		db->aDb = db->aDbStatic;
	}
}


SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3 *db, int iDb) {
	Db *pDb;
	assert(iDb<db->nDb);

	
	pDb = &db->aDb[iDb];
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	assert(pDb->pSchema != 0);
	sqlite3SchemaClear(pDb->pSchema);

	
	if (iDb != 1) {
		pDb = &db->aDb[1];
		assert(pDb->pSchema != 0);
		sqlite3SchemaClear(pDb->pSchema);
	}
	return;
}


SQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3 *db) {
	int i;
	sqlite3BtreeEnterAll(db);
	for (i = 0; i<db->nDb; i++) {
		Db *pDb = &db->aDb[i];
		if (pDb->pSchema) {
			sqlite3SchemaClear(pDb->pSchema);
		}
	}
	db->flags &= ~SQLITE_InternChanges;
	sqlite3VtabUnlockList(db);
	sqlite3BtreeLeaveAll(db);
	sqlite3CollapseDatabaseArray(db);
}


SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3 *db) {
	db->flags &= ~SQLITE_InternChanges;
}


SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable) {
	int i;
	Column *pCol;
	assert(pTable != 0);
	if ((pCol = pTable->aCol) != 0) {
		for (i = 0; i<pTable->nCol; i++, pCol++) {
			sqlite3DbFree(db, pCol->zName);
			sqlite3ExprDelete(db, pCol->pDflt);
			sqlite3DbFree(db, pCol->zColl);
		}
		sqlite3DbFree(db, pTable->aCol);
	}
}


static void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable) {
	Index *pIndex, *pNext;
	TESTONLY(int nLookaside; ) 

							   
		TESTONLY(nLookaside = (db && (pTable->tabFlags & TF_Ephemeral) == 0) ?
			db->lookaside.nOut : 0);

	
	for (pIndex = pTable->pIndex; pIndex; pIndex = pNext) {
		pNext = pIndex->pNext;
		assert(pIndex->pSchema == pTable->pSchema
			|| (IsVirtual(pTable) && pIndex->idxType != SQLITE_IDXTYPE_APPDEF));
		if ((db == 0 || db->pnBytesFreed == 0) && !IsVirtual(pTable)) {
			char *zName = pIndex->zName;
			TESTONLY(Index *pOld = ) sqlite3HashInsert(
				&pIndex->pSchema->idxHash, zName, 0
			);
			assert(db == 0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema));
			assert(pOld == pIndex || pOld == 0);
		}
		freeIndex(db, pIndex);
	}

	
	sqlite3FkDelete(db, pTable);

	
	sqlite3DeleteColumnNames(db, pTable);
	sqlite3DbFree(db, pTable->zName);
	sqlite3DbFree(db, pTable->zColAff);
	sqlite3SelectDelete(db, pTable->pSelect);
	sqlite3ExprListDelete(db, pTable->pCheck);
#ifndef SQLITE_OMIT_VIRTUALTABLE
	sqlite3VtabClear(db, pTable);
#endif
	sqlite3DbFree(db, pTable);

	
	assert(nLookaside == 0 || nLookaside == db->lookaside.nOut);
}
SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3 *db, Table *pTable) {
	
	if (!pTable) return;
	if (((!db || db->pnBytesFreed == 0) && (--pTable->nRef)>0)) return;
	deleteTable(db, pTable);
}



SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName) {
	Table *p;
	Db *pDb;

	assert(db != 0);
	assert(iDb >= 0 && iDb<db->nDb);
	assert(zTabName);
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	testcase(zTabName[0] == 0);  
	pDb = &db->aDb[iDb];
	p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);
	sqlite3DeleteTable(db, p);
	db->flags |= SQLITE_InternChanges;
}


SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, Token *pName) {
	char *zName;
	if (pName) {
		zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);
		sqlite3Dequote(zName);
	}
	else {
		zName = 0;
	}
	return zName;
}


SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *p, int iDb) {
	Vdbe *v = sqlite3GetVdbe(p);
	sqlite3TableLock(p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE(iDb));
	sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, MASTER_ROOT, iDb, 5);
	if (p->nTab == 0) {
		p->nTab = 1;
	}
}


SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *db, const char *zName) {
	int i = -1;         
	if (zName) {
		Db *pDb;
		for (i = (db->nDb - 1), pDb = &db->aDb[i]; i >= 0; i--, pDb--) {
			if (0 == sqlite3StrICmp(pDb->zDbSName, zName)) break;
		}
	}
	return i;
}


SQLITE_PRIVATE int sqlite3FindDb(sqlite3 *db, Token *pName) {
	int i;                               
	char *zName;                         
	zName = sqlite3NameFromToken(db, pName);
	i = sqlite3FindDbName(db, zName);
	sqlite3DbFree(db, zName);
	return i;
}


SQLITE_PRIVATE int sqlite3TwoPartName(
	Parse *pParse,      
	Token *pName1,      
	Token *pName2,      
	Token **pUnqual     
) {
	int iDb;                    
	sqlite3 *db = pParse->db;

	assert(pName2 != 0);
	if (pName2->n>0) {
		if (db->init.busy) {
			sqlite3ErrorMsg(pParse, "corrupt database");
			return -1;
		}
		*pUnqual = pName2;
		iDb = sqlite3FindDb(db, pName1);
		if (iDb<0) {
			sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
			return -1;
		}
	}
	else {
		assert(db->init.iDb == 0 || db->init.busy || (db->flags & SQLITE_Vacuum) != 0);
		iDb = db->init.iDb;
		*pUnqual = pName1;
	}
	return iDb;
}


SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *pParse, const char *zName) {
	if (!pParse->db->init.busy && pParse->nested == 0
		&& (pParse->db->flags & SQLITE_WriteSchema) == 0
		&& 0 == sqlite3StrNICmp(zName, "sqlite_", 7)) {
		sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
		return SQLITE_ERROR;
	}
	return SQLITE_OK;
}


SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table *pTab) {
	Index *p;
	for (p = pTab->pIndex; p && !IsPrimaryKeyIndex(p); p = p->pNext) {}
	return p;
}


SQLITE_PRIVATE i16 sqlite3ColumnOfIndex(Index *pIdx, i16 iCol) {
	int i;
	for (i = 0; i<pIdx->nColumn; i++) {
		if (iCol == pIdx->aiColumn[i]) return i;
	}
	return -1;
}


SQLITE_PRIVATE void sqlite3StartTable(
	Parse *pParse,   
	Token *pName1,   
	Token *pName2,   
	int isTemp,      
	int isView,      
	int isVirtual,   
	int noErr        
) {
	Table *pTable;
	char *zName = 0; 
	sqlite3 *db = pParse->db;
	Vdbe *v;
	int iDb;         
	Token *pName;    

	if (db->init.busy && db->init.newTnum == 1) {
		
		iDb = db->init.iDb;
		zName = sqlite3DbStrDup(db, SCHEMA_TABLE(iDb));
		pName = pName1;
	}
	else {
		
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
		if (iDb<0) return;
		if (!OMIT_TEMPDB && isTemp && pName2->n>0 && iDb != 1) {
			
			sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
			return;
		}
		if (!OMIT_TEMPDB && isTemp) iDb = 1;
		zName = sqlite3NameFromToken(db, pName);
	}
	pParse->sNameToken = *pName;
	if (zName == 0) return;
	if (SQLITE_OK != sqlite3CheckObjectName(pParse, zName)) {
		goto begin_table_error;
	}
	if (db->init.iDb == 1) isTemp = 1;
#ifndef SQLITE_OMIT_AUTHORIZATION
	assert(isTemp == 0 || isTemp == 1);
	assert(isView == 0 || isView == 1);
	{
		static const u8 aCode[] = {
			SQLITE_CREATE_TABLE,
			SQLITE_CREATE_TEMP_TABLE,
			SQLITE_CREATE_VIEW,
			SQLITE_CREATE_TEMP_VIEW
		};
		char *zDb = db->aDb[iDb].zDbSName;
		if (sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb)) {
			goto begin_table_error;
		}
		if (!isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp + 2 * isView],
			zName, 0, zDb)) {
			goto begin_table_error;
		}
	}
#endif

	
	if (!IN_DECLARE_VTAB) {
		char *zDb = db->aDb[iDb].zDbSName;
		if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
			goto begin_table_error;
		}
		pTable = sqlite3FindTable(db, zName, zDb);
		if (pTable) {
			if (!noErr) {
				sqlite3ErrorMsg(pParse, "table %T already exists", pName);
			}
			else {
				assert(!db->init.busy || CORRUPT_DB);
				sqlite3CodeVerifySchema(pParse, iDb);
			}
			goto begin_table_error;
		}
		if (sqlite3FindIndex(db, zName, zDb) != 0) {
			sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
			goto begin_table_error;
		}
	}

	pTable = sqlite3DbMallocZero(db, sizeof(Table));
	if (pTable == 0) {
		assert(db->mallocFailed);
		pParse->rc = SQLITE_NOMEM_BKPT;
		pParse->nErr++;
		goto begin_table_error;
	}
	pTable->zName = zName;
	pTable->iPKey = -1;
	pTable->pSchema = db->aDb[iDb].pSchema;
	pTable->nRef = 1;
	pTable->nRowLogEst = 200; assert(200 == sqlite3LogEst(1048576));
	assert(pParse->pNewTable == 0);
	pParse->pNewTable = pTable;

	
#ifndef SQLITE_OMIT_AUTOINCREMENT
	if (!pParse->nested && strcmp(zName, "sqlite_sequence") == 0) {
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		pTable->pSchema->pSeqTab = pTable;
	}
#endif

	
	if (!db->init.busy && (v = sqlite3GetVdbe(pParse)) != 0) {
		int addr1;
		int fileFormat;
		int reg1, reg2, reg3;
		
		static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };
		sqlite3BeginWriteOperation(pParse, 1, iDb);

#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (isVirtual) {
			sqlite3VdbeAddOp0(v, OP_VBegin);
		}
#endif

		
		reg1 = pParse->regRowid = ++pParse->nMem;
		reg2 = pParse->regRoot = ++pParse->nMem;
		reg3 = ++pParse->nMem;
		sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);
		sqlite3VdbeUsesBtree(v, iDb);
		addr1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);
		fileFormat = (db->flags & SQLITE_LegacyFileFmt) != 0 ?
			1 : SQLITE_MAX_FILE_FORMAT;
		sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, fileFormat);
		sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, ENC(db));
		sqlite3VdbeJumpHere(v, addr1);

		
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
		if (isView || isVirtual) {
			sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2);
		}
		else
#endif
		{
			pParse->addrCrTab = sqlite3VdbeAddOp2(v, OP_CreateTable, iDb, reg2);
		}
		sqlite3OpenMasterTable(pParse, iDb);
		sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);
		sqlite3VdbeAddOp4(v, OP_Blob, 6, reg3, 0, nullRow, P4_STATIC);
		sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);
		sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
		sqlite3VdbeAddOp0(v, OP_Close);
	}

	
	return;

	
begin_table_error:
	sqlite3DbFree(db, zName);
	return;
}


#if SQLITE_ENABLE_HIDDEN_COLUMNS
SQLITE_PRIVATE void sqlite3ColumnPropertiesFromName(Table *pTab, Column *pCol) {
	if (sqlite3_strnicmp(pCol->zName, "__hidden__", 10) == 0) {
		pCol->colFlags |= COLFLAG_HIDDEN;
	}
	else if (pTab && pCol != pTab->aCol && (pCol[-1].colFlags & COLFLAG_HIDDEN)) {
		pTab->tabFlags |= TF_OOOHidden;
	}
}
#endif



SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token *pName, Token *pType) {
	Table *p;
	int i;
	char *z;
	char *zType;
	Column *pCol;
	sqlite3 *db = pParse->db;
	if ((p = pParse->pNewTable) == 0) return;
#if SQLITE_MAX_COLUMN
	if (p->nCol + 1>db->aLimit[SQLITE_LIMIT_COLUMN]) {
		sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
		return;
	}
#endif
	z = sqlite3DbMallocRaw(db, pName->n + pType->n + 2);
	if (z == 0) return;
	memcpy(z, pName->z, pName->n);
	z[pName->n] = 0;
	sqlite3Dequote(z);
	for (i = 0; i<p->nCol; i++) {
		if (sqlite3_stricmp(z, p->aCol[i].zName) == 0) {
			sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
			sqlite3DbFree(db, z);
			return;
		}
	}
	if ((p->nCol & 0x7) == 0) {
		Column *aNew;
		aNew = sqlite3DbRealloc(db, p->aCol, (p->nCol + 8) * sizeof(p->aCol[0]));
		if (aNew == 0) {
			sqlite3DbFree(db, z);
			return;
		}
		p->aCol = aNew;
	}
	pCol = &p->aCol[p->nCol];
	memset(pCol, 0, sizeof(p->aCol[0]));
	pCol->zName = z;
	sqlite3ColumnPropertiesFromName(p, pCol);

	if (pType->n == 0) {
		
		pCol->affinity = SQLITE_AFF_BLOB;
		pCol->szEst = 1;
	}
	else {
		zType = z + sqlite3Strlen30(z) + 1;
		memcpy(zType, pType->z, pType->n);
		zType[pType->n] = 0;
		sqlite3Dequote(zType);
		pCol->affinity = sqlite3AffinityType(zType, &pCol->szEst);
		pCol->colFlags |= COLFLAG_HASTYPE;
	}
	p->nCol++;
	pParse->constraintName.n = 0;
}


SQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError) {
	Table *p;
	p = pParse->pNewTable;
	if (p == 0 || NEVER(p->nCol<1)) return;
	p->aCol[p->nCol - 1].notNull = (u8)onError;
}


SQLITE_PRIVATE char sqlite3AffinityType(const char *zIn, u8 *pszEst) {
	u32 h = 0;
	char aff = SQLITE_AFF_NUMERIC;
	const char *zChar = 0;

	assert(zIn != 0);
	while (zIn[0]) {
		h = (h << 8) + sqlite3UpperToLower[(*zIn) & 0xff];
		zIn++;
		if (h == (('c' << 24) + ('h' << 16) + ('a' << 8) + 'r')) {             
			aff = SQLITE_AFF_TEXT;
			zChar = zIn;
		}
		else if (h == (('c' << 24) + ('l' << 16) + ('o' << 8) + 'b')) {       
			aff = SQLITE_AFF_TEXT;
		}
		else if (h == (('t' << 24) + ('e' << 16) + ('x' << 8) + 't')) {       
			aff = SQLITE_AFF_TEXT;
		}
		else if (h == (('b' << 24) + ('l' << 16) + ('o' << 8) + 'b')          
			&& (aff == SQLITE_AFF_NUMERIC || aff == SQLITE_AFF_REAL)) {
			aff = SQLITE_AFF_BLOB;
			if (zIn[0] == '(') zChar = zIn;
#ifndef SQLITE_OMIT_FLOATING_POINT
		}
		else if (h == (('r' << 24) + ('e' << 16) + ('a' << 8) + 'l')          
			&& aff == SQLITE_AFF_NUMERIC) {
			aff = SQLITE_AFF_REAL;
		}
		else if (h == (('f' << 24) + ('l' << 16) + ('o' << 8) + 'a')          
			&& aff == SQLITE_AFF_NUMERIC) {
			aff = SQLITE_AFF_REAL;
		}
		else if (h == (('d' << 24) + ('o' << 16) + ('u' << 8) + 'b')          
			&& aff == SQLITE_AFF_NUMERIC) {
			aff = SQLITE_AFF_REAL;
#endif
		}
		else if ((h & 0x00FFFFFF) == (('i' << 16) + ('n' << 8) + 't')) {    
			aff = SQLITE_AFF_INTEGER;
			break;
		}
	}

	
	if (pszEst) {
		*pszEst = 1;   
		if (aff<SQLITE_AFF_NUMERIC) {
			if (zChar) {
				while (zChar[0]) {
					if (sqlite3Isdigit(zChar[0])) {
						int v = 0;
						sqlite3GetInt32(zChar, &v);
						v = v / 4 + 1;
						if (v>255) v = 255;
						*pszEst = v; 
						break;
					}
					zChar++;
				}
			}
			else {
				*pszEst = 5;   
			}
		}
	}
	return aff;
}


SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan) {
	Table *p;
	Column *pCol;
	sqlite3 *db = pParse->db;
	p = pParse->pNewTable;
	if (p != 0) {
		pCol = &(p->aCol[p->nCol - 1]);
		if (!sqlite3ExprIsConstantOrFunction(pSpan->pExpr, db->init.busy)) {
			sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant",
				pCol->zName);
		}
		else {
			
			Expr x;
			sqlite3ExprDelete(db, pCol->pDflt);
			memset(&x, 0, sizeof(x));
			x.op = TK_SPAN;
			x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,
				(int)(pSpan->zEnd - pSpan->zStart));
			x.pLeft = pSpan->pExpr;
			x.flags = EP_Skip;
			pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);
			sqlite3DbFree(db, x.u.zToken);
		}
	}
	sqlite3ExprDelete(db, pSpan->pExpr);
}


static void sqlite3StringToId(Expr *p) {
	if (p->op == TK_STRING) {
		p->op = TK_ID;
	}
	else if (p->op == TK_COLLATE && p->pLeft->op == TK_STRING) {
		p->pLeft->op = TK_ID;
	}
}


SQLITE_PRIVATE void sqlite3AddPrimaryKey(
	Parse *pParse,    
	ExprList *pList,  
	int onError,      
	int autoInc,      
	int sortOrder     
) {
	Table *pTab = pParse->pNewTable;
	Column *pCol = 0;
	int iCol = -1, i;
	int nTerm;
	if (pTab == 0) goto primary_key_exit;
	if (pTab->tabFlags & TF_HasPrimaryKey) {
		sqlite3ErrorMsg(pParse,
			"table \"%s\" has more than one primary key", pTab->zName);
		goto primary_key_exit;
	}
	pTab->tabFlags |= TF_HasPrimaryKey;
	if (pList == 0) {
		iCol = pTab->nCol - 1;
		pCol = &pTab->aCol[iCol];
		pCol->colFlags |= COLFLAG_PRIMKEY;
		nTerm = 1;
	}
	else {
		nTerm = pList->nExpr;
		for (i = 0; i<nTerm; i++) {
			Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);
			assert(pCExpr != 0);
			sqlite3StringToId(pCExpr);
			if (pCExpr->op == TK_ID) {
				const char *zCName = pCExpr->u.zToken;
				for (iCol = 0; iCol<pTab->nCol; iCol++) {
					if (sqlite3StrICmp(zCName, pTab->aCol[iCol].zName) == 0) {
						pCol = &pTab->aCol[iCol];
						pCol->colFlags |= COLFLAG_PRIMKEY;
						break;
					}
				}
			}
		}
	}
	if (nTerm == 1
		&& pCol
		&& sqlite3StrICmp(sqlite3ColumnType(pCol, ""), "INTEGER") == 0
		&& sortOrder != SQLITE_SO_DESC
		) {
		pTab->iPKey = iCol;
		pTab->keyConf = (u8)onError;
		assert(autoInc == 0 || autoInc == 1);
		pTab->tabFlags |= autoInc*TF_Autoincrement;
		if (pList) pParse->iPkSortOrder = pList->a[0].sortOrder;
	}
	else if (autoInc) {
#ifndef SQLITE_OMIT_AUTOINCREMENT
		sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "
			"INTEGER PRIMARY KEY");
#endif
	}
	else {
		sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,
			0, sortOrder, 0, SQLITE_IDXTYPE_PRIMARYKEY);
		pList = 0;
	}

primary_key_exit:
	sqlite3ExprListDelete(pParse->db, pList);
	return;
}


SQLITE_PRIVATE void sqlite3AddCheckConstraint(
	Parse *pParse,    
	Expr *pCheckExpr  
) {
#ifndef SQLITE_OMIT_CHECK
	Table *pTab = pParse->pNewTable;
	sqlite3 *db = pParse->db;
	if (pTab && !IN_DECLARE_VTAB
		&& !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)
		) {
		pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);
		if (pParse->constraintName.n) {
			sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);
		}
	}
	else
#endif
	{
		sqlite3ExprDelete(pParse->db, pCheckExpr);
	}
}


SQLITE_PRIVATE void sqlite3AddCollateType(Parse *pParse, Token *pToken) {
	Table *p;
	int i;
	char *zColl;              
	sqlite3 *db;

	if ((p = pParse->pNewTable) == 0) return;
	i = p->nCol - 1;
	db = pParse->db;
	zColl = sqlite3NameFromToken(db, pToken);
	if (!zColl) return;

	if (sqlite3LocateCollSeq(pParse, zColl)) {
		Index *pIdx;
		sqlite3DbFree(db, p->aCol[i].zColl);
		p->aCol[i].zColl = zColl;

		
		for (pIdx = p->pIndex; pIdx; pIdx = pIdx->pNext) {
			assert(pIdx->nKeyCol == 1);
			if (pIdx->aiColumn[0] == i) {
				pIdx->azColl[0] = p->aCol[i].zColl;
			}
		}
	}
	else {
		sqlite3DbFree(db, zColl);
	}
}


SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName) {
	sqlite3 *db = pParse->db;
	u8 enc = ENC(db);
	u8 initbusy = db->init.busy;
	CollSeq *pColl;

	pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);
	if (!initbusy && (!pColl || !pColl->xCmp)) {
		pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);
	}

	return pColl;
}



SQLITE_PRIVATE void sqlite3ChangeCookie(Parse *pParse, int iDb) {
	sqlite3 *db = pParse->db;
	Vdbe *v = pParse->pVdbe;
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION,
		db->aDb[iDb].pSchema->schema_cookie + 1);
}


static int identLength(const char *z) {
	int n;
	for (n = 0; *z; n++, z++) {
		if (*z == '"') { n++; }
	}
	return n + 2;
}


static void identPut(char *z, int *pIdx, char *zSignedIdent) {
	unsigned char *zIdent = (unsigned char*)zSignedIdent;
	int i, j, needQuote;
	i = *pIdx;

	for (j = 0; zIdent[j]; j++) {
		if (!sqlite3Isalnum(zIdent[j]) && zIdent[j] != '_') break;
	}
	needQuote = sqlite3Isdigit(zIdent[0])
		|| sqlite3KeywordCode(zIdent, j) != TK_ID
		|| zIdent[j] != 0
		|| j == 0;

	if (needQuote) z[i++] = '"';
	for (j = 0; zIdent[j]; j++) {
		z[i++] = zIdent[j];
		if (zIdent[j] == '"') z[i++] = '"';
	}
	if (needQuote) z[i++] = '"';
	z[i] = 0;
	*pIdx = i;
}


static char *createTableStmt(sqlite3 *db, Table *p) {
	int i, k, n;
	char *zStmt;
	char *zSep, *zSep2, *zEnd;
	Column *pCol;
	n = 0;
	for (pCol = p->aCol, i = 0; i<p->nCol; i++, pCol++) {
		n += identLength(pCol->zName) + 5;
	}
	n += identLength(p->zName);
	if (n<50) {
		zSep = "";
		zSep2 = ",";
		zEnd = ")";
	}
	else {
		zSep = "\n  ";
		zSep2 = ",\n  ";
		zEnd = "\n)";
	}
	n += 35 + 6 * p->nCol;
	zStmt = sqlite3DbMallocRaw(0, n);
	if (zStmt == 0) {
		sqlite3OomFault(db);
		return 0;
	}
	sqlite3_snprintf(n, zStmt, "CREATE TABLE ");
	k = sqlite3Strlen30(zStmt);
	identPut(zStmt, &k, p->zName);
	zStmt[k++] = '(';
	for (pCol = p->aCol, i = 0; i<p->nCol; i++, pCol++) {
		static const char * const azType[] = {
			 "",
			 " TEXT",
			 " NUM",
			 " INT",
			 " REAL"
		};
		int len;
		const char *zType;

		sqlite3_snprintf(n - k, &zStmt[k], zSep);
		k += sqlite3Strlen30(&zStmt[k]);
		zSep = zSep2;
		identPut(zStmt, &k, pCol->zName);
		assert(pCol->affinity - SQLITE_AFF_BLOB >= 0);
		assert(pCol->affinity - SQLITE_AFF_BLOB < ArraySize(azType));
		testcase(pCol->affinity == SQLITE_AFF_BLOB);
		testcase(pCol->affinity == SQLITE_AFF_TEXT);
		testcase(pCol->affinity == SQLITE_AFF_NUMERIC);
		testcase(pCol->affinity == SQLITE_AFF_INTEGER);
		testcase(pCol->affinity == SQLITE_AFF_REAL);

		zType = azType[pCol->affinity - SQLITE_AFF_BLOB];
		len = sqlite3Strlen30(zType);
		assert(pCol->affinity == SQLITE_AFF_BLOB
			|| pCol->affinity == sqlite3AffinityType(zType, 0));
		memcpy(&zStmt[k], zType, len);
		k += len;
		assert(k <= n);
	}
	sqlite3_snprintf(n - k, &zStmt[k], "%s", zEnd);
	return zStmt;
}


static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N) {
	char *zExtra;
	int nByte;
	if (pIdx->nColumn >= N) return SQLITE_OK;
	assert(pIdx->isResized == 0);
	nByte = (sizeof(char*) + sizeof(i16) + 1)*N;
	zExtra = sqlite3DbMallocZero(db, nByte);
	if (zExtra == 0) return SQLITE_NOMEM_BKPT;
	memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
	pIdx->azColl = (const char**)zExtra;
	zExtra += sizeof(char*)*N;
	memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
	pIdx->aiColumn = (i16*)zExtra;
	zExtra += sizeof(i16)*N;
	memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
	pIdx->aSortOrder = (u8*)zExtra;
	pIdx->nColumn = N;
	pIdx->isResized = 1;
	return SQLITE_OK;
}


static void estimateTableWidth(Table *pTab) {
	unsigned wTable = 0;
	const Column *pTabCol;
	int i;
	for (i = pTab->nCol, pTabCol = pTab->aCol; i>0; i--, pTabCol++) {
		wTable += pTabCol->szEst;
	}
	if (pTab->iPKey<0) wTable++;
	pTab->szTabRow = sqlite3LogEst(wTable * 4);
}


static void estimateIndexWidth(Index *pIdx) {
	unsigned wIndex = 0;
	int i;
	const Column *aCol = pIdx->pTable->aCol;
	for (i = 0; i<pIdx->nColumn; i++) {
		i16 x = pIdx->aiColumn[i];
		assert(x<pIdx->pTable->nCol);
		wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;
	}
	pIdx->szIdxRow = sqlite3LogEst(wIndex * 4);
}


static int hasColumn(const i16 *aiCol, int nCol, int x) {
	while (nCol-- > 0) if (x == *(aiCol++)) return 1;
	return 0;
}


static void convertToWithoutRowidTable(Parse *pParse, Table *pTab) {
	Index *pIdx;
	Index *pPk;
	int nPk;
	int i, j;
	sqlite3 *db = pParse->db;
	Vdbe *v = pParse->pVdbe;

	
	if (!db->init.imposterTable) {
		for (i = 0; i<pTab->nCol; i++) {
			if ((pTab->aCol[i].colFlags & COLFLAG_PRIMKEY) != 0) {
				pTab->aCol[i].notNull = OE_Abort;
			}
		}
	}

	
	if (IN_DECLARE_VTAB) return;

	
	if (pParse->addrCrTab) {
		assert(v);
		sqlite3VdbeChangeOpcode(v, pParse->addrCrTab, OP_CreateIndex);
	}

	
	if (pTab->iPKey >= 0) {
		ExprList *pList;
		Token ipkToken;
		sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);
		pList = sqlite3ExprListAppend(pParse, 0,
			sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));
		if (pList == 0) return;
		pList->a[0].sortOrder = pParse->iPkSortOrder;
		assert(pParse->pNewTable == pTab);
		sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,
			SQLITE_IDXTYPE_PRIMARYKEY);
		if (db->mallocFailed) return;
		pPk = sqlite3PrimaryKeyIndex(pTab);
		pTab->iPKey = -1;
	}
	else {
		pPk = sqlite3PrimaryKeyIndex(pTab);

		
		if (v) {
			assert(db->init.busy == 0);
			sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);
		}

		
		for (i = j = 1; i<pPk->nKeyCol; i++) {
			if (hasColumn(pPk->aiColumn, j, pPk->aiColumn[i])) {
				pPk->nColumn--;
			}
			else {
				pPk->aiColumn[j++] = pPk->aiColumn[i];
			}
		}
		pPk->nKeyCol = j;
	}
	assert(pPk != 0);
	pPk->isCovering = 1;
	if (!db->init.imposterTable) pPk->uniqNotNull = 1;
	nPk = pPk->nKeyCol;

	
	pPk->tnum = pTab->tnum;

	
	for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
		int n;
		if (IsPrimaryKeyIndex(pIdx)) continue;
		for (i = n = 0; i<nPk; i++) {
			if (!hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i])) n++;
		}
		if (n == 0) {
			
			pIdx->nColumn = pIdx->nKeyCol;
			continue;
		}
		if (resizeIndexObject(db, pIdx, pIdx->nKeyCol + n)) return;
		for (i = 0, j = pIdx->nKeyCol; i<nPk; i++) {
			if (!hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i])) {
				pIdx->aiColumn[j] = pPk->aiColumn[i];
				pIdx->azColl[j] = pPk->azColl[i];
				j++;
			}
		}
		assert(pIdx->nColumn >= pIdx->nKeyCol + n);
		assert(pIdx->nColumn >= j);
	}

	
	if (nPk<pTab->nCol) {
		if (resizeIndexObject(db, pPk, pTab->nCol)) return;
		for (i = 0, j = nPk; i<pTab->nCol; i++) {
			if (!hasColumn(pPk->aiColumn, j, i)) {
				assert(j<pPk->nColumn);
				pPk->aiColumn[j] = i;
				pPk->azColl[j] = sqlite3StrBINARY;
				j++;
			}
		}
		assert(pPk->nColumn == j);
		assert(pTab->nCol == j);
	}
	else {
		pPk->nColumn = pTab->nCol;
	}
}


SQLITE_PRIVATE void sqlite3EndTable(
	Parse *pParse,          
	Token *pCons,           
	Token *pEnd,            
	u8 tabOpts,             
	Select *pSelect         
) {
	Table *p;                 
	sqlite3 *db = pParse->db; 
	int iDb;                  
	Index *pIdx;              

	if (pEnd == 0 && pSelect == 0) {
		return;
	}
	assert(!db->mallocFailed);
	p = pParse->pNewTable;
	if (p == 0) return;

	assert(!db->init.busy || !pSelect);

	
	if (db->init.busy) {
		p->tnum = db->init.newTnum;
		if (p->tnum == 1) p->tabFlags |= TF_Readonly;
	}

	
	if (tabOpts & TF_WithoutRowid) {
		if ((p->tabFlags & TF_Autoincrement)) {
			sqlite3ErrorMsg(pParse,
				"AUTOINCREMENT not allowed on WITHOUT ROWID tables");
			return;
		}
		if ((p->tabFlags & TF_HasPrimaryKey) == 0) {
			sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p->zName);
		}
		else {
			p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;
			convertToWithoutRowidTable(pParse, p);
		}
	}

	iDb = sqlite3SchemaToIndex(db, p->pSchema);

#ifndef SQLITE_OMIT_CHECK
	
	if (p->pCheck) {
		sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);
	}
#endif 

	
	estimateTableWidth(p);
	for (pIdx = p->pIndex; pIdx; pIdx = pIdx->pNext) {
		estimateIndexWidth(pIdx);
	}

	
	if (!db->init.busy) {
		int n;
		Vdbe *v;
		char *zType;    
		char *zType2;   
		char *zStmt;    

		v = sqlite3GetVdbe(pParse);
		if (NEVER(v == 0)) return;

		sqlite3VdbeAddOp1(v, OP_Close, 0);

		
		if (p->pSelect == 0) {
			
			zType = "table";
			zType2 = "TABLE";
#ifndef SQLITE_OMIT_VIEW
		}
		else {
			
			zType = "view";
			zType2 = "VIEW";
#endif
		}

		
		if (pSelect) {
			SelectDest dest;    
			int regYield;       
			int addrTop;        
			int regRec;         
			int regRowid;       
			int addrInsLoop;    
			Table *pSelTab;     

			regYield = ++pParse->nMem;
			regRec = ++pParse->nMem;
			regRowid = ++pParse->nMem;
			assert(pParse->nTab == 1);
			sqlite3MayAbort(pParse);
			sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);
			sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);
			pParse->nTab = 2;
			addrTop = sqlite3VdbeCurrentAddr(v) + 1;
			sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
			sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
			sqlite3Select(pParse, pSelect, &dest);
			sqlite3VdbeEndCoroutine(v, regYield);
			sqlite3VdbeJumpHere(v, addrTop - 1);
			if (pParse->nErr) return;
			pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect);
			if (pSelTab == 0) return;
			assert(p->aCol == 0);
			p->nCol = pSelTab->nCol;
			p->aCol = pSelTab->aCol;
			pSelTab->nCol = 0;
			pSelTab->aCol = 0;
			sqlite3DeleteTable(db, pSelTab);
			addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
			VdbeCoverage(v);
			sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);
			sqlite3TableAffinity(v, p, 0);
			sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);
			sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);
			sqlite3VdbeGoto(v, addrInsLoop);
			sqlite3VdbeJumpHere(v, addrInsLoop);
			sqlite3VdbeAddOp1(v, OP_Close, 1);
		}

		
		if (pSelect) {
			zStmt = createTableStmt(db, p);
		}
		else {
			Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
			n = (int)(pEnd2->z - pParse->sNameToken.z);
			if (pEnd2->z[0] != ';') n += pEnd2->n;
			zStmt = sqlite3MPrintf(db,
				"CREATE %s %.*s", zType2, n, pParse->sNameToken.z
			);
		}

		
		sqlite3NestedParse(pParse,
			"UPDATE %Q.%s "
			"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q "
			"WHERE rowid=#%d",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb),
			zType,
			p->zName,
			p->zName,
			pParse->regRoot,
			zStmt,
			pParse->regRowid
		);
		sqlite3DbFree(db, zStmt);
		sqlite3ChangeCookie(pParse, iDb);

#ifndef SQLITE_OMIT_AUTOINCREMENT
		
		if ((p->tabFlags & TF_Autoincrement) != 0) {
			Db *pDb = &db->aDb[iDb];
			assert(sqlite3SchemaMutexHeld(db, iDb, 0));
			if (pDb->pSchema->pSeqTab == 0) {
				sqlite3NestedParse(pParse,
					"CREATE TABLE %Q.sqlite_sequence(name,seq)",
					pDb->zDbSName
				);
			}
		}
#endif

		
		sqlite3VdbeAddParseSchemaOp(v, iDb,
			sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p->zName));
	}


	
	if (db->init.busy) {
		Table *pOld;
		Schema *pSchema = p->pSchema;
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
		if (pOld) {
			assert(p == pOld);  
			sqlite3OomFault(db);
			return;
		}
		pParse->pNewTable = 0;
		db->flags |= SQLITE_InternChanges;

#ifndef SQLITE_OMIT_ALTERTABLE
		if (!p->pSelect) {
			const char *zName = (const char *)pParse->sNameToken.z;
			int nName;
			assert(!pSelect && pCons && pEnd);
			if (pCons->z == 0) {
				pCons = pEnd;
			}
			nName = (int)((const char *)pCons->z - zName);
			p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
		}
#endif
	}
}

#ifndef SQLITE_OMIT_VIEW

SQLITE_PRIVATE void sqlite3CreateView(
	Parse *pParse,     
	Token *pBegin,     
	Token *pName1,     
	Token *pName2,     
	ExprList *pCNames, 
	Select *pSelect,   
	int isTemp,        
	int noErr          
) {
	Table *p;
	int n;
	const char *z;
	Token sEnd;
	DbFixer sFix;
	Token *pName = 0;
	int iDb;
	sqlite3 *db = pParse->db;

	if (pParse->nVar>0) {
		sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
		goto create_view_fail;
	}
	sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
	p = pParse->pNewTable;
	if (p == 0 || pParse->nErr) goto create_view_fail;
	sqlite3TwoPartName(pParse, pName1, pName2, &pName);
	iDb = sqlite3SchemaToIndex(db, p->pSchema);
	sqlite3FixInit(&sFix, pParse, iDb, "view", pName);
	if (sqlite3FixSelect(&sFix, pSelect)) goto create_view_fail;

	
	p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
	p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);
	if (db->mallocFailed) goto create_view_fail;

	
	sEnd = pParse->sLastToken;
	assert(sEnd.z[0] != 0);
	if (sEnd.z[0] != ';') {
		sEnd.z += sEnd.n;
	}
	sEnd.n = 0;
	n = (int)(sEnd.z - pBegin->z);
	assert(n>0);
	z = pBegin->z;
	while (sqlite3Isspace(z[n - 1])) { n--; }
	sEnd.z = &z[n - 1];
	sEnd.n = 1;

	
	sqlite3EndTable(pParse, 0, &sEnd, 0, 0);

create_view_fail:
	sqlite3SelectDelete(db, pSelect);
	sqlite3ExprListDelete(db, pCNames);
	return;
}
#endif 

#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)

SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable) {
	Table *pSelTab;   
	Select *pSel;     
	int nErr = 0;     
	int n;            
	sqlite3 *db = pParse->db;  
#ifndef SQLITE_OMIT_AUTHORIZATION
	sqlite3_xauth xAuth;       
#endif

	assert(pTable);

#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (sqlite3VtabCallConnect(pParse, pTable)) {
		return SQLITE_ERROR;
	}
	if (IsVirtual(pTable)) return 0;
#endif

#ifndef SQLITE_OMIT_VIEW
	
	if (pTable->nCol>0) return 0;

	
	if (pTable->nCol<0) {
		sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
		return 1;
	}
	assert(pTable->nCol >= 0);

	
	assert(pTable->pSelect);
	pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
	if (pSel) {
		n = pParse->nTab;
		sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
		pTable->nCol = -1;
		db->lookaside.bDisable++;
#ifndef SQLITE_OMIT_AUTHORIZATION
		xAuth = db->xAuth;
		db->xAuth = 0;
		pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
		db->xAuth = xAuth;
#else
		pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
#endif
		pParse->nTab = n;
		if (pTable->pCheck) {
			
			sqlite3ColumnsFromExprList(pParse, pTable->pCheck,
				&pTable->nCol, &pTable->aCol);
			if (db->mallocFailed == 0
				&& pParse->nErr == 0
				&& pTable->nCol == pSel->pEList->nExpr
				) {
				sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel);
			}
		}
		else if (pSelTab) {
			
			assert(pTable->aCol == 0);
			pTable->nCol = pSelTab->nCol;
			pTable->aCol = pSelTab->aCol;
			pSelTab->nCol = 0;
			pSelTab->aCol = 0;
			assert(sqlite3SchemaMutexHeld(db, 0, pTable->pSchema));
		}
		else {
			pTable->nCol = 0;
			nErr++;
		}
		sqlite3DeleteTable(db, pSelTab);
		sqlite3SelectDelete(db, pSel);
		db->lookaside.bDisable--;
	}
	else {
		nErr++;
	}
	pTable->pSchema->schemaFlags |= DB_UnresetViews;
#endif 
	return nErr;
}
#endif 

#ifndef SQLITE_OMIT_VIEW

static void sqliteViewResetAll(sqlite3 *db, int idx) {
	HashElem *i;
	assert(sqlite3SchemaMutexHeld(db, idx, 0));
	if (!DbHasProperty(db, idx, DB_UnresetViews)) return;
	for (i = sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i; i = sqliteHashNext(i)) {
		Table *pTab = sqliteHashData(i);
		if (pTab->pSelect) {
			sqlite3DeleteColumnNames(db, pTab);
			pTab->aCol = 0;
			pTab->nCol = 0;
		}
	}
	DbClearProperty(db, idx, DB_UnresetViews);
}
#else
# define sqliteViewResetAll(A,B)
#endif 


#ifndef SQLITE_OMIT_AUTOVACUUM
SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo) {
	HashElem *pElem;
	Hash *pHash;
	Db *pDb;

	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	pDb = &db->aDb[iDb];
	pHash = &pDb->pSchema->tblHash;
	for (pElem = sqliteHashFirst(pHash); pElem; pElem = sqliteHashNext(pElem)) {
		Table *pTab = sqliteHashData(pElem);
		if (pTab->tnum == iFrom) {
			pTab->tnum = iTo;
		}
	}
	pHash = &pDb->pSchema->idxHash;
	for (pElem = sqliteHashFirst(pHash); pElem; pElem = sqliteHashNext(pElem)) {
		Index *pIdx = sqliteHashData(pElem);
		if (pIdx->tnum == iFrom) {
			pIdx->tnum = iTo;
		}
	}
}
#endif


static void destroyRootPage(Parse *pParse, int iTable, int iDb) {
	Vdbe *v = sqlite3GetVdbe(pParse);
	int r1 = sqlite3GetTempReg(pParse);
	assert(iTable>1);
	sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);
	sqlite3MayAbort(pParse);
#ifndef SQLITE_OMIT_AUTOVACUUM
	
	sqlite3NestedParse(pParse,
		"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d",
		pParse->db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb), iTable, r1, r1);
#endif
	sqlite3ReleaseTempReg(pParse, r1);
}


static void destroyTable(Parse *pParse, Table *pTab) {
#ifdef SQLITE_OMIT_AUTOVACUUM
	Index *pIdx;
	int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
	destroyRootPage(pParse, pTab->tnum, iDb);
	for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
		destroyRootPage(pParse, pIdx->tnum, iDb);
	}
#else
	
	int iTab = pTab->tnum;
	int iDestroyed = 0;

	while (1) {
		Index *pIdx;
		int iLargest = 0;

		if (iDestroyed == 0 || iTab<iDestroyed) {
			iLargest = iTab;
		}
		for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
			int iIdx = pIdx->tnum;
			assert(pIdx->pSchema == pTab->pSchema);
			if ((iDestroyed == 0 || (iIdx<iDestroyed)) && iIdx>iLargest) {
				iLargest = iIdx;
			}
		}
		if (iLargest == 0) {
			return;
		}
		else {
			int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
			assert(iDb >= 0 && iDb<pParse->db->nDb);
			destroyRootPage(pParse, iLargest, iDb);
			iDestroyed = iLargest;
		}
	}
#endif
}


static void sqlite3ClearStatTables(
	Parse *pParse,         
	int iDb,               
	const char *zType,     
	const char *zName      
) {
	int i;
	const char *zDbName = pParse->db->aDb[iDb].zDbSName;
	for (i = 1; i <= 4; i++) {
		char zTab[24];
		sqlite3_snprintf(sizeof(zTab), zTab, "sqlite_stat%d", i);
		if (sqlite3FindTable(pParse->db, zTab, zDbName)) {
			sqlite3NestedParse(pParse,
				"DELETE FROM %Q.%s WHERE %s=%Q",
				zDbName, zTab, zType, zName
			);
		}
	}
}


SQLITE_PRIVATE void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView) {
	Vdbe *v;
	sqlite3 *db = pParse->db;
	Trigger *pTrigger;
	Db *pDb = &db->aDb[iDb];

	v = sqlite3GetVdbe(pParse);
	assert(v != 0);
	sqlite3BeginWriteOperation(pParse, 1, iDb);

#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (IsVirtual(pTab)) {
		sqlite3VdbeAddOp0(v, OP_VBegin);
	}
#endif

	
	pTrigger = sqlite3TriggerList(pParse, pTab);
	while (pTrigger) {
		assert(pTrigger->pSchema == pTab->pSchema ||
			pTrigger->pSchema == db->aDb[1].pSchema);
		sqlite3DropTriggerPtr(pParse, pTrigger);
		pTrigger = pTrigger->pNext;
	}

#ifndef SQLITE_OMIT_AUTOINCREMENT
	
	if (pTab->tabFlags & TF_Autoincrement) {
		sqlite3NestedParse(pParse,
			"DELETE FROM %Q.sqlite_sequence WHERE name=%Q",
			pDb->zDbSName, pTab->zName
		);
	}
#endif

	
	sqlite3NestedParse(pParse,
		"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'",
		pDb->zDbSName, SCHEMA_TABLE(iDb), pTab->zName);
	if (!isView && !IsVirtual(pTab)) {
		destroyTable(pParse, pTab);
	}

	
	if (IsVirtual(pTab)) {
		sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0);
	}
	sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);
	sqlite3ChangeCookie(pParse, iDb);
	sqliteViewResetAll(db, iDb);
}


SQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr) {
	Table *pTab;
	Vdbe *v;
	sqlite3 *db = pParse->db;
	int iDb;

	if (db->mallocFailed) {
		goto exit_drop_table;
	}
	assert(pParse->nErr == 0);
	assert(pName->nSrc == 1);
	if (sqlite3ReadSchema(pParse)) goto exit_drop_table;
	if (noErr) db->suppressErr++;
	assert(isView == 0 || isView == LOCATE_VIEW);
	pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);
	if (noErr) db->suppressErr--;

	if (pTab == 0) {
		if (noErr) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
		goto exit_drop_table;
	}
	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	assert(iDb >= 0 && iDb<db->nDb);

	
	if (IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab)) {
		goto exit_drop_table;
	}
#ifndef SQLITE_OMIT_AUTHORIZATION
	{
		int code;
		const char *zTab = SCHEMA_TABLE(iDb);
		const char *zDb = db->aDb[iDb].zDbSName;
		const char *zArg2 = 0;
		if (sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)) {
			goto exit_drop_table;
		}
		if (isView) {
			if (!OMIT_TEMPDB && iDb == 1) {
				code = SQLITE_DROP_TEMP_VIEW;
			}
			else {
				code = SQLITE_DROP_VIEW;
			}
#ifndef SQLITE_OMIT_VIRTUALTABLE
		}
		else if (IsVirtual(pTab)) {
			code = SQLITE_DROP_VTABLE;
			zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;
#endif
		}
		else {
			if (!OMIT_TEMPDB && iDb == 1) {
				code = SQLITE_DROP_TEMP_TABLE;
			}
			else {
				code = SQLITE_DROP_TABLE;
			}
		}
		if (sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb)) {
			goto exit_drop_table;
		}
		if (sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb)) {
			goto exit_drop_table;
		}
	}
#endif
	if (sqlite3StrNICmp(pTab->zName, "sqlite_", 7) == 0
		&& sqlite3StrNICmp(pTab->zName, "sqlite_stat", 11) != 0) {
		sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
		goto exit_drop_table;
	}

#ifndef SQLITE_OMIT_VIEW
	
	if (isView && pTab->pSelect == 0) {
		sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
		goto exit_drop_table;
	}
	if (!isView && pTab->pSelect) {
		sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
		goto exit_drop_table;
	}
#endif

	
	v = sqlite3GetVdbe(pParse);
	if (v) {
		sqlite3BeginWriteOperation(pParse, 1, iDb);
		sqlite3ClearStatTables(pParse, iDb, "tbl", pTab->zName);
		sqlite3FkDropTable(pParse, pName, pTab);
		sqlite3CodeDropTable(pParse, pTab, iDb, isView);
	}

exit_drop_table:
	sqlite3SrcListDelete(db, pName);
}


SQLITE_PRIVATE void sqlite3CreateForeignKey(
	Parse *pParse,       
	ExprList *pFromCol,  
	Token *pTo,          
	ExprList *pToCol,    
	int flags            
) {
	sqlite3 *db = pParse->db;
#ifndef SQLITE_OMIT_FOREIGN_KEY
	FKey *pFKey = 0;
	FKey *pNextTo;
	Table *p = pParse->pNewTable;
	int nByte;
	int i;
	int nCol;
	char *z;

	assert(pTo != 0);
	if (p == 0 || IN_DECLARE_VTAB) goto fk_end;
	if (pFromCol == 0) {
		int iCol = p->nCol - 1;
		if (NEVER(iCol<0)) goto fk_end;
		if (pToCol && pToCol->nExpr != 1) {
			sqlite3ErrorMsg(pParse, "foreign key on %s"
				" should reference only one column of table %T",
				p->aCol[iCol].zName, pTo);
			goto fk_end;
		}
		nCol = 1;
	}
	else if (pToCol && pToCol->nExpr != pFromCol->nExpr) {
		sqlite3ErrorMsg(pParse,
			"number of columns in foreign key does not match the number of "
			"columns in the referenced table");
		goto fk_end;
	}
	else {
		nCol = pFromCol->nExpr;
	}
	nByte = sizeof(*pFKey) + (nCol - 1) * sizeof(pFKey->aCol[0]) + pTo->n + 1;
	if (pToCol) {
		for (i = 0; i<pToCol->nExpr; i++) {
			nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;
		}
	}
	pFKey = sqlite3DbMallocZero(db, nByte);
	if (pFKey == 0) {
		goto fk_end;
	}
	pFKey->pFrom = p;
	pFKey->pNextFrom = p->pFKey;
	z = (char*)&pFKey->aCol[nCol];
	pFKey->zTo = z;
	memcpy(z, pTo->z, pTo->n);
	z[pTo->n] = 0;
	sqlite3Dequote(z);
	z += pTo->n + 1;
	pFKey->nCol = nCol;
	if (pFromCol == 0) {
		pFKey->aCol[0].iFrom = p->nCol - 1;
	}
	else {
		for (i = 0; i<nCol; i++) {
			int j;
			for (j = 0; j<p->nCol; j++) {
				if (sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName) == 0) {
					pFKey->aCol[i].iFrom = j;
					break;
				}
			}
			if (j >= p->nCol) {
				sqlite3ErrorMsg(pParse,
					"unknown column \"%s\" in foreign key definition",
					pFromCol->a[i].zName);
				goto fk_end;
			}
		}
	}
	if (pToCol) {
		for (i = 0; i<nCol; i++) {
			int n = sqlite3Strlen30(pToCol->a[i].zName);
			pFKey->aCol[i].zCol = z;
			memcpy(z, pToCol->a[i].zName, n);
			z[n] = 0;
			z += n + 1;
		}
	}
	pFKey->isDeferred = 0;
	pFKey->aAction[0] = (u8)(flags & 0xff);            
	pFKey->aAction[1] = (u8)((flags >> 8) & 0xff);    

	assert(sqlite3SchemaMutexHeld(db, 0, p->pSchema));
	pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash,
		pFKey->zTo, (void *)pFKey
	);
	if (pNextTo == pFKey) {
		sqlite3OomFault(db);
		goto fk_end;
	}
	if (pNextTo) {
		assert(pNextTo->pPrevTo == 0);
		pFKey->pNextTo = pNextTo;
		pNextTo->pPrevTo = pFKey;
	}

	
	p->pFKey = pFKey;
	pFKey = 0;

fk_end:
	sqlite3DbFree(db, pFKey);
#endif 
	sqlite3ExprListDelete(db, pFromCol);
	sqlite3ExprListDelete(db, pToCol);
}


SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse *pParse, int isDeferred) {
#ifndef SQLITE_OMIT_FOREIGN_KEY
	Table *pTab;
	FKey *pFKey;
	if ((pTab = pParse->pNewTable) == 0 || (pFKey = pTab->pFKey) == 0) return;
	assert(isDeferred == 0 || isDeferred == 1); 
	pFKey->isDeferred = (u8)isDeferred;
#endif
}


static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage) {
	Table *pTab = pIndex->pTable;  
	int iTab = pParse->nTab++;     
	int iIdx = pParse->nTab++;     
	int iSorter;                   
	int addr1;                     
	int addr2;                     
	int tnum;                      
	int iPartIdxLabel;             
	Vdbe *v;                       
	KeyInfo *pKey;                 
	int regRecord;                 
	sqlite3 *db = pParse->db;      
	int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);

#ifndef SQLITE_OMIT_AUTHORIZATION
	if (sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,
		db->aDb[iDb].zDbSName)) {
		return;
	}
#endif

	
	sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);

	v = sqlite3GetVdbe(pParse);
	if (v == 0) return;
	if (memRootPage >= 0) {
		tnum = memRootPage;
	}
	else {
		tnum = pIndex->tnum;
	}
	pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
	assert(pKey != 0 || db->mallocFailed || pParse->nErr);

	
	iSorter = pParse->nTab++;
	sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, pIndex->nKeyCol, (char*)
		sqlite3KeyInfoRef(pKey), P4_KEYINFO);

	
	sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);
	addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeCoverage(v);
	regRecord = sqlite3GetTempReg(pParse);

	sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 0, &iPartIdxLabel, 0, 0);
	sqlite3VdbeAddOp2(v, OP_SorterInsert, iSorter, regRecord);
	sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
	sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1 + 1); VdbeCoverage(v);
	sqlite3VdbeJumpHere(v, addr1);
	if (memRootPage<0) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);
	sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb,
		(char *)pKey, P4_KEYINFO);
	sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR | ((memRootPage >= 0) ? OPFLAG_P2ISREG : 0));

	addr1 = sqlite3VdbeAddOp2(v, OP_SorterSort, iSorter, 0); VdbeCoverage(v);
	if (IsUniqueIndex(pIndex)) {
		int j2 = sqlite3VdbeCurrentAddr(v) + 3;
		sqlite3VdbeGoto(v, j2);
		addr2 = sqlite3VdbeCurrentAddr(v);
		sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,
			pIndex->nKeyCol); VdbeCoverage(v);
		sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);
	}
	else {
		addr2 = sqlite3VdbeCurrentAddr(v);
	}
	sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);
	sqlite3VdbeAddOp3(v, OP_Last, iIdx, 0, -1);
	sqlite3VdbeAddOp3(v, OP_IdxInsert, iIdx, regRecord, 0);
	sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
	sqlite3ReleaseTempReg(pParse, regRecord);
	sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);
	sqlite3VdbeJumpHere(v, addr1);

	sqlite3VdbeAddOp1(v, OP_Close, iTab);
	sqlite3VdbeAddOp1(v, OP_Close, iIdx);
	sqlite3VdbeAddOp1(v, OP_Close, iSorter);
}


SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(
	sqlite3 *db,         
	i16 nCol,            
	int nExtra,          
	char **ppExtra       
) {
	Index *p;            
	int nByte;           

	nByte = ROUND8(sizeof(Index)) +              
		ROUND8(sizeof(char*)*nCol) +         
		ROUND8(sizeof(LogEst)*(nCol + 1) +     
			sizeof(i16)*nCol +            
			sizeof(u8)*nCol);             
	p = sqlite3DbMallocZero(db, nByte + nExtra);
	if (p) {
		char *pExtra = ((char*)p) + ROUND8(sizeof(Index));
		p->azColl = (const char**)pExtra; pExtra += ROUND8(sizeof(char*)*nCol);
		p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol + 1);
		p->aiColumn = (i16*)pExtra;       pExtra += sizeof(i16)*nCol;
		p->aSortOrder = (u8*)pExtra;
		p->nColumn = nCol;
		p->nKeyCol = nCol - 1;
		*ppExtra = ((char*)p) + nByte;
	}
	return p;
}


SQLITE_PRIVATE void sqlite3CreateIndex(
	Parse *pParse,     
	Token *pName1,     
	Token *pName2,     
	SrcList *pTblName, 
	ExprList *pList,   
	int onError,       
	Token *pStart,     
	Expr *pPIWhere,    
	int sortOrder,     
	int ifNotExist,    
	u8 idxType         
) {
	Table *pTab = 0;     
	Index *pIndex = 0;   
	char *zName = 0;     
	int nName;           
	int i, j;
	DbFixer sFix;        
	int sortOrderMask;   
	sqlite3 *db = pParse->db;
	Db *pDb;             
	int iDb;             
	Token *pName = 0;    
	struct ExprList_item *pListItem; 
	int nExtra = 0;                  
	int nExtraCol;                   
	char *zExtra = 0;                
	Index *pPk = 0;      

	if (db->mallocFailed || pParse->nErr>0) {
		goto exit_create_index;
	}
	if (IN_DECLARE_VTAB && idxType != SQLITE_IDXTYPE_PRIMARYKEY) {
		goto exit_create_index;
	}
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		goto exit_create_index;
	}

	
	if (pTblName != 0) {

		
		assert(pName1 && pName2);
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
		if (iDb<0) goto exit_create_index;
		assert(pName && pName->z);

#ifndef SQLITE_OMIT_TEMPDB
		
		if (!db->init.busy) {
			pTab = sqlite3SrcListLookup(pParse, pTblName);
			if (pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {
				iDb = 1;
			}
		}
#endif

		sqlite3FixInit(&sFix, pParse, iDb, "index", pName);
		if (sqlite3FixSrcList(&sFix, pTblName)) {
			
			assert(0);
		}
		pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);
		assert(db->mallocFailed == 0 || pTab == 0);
		if (pTab == 0) goto exit_create_index;
		if (iDb == 1 && db->aDb[iDb].pSchema != pTab->pSchema) {
			sqlite3ErrorMsg(pParse,
				"cannot create a TEMP index on non-TEMP table \"%s\"",
				pTab->zName);
			goto exit_create_index;
		}
		if (!HasRowid(pTab)) pPk = sqlite3PrimaryKeyIndex(pTab);
	}
	else {
		assert(pName == 0);
		assert(pStart == 0);
		pTab = pParse->pNewTable;
		if (!pTab) goto exit_create_index;
		iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	}
	pDb = &db->aDb[iDb];

	assert(pTab != 0);
	assert(pParse->nErr == 0);
	if (sqlite3StrNICmp(pTab->zName, "sqlite_", 7) == 0
		&& db->init.busy == 0
#if SQLITE_USER_AUTHENTICATION
		&& sqlite3UserAuthTable(pTab->zName) == 0
#endif
		&& sqlite3StrNICmp(&pTab->zName[7], "altertab_", 9) != 0) {
		sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
		goto exit_create_index;
	}
#ifndef SQLITE_OMIT_VIEW
	if (pTab->pSelect) {
		sqlite3ErrorMsg(pParse, "views may not be indexed");
		goto exit_create_index;
	}
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (IsVirtual(pTab)) {
		sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
		goto exit_create_index;
	}
#endif

	
	if (pName) {
		zName = sqlite3NameFromToken(db, pName);
		if (zName == 0) goto exit_create_index;
		assert(pName->z != 0);
		if (SQLITE_OK != sqlite3CheckObjectName(pParse, zName)) {
			goto exit_create_index;
		}
		if (!db->init.busy) {
			if (sqlite3FindTable(db, zName, 0) != 0) {
				sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
				goto exit_create_index;
			}
		}
		if (sqlite3FindIndex(db, zName, pDb->zDbSName) != 0) {
			if (!ifNotExist) {
				sqlite3ErrorMsg(pParse, "index %s already exists", zName);
			}
			else {
				assert(!db->init.busy);
				sqlite3CodeVerifySchema(pParse, iDb);
			}
			goto exit_create_index;
		}
	}
	else {
		int n;
		Index *pLoop;
		for (pLoop = pTab->pIndex, n = 1; pLoop; pLoop = pLoop->pNext, n++) {}
		zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
		if (zName == 0) {
			goto exit_create_index;
		}

		
		if (IN_DECLARE_VTAB) zName[7]++;
	}

	
#ifndef SQLITE_OMIT_AUTHORIZATION
	{
		const char *zDb = pDb->zDbSName;
		if (sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb)) {
			goto exit_create_index;
		}
		i = SQLITE_CREATE_INDEX;
		if (!OMIT_TEMPDB && iDb == 1) i = SQLITE_CREATE_TEMP_INDEX;
		if (sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb)) {
			goto exit_create_index;
		}
	}
#endif

	
	if (pList == 0) {
		Token prevCol;
		sqlite3TokenInit(&prevCol, pTab->aCol[pTab->nCol - 1].zName);
		pList = sqlite3ExprListAppend(pParse, 0,
			sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));
		if (pList == 0) goto exit_create_index;
		assert(pList->nExpr == 1);
		sqlite3ExprListSetSortOrder(pList, sortOrder);
	}
	else {
		sqlite3ExprListCheckLength(pParse, pList, "index");
	}

	
	for (i = 0; i<pList->nExpr; i++) {
		Expr *pExpr = pList->a[i].pExpr;
		assert(pExpr != 0);
		if (pExpr->op == TK_COLLATE) {
			nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));
		}
	}

	
	nName = sqlite3Strlen30(zName);
	nExtraCol = pPk ? pPk->nKeyCol : 1;
	pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,
		nName + nExtra + 1, &zExtra);
	if (db->mallocFailed) {
		goto exit_create_index;
	}
	assert(EIGHT_BYTE_ALIGNMENT(pIndex->aiRowLogEst));
	assert(EIGHT_BYTE_ALIGNMENT(pIndex->azColl));
	pIndex->zName = zExtra;
	zExtra += nName + 1;
	memcpy(pIndex->zName, zName, nName + 1);
	pIndex->pTable = pTab;
	pIndex->onError = (u8)onError;
	pIndex->uniqNotNull = onError != OE_None;
	pIndex->idxType = idxType;
	pIndex->pSchema = db->aDb[iDb].pSchema;
	pIndex->nKeyCol = pList->nExpr;
	if (pPIWhere) {
		sqlite3ResolveSelfReference(pParse, pTab, NC_PartIdx, pPIWhere, 0);
		pIndex->pPartIdxWhere = pPIWhere;
		pPIWhere = 0;
	}
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));

	
	if (pDb->pSchema->file_format >= 4) {
		sortOrderMask = -1;   
	}
	else {
		sortOrderMask = 0;    
	}

	
	for (i = 0, pListItem = pList->a; i<pList->nExpr; i++, pListItem++) {
		Expr *pCExpr;                  
		int requestedSortOrder;        
		const char *zColl;             

		sqlite3StringToId(pListItem->pExpr);
		sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);
		if (pParse->nErr) goto exit_create_index;
		pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
		if (pCExpr->op != TK_COLUMN) {
			if (pTab == pParse->pNewTable) {
				sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and "
					"UNIQUE constraints");
				goto exit_create_index;
			}
			if (pIndex->aColExpr == 0) {
				ExprList *pCopy = sqlite3ExprListDup(db, pList, 0);
				pIndex->aColExpr = pCopy;
				if (!db->mallocFailed) {
					assert(pCopy != 0);
					pListItem = &pCopy->a[i];
				}
			}
			j = XN_EXPR;
			pIndex->aiColumn[i] = XN_EXPR;
			pIndex->uniqNotNull = 0;
		}
		else {
			j = pCExpr->iColumn;
			assert(j <= 0x7fff);
			if (j<0) {
				j = pTab->iPKey;
			}
			else if (pTab->aCol[j].notNull == 0) {
				pIndex->uniqNotNull = 0;
			}
			pIndex->aiColumn[i] = (i16)j;
		}
		zColl = 0;
		if (pListItem->pExpr->op == TK_COLLATE) {
			int nColl;
			zColl = pListItem->pExpr->u.zToken;
			nColl = sqlite3Strlen30(zColl) + 1;
			assert(nExtra >= nColl);
			memcpy(zExtra, zColl, nColl);
			zColl = zExtra;
			zExtra += nColl;
			nExtra -= nColl;
		}
		else if (j >= 0) {
			zColl = pTab->aCol[j].zColl;
		}
		if (!zColl) zColl = sqlite3StrBINARY;
		if (!db->init.busy && !sqlite3LocateCollSeq(pParse, zColl)) {
			goto exit_create_index;
		}
		pIndex->azColl[i] = zColl;
		requestedSortOrder = pListItem->sortOrder & sortOrderMask;
		pIndex->aSortOrder[i] = (u8)requestedSortOrder;
	}

	
	if (pPk) {
		for (j = 0; j<pPk->nKeyCol; j++) {
			int x = pPk->aiColumn[j];
			assert(x >= 0);
			if (hasColumn(pIndex->aiColumn, pIndex->nKeyCol, x)) {
				pIndex->nColumn--;
			}
			else {
				pIndex->aiColumn[i] = x;
				pIndex->azColl[i] = pPk->azColl[j];
				pIndex->aSortOrder[i] = pPk->aSortOrder[j];
				i++;
			}
		}
		assert(i == pIndex->nColumn);
	}
	else {
		pIndex->aiColumn[i] = XN_ROWID;
		pIndex->azColl[i] = sqlite3StrBINARY;
	}
	sqlite3DefaultRowEst(pIndex);
	if (pParse->pNewTable == 0) estimateIndexWidth(pIndex);

	
	assert(HasRowid(pTab)
		|| pTab->iPKey<0 || sqlite3ColumnOfIndex(pIndex, pTab->iPKey) >= 0);
	if (pTblName != 0 && pIndex->nColumn >= pTab->nCol) {
		pIndex->isCovering = 1;
		for (j = 0; j<pTab->nCol; j++) {
			if (j == pTab->iPKey) continue;
			if (sqlite3ColumnOfIndex(pIndex, j) >= 0) continue;
			pIndex->isCovering = 0;
			break;
		}
	}

	if (pTab == pParse->pNewTable) {
		
		Index *pIdx;
		for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
			int k;
			assert(IsUniqueIndex(pIdx));
			assert(pIdx->idxType != SQLITE_IDXTYPE_APPDEF);
			assert(IsUniqueIndex(pIndex));

			if (pIdx->nKeyCol != pIndex->nKeyCol) continue;
			for (k = 0; k<pIdx->nKeyCol; k++) {
				const char *z1;
				const char *z2;
				assert(pIdx->aiColumn[k] >= 0);
				if (pIdx->aiColumn[k] != pIndex->aiColumn[k]) break;
				z1 = pIdx->azColl[k];
				z2 = pIndex->azColl[k];
				if (sqlite3StrICmp(z1, z2)) break;
			}
			if (k == pIdx->nKeyCol) {
				if (pIdx->onError != pIndex->onError) {
					
					if (!(pIdx->onError == OE_Default || pIndex->onError == OE_Default)) {
						sqlite3ErrorMsg(pParse,
							"conflicting ON CONFLICT clauses specified", 0);
					}
					if (pIdx->onError == OE_Default) {
						pIdx->onError = pIndex->onError;
					}
				}
				if (idxType == SQLITE_IDXTYPE_PRIMARYKEY) pIdx->idxType = idxType;
				goto exit_create_index;
			}
		}
	}

	
	assert(pParse->nErr == 0);
	if (db->init.busy) {
		Index *p;
		assert(!IN_DECLARE_VTAB);
		assert(sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema));
		p = sqlite3HashInsert(&pIndex->pSchema->idxHash,
			pIndex->zName, pIndex);
		if (p) {
			assert(p == pIndex);  
			sqlite3OomFault(db);
			goto exit_create_index;
		}
		db->flags |= SQLITE_InternChanges;
		if (pTblName != 0) {
			pIndex->tnum = db->init.newTnum;
		}
	}

	
	else if (HasRowid(pTab) || pTblName != 0) {
		Vdbe *v;
		char *zStmt;
		int iMem = ++pParse->nMem;

		v = sqlite3GetVdbe(pParse);
		if (v == 0) goto exit_create_index;

		sqlite3BeginWriteOperation(pParse, 1, iDb);

		
		pIndex->tnum = sqlite3VdbeAddOp0(v, OP_Noop);
		sqlite3VdbeAddOp2(v, OP_CreateIndex, iDb, iMem);

		
		if (pStart) {
			int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
			if (pName->z[n - 1] == ';') n--;
			
			zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",
				onError == OE_None ? "" : " UNIQUE", n, pName->z);
		}
		else {
			
			
			zStmt = 0;
		}

		
		sqlite3NestedParse(pParse,
			"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb),
			pIndex->zName,
			pTab->zName,
			iMem,
			zStmt
		);
		sqlite3DbFree(db, zStmt);

		
		if (pTblName) {
			sqlite3RefillIndex(pParse, pIndex, iMem);
			sqlite3ChangeCookie(pParse, iDb);
			sqlite3VdbeAddParseSchemaOp(v, iDb,
				sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName));
			sqlite3VdbeAddOp0(v, OP_Expire);
		}

		sqlite3VdbeJumpHere(v, pIndex->tnum);
	}

	
	if (db->init.busy || pTblName == 0) {
		if (onError != OE_Replace || pTab->pIndex == 0
			|| pTab->pIndex->onError == OE_Replace) {
			pIndex->pNext = pTab->pIndex;
			pTab->pIndex = pIndex;
		}
		else {
			Index *pOther = pTab->pIndex;
			while (pOther->pNext && pOther->pNext->onError != OE_Replace) {
				pOther = pOther->pNext;
			}
			pIndex->pNext = pOther->pNext;
			pOther->pNext = pIndex;
		}
		pIndex = 0;
	}

	
exit_create_index:
	if (pIndex) freeIndex(db, pIndex);
	sqlite3ExprDelete(db, pPIWhere);
	sqlite3ExprListDelete(db, pList);
	sqlite3SrcListDelete(db, pTblName);
	sqlite3DbFree(db, zName);
}


SQLITE_PRIVATE void sqlite3DefaultRowEst(Index *pIdx) {
	
	LogEst aVal[] = { 33, 32, 30, 28, 26 };
	LogEst *a = pIdx->aiRowLogEst;
	int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);
	int i;

	
	a[0] = pIdx->pTable->nRowLogEst;
	if (pIdx->pPartIdxWhere != 0) a[0] -= 10;  assert(10 == sqlite3LogEst(2));
	if (a[0]<33) a[0] = 33;                  assert(33 == sqlite3LogEst(10));

	
	memcpy(&a[1], aVal, nCopy * sizeof(LogEst));
	for (i = nCopy + 1; i <= pIdx->nKeyCol; i++) {
		a[i] = 23;                    assert(23 == sqlite3LogEst(5));
	}

	assert(0 == sqlite3LogEst(1));
	if (IsUniqueIndex(pIdx)) a[pIdx->nKeyCol] = 0;
}


SQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists) {
	Index *pIndex;
	Vdbe *v;
	sqlite3 *db = pParse->db;
	int iDb;

	assert(pParse->nErr == 0);   
	if (db->mallocFailed) {
		goto exit_drop_index;
	}
	assert(pName->nSrc == 1);
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		goto exit_drop_index;
	}
	pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);
	if (pIndex == 0) {
		if (!ifExists) {
			sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0);
		}
		else {
			sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
		}
		pParse->checkSchema = 1;
		goto exit_drop_index;
	}
	if (pIndex->idxType != SQLITE_IDXTYPE_APPDEF) {
		sqlite3ErrorMsg(pParse, "index associated with UNIQUE "
			"or PRIMARY KEY constraint cannot be dropped", 0);
		goto exit_drop_index;
	}
	iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);
#ifndef SQLITE_OMIT_AUTHORIZATION
	{
		int code = SQLITE_DROP_INDEX;
		Table *pTab = pIndex->pTable;
		const char *zDb = db->aDb[iDb].zDbSName;
		const char *zTab = SCHEMA_TABLE(iDb);
		if (sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)) {
			goto exit_drop_index;
		}
		if (!OMIT_TEMPDB && iDb) code = SQLITE_DROP_TEMP_INDEX;
		if (sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb)) {
			goto exit_drop_index;
		}
	}
#endif

	
	v = sqlite3GetVdbe(pParse);
	if (v) {
		sqlite3BeginWriteOperation(pParse, 1, iDb);
		sqlite3NestedParse(pParse,
			"DELETE FROM %Q.%s WHERE name=%Q AND type='index'",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb), pIndex->zName
		);
		sqlite3ClearStatTables(pParse, iDb, "idx", pIndex->zName);
		sqlite3ChangeCookie(pParse, iDb);
		destroyRootPage(pParse, pIndex->tnum, iDb);
		sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);
	}

exit_drop_index:
	sqlite3SrcListDelete(db, pName);
}


SQLITE_PRIVATE void *sqlite3ArrayAllocate(
	sqlite3 *db,      
	void *pArray,     
	int szEntry,      
	int *pnEntry,     
	int *pIdx         
) {
	char *z;
	int n = *pnEntry;
	if ((n & (n - 1)) == 0) {
		int sz = (n == 0) ? 1 : 2 * n;
		void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
		if (pNew == 0) {
			*pIdx = -1;
			return pArray;
		}
		pArray = pNew;
	}
	z = (char*)pArray;
	memset(&z[n * szEntry], 0, szEntry);
	*pIdx = n;
	++*pnEntry;
	return pArray;
}


SQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken) {
	int i;
	if (pList == 0) {
		pList = sqlite3DbMallocZero(db, sizeof(IdList));
		if (pList == 0) return 0;
	}
	pList->a = sqlite3ArrayAllocate(
		db,
		pList->a,
		sizeof(pList->a[0]),
		&pList->nId,
		&i
	);
	if (i<0) {
		sqlite3IdListDelete(db, pList);
		return 0;
	}
	pList->a[i].zName = sqlite3NameFromToken(db, pToken);
	return pList;
}


SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList) {
	int i;
	if (pList == 0) return;
	for (i = 0; i<pList->nId; i++) {
		sqlite3DbFree(db, pList->a[i].zName);
	}
	sqlite3DbFree(db, pList->a);
	sqlite3DbFree(db, pList);
}


SQLITE_PRIVATE int sqlite3IdListIndex(IdList *pList, const char *zName) {
	int i;
	if (pList == 0) return -1;
	for (i = 0; i<pList->nId; i++) {
		if (sqlite3StrICmp(pList->a[i].zName, zName) == 0) return i;
	}
	return -1;
}


SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(
	sqlite3 *db,       
	SrcList *pSrc,     
	int nExtra,        
	int iStart         
) {
	int i;

	
	assert(iStart >= 0);
	assert(nExtra >= 1);
	assert(pSrc != 0);
	assert(iStart <= pSrc->nSrc);

	
	if ((u32)pSrc->nSrc + nExtra>pSrc->nAlloc) {
		SrcList *pNew;
		int nAlloc = pSrc->nSrc + nExtra;
		int nGot;
		pNew = sqlite3DbRealloc(db, pSrc,
			sizeof(*pSrc) + (nAlloc - 1) * sizeof(pSrc->a[0]));
		if (pNew == 0) {
			assert(db->mallocFailed);
			return pSrc;
		}
		pSrc = pNew;
		nGot = (sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc)) / sizeof(pSrc->a[0]) + 1;
		pSrc->nAlloc = nGot;
	}

	
	for (i = pSrc->nSrc - 1; i >= iStart; i--) {
		pSrc->a[i + nExtra] = pSrc->a[i];
	}
	pSrc->nSrc += nExtra;

	
	memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
	for (i = iStart; i<iStart + nExtra; i++) {
		pSrc->a[i].iCursor = -1;
	}

	
	return pSrc;
}



SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(
	sqlite3 *db,        
	SrcList *pList,     
	Token *pTable,      
	Token *pDatabase    
) {
	struct SrcList_item *pItem;
	assert(pDatabase == 0 || pTable != 0);  
	assert(db != 0);
	if (pList == 0) {
		pList = sqlite3DbMallocRawNN(db, sizeof(SrcList));
		if (pList == 0) return 0;
		pList->nAlloc = 1;
		pList->nSrc = 0;
	}
	pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc);
	if (db->mallocFailed) {
		sqlite3SrcListDelete(db, pList);
		return 0;
	}
	pItem = &pList->a[pList->nSrc - 1];
	if (pDatabase && pDatabase->z == 0) {
		pDatabase = 0;
	}
	if (pDatabase) {
		Token *pTemp = pDatabase;
		pDatabase = pTable;
		pTable = pTemp;
	}
	pItem->zName = sqlite3NameFromToken(db, pTable);
	pItem->zDatabase = sqlite3NameFromToken(db, pDatabase);
	return pList;
}


SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList) {
	int i;
	struct SrcList_item *pItem;
	assert(pList || pParse->db->mallocFailed);
	if (pList) {
		for (i = 0, pItem = pList->a; i<pList->nSrc; i++, pItem++) {
			if (pItem->iCursor >= 0) break;
			pItem->iCursor = pParse->nTab++;
			if (pItem->pSelect) {
				sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);
			}
		}
	}
}


SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList) {
	int i;
	struct SrcList_item *pItem;
	if (pList == 0) return;
	for (pItem = pList->a, i = 0; i<pList->nSrc; i++, pItem++) {
		sqlite3DbFree(db, pItem->zDatabase);
		sqlite3DbFree(db, pItem->zName);
		sqlite3DbFree(db, pItem->zAlias);
		if (pItem->fg.isIndexedBy) sqlite3DbFree(db, pItem->u1.zIndexedBy);
		if (pItem->fg.isTabFunc) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);
		sqlite3DeleteTable(db, pItem->pTab);
		sqlite3SelectDelete(db, pItem->pSelect);
		sqlite3ExprDelete(db, pItem->pOn);
		sqlite3IdListDelete(db, pItem->pUsing);
	}
	sqlite3DbFree(db, pList);
}


SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(
	Parse *pParse,          
	SrcList *p,             
	Token *pTable,          
	Token *pDatabase,       
	Token *pAlias,          
	Select *pSubquery,      
	Expr *pOn,              
	IdList *pUsing          
) {
	struct SrcList_item *pItem;
	sqlite3 *db = pParse->db;
	if (!p && (pOn || pUsing)) {
		sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",
			(pOn ? "ON" : "USING")
		);
		goto append_from_error;
	}
	p = sqlite3SrcListAppend(db, p, pTable, pDatabase);
	if (p == 0 || NEVER(p->nSrc == 0)) {
		goto append_from_error;
	}
	pItem = &p->a[p->nSrc - 1];
	assert(pAlias != 0);
	if (pAlias->n) {
		pItem->zAlias = sqlite3NameFromToken(db, pAlias);
	}
	pItem->pSelect = pSubquery;
	pItem->pOn = pOn;
	pItem->pUsing = pUsing;
	return p;

append_from_error:
	assert(p == 0);
	sqlite3ExprDelete(db, pOn);
	sqlite3IdListDelete(db, pUsing);
	sqlite3SelectDelete(db, pSubquery);
	return 0;
}


SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy) {
	assert(pIndexedBy != 0);
	if (p && ALWAYS(p->nSrc>0)) {
		struct SrcList_item *pItem = &p->a[p->nSrc - 1];
		assert(pItem->fg.notIndexed == 0);
		assert(pItem->fg.isIndexedBy == 0);
		assert(pItem->fg.isTabFunc == 0);
		if (pIndexedBy->n == 1 && !pIndexedBy->z) {
			
			pItem->fg.notIndexed = 1;
		}
		else {
			pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
			pItem->fg.isIndexedBy = (pItem->u1.zIndexedBy != 0);
		}
	}
}


SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList) {
	if (p) {
		struct SrcList_item *pItem = &p->a[p->nSrc - 1];
		assert(pItem->fg.notIndexed == 0);
		assert(pItem->fg.isIndexedBy == 0);
		assert(pItem->fg.isTabFunc == 0);
		pItem->u1.pFuncArg = pList;
		pItem->fg.isTabFunc = 1;
	}
	else {
		sqlite3ExprListDelete(pParse->db, pList);
	}
}


SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p) {
	if (p) {
		int i;
		for (i = p->nSrc - 1; i>0; i--) {
			p->a[i].fg.jointype = p->a[i - 1].fg.jointype;
		}
		p->a[0].fg.jointype = 0;
	}
}


SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type) {
	sqlite3 *db;
	Vdbe *v;
	int i;

	assert(pParse != 0);
	db = pParse->db;
	assert(db != 0);
	if (sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "BEGIN", 0, 0)) {
		return;
	}
	v = sqlite3GetVdbe(pParse);
	if (!v) return;
	if (type != TK_DEFERRED) {
		for (i = 0; i<db->nDb; i++) {
			sqlite3VdbeAddOp2(v, OP_Transaction, i, (type == TK_EXCLUSIVE) + 1);
			sqlite3VdbeUsesBtree(v, i);
		}
	}
	sqlite3VdbeAddOp0(v, OP_AutoCommit);
}


SQLITE_PRIVATE void sqlite3CommitTransaction(Parse *pParse) {
	Vdbe *v;

	assert(pParse != 0);
	assert(pParse->db != 0);
	if (sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "COMMIT", 0, 0)) {
		return;
	}
	v = sqlite3GetVdbe(pParse);
	if (v) {
		sqlite3VdbeAddOp1(v, OP_AutoCommit, 1);
	}
}


SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse *pParse) {
	Vdbe *v;

	assert(pParse != 0);
	assert(pParse->db != 0);
	if (sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "ROLLBACK", 0, 0)) {
		return;
	}
	v = sqlite3GetVdbe(pParse);
	if (v) {
		sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 1);
	}
}


SQLITE_PRIVATE void sqlite3Savepoint(Parse *pParse, int op, Token *pName) {
	char *zName = sqlite3NameFromToken(pParse->db, pName);
	if (zName) {
		Vdbe *v = sqlite3GetVdbe(pParse);
#ifndef SQLITE_OMIT_AUTHORIZATION
		static const char * const az[] = { "BEGIN", "RELEASE", "ROLLBACK" };
		assert(!SAVEPOINT_BEGIN && SAVEPOINT_RELEASE == 1 && SAVEPOINT_ROLLBACK == 2);
#endif
		if (!v || sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0)) {
			sqlite3DbFree(pParse->db, zName);
			return;
		}
		sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC);
	}
}


SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *pParse) {
	sqlite3 *db = pParse->db;
	if (db->aDb[1].pBt == 0 && !pParse->explain) {
		int rc;
		Btree *pBt;
		static const int flags =
			SQLITE_OPEN_READWRITE |
			SQLITE_OPEN_CREATE |
			SQLITE_OPEN_EXCLUSIVE |
			SQLITE_OPEN_DELETEONCLOSE |
			SQLITE_OPEN_TEMP_DB;

		rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);
		if (rc != SQLITE_OK) {
			sqlite3ErrorMsg(pParse, "unable to open a temporary database "
				"file for storing temporary tables");
			pParse->rc = rc;
			return 1;
		}
		db->aDb[1].pBt = pBt;
		assert(db->aDb[1].pSchema);
		if (SQLITE_NOMEM == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0)) {
			sqlite3OomFault(db);
			return 1;
		}
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);

	assert(iDb >= 0 && iDb<pParse->db->nDb);
	assert(pParse->db->aDb[iDb].pBt != 0 || iDb == 1);
	assert(iDb<SQLITE_MAX_ATTACHED + 2);
	assert(sqlite3SchemaMutexHeld(pParse->db, iDb, 0));
	if (DbMaskTest(pToplevel->cookieMask, iDb) == 0) {
		DbMaskSet(pToplevel->cookieMask, iDb);
		if (!OMIT_TEMPDB && iDb == 1) {
			sqlite3OpenTempDatabase(pToplevel);
		}
	}
}


SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb) {
	sqlite3 *db = pParse->db;
	int i;
	for (i = 0; i<db->nDb; i++) {
		Db *pDb = &db->aDb[i];
		if (pDb->pBt && (!zDb || 0 == sqlite3StrICmp(zDb, pDb->zDbSName))) {
			sqlite3CodeVerifySchema(pParse, i);
		}
	}
}


SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);
	sqlite3CodeVerifySchema(pParse, iDb);
	DbMaskSet(pToplevel->writeMask, iDb);
	pToplevel->isMultiWrite |= setStatement;
}


SQLITE_PRIVATE void sqlite3MultiWrite(Parse *pParse) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);
	pToplevel->isMultiWrite = 1;
}


SQLITE_PRIVATE void sqlite3MayAbort(Parse *pParse) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);
	pToplevel->mayAbort = 1;
}


SQLITE_PRIVATE void sqlite3HaltConstraint(
	Parse *pParse,    
	int errCode,      
	int onError,      
	char *p4,         
	i8 p4type,        
	u8 p5Errmsg       
) {
	Vdbe *v = sqlite3GetVdbe(pParse);
	assert((errCode & 0xff) == SQLITE_CONSTRAINT);
	if (onError == OE_Abort) {
		sqlite3MayAbort(pParse);
	}
	sqlite3VdbeAddOp4(v, OP_Halt, errCode, onError, 0, p4, p4type);
	sqlite3VdbeChangeP5(v, p5Errmsg);
}


SQLITE_PRIVATE void sqlite3UniqueConstraint(
	Parse *pParse,    
	int onError,      
	Index *pIdx       
) {
	char *zErr;
	int j;
	StrAccum errMsg;
	Table *pTab = pIdx->pTable;

	sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0, 200);
	if (pIdx->aColExpr) {
		sqlite3XPrintf(&errMsg, "index '%q'", pIdx->zName);
	}
	else {
		for (j = 0; j<pIdx->nKeyCol; j++) {
			char *zCol;
			assert(pIdx->aiColumn[j] >= 0);
			zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
			if (j) sqlite3StrAccumAppend(&errMsg, ", ", 2);
			sqlite3XPrintf(&errMsg, "%s.%s", pTab->zName, zCol);
		}
	}
	zErr = sqlite3StrAccumFinish(&errMsg);
	sqlite3HaltConstraint(pParse,
		IsPrimaryKeyIndex(pIdx) ? SQLITE_CONSTRAINT_PRIMARYKEY
		: SQLITE_CONSTRAINT_UNIQUE,
		onError, zErr, P4_DYNAMIC, P5_ConstraintUnique);
}



SQLITE_PRIVATE void sqlite3RowidConstraint(
	Parse *pParse,    
	int onError,      
	Table *pTab       
) {
	char *zMsg;
	int rc;
	if (pTab->iPKey >= 0) {
		zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName,
			pTab->aCol[pTab->iPKey].zName);
		rc = SQLITE_CONSTRAINT_PRIMARYKEY;
	}
	else {
		zMsg = sqlite3MPrintf(pParse->db, "%s.rowid", pTab->zName);
		rc = SQLITE_CONSTRAINT_ROWID;
	}
	sqlite3HaltConstraint(pParse, rc, onError, zMsg, P4_DYNAMIC,
		P5_ConstraintUnique);
}


#ifndef SQLITE_OMIT_REINDEX
static int collationMatch(const char *zColl, Index *pIndex) {
	int i;
	assert(zColl != 0);
	for (i = 0; i<pIndex->nColumn; i++) {
		const char *z = pIndex->azColl[i];
		assert(z != 0 || pIndex->aiColumn[i]<0);
		if (pIndex->aiColumn[i] >= 0 && 0 == sqlite3StrICmp(z, zColl)) {
			return 1;
		}
	}
	return 0;
}
#endif


#ifndef SQLITE_OMIT_REINDEX
static void reindexTable(Parse *pParse, Table *pTab, char const *zColl) {
	Index *pIndex;              

	for (pIndex = pTab->pIndex; pIndex; pIndex = pIndex->pNext) {
		if (zColl == 0 || collationMatch(zColl, pIndex)) {
			int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
			sqlite3BeginWriteOperation(pParse, 0, iDb);
			sqlite3RefillIndex(pParse, pIndex, -1);
		}
	}
}
#endif


#ifndef SQLITE_OMIT_REINDEX
static void reindexDatabases(Parse *pParse, char const *zColl) {
	Db *pDb;                    
	int iDb;                    
	sqlite3 *db = pParse->db;   
	HashElem *k;                
	Table *pTab;                

	assert(sqlite3BtreeHoldsAllMutexes(db));  
	for (iDb = 0, pDb = db->aDb; iDb<db->nDb; iDb++, pDb++) {
		assert(pDb != 0);
		for (k = sqliteHashFirst(&pDb->pSchema->tblHash); k; k = sqliteHashNext(k)) {
			pTab = (Table*)sqliteHashData(k);
			reindexTable(pParse, pTab, zColl);
		}
	}
}
#endif


#ifndef SQLITE_OMIT_REINDEX
SQLITE_PRIVATE void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2) {
	CollSeq *pColl;             
	char *z;                    
	const char *zDb;            
	Table *pTab;                
	Index *pIndex;              
	int iDb;                    
	sqlite3 *db = pParse->db;   
	Token *pObjName;            

								
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		return;
	}

	if (pName1 == 0) {
		reindexDatabases(pParse, 0);
		return;
	}
	else if (NEVER(pName2 == 0) || pName2->z == 0) {
		char *zColl;
		assert(pName1->z);
		zColl = sqlite3NameFromToken(pParse->db, pName1);
		if (!zColl) return;
		pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);
		if (pColl) {
			reindexDatabases(pParse, zColl);
			sqlite3DbFree(db, zColl);
			return;
		}
		sqlite3DbFree(db, zColl);
	}
	iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);
	if (iDb<0) return;
	z = sqlite3NameFromToken(db, pObjName);
	if (z == 0) return;
	zDb = db->aDb[iDb].zDbSName;
	pTab = sqlite3FindTable(db, z, zDb);
	if (pTab) {
		reindexTable(pParse, pTab, 0);
		sqlite3DbFree(db, z);
		return;
	}
	pIndex = sqlite3FindIndex(db, z, zDb);
	sqlite3DbFree(db, z);
	if (pIndex) {
		sqlite3BeginWriteOperation(pParse, 0, iDb);
		sqlite3RefillIndex(pParse, pIndex, -1);
		return;
	}
	sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}
#endif


SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx) {
	int i;
	int nCol = pIdx->nColumn;
	int nKey = pIdx->nKeyCol;
	KeyInfo *pKey;
	if (pParse->nErr) return 0;
	if (pIdx->uniqNotNull) {
		pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol - nKey);
	}
	else {
		pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);
	}
	if (pKey) {
		assert(sqlite3KeyInfoIsWriteable(pKey));
		for (i = 0; i<nCol; i++) {
			const char *zColl = pIdx->azColl[i];
			pKey->aColl[i] = zColl == sqlite3StrBINARY ? 0 :
				sqlite3LocateCollSeq(pParse, zColl);
			pKey->aSortOrder[i] = pIdx->aSortOrder[i];
		}
		if (pParse->nErr) {
			sqlite3KeyInfoUnref(pKey);
			pKey = 0;
		}
	}
	return pKey;
}

#ifndef SQLITE_OMIT_CTE

SQLITE_PRIVATE With *sqlite3WithAdd(
	Parse *pParse,          
	With *pWith,            
	Token *pName,           
	ExprList *pArglist,     
	Select *pQuery          
) {
	sqlite3 *db = pParse->db;
	With *pNew;
	char *zName;

	
	zName = sqlite3NameFromToken(pParse->db, pName);
	if (zName && pWith) {
		int i;
		for (i = 0; i<pWith->nCte; i++) {
			if (sqlite3StrICmp(zName, pWith->a[i].zName) == 0) {
				sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
			}
		}
	}

	if (pWith) {
		int nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);
		pNew = sqlite3DbRealloc(db, pWith, nByte);
	}
	else {
		pNew = sqlite3DbMallocZero(db, sizeof(*pWith));
	}
	assert((pNew != 0 && zName != 0) || db->mallocFailed);

	if (db->mallocFailed) {
		sqlite3ExprListDelete(db, pArglist);
		sqlite3SelectDelete(db, pQuery);
		sqlite3DbFree(db, zName);
		pNew = pWith;
	}
	else {
		pNew->a[pNew->nCte].pSelect = pQuery;
		pNew->a[pNew->nCte].pCols = pArglist;
		pNew->a[pNew->nCte].zName = zName;
		pNew->a[pNew->nCte].zCteErr = 0;
		pNew->nCte++;
	}

	return pNew;
}


SQLITE_PRIVATE void sqlite3WithDelete(sqlite3 *db, With *pWith) {
	if (pWith) {
		int i;
		for (i = 0; i<pWith->nCte; i++) {
			struct Cte *pCte = &pWith->a[i];
			sqlite3ExprListDelete(db, pCte->pCols);
			sqlite3SelectDelete(db, pCte->pSelect);
			sqlite3DbFree(db, pCte->zName);
		}
		sqlite3DbFree(db, pWith);
	}
}
#endif 








static void callCollNeeded(sqlite3 *db, int enc, const char *zName) {
	assert(!db->xCollNeeded || !db->xCollNeeded16);
	if (db->xCollNeeded) {
		char *zExternal = sqlite3DbStrDup(db, zName);
		if (!zExternal) return;
		db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);
		sqlite3DbFree(db, zExternal);
	}
#ifndef SQLITE_OMIT_UTF16
	if (db->xCollNeeded16) {
		char const *zExternal;
		sqlite3_value *pTmp = sqlite3ValueNew(db);
		sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);
		zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);
		if (zExternal) {
			db->xCollNeeded16(db->pCollNeededArg, db, (int)ENC(db), zExternal);
		}
		sqlite3ValueFree(pTmp);
	}
#endif
}


static int synthCollSeq(sqlite3 *db, CollSeq *pColl) {
	CollSeq *pColl2;
	char *z = pColl->zName;
	int i;
	static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };
	for (i = 0; i<3; i++) {
		pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);
		if (pColl2->xCmp != 0) {
			memcpy(pColl, pColl2, sizeof(CollSeq));
			pColl->xDel = 0;         
			return SQLITE_OK;
		}
	}
	return SQLITE_ERROR;
}


SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(
	Parse *pParse,        
	u8 enc,               
	CollSeq *pColl,       
	const char *zName     
) {
	CollSeq *p;
	sqlite3 *db = pParse->db;

	p = pColl;
	if (!p) {
		p = sqlite3FindCollSeq(db, enc, zName, 0);
	}
	if (!p || !p->xCmp) {
		
		callCollNeeded(db, enc, zName);
		p = sqlite3FindCollSeq(db, enc, zName, 0);
	}
	if (p && !p->xCmp && synthCollSeq(db, p)) {
		p = 0;
	}
	assert(!p || p->xCmp);
	if (p == 0) {
		sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
	}
	return p;
}


SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl) {
	if (pColl) {
		const char *zName = pColl->zName;
		sqlite3 *db = pParse->db;
		CollSeq *p = sqlite3GetCollSeq(pParse, ENC(db), pColl, zName);
		if (!p) {
			return SQLITE_ERROR;
		}
		assert(p == pColl);
	}
	return SQLITE_OK;
}




static CollSeq *findCollSeqEntry(
	sqlite3 *db,          
	const char *zName,    
	int create            
) {
	CollSeq *pColl;
	pColl = sqlite3HashFind(&db->aCollSeq, zName);

	if (0 == pColl && create) {
		int nName = sqlite3Strlen30(zName);
		pColl = sqlite3DbMallocZero(db, 3 * sizeof(*pColl) + nName + 1);
		if (pColl) {
			CollSeq *pDel = 0;
			pColl[0].zName = (char*)&pColl[3];
			pColl[0].enc = SQLITE_UTF8;
			pColl[1].zName = (char*)&pColl[3];
			pColl[1].enc = SQLITE_UTF16LE;
			pColl[2].zName = (char*)&pColl[3];
			pColl[2].enc = SQLITE_UTF16BE;
			memcpy(pColl[0].zName, zName, nName);
			pColl[0].zName[nName] = 0;
			pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);

			
			assert(pDel == 0 || pDel == pColl);
			if (pDel != 0) {
				sqlite3OomFault(db);
				sqlite3DbFree(db, pDel);
				pColl = 0;
			}
		}
	}
	return pColl;
}


SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(
	sqlite3 *db,
	u8 enc,
	const char *zName,
	int create
) {
	CollSeq *pColl;
	if (zName) {
		pColl = findCollSeqEntry(db, zName, create);
	}
	else {
		pColl = db->pDfltColl;
	}
	assert(SQLITE_UTF8 == 1 && SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3);
	assert(enc >= SQLITE_UTF8 && enc <= SQLITE_UTF16BE);
	if (pColl) pColl += enc - 1;
	return pColl;
}


#define FUNC_PERFECT_MATCH 6  
static int matchQuality(
	FuncDef *p,     
	int nArg,       
	u8 enc          
) {
	int match;

	
	if (nArg == (-2)) return (p->xSFunc == 0) ? 0 : FUNC_PERFECT_MATCH;

	
	if (p->nArg != nArg && p->nArg >= 0) return 0;

	
	if (p->nArg == nArg) {
		match = 4;
	}
	else {
		match = 1;
	}

	
	if (enc == (p->funcFlags & SQLITE_FUNC_ENCMASK)) {
		match += 2;  
	}
	else if ((enc & p->funcFlags & 2) != 0) {
		match += 1;  
	}

	return match;
}


static FuncDef *functionSearch(
	int h,               
	const char *zFunc    
) {
	FuncDef *p;
	for (p = sqlite3BuiltinFunctions.a[h]; p; p = p->u.pHash) {
		if (sqlite3StrICmp(p->zName, zFunc) == 0) {
			return p;
		}
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(
	FuncDef *aDef,      
	int nDef            
) {
	int i;
	for (i = 0; i<nDef; i++) {
		FuncDef *pOther;
		const char *zName = aDef[i].zName;
		int nName = sqlite3Strlen30(zName);
		int h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % SQLITE_FUNC_HASH_SZ;
		pOther = functionSearch(h, zName);
		if (pOther) {
			assert(pOther != &aDef[i] && pOther->pNext != &aDef[i]);
			aDef[i].pNext = pOther->pNext;
			pOther->pNext = &aDef[i];
		}
		else {
			aDef[i].pNext = 0;
			aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];
			sqlite3BuiltinFunctions.a[h] = &aDef[i];
		}
	}
}




SQLITE_PRIVATE FuncDef *sqlite3FindFunction(
	sqlite3 *db,       
	const char *zName, 
	int nArg,          
	u8 enc,            
	u8 createFlag      
) {
	FuncDef *p;         
	FuncDef *pBest = 0; 
	int bestScore = 0;  
	int h;              
	int nName;          

	assert(nArg >= (-2));
	assert(nArg >= (-1) || createFlag == 0);
	nName = sqlite3Strlen30(zName);

	
	p = (FuncDef*)sqlite3HashFind(&db->aFunc, zName);
	while (p) {
		int score = matchQuality(p, nArg, enc);
		if (score>bestScore) {
			pBest = p;
			bestScore = score;
		}
		p = p->pNext;
	}

	
	if (!createFlag && (pBest == 0 || (db->flags & SQLITE_PreferBuiltin) != 0)) {
		bestScore = 0;
		h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % SQLITE_FUNC_HASH_SZ;
		p = functionSearch(h, zName);
		while (p) {
			int score = matchQuality(p, nArg, enc);
			if (score>bestScore) {
				pBest = p;
				bestScore = score;
			}
			p = p->pNext;
		}
	}

	
	if (createFlag && bestScore<FUNC_PERFECT_MATCH &&
		(pBest = sqlite3DbMallocZero(db, sizeof(*pBest) + nName + 1)) != 0) {
		FuncDef *pOther;
		pBest->zName = (const char*)&pBest[1];
		pBest->nArg = (u16)nArg;
		pBest->funcFlags = enc;
		memcpy((char*)&pBest[1], zName, nName + 1);
		pOther = (FuncDef*)sqlite3HashInsert(&db->aFunc, pBest->zName, pBest);
		if (pOther == pBest) {
			sqlite3DbFree(db, pBest);
			sqlite3OomFault(db);
			return 0;
		}
		else {
			pBest->pNext = pOther;
		}
	}

	if (pBest && (pBest->xSFunc || createFlag)) {
		return pBest;
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3SchemaClear(void *p) {
	Hash temp1;
	Hash temp2;
	HashElem *pElem;
	Schema *pSchema = (Schema *)p;

	temp1 = pSchema->tblHash;
	temp2 = pSchema->trigHash;
	sqlite3HashInit(&pSchema->trigHash);
	sqlite3HashClear(&pSchema->idxHash);
	for (pElem = sqliteHashFirst(&temp2); pElem; pElem = sqliteHashNext(pElem)) {
		sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem));
	}
	sqlite3HashClear(&temp2);
	sqlite3HashInit(&pSchema->tblHash);
	for (pElem = sqliteHashFirst(&temp1); pElem; pElem = sqliteHashNext(pElem)) {
		Table *pTab = sqliteHashData(pElem);
		sqlite3DeleteTable(0, pTab);
	}
	sqlite3HashClear(&temp1);
	sqlite3HashClear(&pSchema->fkeyHash);
	pSchema->pSeqTab = 0;
	if (pSchema->schemaFlags & DB_SchemaLoaded) {
		pSchema->iGeneration++;
		pSchema->schemaFlags &= ~DB_SchemaLoaded;
	}
}


SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt) {
	Schema * p;
	if (pBt) {
		p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);
	}
	else {
		p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));
	}
	if (!p) {
		sqlite3OomFault(db);
	}
	else if (0 == p->file_format) {
		sqlite3HashInit(&p->tblHash);
		sqlite3HashInit(&p->idxHash);
		sqlite3HashInit(&p->trigHash);
		sqlite3HashInit(&p->fkeyHash);
		p->enc = SQLITE_UTF8;
	}
	return p;
}







SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc) {
	struct SrcList_item *pItem = pSrc->a;
	Table *pTab;
	assert(pItem && pSrc->nSrc == 1);
	pTab = sqlite3LocateTableItem(pParse, 0, pItem);
	sqlite3DeleteTable(pParse->db, pItem->pTab);
	pItem->pTab = pTab;
	if (pTab) {
		pTab->nRef++;
	}
	if (sqlite3IndexedByLookup(pParse, pItem)) {
		pTab = 0;
	}
	return pTab;
}


SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk) {
	
	if ((IsVirtual(pTab)
		&& sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate == 0)
		|| ((pTab->tabFlags & TF_Readonly) != 0
			&& (pParse->db->flags & SQLITE_WriteSchema) == 0
			&& pParse->nested == 0)
		) {
		sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
		return 1;
	}

#ifndef SQLITE_OMIT_VIEW
	if (!viewOk && pTab->pSelect) {
		sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab->zName);
		return 1;
	}
#endif
	return 0;
}


#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)

SQLITE_PRIVATE void sqlite3MaterializeView(
	Parse *pParse,       
	Table *pView,        
	Expr *pWhere,        
	int iCur             
) {
	SelectDest dest;
	Select *pSel;
	SrcList *pFrom;
	sqlite3 *db = pParse->db;
	int iDb = sqlite3SchemaToIndex(db, pView->pSchema);
	pWhere = sqlite3ExprDup(db, pWhere, 0);
	pFrom = sqlite3SrcListAppend(db, 0, 0, 0);
	if (pFrom) {
		assert(pFrom->nSrc == 1);
		pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);
		pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);
		assert(pFrom->a[0].pOn == 0);
		assert(pFrom->a[0].pUsing == 0);
	}
	pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, 0,
		SF_IncludeHidden, 0, 0);
	sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur);
	sqlite3Select(pParse, pSel, &dest);
	sqlite3SelectDelete(db, pSel);
}
#endif 

#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)

SQLITE_PRIVATE Expr *sqlite3LimitWhere(
	Parse *pParse,               
	SrcList *pSrc,               
	Expr *pWhere,                
	ExprList *pOrderBy,          
	Expr *pLimit,                
	Expr *pOffset,               
	char *zStmtType              
) {
	Expr *pWhereRowid = NULL;    
	Expr *pInClause = NULL;      
	Expr *pSelectRowid = NULL;   
	ExprList *pEList = NULL;     
	SrcList *pSelectSrc = NULL;  
	Select *pSelect = NULL;      

								 
	if (pOrderBy && (pLimit == 0)) {
		sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on %s", zStmtType);
		goto limit_where_cleanup;
	}

	
	if (pLimit == 0) {
		
		assert(pOffset == 0);
		return pWhere;
	}

	

	pSelectRowid = sqlite3PExpr(pParse, TK_ROW, 0, 0, 0);
	if (pSelectRowid == 0) goto limit_where_cleanup;
	pEList = sqlite3ExprListAppend(pParse, 0, pSelectRowid);
	if (pEList == 0) goto limit_where_cleanup;

	
	pSelectSrc = sqlite3SrcListDup(pParse->db, pSrc, 0);
	if (pSelectSrc == 0) {
		sqlite3ExprListDelete(pParse->db, pEList);
		goto limit_where_cleanup;
	}

	
	pSelect = sqlite3SelectNew(pParse, pEList, pSelectSrc, pWhere, 0, 0,
		pOrderBy, 0, pLimit, pOffset);
	if (pSelect == 0) return 0;

	
	pWhereRowid = sqlite3PExpr(pParse, TK_ROW, 0, 0, 0);
	pInClause = pWhereRowid ? sqlite3PExpr(pParse, TK_IN, pWhereRowid, 0, 0) : 0;
	sqlite3PExprAddSelect(pParse, pInClause, pSelect);
	return pInClause;

limit_where_cleanup:
	sqlite3ExprDelete(pParse->db, pWhere);
	sqlite3ExprListDelete(pParse->db, pOrderBy);
	sqlite3ExprDelete(pParse->db, pLimit);
	sqlite3ExprDelete(pParse->db, pOffset);
	return 0;
}
#endif 



SQLITE_PRIVATE void sqlite3DeleteFrom(
	Parse *pParse,         
	SrcList *pTabList,     
	Expr *pWhere           
) {
	Vdbe *v;               
	Table *pTab;           
	int i;                 
	WhereInfo *pWInfo;     
	Index *pIdx;           
	int iTabCur;           
	int iDataCur = 0;      
	int iIdxCur = 0;       
	int nIdx;              
	sqlite3 *db;           
	AuthContext sContext;  
	NameContext sNC;       
	int iDb;               
	int memCnt = -1;       
	int rcauth;            
	int eOnePass;          
	int aiCurOnePass[2];   
	u8 *aToOpen = 0;       
	Index *pPk;            
	int iPk = 0;           
	i16 nPk = 1;           
	int iKey;              
	i16 nKey;              
	int iEphCur = 0;       
	int iRowSet = 0;       
	int addrBypass = 0;    
	int addrLoop = 0;      
	int addrEphOpen = 0;   
	int bComplex;          

#ifndef SQLITE_OMIT_TRIGGER
	int isView;                  
	Trigger *pTrigger;           
#endif

	memset(&sContext, 0, sizeof(sContext));
	db = pParse->db;
	if (pParse->nErr || db->mallocFailed) {
		goto delete_from_cleanup;
	}
	assert(pTabList->nSrc == 1);

	
	pTab = sqlite3SrcListLookup(pParse, pTabList);
	if (pTab == 0)  goto delete_from_cleanup;

	
#ifndef SQLITE_OMIT_TRIGGER
	pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
	isView = pTab->pSelect != 0;
	bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
#else
# define pTrigger 0
# define isView 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif

	
	if (sqlite3ViewGetColumnNames(pParse, pTab)) {
		goto delete_from_cleanup;
	}

	if (sqlite3IsReadOnly(pParse, pTab, (pTrigger ? 1 : 0))) {
		goto delete_from_cleanup;
	}
	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	assert(iDb<db->nDb);
	rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0,
		db->aDb[iDb].zDbSName);
	assert(rcauth == SQLITE_OK || rcauth == SQLITE_DENY || rcauth == SQLITE_IGNORE);
	if (rcauth == SQLITE_DENY) {
		goto delete_from_cleanup;
	}
	assert(!isView || pTrigger);

	
	assert(pTabList->nSrc == 1);
	iTabCur = pTabList->a[0].iCursor = pParse->nTab++;
	for (nIdx = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, nIdx++) {
		pParse->nTab++;
	}

	
	if (isView) {
		sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
	}

	
	v = sqlite3GetVdbe(pParse);
	if (v == 0) {
		goto delete_from_cleanup;
	}
	if (pParse->nested == 0) sqlite3VdbeCountChanges(v);
	sqlite3BeginWriteOperation(pParse, 1, iDb);

	
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
	if (isView) {
		sqlite3MaterializeView(pParse, pTab, pWhere, iTabCur);
		iDataCur = iIdxCur = iTabCur;
	}
#endif

	
	memset(&sNC, 0, sizeof(sNC));
	sNC.pParse = pParse;
	sNC.pSrcList = pTabList;
	if (sqlite3ResolveExprNames(&sNC, pWhere)) {
		goto delete_from_cleanup;
	}

	
	if (db->flags & SQLITE_CountRows) {
		memCnt = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt);
	}

#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION
	
	if (rcauth == SQLITE_OK
		&& pWhere == 0
		&& !bComplex
		&& !IsVirtual(pTab)
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
		&& db->xPreUpdateCallback == 0
#endif
		) {
		assert(!isView);
		sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
		if (HasRowid(pTab)) {
			sqlite3VdbeAddOp4(v, OP_Clear, pTab->tnum, iDb, memCnt,
				pTab->zName, P4_STATIC);
		}
		for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
			assert(pIdx->pSchema == pTab->pSchema);
			sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);
		}
	}
	else
#endif 
	{
		u16 wcf = WHERE_ONEPASS_DESIRED | WHERE_DUPLICATES_OK | WHERE_SEEK_TABLE;
		if (sNC.ncFlags & NC_VarSelect) bComplex = 1;
		wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);
		if (HasRowid(pTab)) {
			
			pPk = 0;
			nPk = 1;
			iRowSet = ++pParse->nMem;
			sqlite3VdbeAddOp2(v, OP_Null, 0, iRowSet);
		}
		else {
			
			pPk = sqlite3PrimaryKeyIndex(pTab);
			assert(pPk != 0);
			nPk = pPk->nKeyCol;
			iPk = pParse->nMem + 1;
			pParse->nMem += nPk;
			iEphCur = pParse->nTab++;
			addrEphOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEphCur, nPk);
			sqlite3VdbeSetP4KeyInfo(pParse, pPk);
		}

		
		pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, wcf, iTabCur + 1);
		if (pWInfo == 0) goto delete_from_cleanup;
		eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
		assert(IsVirtual(pTab) == 0 || eOnePass != ONEPASS_MULTI);
		assert(IsVirtual(pTab) || bComplex || eOnePass != ONEPASS_OFF);

		
		if (db->flags & SQLITE_CountRows) {
			sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1);
		}

		
		if (pPk) {
			for (i = 0; i<nPk; i++) {
				assert(pPk->aiColumn[i] >= 0);
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,
					pPk->aiColumn[i], iPk + i);
			}
			iKey = iPk;
		}
		else {
			iKey = pParse->nMem + 1;
			iKey = sqlite3ExprCodeGetColumn(pParse, pTab, -1, iTabCur, iKey, 0);
			if (iKey>pParse->nMem) pParse->nMem = iKey;
		}

		if (eOnePass != ONEPASS_OFF) {
			
			nKey = nPk; 
			aToOpen = sqlite3DbMallocRawNN(db, nIdx + 2);
			if (aToOpen == 0) {
				sqlite3WhereEnd(pWInfo);
				goto delete_from_cleanup;
			}
			memset(aToOpen, 1, nIdx + 1);
			aToOpen[nIdx + 1] = 0;
			if (aiCurOnePass[0] >= 0) aToOpen[aiCurOnePass[0] - iTabCur] = 0;
			if (aiCurOnePass[1] >= 0) aToOpen[aiCurOnePass[1] - iTabCur] = 0;
			if (addrEphOpen) sqlite3VdbeChangeToNoop(v, addrEphOpen);
		}
		else {
			if (pPk) {
				
				iKey = ++pParse->nMem;
				nKey = 0;   
				sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,
					sqlite3IndexAffinityStr(pParse->db, pPk), nPk);
				sqlite3VdbeAddOp2(v, OP_IdxInsert, iEphCur, iKey);
			}
			else {
				
				nKey = 1;  
				sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);
			}
		}

		
		if (eOnePass != ONEPASS_OFF) {
			addrBypass = sqlite3VdbeMakeLabel(v);
		}
		else {
			sqlite3WhereEnd(pWInfo);
		}

		
		if (!isView) {
			int iAddrOnce = 0;
			if (eOnePass == ONEPASS_MULTI) {
				iAddrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
			}
			testcase(IsVirtual(pTab));
			sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, OPFLAG_FORDELETE,
				iTabCur, aToOpen, &iDataCur, &iIdxCur);
			assert(pPk || IsVirtual(pTab) || iDataCur == iTabCur);
			assert(pPk || IsVirtual(pTab) || iIdxCur == iDataCur + 1);
			if (eOnePass == ONEPASS_MULTI) sqlite3VdbeJumpHere(v, iAddrOnce);
		}

		
		if (eOnePass != ONEPASS_OFF) {
			assert(nKey == nPk);  
			if (!IsVirtual(pTab) && aToOpen[iDataCur - iTabCur]) {
				assert(pPk != 0 || pTab->pSelect != 0);
				sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);
				VdbeCoverage(v);
			}
		}
		else if (pPk) {
			addrLoop = sqlite3VdbeAddOp1(v, OP_Rewind, iEphCur); VdbeCoverage(v);
			sqlite3VdbeAddOp2(v, OP_RowKey, iEphCur, iKey);
			assert(nKey == 0);  
		}
		else {
			addrLoop = sqlite3VdbeAddOp3(v, OP_RowSetRead, iRowSet, 0, iKey);
			VdbeCoverage(v);
			assert(nKey == 1);
		}

		
#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (IsVirtual(pTab)) {
			const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
			sqlite3VtabMakeWritable(pParse, pTab);
			sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iKey, pVTab, P4_VTAB);
			sqlite3VdbeChangeP5(v, OE_Abort);
			assert(eOnePass == ONEPASS_OFF || eOnePass == ONEPASS_SINGLE);
			sqlite3MayAbort(pParse);
			if (eOnePass == ONEPASS_SINGLE && sqlite3IsToplevel(pParse)) {
				pParse->isMultiWrite = 0;
			}
		}
		else
#endif
		{
			int count = (pParse->nested == 0);    
			int iIdxNoSeek = -1;
			if (bComplex == 0 && aiCurOnePass[1] != iDataCur) {
				iIdxNoSeek = aiCurOnePass[1];
			}
			sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
				iKey, nKey, count, OE_Default, eOnePass, iIdxNoSeek);
		}

		
		if (eOnePass != ONEPASS_OFF) {
			sqlite3VdbeResolveLabel(v, addrBypass);
			sqlite3WhereEnd(pWInfo);
		}
		else if (pPk) {
			sqlite3VdbeAddOp2(v, OP_Next, iEphCur, addrLoop + 1); VdbeCoverage(v);
			sqlite3VdbeJumpHere(v, addrLoop);
		}
		else {
			sqlite3VdbeGoto(v, addrLoop);
			sqlite3VdbeJumpHere(v, addrLoop);
		}

		
		if (!isView && !IsVirtual(pTab)) {
			if (!pPk) sqlite3VdbeAddOp1(v, OP_Close, iDataCur);
			for (i = 0, pIdx = pTab->pIndex; pIdx; i++, pIdx = pIdx->pNext) {
				sqlite3VdbeAddOp1(v, OP_Close, iIdxCur + i);
			}
		}
	} 

	  
	if (pParse->nested == 0 && pParse->pTriggerTab == 0) {
		sqlite3AutoincrementEnd(pParse);
	}

	
	if ((db->flags&SQLITE_CountRows) && !pParse->nested && !pParse->pTriggerTab) {
		sqlite3VdbeAddOp2(v, OP_ResultRow, memCnt, 1);
		sqlite3VdbeSetNumCols(v, 1);
		sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows deleted", SQLITE_STATIC);
	}

delete_from_cleanup:
	sqlite3AuthContextPop(&sContext);
	sqlite3SrcListDelete(db, pTabList);
	sqlite3ExprDelete(db, pWhere);
	sqlite3DbFree(db, aToOpen);
	return;
}

#ifdef isView
#undef isView
#endif
#ifdef pTrigger
#undef pTrigger
#endif


SQLITE_PRIVATE void sqlite3GenerateRowDelete(
	Parse *pParse,     
	Table *pTab,       
	Trigger *pTrigger, 
	int iDataCur,      
	int iIdxCur,       
	int iPk,           
	i16 nPk,           
	u8 count,          
	u8 onconf,         
	u8 eMode,          
	int iIdxNoSeek     
) {
	Vdbe *v = pParse->pVdbe;        
	int iOld = 0;                   
	int iLabel;                     
	u8 opSeek;                      

									
	assert(v);
	VdbeModuleComment((v, "BEGIN: GenRowDel(%d,%d,%d,%d)",
		iDataCur, iIdxCur, iPk, (int)nPk));

	
	iLabel = sqlite3VdbeMakeLabel(v);
	opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
	if (eMode == ONEPASS_OFF) {
		sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
		VdbeCoverageIf(v, opSeek == OP_NotExists);
		VdbeCoverageIf(v, opSeek == OP_NotFound);
	}

	
	if (sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger) {
		u32 mask;                     
		int iCol;                     
		int addrStart;                

									  
		mask = sqlite3TriggerColmask(
			pParse, pTrigger, 0, 0, TRIGGER_BEFORE | TRIGGER_AFTER, pTab, onconf
		);
		mask |= sqlite3FkOldmask(pParse, pTab);
		iOld = pParse->nMem + 1;
		pParse->nMem += (1 + pTab->nCol);

		
		sqlite3VdbeAddOp2(v, OP_Copy, iPk, iOld);
		for (iCol = 0; iCol<pTab->nCol; iCol++) {
			testcase(mask != 0xffffffff && iCol == 31);
			testcase(mask != 0xffffffff && iCol == 32);
			if (mask == 0xffffffff || (iCol <= 31 && (mask & MASKBIT32(iCol)) != 0)) {
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + iCol + 1);
			}
		}

		
		addrStart = sqlite3VdbeCurrentAddr(v);
		sqlite3CodeRowTrigger(pParse, pTrigger,
			TK_DELETE, 0, TRIGGER_BEFORE, pTab, iOld, onconf, iLabel
		);

		
		if (addrStart<sqlite3VdbeCurrentAddr(v)) {
			sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
			VdbeCoverageIf(v, opSeek == OP_NotExists);
			VdbeCoverageIf(v, opSeek == OP_NotFound);
		}

		
		sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
	}

	
	if (pTab->pSelect == 0) {
		u8 p5 = 0;
		sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0, iIdxNoSeek);
		sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, (count ? OPFLAG_NCHANGE : 0));
		sqlite3VdbeChangeP4(v, -1, (char*)pTab, P4_TABLE);
		if (eMode != ONEPASS_OFF) {
			sqlite3VdbeChangeP5(v, OPFLAG_AUXDELETE);
		}
		if (iIdxNoSeek >= 0) {
			sqlite3VdbeAddOp1(v, OP_Delete, iIdxNoSeek);
		}
		if (eMode == ONEPASS_MULTI) p5 |= OPFLAG_SAVEPOSITION;
		sqlite3VdbeChangeP5(v, p5);
	}

	
	sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);

	
	sqlite3CodeRowTrigger(pParse, pTrigger,
		TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel
	);

	
	sqlite3VdbeResolveLabel(v, iLabel);
	VdbeModuleComment((v, "END: GenRowDel()"));
}


SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(
	Parse *pParse,     
	Table *pTab,       
	int iDataCur,      
	int iIdxCur,       
	int *aRegIdx,      
	int iIdxNoSeek     
) {
	int i;             
	int r1 = -1;       
	int iPartIdxLabel; 
	Index *pIdx;       
	Index *pPrior = 0; 
	Vdbe *v;           
	Index *pPk;        

	v = pParse->pVdbe;
	pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
	for (i = 0, pIdx = pTab->pIndex; pIdx; i++, pIdx = pIdx->pNext) {
		assert(iIdxCur + i != iDataCur || pPk == pIdx);
		if (aRegIdx != 0 && aRegIdx[i] == 0) continue;
		if (pIdx == pPk) continue;
		if (iIdxCur + i == iIdxNoSeek) continue;
		VdbeModuleComment((v, "GenRowIdxDel for %s", pIdx->zName));
		r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
			&iPartIdxLabel, pPrior, r1);
		sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur + i, r1,
			pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
		sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
		pPrior = pIdx;
	}
}


SQLITE_PRIVATE int sqlite3GenerateIndexKey(
	Parse *pParse,       
	Index *pIdx,         
	int iDataCur,        
	int regOut,          
	int prefixOnly,      
	int *piPartIdxLabel, 
	Index *pPrior,       
	int regPrior         
) {
	Vdbe *v = pParse->pVdbe;
	int j;
	int regBase;
	int nCol;

	if (piPartIdxLabel) {
		if (pIdx->pPartIdxWhere) {
			*piPartIdxLabel = sqlite3VdbeMakeLabel(v);
			pParse->iSelfTab = iDataCur;
			sqlite3ExprCachePush(pParse);
			sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel,
				SQLITE_JUMPIFNULL);
		}
		else {
			*piPartIdxLabel = 0;
		}
	}
	nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;
	regBase = sqlite3GetTempRange(pParse, nCol);
	if (pPrior && (regBase != regPrior || pPrior->pPartIdxWhere)) pPrior = 0;
	for (j = 0; j<nCol; j++) {
		if (pPrior
			&& pPrior->aiColumn[j] == pIdx->aiColumn[j]
			&& pPrior->aiColumn[j] != XN_EXPR
			) {
			
			continue;
		}
		sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase + j);
		
		sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);
	}
	if (regOut) {
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regOut);
	}
	sqlite3ReleaseTempRange(pParse, regBase, nCol);
	return regBase;
}


SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel) {
	if (iLabel) {
		sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);
		sqlite3ExprCachePop(pParse);
	}
}










static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context) {
	VdbeOp *pOp;
	assert(context->pVdbe != 0);
	pOp = &context->pVdbe->aOp[context->iOp - 1];
	assert(pOp->opcode == OP_CollSeq);
	assert(pOp->p4type == P4_COLLSEQ);
	return pOp->p4.pColl;
}


static void sqlite3SkipAccumulatorLoad(sqlite3_context *context) {
	context->skipFlag = 1;
}


static void minmaxFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int i;
	int mask;    
	int iBest;
	CollSeq *pColl;

	assert(argc>1);
	mask = sqlite3_user_data(context) == 0 ? 0 : -1;
	pColl = sqlite3GetFuncCollSeq(context);
	assert(pColl);
	assert(mask == -1 || mask == 0);
	iBest = 0;
	if (sqlite3_value_type(argv[0]) == SQLITE_NULL) return;
	for (i = 1; i<argc; i++) {
		if (sqlite3_value_type(argv[i]) == SQLITE_NULL) return;
		if ((sqlite3MemCompare(argv[iBest], argv[i], pColl) ^ mask) >= 0) {
			testcase(mask == 0);
			iBest = i;
		}
	}
	sqlite3_result_value(context, argv[iBest]);
}


static void typeofFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	const char *z = 0;
	UNUSED_PARAMETER(NotUsed);
	switch (sqlite3_value_type(argv[0])) {
	case SQLITE_INTEGER: z = "integer"; break;
	case SQLITE_TEXT:    z = "text";    break;
	case SQLITE_FLOAT:   z = "real";    break;
	case SQLITE_BLOB:    z = "blob";    break;
	default:             z = "null";    break;
	}
	sqlite3_result_text(context, z, -1, SQLITE_STATIC);
}



static void lengthFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int len;

	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	switch (sqlite3_value_type(argv[0])) {
	case SQLITE_BLOB:
	case SQLITE_INTEGER:
	case SQLITE_FLOAT: {
		sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
		break;
	}
	case SQLITE_TEXT: {
		const unsigned char *z = sqlite3_value_text(argv[0]);
		if (z == 0) return;
		len = 0;
		while (*z) {
			len++;
			SQLITE_SKIP_UTF8(z);
		}
		sqlite3_result_int(context, len);
		break;
	}
	default: {
		sqlite3_result_null(context);
		break;
	}
	}
}


static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	switch (sqlite3_value_type(argv[0])) {
	case SQLITE_INTEGER: {
		i64 iVal = sqlite3_value_int64(argv[0]);
		if (iVal<0) {
			if (iVal == SMALLEST_INT64) {
				
				sqlite3_result_error(context, "integer overflow", -1);
				return;
			}
			iVal = -iVal;
		}
		sqlite3_result_int64(context, iVal);
		break;
	}
	case SQLITE_NULL: {
		
		sqlite3_result_null(context);
		break;
	}
	default: {
		
		double rVal = sqlite3_value_double(argv[0]);
		if (rVal<0) rVal = -rVal;
		sqlite3_result_double(context, rVal);
		break;
	}
	}
}


static void instrFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *zHaystack;
	const unsigned char *zNeedle;
	int nHaystack;
	int nNeedle;
	int typeHaystack, typeNeedle;
	int N = 1;
	int isText;

	UNUSED_PARAMETER(argc);
	typeHaystack = sqlite3_value_type(argv[0]);
	typeNeedle = sqlite3_value_type(argv[1]);
	if (typeHaystack == SQLITE_NULL || typeNeedle == SQLITE_NULL) return;
	nHaystack = sqlite3_value_bytes(argv[0]);
	nNeedle = sqlite3_value_bytes(argv[1]);
	if (typeHaystack == SQLITE_BLOB && typeNeedle == SQLITE_BLOB) {
		zHaystack = sqlite3_value_blob(argv[0]);
		zNeedle = sqlite3_value_blob(argv[1]);
		isText = 0;
	}
	else {
		zHaystack = sqlite3_value_text(argv[0]);
		zNeedle = sqlite3_value_text(argv[1]);
		isText = 1;
		if (zNeedle == 0) return;
		assert(zHaystack);
	}
	while (nNeedle <= nHaystack && memcmp(zHaystack, zNeedle, nNeedle) != 0) {
		N++;
		do {
			nHaystack--;
			zHaystack++;
		} while (isText && (zHaystack[0] & 0xc0) == 0x80);
	}
	if (nNeedle>nHaystack) N = 0;
	sqlite3_result_int(context, N);
}


static void printfFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	PrintfArguments x;
	StrAccum str;
	const char *zFormat;
	int n;
	sqlite3 *db = sqlite3_context_db_handle(context);

	if (argc >= 1 && (zFormat = (const char*)sqlite3_value_text(argv[0])) != 0) {
		x.nArg = argc - 1;
		x.nUsed = 0;
		x.apArg = argv + 1;
		sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);
		str.printfFlags = SQLITE_PRINTF_SQLFUNC;
		sqlite3XPrintf(&str, zFormat, &x);
		n = str.nChar;
		sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,
			SQLITE_DYNAMIC);
	}
}


static void substrFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *z;
	const unsigned char *z2;
	int len;
	int p0type;
	i64 p1, p2;
	int negP2 = 0;

	assert(argc == 3 || argc == 2);
	if (sqlite3_value_type(argv[1]) == SQLITE_NULL
		|| (argc == 3 && sqlite3_value_type(argv[2]) == SQLITE_NULL)
		) {
		return;
	}
	p0type = sqlite3_value_type(argv[0]);
	p1 = sqlite3_value_int(argv[1]);
	if (p0type == SQLITE_BLOB) {
		len = sqlite3_value_bytes(argv[0]);
		z = sqlite3_value_blob(argv[0]);
		if (z == 0) return;
		assert(len == sqlite3_value_bytes(argv[0]));
	}
	else {
		z = sqlite3_value_text(argv[0]);
		if (z == 0) return;
		len = 0;
		if (p1<0) {
			for (z2 = z; *z2; len++) {
				SQLITE_SKIP_UTF8(z2);
			}
		}
	}
#ifdef SQLITE_SUBSTR_COMPATIBILITY
	
	if (p1 == 0) p1 = 1; 
#endif
	if (argc == 3) {
		p2 = sqlite3_value_int(argv[2]);
		if (p2<0) {
			p2 = -p2;
			negP2 = 1;
		}
	}
	else {
		p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH];
	}
	if (p1<0) {
		p1 += len;
		if (p1<0) {
			p2 += p1;
			if (p2<0) p2 = 0;
			p1 = 0;
		}
	}
	else if (p1>0) {
		p1--;
	}
	else if (p2>0) {
		p2--;
	}
	if (negP2) {
		p1 -= p2;
		if (p1<0) {
			p2 += p1;
			p1 = 0;
		}
	}
	assert(p1 >= 0 && p2 >= 0);
	if (p0type != SQLITE_BLOB) {
		while (*z && p1) {
			SQLITE_SKIP_UTF8(z);
			p1--;
		}
		for (z2 = z; *z2 && p2; p2--) {
			SQLITE_SKIP_UTF8(z2);
		}
		sqlite3_result_text64(context, (char*)z, z2 - z, SQLITE_TRANSIENT,
			SQLITE_UTF8);
	}
	else {
		if (p1 + p2>len) {
			p2 = len - p1;
			if (p2<0) p2 = 0;
		}
		sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, SQLITE_TRANSIENT);
	}
}


#ifndef SQLITE_OMIT_FLOATING_POINT
static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
	int n = 0;
	double r;
	char *zBuf;
	assert(argc == 1 || argc == 2);
	if (argc == 2) {
		if (SQLITE_NULL == sqlite3_value_type(argv[1])) return;
		n = sqlite3_value_int(argv[1]);
		if (n>30) n = 30;
		if (n<0) n = 0;
	}
	if (sqlite3_value_type(argv[0]) == SQLITE_NULL) return;
	r = sqlite3_value_double(argv[0]);
	
	if (n == 0 && r >= 0 && r<LARGEST_INT64 - 1) {
		r = (double)((sqlite_int64)(r + 0.5));
	}
	else if (n == 0 && r<0 && (-r)<LARGEST_INT64 - 1) {
		r = -(double)((sqlite_int64)((-r) + 0.5));
	}
	else {
		zBuf = sqlite3_mprintf("%.*f", n, r);
		if (zBuf == 0) {
			sqlite3_result_error_nomem(context);
			return;
		}
		sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), SQLITE_UTF8);
		sqlite3_free(zBuf);
	}
	sqlite3_result_double(context, r);
}
#endif


static void *contextMalloc(sqlite3_context *context, i64 nByte) {
	char *z;
	sqlite3 *db = sqlite3_context_db_handle(context);
	assert(nByte>0);
	testcase(nByte == db->aLimit[SQLITE_LIMIT_LENGTH]);
	testcase(nByte == db->aLimit[SQLITE_LIMIT_LENGTH] + 1);
	if (nByte>db->aLimit[SQLITE_LIMIT_LENGTH]) {
		sqlite3_result_error_toobig(context);
		z = 0;
	}
	else {
		z = sqlite3Malloc(nByte);
		if (!z) {
			sqlite3_result_error_nomem(context);
		}
	}
	return z;
}


static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
	char *z1;
	const char *z2;
	int i, n;
	UNUSED_PARAMETER(argc);
	z2 = (char*)sqlite3_value_text(argv[0]);
	n = sqlite3_value_bytes(argv[0]);
	
	assert(z2 == (char*)sqlite3_value_text(argv[0]));
	if (z2) {
		z1 = contextMalloc(context, ((i64)n) + 1);
		if (z1) {
			for (i = 0; i<n; i++) {
				z1[i] = (char)sqlite3Toupper(z2[i]);
			}
			sqlite3_result_text(context, z1, n, sqlite3_free);
		}
	}
}
static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
	char *z1;
	const char *z2;
	int i, n;
	UNUSED_PARAMETER(argc);
	z2 = (char*)sqlite3_value_text(argv[0]);
	n = sqlite3_value_bytes(argv[0]);
	
	assert(z2 == (char*)sqlite3_value_text(argv[0]));
	if (z2) {
		z1 = contextMalloc(context, ((i64)n) + 1);
		if (z1) {
			for (i = 0; i<n; i++) {
				z1[i] = sqlite3Tolower(z2[i]);
			}
			sqlite3_result_text(context, z1, n, sqlite3_free);
		}
	}
}


#define noopFunc versionFunc   


static void randomFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	sqlite_int64 r;
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	sqlite3_randomness(sizeof(r), &r);
	if (r<0) {
		
		r = -(r & LARGEST_INT64);
	}
	sqlite3_result_int64(context, r);
}


static void randomBlob(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int n;
	unsigned char *p;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	n = sqlite3_value_int(argv[0]);
	if (n<1) {
		n = 1;
	}
	p = contextMalloc(context, n);
	if (p) {
		sqlite3_randomness(n, p);
		sqlite3_result_blob(context, (char*)p, n, sqlite3_free);
	}
}


static void last_insert_rowid(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	sqlite3 *db = sqlite3_context_db_handle(context);
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	
	sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}


static void changes(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	sqlite3 *db = sqlite3_context_db_handle(context);
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	sqlite3_result_int(context, sqlite3_changes(db));
}


static void total_changes(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	sqlite3 *db = sqlite3_context_db_handle(context);
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	
	sqlite3_result_int(context, sqlite3_total_changes(db));
}


struct compareInfo {
	u8 matchAll;          
	u8 matchOne;          
	u8 matchSet;          
	u8 noCase;            
};


#if defined(SQLITE_EBCDIC)
# define sqlite3Utf8Read(A)        (*((*A)++))
# define Utf8Read(A)               (*(A++))
#else
# define Utf8Read(A)               (A[0]<0x80?*(A++):sqlite3Utf8Read(&A))
#endif

static const struct compareInfo globInfo = { '*', '?', '[', 0 };

static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };

static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };


static int patternCompare(
	const u8 *zPattern,              
	const u8 *zString,               
	const struct compareInfo *pInfo, 
	u32 matchOther                   
) {
	u32 c, c2;                       
	u32 matchOne = pInfo->matchOne;  
	u32 matchAll = pInfo->matchAll;  
	u8 noCase = pInfo->noCase;       
	const u8 *zEscaped = 0;          

	while ((c = Utf8Read(zPattern)) != 0) {
		if (c == matchAll) {  
							  
			while ((c = Utf8Read(zPattern)) == matchAll || c == matchOne) {
				if (c == matchOne && sqlite3Utf8Read(&zString) == 0) {
					return 0;
				}
			}
			if (c == 0) {
				return 1;   
			}
			else if (c == matchOther) {
				if (pInfo->matchSet == 0) {
					c = sqlite3Utf8Read(&zPattern);
					if (c == 0) return 0;
				}
				else {
					
					assert(matchOther<0x80);  
					while (*zString
						&& patternCompare(&zPattern[-1], zString, pInfo, matchOther) == 0) {
						SQLITE_SKIP_UTF8(zString);
					}
					return *zString != 0;
				}
			}

			
			if (c <= 0x80) {
				u32 cx;
				if (noCase) {
					cx = sqlite3Toupper(c);
					c = sqlite3Tolower(c);
				}
				else {
					cx = c;
				}
				while ((c2 = *(zString++)) != 0) {
					if (c2 != c && c2 != cx) continue;
					if (patternCompare(zPattern, zString, pInfo, matchOther)) return 1;
				}
			}
			else {
				while ((c2 = Utf8Read(zString)) != 0) {
					if (c2 != c) continue;
					if (patternCompare(zPattern, zString, pInfo, matchOther)) return 1;
				}
			}
			return 0;
		}
		if (c == matchOther) {
			if (pInfo->matchSet == 0) {
				c = sqlite3Utf8Read(&zPattern);
				if (c == 0) return 0;
				zEscaped = zPattern;
			}
			else {
				u32 prior_c = 0;
				int seen = 0;
				int invert = 0;
				c = sqlite3Utf8Read(&zString);
				if (c == 0) return 0;
				c2 = sqlite3Utf8Read(&zPattern);
				if (c2 == '^') {
					invert = 1;
					c2 = sqlite3Utf8Read(&zPattern);
				}
				if (c2 == ']') {
					if (c == ']') seen = 1;
					c2 = sqlite3Utf8Read(&zPattern);
				}
				while (c2 && c2 != ']') {
					if (c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && prior_c>0) {
						c2 = sqlite3Utf8Read(&zPattern);
						if (c >= prior_c && c <= c2) seen = 1;
						prior_c = 0;
					}
					else {
						if (c == c2) {
							seen = 1;
						}
						prior_c = c2;
					}
					c2 = sqlite3Utf8Read(&zPattern);
				}
				if (c2 == 0 || (seen ^ invert) == 0) {
					return 0;
				}
				continue;
			}
		}
		c2 = Utf8Read(zString);
		if (c == c2) continue;
		if (noCase  && sqlite3Tolower(c) == sqlite3Tolower(c2) && c<0x80 && c2<0x80) {
			continue;
		}
		if (c == matchOne && zPattern != zEscaped && c2 != 0) continue;
		return 0;
	}
	return *zString == 0;
}


SQLITE_API int sqlite3_strglob(const char *zGlobPattern, const char *zString) {
	return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[') == 0;
}


SQLITE_API int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc) {
	return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc) == 0;
}


#ifdef SQLITE_TEST
SQLITE_API int sqlite3_like_count = 0;
#endif



static void likeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *zA, *zB;
	u32 escape;
	int nPat;
	sqlite3 *db = sqlite3_context_db_handle(context);
	struct compareInfo *pInfo = sqlite3_user_data(context);

#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
	if (sqlite3_value_type(argv[0]) == SQLITE_BLOB
		|| sqlite3_value_type(argv[1]) == SQLITE_BLOB
		) {
#ifdef SQLITE_TEST
		sqlite3_like_count++;
#endif
		sqlite3_result_int(context, 0);
		return;
	}
#endif
	zB = sqlite3_value_text(argv[0]);
	zA = sqlite3_value_text(argv[1]);

	
	nPat = sqlite3_value_bytes(argv[0]);
	testcase(nPat == db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]);
	testcase(nPat == db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] + 1);
	if (nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]) {
		sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
		return;
	}
	assert(zB == sqlite3_value_text(argv[0]));  

	if (argc == 3) {
		
		const unsigned char *zEsc = sqlite3_value_text(argv[2]);
		if (zEsc == 0) return;
		if (sqlite3Utf8CharLen((char*)zEsc, -1) != 1) {
			sqlite3_result_error(context,
				"ESCAPE expression must be a single character", -1);
			return;
		}
		escape = sqlite3Utf8Read(&zEsc);
	}
	else {
		escape = pInfo->matchSet;
	}
	if (zA && zB) {
#ifdef SQLITE_TEST
		sqlite3_like_count++;
#endif
		sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape));
	}
}


static void nullifFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	CollSeq *pColl = sqlite3GetFuncCollSeq(context);
	UNUSED_PARAMETER(NotUsed);
	if (sqlite3MemCompare(argv[0], argv[1], pColl) != 0) {
		sqlite3_result_value(context, argv[0]);
	}
}


static void versionFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	
	sqlite3_result_text(context, sqlite3_libversion(), -1, SQLITE_STATIC);
}


static void sourceidFunc(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **NotUsed2
) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	
	sqlite3_result_text(context, sqlite3_sourceid(), -1, SQLITE_STATIC);
}


static void errlogFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	UNUSED_PARAMETER(argc);
	UNUSED_PARAMETER(context);
	sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));
}


#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptionusedFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const char *zOptName;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	
	if ((zOptName = (const char*)sqlite3_value_text(argv[0])) != 0) {
		sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
	}
}
#endif 


#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptiongetFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int n;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	
	n = sqlite3_value_int(argv[0]);
	sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, SQLITE_STATIC);
}
#endif 


static const char hexdigits[] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};


static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	switch (sqlite3_value_type(argv[0])) {
	case SQLITE_FLOAT: {
		double r1, r2;
		char zBuf[50];
		r1 = sqlite3_value_double(argv[0]);
		sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.15g", r1);
		sqlite3AtoF(zBuf, &r2, 20, SQLITE_UTF8);
		if (r1 != r2) {
			sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.20e", r1);
		}
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
		break;
	}
	case SQLITE_INTEGER: {
		sqlite3_result_value(context, argv[0]);
		break;
	}
	case SQLITE_BLOB: {
		char *zText = 0;
		char const *zBlob = sqlite3_value_blob(argv[0]);
		int nBlob = sqlite3_value_bytes(argv[0]);
		assert(zBlob == sqlite3_value_blob(argv[0])); 
		zText = (char *)contextMalloc(context, (2 * (i64)nBlob) + 4);
		if (zText) {
			int i;
			for (i = 0; i<nBlob; i++) {
				zText[(i * 2) + 2] = hexdigits[(zBlob[i] >> 4) & 0x0F];
				zText[(i * 2) + 3] = hexdigits[(zBlob[i]) & 0x0F];
			}
			zText[(nBlob * 2) + 2] = '\'';
			zText[(nBlob * 2) + 3] = '\0';
			zText[0] = 'X';
			zText[1] = '\'';
			sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);
			sqlite3_free(zText);
		}
		break;
	}
	case SQLITE_TEXT: {
		int i, j;
		u64 n;
		const unsigned char *zArg = sqlite3_value_text(argv[0]);
		char *z;

		if (zArg == 0) return;
		for (i = 0, n = 0; zArg[i]; i++) { if (zArg[i] == '\'') n++; }
		z = contextMalloc(context, ((i64)i) + ((i64)n) + 3);
		if (z) {
			z[0] = '\'';
			for (i = 0, j = 1; zArg[i]; i++) {
				z[j++] = zArg[i];
				if (zArg[i] == '\'') {
					z[j++] = '\'';
				}
			}
			z[j++] = '\'';
			z[j] = 0;
			sqlite3_result_text(context, z, j, sqlite3_free);
		}
		break;
	}
	default: {
		assert(sqlite3_value_type(argv[0]) == SQLITE_NULL);
		sqlite3_result_text(context, "NULL", 4, SQLITE_STATIC);
		break;
	}
	}
}


static void unicodeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *z = sqlite3_value_text(argv[0]);
	(void)argc;
	if (z && z[0]) sqlite3_result_int(context, sqlite3Utf8Read(&z));
}


static void charFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	unsigned char *z, *zOut;
	int i;
	zOut = z = sqlite3_malloc64(argc * 4 + 1);
	if (z == 0) {
		sqlite3_result_error_nomem(context);
		return;
	}
	for (i = 0; i<argc; i++) {
		sqlite3_int64 x;
		unsigned c;
		x = sqlite3_value_int64(argv[i]);
		if (x<0 || x>0x10ffff) x = 0xfffd;
		c = (unsigned)(x & 0x1fffff);
		if (c<0x00080) {
			*zOut++ = (u8)(c & 0xFF);
		}
		else if (c<0x00800) {
			*zOut++ = 0xC0 + (u8)((c >> 6) & 0x1F);
			*zOut++ = 0x80 + (u8)(c & 0x3F);
		}
		else if (c<0x10000) {
			*zOut++ = 0xE0 + (u8)((c >> 12) & 0x0F);
			*zOut++ = 0x80 + (u8)((c >> 6) & 0x3F);
			*zOut++ = 0x80 + (u8)(c & 0x3F);
		}
		else {
			*zOut++ = 0xF0 + (u8)((c >> 18) & 0x07);
			*zOut++ = 0x80 + (u8)((c >> 12) & 0x3F);
			*zOut++ = 0x80 + (u8)((c >> 6) & 0x3F);
			*zOut++ = 0x80 + (u8)(c & 0x3F);
		}                                                    \
	}
	sqlite3_result_text64(context, (char*)z, zOut - z, sqlite3_free, SQLITE_UTF8);
}


static void hexFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int i, n;
	const unsigned char *pBlob;
	char *zHex, *z;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	pBlob = sqlite3_value_blob(argv[0]);
	n = sqlite3_value_bytes(argv[0]);
	assert(pBlob == sqlite3_value_blob(argv[0]));  
	z = zHex = contextMalloc(context, ((i64)n) * 2 + 1);
	if (zHex) {
		for (i = 0; i<n; i++, pBlob++) {
			unsigned char c = *pBlob;
			*(z++) = hexdigits[(c >> 4) & 0xf];
			*(z++) = hexdigits[c & 0xf];
		}
		*z = 0;
		sqlite3_result_text(context, zHex, n * 2, sqlite3_free);
	}
}


static void zeroblobFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	i64 n;
	int rc;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	n = sqlite3_value_int64(argv[0]);
	if (n<0) n = 0;
	rc = sqlite3_result_zeroblob64(context, n); 
	if (rc) {
		sqlite3_result_error_code(context, rc);
	}
}


static void replaceFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *zStr;        
	const unsigned char *zPattern;    
	const unsigned char *zRep;        
	unsigned char *zOut;              
	int nStr;                
	int nPattern;            
	int nRep;                
	i64 nOut;                
	int loopLimit;           
	int i, j;                

	assert(argc == 3);
	UNUSED_PARAMETER(argc);
	zStr = sqlite3_value_text(argv[0]);
	if (zStr == 0) return;
	nStr = sqlite3_value_bytes(argv[0]);
	assert(zStr == sqlite3_value_text(argv[0]));  
	zPattern = sqlite3_value_text(argv[1]);
	if (zPattern == 0) {
		assert(sqlite3_value_type(argv[1]) == SQLITE_NULL
			|| sqlite3_context_db_handle(context)->mallocFailed);
		return;
	}
	if (zPattern[0] == 0) {
		assert(sqlite3_value_type(argv[1]) != SQLITE_NULL);
		sqlite3_result_value(context, argv[0]);
		return;
	}
	nPattern = sqlite3_value_bytes(argv[1]);
	assert(zPattern == sqlite3_value_text(argv[1]));  
	zRep = sqlite3_value_text(argv[2]);
	if (zRep == 0) return;
	nRep = sqlite3_value_bytes(argv[2]);
	assert(zRep == sqlite3_value_text(argv[2]));
	nOut = nStr + 1;
	assert(nOut<SQLITE_MAX_LENGTH);
	zOut = contextMalloc(context, (i64)nOut);
	if (zOut == 0) {
		return;
	}
	loopLimit = nStr - nPattern;
	for (i = j = 0; i <= loopLimit; i++) {
		if (zStr[i] != zPattern[0] || memcmp(&zStr[i], zPattern, nPattern)) {
			zOut[j++] = zStr[i];
		}
		else {
			u8 *zOld;
			sqlite3 *db = sqlite3_context_db_handle(context);
			nOut += nRep - nPattern;
			testcase(nOut - 1 == db->aLimit[SQLITE_LIMIT_LENGTH]);
			testcase(nOut - 2 == db->aLimit[SQLITE_LIMIT_LENGTH]);
			if (nOut - 1>db->aLimit[SQLITE_LIMIT_LENGTH]) {
				sqlite3_result_error_toobig(context);
				sqlite3_free(zOut);
				return;
			}
			zOld = zOut;
			zOut = sqlite3_realloc64(zOut, (int)nOut);
			if (zOut == 0) {
				sqlite3_result_error_nomem(context);
				sqlite3_free(zOld);
				return;
			}
			memcpy(&zOut[j], zRep, nRep);
			j += nRep;
			i += nPattern - 1;
		}
	}
	assert(j + nStr - i + 1 == nOut);
	memcpy(&zOut[j], &zStr[i], nStr - i);
	j += nStr - i;
	assert(j <= nOut);
	zOut[j] = 0;
	sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);
}


static void trimFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *zIn;         
	const unsigned char *zCharSet;    
	int nIn;                          
	int flags;                        
	int i;                            
	unsigned char *aLen = 0;          
	unsigned char **azChar = 0;       
	int nChar;                        

	if (sqlite3_value_type(argv[0]) == SQLITE_NULL) {
		return;
	}
	zIn = sqlite3_value_text(argv[0]);
	if (zIn == 0) return;
	nIn = sqlite3_value_bytes(argv[0]);
	assert(zIn == sqlite3_value_text(argv[0]));
	if (argc == 1) {
		static const unsigned char lenOne[] = { 1 };
		static unsigned char * const azOne[] = { (u8*)" " };
		nChar = 1;
		aLen = (u8*)lenOne;
		azChar = (unsigned char **)azOne;
		zCharSet = 0;
	}
	else if ((zCharSet = sqlite3_value_text(argv[1])) == 0) {
		return;
	}
	else {
		const unsigned char *z;
		for (z = zCharSet, nChar = 0; *z; nChar++) {
			SQLITE_SKIP_UTF8(z);
		}
		if (nChar>0) {
			azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*) + 1));
			if (azChar == 0) {
				return;
			}
			aLen = (unsigned char*)&azChar[nChar];
			for (z = zCharSet, nChar = 0; *z; nChar++) {
				azChar[nChar] = (unsigned char *)z;
				SQLITE_SKIP_UTF8(z);
				aLen[nChar] = (u8)(z - azChar[nChar]);
			}
		}
	}
	if (nChar>0) {
		flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context));
		if (flags & 1) {
			while (nIn>0) {
				int len = 0;
				for (i = 0; i<nChar; i++) {
					len = aLen[i];
					if (len <= nIn && memcmp(zIn, azChar[i], len) == 0) break;
				}
				if (i >= nChar) break;
				zIn += len;
				nIn -= len;
			}
		}
		if (flags & 2) {
			while (nIn>0) {
				int len = 0;
				for (i = 0; i<nChar; i++) {
					len = aLen[i];
					if (len <= nIn && memcmp(&zIn[nIn - len], azChar[i], len) == 0) break;
				}
				if (i >= nChar) break;
				nIn -= len;
			}
		}
		if (zCharSet) {
			sqlite3_free(azChar);
		}
	}
	sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT);
}


#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION

static void unknownFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	
}
#endif 



#ifdef SQLITE_SOUNDEX

static void soundexFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	char zResult[8];
	const u8 *zIn;
	int i, j;
	static const unsigned char iCode[] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,
		1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,
		0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,
		1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,
	};
	assert(argc == 1);
	zIn = (u8*)sqlite3_value_text(argv[0]);
	if (zIn == 0) zIn = (u8*)"";
	for (i = 0; zIn[i] && !sqlite3Isalpha(zIn[i]); i++) {}
	if (zIn[i]) {
		u8 prevcode = iCode[zIn[i] & 0x7f];
		zResult[0] = sqlite3Toupper(zIn[i]);
		for (j = 1; j<4 && zIn[i]; i++) {
			int code = iCode[zIn[i] & 0x7f];
			if (code>0) {
				if (code != prevcode) {
					prevcode = code;
					zResult[j++] = code + '0';
				}
			}
			else {
				prevcode = 0;
			}
		}
		while (j<4) {
			zResult[j++] = '0';
		}
		zResult[j] = 0;
		sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);
	}
	else {
		
		sqlite3_result_text(context, "?000", 4, SQLITE_STATIC);
	}
}
#endif 

#ifndef SQLITE_OMIT_LOAD_EXTENSION

static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv) {
	const char *zFile = (const char *)sqlite3_value_text(argv[0]);
	const char *zProc;
	sqlite3 *db = sqlite3_context_db_handle(context);
	char *zErrMsg = 0;

	
	if ((db->flags & SQLITE_LoadExtFunc) == 0) {
		sqlite3_result_error(context, "not authorized", -1);
		return;
	}

	if (argc == 2) {
		zProc = (const char *)sqlite3_value_text(argv[1]);
	}
	else {
		zProc = 0;
	}
	if (zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg)) {
		sqlite3_result_error(context, zErrMsg, -1);
		sqlite3_free(zErrMsg);
	}
}
#endif



typedef struct SumCtx SumCtx;
struct SumCtx {
	double rSum;      
	i64 iSum;         
	i64 cnt;          
	u8 overflow;      
	u8 approx;        
};


static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv) {
	SumCtx *p;
	int type;
	assert(argc == 1);
	UNUSED_PARAMETER(argc);
	p = sqlite3_aggregate_context(context, sizeof(*p));
	type = sqlite3_value_numeric_type(argv[0]);
	if (p && type != SQLITE_NULL) {
		p->cnt++;
		if (type == SQLITE_INTEGER) {
			i64 v = sqlite3_value_int64(argv[0]);
			p->rSum += v;
			if ((p->approx | p->overflow) == 0 && sqlite3AddInt64(&p->iSum, v)) {
				p->overflow = 1;
			}
		}
		else {
			p->rSum += sqlite3_value_double(argv[0]);
			p->approx = 1;
		}
	}
}
static void sumFinalize(sqlite3_context *context) {
	SumCtx *p;
	p = sqlite3_aggregate_context(context, 0);
	if (p && p->cnt>0) {
		if (p->overflow) {
			sqlite3_result_error(context, "integer overflow", -1);
		}
		else if (p->approx) {
			sqlite3_result_double(context, p->rSum);
		}
		else {
			sqlite3_result_int64(context, p->iSum);
		}
	}
}
static void avgFinalize(sqlite3_context *context) {
	SumCtx *p;
	p = sqlite3_aggregate_context(context, 0);
	if (p && p->cnt>0) {
		sqlite3_result_double(context, p->rSum / (double)p->cnt);
	}
}
static void totalFinalize(sqlite3_context *context) {
	SumCtx *p;
	p = sqlite3_aggregate_context(context, 0);
	
	sqlite3_result_double(context, p ? p->rSum : (double)0);
}


typedef struct CountCtx CountCtx;
struct CountCtx {
	i64 n;
};


static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv) {
	CountCtx *p;
	p = sqlite3_aggregate_context(context, sizeof(*p));
	if ((argc == 0 || SQLITE_NULL != sqlite3_value_type(argv[0])) && p) {
		p->n++;
	}

#ifndef SQLITE_OMIT_DEPRECATED
	
	assert(argc == 1 || p == 0 || p->n>0x7fffffff
		|| p->n == sqlite3_aggregate_count(context));
#endif
}
static void countFinalize(sqlite3_context *context) {
	CountCtx *p;
	p = sqlite3_aggregate_context(context, 0);
	sqlite3_result_int64(context, p ? p->n : 0);
}


static void minmaxStep(
	sqlite3_context *context,
	int NotUsed,
	sqlite3_value **argv
) {
	Mem *pArg = (Mem *)argv[0];
	Mem *pBest;
	UNUSED_PARAMETER(NotUsed);

	pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
	if (!pBest) return;

	if (sqlite3_value_type(argv[0]) == SQLITE_NULL) {
		if (pBest->flags) sqlite3SkipAccumulatorLoad(context);
	}
	else if (pBest->flags) {
		int max;
		int cmp;
		CollSeq *pColl = sqlite3GetFuncCollSeq(context);
		
		max = sqlite3_user_data(context) != 0;
		cmp = sqlite3MemCompare(pBest, pArg, pColl);
		if ((max && cmp<0) || (!max && cmp>0)) {
			sqlite3VdbeMemCopy(pBest, pArg);
		}
		else {
			sqlite3SkipAccumulatorLoad(context);
		}
	}
	else {
		pBest->db = sqlite3_context_db_handle(context);
		sqlite3VdbeMemCopy(pBest, pArg);
	}
}
static void minMaxFinalize(sqlite3_context *context) {
	sqlite3_value *pRes;
	pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
	if (pRes) {
		if (pRes->flags) {
			sqlite3_result_value(context, pRes);
		}
		sqlite3VdbeMemRelease(pRes);
	}
}


static void groupConcatStep(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const char *zVal;
	StrAccum *pAccum;
	const char *zSep;
	int nVal, nSep;
	assert(argc == 1 || argc == 2);
	if (sqlite3_value_type(argv[0]) == SQLITE_NULL) return;
	pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));

	if (pAccum) {
		sqlite3 *db = sqlite3_context_db_handle(context);
		int firstTerm = pAccum->mxAlloc == 0;
		pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];
		if (!firstTerm) {
			if (argc == 2) {
				zSep = (char*)sqlite3_value_text(argv[1]);
				nSep = sqlite3_value_bytes(argv[1]);
			}
			else {
				zSep = ",";
				nSep = 1;
			}
			if (nSep) sqlite3StrAccumAppend(pAccum, zSep, nSep);
		}
		zVal = (char*)sqlite3_value_text(argv[0]);
		nVal = sqlite3_value_bytes(argv[0]);
		if (zVal) sqlite3StrAccumAppend(pAccum, zVal, nVal);
	}
}
static void groupConcatFinalize(sqlite3_context *context) {
	StrAccum *pAccum;
	pAccum = sqlite3_aggregate_context(context, 0);
	if (pAccum) {
		if (pAccum->accError == STRACCUM_TOOBIG) {
			sqlite3_result_error_toobig(context);
		}
		else if (pAccum->accError == STRACCUM_NOMEM) {
			sqlite3_result_error_nomem(context);
		}
		else {
			sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1,
				sqlite3_free);
		}
	}
}


SQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db) {
	int rc = sqlite3_overload_function(db, "MATCH", 2);
	assert(rc == SQLITE_NOMEM || rc == SQLITE_OK);
	if (rc == SQLITE_NOMEM) {
		sqlite3OomFault(db);
	}
}


static void setLikeOptFlag(sqlite3 *db, const char *zName, u8 flagVal) {
	FuncDef *pDef;
	pDef = sqlite3FindFunction(db, zName, 2, SQLITE_UTF8, 0);
	if (ALWAYS(pDef)) {
		pDef->funcFlags |= flagVal;
	}
}


SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive) {
	struct compareInfo *pInfo;
	if (caseSensitive) {
		pInfo = (struct compareInfo*)&likeInfoAlt;
	}
	else {
		pInfo = (struct compareInfo*)&likeInfoNorm;
	}
	sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0);
	sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0);
	sqlite3CreateFunc(db, "glob", 2, SQLITE_UTF8,
		(struct compareInfo*)&globInfo, likeFunc, 0, 0, 0);
	setLikeOptFlag(db, "glob", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE);
	setLikeOptFlag(db, "like",
		caseSensitive ? (SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE) : SQLITE_FUNC_LIKE);
}


SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc) {
	FuncDef *pDef;
	if (pExpr->op != TK_FUNCTION
		|| !pExpr->x.pList
		|| pExpr->x.pList->nExpr != 2
		) {
		return 0;
	}
	assert(!ExprHasProperty(pExpr, EP_xIsSelect));
	pDef = sqlite3FindFunction(db, pExpr->u.zToken, 2, SQLITE_UTF8, 0);
	if (NEVER(pDef == 0) || (pDef->funcFlags & SQLITE_FUNC_LIKE) == 0) {
		return 0;
	}

	
	memcpy(aWc, pDef->pUserData, 3);
	assert((char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll);
	assert(&((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne);
	assert(&((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet);
	*pIsNocase = (pDef->funcFlags & SQLITE_FUNC_CASE) == 0;
	return 1;
}


SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void) {
	
	static FuncDef aBuiltinFunc[] = {
#ifdef SQLITE_SOUNDEX
		FUNCTION(soundex,            1, 0, 0, soundexFunc),
#endif
#ifndef SQLITE_OMIT_LOAD_EXTENSION
		VFUNCTION(load_extension,    1, 0, 0, loadExt),
		VFUNCTION(load_extension,    2, 0, 0, loadExt),
#endif
#if SQLITE_USER_AUTHENTICATION
		FUNCTION(sqlite_crypt,       2, 0, 0, sqlite3CryptFunc),
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
		DFUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc),
		DFUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc),
#endif 
		FUNCTION2(unlikely,          1, 0, 0, noopFunc,  SQLITE_FUNC_UNLIKELY),
		FUNCTION2(likelihood,        2, 0, 0, noopFunc,  SQLITE_FUNC_UNLIKELY),
		FUNCTION2(likely,            1, 0, 0, noopFunc,  SQLITE_FUNC_UNLIKELY),
		FUNCTION(ltrim,              1, 1, 0, trimFunc),
		FUNCTION(ltrim,              2, 1, 0, trimFunc),
		FUNCTION(rtrim,              1, 2, 0, trimFunc),
		FUNCTION(rtrim,              2, 2, 0, trimFunc),
		FUNCTION(trim,               1, 3, 0, trimFunc),
		FUNCTION(trim,               2, 3, 0, trimFunc),
		FUNCTION(min,               -1, 0, 1, minmaxFunc),
		FUNCTION(min,                0, 0, 1, 0),
		AGGREGATE2(min,              1, 0, 1, minmaxStep,      minMaxFinalize,
		SQLITE_FUNC_MINMAX),
		FUNCTION(max,               -1, 1, 1, minmaxFunc),
		FUNCTION(max,                0, 1, 1, 0),
		AGGREGATE2(max,              1, 1, 1, minmaxStep,      minMaxFinalize,
		SQLITE_FUNC_MINMAX),
		FUNCTION2(typeof,            1, 0, 0, typeofFunc,  SQLITE_FUNC_TYPEOF),
		FUNCTION2(length,            1, 0, 0, lengthFunc,  SQLITE_FUNC_LENGTH),
		FUNCTION(instr,              2, 0, 0, instrFunc),
		FUNCTION(printf,            -1, 0, 0, printfFunc),
		FUNCTION(unicode,            1, 0, 0, unicodeFunc),
		FUNCTION(char,              -1, 0, 0, charFunc),
		FUNCTION(abs,                1, 0, 0, absFunc),
#ifndef SQLITE_OMIT_FLOATING_POINT
		FUNCTION(round,              1, 0, 0, roundFunc),
		FUNCTION(round,              2, 0, 0, roundFunc),
#endif
		FUNCTION(upper,              1, 0, 0, upperFunc),
		FUNCTION(lower,              1, 0, 0, lowerFunc),
		FUNCTION(hex,                1, 0, 0, hexFunc),
		FUNCTION2(ifnull,            2, 0, 0, noopFunc,  SQLITE_FUNC_COALESCE),
		VFUNCTION(random,            0, 0, 0, randomFunc),
		VFUNCTION(randomblob,        1, 0, 0, randomBlob),
		FUNCTION(nullif,             2, 0, 1, nullifFunc),
		DFUNCTION(sqlite_version,    0, 0, 0, versionFunc),
		DFUNCTION(sqlite_source_id,  0, 0, 0, sourceidFunc),
		FUNCTION(sqlite_log,         2, 0, 0, errlogFunc),
		FUNCTION(quote,              1, 0, 0, quoteFunc),
		VFUNCTION(last_insert_rowid, 0, 0, 0, last_insert_rowid),
		VFUNCTION(changes,           0, 0, 0, changes),
		VFUNCTION(total_changes,     0, 0, 0, total_changes),
		FUNCTION(replace,            3, 0, 0, replaceFunc),
		FUNCTION(zeroblob,           1, 0, 0, zeroblobFunc),
		FUNCTION(substr,             2, 0, 0, substrFunc),
		FUNCTION(substr,             3, 0, 0, substrFunc),
		AGGREGATE(sum,               1, 0, 0, sumStep,         sumFinalize),
		AGGREGATE(total,             1, 0, 0, sumStep,         totalFinalize),
		AGGREGATE(avg,               1, 0, 0, sumStep,         avgFinalize),
		AGGREGATE2(count,            0, 0, 0, countStep,       countFinalize,
		SQLITE_FUNC_COUNT),
		AGGREGATE(count,             1, 0, 0, countStep,       countFinalize),
		AGGREGATE(group_concat,      1, 0, 0, groupConcatStep, groupConcatFinalize),
		AGGREGATE(group_concat,      2, 0, 0, groupConcatStep, groupConcatFinalize),

		LIKEFUNC(glob, 2, &globInfo, SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE),
#ifdef SQLITE_CASE_SENSITIVE_LIKE
		LIKEFUNC(like, 2, &likeInfoAlt, SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE),
		LIKEFUNC(like, 3, &likeInfoAlt, SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE),
#else
		LIKEFUNC(like, 2, &likeInfoNorm, SQLITE_FUNC_LIKE),
		LIKEFUNC(like, 3, &likeInfoNorm, SQLITE_FUNC_LIKE),
#endif
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
		FUNCTION(unknown,           -1, 0, 0, unknownFunc),
#endif
		FUNCTION(coalesce,           1, 0, 0, 0),
		FUNCTION(coalesce,           0, 0, 0, 0),
		FUNCTION2(coalesce,         -1, 0, 0, noopFunc,  SQLITE_FUNC_COALESCE),
	};
#ifndef SQLITE_OMIT_ALTERTABLE
	sqlite3AlterFunctions();
#endif
#if defined(SQLITE_ENABLE_STAT3) || defined(SQLITE_ENABLE_STAT4)
	sqlite3AnalyzeFunctions();
#endif
	sqlite3RegisterDateTimeFunctions();
	sqlite3InsertBuiltinFuncs(aBuiltinFunc, ArraySize(aBuiltinFunc));

#if 0  
	{
		int i;
		FuncDef *p;
		for (i = 0; i<SQLITE_FUNC_HASH_SZ; i++) {
			printf("FUNC-HASH %02d:", i);
			for (p = sqlite3BuiltinFunctions.a[i]; p; p = p->u.pHash) {
				int n = sqlite3Strlen30(p->zName);
				int h = p->zName[0] + n;
				printf(" %s(%d)", p->zName, h);
			}
			printf("\n");
		}
	}
#endif
}






#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER






SQLITE_PRIVATE int sqlite3FkLocateIndex(
	Parse *pParse,                  
	Table *pParent,                 
	FKey *pFKey,                    
	Index **ppIdx,                  
	int **paiCol                    
) {
	Index *pIdx = 0;                    
	int *aiCol = 0;                     
	int nCol = pFKey->nCol;             
	char *zKey = pFKey->aCol[0].zCol;   

										
	assert(ppIdx && *ppIdx == 0);
	assert(!paiCol || *paiCol == 0);
	assert(pParse);

	
	if (nCol == 1) {
		
		if (pParent->iPKey >= 0) {
			if (!zKey) return 0;
			if (!sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey)) return 0;
		}
	}
	else if (paiCol) {
		assert(nCol>1);
		aiCol = (int *)sqlite3DbMallocRawNN(pParse->db, nCol * sizeof(int));
		if (!aiCol) return 1;
		*paiCol = aiCol;
	}

	for (pIdx = pParent->pIndex; pIdx; pIdx = pIdx->pNext) {
		if (pIdx->nKeyCol == nCol && IsUniqueIndex(pIdx)) {
			

			if (zKey == 0) {
				
				if (IsPrimaryKeyIndex(pIdx)) {
					if (aiCol) {
						int i;
						for (i = 0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;
					}
					break;
				}
			}
			else {
				
				int i, j;
				for (i = 0; i<nCol; i++) {
					i16 iCol = pIdx->aiColumn[i];     
					const char *zDfltColl;            
					char *zIdxCol;                    

					if (iCol<0) break; 

									   
					zDfltColl = pParent->aCol[iCol].zColl;
					if (!zDfltColl) zDfltColl = sqlite3StrBINARY;
					if (sqlite3StrICmp(pIdx->azColl[i], zDfltColl)) break;

					zIdxCol = pParent->aCol[iCol].zName;
					for (j = 0; j<nCol; j++) {
						if (sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol) == 0) {
							if (aiCol) aiCol[i] = pFKey->aCol[j].iFrom;
							break;
						}
					}
					if (j == nCol) break;
				}
				if (i == nCol) break;      
			}
		}
	}

	if (!pIdx) {
		if (!pParse->disableTriggers) {
			sqlite3ErrorMsg(pParse,
				"foreign key mismatch - \"%w\" referencing \"%w\"",
				pFKey->pFrom->zName, pFKey->zTo);
		}
		sqlite3DbFree(pParse->db, aiCol);
		return 1;
	}

	*ppIdx = pIdx;
	return 0;
}


static void fkLookupParent(
	Parse *pParse,        
	int iDb,              
	Table *pTab,          
	Index *pIdx,          
	FKey *pFKey,          
	int *aiCol,           
	int regData,          
	int nIncr,            
	int isIgnore          
) {
	int i;                                    
	Vdbe *v = sqlite3GetVdbe(pParse);         
	int iCur = pParse->nTab - 1;              
	int iOk = sqlite3VdbeMakeLabel(v);        

											  
	if (nIncr<0) {
		sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, iOk);
		VdbeCoverage(v);
	}
	for (i = 0; i<pFKey->nCol; i++) {
		int iReg = aiCol[i] + regData + 1;
		sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk); VdbeCoverage(v);
	}

	if (isIgnore == 0) {
		if (pIdx == 0) {
			
			int iMustBeInt;               
			int regTemp = sqlite3GetTempReg(pParse);

			
			sqlite3VdbeAddOp2(v, OP_SCopy, aiCol[0] + 1 + regData, regTemp);
			iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);
			VdbeCoverage(v);

			
			if (pTab == pFKey->pFrom && nIncr == 1) {
				sqlite3VdbeAddOp3(v, OP_Eq, regData, iOk, regTemp); VdbeCoverage(v);
				sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
			}

			sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);
			sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp); VdbeCoverage(v);
			sqlite3VdbeGoto(v, iOk);
			sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v) - 2);
			sqlite3VdbeJumpHere(v, iMustBeInt);
			sqlite3ReleaseTempReg(pParse, regTemp);
		}
		else {
			int nCol = pFKey->nCol;
			int regTemp = sqlite3GetTempRange(pParse, nCol);
			int regRec = sqlite3GetTempReg(pParse);

			sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
			for (i = 0; i<nCol; i++) {
				sqlite3VdbeAddOp2(v, OP_Copy, aiCol[i] + 1 + regData, regTemp + i);
			}

			
			if (pTab == pFKey->pFrom && nIncr == 1) {
				int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;
				for (i = 0; i<nCol; i++) {
					int iChild = aiCol[i] + 1 + regData;
					int iParent = pIdx->aiColumn[i] + 1 + regData;
					assert(pIdx->aiColumn[i] >= 0);
					assert(aiCol[i] != pTab->iPKey);
					if (pIdx->aiColumn[i] == pTab->iPKey) {
						
						iParent = regData;
					}
					sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent); VdbeCoverage(v);
					sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);
				}
				sqlite3VdbeGoto(v, iOk);
			}

			sqlite3VdbeAddOp4(v, OP_MakeRecord, regTemp, nCol, regRec,
				sqlite3IndexAffinityStr(pParse->db, pIdx), nCol);
			sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regRec, 0); VdbeCoverage(v);

			sqlite3ReleaseTempReg(pParse, regRec);
			sqlite3ReleaseTempRange(pParse, regTemp, nCol);
		}
	}

	if (!pFKey->isDeferred && !(pParse->db->flags & SQLITE_DeferFKs)
		&& !pParse->pToplevel
		&& !pParse->isMultiWrite
		) {
		
		assert(nIncr == 1);
		sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,
			OE_Abort, 0, P4_STATIC, P5_ConstraintFK);
	}
	else {
		if (nIncr>0 && pFKey->isDeferred == 0) {
			sqlite3MayAbort(pParse);
		}
		sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
	}

	sqlite3VdbeResolveLabel(v, iOk);
	sqlite3VdbeAddOp1(v, OP_Close, iCur);
}



static Expr *exprTableRegister(
	Parse *pParse,     
	Table *pTab,       
	int regBase,       
	i16 iCol           
) {
	Expr *pExpr;
	Column *pCol;
	const char *zColl;
	sqlite3 *db = pParse->db;

	pExpr = sqlite3Expr(db, TK_REGISTER, 0);
	if (pExpr) {
		if (iCol >= 0 && iCol != pTab->iPKey) {
			pCol = &pTab->aCol[iCol];
			pExpr->iTable = regBase + iCol + 1;
			pExpr->affinity = pCol->affinity;
			zColl = pCol->zColl;
			if (zColl == 0) zColl = db->pDfltColl->zName;
			pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
		}
		else {
			pExpr->iTable = regBase;
			pExpr->affinity = SQLITE_AFF_INTEGER;
		}
	}
	return pExpr;
}


static Expr *exprTableColumn(
	sqlite3 *db,      
	Table *pTab,      
	int iCursor,      
	i16 iCol          
) {
	Expr *pExpr = sqlite3Expr(db, TK_COLUMN, 0);
	if (pExpr) {
		pExpr->pTab = pTab;
		pExpr->iTable = iCursor;
		pExpr->iColumn = iCol;
	}
	return pExpr;
}


static void fkScanChildren(
	Parse *pParse,                  
	SrcList *pSrc,                  
	Table *pTab,                    
	Index *pIdx,                    
	FKey *pFKey,                    
	int *aiCol,                     
	int regData,                    
	int nIncr                       
) {
	sqlite3 *db = pParse->db;       
	int i;                          
	Expr *pWhere = 0;               
	NameContext sNameContext;       
	WhereInfo *pWInfo;              
	int iFkIfZero = 0;              
	Vdbe *v = sqlite3GetVdbe(pParse);

	assert(pIdx == 0 || pIdx->pTable == pTab);
	assert(pIdx == 0 || pIdx->nKeyCol == pFKey->nCol);
	assert(pIdx != 0 || pFKey->nCol == 1);
	assert(pIdx != 0 || HasRowid(pTab));

	if (nIncr<0) {
		iFkIfZero = sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, 0);
		VdbeCoverage(v);
	}

	
	for (i = 0; i<pFKey->nCol; i++) {
		Expr *pLeft;                  
		Expr *pRight;                 
		Expr *pEq;                    
		i16 iCol;                     
		const char *zCol;             

		iCol = pIdx ? pIdx->aiColumn[i] : -1;
		pLeft = exprTableRegister(pParse, pTab, regData, iCol);
		iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
		assert(iCol >= 0);
		zCol = pFKey->pFrom->aCol[iCol].zName;
		pRight = sqlite3Expr(db, TK_ID, zCol);
		pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight, 0);
		pWhere = sqlite3ExprAnd(db, pWhere, pEq);
	}

	
	if (pTab == pFKey->pFrom && nIncr>0) {
		Expr *pNe;                    
		Expr *pLeft;                  
		Expr *pRight;                 
		if (HasRowid(pTab)) {
			pLeft = exprTableRegister(pParse, pTab, regData, -1);
			pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);
			pNe = sqlite3PExpr(pParse, TK_NE, pLeft, pRight, 0);
		}
		else {
			Expr *pEq, *pAll = 0;
			Index *pPk = sqlite3PrimaryKeyIndex(pTab);
			assert(pIdx != 0);
			for (i = 0; i<pPk->nKeyCol; i++) {
				i16 iCol = pIdx->aiColumn[i];
				assert(iCol >= 0);
				pLeft = exprTableRegister(pParse, pTab, regData, iCol);
				pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, iCol);
				pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight, 0);
				pAll = sqlite3ExprAnd(db, pAll, pEq);
			}
			pNe = sqlite3PExpr(pParse, TK_NOT, pAll, 0, 0);
		}
		pWhere = sqlite3ExprAnd(db, pWhere, pNe);
	}

	
	memset(&sNameContext, 0, sizeof(NameContext));
	sNameContext.pSrcList = pSrc;
	sNameContext.pParse = pParse;
	sqlite3ResolveExprNames(&sNameContext, pWhere);

	
	pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);
	sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
	if (pWInfo) {
		sqlite3WhereEnd(pWInfo);
	}

	
	sqlite3ExprDelete(db, pWhere);
	if (iFkIfZero) {
		sqlite3VdbeJumpHere(v, iFkIfZero);
	}
}


SQLITE_PRIVATE FKey *sqlite3FkReferences(Table *pTab) {
	return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName);
}


static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p) {
	if (p) {
		TriggerStep *pStep = p->step_list;
		sqlite3ExprDelete(dbMem, pStep->pWhere);
		sqlite3ExprListDelete(dbMem, pStep->pExprList);
		sqlite3SelectDelete(dbMem, pStep->pSelect);
		sqlite3ExprDelete(dbMem, p->pWhen);
		sqlite3DbFree(dbMem, p);
	}
}


SQLITE_PRIVATE void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab) {
	sqlite3 *db = pParse->db;
	if ((db->flags&SQLITE_ForeignKeys) && !IsVirtual(pTab) && !pTab->pSelect) {
		int iSkip = 0;
		Vdbe *v = sqlite3GetVdbe(pParse);

		assert(v);                  
		if (sqlite3FkReferences(pTab) == 0) {
			
			FKey *p;
			for (p = pTab->pFKey; p; p = p->pNextFrom) {
				if (p->isDeferred || (db->flags & SQLITE_DeferFKs)) break;
			}
			if (!p) return;
			iSkip = sqlite3VdbeMakeLabel(v);
			sqlite3VdbeAddOp2(v, OP_FkIfZero, 1, iSkip); VdbeCoverage(v);
		}

		pParse->disableTriggers = 1;
		sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0);
		pParse->disableTriggers = 0;

		
		if ((db->flags & SQLITE_DeferFKs) == 0) {
			sqlite3VdbeAddOp2(v, OP_FkIfZero, 0, sqlite3VdbeCurrentAddr(v) + 2);
			VdbeCoverage(v);
			sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,
				OE_Abort, 0, P4_STATIC, P5_ConstraintFK);
		}

		if (iSkip) {
			sqlite3VdbeResolveLabel(v, iSkip);
		}
	}
}



static int fkChildIsModified(
	Table *pTab,                    
	FKey *p,                        
	int *aChange,                   
	int bChngRowid                  
) {
	int i;
	for (i = 0; i<p->nCol; i++) {
		int iChildKey = p->aCol[i].iFrom;
		if (aChange[iChildKey] >= 0) return 1;
		if (iChildKey == pTab->iPKey && bChngRowid) return 1;
	}
	return 0;
}


static int fkParentIsModified(
	Table *pTab,
	FKey *p,
	int *aChange,
	int bChngRowid
) {
	int i;
	for (i = 0; i<p->nCol; i++) {
		char *zKey = p->aCol[i].zCol;
		int iKey;
		for (iKey = 0; iKey<pTab->nCol; iKey++) {
			if (aChange[iKey] >= 0 || (iKey == pTab->iPKey && bChngRowid)) {
				Column *pCol = &pTab->aCol[iKey];
				if (zKey) {
					if (0 == sqlite3StrICmp(pCol->zName, zKey)) return 1;
				}
				else if (pCol->colFlags & COLFLAG_PRIMKEY) {
					return 1;
				}
			}
		}
	}
	return 0;
}


static int isSetNullAction(Parse *pParse, FKey *pFKey) {
	Parse *pTop = sqlite3ParseToplevel(pParse);
	if (pTop->pTriggerPrg) {
		Trigger *p = pTop->pTriggerPrg->pTrigger;
		if ((p == pFKey->apTrigger[0] && pFKey->aAction[0] == OE_SetNull)
			|| (p == pFKey->apTrigger[1] && pFKey->aAction[1] == OE_SetNull)
			) {
			return 1;
		}
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3FkCheck(
	Parse *pParse,                  
	Table *pTab,                    
	int regOld,                     
	int regNew,                     
	int *aChange,                   
	int bChngRowid                  
) {
	sqlite3 *db = pParse->db;       
	FKey *pFKey;                    
	int iDb;                        
	const char *zDb;                
	int isIgnoreErrors = pParse->disableTriggers;

	
	assert((regOld == 0) != (regNew == 0));

	
	if ((db->flags&SQLITE_ForeignKeys) == 0) return;

	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	zDb = db->aDb[iDb].zDbSName;

	
	for (pFKey = pTab->pFKey; pFKey; pFKey = pFKey->pNextFrom) {
		Table *pTo;                   
		Index *pIdx = 0;              
		int *aiFree = 0;
		int *aiCol;
		int iCol;
		int i;
		int bIgnore = 0;

		if (aChange
			&& sqlite3_stricmp(pTab->zName, pFKey->zTo) != 0
			&& fkChildIsModified(pTab, pFKey, aChange, bChngRowid) == 0
			) {
			continue;
		}

		
		if (pParse->disableTriggers) {
			pTo = sqlite3FindTable(db, pFKey->zTo, zDb);
		}
		else {
			pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);
		}
		if (!pTo || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree)) {
			assert(isIgnoreErrors == 0 || (regOld != 0 && regNew == 0));
			if (!isIgnoreErrors || db->mallocFailed) return;
			if (pTo == 0) {
				
				Vdbe *v = sqlite3GetVdbe(pParse);
				int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;
				for (i = 0; i<pFKey->nCol; i++) {
					int iReg = pFKey->aCol[i].iFrom + regOld + 1;
					sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iJump); VdbeCoverage(v);
				}
				sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, -1);
			}
			continue;
		}
		assert(pFKey->nCol == 1 || (aiFree && pIdx));

		if (aiFree) {
			aiCol = aiFree;
		}
		else {
			iCol = pFKey->aCol[0].iFrom;
			aiCol = &iCol;
		}
		for (i = 0; i<pFKey->nCol; i++) {
			if (aiCol[i] == pTab->iPKey) {
				aiCol[i] = -1;
			}
			assert(pIdx == 0 || pIdx->aiColumn[i] >= 0);
#ifndef SQLITE_OMIT_AUTHORIZATION
			
			if (db->xAuth) {
				int rcauth;
				char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;
				rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
				bIgnore = (rcauth == SQLITE_IGNORE);
			}
#endif
		}

		
		sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
		pParse->nTab++;

		if (regOld != 0) {
			
			fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);
		}
		if (regNew != 0 && !isSetNullAction(pParse, pFKey)) {
			
			fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1, bIgnore);
		}

		sqlite3DbFree(db, aiFree);
	}

	
	for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey->pNextTo) {
		Index *pIdx = 0;              
		SrcList *pSrc;
		int *aiCol = 0;

		if (aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid) == 0) {
			continue;
		}

		if (!pFKey->isDeferred && !(db->flags & SQLITE_DeferFKs)
			&& !pParse->pToplevel && !pParse->isMultiWrite
			) {
			assert(regOld == 0 && regNew != 0);
			
			continue;
		}

		if (sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol)) {
			if (!isIgnoreErrors || db->mallocFailed) return;
			continue;
		}
		assert(aiCol || pFKey->nCol == 1);

		
		pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
		if (pSrc) {
			struct SrcList_item *pItem = pSrc->a;
			pItem->pTab = pFKey->pFrom;
			pItem->zName = pFKey->pFrom->zName;
			pItem->pTab->nRef++;
			pItem->iCursor = pParse->nTab++;

			if (regNew != 0) {
				fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);
			}
			if (regOld != 0) {
				int eAction = pFKey->aAction[aChange != 0];
				fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
				
				if (!pFKey->isDeferred && eAction != OE_Cascade && eAction != OE_SetNull) {
					sqlite3MayAbort(pParse);
				}
			}
			pItem->zName = 0;
			sqlite3SrcListDelete(db, pSrc);
		}
		sqlite3DbFree(db, aiCol);
	}
}

#define COLUMN_MASK(x) (((x)>31) ? 0xffffffff : ((u32)1<<(x)))


SQLITE_PRIVATE u32 sqlite3FkOldmask(
	Parse *pParse,                  
	Table *pTab                     
) {
	u32 mask = 0;
	if (pParse->db->flags&SQLITE_ForeignKeys) {
		FKey *p;
		int i;
		for (p = pTab->pFKey; p; p = p->pNextFrom) {
			for (i = 0; i<p->nCol; i++) mask |= COLUMN_MASK(p->aCol[i].iFrom);
		}
		for (p = sqlite3FkReferences(pTab); p; p = p->pNextTo) {
			Index *pIdx = 0;
			sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);
			if (pIdx) {
				for (i = 0; i<pIdx->nKeyCol; i++) {
					assert(pIdx->aiColumn[i] >= 0);
					mask |= COLUMN_MASK(pIdx->aiColumn[i]);
				}
			}
		}
	}
	return mask;
}



SQLITE_PRIVATE int sqlite3FkRequired(
	Parse *pParse,                  
	Table *pTab,                    
	int *aChange,                   
	int chngRowid                   
) {
	if (pParse->db->flags&SQLITE_ForeignKeys) {
		if (!aChange) {
			
			return (sqlite3FkReferences(pTab) || pTab->pFKey);
		}
		else {
			
			FKey *p;

			
			for (p = pTab->pFKey; p; p = p->pNextFrom) {
				if (fkChildIsModified(pTab, p, aChange, chngRowid)) return 1;
			}

			
			for (p = sqlite3FkReferences(pTab); p; p = p->pNextTo) {
				if (fkParentIsModified(pTab, p, aChange, chngRowid)) return 1;
			}
		}
	}
	return 0;
}


static Trigger *fkActionTrigger(
	Parse *pParse,                  
	Table *pTab,                    
	FKey *pFKey,                    
	ExprList *pChanges              
) {
	sqlite3 *db = pParse->db;       
	int action;                     
	Trigger *pTrigger;              
	int iAction = (pChanges != 0);    

	action = pFKey->aAction[iAction];
	if (action == OE_Restrict && (db->flags & SQLITE_DeferFKs)) {
		return 0;
	}
	pTrigger = pFKey->apTrigger[iAction];

	if (action != OE_None && !pTrigger) {
		char const *zFrom;            
		int nFrom;                    
		Index *pIdx = 0;              
		int *aiCol = 0;               
		TriggerStep *pStep = 0;        
		Expr *pWhere = 0;             
		ExprList *pList = 0;          
		Select *pSelect = 0;          
		int i;                        
		Expr *pWhen = 0;              

		if (sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol)) return 0;
		assert(aiCol || pFKey->nCol == 1);

		for (i = 0; i<pFKey->nCol; i++) {
			Token tOld = { "old", 3 };  
			Token tNew = { "new", 3 };  
			Token tFromCol;             
			Token tToCol;               
			int iFromCol;               
			Expr *pEq;                  

			iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
			assert(iFromCol >= 0);
			assert(pIdx != 0 || (pTab->iPKey >= 0 && pTab->iPKey<pTab->nCol));
			assert(pIdx == 0 || pIdx->aiColumn[i] >= 0);
			sqlite3TokenInit(&tToCol,
				pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName);
			sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zName);

			
			pEq = sqlite3PExpr(pParse, TK_EQ,
				sqlite3PExpr(pParse, TK_DOT,
					sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
					sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)
					, 0),
				sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)
				, 0);
			pWhere = sqlite3ExprAnd(db, pWhere, pEq);

			
			if (pChanges) {
				pEq = sqlite3PExpr(pParse, TK_IS,
					sqlite3PExpr(pParse, TK_DOT,
						sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
						sqlite3ExprAlloc(db, TK_ID, &tToCol, 0),
						0),
					sqlite3PExpr(pParse, TK_DOT,
						sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
						sqlite3ExprAlloc(db, TK_ID, &tToCol, 0),
						0),
					0);
				pWhen = sqlite3ExprAnd(db, pWhen, pEq);
			}

			if (action != OE_Restrict && (action != OE_Cascade || pChanges)) {
				Expr *pNew;
				if (action == OE_Cascade) {
					pNew = sqlite3PExpr(pParse, TK_DOT,
						sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
						sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)
						, 0);
				}
				else if (action == OE_SetDflt) {
					Expr *pDflt = pFKey->pFrom->aCol[iFromCol].pDflt;
					if (pDflt) {
						pNew = sqlite3ExprDup(db, pDflt, 0);
					}
					else {
						pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);
					}
				}
				else {
					pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);
				}
				pList = sqlite3ExprListAppend(pParse, pList, pNew);
				sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);
			}
		}
		sqlite3DbFree(db, aiCol);

		zFrom = pFKey->pFrom->zName;
		nFrom = sqlite3Strlen30(zFrom);

		if (action == OE_Restrict) {
			Token tFrom;
			Expr *pRaise;

			tFrom.z = zFrom;
			tFrom.n = nFrom;
			pRaise = sqlite3Expr(db, TK_RAISE, "FOREIGN KEY constraint failed");
			if (pRaise) {
				pRaise->affinity = OE_Abort;
			}
			pSelect = sqlite3SelectNew(pParse,
				sqlite3ExprListAppend(pParse, 0, pRaise),
				sqlite3SrcListAppend(db, 0, &tFrom, 0),
				pWhere,
				0, 0, 0, 0, 0, 0
			);
			pWhere = 0;
		}

		
		db->lookaside.bDisable++;

		pTrigger = (Trigger *)sqlite3DbMallocZero(db,
			sizeof(Trigger) +         
			sizeof(TriggerStep) +     
			nFrom + 1                 
		);
		if (pTrigger) {
			pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
			pStep->zTarget = (char *)&pStep[1];
			memcpy((char *)pStep->zTarget, zFrom, nFrom);

			pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);
			pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);
			pStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
			if (pWhen) {
				pWhen = sqlite3PExpr(pParse, TK_NOT, pWhen, 0, 0);
				pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);
			}
		}

		
		db->lookaside.bDisable--;

		sqlite3ExprDelete(db, pWhere);
		sqlite3ExprDelete(db, pWhen);
		sqlite3ExprListDelete(db, pList);
		sqlite3SelectDelete(db, pSelect);
		if (db->mallocFailed == 1) {
			fkTriggerDelete(db, pTrigger);
			return 0;
		}
		assert(pStep != 0);

		switch (action) {
		case OE_Restrict:
			pStep->op = TK_SELECT;
			break;
		case OE_Cascade:
			if (!pChanges) {
				pStep->op = TK_DELETE;
				break;
			}
		default:
			pStep->op = TK_UPDATE;
		}
		pStep->pTrig = pTrigger;
		pTrigger->pSchema = pTab->pSchema;
		pTrigger->pTabSchema = pTab->pSchema;
		pFKey->apTrigger[iAction] = pTrigger;
		pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);
	}

	return pTrigger;
}


SQLITE_PRIVATE void sqlite3FkActions(
	Parse *pParse,                  
	Table *pTab,                    
	ExprList *pChanges,             
	int regOld,                     
	int *aChange,                   
	int bChngRowid                  
) {
	
	if (pParse->db->flags&SQLITE_ForeignKeys) {
		FKey *pFKey;                  
		for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey->pNextTo) {
			if (aChange == 0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid)) {
				Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
				if (pAct) {
					sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, OE_Abort, 0);
				}
			}
		}
	}
}

#endif 


SQLITE_PRIVATE void sqlite3FkDelete(sqlite3 *db, Table *pTab) {
	FKey *pFKey;                    
	FKey *pNext;                    

	assert(db == 0 || IsVirtual(pTab)
		|| sqlite3SchemaMutexHeld(db, 0, pTab->pSchema));
	for (pFKey = pTab->pFKey; pFKey; pFKey = pNext) {

		
		if (!db || db->pnBytesFreed == 0) {
			if (pFKey->pPrevTo) {
				pFKey->pPrevTo->pNextTo = pFKey->pNextTo;
			}
			else {
				void *p = (void *)pFKey->pNextTo;
				const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);
				sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, p);
			}
			if (pFKey->pNextTo) {
				pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;
			}
		}

		
		assert(pFKey->isDeferred == 0 || pFKey->isDeferred == 1);

		
#ifndef SQLITE_OMIT_TRIGGER
		fkTriggerDelete(db, pFKey->apTrigger[0]);
		fkTriggerDelete(db, pFKey->apTrigger[1]);
#endif

		pNext = pFKey->pNextFrom;
		sqlite3DbFree(db, pFKey);
	}
}
#endif 







SQLITE_PRIVATE void sqlite3OpenTable(
	Parse *pParse,  
	int iCur,       
	int iDb,        
	Table *pTab,    
	int opcode      
) {
	Vdbe *v;
	assert(!IsVirtual(pTab));
	v = sqlite3GetVdbe(pParse);
	assert(opcode == OP_OpenWrite || opcode == OP_OpenRead);
	sqlite3TableLock(pParse, iDb, pTab->tnum,
		(opcode == OP_OpenWrite) ? 1 : 0, pTab->zName);
	if (HasRowid(pTab)) {
		sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nCol);
		VdbeComment((v, "%s", pTab->zName));
	}
	else {
		Index *pPk = sqlite3PrimaryKeyIndex(pTab);
		assert(pPk != 0);
		assert(pPk->tnum == pTab->tnum);
		sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);
		sqlite3VdbeSetP4KeyInfo(pParse, pPk);
		VdbeComment((v, "%s", pTab->zName));
	}
}


SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx) {
	if (!pIdx->zColAff) {
		
		int n;
		Table *pTab = pIdx->pTable;
		pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn + 1);
		if (!pIdx->zColAff) {
			sqlite3OomFault(db);
			return 0;
		}
		for (n = 0; n<pIdx->nColumn; n++) {
			i16 x = pIdx->aiColumn[n];
			if (x >= 0) {
				pIdx->zColAff[n] = pTab->aCol[x].affinity;
			}
			else if (x == XN_ROWID) {
				pIdx->zColAff[n] = SQLITE_AFF_INTEGER;
			}
			else {
				char aff;
				assert(x == XN_EXPR);
				assert(pIdx->aColExpr != 0);
				aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
				if (aff == 0) aff = SQLITE_AFF_BLOB;
				pIdx->zColAff[n] = aff;
			}
		}
		pIdx->zColAff[n] = 0;
	}

	return pIdx->zColAff;
}


SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg) {
	int i;
	char *zColAff = pTab->zColAff;
	if (zColAff == 0) {
		sqlite3 *db = sqlite3VdbeDb(v);
		zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol + 1);
		if (!zColAff) {
			sqlite3OomFault(db);
			return;
		}

		for (i = 0; i<pTab->nCol; i++) {
			zColAff[i] = pTab->aCol[i].affinity;
		}
		do {
			zColAff[i--] = 0;
		} while (i >= 0 && zColAff[i] == SQLITE_AFF_BLOB);
		pTab->zColAff = zColAff;
	}
	i = sqlite3Strlen30(zColAff);
	if (i) {
		if (iReg) {
			sqlite3VdbeAddOp4(v, OP_Affinity, iReg, i, 0, zColAff, i);
		}
		else {
			sqlite3VdbeChangeP4(v, -1, zColAff, i);
		}
	}
}


static int readsTable(Parse *p, int iDb, Table *pTab) {
	Vdbe *v = sqlite3GetVdbe(p);
	int i;
	int iEnd = sqlite3VdbeCurrentAddr(v);
#ifndef SQLITE_OMIT_VIRTUALTABLE
	VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;
#endif

	for (i = 1; i<iEnd; i++) {
		VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
		assert(pOp != 0);
		if (pOp->opcode == OP_OpenRead && pOp->p3 == iDb) {
			Index *pIndex;
			int tnum = pOp->p2;
			if (tnum == pTab->tnum) {
				return 1;
			}
			for (pIndex = pTab->pIndex; pIndex; pIndex = pIndex->pNext) {
				if (tnum == pIndex->tnum) {
					return 1;
				}
			}
		}
#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (pOp->opcode == OP_VOpen && pOp->p4.pVtab == pVTab) {
			assert(pOp->p4.pVtab != 0);
			assert(pOp->p4type == P4_VTAB);
			return 1;
		}
#endif
	}
	return 0;
}

#ifndef SQLITE_OMIT_AUTOINCREMENT

static int autoIncBegin(
	Parse *pParse,      
	int iDb,            
	Table *pTab         
) {
	int memId = 0;      
	if ((pTab->tabFlags & TF_Autoincrement) != 0
		&& (pParse->db->flags & SQLITE_Vacuum) == 0
		) {
		Parse *pToplevel = sqlite3ParseToplevel(pParse);
		AutoincInfo *pInfo;

		pInfo = pToplevel->pAinc;
		while (pInfo && pInfo->pTab != pTab) { pInfo = pInfo->pNext; }
		if (pInfo == 0) {
			pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));
			if (pInfo == 0) return 0;
			pInfo->pNext = pToplevel->pAinc;
			pToplevel->pAinc = pInfo;
			pInfo->pTab = pTab;
			pInfo->iDb = iDb;
			pToplevel->nMem++;                  
			pInfo->regCtr = ++pToplevel->nMem;  
			pToplevel->nMem++;                  
		}
		memId = pInfo->regCtr;
	}
	return memId;
}


SQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse) {
	AutoincInfo *p;            
	sqlite3 *db = pParse->db;  
	Db *pDb;                   
	int memId;                 
	Vdbe *v = pParse->pVdbe;   

							   
	assert(pParse->pTriggerTab == 0);
	assert(sqlite3IsToplevel(pParse));

	assert(v);   
	for (p = pParse->pAinc; p; p = p->pNext) {
		static const int iLn = VDBE_OFFSET_LINENO(2);
		static const VdbeOpList autoInc[] = {
			{ OP_Null,    0,  0, 0 },
			{ OP_Rewind,  0,  9, 0 },
			{ OP_Column,  0,  0, 0 },
			{ OP_Ne,      0,  7, 0 },
			{ OP_Rowid,   0,  0, 0 },
			{ OP_Column,  0,  1, 0 },
			{ OP_Goto,    0,  9, 0 },
			{ OP_Next,    0,  2, 0 },
			{ OP_Integer, 0,  0, 0 },
			{ OP_Close,   0,  0, 0 }
		};
		VdbeOp *aOp;
		pDb = &db->aDb[p->iDb];
		memId = p->regCtr;
		assert(sqlite3SchemaMutexHeld(db, 0, pDb->pSchema));
		sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenRead);
		sqlite3VdbeLoadString(v, memId - 1, p->pTab->zName);
		aOp = sqlite3VdbeAddOpList(v, ArraySize(autoInc), autoInc, iLn);
		if (aOp == 0) break;
		aOp[0].p2 = memId;
		aOp[0].p3 = memId + 1;
		aOp[2].p3 = memId;
		aOp[3].p1 = memId - 1;
		aOp[3].p3 = memId;
		aOp[3].p5 = SQLITE_JUMPIFNULL;
		aOp[4].p2 = memId + 1;
		aOp[5].p3 = memId;
		aOp[8].p2 = memId;
	}
}


static void autoIncStep(Parse *pParse, int memId, int regRowid) {
	if (memId>0) {
		sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid);
	}
}


static SQLITE_NOINLINE void autoIncrementEnd(Parse *pParse) {
	AutoincInfo *p;
	Vdbe *v = pParse->pVdbe;
	sqlite3 *db = pParse->db;

	assert(v);
	for (p = pParse->pAinc; p; p = p->pNext) {
		static const int iLn = VDBE_OFFSET_LINENO(2);
		static const VdbeOpList autoIncEnd[] = {
			{ OP_NotNull,     0, 2, 0 },
			{ OP_NewRowid,    0, 0, 0 },
			{ OP_MakeRecord,  0, 2, 0 },
			{ OP_Insert,      0, 0, 0 },
			{ OP_Close,       0, 0, 0 }
		};
		VdbeOp *aOp;
		Db *pDb = &db->aDb[p->iDb];
		int iRec;
		int memId = p->regCtr;

		iRec = sqlite3GetTempReg(pParse);
		assert(sqlite3SchemaMutexHeld(db, 0, pDb->pSchema));
		sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);
		aOp = sqlite3VdbeAddOpList(v, ArraySize(autoIncEnd), autoIncEnd, iLn);
		if (aOp == 0) break;
		aOp[0].p1 = memId + 1;
		aOp[1].p2 = memId + 1;
		aOp[2].p1 = memId - 1;
		aOp[2].p3 = iRec;
		aOp[3].p2 = iRec;
		aOp[3].p3 = memId + 1;
		aOp[3].p5 = OPFLAG_APPEND;
		sqlite3ReleaseTempReg(pParse, iRec);
	}
}
SQLITE_PRIVATE void sqlite3AutoincrementEnd(Parse *pParse) {
	if (pParse->pAinc) autoIncrementEnd(pParse);
}
#else

# define autoIncBegin(A,B,C) (0)
# define autoIncStep(A,B,C)
#endif 



static int xferOptimization(
	Parse *pParse,        
	Table *pDest,         
	Select *pSelect,      
	int onError,          
	int iDbDest           
);


SQLITE_PRIVATE void sqlite3Insert(
	Parse *pParse,        
	SrcList *pTabList,    
	Select *pSelect,      
	IdList *pColumn,      
	int onError           
) {
	sqlite3 *db;          
	Table *pTab;          
	char *zTab;           
	int i, j, idx;        
	Vdbe *v;              
	Index *pIdx;          
	int nColumn;          
	int nHidden = 0;      
	int iDataCur = 0;     
	int iIdxCur = 0;      
	int ipkColumn = -1;   
	int endOfLoop;        
	int srcTab = 0;       
	int addrInsTop = 0;   
	int addrCont = 0;     
	SelectDest dest;      
	int iDb;              
	u8 useTempTable = 0;  
	u8 appendFlag = 0;    
	u8 withoutRowid;      
	u8 bIdListInOrder;    
	ExprList *pList = 0;  

						  
	int regFromSelect = 0;
	int regAutoinc = 0;   
	int regRowCount = 0;  
	int regIns;           
	int regRowid;         
	int regData;          
	int *aRegIdx = 0;     

#ifndef SQLITE_OMIT_TRIGGER
	int isView;                 
	Trigger *pTrigger;          
	int tmask;                  
#endif

	db = pParse->db;
	memset(&dest, 0, sizeof(dest));
	if (pParse->nErr || db->mallocFailed) {
		goto insert_cleanup;
	}

	
	if (pSelect && (pSelect->selFlags & SF_Values) != 0 && pSelect->pPrior == 0) {
		pList = pSelect->pEList;
		pSelect->pEList = 0;
		sqlite3SelectDelete(db, pSelect);
		pSelect = 0;
	}

	
	assert(pTabList->nSrc == 1);
	zTab = pTabList->a[0].zName;
	if (NEVER(zTab == 0)) goto insert_cleanup;
	pTab = sqlite3SrcListLookup(pParse, pTabList);
	if (pTab == 0) {
		goto insert_cleanup;
	}
	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	assert(iDb<db->nDb);
	if (sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab->zName, 0,
		db->aDb[iDb].zDbSName)) {
		goto insert_cleanup;
	}
	withoutRowid = !HasRowid(pTab);

	
#ifndef SQLITE_OMIT_TRIGGER
	pTrigger = sqlite3TriggersExist(pParse, pTab, TK_INSERT, 0, &tmask);
	isView = pTab->pSelect != 0;
#else
# define pTrigger 0
# define tmask 0
# define isView 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif
	assert((pTrigger && tmask) || (pTrigger == 0 && tmask == 0));

	
	if (sqlite3ViewGetColumnNames(pParse, pTab)) {
		goto insert_cleanup;
	}

	
	if (sqlite3IsReadOnly(pParse, pTab, tmask)) {
		goto insert_cleanup;
	}

	
	v = sqlite3GetVdbe(pParse);
	if (v == 0) goto insert_cleanup;
	if (pParse->nested == 0) sqlite3VdbeCountChanges(v);
	sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);

#ifndef SQLITE_OMIT_XFER_OPT
	
	if (pColumn == 0 && xferOptimization(pParse, pTab, pSelect, onError, iDb)) {
		assert(!pTrigger);
		assert(pList == 0);
		goto insert_end;
	}
#endif 

	
	regAutoinc = autoIncBegin(pParse, iDb, pTab);

	
	regRowid = regIns = pParse->nMem + 1;
	pParse->nMem += pTab->nCol + 1;
	if (IsVirtual(pTab)) {
		regRowid++;
		pParse->nMem++;
	}
	regData = regRowid + 1;

	
	bIdListInOrder = (pTab->tabFlags & TF_OOOHidden) == 0;
	if (pColumn) {
		for (i = 0; i<pColumn->nId; i++) {
			pColumn->a[i].idx = -1;
		}
		for (i = 0; i<pColumn->nId; i++) {
			for (j = 0; j<pTab->nCol; j++) {
				if (sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName) == 0) {
					pColumn->a[i].idx = j;
					if (i != j) bIdListInOrder = 0;
					if (j == pTab->iPKey) {
						ipkColumn = i;  assert(!withoutRowid);
					}
					break;
				}
			}
			if (j >= pTab->nCol) {
				if (sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid) {
					ipkColumn = i;
					bIdListInOrder = 0;
				}
				else {
					sqlite3ErrorMsg(pParse, "table %S has no column named %s",
						pTabList, 0, pColumn->a[i].zName);
					pParse->checkSchema = 1;
					goto insert_cleanup;
				}
			}
		}
	}

	
	if (pSelect) {
		
		int regYield;       
		int addrTop;        
		int rc;             

		regYield = ++pParse->nMem;
		addrTop = sqlite3VdbeCurrentAddr(v) + 1;
		sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
		sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
		dest.iSdst = bIdListInOrder ? regData : 0;
		dest.nSdst = pTab->nCol;
		rc = sqlite3Select(pParse, pSelect, &dest);
		regFromSelect = dest.iSdst;
		if (rc || db->mallocFailed || pParse->nErr) goto insert_cleanup;
		sqlite3VdbeEndCoroutine(v, regYield);
		sqlite3VdbeJumpHere(v, addrTop - 1);                       
		assert(pSelect->pEList);
		nColumn = pSelect->pEList->nExpr;

		
		if (pTrigger || readsTable(pParse, iDb, pTab)) {
			useTempTable = 1;
		}

		if (useTempTable) {
			
			int regRec;          
			int regTempRowid;    
			int addrL;           

			srcTab = pParse->nTab++;
			regRec = sqlite3GetTempReg(pParse);
			regTempRowid = sqlite3GetTempReg(pParse);
			sqlite3VdbeAddOp2(v, OP_OpenEphemeral, srcTab, nColumn);
			addrL = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm); VdbeCoverage(v);
			sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec);
			sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regTempRowid);
			sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regTempRowid);
			sqlite3VdbeGoto(v, addrL);
			sqlite3VdbeJumpHere(v, addrL);
			sqlite3ReleaseTempReg(pParse, regRec);
			sqlite3ReleaseTempReg(pParse, regTempRowid);
		}
	}
	else {
		
		NameContext sNC;
		memset(&sNC, 0, sizeof(sNC));
		sNC.pParse = pParse;
		srcTab = -1;
		assert(useTempTable == 0);
		if (pList) {
			nColumn = pList->nExpr;
			if (sqlite3ResolveExprListNames(&sNC, pList)) {
				goto insert_cleanup;
			}
		}
		else {
			nColumn = 0;
		}
	}

	
	if (pColumn == 0 && nColumn>0) {
		ipkColumn = pTab->iPKey;
	}

	
	for (i = 0; i<pTab->nCol; i++) {
		nHidden += (IsHiddenColumn(&pTab->aCol[i]) ? 1 : 0);
	}
	if (pColumn == 0 && nColumn && nColumn != (pTab->nCol - nHidden)) {
		sqlite3ErrorMsg(pParse,
			"table %S has %d columns but %d values were supplied",
			pTabList, 0, pTab->nCol - nHidden, nColumn);
		goto insert_cleanup;
	}
	if (pColumn != 0 && nColumn != pColumn->nId) {
		sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
		goto insert_cleanup;
	}

	
	if (db->flags & SQLITE_CountRows) {
		regRowCount = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);
	}

	
	if (!isView) {
		int nIdx;
		nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,
			&iDataCur, &iIdxCur);
		aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx + 1));
		if (aRegIdx == 0) {
			goto insert_cleanup;
		}
		for (i = 0; i<nIdx; i++) {
			aRegIdx[i] = ++pParse->nMem;
		}
	}

	
	if (useTempTable) {
		
		addrInsTop = sqlite3VdbeAddOp1(v, OP_Rewind, srcTab); VdbeCoverage(v);
		addrCont = sqlite3VdbeCurrentAddr(v);
	}
	else if (pSelect) {
		
		addrInsTop = addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
		VdbeCoverage(v);
	}

	
	endOfLoop = sqlite3VdbeMakeLabel(v);
	if (tmask & TRIGGER_BEFORE) {
		int regCols = sqlite3GetTempRange(pParse, pTab->nCol + 1);

		
		if (ipkColumn<0) {
			sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
		}
		else {
			int addr1;
			assert(!withoutRowid);
			if (useTempTable) {
				sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regCols);
			}
			else {
				assert(pSelect == 0);  
				sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
			}
			addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols); VdbeCoverage(v);
			sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
			sqlite3VdbeJumpHere(v, addr1);
			sqlite3VdbeAddOp1(v, OP_MustBeInt, regCols); VdbeCoverage(v);
		}

		
		assert(!IsVirtual(pTab));

		
		for (i = j = 0; i<pTab->nCol; i++) {
			if (pColumn) {
				for (j = 0; j<pColumn->nId; j++) {
					if (pColumn->a[j].idx == i) break;
				}
			}
			if ((!useTempTable && !pList) || (pColumn && j >= pColumn->nId)
				|| (pColumn == 0 && IsOrdinaryHiddenColumn(&pTab->aCol[i]))) {
				sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols + i + 1);
			}
			else if (useTempTable) {
				sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, regCols + i + 1);
			}
			else {
				assert(pSelect == 0); 
				sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols + i + 1);
			}
			if (pColumn == 0 && !IsOrdinaryHiddenColumn(&pTab->aCol[i])) j++;
		}

		
		if (!isView) {
			sqlite3TableAffinity(v, pTab, regCols + 1);
		}

		
		sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_BEFORE,
			pTab, regCols - pTab->nCol - 1, onError, endOfLoop);

		sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol + 1);
	}

	
	if (!isView) {
		if (IsVirtual(pTab)) {
			
			sqlite3VdbeAddOp2(v, OP_Null, 0, regIns);
		}
		if (ipkColumn >= 0) {
			if (useTempTable) {
				sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regRowid);
			}
			else if (pSelect) {
				sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect + ipkColumn, regRowid);
			}
			else {
				VdbeOp *pOp;
				sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
				pOp = sqlite3VdbeGetOp(v, -1);
				if (ALWAYS(pOp) && pOp->opcode == OP_Null && !IsVirtual(pTab)) {
					appendFlag = 1;
					pOp->opcode = OP_NewRowid;
					pOp->p1 = iDataCur;
					pOp->p2 = regRowid;
					pOp->p3 = regAutoinc;
				}
			}
			
			if (!appendFlag) {
				int addr1;
				if (!IsVirtual(pTab)) {
					addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);
					sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
					sqlite3VdbeJumpHere(v, addr1);
				}
				else {
					addr1 = sqlite3VdbeCurrentAddr(v);
					sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, addr1 + 2); VdbeCoverage(v);
				}
				sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); VdbeCoverage(v);
			}
		}
		else if (IsVirtual(pTab) || withoutRowid) {
			sqlite3VdbeAddOp2(v, OP_Null, 0, regRowid);
		}
		else {
			sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
			appendFlag = 1;
		}
		autoIncStep(pParse, regAutoinc, regRowid);

		
		nHidden = 0;
		for (i = 0; i<pTab->nCol; i++) {
			int iRegStore = regRowid + 1 + i;
			if (i == pTab->iPKey) {
				
				sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);
				continue;
			}
			if (pColumn == 0) {
				if (IsHiddenColumn(&pTab->aCol[i])) {
					j = -1;
					nHidden++;
				}
				else {
					j = i - nHidden;
				}
			}
			else {
				for (j = 0; j<pColumn->nId; j++) {
					if (pColumn->a[j].idx == i) break;
				}
			}
			if (j<0 || nColumn == 0 || (pColumn && j >= pColumn->nId)) {
				sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);
			}
			else if (useTempTable) {
				sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, iRegStore);
			}
			else if (pSelect) {
				if (regFromSelect != regData) {
					sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect + j, iRegStore);
				}
			}
			else {
				sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
			}
		}

		
#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (IsVirtual(pTab)) {
			const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
			sqlite3VtabMakeWritable(pParse, pTab);
			sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol + 2, regIns, pVTab, P4_VTAB);
			sqlite3VdbeChangeP5(v, onError == OE_Default ? OE_Abort : onError);
			sqlite3MayAbort(pParse);
		}
		else
#endif
		{
			int isReplace;    
			sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
				regIns, 0, ipkColumn >= 0, onError, endOfLoop, &isReplace, 0
			);
			sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);
			sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,
				regIns, aRegIdx, 0, appendFlag, isReplace == 0);
		}
	}

	
	if ((db->flags & SQLITE_CountRows) != 0) {
		sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);
	}

	if (pTrigger) {
		
		sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_AFTER,
			pTab, regData - 2 - pTab->nCol, onError, endOfLoop);
	}

	
	sqlite3VdbeResolveLabel(v, endOfLoop);
	if (useTempTable) {
		sqlite3VdbeAddOp2(v, OP_Next, srcTab, addrCont); VdbeCoverage(v);
		sqlite3VdbeJumpHere(v, addrInsTop);
		sqlite3VdbeAddOp1(v, OP_Close, srcTab);
	}
	else if (pSelect) {
		sqlite3VdbeGoto(v, addrCont);
		sqlite3VdbeJumpHere(v, addrInsTop);
	}

	if (!IsVirtual(pTab) && !isView) {
		
		if (iDataCur<iIdxCur) sqlite3VdbeAddOp1(v, OP_Close, iDataCur);
		for (idx = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, idx++) {
			sqlite3VdbeAddOp1(v, OP_Close, idx + iIdxCur);
		}
	}

insert_end:
	
	if (pParse->nested == 0 && pParse->pTriggerTab == 0) {
		sqlite3AutoincrementEnd(pParse);
	}

	
	if ((db->flags&SQLITE_CountRows) && !pParse->nested && !pParse->pTriggerTab) {
		sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);
		sqlite3VdbeSetNumCols(v, 1);
		sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows inserted", SQLITE_STATIC);
	}

insert_cleanup:
	sqlite3SrcListDelete(db, pTabList);
	sqlite3ExprListDelete(db, pList);
	sqlite3SelectDelete(db, pSelect);
	sqlite3IdListDelete(db, pColumn);
	sqlite3DbFree(db, aRegIdx);
}


#ifdef isView
#undef isView
#endif
#ifdef pTrigger
#undef pTrigger
#endif
#ifdef tmask
#undef tmask
#endif


#define CKCNSTRNT_COLUMN   0x01    
#define CKCNSTRNT_ROWID    0x02    


static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr) {
	if (pExpr->op == TK_COLUMN) {
		assert(pExpr->iColumn >= 0 || pExpr->iColumn == -1);
		if (pExpr->iColumn >= 0) {
			if (pWalker->u.aiCol[pExpr->iColumn] >= 0) {
				pWalker->eCode |= CKCNSTRNT_COLUMN;
			}
		}
		else {
			pWalker->eCode |= CKCNSTRNT_ROWID;
		}
	}
	return WRC_Continue;
}


static int checkConstraintUnchanged(Expr *pExpr, int *aiChng, int chngRowid) {
	Walker w;
	memset(&w, 0, sizeof(w));
	w.eCode = 0;
	w.xExprCallback = checkConstraintExprNode;
	w.u.aiCol = aiChng;
	sqlite3WalkExpr(&w, pExpr);
	if (!chngRowid) {
		testcase((w.eCode & CKCNSTRNT_ROWID) != 0);
		w.eCode &= ~CKCNSTRNT_ROWID;
	}
	testcase(w.eCode == 0);
	testcase(w.eCode == CKCNSTRNT_COLUMN);
	testcase(w.eCode == CKCNSTRNT_ROWID);
	testcase(w.eCode == (CKCNSTRNT_ROWID | CKCNSTRNT_COLUMN));
	return !w.eCode;
}


SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
	Parse *pParse,       
	Table *pTab,         
	int *aRegIdx,        
	int iDataCur,        
	int iIdxCur,         
	int regNewData,      
	int regOldData,      
	u8 pkChng,           
	u8 overrideError,    
	int ignoreDest,      
	int *pbMayReplace,   
	int *aiChng          
) {
	Vdbe *v;             
	Index *pIdx;         
	Index *pPk = 0;      
	sqlite3 *db;         
	int i;               
	int ix;              
	int nCol;            
	int onError;         
	int addr1;           
	int seenReplace = 0; 
	int nPkField;        
	int ipkTop = 0;      
	int ipkBottom = 0;   
	u8 isUpdate;         
	u8 bAffinityDone = 0;  
	int regRowid = -1;   

	isUpdate = regOldData != 0;
	db = pParse->db;
	v = sqlite3GetVdbe(pParse);
	assert(v != 0);
	assert(pTab->pSelect == 0);  
	nCol = pTab->nCol;

	
	if (HasRowid(pTab)) {
		pPk = 0;
		nPkField = 1;
	}
	else {
		pPk = sqlite3PrimaryKeyIndex(pTab);
		nPkField = pPk->nKeyCol;
	}

	
	VdbeModuleComment((v, "BEGIN: GenCnstCks(%d,%d,%d,%d,%d)",
		iDataCur, iIdxCur, regNewData, regOldData, pkChng));

	
	for (i = 0; i<nCol; i++) {
		if (i == pTab->iPKey) {
			continue;        
		}
		if (aiChng && aiChng[i]<0) {
			
			continue;
		}
		onError = pTab->aCol[i].notNull;
		if (onError == OE_None) continue;  
		if (overrideError != OE_Default) {
			onError = overrideError;
		}
		else if (onError == OE_Default) {
			onError = OE_Abort;
		}
		if (onError == OE_Replace && pTab->aCol[i].pDflt == 0) {
			onError = OE_Abort;
		}
		assert(onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail
			|| onError == OE_Ignore || onError == OE_Replace);
		switch (onError) {
		case OE_Abort:
			sqlite3MayAbort(pParse);
			
		case OE_Rollback:
		case OE_Fail: {
			char *zMsg = sqlite3MPrintf(db, "%s.%s", pTab->zName,
				pTab->aCol[i].zName);
			sqlite3VdbeAddOp4(v, OP_HaltIfNull, SQLITE_CONSTRAINT_NOTNULL, onError,
				regNewData + 1 + i, zMsg, P4_DYNAMIC);
			sqlite3VdbeChangeP5(v, P5_ConstraintNotNull);
			VdbeCoverage(v);
			break;
		}
		case OE_Ignore: {
			sqlite3VdbeAddOp2(v, OP_IsNull, regNewData + 1 + i, ignoreDest);
			VdbeCoverage(v);
			break;
		}
		default: {
			assert(onError == OE_Replace);
			addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regNewData + 1 + i);
			VdbeCoverage(v);
			sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regNewData + 1 + i);
			sqlite3VdbeJumpHere(v, addr1);
			break;
		}
		}
	}

	
#ifndef SQLITE_OMIT_CHECK
	if (pTab->pCheck && (db->flags & SQLITE_IgnoreChecks) == 0) {
		ExprList *pCheck = pTab->pCheck;
		pParse->ckBase = regNewData + 1;
		onError = overrideError != OE_Default ? overrideError : OE_Abort;
		for (i = 0; i<pCheck->nExpr; i++) {
			int allOk;
			Expr *pExpr = pCheck->a[i].pExpr;
			if (aiChng && checkConstraintUnchanged(pExpr, aiChng, pkChng)) continue;
			allOk = sqlite3VdbeMakeLabel(v);
			sqlite3ExprIfTrue(pParse, pExpr, allOk, SQLITE_JUMPIFNULL);
			if (onError == OE_Ignore) {
				sqlite3VdbeGoto(v, ignoreDest);
			}
			else {
				char *zName = pCheck->a[i].zName;
				if (zName == 0) zName = pTab->zName;
				if (onError == OE_Replace) onError = OE_Abort; 
				sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_CHECK,
					onError, zName, P4_TRANSIENT,
					P5_ConstraintCheck);
			}
			sqlite3VdbeResolveLabel(v, allOk);
		}
	}
#endif 

	
	if (pkChng && pPk == 0) {
		int addrRowidOk = sqlite3VdbeMakeLabel(v);

		
		onError = pTab->keyConf;
		if (overrideError != OE_Default) {
			onError = overrideError;
		}
		else if (onError == OE_Default) {
			onError = OE_Abort;
		}

		if (isUpdate) {
			
			sqlite3VdbeAddOp3(v, OP_Eq, regNewData, addrRowidOk, regOldData);
			sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
			VdbeCoverage(v);
		}

		
		if (onError == OE_Replace && overrideError != OE_Replace) {
			for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
				if (pIdx->onError == OE_Ignore || pIdx->onError == OE_Fail) {
					ipkTop = sqlite3VdbeAddOp0(v, OP_Goto);
					break;
				}
			}
		}

		
		sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, addrRowidOk, regNewData);
		VdbeCoverage(v);

		
		switch (onError) {
		default: {
			onError = OE_Abort;
			
		}
		case OE_Rollback:
		case OE_Abort:
		case OE_Fail: {
			sqlite3RowidConstraint(pParse, onError, pTab);
			break;
		}
		case OE_Replace: {
			
			Trigger *pTrigger = 0;
			if (db->flags&SQLITE_RecTriggers) {
				pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
			}
			if (pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0)) {
				sqlite3MultiWrite(pParse);
				sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
					regNewData, 1, 0, OE_Replace, 1, -1);
			}
			else {
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
				if (HasRowid(pTab)) {
					
					sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, OPFLAG_ISNOOP);
					sqlite3VdbeChangeP4(v, -1, (char *)pTab, P4_TABLE);
				}
#endif 
				if (pTab->pIndex) {
					sqlite3MultiWrite(pParse);
					sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0, -1);
				}
			}
			seenReplace = 1;
			break;
		}
		case OE_Ignore: {
			
			sqlite3VdbeGoto(v, ignoreDest);
			break;
		}
		}
		sqlite3VdbeResolveLabel(v, addrRowidOk);
		if (ipkTop) {
			ipkBottom = sqlite3VdbeAddOp0(v, OP_Goto);
			sqlite3VdbeJumpHere(v, ipkTop);
		}
	}

	
	for (ix = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, ix++) {
		int regIdx;          
		int regR;            
		int iThisCur;        
		int addrUniqueOk;    

		if (aRegIdx[ix] == 0) continue;  
		if (bAffinityDone == 0) {
			sqlite3TableAffinity(v, pTab, regNewData + 1);
			bAffinityDone = 1;
		}
		iThisCur = iIdxCur + ix;
		addrUniqueOk = sqlite3VdbeMakeLabel(v);

		
		if (pIdx->pPartIdxWhere) {
			sqlite3VdbeAddOp2(v, OP_Null, 0, aRegIdx[ix]);
			pParse->ckBase = regNewData + 1;
			sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,
				SQLITE_JUMPIFNULL);
			pParse->ckBase = 0;
		}

		
		regIdx = sqlite3GetTempRange(pParse, pIdx->nColumn);
		for (i = 0; i<pIdx->nColumn; i++) {
			int iField = pIdx->aiColumn[i];
			int x;
			if (iField == XN_EXPR) {
				pParse->ckBase = regNewData + 1;
				sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx + i);
				pParse->ckBase = 0;
				VdbeComment((v, "%s column %d", pIdx->zName, i));
			}
			else {
				if (iField == XN_ROWID || iField == pTab->iPKey) {
					if (regRowid == regIdx + i) continue; 
					x = regNewData;
					regRowid = pIdx->pPartIdxWhere ? -1 : regIdx + i;
				}
				else {
					x = iField + regNewData + 1;
				}
				sqlite3VdbeAddOp2(v, iField<0 ? OP_IntCopy : OP_SCopy, x, regIdx + i);
				VdbeComment((v, "%s", iField<0 ? "rowid" : pTab->aCol[iField].zName));
			}
		}
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn, aRegIdx[ix]);
		VdbeComment((v, "for %s", pIdx->zName));
		sqlite3ExprCacheAffinityChange(pParse, regIdx, pIdx->nColumn);

		
		if (isUpdate && pPk == pIdx && pkChng == 0) {
			sqlite3VdbeResolveLabel(v, addrUniqueOk);
			continue;
		}

		
		onError = pIdx->onError;
		if (onError == OE_None) {
			sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn);
			sqlite3VdbeResolveLabel(v, addrUniqueOk);
			continue;  
		}
		if (overrideError != OE_Default) {
			onError = overrideError;
		}
		else if (onError == OE_Default) {
			onError = OE_Abort;
		}

		
		sqlite3VdbeAddOp4Int(v, OP_NoConflict, iThisCur, addrUniqueOk,
			regIdx, pIdx->nKeyCol); VdbeCoverage(v);

		
		regR = (pIdx == pPk) ? regIdx : sqlite3GetTempRange(pParse, nPkField);
		if (isUpdate || onError == OE_Replace) {
			if (HasRowid(pTab)) {
				sqlite3VdbeAddOp2(v, OP_IdxRowid, iThisCur, regR);
				
				if (isUpdate) {
					sqlite3VdbeAddOp3(v, OP_Eq, regR, addrUniqueOk, regOldData);
					sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
					VdbeCoverage(v);
				}
			}
			else {
				int x;
				
				if (pIdx != pPk) {
					for (i = 0; i<pPk->nKeyCol; i++) {
						assert(pPk->aiColumn[i] >= 0);
						x = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);
						sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR + i);
						VdbeComment((v, "%s.%s", pTab->zName,
							pTab->aCol[pPk->aiColumn[i]].zName));
					}
				}
				if (isUpdate) {
					
					int addrJump = sqlite3VdbeCurrentAddr(v) + pPk->nKeyCol;
					int op = OP_Ne;
					int regCmp = (IsPrimaryKeyIndex(pIdx) ? regIdx : regR);

					for (i = 0; i<pPk->nKeyCol; i++) {
						char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);
						x = pPk->aiColumn[i];
						assert(x >= 0);
						if (i == (pPk->nKeyCol - 1)) {
							addrJump = addrUniqueOk;
							op = OP_Eq;
						}
						sqlite3VdbeAddOp4(v, op,
							regOldData + 1 + x, addrJump, regCmp + i, p4, P4_COLLSEQ
						);
						sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
						VdbeCoverageIf(v, op == OP_Eq);
						VdbeCoverageIf(v, op == OP_Ne);
					}
				}
			}
		}

		
		assert(onError == OE_Rollback || onError == OE_Abort || onError == OE_Fail
			|| onError == OE_Ignore || onError == OE_Replace);
		switch (onError) {
		case OE_Rollback:
		case OE_Abort:
		case OE_Fail: {
			sqlite3UniqueConstraint(pParse, onError, pIdx);
			break;
		}
		case OE_Ignore: {
			sqlite3VdbeGoto(v, ignoreDest);
			break;
		}
		default: {
			Trigger *pTrigger = 0;
			assert(onError == OE_Replace);
			sqlite3MultiWrite(pParse);
			if (db->flags&SQLITE_RecTriggers) {
				pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
			}
			sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
				regR, nPkField, 0, OE_Replace,
				(pIdx == pPk ? ONEPASS_SINGLE : ONEPASS_OFF), -1);
			seenReplace = 1;
			break;
		}
		}
		sqlite3VdbeResolveLabel(v, addrUniqueOk);
		sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn);
		if (regR != regIdx) sqlite3ReleaseTempRange(pParse, regR, nPkField);
	}
	if (ipkTop) {
		sqlite3VdbeGoto(v, ipkTop + 1);
		sqlite3VdbeJumpHere(v, ipkBottom);
	}

	*pbMayReplace = seenReplace;
	VdbeModuleComment((v, "END: GenCnstCks(%d)", seenReplace));
}


SQLITE_PRIVATE void sqlite3CompleteInsertion(
	Parse *pParse,      
	Table *pTab,        
	int iDataCur,       
	int iIdxCur,        
	int regNewData,     
	int *aRegIdx,       
	int isUpdate,       
	int appendBias,     
	int useSeekResult   
) {
	Vdbe *v;            
	Index *pIdx;        
	u8 pik_flags;       
	int regData;        
	int regRec;         
	int i;              
	u8 bAffinityDone = 0; 

	v = sqlite3GetVdbe(pParse);
	assert(v != 0);
	assert(pTab->pSelect == 0);  
	for (i = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, i++) {
		if (aRegIdx[i] == 0) continue;
		bAffinityDone = 1;
		if (pIdx->pPartIdxWhere) {
			sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v) + 2);
			VdbeCoverage(v);
		}
		sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdxCur + i, aRegIdx[i]);
		pik_flags = 0;
		if (useSeekResult) pik_flags = OPFLAG_USESEEKRESULT;
		if (IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab)) {
			assert(pParse->nested == 0);
			pik_flags |= OPFLAG_NCHANGE;
		}
		sqlite3VdbeChangeP5(v, pik_flags);
	}
	if (!HasRowid(pTab)) return;
	regData = regNewData + 1;
	regRec = sqlite3GetTempReg(pParse);
	sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);
	if (!bAffinityDone) sqlite3TableAffinity(v, pTab, 0);
	sqlite3ExprCacheAffinityChange(pParse, regData, pTab->nCol);
	if (pParse->nested) {
		pik_flags = 0;
	}
	else {
		pik_flags = OPFLAG_NCHANGE;
		pik_flags |= (isUpdate ? OPFLAG_ISUPDATE : OPFLAG_LASTROWID);
	}
	if (appendBias) {
		pik_flags |= OPFLAG_APPEND;
	}
	if (useSeekResult) {
		pik_flags |= OPFLAG_USESEEKRESULT;
	}
	sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, regRec, regNewData);
	if (!pParse->nested) {
		sqlite3VdbeChangeP4(v, -1, (char *)pTab, P4_TABLE);
	}
	sqlite3VdbeChangeP5(v, pik_flags);
}


SQLITE_PRIVATE int sqlite3OpenTableAndIndices(
	Parse *pParse,   
	Table *pTab,     
	int op,          
	u8 p5,           
	int iBase,       
	u8 *aToOpen,     
	int *piDataCur,  
	int *piIdxCur    
) {
	int i;
	int iDb;
	int iDataCur;
	Index *pIdx;
	Vdbe *v;

	assert(op == OP_OpenRead || op == OP_OpenWrite);
	assert(op == OP_OpenWrite || p5 == 0);
	if (IsVirtual(pTab)) {
		
		return 0;
	}
	iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
	v = sqlite3GetVdbe(pParse);
	assert(v != 0);
	if (iBase<0) iBase = pParse->nTab;
	iDataCur = iBase++;
	if (piDataCur) *piDataCur = iDataCur;
	if (HasRowid(pTab) && (aToOpen == 0 || aToOpen[0])) {
		sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
	}
	else {
		sqlite3TableLock(pParse, iDb, pTab->tnum, op == OP_OpenWrite, pTab->zName);
	}
	if (piIdxCur) *piIdxCur = iBase;
	for (i = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, i++) {
		int iIdxCur = iBase++;
		assert(pIdx->pSchema == pTab->pSchema);
		if (IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab)) {
			if (piDataCur) *piDataCur = iIdxCur;
			p5 = 0;
		}
		if (aToOpen == 0 || aToOpen[i + 1]) {
			sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
			sqlite3VdbeChangeP5(v, p5);
			VdbeComment((v, "%s", pIdx->zName));
		}
	}
	if (iBase>pParse->nTab) pParse->nTab = iBase;
	return i;
}


#ifdef SQLITE_TEST

SQLITE_API int sqlite3_xferopt_count;
#endif 


#ifndef SQLITE_OMIT_XFER_OPT

static int xferCompatibleIndex(Index *pDest, Index *pSrc) {
	int i;
	assert(pDest && pSrc);
	assert(pDest->pTable != pSrc->pTable);
	if (pDest->nKeyCol != pSrc->nKeyCol) {
		return 0;   
	}
	if (pDest->onError != pSrc->onError) {
		return 0;   
	}
	for (i = 0; i<pSrc->nKeyCol; i++) {
		if (pSrc->aiColumn[i] != pDest->aiColumn[i]) {
			return 0;   
		}
		if (pSrc->aiColumn[i] == XN_EXPR) {
			assert(pSrc->aColExpr != 0 && pDest->aColExpr != 0);
			if (sqlite3ExprCompare(pSrc->aColExpr->a[i].pExpr,
				pDest->aColExpr->a[i].pExpr, -1) != 0) {
				return 0;   
			}
		}
		if (pSrc->aSortOrder[i] != pDest->aSortOrder[i]) {
			return 0;   
		}
		if (sqlite3_stricmp(pSrc->azColl[i], pDest->azColl[i]) != 0) {
			return 0;   
		}
	}
	if (sqlite3ExprCompare(pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1)) {
		return 0;     
	}

	
	return 1;
}


static int xferOptimization(
	Parse *pParse,        
	Table *pDest,         
	Select *pSelect,      
	int onError,          
	int iDbDest           
) {
	sqlite3 *db = pParse->db;
	ExprList *pEList;                
	Table *pSrc;                     
	Index *pSrcIdx, *pDestIdx;       
	struct SrcList_item *pItem;      
	int i;                           
	int iDbSrc;                      
	int iSrc, iDest;                 
	int addr1, addr2;                
	int emptyDestTest = 0;           
	int emptySrcTest = 0;            
	Vdbe *v;                         
	int regAutoinc;                  
	int destHasUniqueIdx = 0;        
	int regData, regRowid;           

	if (pSelect == 0) {
		return 0;   
	}
	if (pParse->pWith || pSelect->pWith) {
		
		return 0;
	}
	if (sqlite3TriggerList(pParse, pDest)) {
		return 0;   
	}
#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (pDest->tabFlags & TF_Virtual) {
		return 0;   
	}
#endif
	if (onError == OE_Default) {
		if (pDest->iPKey >= 0) onError = pDest->keyConf;
		if (onError == OE_Default) onError = OE_Abort;
	}
	assert(pSelect->pSrc);   
	if (pSelect->pSrc->nSrc != 1) {
		return 0;   
	}
	if (pSelect->pSrc->a[0].pSelect) {
		return 0;   
	}
	if (pSelect->pWhere) {
		return 0;   
	}
	if (pSelect->pOrderBy) {
		return 0;   
	}
	
	if (pSelect->pGroupBy) {
		return 0;   
	}
	if (pSelect->pLimit) {
		return 0;   
	}
	assert(pSelect->pOffset == 0);  
	if (pSelect->pPrior) {
		return 0;   
	}
	if (pSelect->selFlags & SF_Distinct) {
		return 0;   
	}
	pEList = pSelect->pEList;
	assert(pEList != 0);
	if (pEList->nExpr != 1) {
		return 0;   
	}
	assert(pEList->a[0].pExpr);
	if (pEList->a[0].pExpr->op != TK_ASTERISK) {
		return 0;   
	}

	
	pItem = pSelect->pSrc->a;
	pSrc = sqlite3LocateTableItem(pParse, 0, pItem);
	if (pSrc == 0) {
		return 0;   
	}
	if (pSrc == pDest) {
		return 0;   
	}
	if (HasRowid(pDest) != HasRowid(pSrc)) {
		return 0;   
	}
#ifndef SQLITE_OMIT_VIRTUALTABLE
	if (pSrc->tabFlags & TF_Virtual) {
		return 0;   
	}
#endif
	if (pSrc->pSelect) {
		return 0;   
	}
	if (pDest->nCol != pSrc->nCol) {
		return 0;   
	}
	if (pDest->iPKey != pSrc->iPKey) {
		return 0;   
	}
	for (i = 0; i<pDest->nCol; i++) {
		Column *pDestCol = &pDest->aCol[i];
		Column *pSrcCol = &pSrc->aCol[i];
#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS
		if ((db->flags & SQLITE_Vacuum) == 0
			&& (pDestCol->colFlags | pSrcCol->colFlags) & COLFLAG_HIDDEN
			) {
			return 0;    
		}
#endif
		if (pDestCol->affinity != pSrcCol->affinity) {
			return 0;    
		}
		if (sqlite3_stricmp(pDestCol->zColl, pSrcCol->zColl) != 0) {
			return 0;    
		}
		if (pDestCol->notNull && !pSrcCol->notNull) {
			return 0;    
		}
		
		if (i>0) {
			assert(pDestCol->pDflt == 0 || pDestCol->pDflt->op == TK_SPAN);
			assert(pSrcCol->pDflt == 0 || pSrcCol->pDflt->op == TK_SPAN);
			if ((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0)
				|| (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken,
					pSrcCol->pDflt->u.zToken) != 0)
				) {
				return 0;    
			}
		}
	}
	for (pDestIdx = pDest->pIndex; pDestIdx; pDestIdx = pDestIdx->pNext) {
		if (IsUniqueIndex(pDestIdx)) {
			destHasUniqueIdx = 1;
		}
		for (pSrcIdx = pSrc->pIndex; pSrcIdx; pSrcIdx = pSrcIdx->pNext) {
			if (xferCompatibleIndex(pDestIdx, pSrcIdx)) break;
		}
		if (pSrcIdx == 0) {
			return 0;    
		}
	}
#ifndef SQLITE_OMIT_CHECK
	if (pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck, pDest->pCheck, -1)) {
		return 0;   
	}
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
	
	if ((db->flags & SQLITE_ForeignKeys) != 0 && pDest->pFKey != 0) {
		return 0;
	}
#endif
	if ((db->flags & SQLITE_CountRows) != 0) {
		return 0;  
	}

	
#ifdef SQLITE_TEST
	sqlite3_xferopt_count++;
#endif
	iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
	v = sqlite3GetVdbe(pParse);
	sqlite3CodeVerifySchema(pParse, iDbSrc);
	iSrc = pParse->nTab++;
	iDest = pParse->nTab++;
	regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
	regData = sqlite3GetTempReg(pParse);
	regRowid = sqlite3GetTempReg(pParse);
	sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);
	assert(HasRowid(pDest) || destHasUniqueIdx);
	if ((db->flags & SQLITE_Vacuum) == 0 && (
		(pDest->iPKey<0 && pDest->pIndex != 0)          
		|| destHasUniqueIdx                              
		|| (onError != OE_Abort && onError != OE_Rollback)   
		)) {
		
		addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); VdbeCoverage(v);
		emptyDestTest = sqlite3VdbeAddOp0(v, OP_Goto);
		sqlite3VdbeJumpHere(v, addr1);
	}
	if (HasRowid(pSrc)) {
		sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);
		emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
		if (pDest->iPKey >= 0) {
			addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);
			addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);
			VdbeCoverage(v);
			sqlite3RowidConstraint(pParse, onError, pDest);
			sqlite3VdbeJumpHere(v, addr2);
			autoIncStep(pParse, regAutoinc, regRowid);
		}
		else if (pDest->pIndex == 0) {
			addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);
		}
		else {
			addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);
			assert((pDest->tabFlags & TF_Autoincrement) == 0);
		}
		sqlite3VdbeAddOp2(v, OP_RowData, iSrc, regData);
		sqlite3VdbeAddOp4(v, OP_Insert, iDest, regData, regRowid,
			(char*)pDest, P4_TABLE);
		sqlite3VdbeChangeP5(v, OPFLAG_NCHANGE | OPFLAG_LASTROWID | OPFLAG_APPEND);
		sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); VdbeCoverage(v);
		sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
		sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
	}
	else {
		sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);
		sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);
	}
	for (pDestIdx = pDest->pIndex; pDestIdx; pDestIdx = pDestIdx->pNext) {
		u8 idxInsFlags = 0;
		for (pSrcIdx = pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx = pSrcIdx->pNext) {
			if (xferCompatibleIndex(pDestIdx, pSrcIdx)) break;
		}
		assert(pSrcIdx);
		sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);
		sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
		VdbeComment((v, "%s", pSrcIdx->zName));
		sqlite3VdbeAddOp3(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest);
		sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
		sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR);
		VdbeComment((v, "%s", pDestIdx->zName));
		addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
		sqlite3VdbeAddOp2(v, OP_RowKey, iSrc, regData);
		if (db->flags & SQLITE_Vacuum) {
			
			for (i = 0; i<pSrcIdx->nColumn; i++) {
				const char *zColl = pSrcIdx->azColl[i];
				assert(sqlite3_stricmp(sqlite3StrBINARY, zColl) != 0
					|| sqlite3StrBINARY == zColl);
				if (sqlite3_stricmp(sqlite3StrBINARY, zColl)) break;
			}
			if (i == pSrcIdx->nColumn) {
				idxInsFlags = OPFLAG_USESEEKRESULT;
				sqlite3VdbeAddOp3(v, OP_Last, iDest, 0, -1);
			}
		}
		if (!HasRowid(pSrc) && pDestIdx->idxType == 2) {
			idxInsFlags |= OPFLAG_NCHANGE;
		}
		sqlite3VdbeAddOp3(v, OP_IdxInsert, iDest, regData, 1);
		sqlite3VdbeChangeP5(v, idxInsFlags);
		sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1 + 1); VdbeCoverage(v);
		sqlite3VdbeJumpHere(v, addr1);
		sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
		sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
	}
	if (emptySrcTest) sqlite3VdbeJumpHere(v, emptySrcTest);
	sqlite3ReleaseTempReg(pParse, regRowid);
	sqlite3ReleaseTempReg(pParse, regData);
	if (emptyDestTest) {
		sqlite3AutoincrementEnd(pParse);
		sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0);
		sqlite3VdbeJumpHere(v, emptyDestTest);
		sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
		return 0;
	}
	else {
		return 1;
	}
}
#endif 








SQLITE_API int sqlite3_exec(
	sqlite3 *db,                
	const char *zSql,           
	sqlite3_callback xCallback, 
	void *pArg,                 
	char **pzErrMsg             
) {
	int rc = SQLITE_OK;         
	const char *zLeftover;      
	sqlite3_stmt *pStmt = 0;    
	char **azCols = 0;          
	int callbackIsInit;         

	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
	if (zSql == 0) zSql = "";

	sqlite3_mutex_enter(db->mutex);
	sqlite3Error(db, SQLITE_OK);
	while (rc == SQLITE_OK && zSql[0]) {
		int nCol;
		char **azVals = 0;

		pStmt = 0;
		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
		assert(rc == SQLITE_OK || pStmt == 0);
		if (rc != SQLITE_OK) {
			continue;
		}
		if (!pStmt) {
			
			zSql = zLeftover;
			continue;
		}

		callbackIsInit = 0;
		nCol = sqlite3_column_count(pStmt);

		while (1) {
			int i;
			rc = sqlite3_step(pStmt);

			
			if (xCallback && (SQLITE_ROW == rc ||
				(SQLITE_DONE == rc && !callbackIsInit
					&& db->flags&SQLITE_NullCallback))) {
				if (!callbackIsInit) {
					azCols = sqlite3DbMallocZero(db, 2 * nCol * sizeof(const char*) + 1);
					if (azCols == 0) {
						goto exec_out;
					}
					for (i = 0; i<nCol; i++) {
						azCols[i] = (char *)sqlite3_column_name(pStmt, i);
						
						assert(azCols[i] != 0);
					}
					callbackIsInit = 1;
				}
				if (rc == SQLITE_ROW) {
					azVals = &azCols[nCol];
					for (i = 0; i<nCol; i++) {
						azVals[i] = (char *)sqlite3_column_text(pStmt, i);
						if (!azVals[i] && sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
							sqlite3OomFault(db);
							goto exec_out;
						}
					}
				}
				if (xCallback(pArg, nCol, azVals, azCols)) {
					
					rc = SQLITE_ABORT;
					sqlite3VdbeFinalize((Vdbe *)pStmt);
					pStmt = 0;
					sqlite3Error(db, SQLITE_ABORT);
					goto exec_out;
				}
			}

			if (rc != SQLITE_ROW) {
				rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
				pStmt = 0;
				zSql = zLeftover;
				while (sqlite3Isspace(zSql[0])) zSql++;
				break;
			}
		}

		sqlite3DbFree(db, azCols);
		azCols = 0;
	}

exec_out:
	if (pStmt) sqlite3VdbeFinalize((Vdbe *)pStmt);
	sqlite3DbFree(db, azCols);

	rc = sqlite3ApiExit(db, rc);
	if (rc != SQLITE_OK && pzErrMsg) {
		int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));
		*pzErrMsg = sqlite3Malloc(nErrMsg);
		if (*pzErrMsg) {
			memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);
		}
		else {
			rc = SQLITE_NOMEM_BKPT;
			sqlite3Error(db, SQLITE_NOMEM);
		}
	}
	else if (pzErrMsg) {
		*pzErrMsg = 0;
	}

	assert((rc&db->errMask) == rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}





#ifndef SQLITE_CORE
#define SQLITE_CORE 1  
#endif



#ifndef SQLITE3EXT_H
#define SQLITE3EXT_H



struct sqlite3_api_routines {
	void * (*aggregate_context)(sqlite3_context*, int nBytes);
	int(*aggregate_count)(sqlite3_context*);
	int(*bind_blob)(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
	int(*bind_double)(sqlite3_stmt*, int, double);
	int(*bind_int)(sqlite3_stmt*, int, int);
	int(*bind_int64)(sqlite3_stmt*, int, sqlite_int64);
	int(*bind_null)(sqlite3_stmt*, int);
	int(*bind_parameter_count)(sqlite3_stmt*);
	int(*bind_parameter_index)(sqlite3_stmt*, const char*zName);
	const char * (*bind_parameter_name)(sqlite3_stmt*, int);
	int(*bind_text)(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
	int(*bind_text16)(sqlite3_stmt*, int, const void*, int, void(*)(void*));
	int(*bind_value)(sqlite3_stmt*, int, const sqlite3_value*);
	int(*busy_handler)(sqlite3*, int(*)(void*, int), void*);
	int(*busy_timeout)(sqlite3*, int ms);
	int(*changes)(sqlite3*);
	int(*close)(sqlite3*);
	int(*collation_needed)(sqlite3*, void*, void(*)(void*, sqlite3*,
		int eTextRep, const char*));
	int(*collation_needed16)(sqlite3*, void*, void(*)(void*, sqlite3*,
		int eTextRep, const void*));
	const void * (*column_blob)(sqlite3_stmt*, int iCol);
	int(*column_bytes)(sqlite3_stmt*, int iCol);
	int(*column_bytes16)(sqlite3_stmt*, int iCol);
	int(*column_count)(sqlite3_stmt*pStmt);
	const char * (*column_database_name)(sqlite3_stmt*, int);
	const void * (*column_database_name16)(sqlite3_stmt*, int);
	const char * (*column_decltype)(sqlite3_stmt*, int i);
	const void * (*column_decltype16)(sqlite3_stmt*, int);
	double(*column_double)(sqlite3_stmt*, int iCol);
	int(*column_int)(sqlite3_stmt*, int iCol);
	sqlite_int64(*column_int64)(sqlite3_stmt*, int iCol);
	const char * (*column_name)(sqlite3_stmt*, int);
	const void * (*column_name16)(sqlite3_stmt*, int);
	const char * (*column_origin_name)(sqlite3_stmt*, int);
	const void * (*column_origin_name16)(sqlite3_stmt*, int);
	const char * (*column_table_name)(sqlite3_stmt*, int);
	const void * (*column_table_name16)(sqlite3_stmt*, int);
	const unsigned char * (*column_text)(sqlite3_stmt*, int iCol);
	const void * (*column_text16)(sqlite3_stmt*, int iCol);
	int(*column_type)(sqlite3_stmt*, int iCol);
	sqlite3_value* (*column_value)(sqlite3_stmt*, int iCol);
	void * (*commit_hook)(sqlite3*, int(*)(void*), void*);
	int(*complete)(const char*sql);
	int(*complete16)(const void*sql);
	int(*create_collation)(sqlite3*, const char*, int, void*,
		int(*)(void*, int, const void*, int, const void*));
	int(*create_collation16)(sqlite3*, const void*, int, void*,
		int(*)(void*, int, const void*, int, const void*));
	int(*create_function)(sqlite3*, const char*, int, int, void*,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*));
	int(*create_function16)(sqlite3*, const void*, int, int, void*,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*));
	int(*create_module)(sqlite3*, const char*, const sqlite3_module*, void*);
	int(*data_count)(sqlite3_stmt*pStmt);
	sqlite3 * (*db_handle)(sqlite3_stmt*);
	int(*declare_vtab)(sqlite3*, const char*);
	int(*enable_shared_cache)(int);
	int(*errcode)(sqlite3*db);
	const char * (*errmsg)(sqlite3*);
	const void * (*errmsg16)(sqlite3*);
	int(*exec)(sqlite3*, const char*, sqlite3_callback, void*, char**);
	int(*expired)(sqlite3_stmt*);
	int(*finalize)(sqlite3_stmt*pStmt);
	void(*free)(void*);
	void(*free_table)(char**result);
	int(*get_autocommit)(sqlite3*);
	void * (*get_auxdata)(sqlite3_context*, int);
	int(*get_table)(sqlite3*, const char*, char***, int*, int*, char**);
	int(*global_recover)(void);
	void(*interruptx)(sqlite3*);
	sqlite_int64(*last_insert_rowid)(sqlite3*);
	const char * (*libversion)(void);
	int(*libversion_number)(void);
	void *(*malloc)(int);
	char * (*mprintf)(const char*, ...);
	int(*open)(const char*, sqlite3**);
	int(*open16)(const void*, sqlite3**);
	int(*prepare)(sqlite3*, const char*, int, sqlite3_stmt**, const char**);
	int(*prepare16)(sqlite3*, const void*, int, sqlite3_stmt**, const void**);
	void * (*profile)(sqlite3*, void(*)(void*, const char*, sqlite_uint64), void*);
	void(*progress_handler)(sqlite3*, int, int(*)(void*), void*);
	void *(*realloc)(void*, int);
	int(*reset)(sqlite3_stmt*pStmt);
	void(*result_blob)(sqlite3_context*, const void*, int, void(*)(void*));
	void(*result_double)(sqlite3_context*, double);
	void(*result_error)(sqlite3_context*, const char*, int);
	void(*result_error16)(sqlite3_context*, const void*, int);
	void(*result_int)(sqlite3_context*, int);
	void(*result_int64)(sqlite3_context*, sqlite_int64);
	void(*result_null)(sqlite3_context*);
	void(*result_text)(sqlite3_context*, const char*, int, void(*)(void*));
	void(*result_text16)(sqlite3_context*, const void*, int, void(*)(void*));
	void(*result_text16be)(sqlite3_context*, const void*, int, void(*)(void*));
	void(*result_text16le)(sqlite3_context*, const void*, int, void(*)(void*));
	void(*result_value)(sqlite3_context*, sqlite3_value*);
	void * (*rollback_hook)(sqlite3*, void(*)(void*), void*);
	int(*set_authorizer)(sqlite3*, int(*)(void*, int, const char*, const char*,
		const char*, const char*), void*);
	void(*set_auxdata)(sqlite3_context*, int, void*, void(*)(void*));
	char * (*snprintf)(int, char*, const char*, ...);
	int(*step)(sqlite3_stmt*);
	int(*table_column_metadata)(sqlite3*, const char*, const char*, const char*,
		char const**, char const**, int*, int*, int*);
	void(*thread_cleanup)(void);
	int(*total_changes)(sqlite3*);
	void * (*trace)(sqlite3*, void(*xTrace)(void*, const char*), void*);
	int(*transfer_bindings)(sqlite3_stmt*, sqlite3_stmt*);
	void * (*update_hook)(sqlite3*, void(*)(void*, int, char const*, char const*,
		sqlite_int64), void*);
	void * (*user_data)(sqlite3_context*);
	const void * (*value_blob)(sqlite3_value*);
	int(*value_bytes)(sqlite3_value*);
	int(*value_bytes16)(sqlite3_value*);
	double(*value_double)(sqlite3_value*);
	int(*value_int)(sqlite3_value*);
	sqlite_int64(*value_int64)(sqlite3_value*);
	int(*value_numeric_type)(sqlite3_value*);
	const unsigned char * (*value_text)(sqlite3_value*);
	const void * (*value_text16)(sqlite3_value*);
	const void * (*value_text16be)(sqlite3_value*);
	const void * (*value_text16le)(sqlite3_value*);
	int(*value_type)(sqlite3_value*);
	char *(*vmprintf)(const char*, va_list);
	
	int(*overload_function)(sqlite3*, const char *zFuncName, int nArg);
	
	int(*prepare_v2)(sqlite3*, const char*, int, sqlite3_stmt**, const char**);
	int(*prepare16_v2)(sqlite3*, const void*, int, sqlite3_stmt**, const void**);
	int(*clear_bindings)(sqlite3_stmt*);
	
	int(*create_module_v2)(sqlite3*, const char*, const sqlite3_module*, void*,
		void(*xDestroy)(void *));
	
	int(*bind_zeroblob)(sqlite3_stmt*, int, int);
	int(*blob_bytes)(sqlite3_blob*);
	int(*blob_close)(sqlite3_blob*);
	int(*blob_open)(sqlite3*, const char*, const char*, const char*, sqlite3_int64,
		int, sqlite3_blob**);
	int(*blob_read)(sqlite3_blob*, void*, int, int);
	int(*blob_write)(sqlite3_blob*, const void*, int, int);
	int(*create_collation_v2)(sqlite3*, const char*, int, void*,
		int(*)(void*, int, const void*, int, const void*),
		void(*)(void*));
	int(*file_control)(sqlite3*, const char*, int, void*);
	sqlite3_int64(*memory_highwater)(int);
	sqlite3_int64(*memory_used)(void);
	sqlite3_mutex *(*mutex_alloc)(int);
	void(*mutex_enter)(sqlite3_mutex*);
	void(*mutex_free)(sqlite3_mutex*);
	void(*mutex_leave)(sqlite3_mutex*);
	int(*mutex_try)(sqlite3_mutex*);
	int(*open_v2)(const char*, sqlite3**, int, const char*);
	int(*release_memory)(int);
	void(*result_error_nomem)(sqlite3_context*);
	void(*result_error_toobig)(sqlite3_context*);
	int(*sleep)(int);
	void(*soft_heap_limit)(int);
	sqlite3_vfs *(*vfs_find)(const char*);
	int(*vfs_register)(sqlite3_vfs*, int);
	int(*vfs_unregister)(sqlite3_vfs*);
	int(*xthreadsafe)(void);
	void(*result_zeroblob)(sqlite3_context*, int);
	void(*result_error_code)(sqlite3_context*, int);
	int(*test_control)(int, ...);
	void(*randomness)(int, void*);
	sqlite3 *(*context_db_handle)(sqlite3_context*);
	int(*extended_result_codes)(sqlite3*, int);
	int(*limit)(sqlite3*, int, int);
	sqlite3_stmt *(*next_stmt)(sqlite3*, sqlite3_stmt*);
	const char *(*sql)(sqlite3_stmt*);
	int(*status)(int, int*, int*, int);
	int(*backup_finish)(sqlite3_backup*);
	sqlite3_backup *(*backup_init)(sqlite3*, const char*, sqlite3*, const char*);
	int(*backup_pagecount)(sqlite3_backup*);
	int(*backup_remaining)(sqlite3_backup*);
	int(*backup_step)(sqlite3_backup*, int);
	const char *(*compileoption_get)(int);
	int(*compileoption_used)(const char*);
	int(*create_function_v2)(sqlite3*, const char*, int, int, void*,
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**),
		void(*xStep)(sqlite3_context*, int, sqlite3_value**),
		void(*xFinal)(sqlite3_context*),
		void(*xDestroy)(void*));
	int(*db_config)(sqlite3*, int, ...);
	sqlite3_mutex *(*db_mutex)(sqlite3*);
	int(*db_status)(sqlite3*, int, int*, int*, int);
	int(*extended_errcode)(sqlite3*);
	void(*log)(int, const char*, ...);
	sqlite3_int64(*soft_heap_limit64)(sqlite3_int64);
	const char *(*sourceid)(void);
	int(*stmt_status)(sqlite3_stmt*, int, int);
	int(*strnicmp)(const char*, const char*, int);
	int(*unlock_notify)(sqlite3*, void(*)(void**, int), void*);
	int(*wal_autocheckpoint)(sqlite3*, int);
	int(*wal_checkpoint)(sqlite3*, const char*);
	void *(*wal_hook)(sqlite3*, int(*)(void*, sqlite3*, const char*, int), void*);
	int(*blob_reopen)(sqlite3_blob*, sqlite3_int64);
	int(*vtab_config)(sqlite3*, int op, ...);
	int(*vtab_on_conflict)(sqlite3*);
	
	int(*close_v2)(sqlite3*);
	const char *(*db_filename)(sqlite3*, const char*);
	int(*db_readonly)(sqlite3*, const char*);
	int(*db_release_memory)(sqlite3*);
	const char *(*errstr)(int);
	int(*stmt_busy)(sqlite3_stmt*);
	int(*stmt_readonly)(sqlite3_stmt*);
	int(*stricmp)(const char*, const char*);
	int(*uri_boolean)(const char*, const char*, int);
	sqlite3_int64(*uri_int64)(const char*, const char*, sqlite3_int64);
	const char *(*uri_parameter)(const char*, const char*);
	char *(*vsnprintf)(int, char*, const char*, va_list);
	int(*wal_checkpoint_v2)(sqlite3*, const char*, int, int*, int*);
	
	int(*auto_extension)(void(*)(void));
	int(*bind_blob64)(sqlite3_stmt*, int, const void*, sqlite3_uint64,
		void(*)(void*));
	int(*bind_text64)(sqlite3_stmt*, int, const char*, sqlite3_uint64,
		void(*)(void*), unsigned char);
	int(*cancel_auto_extension)(void(*)(void));
	int(*load_extension)(sqlite3*, const char*, const char*, char**);
	void *(*malloc64)(sqlite3_uint64);
	sqlite3_uint64(*msize)(void*);
	void *(*realloc64)(void*, sqlite3_uint64);
	void(*reset_auto_extension)(void);
	void(*result_blob64)(sqlite3_context*, const void*, sqlite3_uint64,
		void(*)(void*));
	void(*result_text64)(sqlite3_context*, const char*, sqlite3_uint64,
		void(*)(void*), unsigned char);
	int(*strglob)(const char*, const char*);
	
	sqlite3_value *(*value_dup)(const sqlite3_value*);
	void(*value_free)(sqlite3_value*);
	int(*result_zeroblob64)(sqlite3_context*, sqlite3_uint64);
	int(*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);
	
	unsigned int(*value_subtype)(sqlite3_value*);
	void(*result_subtype)(sqlite3_context*, unsigned int);
	
	int(*status64)(int, sqlite3_int64*, sqlite3_int64*, int);
	int(*strlike)(const char*, const char*, unsigned int);
	int(*db_cacheflush)(sqlite3*);
	
	int(*system_errno)(sqlite3*);
	
	int(*trace_v2)(sqlite3*, unsigned, int(*)(unsigned, void*, void*, void*), void*);
	char *(*expanded_sql)(sqlite3_stmt*);
};


typedef int(*sqlite3_loadext_entry)(
	sqlite3 *db,                       
	char **pzErrMsg,                   
	const sqlite3_api_routines *pThunk 
	);


#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
#define sqlite3_aggregate_context      sqlite3_api->aggregate_context
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_aggregate_count        sqlite3_api->aggregate_count
#endif
#define sqlite3_bind_blob              sqlite3_api->bind_blob
#define sqlite3_bind_double            sqlite3_api->bind_double
#define sqlite3_bind_int               sqlite3_api->bind_int
#define sqlite3_bind_int64             sqlite3_api->bind_int64
#define sqlite3_bind_null              sqlite3_api->bind_null
#define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count
#define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index
#define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name
#define sqlite3_bind_text              sqlite3_api->bind_text
#define sqlite3_bind_text16            sqlite3_api->bind_text16
#define sqlite3_bind_value             sqlite3_api->bind_value
#define sqlite3_busy_handler           sqlite3_api->busy_handler
#define sqlite3_busy_timeout           sqlite3_api->busy_timeout
#define sqlite3_changes                sqlite3_api->changes
#define sqlite3_close                  sqlite3_api->close
#define sqlite3_collation_needed       sqlite3_api->collation_needed
#define sqlite3_collation_needed16     sqlite3_api->collation_needed16
#define sqlite3_column_blob            sqlite3_api->column_blob
#define sqlite3_column_bytes           sqlite3_api->column_bytes
#define sqlite3_column_bytes16         sqlite3_api->column_bytes16
#define sqlite3_column_count           sqlite3_api->column_count
#define sqlite3_column_database_name   sqlite3_api->column_database_name
#define sqlite3_column_database_name16 sqlite3_api->column_database_name16
#define sqlite3_column_decltype        sqlite3_api->column_decltype
#define sqlite3_column_decltype16      sqlite3_api->column_decltype16
#define sqlite3_column_double          sqlite3_api->column_double
#define sqlite3_column_int             sqlite3_api->column_int
#define sqlite3_column_int64           sqlite3_api->column_int64
#define sqlite3_column_name            sqlite3_api->column_name
#define sqlite3_column_name16          sqlite3_api->column_name16
#define sqlite3_column_origin_name     sqlite3_api->column_origin_name
#define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16
#define sqlite3_column_table_name      sqlite3_api->column_table_name
#define sqlite3_column_table_name16    sqlite3_api->column_table_name16
#define sqlite3_column_text            sqlite3_api->column_text
#define sqlite3_column_text16          sqlite3_api->column_text16
#define sqlite3_column_type            sqlite3_api->column_type
#define sqlite3_column_value           sqlite3_api->column_value
#define sqlite3_commit_hook            sqlite3_api->commit_hook
#define sqlite3_complete               sqlite3_api->complete
#define sqlite3_complete16             sqlite3_api->complete16
#define sqlite3_create_collation       sqlite3_api->create_collation
#define sqlite3_create_collation16     sqlite3_api->create_collation16
#define sqlite3_create_function        sqlite3_api->create_function
#define sqlite3_create_function16      sqlite3_api->create_function16
#define sqlite3_create_module          sqlite3_api->create_module
#define sqlite3_create_module_v2       sqlite3_api->create_module_v2
#define sqlite3_data_count             sqlite3_api->data_count
#define sqlite3_db_handle              sqlite3_api->db_handle
#define sqlite3_declare_vtab           sqlite3_api->declare_vtab
#define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache
#define sqlite3_errcode                sqlite3_api->errcode
#define sqlite3_errmsg                 sqlite3_api->errmsg
#define sqlite3_errmsg16               sqlite3_api->errmsg16
#define sqlite3_exec                   sqlite3_api->exec
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_expired                sqlite3_api->expired
#endif
#define sqlite3_finalize               sqlite3_api->finalize
#define sqlite3_free                   sqlite3_api->free
#define sqlite3_free_table             sqlite3_api->free_table
#define sqlite3_get_autocommit         sqlite3_api->get_autocommit
#define sqlite3_get_auxdata            sqlite3_api->get_auxdata
#define sqlite3_get_table              sqlite3_api->get_table
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_global_recover         sqlite3_api->global_recover
#endif
#define sqlite3_interrupt              sqlite3_api->interruptx
#define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid
#define sqlite3_libversion             sqlite3_api->libversion
#define sqlite3_libversion_number      sqlite3_api->libversion_number
#define sqlite3_malloc                 sqlite3_api->malloc
#define sqlite3_mprintf                sqlite3_api->mprintf
#define sqlite3_open                   sqlite3_api->open
#define sqlite3_open16                 sqlite3_api->open16
#define sqlite3_prepare                sqlite3_api->prepare
#define sqlite3_prepare16              sqlite3_api->prepare16
#define sqlite3_prepare_v2             sqlite3_api->prepare_v2
#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2
#define sqlite3_profile                sqlite3_api->profile
#define sqlite3_progress_handler       sqlite3_api->progress_handler
#define sqlite3_realloc                sqlite3_api->realloc
#define sqlite3_reset                  sqlite3_api->reset
#define sqlite3_result_blob            sqlite3_api->result_blob
#define sqlite3_result_double          sqlite3_api->result_double
#define sqlite3_result_error           sqlite3_api->result_error
#define sqlite3_result_error16         sqlite3_api->result_error16
#define sqlite3_result_int             sqlite3_api->result_int
#define sqlite3_result_int64           sqlite3_api->result_int64
#define sqlite3_result_null            sqlite3_api->result_null
#define sqlite3_result_text            sqlite3_api->result_text
#define sqlite3_result_text16          sqlite3_api->result_text16
#define sqlite3_result_text16be        sqlite3_api->result_text16be
#define sqlite3_result_text16le        sqlite3_api->result_text16le
#define sqlite3_result_value           sqlite3_api->result_value
#define sqlite3_rollback_hook          sqlite3_api->rollback_hook
#define sqlite3_set_authorizer         sqlite3_api->set_authorizer
#define sqlite3_set_auxdata            sqlite3_api->set_auxdata
#define sqlite3_snprintf               sqlite3_api->snprintf
#define sqlite3_step                   sqlite3_api->step
#define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata
#define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup
#define sqlite3_total_changes          sqlite3_api->total_changes
#define sqlite3_trace                  sqlite3_api->trace
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings
#endif
#define sqlite3_update_hook            sqlite3_api->update_hook
#define sqlite3_user_data              sqlite3_api->user_data
#define sqlite3_value_blob             sqlite3_api->value_blob
#define sqlite3_value_bytes            sqlite3_api->value_bytes
#define sqlite3_value_bytes16          sqlite3_api->value_bytes16
#define sqlite3_value_double           sqlite3_api->value_double
#define sqlite3_value_int              sqlite3_api->value_int
#define sqlite3_value_int64            sqlite3_api->value_int64
#define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type
#define sqlite3_value_text             sqlite3_api->value_text
#define sqlite3_value_text16           sqlite3_api->value_text16
#define sqlite3_value_text16be         sqlite3_api->value_text16be
#define sqlite3_value_text16le         sqlite3_api->value_text16le
#define sqlite3_value_type             sqlite3_api->value_type
#define sqlite3_vmprintf               sqlite3_api->vmprintf
#define sqlite3_vsnprintf              sqlite3_api->vsnprintf
#define sqlite3_overload_function      sqlite3_api->overload_function
#define sqlite3_prepare_v2             sqlite3_api->prepare_v2
#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2
#define sqlite3_clear_bindings         sqlite3_api->clear_bindings
#define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob
#define sqlite3_blob_bytes             sqlite3_api->blob_bytes
#define sqlite3_blob_close             sqlite3_api->blob_close
#define sqlite3_blob_open              sqlite3_api->blob_open
#define sqlite3_blob_read              sqlite3_api->blob_read
#define sqlite3_blob_write             sqlite3_api->blob_write
#define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2
#define sqlite3_file_control           sqlite3_api->file_control
#define sqlite3_memory_highwater       sqlite3_api->memory_highwater
#define sqlite3_memory_used            sqlite3_api->memory_used
#define sqlite3_mutex_alloc            sqlite3_api->mutex_alloc
#define sqlite3_mutex_enter            sqlite3_api->mutex_enter
#define sqlite3_mutex_free             sqlite3_api->mutex_free
#define sqlite3_mutex_leave            sqlite3_api->mutex_leave
#define sqlite3_mutex_try              sqlite3_api->mutex_try
#define sqlite3_open_v2                sqlite3_api->open_v2
#define sqlite3_release_memory         sqlite3_api->release_memory
#define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem
#define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig
#define sqlite3_sleep                  sqlite3_api->sleep
#define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit
#define sqlite3_vfs_find               sqlite3_api->vfs_find
#define sqlite3_vfs_register           sqlite3_api->vfs_register
#define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister
#define sqlite3_threadsafe             sqlite3_api->xthreadsafe
#define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob
#define sqlite3_result_error_code      sqlite3_api->result_error_code
#define sqlite3_test_control           sqlite3_api->test_control
#define sqlite3_randomness             sqlite3_api->randomness
#define sqlite3_context_db_handle      sqlite3_api->context_db_handle
#define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes
#define sqlite3_limit                  sqlite3_api->limit
#define sqlite3_next_stmt              sqlite3_api->next_stmt
#define sqlite3_sql                    sqlite3_api->sql
#define sqlite3_status                 sqlite3_api->status
#define sqlite3_backup_finish          sqlite3_api->backup_finish
#define sqlite3_backup_init            sqlite3_api->backup_init
#define sqlite3_backup_pagecount       sqlite3_api->backup_pagecount
#define sqlite3_backup_remaining       sqlite3_api->backup_remaining
#define sqlite3_backup_step            sqlite3_api->backup_step
#define sqlite3_compileoption_get      sqlite3_api->compileoption_get
#define sqlite3_compileoption_used     sqlite3_api->compileoption_used
#define sqlite3_create_function_v2     sqlite3_api->create_function_v2
#define sqlite3_db_config              sqlite3_api->db_config
#define sqlite3_db_mutex               sqlite3_api->db_mutex
#define sqlite3_db_status              sqlite3_api->db_status
#define sqlite3_extended_errcode       sqlite3_api->extended_errcode
#define sqlite3_log                    sqlite3_api->log
#define sqlite3_soft_heap_limit64      sqlite3_api->soft_heap_limit64
#define sqlite3_sourceid               sqlite3_api->sourceid
#define sqlite3_stmt_status            sqlite3_api->stmt_status
#define sqlite3_strnicmp               sqlite3_api->strnicmp
#define sqlite3_unlock_notify          sqlite3_api->unlock_notify
#define sqlite3_wal_autocheckpoint     sqlite3_api->wal_autocheckpoint
#define sqlite3_wal_checkpoint         sqlite3_api->wal_checkpoint
#define sqlite3_wal_hook               sqlite3_api->wal_hook
#define sqlite3_blob_reopen            sqlite3_api->blob_reopen
#define sqlite3_vtab_config            sqlite3_api->vtab_config
#define sqlite3_vtab_on_conflict       sqlite3_api->vtab_on_conflict

#define sqlite3_close_v2               sqlite3_api->close_v2
#define sqlite3_db_filename            sqlite3_api->db_filename
#define sqlite3_db_readonly            sqlite3_api->db_readonly
#define sqlite3_db_release_memory      sqlite3_api->db_release_memory
#define sqlite3_errstr                 sqlite3_api->errstr
#define sqlite3_stmt_busy              sqlite3_api->stmt_busy
#define sqlite3_stmt_readonly          sqlite3_api->stmt_readonly
#define sqlite3_stricmp                sqlite3_api->stricmp
#define sqlite3_uri_boolean            sqlite3_api->uri_boolean
#define sqlite3_uri_int64              sqlite3_api->uri_int64
#define sqlite3_uri_parameter          sqlite3_api->uri_parameter
#define sqlite3_uri_vsnprintf          sqlite3_api->vsnprintf
#define sqlite3_wal_checkpoint_v2      sqlite3_api->wal_checkpoint_v2

#define sqlite3_auto_extension         sqlite3_api->auto_extension
#define sqlite3_bind_blob64            sqlite3_api->bind_blob64
#define sqlite3_bind_text64            sqlite3_api->bind_text64
#define sqlite3_cancel_auto_extension  sqlite3_api->cancel_auto_extension
#define sqlite3_load_extension         sqlite3_api->load_extension
#define sqlite3_malloc64               sqlite3_api->malloc64
#define sqlite3_msize                  sqlite3_api->msize
#define sqlite3_realloc64              sqlite3_api->realloc64
#define sqlite3_reset_auto_extension   sqlite3_api->reset_auto_extension
#define sqlite3_result_blob64          sqlite3_api->result_blob64
#define sqlite3_result_text64          sqlite3_api->result_text64
#define sqlite3_strglob                sqlite3_api->strglob

#define sqlite3_value_dup              sqlite3_api->value_dup
#define sqlite3_value_free             sqlite3_api->value_free
#define sqlite3_result_zeroblob64      sqlite3_api->result_zeroblob64
#define sqlite3_bind_zeroblob64        sqlite3_api->bind_zeroblob64

#define sqlite3_value_subtype          sqlite3_api->value_subtype
#define sqlite3_result_subtype         sqlite3_api->result_subtype

#define sqlite3_status64               sqlite3_api->status64
#define sqlite3_strlike                sqlite3_api->strlike
#define sqlite3_db_cacheflush          sqlite3_api->db_cacheflush

#define sqlite3_system_errno           sqlite3_api->system_errno

#define sqlite3_trace_v2               sqlite3_api->trace_v2
#define sqlite3_expanded_sql           sqlite3_api->expanded_sql
#endif 

#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)

# define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api=0;
# define SQLITE_EXTENSION_INIT2(v)  sqlite3_api=v;
# define SQLITE_EXTENSION_INIT3     \
    extern const sqlite3_api_routines *sqlite3_api;
#else

# define SQLITE_EXTENSION_INIT1     
# define SQLITE_EXTENSION_INIT2(v)  (void)v; 
# define SQLITE_EXTENSION_INIT3     
#endif

#endif 






#ifndef SQLITE_OMIT_LOAD_EXTENSION

#ifndef SQLITE_ENABLE_COLUMN_METADATA
# define sqlite3_column_database_name   0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name      0
# define sqlite3_column_table_name16    0
# define sqlite3_column_origin_name     0
# define sqlite3_column_origin_name16   0
#endif

#ifdef SQLITE_OMIT_AUTHORIZATION
# define sqlite3_set_authorizer         0
#endif

#ifdef SQLITE_OMIT_UTF16
# define sqlite3_bind_text16            0
# define sqlite3_collation_needed16     0
# define sqlite3_column_decltype16      0
# define sqlite3_column_name16          0
# define sqlite3_column_text16          0
# define sqlite3_complete16             0
# define sqlite3_create_collation16     0
# define sqlite3_create_function16      0
# define sqlite3_errmsg16               0
# define sqlite3_open16                 0
# define sqlite3_prepare16              0
# define sqlite3_prepare16_v2           0
# define sqlite3_result_error16         0
# define sqlite3_result_text16          0
# define sqlite3_result_text16be        0
# define sqlite3_result_text16le        0
# define sqlite3_value_text16           0
# define sqlite3_value_text16be         0
# define sqlite3_value_text16le         0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name16    0
# define sqlite3_column_origin_name16   0
#endif

#ifdef SQLITE_OMIT_COMPLETE
# define sqlite3_complete 0
# define sqlite3_complete16 0
#endif

#ifdef SQLITE_OMIT_DECLTYPE
# define sqlite3_column_decltype16      0
# define sqlite3_column_decltype        0
#endif

#ifdef SQLITE_OMIT_PROGRESS_CALLBACK
# define sqlite3_progress_handler 0
#endif

#ifdef SQLITE_OMIT_VIRTUALTABLE
# define sqlite3_create_module 0
# define sqlite3_create_module_v2 0
# define sqlite3_declare_vtab 0
# define sqlite3_vtab_config 0
# define sqlite3_vtab_on_conflict 0
#endif

#ifdef SQLITE_OMIT_SHARED_CACHE
# define sqlite3_enable_shared_cache 0
#endif

#if defined(SQLITE_OMIT_TRACE) || defined(SQLITE_OMIT_DEPRECATED)
# define sqlite3_profile       0
# define sqlite3_trace         0
#endif

#ifdef SQLITE_OMIT_GET_TABLE
# define sqlite3_free_table    0
# define sqlite3_get_table     0
#endif

#ifdef SQLITE_OMIT_INCRBLOB
#define sqlite3_bind_zeroblob  0
#define sqlite3_blob_bytes     0
#define sqlite3_blob_close     0
#define sqlite3_blob_open      0
#define sqlite3_blob_read      0
#define sqlite3_blob_write     0
#define sqlite3_blob_reopen    0
#endif

#if defined(SQLITE_OMIT_TRACE)
# define sqlite3_trace_v2      0
#endif


static const sqlite3_api_routines sqlite3Apis = {
	sqlite3_aggregate_context,
#ifndef SQLITE_OMIT_DEPRECATED
	sqlite3_aggregate_count,
#else
	0,
#endif
	sqlite3_bind_blob,
	sqlite3_bind_double,
	sqlite3_bind_int,
	sqlite3_bind_int64,
	sqlite3_bind_null,
	sqlite3_bind_parameter_count,
	sqlite3_bind_parameter_index,
	sqlite3_bind_parameter_name,
	sqlite3_bind_text,
	sqlite3_bind_text16,
	sqlite3_bind_value,
	sqlite3_busy_handler,
	sqlite3_busy_timeout,
	sqlite3_changes,
	sqlite3_close,
	sqlite3_collation_needed,
	sqlite3_collation_needed16,
	sqlite3_column_blob,
	sqlite3_column_bytes,
	sqlite3_column_bytes16,
	sqlite3_column_count,
	sqlite3_column_database_name,
	sqlite3_column_database_name16,
	sqlite3_column_decltype,
	sqlite3_column_decltype16,
	sqlite3_column_double,
	sqlite3_column_int,
	sqlite3_column_int64,
	sqlite3_column_name,
	sqlite3_column_name16,
	sqlite3_column_origin_name,
	sqlite3_column_origin_name16,
	sqlite3_column_table_name,
	sqlite3_column_table_name16,
	sqlite3_column_text,
	sqlite3_column_text16,
	sqlite3_column_type,
	sqlite3_column_value,
	sqlite3_commit_hook,
	sqlite3_complete,
	sqlite3_complete16,
	sqlite3_create_collation,
	sqlite3_create_collation16,
	sqlite3_create_function,
	sqlite3_create_function16,
	sqlite3_create_module,
	sqlite3_data_count,
	sqlite3_db_handle,
	sqlite3_declare_vtab,
	sqlite3_enable_shared_cache,
	sqlite3_errcode,
	sqlite3_errmsg,
	sqlite3_errmsg16,
	sqlite3_exec,
#ifndef SQLITE_OMIT_DEPRECATED
	sqlite3_expired,
#else
	0,
#endif
	sqlite3_finalize,
	sqlite3_free,
	sqlite3_free_table,
	sqlite3_get_autocommit,
	sqlite3_get_auxdata,
	sqlite3_get_table,
	0,     
	sqlite3_interrupt,
	sqlite3_last_insert_rowid,
	sqlite3_libversion,
	sqlite3_libversion_number,
	sqlite3_malloc,
	sqlite3_mprintf,
	sqlite3_open,
	sqlite3_open16,
	sqlite3_prepare,
	sqlite3_prepare16,
	sqlite3_profile,
	sqlite3_progress_handler,
	sqlite3_realloc,
	sqlite3_reset,
	sqlite3_result_blob,
	sqlite3_result_double,
	sqlite3_result_error,
	sqlite3_result_error16,
	sqlite3_result_int,
	sqlite3_result_int64,
	sqlite3_result_null,
	sqlite3_result_text,
	sqlite3_result_text16,
	sqlite3_result_text16be,
	sqlite3_result_text16le,
	sqlite3_result_value,
	sqlite3_rollback_hook,
	sqlite3_set_authorizer,
	sqlite3_set_auxdata,
	sqlite3_snprintf,
	sqlite3_step,
	sqlite3_table_column_metadata,
#ifndef SQLITE_OMIT_DEPRECATED
	sqlite3_thread_cleanup,
#else
	0,
#endif
	sqlite3_total_changes,
	sqlite3_trace,
#ifndef SQLITE_OMIT_DEPRECATED
	sqlite3_transfer_bindings,
#else
	0,
#endif
	sqlite3_update_hook,
	sqlite3_user_data,
	sqlite3_value_blob,
	sqlite3_value_bytes,
	sqlite3_value_bytes16,
	sqlite3_value_double,
	sqlite3_value_int,
	sqlite3_value_int64,
	sqlite3_value_numeric_type,
	sqlite3_value_text,
	sqlite3_value_text16,
	sqlite3_value_text16be,
	sqlite3_value_text16le,
	sqlite3_value_type,
	sqlite3_vmprintf,
	
	sqlite3_overload_function,

	
	sqlite3_prepare_v2,
	sqlite3_prepare16_v2,
	sqlite3_clear_bindings,

	
	sqlite3_create_module_v2,

	
	sqlite3_bind_zeroblob,
	sqlite3_blob_bytes,
	sqlite3_blob_close,
	sqlite3_blob_open,
	sqlite3_blob_read,
	sqlite3_blob_write,
	sqlite3_create_collation_v2,
	sqlite3_file_control,
	sqlite3_memory_highwater,
	sqlite3_memory_used,
#ifdef SQLITE_MUTEX_OMIT
	0,
	0,
	0,
	0,
	0,
#else
	sqlite3_mutex_alloc,
	sqlite3_mutex_enter,
	sqlite3_mutex_free,
	sqlite3_mutex_leave,
	sqlite3_mutex_try,
#endif
	sqlite3_open_v2,
	sqlite3_release_memory,
	sqlite3_result_error_nomem,
	sqlite3_result_error_toobig,
	sqlite3_sleep,
	sqlite3_soft_heap_limit,
	sqlite3_vfs_find,
	sqlite3_vfs_register,
	sqlite3_vfs_unregister,

	
	sqlite3_threadsafe,
	sqlite3_result_zeroblob,
	sqlite3_result_error_code,
	sqlite3_test_control,
	sqlite3_randomness,
	sqlite3_context_db_handle,

	
	sqlite3_extended_result_codes,
	sqlite3_limit,
	sqlite3_next_stmt,
	sqlite3_sql,
	sqlite3_status,

	
	sqlite3_backup_finish,
	sqlite3_backup_init,
	sqlite3_backup_pagecount,
	sqlite3_backup_remaining,
	sqlite3_backup_step,
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
	sqlite3_compileoption_get,
	sqlite3_compileoption_used,
#else
	0,
	0,
#endif
	sqlite3_create_function_v2,
	sqlite3_db_config,
	sqlite3_db_mutex,
	sqlite3_db_status,
	sqlite3_extended_errcode,
	sqlite3_log,
	sqlite3_soft_heap_limit64,
	sqlite3_sourceid,
	sqlite3_stmt_status,
	sqlite3_strnicmp,
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
	sqlite3_unlock_notify,
#else
	0,
#endif
#ifndef SQLITE_OMIT_WAL
	sqlite3_wal_autocheckpoint,
	sqlite3_wal_checkpoint,
	sqlite3_wal_hook,
#else
	0,
	0,
	0,
#endif
	sqlite3_blob_reopen,
	sqlite3_vtab_config,
	sqlite3_vtab_on_conflict,
	sqlite3_close_v2,
	sqlite3_db_filename,
	sqlite3_db_readonly,
	sqlite3_db_release_memory,
	sqlite3_errstr,
	sqlite3_stmt_busy,
	sqlite3_stmt_readonly,
	sqlite3_stricmp,
	sqlite3_uri_boolean,
	sqlite3_uri_int64,
	sqlite3_uri_parameter,
	sqlite3_vsnprintf,
	sqlite3_wal_checkpoint_v2,
	
	sqlite3_auto_extension,
	sqlite3_bind_blob64,
	sqlite3_bind_text64,
	sqlite3_cancel_auto_extension,
	sqlite3_load_extension,
	sqlite3_malloc64,
	sqlite3_msize,
	sqlite3_realloc64,
	sqlite3_reset_auto_extension,
	sqlite3_result_blob64,
	sqlite3_result_text64,
	sqlite3_strglob,
	
	(sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,
	sqlite3_value_free,
	sqlite3_result_zeroblob64,
	sqlite3_bind_zeroblob64,
	
	sqlite3_value_subtype,
	sqlite3_result_subtype,
	
	sqlite3_status64,
	sqlite3_strlike,
	sqlite3_db_cacheflush,
	
	sqlite3_system_errno,
	
	sqlite3_trace_v2,
	sqlite3_expanded_sql
};


static int sqlite3LoadExtension(
	sqlite3 *db,          
	const char *zFile,    
	const char *zProc,    
	char **pzErrMsg       
) {
	sqlite3_vfs *pVfs = db->pVfs;
	void *handle;
	sqlite3_loadext_entry xInit;
	char *zErrmsg = 0;
	const char *zEntry;
	char *zAltEntry = 0;
	void **aHandle;
	u64 nMsg = 300 + sqlite3Strlen30(zFile);
	int ii;
	int rc;

	
	static const char *azEndings[] = {
#if SQLITE_OS_WIN
		"dll"
#elif defined(__APPLE__)
		"dylib"
#else
		"so"
#endif
	};


	if (pzErrMsg) *pzErrMsg = 0;

	
	if ((db->flags & SQLITE_LoadExtension) == 0) {
		if (pzErrMsg) {
			*pzErrMsg = sqlite3_mprintf("not authorized");
		}
		return SQLITE_ERROR;
	}

	zEntry = zProc ? zProc : "sqlite3_extension_init";

	handle = sqlite3OsDlOpen(pVfs, zFile);
#if SQLITE_OS_UNIX || SQLITE_OS_WIN
	for (ii = 0; ii<ArraySize(azEndings) && handle == 0; ii++) {
		char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);
		if (zAltFile == 0) return SQLITE_NOMEM_BKPT;
		handle = sqlite3OsDlOpen(pVfs, zAltFile);
		sqlite3_free(zAltFile);
	}
#endif
	if (handle == 0) {
		if (pzErrMsg) {
			*pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
			if (zErrmsg) {
				sqlite3_snprintf(nMsg, zErrmsg,
					"unable to open shared library [%s]", zFile);
				sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);
			}
		}
		return SQLITE_ERROR;
	}
	xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);

	
	if (xInit == 0 && zProc == 0) {
		int iFile, iEntry, c;
		int ncFile = sqlite3Strlen30(zFile);
		zAltEntry = sqlite3_malloc64(ncFile + 30);
		if (zAltEntry == 0) {
			sqlite3OsDlClose(pVfs, handle);
			return SQLITE_NOMEM_BKPT;
		}
		memcpy(zAltEntry, "sqlite3_", 8);
		for (iFile = ncFile - 1; iFile >= 0 && zFile[iFile] != '/'; iFile--) {}
		iFile++;
		if (sqlite3_strnicmp(zFile + iFile, "lib", 3) == 0) iFile += 3;
		for (iEntry = 8; (c = zFile[iFile]) != 0 && c != '.'; iFile++) {
			if (sqlite3Isalpha(c)) {
				zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];
			}
		}
		memcpy(zAltEntry + iEntry, "_init", 6);
		zEntry = zAltEntry;
		xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
	}
	if (xInit == 0) {
		if (pzErrMsg) {
			nMsg += sqlite3Strlen30(zEntry);
			*pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
			if (zErrmsg) {
				sqlite3_snprintf(nMsg, zErrmsg,
					"no entry point [%s] in shared library [%s]", zEntry, zFile);
				sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);
			}
		}
		sqlite3OsDlClose(pVfs, handle);
		sqlite3_free(zAltEntry);
		return SQLITE_ERROR;
	}
	sqlite3_free(zAltEntry);
	rc = xInit(db, &zErrmsg, &sqlite3Apis);
	if (rc) {
		if (rc == SQLITE_OK_LOAD_PERMANENTLY) return SQLITE_OK;
		if (pzErrMsg) {
			*pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
		}
		sqlite3_free(zErrmsg);
		sqlite3OsDlClose(pVfs, handle);
		return SQLITE_ERROR;
	}

	
	aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension + 1));
	if (aHandle == 0) {
		return SQLITE_NOMEM_BKPT;
	}
	if (db->nExtension>0) {
		memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
	}
	sqlite3DbFree(db, db->aExtension);
	db->aExtension = aHandle;

	db->aExtension[db->nExtension++] = handle;
	return SQLITE_OK;
}
SQLITE_API int sqlite3_load_extension(
	sqlite3 *db,          
	const char *zFile,    
	const char *zProc,    
	char **pzErrMsg       
) {
	int rc;
	sqlite3_mutex_enter(db->mutex);
	rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db) {
	int i;
	assert(sqlite3_mutex_held(db->mutex));
	for (i = 0; i<db->nExtension; i++) {
		sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
	}
	sqlite3DbFree(db, db->aExtension);
}


SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
	sqlite3_mutex_enter(db->mutex);
	if (onoff) {
		db->flags |= SQLITE_LoadExtension | SQLITE_LoadExtFunc;
	}
	else {
		db->flags &= ~(SQLITE_LoadExtension | SQLITE_LoadExtFunc);
	}
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}

#endif 


typedef struct sqlite3AutoExtList sqlite3AutoExtList;
static SQLITE_WSD struct sqlite3AutoExtList {
	u32 nExt;              
	void(**aExt)(void);   
} sqlite3Autoext = { 0, 0 };


#ifdef SQLITE_OMIT_WSD
# define wsdAutoextInit \
  sqlite3AutoExtList *x = &GLOBAL(sqlite3AutoExtList,sqlite3Autoext)
# define wsdAutoext x[0]
#else
# define wsdAutoextInit
# define wsdAutoext sqlite3Autoext
#endif



SQLITE_API int sqlite3_auto_extension(
	void(*xInit)(void)
) {
	int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_AUTOINIT
	rc = sqlite3_initialize();
	if (rc) {
		return rc;
	}
	else
#endif
	{
		u32 i;
#if SQLITE_THREADSAFE
		sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
		wsdAutoextInit;
		sqlite3_mutex_enter(mutex);
		for (i = 0; i<wsdAutoext.nExt; i++) {
			if (wsdAutoext.aExt[i] == xInit) break;
		}
		if (i == wsdAutoext.nExt) {
			u64 nByte = (wsdAutoext.nExt + 1) * sizeof(wsdAutoext.aExt[0]);
			void(**aNew)(void);
			aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);
			if (aNew == 0) {
				rc = SQLITE_NOMEM_BKPT;
			}
			else {
				wsdAutoext.aExt = aNew;
				wsdAutoext.aExt[wsdAutoext.nExt] = xInit;
				wsdAutoext.nExt++;
			}
		}
		sqlite3_mutex_leave(mutex);
		assert((rc & 0xff) == rc);
		return rc;
	}
}


SQLITE_API int sqlite3_cancel_auto_extension(
	void(*xInit)(void)
) {
#if SQLITE_THREADSAFE
	sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
	int i;
	int n = 0;
	wsdAutoextInit;
	sqlite3_mutex_enter(mutex);
	for (i = (int)wsdAutoext.nExt - 1; i >= 0; i--) {
		if (wsdAutoext.aExt[i] == xInit) {
			wsdAutoext.nExt--;
			wsdAutoext.aExt[i] = wsdAutoext.aExt[wsdAutoext.nExt];
			n++;
			break;
		}
	}
	sqlite3_mutex_leave(mutex);
	return n;
}


SQLITE_API void sqlite3_reset_auto_extension(void) {
#ifndef SQLITE_OMIT_AUTOINIT
	if (sqlite3_initialize() == SQLITE_OK)
#endif
	{
#if SQLITE_THREADSAFE
		sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
		wsdAutoextInit;
		sqlite3_mutex_enter(mutex);
		sqlite3_free(wsdAutoext.aExt);
		wsdAutoext.aExt = 0;
		wsdAutoext.nExt = 0;
		sqlite3_mutex_leave(mutex);
	}
}


SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db) {
	u32 i;
	int go = 1;
	int rc;
	sqlite3_loadext_entry xInit;

	wsdAutoextInit;
	if (wsdAutoext.nExt == 0) {
		
		return;
	}
	for (i = 0; go; i++) {
		char *zErrmsg;
#if SQLITE_THREADSAFE
		sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
#endif
#ifdef SQLITE_OMIT_LOAD_EXTENSION
		const sqlite3_api_routines *pThunk = 0;
#else
		const sqlite3_api_routines *pThunk = &sqlite3Apis;
#endif
		sqlite3_mutex_enter(mutex);
		if (i >= wsdAutoext.nExt) {
			xInit = 0;
			go = 0;
		}
		else {
			xInit = (sqlite3_loadext_entry)wsdAutoext.aExt[i];
		}
		sqlite3_mutex_leave(mutex);
		zErrmsg = 0;
		if (xInit && (rc = xInit(db, &zErrmsg, pThunk)) != 0) {
			sqlite3ErrorWithMsg(db, rc,
				"automatic extension loading failed: %s", zErrmsg);
			go = 0;
		}
		sqlite3_free(zErrmsg);
	}
}






#if !defined(SQLITE_ENABLE_LOCKING_STYLE)
#  if defined(__APPLE__)
#    define SQLITE_ENABLE_LOCKING_STYLE 1
#  else
#    define SQLITE_ENABLE_LOCKING_STYLE 0
#  endif
#endif





#define PragTyp_HEADER_VALUE                   0
#define PragTyp_AUTO_VACUUM                    1
#define PragTyp_FLAG                           2
#define PragTyp_BUSY_TIMEOUT                   3
#define PragTyp_CACHE_SIZE                     4
#define PragTyp_CACHE_SPILL                    5
#define PragTyp_CASE_SENSITIVE_LIKE            6
#define PragTyp_COLLATION_LIST                 7
#define PragTyp_COMPILE_OPTIONS                8
#define PragTyp_DATA_STORE_DIRECTORY           9
#define PragTyp_DATABASE_LIST                 10
#define PragTyp_DEFAULT_CACHE_SIZE            11
#define PragTyp_ENCODING                      12
#define PragTyp_FOREIGN_KEY_CHECK             13
#define PragTyp_FOREIGN_KEY_LIST              14
#define PragTyp_INCREMENTAL_VACUUM            15
#define PragTyp_INDEX_INFO                    16
#define PragTyp_INDEX_LIST                    17
#define PragTyp_INTEGRITY_CHECK               18
#define PragTyp_JOURNAL_MODE                  19
#define PragTyp_JOURNAL_SIZE_LIMIT            20
#define PragTyp_LOCK_PROXY_FILE               21
#define PragTyp_LOCKING_MODE                  22
#define PragTyp_PAGE_COUNT                    23
#define PragTyp_MMAP_SIZE                     24
#define PragTyp_PAGE_SIZE                     25
#define PragTyp_SECURE_DELETE                 26
#define PragTyp_SHRINK_MEMORY                 27
#define PragTyp_SOFT_HEAP_LIMIT               28
#define PragTyp_STATS                         29
#define PragTyp_SYNCHRONOUS                   30
#define PragTyp_TABLE_INFO                    31
#define PragTyp_TEMP_STORE                    32
#define PragTyp_TEMP_STORE_DIRECTORY          33
#define PragTyp_THREADS                       34
#define PragTyp_WAL_AUTOCHECKPOINT            35
#define PragTyp_WAL_CHECKPOINT                36
#define PragTyp_ACTIVATE_EXTENSIONS           37
#define PragTyp_HEXKEY                        38
#define PragTyp_KEY                           39
#define PragTyp_REKEY                         40
#define PragTyp_LOCK_STATUS                   41
#define PragTyp_PARSER_TRACE                  42
#define PragFlag_NeedSchema           0x01
#define PragFlag_ReadOnly             0x02
static const struct sPragmaNames {
	const char *const zName;  
	u8 ePragTyp;              
	u8 mPragFlag;             
	u32 iArg;                 
} aPragmaNames[] = {
#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)
	{  "activate_extensions",
	 PragTyp_ACTIVATE_EXTENSIONS,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
	{  "application_id",
	 PragTyp_HEADER_VALUE,
	 0,
	 BTREE_APPLICATION_ID },
#endif
#if !defined(SQLITE_OMIT_AUTOVACUUM)
	{  "auto_vacuum",
	 PragTyp_AUTO_VACUUM,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_AUTOMATIC_INDEX)
	{  "automatic_index",
	 PragTyp_FLAG,
	 0,
	 SQLITE_AutoIndex },
#endif
#endif
	{  "busy_timeout",
	 PragTyp_BUSY_TIMEOUT,
	 0,
	 0 },
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "cache_size",
	 PragTyp_CACHE_SIZE,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "cache_spill",
	 PragTyp_CACHE_SPILL,
	 0,
	 0 },
#endif
	{  "case_sensitive_like",
	 PragTyp_CASE_SENSITIVE_LIKE,
	 0,
	 0 },
	{  "cell_size_check",
	 PragTyp_FLAG,
	 0,
	 SQLITE_CellSizeCk },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "checkpoint_fullfsync",
	 PragTyp_FLAG,
	 0,
	 SQLITE_CkptFullFSync },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
	{  "collation_list",
	 PragTyp_COLLATION_LIST,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_COMPILEOPTION_DIAGS)
	{  "compile_options",
	 PragTyp_COMPILE_OPTIONS,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "count_changes",
	 PragTyp_FLAG,
	 0,
	 SQLITE_CountRows },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && SQLITE_OS_WIN
	{  "data_store_directory",
	 PragTyp_DATA_STORE_DIRECTORY,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
	{  "data_version",
	 PragTyp_HEADER_VALUE,
	 PragFlag_ReadOnly,
	 BTREE_DATA_VERSION },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
	{  "database_list",
	 PragTyp_DATABASE_LIST,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
	{  "default_cache_size",
	 PragTyp_DEFAULT_CACHE_SIZE,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
	{  "defer_foreign_keys",
	 PragTyp_FLAG,
	 0,
	 SQLITE_DeferFKs },
#endif
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "empty_result_callbacks",
	 PragTyp_FLAG,
	 0,
	 SQLITE_NullCallback },
#endif
#if !defined(SQLITE_OMIT_UTF16)
	{  "encoding",
	 PragTyp_ENCODING,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
	{  "foreign_key_check",
	 PragTyp_FOREIGN_KEY_CHECK,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FOREIGN_KEY)
	{  "foreign_key_list",
	 PragTyp_FOREIGN_KEY_LIST,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
	{  "foreign_keys",
	 PragTyp_FLAG,
	 0,
	 SQLITE_ForeignKeys },
#endif
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
	{  "freelist_count",
	 PragTyp_HEADER_VALUE,
	 PragFlag_ReadOnly,
	 BTREE_FREE_PAGE_COUNT },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "full_column_names",
	 PragTyp_FLAG,
	 0,
	 SQLITE_FullColNames },
	{  "fullfsync",
	 PragTyp_FLAG,
	 0,
	 SQLITE_FullFSync },
#endif
#if defined(SQLITE_HAS_CODEC)
	{  "hexkey",
	 PragTyp_HEXKEY,
	 0,
	 0 },
	{  "hexrekey",
	 PragTyp_HEXKEY,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_CHECK)
	{  "ignore_check_constraints",
	 PragTyp_FLAG,
	 0,
	 SQLITE_IgnoreChecks },
#endif
#endif
#if !defined(SQLITE_OMIT_AUTOVACUUM)
	{  "incremental_vacuum",
	 PragTyp_INCREMENTAL_VACUUM,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
	{  "index_info",
	 PragTyp_INDEX_INFO,
	 PragFlag_NeedSchema,
	 0 },
	{  "index_list",
	 PragTyp_INDEX_LIST,
	 PragFlag_NeedSchema,
	 0 },
	{  "index_xinfo",
	 PragTyp_INDEX_INFO,
	 PragFlag_NeedSchema,
	 1 },
#endif
#if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
	{  "integrity_check",
	 PragTyp_INTEGRITY_CHECK,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "journal_mode",
	 PragTyp_JOURNAL_MODE,
	 PragFlag_NeedSchema,
	 0 },
	{  "journal_size_limit",
	 PragTyp_JOURNAL_SIZE_LIMIT,
	 0,
	 0 },
#endif
#if defined(SQLITE_HAS_CODEC)
	{  "key",
	 PragTyp_KEY,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "legacy_file_format",
	 PragTyp_FLAG,
	 0,
	 SQLITE_LegacyFileFmt },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && SQLITE_ENABLE_LOCKING_STYLE
	{  "lock_proxy_file",
	 PragTyp_LOCK_PROXY_FILE,
	 0,
	 0 },
#endif
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
	{  "lock_status",
	 PragTyp_LOCK_STATUS,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "locking_mode",
	 PragTyp_LOCKING_MODE,
	 0,
	 0 },
	{  "max_page_count",
	 PragTyp_PAGE_COUNT,
	 PragFlag_NeedSchema,
	 0 },
	{  "mmap_size",
	 PragTyp_MMAP_SIZE,
	 0,
	 0 },
	{  "page_count",
	 PragTyp_PAGE_COUNT,
	 PragFlag_NeedSchema,
	 0 },
	{  "page_size",
	 PragTyp_PAGE_SIZE,
	 0,
	 0 },
#endif
#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_PARSER_TRACE)
	{  "parser_trace",
	 PragTyp_PARSER_TRACE,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "query_only",
	 PragTyp_FLAG,
	 0,
	 SQLITE_QueryOnly },
#endif
#if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
	{  "quick_check",
	 PragTyp_INTEGRITY_CHECK,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "read_uncommitted",
	 PragTyp_FLAG,
	 0,
	 SQLITE_ReadUncommitted },
	{  "recursive_triggers",
	 PragTyp_FLAG,
	 0,
	 SQLITE_RecTriggers },
#endif
#if defined(SQLITE_HAS_CODEC)
	{  "rekey",
	 PragTyp_REKEY,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "reverse_unordered_selects",
	 PragTyp_FLAG,
	 0,
	 SQLITE_ReverseOrder },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
	{  "schema_version",
	 PragTyp_HEADER_VALUE,
	 0,
	 BTREE_SCHEMA_VERSION },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "secure_delete",
	 PragTyp_SECURE_DELETE,
	 0,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "short_column_names",
	 PragTyp_FLAG,
	 0,
	 SQLITE_ShortColNames },
#endif
	{  "shrink_memory",
	 PragTyp_SHRINK_MEMORY,
	 0,
	 0 },
	{  "soft_heap_limit",
	 PragTyp_SOFT_HEAP_LIMIT,
	 0,
	 0 },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if defined(SQLITE_DEBUG)
	{  "sql_trace",
	 PragTyp_FLAG,
	 0,
	 SQLITE_SqlTrace },
#endif
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
	{  "stats",
	 PragTyp_STATS,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "synchronous",
	 PragTyp_SYNCHRONOUS,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
	{  "table_info",
	 PragTyp_TABLE_INFO,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
	{  "temp_store",
	 PragTyp_TEMP_STORE,
	 0,
	 0 },
	{  "temp_store_directory",
	 PragTyp_TEMP_STORE_DIRECTORY,
	 0,
	 0 },
#endif
	{  "threads",
	 PragTyp_THREADS,
	 0,
	 0 },
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
	{  "user_version",
	 PragTyp_HEADER_VALUE,
	 0,
	 BTREE_USER_VERSION },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if defined(SQLITE_DEBUG)
	{  "vdbe_addoptrace",
	 PragTyp_FLAG,
	 0,
	 SQLITE_VdbeAddopTrace },
	{  "vdbe_debug",
	 PragTyp_FLAG,
	 0,
	 SQLITE_SqlTrace | SQLITE_VdbeListing | SQLITE_VdbeTrace },
	{  "vdbe_eqp",
	 PragTyp_FLAG,
	 0,
	 SQLITE_VdbeEQP },
	{  "vdbe_listing",
	 PragTyp_FLAG,
	 0,
	 SQLITE_VdbeListing },
	{  "vdbe_trace",
	 PragTyp_FLAG,
	 0,
	 SQLITE_VdbeTrace },
#endif
#endif
#if !defined(SQLITE_OMIT_WAL)
	{  "wal_autocheckpoint",
	 PragTyp_WAL_AUTOCHECKPOINT,
	 0,
	 0 },
	{  "wal_checkpoint",
	 PragTyp_WAL_CHECKPOINT,
	 PragFlag_NeedSchema,
	 0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
	{  "writable_schema",
	 PragTyp_FLAG,
	 0,
	 SQLITE_WriteSchema | SQLITE_RecoveryMode },
#endif
};






static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt) {
	
	static const char zText[] = "onoffalseyestruextrafull";
	static const u8 iOffset[] = { 0, 1, 2,  4,    9,  12,  15,   20 };
	static const u8 iLength[] = { 2, 2, 3,  5,    3,   4,   5,    4 };
	static const u8 iValue[] = { 1, 0, 0,  0,    1,   1,   3,    2 };
	
	int i, n;
	if (sqlite3Isdigit(*z)) {
		return (u8)sqlite3Atoi(z);
	}
	n = sqlite3Strlen30(z);
	for (i = 0; i<ArraySize(iLength); i++) {
		if (iLength[i] == n && sqlite3StrNICmp(&zText[iOffset[i]], z, n) == 0
			&& (!omitFull || iValue[i] <= 1)
			) {
			return iValue[i];
		}
	}
	return dflt;
}


SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z, u8 dflt) {
	return getSafetyLevel(z, 1, dflt) != 0;
}


#if !defined(SQLITE_OMIT_PRAGMA)


static int getLockingMode(const char *z) {
	if (z) {
		if (0 == sqlite3StrICmp(z, "exclusive")) return PAGER_LOCKINGMODE_EXCLUSIVE;
		if (0 == sqlite3StrICmp(z, "normal")) return PAGER_LOCKINGMODE_NORMAL;
	}
	return PAGER_LOCKINGMODE_QUERY;
}

#ifndef SQLITE_OMIT_AUTOVACUUM

static int getAutoVacuum(const char *z) {
	int i;
	if (0 == sqlite3StrICmp(z, "none")) return BTREE_AUTOVACUUM_NONE;
	if (0 == sqlite3StrICmp(z, "full")) return BTREE_AUTOVACUUM_FULL;
	if (0 == sqlite3StrICmp(z, "incremental")) return BTREE_AUTOVACUUM_INCR;
	i = sqlite3Atoi(z);
	return (u8)((i >= 0 && i <= 2) ? i : 0);
}
#endif 

#ifndef SQLITE_OMIT_PAGER_PRAGMAS

static int getTempStore(const char *z) {
	if (z[0] >= '0' && z[0] <= '2') {
		return z[0] - '0';
	}
	else if (sqlite3StrICmp(z, "file") == 0) {
		return 1;
	}
	else if (sqlite3StrICmp(z, "memory") == 0) {
		return 2;
	}
	else {
		return 0;
	}
}
#endif 

#ifndef SQLITE_OMIT_PAGER_PRAGMAS

static int invalidateTempStorage(Parse *pParse) {
	sqlite3 *db = pParse->db;
	if (db->aDb[1].pBt != 0) {
		if (!db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt)) {
			sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "
				"from within a transaction");
			return SQLITE_ERROR;
		}
		sqlite3BtreeClose(db->aDb[1].pBt);
		db->aDb[1].pBt = 0;
		sqlite3ResetAllSchemasOfConnection(db);
	}
	return SQLITE_OK;
}
#endif 

#ifndef SQLITE_OMIT_PAGER_PRAGMAS

static int changeTempStorage(Parse *pParse, const char *zStorageType) {
	int ts = getTempStore(zStorageType);
	sqlite3 *db = pParse->db;
	if (db->temp_store == ts) return SQLITE_OK;
	if (invalidateTempStorage(pParse) != SQLITE_OK) {
		return SQLITE_ERROR;
	}
	db->temp_store = (u8)ts;
	return SQLITE_OK;
}
#endif 


static void setAllColumnNames(
	Vdbe *v,               
	int N,                 
	const char **azCol     
) {
	int i;
	sqlite3VdbeSetNumCols(v, N);
	for (i = 0; i<N; i++) {
		sqlite3VdbeSetColName(v, i, COLNAME_NAME, azCol[i], SQLITE_STATIC);
	}
}
static void setOneColumnName(Vdbe *v, const char *z) {
	setAllColumnNames(v, 1, &z);
}


static void returnSingleInt(Vdbe *v, const char *zLabel, i64 value) {
	sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, 1, 0, (const u8*)&value, P4_INT64);
	setOneColumnName(v, zLabel);
	sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
}


static void returnSingleText(
	Vdbe *v,                
	const char *zLabel,     
	const char *zValue      
) {
	if (zValue) {
		sqlite3VdbeLoadString(v, 1, (const char*)zValue);
		setOneColumnName(v, zLabel);
		sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
	}
}



#ifndef SQLITE_OMIT_PAGER_PRAGMAS
static void setAllPagerFlags(sqlite3 *db) {
	if (db->autoCommit) {
		Db *pDb = db->aDb;
		int n = db->nDb;
		assert(SQLITE_FullFSync == PAGER_FULLFSYNC);
		assert(SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNC);
		assert(SQLITE_CacheSpill == PAGER_CACHESPILL);
		assert((PAGER_FULLFSYNC | PAGER_CKPT_FULLFSYNC | PAGER_CACHESPILL)
			== PAGER_FLAGS_MASK);
		assert((pDb->safety_level & PAGER_SYNCHRONOUS_MASK) == pDb->safety_level);
		while ((n--) > 0) {
			if (pDb->pBt) {
				sqlite3BtreeSetPagerFlags(pDb->pBt,
					pDb->safety_level | (db->flags & PAGER_FLAGS_MASK));
			}
			pDb++;
		}
	}
}
#else
# define setAllPagerFlags(X)  
#endif



#ifndef SQLITE_OMIT_FOREIGN_KEY
static const char *actionName(u8 action) {
	const char *zName;
	switch (action) {
	case OE_SetNull:  zName = "SET NULL";        break;
	case OE_SetDflt:  zName = "SET DEFAULT";     break;
	case OE_Cascade:  zName = "CASCADE";         break;
	case OE_Restrict: zName = "RESTRICT";        break;
	default:          zName = "NO ACTION";
		assert(action == OE_None); break;
	}
	return zName;
}
#endif



SQLITE_PRIVATE const char *sqlite3JournalModename(int eMode) {
	static char * const azModeName[] = {
		"delete", "persist", "off", "truncate", "memory"
#ifndef SQLITE_OMIT_WAL
		, "wal"
#endif
	};
	assert(PAGER_JOURNALMODE_DELETE == 0);
	assert(PAGER_JOURNALMODE_PERSIST == 1);
	assert(PAGER_JOURNALMODE_OFF == 2);
	assert(PAGER_JOURNALMODE_TRUNCATE == 3);
	assert(PAGER_JOURNALMODE_MEMORY == 4);
	assert(PAGER_JOURNALMODE_WAL == 5);
	assert(eMode >= 0 && eMode <= ArraySize(azModeName));

	if (eMode == ArraySize(azModeName)) return 0;
	return azModeName[eMode];
}


SQLITE_PRIVATE void sqlite3Pragma(
	Parse *pParse,
	Token *pId1,        
	Token *pId2,        
	Token *pValue,      
	int minusFlag       
) {
	char *zLeft = 0;       
	char *zRight = 0;      
	const char *zDb = 0;   
	Token *pId;            
	char *aFcntl[4];       
	int iDb;               
	int lwr, upr, mid = 0;       
	int rc;                      
	sqlite3 *db = pParse->db;    
	Db *pDb;                     
	Vdbe *v = sqlite3GetVdbe(pParse);  
	const struct sPragmaNames *pPragma;

	if (v == 0) return;
	sqlite3VdbeRunOnlyOnce(v);
	pParse->nMem = 2;

	
	iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
	if (iDb<0) return;
	pDb = &db->aDb[iDb];

	
	if (iDb == 1 && sqlite3OpenTempDatabase(pParse)) {
		return;
	}

	zLeft = sqlite3NameFromToken(db, pId);
	if (!zLeft) return;
	if (minusFlag) {
		zRight = sqlite3MPrintf(db, "-%T", pValue);
	}
	else {
		zRight = sqlite3NameFromToken(db, pValue);
	}

	assert(pId2);
	zDb = pId2->n>0 ? pDb->zDbSName : 0;
	if (sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb)) {
		goto pragma_out;
	}

	
	aFcntl[0] = 0;
	aFcntl[1] = zLeft;
	aFcntl[2] = zRight;
	aFcntl[3] = 0;
	db->busyHandler.nBusy = 0;
	rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);
	if (rc == SQLITE_OK) {
		returnSingleText(v, "result", aFcntl[0]);
		sqlite3_free(aFcntl[0]);
		goto pragma_out;
	}
	if (rc != SQLITE_NOTFOUND) {
		if (aFcntl[0]) {
			sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
			sqlite3_free(aFcntl[0]);
		}
		pParse->nErr++;
		pParse->rc = rc;
		goto pragma_out;
	}

	
	lwr = 0;
	upr = ArraySize(aPragmaNames) - 1;
	while (lwr <= upr) {
		mid = (lwr + upr) / 2;
		rc = sqlite3_stricmp(zLeft, aPragmaNames[mid].zName);
		if (rc == 0) break;
		if (rc<0) {
			upr = mid - 1;
		}
		else {
			lwr = mid + 1;
		}
	}
	if (lwr>upr) goto pragma_out;
	pPragma = &aPragmaNames[mid];

	
	if ((pPragma->mPragFlag & PragFlag_NeedSchema) != 0) {
		if (sqlite3ReadSchema(pParse)) goto pragma_out;
	}

	
	switch (pPragma->ePragTyp) {

#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
		
	case PragTyp_DEFAULT_CACHE_SIZE: {
		static const int iLn = VDBE_OFFSET_LINENO(2);
		static const VdbeOpList getCacheSize[] = {
			{ OP_Transaction, 0, 0,        0 },                         
			{ OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE },  
			{ OP_IfPos,       1, 8,        0 },
			{ OP_Integer,     0, 2,        0 },
			{ OP_Subtract,    1, 2,        1 },
			{ OP_IfPos,       1, 8,        0 },
			{ OP_Integer,     0, 1,        0 },                         
			{ OP_Noop,        0, 0,        0 },
			{ OP_ResultRow,   1, 1,        0 },
		};
		VdbeOp *aOp;
		sqlite3VdbeUsesBtree(v, iDb);
		if (!zRight) {
			setOneColumnName(v, "cache_size");
			pParse->nMem += 2;
			sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));
			aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);
			if (ONLY_IF_REALLOC_STRESS(aOp == 0)) break;
			aOp[0].p1 = iDb;
			aOp[1].p1 = iDb;
			aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;
		}
		else {
			int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
			sqlite3BeginWriteOperation(pParse, 0, iDb);
			sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);
			assert(sqlite3SchemaMutexHeld(db, iDb, 0));
			pDb->pSchema->cache_size = size;
			sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
		}
		break;
	}
#endif 

#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
									 
	case PragTyp_PAGE_SIZE: {
		Btree *pBt = pDb->pBt;
		assert(pBt != 0);
		if (!zRight) {
			int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
			returnSingleInt(v, "page_size", size);
		}
		else {
			
			db->nextPagesize = sqlite3Atoi(zRight);
			if (SQLITE_NOMEM == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0)) {
				sqlite3OomFault(db);
			}
		}
		break;
	}

							
	case PragTyp_SECURE_DELETE: {
		Btree *pBt = pDb->pBt;
		int b = -1;
		assert(pBt != 0);
		if (zRight) {
			b = sqlite3GetBoolean(zRight, 0);
		}
		if (pId2->n == 0 && b >= 0) {
			int ii;
			for (ii = 0; ii<db->nDb; ii++) {
				sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
			}
		}
		b = sqlite3BtreeSecureDelete(pBt, b);
		returnSingleInt(v, "secure_delete", b);
		break;
	}

								
	case PragTyp_PAGE_COUNT: {
		int iReg;
		sqlite3CodeVerifySchema(pParse, iDb);
		iReg = ++pParse->nMem;
		if (sqlite3Tolower(zLeft[0]) == 'p') {
			sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);
		}
		else {
			sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg,
				sqlite3AbsInt32(sqlite3Atoi(zRight)));
		}
		sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);
		sqlite3VdbeSetNumCols(v, 1);
		sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT);
		break;
	}

							 
	case PragTyp_LOCKING_MODE: {
		const char *zRet = "normal";
		int eMode = getLockingMode(zRight);

		if (pId2->n == 0 && eMode == PAGER_LOCKINGMODE_QUERY) {
			
			eMode = db->dfltLockMode;
		}
		else {
			Pager *pPager;
			if (pId2->n == 0) {
				
				int ii;
				assert(pDb == &db->aDb[0]);
				for (ii = 2; ii<db->nDb; ii++) {
					pPager = sqlite3BtreePager(db->aDb[ii].pBt);
					sqlite3PagerLockingMode(pPager, eMode);
				}
				db->dfltLockMode = (u8)eMode;
			}
			pPager = sqlite3BtreePager(pDb->pBt);
			eMode = sqlite3PagerLockingMode(pPager, eMode);
		}

		assert(eMode == PAGER_LOCKINGMODE_NORMAL
			|| eMode == PAGER_LOCKINGMODE_EXCLUSIVE);
		if (eMode == PAGER_LOCKINGMODE_EXCLUSIVE) {
			zRet = "exclusive";
		}
		returnSingleText(v, "locking_mode", zRet);
		break;
	}

							   
	case PragTyp_JOURNAL_MODE: {
		int eMode;        
		int ii;           

		setOneColumnName(v, "journal_mode");
		if (zRight == 0) {
			
			eMode = PAGER_JOURNALMODE_QUERY;
		}
		else {
			const char *zMode;
			int n = sqlite3Strlen30(zRight);
			for (eMode = 0; (zMode = sqlite3JournalModename(eMode)) != 0; eMode++) {
				if (sqlite3StrNICmp(zRight, zMode, n) == 0) break;
			}
			if (!zMode) {
				
				eMode = PAGER_JOURNALMODE_QUERY;
			}
		}
		if (eMode == PAGER_JOURNALMODE_QUERY && pId2->n == 0) {
			
			iDb = 0;
			pId2->n = 1;
		}
		for (ii = db->nDb - 1; ii >= 0; ii--) {
			if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {
				sqlite3VdbeUsesBtree(v, ii);
				sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);
			}
		}
		sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
		break;
	}

							   
	case PragTyp_JOURNAL_SIZE_LIMIT: {
		Pager *pPager = sqlite3BtreePager(pDb->pBt);
		i64 iLimit = -2;
		if (zRight) {
			sqlite3DecOrHexToI64(zRight, &iLimit);
			if (iLimit<-1) iLimit = -1;
		}
		iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
		returnSingleInt(v, "journal_size_limit", iLimit);
		break;
	}

#endif 

									 
#ifndef SQLITE_OMIT_AUTOVACUUM
	case PragTyp_AUTO_VACUUM: {
		Btree *pBt = pDb->pBt;
		assert(pBt != 0);
		if (!zRight) {
			returnSingleInt(v, "auto_vacuum", sqlite3BtreeGetAutoVacuum(pBt));
		}
		else {
			int eAuto = getAutoVacuum(zRight);
			assert(eAuto >= 0 && eAuto <= 2);
			db->nextAutovac = (u8)eAuto;
			
			rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);
			if (rc == SQLITE_OK && (eAuto == 1 || eAuto == 2)) {
				
				static const int iLn = VDBE_OFFSET_LINENO(2);
				static const VdbeOpList setMeta6[] = {
					{ OP_Transaction,    0,         1,                 0 },    
					{ OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE },
					{ OP_If,             1,         0,                 0 },    
					{ OP_Halt,           SQLITE_OK, OE_Abort,          0 },    
					{ OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0 },    
				};
				VdbeOp *aOp;
				int iAddr = sqlite3VdbeCurrentAddr(v);
				sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));
				aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);
				if (ONLY_IF_REALLOC_STRESS(aOp == 0)) break;
				aOp[0].p1 = iDb;
				aOp[1].p1 = iDb;
				aOp[2].p2 = iAddr + 4;
				aOp[4].p1 = iDb;
				aOp[4].p3 = eAuto - 1;
				sqlite3VdbeUsesBtree(v, iDb);
			}
		}
		break;
	}
#endif

							  
#ifndef SQLITE_OMIT_AUTOVACUUM
	case PragTyp_INCREMENTAL_VACUUM: {
		int iLimit, addr;
		if (zRight == 0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit <= 0) {
			iLimit = 0x7fffffff;
		}
		sqlite3BeginWriteOperation(pParse, 0, iDb);
		sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);
		addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);
		sqlite3VdbeAddOp1(v, OP_ResultRow, 1);
		sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);
		sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);
		sqlite3VdbeJumpHere(v, addr);
		break;
	}
#endif

#ifndef SQLITE_OMIT_PAGER_PRAGMAS
									 
	case PragTyp_CACHE_SIZE: {
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		if (!zRight) {
			returnSingleInt(v, "cache_size", pDb->pSchema->cache_size);
		}
		else {
			int size = sqlite3Atoi(zRight);
			pDb->pSchema->cache_size = size;
			sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
		}
		break;
	}

							 
	case PragTyp_CACHE_SPILL: {
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		if (!zRight) {
			returnSingleInt(v, "cache_spill",
				(db->flags & SQLITE_CacheSpill) == 0 ? 0 :
				sqlite3BtreeSetSpillSize(pDb->pBt, 0));
		}
		else {
			int size = 1;
			if (sqlite3GetInt32(zRight, &size)) {
				sqlite3BtreeSetSpillSize(pDb->pBt, size);
			}
			if (sqlite3GetBoolean(zRight, size != 0)) {
				db->flags |= SQLITE_CacheSpill;
			}
			else {
				db->flags &= ~SQLITE_CacheSpill;
			}
			setAllPagerFlags(db);
		}
		break;
	}

							  
	case PragTyp_MMAP_SIZE: {
		sqlite3_int64 sz;
#if SQLITE_MAX_MMAP_SIZE>0
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		if (zRight) {
			int ii;
			sqlite3DecOrHexToI64(zRight, &sz);
			if (sz<0) sz = sqlite3GlobalConfig.szMmap;
			if (pId2->n == 0) db->szMmap = sz;
			for (ii = db->nDb - 1; ii >= 0; ii--) {
				if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {
					sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);
				}
			}
		}
		sz = -1;
		rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);
#else
		sz = 0;
		rc = SQLITE_OK;
#endif
		if (rc == SQLITE_OK) {
			returnSingleInt(v, "mmap_size", sz);
		}
		else if (rc != SQLITE_NOTFOUND) {
			pParse->nErr++;
			pParse->rc = rc;
		}
		break;
	}

							
	case PragTyp_TEMP_STORE: {
		if (!zRight) {
			returnSingleInt(v, "temp_store", db->temp_store);
		}
		else {
			changeTempStorage(pParse, zRight);
		}
		break;
	}

							 
	case PragTyp_TEMP_STORE_DIRECTORY: {
		if (!zRight) {
			returnSingleText(v, "temp_store_directory", sqlite3_temp_directory);
		}
		else {
#ifndef SQLITE_OMIT_WSD
			if (zRight[0]) {
				int res;
				rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);
				if (rc != SQLITE_OK || res == 0) {
					sqlite3ErrorMsg(pParse, "not a writable directory");
					goto pragma_out;
				}
			}
			if (SQLITE_TEMP_STORE == 0
				|| (SQLITE_TEMP_STORE == 1 && db->temp_store <= 1)
				|| (SQLITE_TEMP_STORE == 2 && db->temp_store == 1)
				) {
				invalidateTempStorage(pParse);
			}
			sqlite3_free(sqlite3_temp_directory);
			if (zRight[0]) {
				sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
			}
			else {
				sqlite3_temp_directory = 0;
			}
#endif 
		}
		break;
	}

#if SQLITE_OS_WIN
									   
	case PragTyp_DATA_STORE_DIRECTORY: {
		if (!zRight) {
			returnSingleText(v, "data_store_directory", sqlite3_data_directory);
		}
		else {
#ifndef SQLITE_OMIT_WSD
			if (zRight[0]) {
				int res;
				rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);
				if (rc != SQLITE_OK || res == 0) {
					sqlite3ErrorMsg(pParse, "not a writable directory");
					goto pragma_out;
				}
			}
			sqlite3_free(sqlite3_data_directory);
			if (zRight[0]) {
				sqlite3_data_directory = sqlite3_mprintf("%s", zRight);
			}
			else {
				sqlite3_data_directory = 0;
			}
#endif 
		}
		break;
	}
#endif

#if SQLITE_ENABLE_LOCKING_STYLE
									   
	case PragTyp_LOCK_PROXY_FILE: {
		if (!zRight) {
			Pager *pPager = sqlite3BtreePager(pDb->pBt);
			char *proxy_file_path = NULL;
			sqlite3_file *pFile = sqlite3PagerFile(pPager);
			sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE,
				&proxy_file_path);
			returnSingleText(v, "lock_proxy_file", proxy_file_path);
		}
		else {
			Pager *pPager = sqlite3BtreePager(pDb->pBt);
			sqlite3_file *pFile = sqlite3PagerFile(pPager);
			int res;
			if (zRight[0]) {
				res = sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,
					zRight);
			}
			else {
				res = sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,
					NULL);
			}
			if (res != SQLITE_OK) {
				sqlite3ErrorMsg(pParse, "failed to set lock proxy file");
				goto pragma_out;
			}
		}
		break;
	}
#endif       

								  
	case PragTyp_SYNCHRONOUS: {
		if (!zRight) {
			returnSingleInt(v, "synchronous", pDb->safety_level - 1);
		}
		else {
			if (!db->autoCommit) {
				sqlite3ErrorMsg(pParse,
					"Safety level may not be changed inside a transaction");
			}
			else {
				int iLevel = (getSafetyLevel(zRight, 0, 1) + 1) & PAGER_SYNCHRONOUS_MASK;
				if (iLevel == 0) iLevel = 1;
				pDb->safety_level = iLevel;
				pDb->bSyncSet = 1;
				setAllPagerFlags(db);
			}
		}
		break;
	}
#endif 

#ifndef SQLITE_OMIT_FLAG_PRAGMAS
	case PragTyp_FLAG: {
		if (zRight == 0) {
			returnSingleInt(v, pPragma->zName, (db->flags & pPragma->iArg) != 0);
		}
		else {
			int mask = pPragma->iArg;    
			if (db->autoCommit == 0) {
				
				mask &= ~(SQLITE_ForeignKeys);
			}
#if SQLITE_USER_AUTHENTICATION
			if (db->auth.authLevel == UAUTH_User) {
				
				mask &= ~(SQLITE_WriteSchema);
			}
#endif

			if (sqlite3GetBoolean(zRight, 0)) {
				db->flags |= mask;
			}
			else {
				db->flags &= ~mask;
				if (mask == SQLITE_DeferFKs) db->nDeferredImmCons = 0;
			}

			
			sqlite3VdbeAddOp0(v, OP_Expire);
			setAllPagerFlags(db);
		}
		break;
	}
#endif 

#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS
					   
	case PragTyp_TABLE_INFO: if (zRight) {
		Table *pTab;
		pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);
		if (pTab) {
			static const char *azCol[] = {
				"cid", "name", "type", "notnull", "dflt_value", "pk"
			};
			int i, k;
			int nHidden = 0;
			Column *pCol;
			Index *pPk = sqlite3PrimaryKeyIndex(pTab);
			pParse->nMem = 6;
			sqlite3CodeVerifySchema(pParse, iDb);
			setAllColumnNames(v, 6, azCol); assert(6 == ArraySize(azCol));
			sqlite3ViewGetColumnNames(pParse, pTab);
			for (i = 0, pCol = pTab->aCol; i<pTab->nCol; i++, pCol++) {
				if (IsHiddenColumn(pCol)) {
					nHidden++;
					continue;
				}
				if ((pCol->colFlags & COLFLAG_PRIMKEY) == 0) {
					k = 0;
				}
				else if (pPk == 0) {
					k = 1;
				}
				else {
					for (k = 1; k <= pTab->nCol && pPk->aiColumn[k - 1] != i; k++) {}
				}
				assert(pCol->pDflt == 0 || pCol->pDflt->op == TK_SPAN);
				sqlite3VdbeMultiLoad(v, 1, "issisi",
					i - nHidden,
					pCol->zName,
					sqlite3ColumnType(pCol, ""),
					pCol->notNull ? 1 : 0,
					pCol->pDflt ? pCol->pDflt->u.zToken : 0,
					k);
				sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6);
			}
		}
	}
							 break;

	case PragTyp_STATS: {
		static const char *azCol[] = { "table", "index", "width", "height" };
		Index *pIdx;
		HashElem *i;
		v = sqlite3GetVdbe(pParse);
		pParse->nMem = 4;
		sqlite3CodeVerifySchema(pParse, iDb);
		setAllColumnNames(v, 4, azCol);  assert(4 == ArraySize(azCol));
		for (i = sqliteHashFirst(&pDb->pSchema->tblHash); i; i = sqliteHashNext(i)) {
			Table *pTab = sqliteHashData(i);
			sqlite3VdbeMultiLoad(v, 1, "ssii",
				pTab->zName,
				0,
				pTab->szTabRow,
				pTab->nRowLogEst);
			sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 4);
			for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
				sqlite3VdbeMultiLoad(v, 2, "sii",
					pIdx->zName,
					pIdx->szIdxRow,
					pIdx->aiRowLogEst[0]);
				sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 4);
			}
		}
	}
						break;

	case PragTyp_INDEX_INFO: if (zRight) {
		Index *pIdx;
		Table *pTab;
		pIdx = sqlite3FindIndex(db, zRight, zDb);
		if (pIdx) {
			static const char *azCol[] = {
				"seqno", "cid", "name", "desc", "coll", "key"
			};
			int i;
			int mx;
			if (pPragma->iArg) {
				
				mx = pIdx->nColumn;
				pParse->nMem = 6;
			}
			else {
				
				mx = pIdx->nKeyCol;
				pParse->nMem = 3;
			}
			pTab = pIdx->pTable;
			sqlite3CodeVerifySchema(pParse, iDb);
			assert(pParse->nMem <= ArraySize(azCol));
			setAllColumnNames(v, pParse->nMem, azCol);
			for (i = 0; i<mx; i++) {
				i16 cnum = pIdx->aiColumn[i];
				sqlite3VdbeMultiLoad(v, 1, "iis", i, cnum,
					cnum<0 ? 0 : pTab->aCol[cnum].zName);
				if (pPragma->iArg) {
					sqlite3VdbeMultiLoad(v, 4, "isi",
						pIdx->aSortOrder[i],
						pIdx->azColl[i],
						i<pIdx->nKeyCol);
				}
				sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);
			}
		}
	}
							 break;

	case PragTyp_INDEX_LIST: if (zRight) {
		Index *pIdx;
		Table *pTab;
		int i;
		pTab = sqlite3FindTable(db, zRight, zDb);
		if (pTab) {
			static const char *azCol[] = {
				"seq", "name", "unique", "origin", "partial"
			};
			v = sqlite3GetVdbe(pParse);
			pParse->nMem = 5;
			sqlite3CodeVerifySchema(pParse, iDb);
			setAllColumnNames(v, 5, azCol);  assert(5 == ArraySize(azCol));
			for (pIdx = pTab->pIndex, i = 0; pIdx; pIdx = pIdx->pNext, i++) {
				const char *azOrigin[] = { "c", "u", "pk" };
				sqlite3VdbeMultiLoad(v, 1, "isisi",
					i,
					pIdx->zName,
					IsUniqueIndex(pIdx),
					azOrigin[pIdx->idxType],
					pIdx->pPartIdxWhere != 0);
				sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
			}
		}
	}
							 break;

	case PragTyp_DATABASE_LIST: {
		static const char *azCol[] = { "seq", "name", "file" };
		int i;
		pParse->nMem = 3;
		setAllColumnNames(v, 3, azCol); assert(3 == ArraySize(azCol));
		for (i = 0; i<db->nDb; i++) {
			if (db->aDb[i].pBt == 0) continue;
			assert(db->aDb[i].zDbSName != 0);
			sqlite3VdbeMultiLoad(v, 1, "iss",
				i,
				db->aDb[i].zDbSName,
				sqlite3BtreeGetFilename(db->aDb[i].pBt));
			sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
		}
	}
								break;

	case PragTyp_COLLATION_LIST: {
		static const char *azCol[] = { "seq", "name" };
		int i = 0;
		HashElem *p;
		pParse->nMem = 2;
		setAllColumnNames(v, 2, azCol); assert(2 == ArraySize(azCol));
		for (p = sqliteHashFirst(&db->aCollSeq); p; p = sqliteHashNext(p)) {
			CollSeq *pColl = (CollSeq *)sqliteHashData(p);
			sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
			sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
		}
	}
								 break;
#endif 

#ifndef SQLITE_OMIT_FOREIGN_KEY
	case PragTyp_FOREIGN_KEY_LIST: if (zRight) {
		FKey *pFK;
		Table *pTab;
		pTab = sqlite3FindTable(db, zRight, zDb);
		if (pTab) {
			v = sqlite3GetVdbe(pParse);
			pFK = pTab->pFKey;
			if (pFK) {
				static const char *azCol[] = {
					"id", "seq", "table", "from", "to", "on_update", "on_delete",
					"match"
				};
				int i = 0;
				pParse->nMem = 8;
				sqlite3CodeVerifySchema(pParse, iDb);
				setAllColumnNames(v, 8, azCol); assert(8 == ArraySize(azCol));
				while (pFK) {
					int j;
					for (j = 0; j<pFK->nCol; j++) {
						sqlite3VdbeMultiLoad(v, 1, "iissssss",
							i,
							j,
							pFK->zTo,
							pTab->aCol[pFK->aCol[j].iFrom].zName,
							pFK->aCol[j].zCol,
							actionName(pFK->aAction[1]),  
							actionName(pFK->aAction[0]),  
							"NONE");
						sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 8);
					}
					++i;
					pFK = pFK->pNextFrom;
				}
			}
		}
	}
								   break;
#endif 

#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER
	case PragTyp_FOREIGN_KEY_CHECK: {
		FKey *pFK;             
		Table *pTab;           
		Table *pParent;        
		Index *pIdx;           
		int i;                 
		int j;                 
		HashElem *k;           
		int x;                 
		int regResult;         
		int regKey;            
		int regRow;            
		int addrTop;           
		int addrOk;            
		int *aiCols;           
		static const char *azCol[] = { "table", "rowid", "parent", "fkid" };

		regResult = pParse->nMem + 1;
		pParse->nMem += 4;
		regKey = ++pParse->nMem;
		regRow = ++pParse->nMem;
		v = sqlite3GetVdbe(pParse);
		setAllColumnNames(v, 4, azCol); assert(4 == ArraySize(azCol));
		sqlite3CodeVerifySchema(pParse, iDb);
		k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);
		while (k) {
			if (zRight) {
				pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);
				k = 0;
			}
			else {
				pTab = (Table*)sqliteHashData(k);
				k = sqliteHashNext(k);
			}
			if (pTab == 0 || pTab->pFKey == 0) continue;
			sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
			if (pTab->nCol + regRow>pParse->nMem) pParse->nMem = pTab->nCol + regRow;
			sqlite3OpenTable(pParse, 0, iDb, pTab, OP_OpenRead);
			sqlite3VdbeLoadString(v, regResult, pTab->zName);
			for (i = 1, pFK = pTab->pFKey; pFK; i++, pFK = pFK->pNextFrom) {
				pParent = sqlite3FindTable(db, pFK->zTo, zDb);
				if (pParent == 0) continue;
				pIdx = 0;
				sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);
				x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);
				if (x == 0) {
					if (pIdx == 0) {
						sqlite3OpenTable(pParse, i, iDb, pParent, OP_OpenRead);
					}
					else {
						sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iDb);
						sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
					}
				}
				else {
					k = 0;
					break;
				}
			}
			assert(pParse->nErr>0 || pFK == 0);
			if (pFK) break;
			if (pParse->nTab<i) pParse->nTab = i;
			addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);
			for (i = 1, pFK = pTab->pFKey; pFK; i++, pFK = pFK->pNextFrom) {
				pParent = sqlite3FindTable(db, pFK->zTo, zDb);
				pIdx = 0;
				aiCols = 0;
				if (pParent) {
					x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
					assert(x == 0);
				}
				addrOk = sqlite3VdbeMakeLabel(v);
				if (pParent && pIdx == 0) {
					int iKey = pFK->aCol[0].iFrom;
					assert(iKey >= 0 && iKey<pTab->nCol);
					if (iKey != pTab->iPKey) {
						sqlite3VdbeAddOp3(v, OP_Column, 0, iKey, regRow);
						sqlite3ColumnDefault(v, pTab, iKey, regRow);
						sqlite3VdbeAddOp2(v, OP_IsNull, regRow, addrOk); VdbeCoverage(v);
					}
					else {
						sqlite3VdbeAddOp2(v, OP_Rowid, 0, regRow);
					}
					sqlite3VdbeAddOp3(v, OP_SeekRowid, i, 0, regRow); VdbeCoverage(v);
					sqlite3VdbeGoto(v, addrOk);
					sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v) - 2);
				}
				else {
					for (j = 0; j<pFK->nCol; j++) {
						sqlite3ExprCodeGetColumnOfTable(v, pTab, 0,
							aiCols ? aiCols[j] : pFK->aCol[j].iFrom, regRow + j);
						sqlite3VdbeAddOp2(v, OP_IsNull, regRow + j, addrOk); VdbeCoverage(v);
					}
					if (pParent) {
						sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,
							sqlite3IndexAffinityStr(db, pIdx), pFK->nCol);
						sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);
						VdbeCoverage(v);
					}
				}
				sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult + 1);
				sqlite3VdbeMultiLoad(v, regResult + 2, "si", pFK->zTo, i - 1);
				sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);
				sqlite3VdbeResolveLabel(v, addrOk);
				sqlite3DbFree(db, aiCols);
			}
			sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop + 1); VdbeCoverage(v);
			sqlite3VdbeJumpHere(v, addrTop);
		}
	}
									break;
#endif 
#endif 

#ifndef NDEBUG
	case PragTyp_PARSER_TRACE: {
		if (zRight) {
			if (sqlite3GetBoolean(zRight, 0)) {
				sqlite3ParserTrace(stdout, "parser: ");
			}
			else {
				sqlite3ParserTrace(0, 0);
			}
		}
	}
							   break;
#endif

							   
	case PragTyp_CASE_SENSITIVE_LIKE: {
		if (zRight) {
			sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
		}
	}
									  break;

#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX
# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100
#endif

#ifndef SQLITE_OMIT_INTEGRITY_CHECK
									  
	case PragTyp_INTEGRITY_CHECK: {
		int i, j, addr, mxErr;

		int isQuick = (sqlite3Tolower(zLeft[0]) == 'q');

		
		assert(iDb >= 0);
		assert(iDb == 0 || pId2->z);
		if (pId2->z == 0) iDb = -1;

		
		pParse->nMem = 6;
		setOneColumnName(v, "integrity_check");

		
		mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;
		if (zRight) {
			sqlite3GetInt32(zRight, &mxErr);
			if (mxErr <= 0) {
				mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;
			}
		}
		sqlite3VdbeAddOp2(v, OP_Integer, mxErr, 1);  

													 
		for (i = 0; i<db->nDb; i++) {
			HashElem *x;
			Hash *pTbls;
			int *aRoot;
			int cnt = 0;
			int mxIdx = 0;
			int nIdx;

			if (OMIT_TEMPDB && i == 1) continue;
			if (iDb >= 0 && i != iDb) continue;

			sqlite3CodeVerifySchema(pParse, i);
			addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1); 
			VdbeCoverage(v);
			sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);
			sqlite3VdbeJumpHere(v, addr);

			
			assert(sqlite3SchemaMutexHeld(db, i, 0));
			pTbls = &db->aDb[i].pSchema->tblHash;
			for (cnt = 0, x = sqliteHashFirst(pTbls); x; x = sqliteHashNext(x)) {
				Table *pTab = sqliteHashData(x);
				Index *pIdx;
				if (HasRowid(pTab)) cnt++;
				for (nIdx = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, nIdx++) { cnt++; }
				if (nIdx>mxIdx) mxIdx = nIdx;
			}
			aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt + 1));
			if (aRoot == 0) break;
			for (cnt = 0, x = sqliteHashFirst(pTbls); x; x = sqliteHashNext(x)) {
				Table *pTab = sqliteHashData(x);
				Index *pIdx;
				if (HasRowid(pTab)) aRoot[cnt++] = pTab->tnum;
				for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
					aRoot[cnt++] = pIdx->tnum;
				}
			}
			aRoot[cnt] = 0;

			
			pParse->nMem = MAX(pParse->nMem, 8 + mxIdx);

			
			sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot, P4_INTARRAY);
			sqlite3VdbeChangeP5(v, (u8)i);
			addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);
			sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,
				sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zDbSName),
				P4_DYNAMIC);
			sqlite3VdbeAddOp3(v, OP_Move, 2, 4, 1);
			sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 2);
			sqlite3VdbeAddOp2(v, OP_ResultRow, 2, 1);
			sqlite3VdbeJumpHere(v, addr);

			
			for (x = sqliteHashFirst(pTbls); x && !isQuick; x = sqliteHashNext(x)) {
				Table *pTab = sqliteHashData(x);
				Index *pIdx, *pPk;
				Index *pPrior = 0;
				int loopTop;
				int iDataCur, iIdxCur;
				int r1 = -1;

				if (pTab->pIndex == 0) continue;
				pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
				addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1);  
				VdbeCoverage(v);
				sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);
				sqlite3VdbeJumpHere(v, addr);
				sqlite3ExprCacheClear(pParse);
				sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,
					1, 0, &iDataCur, &iIdxCur);
				sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);
				for (j = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, j++) {
					sqlite3VdbeAddOp2(v, OP_Integer, 0, 8 + j); 
				}
				assert(pParse->nMem >= 8 + j);
				assert(sqlite3NoTempsInRange(pParse, 1, 7 + j));
				sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);
				loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);
				
				for (j = 0; j<pTab->nCol; j++) {
					char *zErr;
					int jmp2, jmp3;
					if (j == pTab->iPKey) continue;
					if (pTab->aCol[j].notNull == 0) continue;
					sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
					sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
					jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);
					sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); 
					zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab->zName,
						pTab->aCol[j].zName);
					sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);
					sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);
					jmp3 = sqlite3VdbeAddOp1(v, OP_IfPos, 1); VdbeCoverage(v);
					sqlite3VdbeAddOp0(v, OP_Halt);
					sqlite3VdbeJumpHere(v, jmp2);
					sqlite3VdbeJumpHere(v, jmp3);
				}
				
				for (j = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, j++) {
					int jmp2, jmp3, jmp4, jmp5;
					int ckUniq = sqlite3VdbeMakeLabel(v);
					if (pPk == pIdx) continue;
					r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,
						pPrior, r1);
					pPrior = pIdx;
					sqlite3VdbeAddOp2(v, OP_AddImm, 8 + j, 1);  
																
					jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur + j, ckUniq, r1,
						pIdx->nColumn); VdbeCoverage(v);
					sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); 
					sqlite3VdbeLoadString(v, 3, "row ");
					sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);
					sqlite3VdbeLoadString(v, 4, " missing from index ");
					sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
					jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);
					sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
					sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);
					jmp4 = sqlite3VdbeAddOp1(v, OP_IfPos, 1); VdbeCoverage(v);
					sqlite3VdbeAddOp0(v, OP_Halt);
					sqlite3VdbeJumpHere(v, jmp2);
					
					if (IsUniqueIndex(pIdx)) {
						int uniqOk = sqlite3VdbeMakeLabel(v);
						int jmp6;
						int kk;
						for (kk = 0; kk<pIdx->nKeyCol; kk++) {
							int iCol = pIdx->aiColumn[kk];
							assert(iCol != XN_ROWID && iCol<pTab->nCol);
							if (iCol >= 0 && pTab->aCol[iCol].notNull) continue;
							sqlite3VdbeAddOp2(v, OP_IsNull, r1 + kk, uniqOk);
							VdbeCoverage(v);
						}
						jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur + j); VdbeCoverage(v);
						sqlite3VdbeGoto(v, uniqOk);
						sqlite3VdbeJumpHere(v, jmp6);
						sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur + j, uniqOk, r1,
							pIdx->nKeyCol); VdbeCoverage(v);
						sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); 
						sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");
						sqlite3VdbeGoto(v, jmp5);
						sqlite3VdbeResolveLabel(v, uniqOk);
					}
					sqlite3VdbeJumpHere(v, jmp4);
					sqlite3ResolvePartIdxLabel(pParse, jmp3);
				}
				sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);
				sqlite3VdbeJumpHere(v, loopTop - 1);
#ifndef SQLITE_OMIT_BTREECOUNT
				sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");
				for (j = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, j++) {
					if (pPk == pIdx) continue;
					addr = sqlite3VdbeCurrentAddr(v);
					sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr + 2); VdbeCoverage(v);
					sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);
					sqlite3VdbeAddOp2(v, OP_Count, iIdxCur + j, 3);
					sqlite3VdbeAddOp3(v, OP_Eq, 8 + j, addr + 8, 3); VdbeCoverage(v);
					sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
					sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);
					sqlite3VdbeLoadString(v, 3, pIdx->zName);
					sqlite3VdbeAddOp3(v, OP_Concat, 3, 2, 7);
					sqlite3VdbeAddOp2(v, OP_ResultRow, 7, 1);
				}
#endif 
			}
		}
		{
			static const int iLn = VDBE_OFFSET_LINENO(2);
			static const VdbeOpList endCode[] = {
				{ OP_AddImm,      1, 0,        0 },    
				{ OP_If,          1, 4,        0 },    
				{ OP_String8,     0, 3,        0 },    
				{ OP_ResultRow,   3, 1,        0 },    
			};
			VdbeOp *aOp;

			aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);
			if (aOp) {
				aOp[0].p2 = -mxErr;
				aOp[2].p4type = P4_STATIC;
				aOp[2].p4.z = "ok";
			}
		}
	}
								  break;
#endif 

#ifndef SQLITE_OMIT_UTF16
								  
	case PragTyp_ENCODING: {
		static const struct EncName {
			char *zName;
			u8 enc;
		} encnames[] = {
			{ "UTF8",     SQLITE_UTF8 },
			{ "UTF-8",    SQLITE_UTF8 },  
			{ "UTF-16le", SQLITE_UTF16LE },  
			{ "UTF-16be", SQLITE_UTF16BE },  
			{ "UTF16le",  SQLITE_UTF16LE },
			{ "UTF16be",  SQLITE_UTF16BE },
			{ "UTF-16",   0 }, 
			{ "UTF16",    0 }, 
			{ 0, 0 }
		};
		const struct EncName *pEnc;
		if (!zRight) {    
			if (sqlite3ReadSchema(pParse)) goto pragma_out;
			assert(encnames[SQLITE_UTF8].enc == SQLITE_UTF8);
			assert(encnames[SQLITE_UTF16LE].enc == SQLITE_UTF16LE);
			assert(encnames[SQLITE_UTF16BE].enc == SQLITE_UTF16BE);
			returnSingleText(v, "encoding", encnames[ENC(pParse->db)].zName);
		}
		else {                        
									  
			if (
				!(DbHasProperty(db, 0, DB_SchemaLoaded)) ||
				DbHasProperty(db, 0, DB_Empty)
				) {
				for (pEnc = &encnames[0]; pEnc->zName; pEnc++) {
					if (0 == sqlite3StrICmp(zRight, pEnc->zName)) {
						SCHEMA_ENC(db) = ENC(db) =
							pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;
						break;
					}
				}
				if (!pEnc->zName) {
					sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
				}
			}
		}
	}
						   break;
#endif 

#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
						   
	case PragTyp_HEADER_VALUE: {
		int iCookie = pPragma->iArg;  
		sqlite3VdbeUsesBtree(v, iDb);
		if (zRight && (pPragma->mPragFlag & PragFlag_ReadOnly) == 0) {
			
			static const VdbeOpList setCookie[] = {
				{ OP_Transaction,    0,  1,  0 },    
				{ OP_SetCookie,      0,  0,  0 },    
			};
			VdbeOp *aOp;
			sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));
			aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);
			if (ONLY_IF_REALLOC_STRESS(aOp == 0)) break;
			aOp[0].p1 = iDb;
			aOp[1].p1 = iDb;
			aOp[1].p2 = iCookie;
			aOp[1].p3 = sqlite3Atoi(zRight);
		}
		else {
			
			static const VdbeOpList readCookie[] = {
				{ OP_Transaction,     0,  0,  0 },    
				{ OP_ReadCookie,      0,  1,  0 },    
				{ OP_ResultRow,       1,  1,  0 }
			};
			VdbeOp *aOp;
			sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));
			aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie), readCookie, 0);
			if (ONLY_IF_REALLOC_STRESS(aOp == 0)) break;
			aOp[0].p1 = iDb;
			aOp[1].p1 = iDb;
			aOp[1].p3 = iCookie;
			sqlite3VdbeSetNumCols(v, 1);
			sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT);
			sqlite3VdbeReusable(v);
		}
	}
							   break;
#endif 

#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
							   
	case PragTyp_COMPILE_OPTIONS: {
		int i = 0;
		const char *zOpt;
		pParse->nMem = 1;
		setOneColumnName(v, "compile_option");
		while ((zOpt = sqlite3_compileoption_get(i++)) != 0) {
			sqlite3VdbeLoadString(v, 1, zOpt);
			sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
		}
		sqlite3VdbeReusable(v);
	}
								  break;
#endif 

#ifndef SQLITE_OMIT_WAL
								  
	case PragTyp_WAL_CHECKPOINT: {
		static const char *azCol[] = { "busy", "log", "checkpointed" };
		int iBt = (pId2->z ? iDb : SQLITE_MAX_ATTACHED);
		int eMode = SQLITE_CHECKPOINT_PASSIVE;
		if (zRight) {
			if (sqlite3StrICmp(zRight, "full") == 0) {
				eMode = SQLITE_CHECKPOINT_FULL;
			}
			else if (sqlite3StrICmp(zRight, "restart") == 0) {
				eMode = SQLITE_CHECKPOINT_RESTART;
			}
			else if (sqlite3StrICmp(zRight, "truncate") == 0) {
				eMode = SQLITE_CHECKPOINT_TRUNCATE;
			}
		}
		setAllColumnNames(v, 3, azCol);  assert(3 == ArraySize(azCol));
		pParse->nMem = 3;
		sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);
		sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
	}
								 break;

								 
	case PragTyp_WAL_AUTOCHECKPOINT: {
		if (zRight) {
			sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
		}
		returnSingleInt(v, "wal_autocheckpoint",
			db->xWalCallback == sqlite3WalDefaultHook ?
			SQLITE_PTR_TO_INT(db->pWalArg) : 0);
	}
									 break;
#endif

									 
	case PragTyp_SHRINK_MEMORY: {
		sqlite3_db_release_memory(db);
		break;
	}

								
								 default: {
									assert(pPragma->ePragTyp == PragTyp_BUSY_TIMEOUT);
									if (zRight) {
										sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
									}
									returnSingleInt(v, "timeout", db->busyTimeout);
									break;
								}

								
	case PragTyp_SOFT_HEAP_LIMIT: {
		sqlite3_int64 N;
		if (zRight && sqlite3DecOrHexToI64(zRight, &N) == SQLITE_OK) {
			sqlite3_soft_heap_limit64(N);
		}
		returnSingleInt(v, "soft_heap_limit", sqlite3_soft_heap_limit64(-1));
		break;
	}

								  
	case PragTyp_THREADS: {
		sqlite3_int64 N;
		if (zRight
			&& sqlite3DecOrHexToI64(zRight, &N) == SQLITE_OK
			&& N >= 0
			) {
			sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N & 0x7fffffff));
		}
		returnSingleInt(v, "threads",
			sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));
		break;
	}

#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
						  
	case PragTyp_LOCK_STATUS: {
		static const char *const azLockName[] = {
			"unlocked", "shared", "reserved", "pending", "exclusive"
		};
		static const char *azCol[] = { "database", "status" };
		int i;
		setAllColumnNames(v, 2, azCol); assert(2 == ArraySize(azCol));
		pParse->nMem = 2;
		for (i = 0; i<db->nDb; i++) {
			Btree *pBt;
			const char *zState = "unknown";
			int j;
			if (db->aDb[i].zDbSName == 0) continue;
			pBt = db->aDb[i].pBt;
			if (pBt == 0 || sqlite3BtreePager(pBt) == 0) {
				zState = "closed";
			}
			else if (sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0,
				SQLITE_FCNTL_LOCKSTATE, &j) == SQLITE_OK) {
				zState = azLockName[j];
			}
			sqlite3VdbeMultiLoad(v, 1, "ss", db->aDb[i].zDbSName, zState);
			sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
		}
		break;
	}
#endif

#ifdef SQLITE_HAS_CODEC
	case PragTyp_KEY: {
		if (zRight) sqlite3_key_v2(db, zDb, zRight, sqlite3Strlen30(zRight));
		break;
	}
	case PragTyp_REKEY: {
		if (zRight) sqlite3_rekey_v2(db, zDb, zRight, sqlite3Strlen30(zRight));
		break;
	}
	case PragTyp_HEXKEY: {
		if (zRight) {
			u8 iByte;
			int i;
			char zKey[40];
			for (i = 0, iByte = 0; i<sizeof(zKey) * 2 && sqlite3Isxdigit(zRight[i]); i++) {
				iByte = (iByte << 4) + sqlite3HexToInt(zRight[i]);
				if ((i & 1) != 0) zKey[i / 2] = iByte;
			}
			if ((zLeft[3] & 0xf) == 0xb) {
				sqlite3_key_v2(db, zDb, zKey, i / 2);
			}
			else {
				sqlite3_rekey_v2(db, zDb, zKey, i / 2);
			}
		}
		break;
	}
#endif
#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)
	case PragTyp_ACTIVATE_EXTENSIONS: if (zRight) {
#ifdef SQLITE_HAS_CODEC
		if (sqlite3StrNICmp(zRight, "see-", 4) == 0) {
			sqlite3_activate_see(&zRight[4]);
		}
#endif
#ifdef SQLITE_ENABLE_CEROD
		if (sqlite3StrNICmp(zRight, "cerod-", 6) == 0) {
			sqlite3_activate_cerod(&zRight[6]);
		}
#endif
	}
									  break;
#endif

	} 

pragma_out:
	sqlite3DbFree(db, zLeft);
	sqlite3DbFree(db, zRight);
}

#endif 







static void corruptSchema(
	InitData *pData,     
	const char *zObj,    
	const char *zExtra   
) {
	sqlite3 *db = pData->db;
	if (!db->mallocFailed && (db->flags & SQLITE_RecoveryMode) == 0) {
		char *z;
		if (zObj == 0) zObj = "?";
		z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
		if (zExtra) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
		sqlite3DbFree(db, *pData->pzErrMsg);
		*pData->pzErrMsg = z;
	}
	pData->rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_CORRUPT_BKPT;
}


SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed) {
	InitData *pData = (InitData*)pInit;
	sqlite3 *db = pData->db;
	int iDb = pData->iDb;

	assert(argc == 3);
	UNUSED_PARAMETER2(NotUsed, argc);
	assert(sqlite3_mutex_held(db->mutex));
	DbClearProperty(db, iDb, DB_Empty);
	if (db->mallocFailed) {
		corruptSchema(pData, argv[0], 0);
		return 1;
	}

	assert(iDb >= 0 && iDb<db->nDb);
	if (argv == 0) return 0;   
	if (argv[1] == 0) {
		corruptSchema(pData, argv[0], 0);
	}
	else if (sqlite3_strnicmp(argv[2], "create ", 7) == 0) {
		
		int rc;
		u8 saved_iDb = db->init.iDb;
		sqlite3_stmt *pStmt;
		TESTONLY(int rcp);            

		assert(db->init.busy);
		db->init.iDb = iDb;
		db->init.newTnum = sqlite3Atoi(argv[1]);
		db->init.orphanTrigger = 0;
		TESTONLY(rcp = ) sqlite3_prepare(db, argv[2], -1, &pStmt, 0);
		rc = db->errCode;
		assert((rc & 0xFF) == (rcp & 0xFF));
		db->init.iDb = saved_iDb;
		assert(saved_iDb == 0 || (db->flags & SQLITE_Vacuum) != 0);
		if (SQLITE_OK != rc) {
			if (db->init.orphanTrigger) {
				assert(iDb == 1);
			}
			else {
				pData->rc = rc;
				if (rc == SQLITE_NOMEM) {
					sqlite3OomFault(db);
				}
				else if (rc != SQLITE_INTERRUPT && (rc & 0xFF) != SQLITE_LOCKED) {
					corruptSchema(pData, argv[0], sqlite3_errmsg(db));
				}
			}
		}
		sqlite3_finalize(pStmt);
	}
	else if (argv[0] == 0 || (argv[2] != 0 && argv[2][0] != 0)) {
		corruptSchema(pData, argv[0], 0);
	}
	else {
		
		Index *pIndex;
		pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zDbSName);
		if (pIndex == 0) {
			
			;
		}
		else if (sqlite3GetInt32(argv[1], &pIndex->tnum) == 0) {
			corruptSchema(pData, argv[0], "invalid rootpage");
		}
	}
	return 0;
}


static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg) {
	int rc;
	int i;
#ifndef SQLITE_OMIT_DEPRECATED
	int size;
#endif
	Db *pDb;
	char const *azArg[4];
	int meta[5];
	InitData initData;
	const char *zMasterName;
	int openedTransaction = 0;

	assert(iDb >= 0 && iDb<db->nDb);
	assert(db->aDb[iDb].pSchema);
	assert(sqlite3_mutex_held(db->mutex));
	assert(iDb == 1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt));

	
	azArg[0] = zMasterName = SCHEMA_TABLE(iDb);
	azArg[1] = "1";
	azArg[2] = "CREATE TABLE x(type text,name text,tbl_name text,"
		"rootpage integer,sql text)";
	azArg[3] = 0;
	initData.db = db;
	initData.iDb = iDb;
	initData.rc = SQLITE_OK;
	initData.pzErrMsg = pzErrMsg;
	sqlite3InitCallback(&initData, 3, (char **)azArg, 0);
	if (initData.rc) {
		rc = initData.rc;
		goto error_out;
	}

	
	pDb = &db->aDb[iDb];
	if (pDb->pBt == 0) {
		if (!OMIT_TEMPDB && ALWAYS(iDb == 1)) {
			DbSetProperty(db, 1, DB_SchemaLoaded);
		}
		return SQLITE_OK;
	}

	
	sqlite3BtreeEnter(pDb->pBt);
	if (!sqlite3BtreeIsInReadTrans(pDb->pBt)) {
		rc = sqlite3BtreeBeginTrans(pDb->pBt, 0);
		if (rc != SQLITE_OK) {
			sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));
			goto initone_error_out;
		}
		openedTransaction = 1;
	}

	
	for (i = 0; i<ArraySize(meta); i++) {
		sqlite3BtreeGetMeta(pDb->pBt, i + 1, (u32 *)&meta[i]);
	}
	pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION - 1];

	
	if (meta[BTREE_TEXT_ENCODING - 1]) {  
		if (iDb == 0) {
#ifndef SQLITE_OMIT_UTF16
			u8 encoding;
			
			encoding = (u8)meta[BTREE_TEXT_ENCODING - 1] & 3;
			if (encoding == 0) encoding = SQLITE_UTF8;
			ENC(db) = encoding;
#else
			ENC(db) = SQLITE_UTF8;
#endif
		}
		else {
			
			if (meta[BTREE_TEXT_ENCODING - 1] != ENC(db)) {
				sqlite3SetString(pzErrMsg, db, "attached databases must use the same"
					" text encoding as main database");
				rc = SQLITE_ERROR;
				goto initone_error_out;
			}
		}
	}
	else {
		DbSetProperty(db, iDb, DB_Empty);
	}
	pDb->pSchema->enc = ENC(db);

	if (pDb->pSchema->cache_size == 0) {
#ifndef SQLITE_OMIT_DEPRECATED
		size = sqlite3AbsInt32(meta[BTREE_DEFAULT_CACHE_SIZE - 1]);
		if (size == 0) { size = SQLITE_DEFAULT_CACHE_SIZE; }
		pDb->pSchema->cache_size = size;
#else
		pDb->pSchema->cache_size = SQLITE_DEFAULT_CACHE_SIZE;
#endif
		sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
	}

	
	pDb->pSchema->file_format = (u8)meta[BTREE_FILE_FORMAT - 1];
	if (pDb->pSchema->file_format == 0) {
		pDb->pSchema->file_format = 1;
	}
	if (pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT) {
		sqlite3SetString(pzErrMsg, db, "unsupported file format");
		rc = SQLITE_ERROR;
		goto initone_error_out;
	}

	
	if (iDb == 0 && meta[BTREE_FILE_FORMAT - 1] >= 4) {
		db->flags &= ~SQLITE_LegacyFileFmt;
	}

	
	assert(db->init.busy);
	{
		char *zSql;
		zSql = sqlite3MPrintf(db,
			"SELECT name, rootpage, sql FROM \"%w\".%s ORDER BY rowid",
			db->aDb[iDb].zDbSName, zMasterName);
#ifndef SQLITE_OMIT_AUTHORIZATION
		{
			sqlite3_xauth xAuth;
			xAuth = db->xAuth;
			db->xAuth = 0;
#endif
			rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
#ifndef SQLITE_OMIT_AUTHORIZATION
			db->xAuth = xAuth;
		}
#endif
		if (rc == SQLITE_OK) rc = initData.rc;
		sqlite3DbFree(db, zSql);
#ifndef SQLITE_OMIT_ANALYZE
		if (rc == SQLITE_OK) {
			sqlite3AnalysisLoad(db, iDb);
		}
#endif
	}
	if (db->mallocFailed) {
		rc = SQLITE_NOMEM_BKPT;
		sqlite3ResetAllSchemasOfConnection(db);
	}
	if (rc == SQLITE_OK || (db->flags&SQLITE_RecoveryMode)) {
		
		DbSetProperty(db, iDb, DB_SchemaLoaded);
		rc = SQLITE_OK;
	}

	
initone_error_out:
	if (openedTransaction) {
		sqlite3BtreeCommit(pDb->pBt);
	}
	sqlite3BtreeLeave(pDb->pBt);

error_out:
	if (rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM) {
		sqlite3OomFault(db);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg) {
	int i, rc;
	int commit_internal = !(db->flags&SQLITE_InternChanges);

	assert(sqlite3_mutex_held(db->mutex));
	assert(sqlite3BtreeHoldsMutex(db->aDb[0].pBt));
	assert(db->init.busy == 0);
	rc = SQLITE_OK;
	db->init.busy = 1;
	ENC(db) = SCHEMA_ENC(db);
	for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
		if (DbHasProperty(db, i, DB_SchemaLoaded) || i == 1) continue;
		rc = sqlite3InitOne(db, i, pzErrMsg);
		if (rc) {
			sqlite3ResetOneSchema(db, i);
		}
	}

	
#ifndef SQLITE_OMIT_TEMPDB
	assert(db->nDb>1);
	if (rc == SQLITE_OK && !DbHasProperty(db, 1, DB_SchemaLoaded)) {
		rc = sqlite3InitOne(db, 1, pzErrMsg);
		if (rc) {
			sqlite3ResetOneSchema(db, 1);
		}
	}
#endif

	db->init.busy = 0;
	if (rc == SQLITE_OK && commit_internal) {
		sqlite3CommitInternalChanges(db);
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse) {
	int rc = SQLITE_OK;
	sqlite3 *db = pParse->db;
	assert(sqlite3_mutex_held(db->mutex));
	if (!db->init.busy) {
		rc = sqlite3Init(db, &pParse->zErrMsg);
	}
	if (rc != SQLITE_OK) {
		pParse->rc = rc;
		pParse->nErr++;
	}
	return rc;
}



static void schemaIsValid(Parse *pParse) {
	sqlite3 *db = pParse->db;
	int iDb;
	int rc;
	int cookie;

	assert(pParse->checkSchema);
	assert(sqlite3_mutex_held(db->mutex));
	for (iDb = 0; iDb<db->nDb; iDb++) {
		int openedTransaction = 0;         
		Btree *pBt = db->aDb[iDb].pBt;     
		if (pBt == 0) continue;

		
		if (!sqlite3BtreeIsInReadTrans(pBt)) {
			rc = sqlite3BtreeBeginTrans(pBt, 0);
			if (rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM) {
				sqlite3OomFault(db);
			}
			if (rc != SQLITE_OK) return;
			openedTransaction = 1;
		}

		
		sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		if (cookie != db->aDb[iDb].pSchema->schema_cookie) {
			sqlite3ResetOneSchema(db, iDb);
			pParse->rc = SQLITE_SCHEMA;
		}

		
		if (openedTransaction) {
			sqlite3BtreeCommit(pBt);
		}
	}
}


SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema) {
	int i = -1000000;

	
	assert(sqlite3_mutex_held(db->mutex));
	if (pSchema) {
		for (i = 0; ALWAYS(i<db->nDb); i++) {
			if (db->aDb[i].pSchema == pSchema) {
				break;
			}
		}
		assert(i >= 0 && i<db->nDb);
	}
	return i;
}


SQLITE_PRIVATE void sqlite3ParserReset(Parse *pParse) {
	if (pParse) {
		sqlite3 *db = pParse->db;
		sqlite3DbFree(db, pParse->aLabel);
		sqlite3ExprListDelete(db, pParse->pConstExpr);
		if (db) {
			assert(db->lookaside.bDisable >= pParse->disableLookaside);
			db->lookaside.bDisable -= pParse->disableLookaside;
		}
		pParse->disableLookaside = 0;
	}
}


static int sqlite3Prepare(
	sqlite3 *db,              
	const char *zSql,         
	int nBytes,               
	int saveSqlFlag,          
	Vdbe *pReprepare,         
	sqlite3_stmt **ppStmt,    
	const char **pzTail       
) {
	char *zErrMsg = 0;        
	int rc = SQLITE_OK;       
	int i;                    
	Parse sParse;             

	memset(&sParse, 0, PARSE_HDR_SZ);
	memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
	sParse.pReprepare = pReprepare;
	assert(ppStmt && *ppStmt == 0);
	
	assert(sqlite3_mutex_held(db->mutex));

	
	for (i = 0; i<db->nDb; i++) {
		Btree *pBt = db->aDb[i].pBt;
		if (pBt) {
			assert(sqlite3BtreeHoldsMutex(pBt));
			rc = sqlite3BtreeSchemaLocked(pBt);
			if (rc) {
				const char *zDb = db->aDb[i].zDbSName;
				sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
				testcase(db->flags & SQLITE_ReadUncommitted);
				goto end_prepare;
			}
		}
	}

	sqlite3VtabUnlockList(db);

	sParse.db = db;
	if (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != 0)) {
		char *zSqlCopy;
		int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
		testcase(nBytes == mxLen);
		testcase(nBytes == mxLen + 1);
		if (nBytes>mxLen) {
			sqlite3ErrorWithMsg(db, SQLITE_TOOBIG, "statement too long");
			rc = sqlite3ApiExit(db, SQLITE_TOOBIG);
			goto end_prepare;
		}
		zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);
		if (zSqlCopy) {
			sqlite3RunParser(&sParse, zSqlCopy, &zErrMsg);
			sParse.zTail = &zSql[sParse.zTail - zSqlCopy];
			sqlite3DbFree(db, zSqlCopy);
		}
		else {
			sParse.zTail = &zSql[nBytes];
		}
	}
	else {
		sqlite3RunParser(&sParse, zSql, &zErrMsg);
	}
	assert(0 == sParse.nQueryLoop);

	if (sParse.rc == SQLITE_DONE) sParse.rc = SQLITE_OK;
	if (sParse.checkSchema) {
		schemaIsValid(&sParse);
	}
	if (db->mallocFailed) {
		sParse.rc = SQLITE_NOMEM_BKPT;
	}
	if (pzTail) {
		*pzTail = sParse.zTail;
	}
	rc = sParse.rc;

#ifndef SQLITE_OMIT_EXPLAIN
	if (rc == SQLITE_OK && sParse.pVdbe && sParse.explain) {
		static const char * const azColName[] = {
			"addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
			"selectid", "order", "from", "detail"
		};
		int iFirst, mx;
		if (sParse.explain == 2) {
			sqlite3VdbeSetNumCols(sParse.pVdbe, 4);
			iFirst = 8;
			mx = 12;
		}
		else {
			sqlite3VdbeSetNumCols(sParse.pVdbe, 8);
			iFirst = 0;
			mx = 8;
		}
		for (i = iFirst; i<mx; i++) {
			sqlite3VdbeSetColName(sParse.pVdbe, i - iFirst, COLNAME_NAME,
				azColName[i], SQLITE_STATIC);
		}
	}
#endif

	if (db->init.busy == 0) {
		Vdbe *pVdbe = sParse.pVdbe;
		sqlite3VdbeSetSql(pVdbe, zSql, (int)(sParse.zTail - zSql), saveSqlFlag);
	}
	if (sParse.pVdbe && (rc != SQLITE_OK || db->mallocFailed)) {
		sqlite3VdbeFinalize(sParse.pVdbe);
		assert(!(*ppStmt));
	}
	else {
		*ppStmt = (sqlite3_stmt*)sParse.pVdbe;
	}

	if (zErrMsg) {
		sqlite3ErrorWithMsg(db, rc, "%s", zErrMsg);
		sqlite3DbFree(db, zErrMsg);
	}
	else {
		sqlite3Error(db, rc);
	}

	
	while (sParse.pTriggerPrg) {
		TriggerPrg *pT = sParse.pTriggerPrg;
		sParse.pTriggerPrg = pT->pNext;
		sqlite3DbFree(db, pT);
	}

end_prepare:

	sqlite3ParserReset(&sParse);
	rc = sqlite3ApiExit(db, rc);
	assert((rc&db->errMask) == rc);
	return rc;
}
static int sqlite3LockAndPrepare(
	sqlite3 *db,              
	const char *zSql,         
	int nBytes,               
	int saveSqlFlag,          
	Vdbe *pOld,               
	sqlite3_stmt **ppStmt,    
	const char **pzTail       
) {
	int rc;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (ppStmt == 0) return SQLITE_MISUSE_BKPT;
#endif
	*ppStmt = 0;
	if (!sqlite3SafetyCheckOk(db) || zSql == 0) {
		return SQLITE_MISUSE_BKPT;
	}
	sqlite3_mutex_enter(db->mutex);
	sqlite3BtreeEnterAll(db);
	rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
	if (rc == SQLITE_SCHEMA) {
		sqlite3_finalize(*ppStmt);
		rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
	}
	sqlite3BtreeLeaveAll(db);
	sqlite3_mutex_leave(db->mutex);
	assert(rc == SQLITE_OK || *ppStmt == 0);
	return rc;
}


SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p) {
	int rc;
	sqlite3_stmt *pNew;
	const char *zSql;
	sqlite3 *db;

	assert(sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex));
	zSql = sqlite3_sql((sqlite3_stmt *)p);
	assert(zSql != 0);  
	db = sqlite3VdbeDb(p);
	assert(sqlite3_mutex_held(db->mutex));
	rc = sqlite3LockAndPrepare(db, zSql, -1, 0, p, &pNew, 0);
	if (rc) {
		if (rc == SQLITE_NOMEM) {
			sqlite3OomFault(db);
		}
		assert(pNew == 0);
		return rc;
	}
	else {
		assert(pNew != 0);
	}
	sqlite3VdbeSwap((Vdbe*)pNew, p);
	sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);
	sqlite3VdbeResetStepResult((Vdbe*)pNew);
	sqlite3VdbeFinalize((Vdbe*)pNew);
	return SQLITE_OK;
}



SQLITE_API int sqlite3_prepare(
	sqlite3 *db,              
	const char *zSql,         
	int nBytes,               
	sqlite3_stmt **ppStmt,    
	const char **pzTail       
) {
	int rc;
	rc = sqlite3LockAndPrepare(db, zSql, nBytes, 0, 0, ppStmt, pzTail);
	assert(rc == SQLITE_OK || ppStmt == 0 || *ppStmt == 0);  
	return rc;
}
SQLITE_API int sqlite3_prepare_v2(
	sqlite3 *db,              
	const char *zSql,         
	int nBytes,               
	sqlite3_stmt **ppStmt,    
	const char **pzTail       
) {
	int rc;
	rc = sqlite3LockAndPrepare(db, zSql, nBytes, 1, 0, ppStmt, pzTail);
	assert(rc == SQLITE_OK || ppStmt == 0 || *ppStmt == 0);  
	return rc;
}


#ifndef SQLITE_OMIT_UTF16

static int sqlite3Prepare16(
	sqlite3 *db,              
	const void *zSql,         
	int nBytes,               
	int saveSqlFlag,          
	sqlite3_stmt **ppStmt,    
	const void **pzTail       
) {
	
	char *zSql8;
	const char *zTail8 = 0;
	int rc = SQLITE_OK;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (ppStmt == 0) return SQLITE_MISUSE_BKPT;
#endif
	*ppStmt = 0;
	if (!sqlite3SafetyCheckOk(db) || zSql == 0) {
		return SQLITE_MISUSE_BKPT;
	}
	if (nBytes >= 0) {
		int sz;
		const char *z = (const char*)zSql;
		for (sz = 0; sz<nBytes && (z[sz] != 0 || z[sz + 1] != 0); sz += 2) {}
		nBytes = sz;
	}
	sqlite3_mutex_enter(db->mutex);
	zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);
	if (zSql8) {
		rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, 0, ppStmt, &zTail8);
	}

	if (zTail8 && pzTail) {
		
		int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8 - zSql8));
		*pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);
	}
	sqlite3DbFree(db, zSql8);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_API int sqlite3_prepare16(
	sqlite3 *db,              
	const void *zSql,         
	int nBytes,               
	sqlite3_stmt **ppStmt,    
	const void **pzTail       
) {
	int rc;
	rc = sqlite3Prepare16(db, zSql, nBytes, 0, ppStmt, pzTail);
	assert(rc == SQLITE_OK || ppStmt == 0 || *ppStmt == 0);  
	return rc;
}
SQLITE_API int sqlite3_prepare16_v2(
	sqlite3 *db,              
	const void *zSql,         
	int nBytes,               
	sqlite3_stmt **ppStmt,    
	const void **pzTail       
) {
	int rc;
	rc = sqlite3Prepare16(db, zSql, nBytes, 1, ppStmt, pzTail);
	assert(rc == SQLITE_OK || ppStmt == 0 || *ppStmt == 0);  
	return rc;
}

#endif 







#if SELECTTRACE_ENABLED
 int sqlite3SelectTrace = 0;
# define SELECTTRACE(K,P,S,X)  \
  if(sqlite3SelectTrace&(K))   \
    sqlite3DebugPrintf("%*s%s.%p: ",(P)->nSelectIndent*2-2,"",\
        (S)->zSelName,(S)),\
    sqlite3DebugPrintf X
#else
# define SELECTTRACE(K,P,S,X)
#endif



typedef struct DistinctCtx DistinctCtx;
struct DistinctCtx {
	u8 isTnct;      
	u8 eTnctType;   
	int tabTnct;    
	int addrTnct;   
};


typedef struct SortCtx SortCtx;
struct SortCtx {
	ExprList *pOrderBy;   
	int nOBSat;           
	int iECursor;         
	int regReturn;        
	int labelBkOut;       
	int addrSortIndex;    
	int labelDone;        
	u8 sortFlags;         
	u8 bOrderedInnerLoop; 
};
#define SORTFLAG_UseSorter  0x01   


static void clearSelect(sqlite3 *db, Select *p, int bFree) {
	while (p) {
		Select *pPrior = p->pPrior;
		sqlite3ExprListDelete(db, p->pEList);
		sqlite3SrcListDelete(db, p->pSrc);
		sqlite3ExprDelete(db, p->pWhere);
		sqlite3ExprListDelete(db, p->pGroupBy);
		sqlite3ExprDelete(db, p->pHaving);
		sqlite3ExprListDelete(db, p->pOrderBy);
		sqlite3ExprDelete(db, p->pLimit);
		sqlite3ExprDelete(db, p->pOffset);
		if (p->pWith) sqlite3WithDelete(db, p->pWith);
		if (bFree) sqlite3DbFree(db, p);
		p = pPrior;
		bFree = 1;
	}
}


SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm) {
	pDest->eDest = (u8)eDest;
	pDest->iSDParm = iParm;
	pDest->zAffSdst = 0;
	pDest->iSdst = 0;
	pDest->nSdst = 0;
}



SQLITE_PRIVATE Select *sqlite3SelectNew(
	Parse *pParse,        
	ExprList *pEList,     
	SrcList *pSrc,        
	Expr *pWhere,         
	ExprList *pGroupBy,   
	Expr *pHaving,        
	ExprList *pOrderBy,   
	u32 selFlags,         
	Expr *pLimit,         
	Expr *pOffset         
) {
	Select *pNew;
	Select standin;
	sqlite3 *db = pParse->db;
	pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew));
	if (pNew == 0) {
		assert(db->mallocFailed);
		pNew = &standin;
	}
	if (pEList == 0) {
		pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));
	}
	pNew->pEList = pEList;
	pNew->op = TK_SELECT;
	pNew->selFlags = selFlags;
	pNew->iLimit = 0;
	pNew->iOffset = 0;
#if SELECTTRACE_ENABLED
	pNew->zSelName[0] = 0;
#endif
	pNew->addrOpenEphm[0] = -1;
	pNew->addrOpenEphm[1] = -1;
	pNew->nSelectRow = 0;
	if (pSrc == 0) pSrc = sqlite3DbMallocZero(db, sizeof(*pSrc));
	pNew->pSrc = pSrc;
	pNew->pWhere = pWhere;
	pNew->pGroupBy = pGroupBy;
	pNew->pHaving = pHaving;
	pNew->pOrderBy = pOrderBy;
	pNew->pPrior = 0;
	pNew->pNext = 0;
	pNew->pLimit = pLimit;
	pNew->pOffset = pOffset;
	pNew->pWith = 0;
	assert(pOffset == 0 || pLimit != 0 || pParse->nErr>0 || db->mallocFailed != 0);
	if (db->mallocFailed) {
		clearSelect(db, pNew, pNew != &standin);
		pNew = 0;
	}
	else {
		assert(pNew->pSrc != 0 || pParse->nErr>0);
	}
	assert(pNew != &standin);
	return pNew;
}

#if SELECTTRACE_ENABLED

SQLITE_PRIVATE void sqlite3SelectSetName(Select *p, const char *zName) {
	if (p && zName) {
		sqlite3_snprintf(sizeof(p->zSelName), p->zSelName, "%s", zName);
	}
}
#endif



SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3 *db, Select *p) {
	if (p) clearSelect(db, p, 1);
}


static Select *findRightmost(Select *p) {
	while (p->pNext) p = p->pNext;
	return p;
}


SQLITE_PRIVATE int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC) {
	int jointype = 0;
	Token *apAll[3];
	Token *p;
	
	static const char zKeyText[] = "naturaleftouterightfullinnercross";
	static const struct {
		u8 i;        
		u8 nChar;    
		u8 code;     
	} aKeyword[] = {
		{ 0,  7, JT_NATURAL },
		{ 6,  4, JT_LEFT | JT_OUTER },
		{ 10, 5, JT_OUTER },
		{ 14, 5, JT_RIGHT | JT_OUTER },
		{ 19, 4, JT_LEFT | JT_RIGHT | JT_OUTER },
		{ 23, 5, JT_INNER },
		{ 28, 5, JT_INNER | JT_CROSS },
	};
	int i, j;
	apAll[0] = pA;
	apAll[1] = pB;
	apAll[2] = pC;
	for (i = 0; i<3 && apAll[i]; i++) {
		p = apAll[i];
		for (j = 0; j<ArraySize(aKeyword); j++) {
			if (p->n == aKeyword[j].nChar
				&& sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n) == 0) {
				jointype |= aKeyword[j].code;
				break;
			}
		}
		testcase(j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5 || j == 6);
		if (j >= ArraySize(aKeyword)) {
			jointype |= JT_ERROR;
			break;
		}
	}
	if (
		(jointype & (JT_INNER | JT_OUTER)) == (JT_INNER | JT_OUTER) ||
		(jointype & JT_ERROR) != 0
		) {
		const char *zSp = " ";
		assert(pB != 0);
		if (pC == 0) { zSp++; }
		sqlite3ErrorMsg(pParse, "unknown or unsupported join type: "
			"%T %T%s%T", pA, pB, zSp, pC);
		jointype = JT_INNER;
	}
	else if ((jointype & JT_OUTER) != 0
		&& (jointype & (JT_LEFT | JT_RIGHT)) != JT_LEFT) {
		sqlite3ErrorMsg(pParse,
			"RIGHT and FULL OUTER JOINs are not currently supported");
		jointype = JT_INNER;
	}
	return jointype;
}


static int columnIndex(Table *pTab, const char *zCol) {
	int i;
	for (i = 0; i<pTab->nCol; i++) {
		if (sqlite3StrICmp(pTab->aCol[i].zName, zCol) == 0) return i;
	}
	return -1;
}


static int tableAndColumnIndex(
	SrcList *pSrc,       
	int N,               
	const char *zCol,    
	int *piTab,          
	int *piCol           
) {
	int i;               
	int iCol;            

	assert((piTab == 0) == (piCol == 0));  
	for (i = 0; i<N; i++) {
		iCol = columnIndex(pSrc->a[i].pTab, zCol);
		if (iCol >= 0) {
			if (piTab) {
				*piTab = i;
				*piCol = iCol;
			}
			return 1;
		}
	}
	return 0;
}


static void addWhereTerm(
	Parse *pParse,                  
	SrcList *pSrc,                  
	int iLeft,                      
	int iColLeft,                   
	int iRight,                     
	int iColRight,                  
	int isOuterJoin,                
	Expr **ppWhere                  
) {
	sqlite3 *db = pParse->db;
	Expr *pE1;
	Expr *pE2;
	Expr *pEq;

	assert(iLeft<iRight);
	assert(pSrc->nSrc>iRight);
	assert(pSrc->a[iLeft].pTab);
	assert(pSrc->a[iRight].pTab);

	pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
	pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);

	pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2, 0);
	if (pEq && isOuterJoin) {
		ExprSetProperty(pEq, EP_FromJoin);
		assert(!ExprHasProperty(pEq, EP_TokenOnly | EP_Reduced));
		ExprSetVVAProperty(pEq, EP_NoReduce);
		pEq->iRightJoinTable = (i16)pE2->iTable;
	}
	*ppWhere = sqlite3ExprAnd(db, *ppWhere, pEq);
}


static void setJoinExpr(Expr *p, int iTable) {
	while (p) {
		ExprSetProperty(p, EP_FromJoin);
		assert(!ExprHasProperty(p, EP_TokenOnly | EP_Reduced));
		ExprSetVVAProperty(p, EP_NoReduce);
		p->iRightJoinTable = (i16)iTable;
		if (p->op == TK_FUNCTION && p->x.pList) {
			int i;
			for (i = 0; i<p->x.pList->nExpr; i++) {
				setJoinExpr(p->x.pList->a[i].pExpr, iTable);
			}
		}
		setJoinExpr(p->pLeft, iTable);
		p = p->pRight;
	}
}


static int sqliteProcessJoin(Parse *pParse, Select *p) {
	SrcList *pSrc;                  
	int i, j;                       
	struct SrcList_item *pLeft;     
	struct SrcList_item *pRight;    

	pSrc = p->pSrc;
	pLeft = &pSrc->a[0];
	pRight = &pLeft[1];
	for (i = 0; i<pSrc->nSrc - 1; i++, pRight++, pLeft++) {
		Table *pLeftTab = pLeft->pTab;
		Table *pRightTab = pRight->pTab;
		int isOuter;

		if (NEVER(pLeftTab == 0 || pRightTab == 0)) continue;
		isOuter = (pRight->fg.jointype & JT_OUTER) != 0;

		
		if (pRight->fg.jointype & JT_NATURAL) {
			if (pRight->pOn || pRight->pUsing) {
				sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
					"an ON or USING clause", 0);
				return 1;
			}
			for (j = 0; j<pRightTab->nCol; j++) {
				char *zName;   
				int iLeft;     
				int iLeftCol;  

				zName = pRightTab->aCol[j].zName;
				if (tableAndColumnIndex(pSrc, i + 1, zName, &iLeft, &iLeftCol)) {
					addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i + 1, j,
						isOuter, &p->pWhere);
				}
			}
		}

		
		if (pRight->pOn && pRight->pUsing) {
			sqlite3ErrorMsg(pParse, "cannot have both ON and USING "
				"clauses in the same join");
			return 1;
		}

		
		if (pRight->pOn) {
			if (isOuter) setJoinExpr(pRight->pOn, pRight->iCursor);
			p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn);
			pRight->pOn = 0;
		}

		
		if (pRight->pUsing) {
			IdList *pList = pRight->pUsing;
			for (j = 0; j<pList->nId; j++) {
				char *zName;     
				int iLeft;       
				int iLeftCol;    
				int iRightCol;   

				zName = pList->a[j].zName;
				iRightCol = columnIndex(pRightTab, zName);
				if (iRightCol<0
					|| !tableAndColumnIndex(pSrc, i + 1, zName, &iLeft, &iLeftCol)
					) {
					sqlite3ErrorMsg(pParse, "cannot join using column %s - column "
						"not present in both tables", zName);
					return 1;
				}
				addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i + 1, iRightCol,
					isOuter, &p->pWhere);
			}
		}
	}
	return 0;
}


static KeyInfo *keyInfoFromExprList(
	Parse *pParse,       
	ExprList *pList,     
	int iStart,          
	int nExtra           
);


static void pushOntoSorter(
	Parse *pParse,         
	SortCtx *pSort,        
	Select *pSelect,       
	int regData,           
	int regOrigData,       
	int nData,             
	int nPrefixReg         
) {
	Vdbe *v = pParse->pVdbe;                         
	int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter) == 0);
	int nExpr = pSort->pOrderBy->nExpr;              
	int nBase = nExpr + bSeq + nData;                
	int regBase;                                     
	int regRecord = ++pParse->nMem;                  
	int nOBSat = pSort->nOBSat;                      
	int op;                            
	int iLimit;                        

	assert(bSeq == 0 || bSeq == 1);
	assert(nData == 1 || regData == regOrigData);
	if (nPrefixReg) {
		assert(nPrefixReg == nExpr + bSeq);
		regBase = regData - nExpr - bSeq;
	}
	else {
		regBase = pParse->nMem + 1;
		pParse->nMem += nBase;
	}
	assert(pSelect->iOffset == 0 || pSelect->iLimit != 0);
	iLimit = pSelect->iOffset ? pSelect->iOffset + 1 : pSelect->iLimit;
	pSort->labelDone = sqlite3VdbeMakeLabel(v);
	sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,
		SQLITE_ECEL_DUP | SQLITE_ECEL_REF);
	if (bSeq) {
		sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase + nExpr);
	}
	if (nPrefixReg == 0) {
		sqlite3ExprCodeMove(pParse, regData, regBase + nExpr + bSeq, nData);
	}
	sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase + nOBSat, nBase - nOBSat, regRecord);
	if (nOBSat>0) {
		int regPrevKey;   
		int addrFirst;    
		int addrJmp;      
		VdbeOp *pOp;      
		int nKey;         
		KeyInfo *pKI;     

		regPrevKey = pParse->nMem + 1;
		pParse->nMem += pSort->nOBSat;
		nKey = nExpr - pSort->nOBSat + bSeq;
		if (bSeq) {
			addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase + nExpr);
		}
		else {
			addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);
		}
		VdbeCoverage(v);
		sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);
		pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
		if (pParse->db->mallocFailed) return;
		pOp->p2 = nKey + nData;
		pKI = pOp->p4.pKeyInfo;
		memset(pKI->aSortOrder, 0, pKI->nField); 
		sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);
		testcase(pKI->nXField>2);
		pOp->p4.pKeyInfo = keyInfoFromExprList(pParse, pSort->pOrderBy, nOBSat,
			pKI->nXField - 1);
		addrJmp = sqlite3VdbeCurrentAddr(v);
		sqlite3VdbeAddOp3(v, OP_Jump, addrJmp + 1, 0, addrJmp + 1); VdbeCoverage(v);
		pSort->labelBkOut = sqlite3VdbeMakeLabel(v);
		pSort->regReturn = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);
		sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);
		if (iLimit) {
			sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);
			VdbeCoverage(v);
		}
		sqlite3VdbeJumpHere(v, addrFirst);
		sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);
		sqlite3VdbeJumpHere(v, addrJmp);
	}
	if (pSort->sortFlags & SORTFLAG_UseSorter) {
		op = OP_SorterInsert;
	}
	else {
		op = OP_IdxInsert;
	}
	sqlite3VdbeAddOp2(v, op, pSort->iECursor, regRecord);
	if (iLimit) {
		int addr;
		int r1 = 0;
		
		addr = sqlite3VdbeAddOp3(v, OP_IfNotZero, iLimit, 0, 1); VdbeCoverage(v);
		sqlite3VdbeAddOp1(v, OP_Last, pSort->iECursor);
		if (pSort->bOrderedInnerLoop) {
			r1 = ++pParse->nMem;
			sqlite3VdbeAddOp3(v, OP_Column, pSort->iECursor, nExpr, r1);
			VdbeComment((v, "seq"));
		}
		sqlite3VdbeAddOp1(v, OP_Delete, pSort->iECursor);
		if (pSort->bOrderedInnerLoop) {
			
			int iBrk = sqlite3VdbeCurrentAddr(v) + 2;
			sqlite3VdbeAddOp3(v, OP_Eq, regBase + nExpr, iBrk, r1);
			sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
			VdbeCoverage(v);
		}
		sqlite3VdbeJumpHere(v, addr);
	}
}


static void codeOffset(
	Vdbe *v,          
	int iOffset,      
	int iContinue     
) {
	if (iOffset>0) {
		sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);
		VdbeComment((v, "OFFSET"));
	}
}


static void codeDistinct(
	Parse *pParse,     
	int iTab,          
	int addrRepeat,    
	int N,             
	int iMem           
) {
	Vdbe *v;
	int r1;

	v = pParse->pVdbe;
	r1 = sqlite3GetTempReg(pParse);
	sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, iMem, N); VdbeCoverage(v);
	sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1);
	sqlite3VdbeAddOp2(v, OP_IdxInsert, iTab, r1);
	sqlite3ReleaseTempReg(pParse, r1);
}


static void selectInnerLoop(
	Parse *pParse,          
	Select *p,              
	ExprList *pEList,       
	int srcTab,             
	SortCtx *pSort,         
	DistinctCtx *pDistinct, 
	SelectDest *pDest,      
	int iContinue,          
	int iBreak              
) {
	Vdbe *v = pParse->pVdbe;
	int i;
	int hasDistinct;        
	int regResult;              
	int eDest = pDest->eDest;   
	int iParm = pDest->iSDParm; 
	int nResultCol;             
	int nPrefixReg = 0;         

	assert(v);
	assert(pEList != 0);
	hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;
	if (pSort && pSort->pOrderBy == 0) pSort = 0;
	if (pSort == 0 && !hasDistinct) {
		assert(iContinue != 0);
		codeOffset(v, p->iOffset, iContinue);
	}

	
	nResultCol = pEList->nExpr;

	if (pDest->iSdst == 0) {
		if (pSort) {
			nPrefixReg = pSort->pOrderBy->nExpr;
			if (!(pSort->sortFlags & SORTFLAG_UseSorter)) nPrefixReg++;
			pParse->nMem += nPrefixReg;
		}
		pDest->iSdst = pParse->nMem + 1;
		pParse->nMem += nResultCol;
	}
	else if (pDest->iSdst + nResultCol > pParse->nMem) {
		
		pParse->nMem += nResultCol;
	}
	pDest->nSdst = nResultCol;
	regResult = pDest->iSdst;
	if (srcTab >= 0) {
		for (i = 0; i<nResultCol; i++) {
			sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult + i);
			VdbeComment((v, "%s", pEList->a[i].zName));
		}
	}
	else if (eDest != SRT_Exists) {
		
		u8 ecelFlags;
		if (eDest == SRT_Mem || eDest == SRT_Output || eDest == SRT_Coroutine) {
			ecelFlags = SQLITE_ECEL_DUP;
		}
		else {
			ecelFlags = 0;
		}
		sqlite3ExprCodeExprList(pParse, pEList, regResult, 0, ecelFlags);
	}

	
	if (hasDistinct) {
		switch (pDistinct->eTnctType) {
		case WHERE_DISTINCT_ORDERED: {
			VdbeOp *pOp;            
			int iJump;              
			int regPrev;            

									
			regPrev = pParse->nMem + 1;
			pParse->nMem += nResultCol;

			
			sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
			pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);
			pOp->opcode = OP_Null;
			pOp->p1 = 1;
			pOp->p2 = regPrev;

			iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;
			for (i = 0; i<nResultCol; i++) {
				CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);
				if (i<nResultCol - 1) {
					sqlite3VdbeAddOp3(v, OP_Ne, regResult + i, iJump, regPrev + i);
					VdbeCoverage(v);
				}
				else {
					sqlite3VdbeAddOp3(v, OP_Eq, regResult + i, iContinue, regPrev + i);
					VdbeCoverage(v);
				}
				sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);
				sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
			}
			assert(sqlite3VdbeCurrentAddr(v) == iJump || pParse->db->mallocFailed);
			sqlite3VdbeAddOp3(v, OP_Copy, regResult, regPrev, nResultCol - 1);
			break;
		}

		case WHERE_DISTINCT_UNIQUE: {
			sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
			break;
		}

		default: {
			assert(pDistinct->eTnctType == WHERE_DISTINCT_UNORDERED);
			codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol,
				regResult);
			break;
		}
		}
		if (pSort == 0) {
			codeOffset(v, p->iOffset, iContinue);
		}
	}

	switch (eDest) {
		
#ifndef SQLITE_OMIT_COMPOUND_SELECT
	case SRT_Union: {
		int r1;
		r1 = sqlite3GetTempReg(pParse);
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);
		sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1);
		sqlite3ReleaseTempReg(pParse, r1);
		break;
	}

					
	case SRT_Except: {
		sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);
		break;
	}
#endif 

					 
	case SRT_Fifo:
	case SRT_DistFifo:
	case SRT_Table:
	case SRT_EphemTab: {
		int r1 = sqlite3GetTempRange(pParse, nPrefixReg + 1);
		testcase(eDest == SRT_Table);
		testcase(eDest == SRT_EphemTab);
		testcase(eDest == SRT_Fifo);
		testcase(eDest == SRT_DistFifo);
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1 + nPrefixReg);
#ifndef SQLITE_OMIT_CTE
		if (eDest == SRT_DistFifo) {
			
			int addr = sqlite3VdbeCurrentAddr(v) + 4;
			sqlite3VdbeAddOp4Int(v, OP_Found, iParm + 1, addr, r1, 0);
			VdbeCoverage(v);
			sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm + 1, r1);
			assert(pSort == 0);
		}
#endif
		if (pSort) {
			pushOntoSorter(pParse, pSort, p, r1 + nPrefixReg, regResult, 1, nPrefixReg);
		}
		else {
			int r2 = sqlite3GetTempReg(pParse);
			sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);
			sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);
			sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
			sqlite3ReleaseTempReg(pParse, r2);
		}
		sqlite3ReleaseTempRange(pParse, r1, nPrefixReg + 1);
		break;
	}

#ifndef SQLITE_OMIT_SUBQUERY
					   
	case SRT_Set: {
		if (pSort) {
			
			pushOntoSorter(
				pParse, pSort, p, regResult, regResult, nResultCol, nPrefixReg);
		}
		else {
			int r1 = sqlite3GetTempReg(pParse);
			assert(sqlite3Strlen30(pDest->zAffSdst) == nResultCol);
			sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol,
				r1, pDest->zAffSdst, nResultCol);
			sqlite3ExprCacheAffinityChange(pParse, regResult, nResultCol);
			sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1);
			sqlite3ReleaseTempReg(pParse, r1);
		}
		break;
	}

				  
	case SRT_Exists: {
		sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);
		
		break;
	}

					 
	case SRT_Mem: {
		assert(nResultCol == pDest->nSdst);
		if (pSort) {
			pushOntoSorter(
				pParse, pSort, p, regResult, regResult, nResultCol, nPrefixReg);
		}
		else {
			assert(regResult == iParm);
			
		}
		break;
	}
#endif 

	case SRT_Coroutine:       
	case SRT_Output: {        
		testcase(eDest == SRT_Coroutine);
		testcase(eDest == SRT_Output);
		if (pSort) {
			pushOntoSorter(pParse, pSort, p, regResult, regResult, nResultCol,
				nPrefixReg);
		}
		else if (eDest == SRT_Coroutine) {
			sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
		}
		else {
			sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);
			sqlite3ExprCacheAffinityChange(pParse, regResult, nResultCol);
		}
		break;
	}

#ifndef SQLITE_OMIT_CTE
					 
	case SRT_DistQueue:
	case SRT_Queue: {
		int nKey;
		int r1, r2, r3;
		int addrTest = 0;
		ExprList *pSO;
		pSO = pDest->pOrderBy;
		assert(pSO);
		nKey = pSO->nExpr;
		r1 = sqlite3GetTempReg(pParse);
		r2 = sqlite3GetTempRange(pParse, nKey + 2);
		r3 = r2 + nKey + 1;
		if (eDest == SRT_DistQueue) {
			
			addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm + 1, 0,
				regResult, nResultCol);
			VdbeCoverage(v);
		}
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);
		if (eDest == SRT_DistQueue) {
			sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm + 1, r3);
			sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
		}
		for (i = 0; i<nKey; i++) {
			sqlite3VdbeAddOp2(v, OP_SCopy,
				regResult + pSO->a[i].u.x.iOrderByCol - 1,
				r2 + i);
		}
		sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2 + nKey);
		sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey + 2, r1);
		sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1);
		if (addrTest) sqlite3VdbeJumpHere(v, addrTest);
		sqlite3ReleaseTempReg(pParse, r1);
		sqlite3ReleaseTempRange(pParse, r2, nKey + 2);
		break;
	}
#endif 



#if !defined(SQLITE_OMIT_TRIGGER)
					
	default: {
		assert(eDest == SRT_Discard);
		break;
	}
#endif
	}

	
	if (pSort == 0 && p->iLimit) {
		sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
	}
}


SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X) {
	int nExtra = (N + X)*(sizeof(CollSeq*) + 1);
	KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);
	if (p) {
		p->aSortOrder = (u8*)&p->aColl[N + X];
		p->nField = (u16)N;
		p->nXField = (u16)X;
		p->enc = ENC(db);
		p->db = db;
		p->nRef = 1;
		memset(&p[1], 0, nExtra);
	}
	else {
		sqlite3OomFault(db);
	}
	return p;
}


SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo *p) {
	if (p) {
		assert(p->nRef>0);
		p->nRef--;
		if (p->nRef == 0) sqlite3DbFree(p->db, p);
	}
}


SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo *p) {
	if (p) {
		assert(p->nRef>0);
		p->nRef++;
	}
	return p;
}

#ifdef SQLITE_DEBUG

SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo *p) { return p->nRef == 1; }
#endif 


static KeyInfo *keyInfoFromExprList(
	Parse *pParse,       
	ExprList *pList,     
	int iStart,          
	int nExtra           
) {
	int nExpr;
	KeyInfo *pInfo;
	struct ExprList_item *pItem;
	sqlite3 *db = pParse->db;
	int i;

	nExpr = pList->nExpr;
	pInfo = sqlite3KeyInfoAlloc(db, nExpr - iStart, nExtra + 1);
	if (pInfo) {
		assert(sqlite3KeyInfoIsWriteable(pInfo));
		for (i = iStart, pItem = pList->a + iStart; i<nExpr; i++, pItem++) {
			CollSeq *pColl;
			pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
			if (!pColl) pColl = db->pDfltColl;
			pInfo->aColl[i - iStart] = pColl;
			pInfo->aSortOrder[i - iStart] = pItem->sortOrder;
		}
	}
	return pInfo;
}


static const char *selectOpName(int id) {
	char *z;
	switch (id) {
	case TK_ALL:       z = "UNION ALL";   break;
	case TK_INTERSECT: z = "INTERSECT";   break;
	case TK_EXCEPT:    z = "EXCEPT";      break;
	default:           z = "UNION";       break;
	}
	return z;
}

#ifndef SQLITE_OMIT_EXPLAIN

static void explainTempTable(Parse *pParse, const char *zUsage) {
	if (pParse->explain == 2) {
		Vdbe *v = pParse->pVdbe;
		char *zMsg = sqlite3MPrintf(pParse->db, "USE TEMP B-TREE FOR %s", zUsage);
		sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);
	}
}


# define explainSetInteger(a, b) a = b

#else

# define explainTempTable(y,z)
# define explainSetInteger(y,z)
#endif

#if !defined(SQLITE_OMIT_EXPLAIN) && !defined(SQLITE_OMIT_COMPOUND_SELECT)

static void explainComposite(
	Parse *pParse,                  
	int op,                         
	int iSub1,                      
	int iSub2,                      
	int bUseTmp                     
) {
	assert(op == TK_UNION || op == TK_EXCEPT || op == TK_INTERSECT || op == TK_ALL);
	if (pParse->explain == 2) {
		Vdbe *v = pParse->pVdbe;
		char *zMsg = sqlite3MPrintf(
			pParse->db, "COMPOUND SUBQUERIES %d AND %d %s(%s)", iSub1, iSub2,
			bUseTmp ? "USING TEMP B-TREE " : "", selectOpName(op)
		);
		sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);
	}
}
#else

# define explainComposite(v,w,x,y,z)
#endif


static void generateSortTail(
	Parse *pParse,    
	Select *p,        
	SortCtx *pSort,   
	int nColumn,      
	SelectDest *pDest 
) {
	Vdbe *v = pParse->pVdbe;                     
	int addrBreak = pSort->labelDone;            
	int addrContinue = sqlite3VdbeMakeLabel(v);  
	int addr;
	int addrOnce = 0;
	int iTab;
	ExprList *pOrderBy = pSort->pOrderBy;
	int eDest = pDest->eDest;
	int iParm = pDest->iSDParm;
	int regRow;
	int regRowid;
	int nKey;
	int iSortTab;                   
	int nSortData;                  
	int i;
	int bSeq;                       
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
	struct ExprList_item *aOutEx = p->pEList->a;
#endif

	assert(addrBreak<0);
	if (pSort->labelBkOut) {
		sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);
		sqlite3VdbeGoto(v, addrBreak);
		sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
	}
	iTab = pSort->iECursor;
	if (eDest == SRT_Output || eDest == SRT_Coroutine || eDest == SRT_Mem) {
		regRowid = 0;
		regRow = pDest->iSdst;
		nSortData = nColumn;
	}
	else {
		regRowid = sqlite3GetTempReg(pParse);
		regRow = sqlite3GetTempRange(pParse, nColumn);
		nSortData = nColumn;
	}
	nKey = pOrderBy->nExpr - pSort->nOBSat;
	if (pSort->sortFlags & SORTFLAG_UseSorter) {
		int regSortOut = ++pParse->nMem;
		iSortTab = pParse->nTab++;
		if (pSort->labelBkOut) {
			addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
		}
		sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut, nKey + 1 + nSortData);
		if (addrOnce) sqlite3VdbeJumpHere(v, addrOnce);
		addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);
		VdbeCoverage(v);
		codeOffset(v, p->iOffset, addrContinue);
		sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);
		bSeq = 0;
	}
	else {
		addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);
		codeOffset(v, p->iOffset, addrContinue);
		iSortTab = iTab;
		bSeq = 1;
	}
	for (i = 0; i<nSortData; i++) {
		sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey + bSeq + i, regRow + i);
		VdbeComment((v, "%s", aOutEx[i].zName ? aOutEx[i].zName : aOutEx[i].zSpan));
	}
	switch (eDest) {
	case SRT_EphemTab: {
		sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);
		sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);
		sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
		break;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case SRT_Set: {
		assert(nColumn == sqlite3Strlen30(pDest->zAffSdst));
		sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,
			pDest->zAffSdst, nColumn);
		sqlite3ExprCacheAffinityChange(pParse, regRow, nColumn);
		sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, regRowid);
		break;
	}
	case SRT_Mem: {
		
		break;
	}
#endif
	default: {
		assert(eDest == SRT_Output || eDest == SRT_Coroutine);
		testcase(eDest == SRT_Output);
		testcase(eDest == SRT_Coroutine);
		if (eDest == SRT_Output) {
			sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);
			sqlite3ExprCacheAffinityChange(pParse, pDest->iSdst, nColumn);
		}
		else {
			sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
		}
		break;
	}
	}
	if (regRowid) {
		if (eDest == SRT_Set) {
			sqlite3ReleaseTempRange(pParse, regRow, nColumn);
		}
		else {
			sqlite3ReleaseTempReg(pParse, regRow);
		}
		sqlite3ReleaseTempReg(pParse, regRowid);
	}
	
	sqlite3VdbeResolveLabel(v, addrContinue);
	if (pSort->sortFlags & SORTFLAG_UseSorter) {
		sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);
	}
	else {
		sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);
	}
	if (pSort->regReturn) sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);
	sqlite3VdbeResolveLabel(v, addrBreak);
}


#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define columnType(A,B,C,D,E,F) columnTypeImpl(A,B,C,D,E,F)
#else 
# define columnType(A,B,C,D,E,F) columnTypeImpl(A,B,F)
#endif
static const char *columnTypeImpl(
	NameContext *pNC,
	Expr *pExpr,
#ifdef SQLITE_ENABLE_COLUMN_METADATA
	const char **pzOrigDb,
	const char **pzOrigTab,
	const char **pzOrigCol,
#endif
	u8 *pEstWidth
) {
	char const *zType = 0;
	int j;
	u8 estWidth = 1;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
	char const *zOrigDb = 0;
	char const *zOrigTab = 0;
	char const *zOrigCol = 0;
#endif

	assert(pExpr != 0);
	assert(pNC->pSrcList != 0);
	switch (pExpr->op) {
	case TK_AGG_COLUMN:
	case TK_COLUMN: {
		
		Table *pTab = 0;            
		Select *pS = 0;             
		int iCol = pExpr->iColumn;  
		testcase(pExpr->op == TK_AGG_COLUMN);
		testcase(pExpr->op == TK_COLUMN);
		while (pNC && !pTab) {
			SrcList *pTabList = pNC->pSrcList;
			for (j = 0; j<pTabList->nSrc && pTabList->a[j].iCursor != pExpr->iTable; j++);
			if (j<pTabList->nSrc) {
				pTab = pTabList->a[j].pTab;
				pS = pTabList->a[j].pSelect;
			}
			else {
				pNC = pNC->pNext;
			}
		}

		if (pTab == 0) {
			
			break;
		}

		assert(pTab && pExpr->pTab == pTab);
		if (pS) {
			
			if (iCol >= 0 && ALWAYS(iCol<pS->pEList->nExpr)) {
				
				NameContext sNC;
				Expr *p = pS->pEList->a[iCol].pExpr;
				sNC.pSrcList = pS->pSrc;
				sNC.pNext = pNC;
				sNC.pParse = pNC->pParse;
				zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol, &estWidth);
			}
		}
		else if (pTab->pSchema) {
			
			assert(!pS);
			if (iCol<0) iCol = pTab->iPKey;
			assert(iCol == -1 || (iCol >= 0 && iCol<pTab->nCol));
#ifdef SQLITE_ENABLE_COLUMN_METADATA
			if (iCol<0) {
				zType = "INTEGER";
				zOrigCol = "rowid";
			}
			else {
				zOrigCol = pTab->aCol[iCol].zName;
				zType = sqlite3ColumnType(&pTab->aCol[iCol], 0);
				estWidth = pTab->aCol[iCol].szEst;
			}
			zOrigTab = pTab->zName;
			if (pNC->pParse) {
				int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);
				zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;
			}
#else
			if (iCol<0) {
				zType = "INTEGER";
			}
			else {
				zType = sqlite3ColumnType(&pTab->aCol[iCol], 0);
				estWidth = pTab->aCol[iCol].szEst;
			}
#endif
		}
		break;
	}
#ifndef SQLITE_OMIT_SUBQUERY
	case TK_SELECT: {
		
		NameContext sNC;
		Select *pS = pExpr->x.pSelect;
		Expr *p = pS->pEList->a[0].pExpr;
		assert(ExprHasProperty(pExpr, EP_xIsSelect));
		sNC.pSrcList = pS->pSrc;
		sNC.pNext = pNC;
		sNC.pParse = pNC->pParse;
		zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol, &estWidth);
		break;
	}
#endif
	}

#ifdef SQLITE_ENABLE_COLUMN_METADATA  
	if (pzOrigDb) {
		assert(pzOrigTab && pzOrigCol);
		*pzOrigDb = zOrigDb;
		*pzOrigTab = zOrigTab;
		*pzOrigCol = zOrigCol;
	}
#endif
	if (pEstWidth) *pEstWidth = estWidth;
	return zType;
}


static void generateColumnTypes(
	Parse *pParse,      
	SrcList *pTabList,  
	ExprList *pEList    
) {
#ifndef SQLITE_OMIT_DECLTYPE
	Vdbe *v = pParse->pVdbe;
	int i;
	NameContext sNC;
	sNC.pSrcList = pTabList;
	sNC.pParse = pParse;
	for (i = 0; i<pEList->nExpr; i++) {
		Expr *p = pEList->a[i].pExpr;
		const char *zType;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
		const char *zOrigDb = 0;
		const char *zOrigTab = 0;
		const char *zOrigCol = 0;
		zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol, 0);

		
		sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);
		sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);
		sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);
#else
		zType = columnType(&sNC, p, 0, 0, 0, 0);
#endif
		sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);
	}
#endif 
}


static void generateColumnNames(
	Parse *pParse,      
	SrcList *pTabList,  
	ExprList *pEList    
) {
	Vdbe *v = pParse->pVdbe;
	int i, j;
	sqlite3 *db = pParse->db;
	int fullNames, shortNames;

#ifndef SQLITE_OMIT_EXPLAIN
	
	if (pParse->explain) {
		return;
	}
#endif

	if (pParse->colNamesSet || db->mallocFailed) return;
	assert(v != 0);
	assert(pTabList != 0);
	pParse->colNamesSet = 1;
	fullNames = (db->flags & SQLITE_FullColNames) != 0;
	shortNames = (db->flags & SQLITE_ShortColNames) != 0;
	sqlite3VdbeSetNumCols(v, pEList->nExpr);
	for (i = 0; i<pEList->nExpr; i++) {
		Expr *p;
		p = pEList->a[i].pExpr;
		if (NEVER(p == 0)) continue;
		if (pEList->a[i].zName) {
			char *zName = pEList->a[i].zName;
			sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);
		}
		else if (p->op == TK_COLUMN || p->op == TK_AGG_COLUMN) {
			Table *pTab;
			char *zCol;
			int iCol = p->iColumn;
			for (j = 0; ALWAYS(j<pTabList->nSrc); j++) {
				if (pTabList->a[j].iCursor == p->iTable) break;
			}
			assert(j<pTabList->nSrc);
			pTab = pTabList->a[j].pTab;
			if (iCol<0) iCol = pTab->iPKey;
			assert(iCol == -1 || (iCol >= 0 && iCol<pTab->nCol));
			if (iCol<0) {
				zCol = "rowid";
			}
			else {
				zCol = pTab->aCol[iCol].zName;
			}
			if (!shortNames && !fullNames) {
				sqlite3VdbeSetColName(v, i, COLNAME_NAME,
					sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);
			}
			else if (fullNames) {
				char *zName = 0;
				zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
				sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
			}
			else {
				sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
			}
		}
		else {
			const char *z = pEList->a[i].zSpan;
			z = z == 0 ? sqlite3MPrintf(db, "column%d", i + 1) : sqlite3DbStrDup(db, z);
			sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);
		}
	}
	generateColumnTypes(pParse, pTabList, pEList);
}


SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
	Parse *pParse,          
	ExprList *pEList,       
	i16 *pnCol,             
	Column **paCol          
) {
	sqlite3 *db = pParse->db;   
	int i, j;                   
	u32 cnt;                    
	Column *aCol, *pCol;        
	int nCol;                   
	Expr *p;                    
	char *zName;                
	int nName;                  
	Hash ht;                    

	sqlite3HashInit(&ht);
	if (pEList) {
		nCol = pEList->nExpr;
		aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);
		testcase(aCol == 0);
	}
	else {
		nCol = 0;
		aCol = 0;
	}
	assert(nCol == (i16)nCol);
	*pnCol = nCol;
	*paCol = aCol;

	for (i = 0, pCol = aCol; i<nCol && !db->mallocFailed; i++, pCol++) {
		
		p = sqlite3ExprSkipCollate(pEList->a[i].pExpr);
		if ((zName = pEList->a[i].zName) != 0) {
			
		}
		else {
			Expr *pColExpr = p;  
			Table *pTab;         
			while (pColExpr->op == TK_DOT) {
				pColExpr = pColExpr->pRight;
				assert(pColExpr != 0);
			}
			if (pColExpr->op == TK_COLUMN && ALWAYS(pColExpr->pTab != 0)) {
				
				int iCol = pColExpr->iColumn;
				pTab = pColExpr->pTab;
				if (iCol<0) iCol = pTab->iPKey;
				zName = iCol >= 0 ? pTab->aCol[iCol].zName : "rowid";
			}
			else if (pColExpr->op == TK_ID) {
				assert(!ExprHasProperty(pColExpr, EP_IntValue));
				zName = pColExpr->u.zToken;
			}
			else {
				
				zName = pEList->a[i].zSpan;
			}
		}
		zName = sqlite3MPrintf(db, "%s", zName);

		
		cnt = 0;
		while (zName && sqlite3HashFind(&ht, zName) != 0) {
			nName = sqlite3Strlen30(zName);
			if (nName>0) {
				for (j = nName - 1; j>0 && sqlite3Isdigit(zName[j]); j--) {}
				if (zName[j] == ':') nName = j;
			}
			zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, ++cnt);
			if (cnt>3) sqlite3_randomness(sizeof(cnt), &cnt);
		}
		pCol->zName = zName;
		sqlite3ColumnPropertiesFromName(0, pCol);
		if (zName && sqlite3HashInsert(&ht, zName, pCol) == pCol) {
			sqlite3OomFault(db);
		}
	}
	sqlite3HashClear(&ht);
	if (db->mallocFailed) {
		for (j = 0; j<i; j++) {
			sqlite3DbFree(db, aCol[j].zName);
		}
		sqlite3DbFree(db, aCol);
		*paCol = 0;
		*pnCol = 0;
		return SQLITE_NOMEM_BKPT;
	}
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(
	Parse *pParse,        
	Table *pTab,          
	Select *pSelect       
) {
	sqlite3 *db = pParse->db;
	NameContext sNC;
	Column *pCol;
	CollSeq *pColl;
	int i;
	Expr *p;
	struct ExprList_item *a;
	u64 szAll = 0;

	assert(pSelect != 0);
	assert((pSelect->selFlags & SF_Resolved) != 0);
	assert(pTab->nCol == pSelect->pEList->nExpr || db->mallocFailed);
	if (db->mallocFailed) return;
	memset(&sNC, 0, sizeof(sNC));
	sNC.pSrcList = pSelect->pSrc;
	a = pSelect->pEList->a;
	for (i = 0, pCol = pTab->aCol; i<pTab->nCol; i++, pCol++) {
		const char *zType;
		int n, m;
		p = a[i].pExpr;
		zType = columnType(&sNC, p, 0, 0, 0, &pCol->szEst);
		szAll += pCol->szEst;
		pCol->affinity = sqlite3ExprAffinity(p);
		if (zType && (m = sqlite3Strlen30(zType))>0) {
			n = sqlite3Strlen30(pCol->zName);
			pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n + m + 2);
			if (pCol->zName) {
				memcpy(&pCol->zName[n + 1], zType, m + 1);
				pCol->colFlags |= COLFLAG_HASTYPE;
			}
		}
		if (pCol->affinity == 0) pCol->affinity = SQLITE_AFF_BLOB;
		pColl = sqlite3ExprCollSeq(pParse, p);
		if (pColl && pCol->zColl == 0) {
			pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
		}
	}
	pTab->szTabRow = sqlite3LogEst(szAll * 4);
}


SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect) {
	Table *pTab;
	sqlite3 *db = pParse->db;
	int savedFlags;

	savedFlags = db->flags;
	db->flags &= ~SQLITE_FullColNames;
	db->flags |= SQLITE_ShortColNames;
	sqlite3SelectPrep(pParse, pSelect, 0);
	if (pParse->nErr) return 0;
	while (pSelect->pPrior) pSelect = pSelect->pPrior;
	db->flags = savedFlags;
	pTab = sqlite3DbMallocZero(db, sizeof(Table));
	if (pTab == 0) {
		return 0;
	}
	
	assert(db->lookaside.bDisable);
	pTab->nRef = 1;
	pTab->zName = 0;
	pTab->nRowLogEst = 200; assert(200 == sqlite3LogEst(1048576));
	sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
	sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect);
	pTab->iPKey = -1;
	if (db->mallocFailed) {
		sqlite3DeleteTable(db, pTab);
		return 0;
	}
	return pTab;
}


static SQLITE_NOINLINE Vdbe *allocVdbe(Parse *pParse) {
	Vdbe *v = pParse->pVdbe = sqlite3VdbeCreate(pParse);
	if (v) sqlite3VdbeAddOp2(v, OP_Init, 0, 1);
	if (pParse->pToplevel == 0
		&& OptimizationEnabled(pParse->db, SQLITE_FactorOutConst)
		) {
		pParse->okConstFactor = 1;
	}
	return v;
}
SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse *pParse) {
	Vdbe *v = pParse->pVdbe;
	return v ? v : allocVdbe(pParse);
}



static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak) {
	Vdbe *v = 0;
	int iLimit = 0;
	int iOffset;
	int n;
	if (p->iLimit) return;

	
	sqlite3ExprCacheClear(pParse);
	assert(p->pOffset == 0 || p->pLimit != 0);
	if (p->pLimit) {
		p->iLimit = iLimit = ++pParse->nMem;
		v = sqlite3GetVdbe(pParse);
		assert(v != 0);
		if (sqlite3ExprIsInteger(p->pLimit, &n)) {
			sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);
			VdbeComment((v, "LIMIT counter"));
			if (n == 0) {
				sqlite3VdbeGoto(v, iBreak);
			}
			else if (n >= 0 && p->nSelectRow>sqlite3LogEst((u64)n)) {
				p->nSelectRow = sqlite3LogEst((u64)n);
				p->selFlags |= SF_FixedLimit;
			}
		}
		else {
			sqlite3ExprCode(pParse, p->pLimit, iLimit);
			sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);
			VdbeComment((v, "LIMIT counter"));
			sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);
		}
		if (p->pOffset) {
			p->iOffset = iOffset = ++pParse->nMem;
			pParse->nMem++;   
			sqlite3ExprCode(pParse, p->pOffset, iOffset);
			sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);
			VdbeComment((v, "OFFSET counter"));
			sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset + 1, iOffset);
			VdbeComment((v, "LIMIT+OFFSET"));
		}
	}
}

#ifndef SQLITE_OMIT_COMPOUND_SELECT

static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol) {
	CollSeq *pRet;
	if (p->pPrior) {
		pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
	}
	else {
		pRet = 0;
	}
	assert(iCol >= 0);
	
	if (pRet == 0 && ALWAYS(iCol<p->pEList->nExpr)) {
		pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);
	}
	return pRet;
}


static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra) {
	ExprList *pOrderBy = p->pOrderBy;
	int nOrderBy = p->pOrderBy->nExpr;
	sqlite3 *db = pParse->db;
	KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy + nExtra, 1);
	if (pRet) {
		int i;
		for (i = 0; i<nOrderBy; i++) {
			struct ExprList_item *pItem = &pOrderBy->a[i];
			Expr *pTerm = pItem->pExpr;
			CollSeq *pColl;

			if (pTerm->flags & EP_Collate) {
				pColl = sqlite3ExprCollSeq(pParse, pTerm);
			}
			else {
				pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol - 1);
				if (pColl == 0) pColl = db->pDfltColl;
				pOrderBy->a[i].pExpr =
					sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);
			}
			assert(sqlite3KeyInfoIsWriteable(pRet));
			pRet->aColl[i] = pColl;
			pRet->aSortOrder[i] = pOrderBy->a[i].sortOrder;
		}
	}

	return pRet;
}

#ifndef SQLITE_OMIT_CTE

static void generateWithRecursiveQuery(
	Parse *pParse,        
	Select *p,            
	SelectDest *pDest     
) {
	SrcList *pSrc = p->pSrc;      
	int nCol = p->pEList->nExpr;  
	Vdbe *v = pParse->pVdbe;      
	Select *pSetup = p->pPrior;   
	int addrTop;                  
	int addrCont, addrBreak;      
	int iCurrent = 0;             
	int regCurrent;               
	int iQueue;                   
	int iDistinct = 0;            
	int eDest = SRT_Fifo;         
	SelectDest destQueue;         
	int i;                        
	int rc;                       
	ExprList *pOrderBy;           
	Expr *pLimit, *pOffset;       
	int regLimit, regOffset;      

								  
	if (sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0)) return;

	
	addrBreak = sqlite3VdbeMakeLabel(v);
	computeLimitRegisters(pParse, p, addrBreak);
	pLimit = p->pLimit;
	pOffset = p->pOffset;
	regLimit = p->iLimit;
	regOffset = p->iOffset;
	p->pLimit = p->pOffset = 0;
	p->iLimit = p->iOffset = 0;
	pOrderBy = p->pOrderBy;

	
	for (i = 0; ALWAYS(i<pSrc->nSrc); i++) {
		if (pSrc->a[i].fg.isRecursive) {
			iCurrent = pSrc->a[i].iCursor;
			break;
		}
	}

	
	iQueue = pParse->nTab++;
	if (p->op == TK_UNION) {
		eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;
		iDistinct = pParse->nTab++;
	}
	else {
		eDest = pOrderBy ? SRT_Queue : SRT_Fifo;
	}
	sqlite3SelectDestInit(&destQueue, eDest, iQueue);

	
	regCurrent = ++pParse->nMem;
	sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);
	if (pOrderBy) {
		KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);
		sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr + 2, 0,
			(char*)pKeyInfo, P4_KEYINFO);
		destQueue.pOrderBy = pOrderBy;
	}
	else {
		sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);
	}
	VdbeComment((v, "Queue table"));
	if (iDistinct) {
		p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);
		p->selFlags |= SF_UsesEphemeral;
	}

	
	p->pOrderBy = 0;

	
	pSetup->pNext = 0;
	rc = sqlite3Select(pParse, pSetup, &destQueue);
	pSetup->pNext = p;
	if (rc) goto end_of_recursive_query;

	
	addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);

	
	sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); 
	if (pOrderBy) {
		sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr + 1, regCurrent);
	}
	else {
		sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);
	}
	sqlite3VdbeAddOp1(v, OP_Delete, iQueue);

	
	addrCont = sqlite3VdbeMakeLabel(v);
	codeOffset(v, regOffset, addrCont);
	selectInnerLoop(pParse, p, p->pEList, iCurrent,
		0, 0, pDest, addrCont, addrBreak);
	if (regLimit) {
		sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);
		VdbeCoverage(v);
	}
	sqlite3VdbeResolveLabel(v, addrCont);

	
	if (p->selFlags & SF_Aggregate) {
		sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
	}
	else {
		p->pPrior = 0;
		sqlite3Select(pParse, p, &destQueue);
		assert(p->pPrior == 0);
		p->pPrior = pSetup;
	}

	
	sqlite3VdbeGoto(v, addrTop);
	sqlite3VdbeResolveLabel(v, addrBreak);

end_of_recursive_query:
	sqlite3ExprListDelete(pParse->db, p->pOrderBy);
	p->pOrderBy = pOrderBy;
	p->pLimit = pLimit;
	p->pOffset = pOffset;
	return;
}
#endif 


static int multiSelectOrderBy(
	Parse *pParse,        
	Select *p,            
	SelectDest *pDest     
);


static int multiSelectValues(
	Parse *pParse,        
	Select *p,            
	SelectDest *pDest     
) {
	Select *pPrior;
	int nRow = 1;
	int rc = 0;
	assert(p->selFlags & SF_MultiValue);
	do {
		assert(p->selFlags & SF_Values);
		assert(p->op == TK_ALL || (p->op == TK_SELECT && p->pPrior == 0));
		assert(p->pLimit == 0);
		assert(p->pOffset == 0);
		assert(p->pNext == 0 || p->pEList->nExpr == p->pNext->pEList->nExpr);
		if (p->pPrior == 0) break;
		assert(p->pPrior->pNext == p);
		p = p->pPrior;
		nRow++;
	} while (1);
	while (p) {
		pPrior = p->pPrior;
		p->pPrior = 0;
		rc = sqlite3Select(pParse, p, pDest);
		p->pPrior = pPrior;
		if (rc) break;
		p->nSelectRow = nRow;
		p = p->pNext;
	}
	return rc;
}


static int multiSelect(
	Parse *pParse,        
	Select *p,            
	SelectDest *pDest     
) {
	int rc = SQLITE_OK;   
	Select *pPrior;       
	Vdbe *v;              
	SelectDest dest;      
	Select *pDelete = 0;  
	sqlite3 *db;          
#ifndef SQLITE_OMIT_EXPLAIN
	int iSub1 = 0;        
	int iSub2 = 0;        
#endif

						  
	assert(p && p->pPrior);  
	assert((p->selFlags & SF_Recursive) == 0 || p->op == TK_ALL || p->op == TK_UNION);
	db = pParse->db;
	pPrior = p->pPrior;
	dest = *pDest;
	if (pPrior->pOrderBy) {
		sqlite3ErrorMsg(pParse, "ORDER BY clause should come after %s not before",
			selectOpName(p->op));
		rc = 1;
		goto multi_select_end;
	}
	if (pPrior->pLimit) {
		sqlite3ErrorMsg(pParse, "LIMIT clause should come after %s not before",
			selectOpName(p->op));
		rc = 1;
		goto multi_select_end;
	}

	v = sqlite3GetVdbe(pParse);
	assert(v != 0);  

					 
	if (dest.eDest == SRT_EphemTab) {
		assert(p->pEList);
		sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);
		dest.eDest = SRT_Table;
	}

	
	if (p->selFlags & SF_MultiValue) {
		rc = multiSelectValues(pParse, p, &dest);
		goto multi_select_end;
	}

	
	assert(p->pEList && pPrior->pEList);
	assert(p->pEList->nExpr == pPrior->pEList->nExpr);

#ifndef SQLITE_OMIT_CTE
	if (p->selFlags & SF_Recursive) {
		generateWithRecursiveQuery(pParse, p, &dest);
	}
	else
#endif

		
		if (p->pOrderBy) {
			return multiSelectOrderBy(pParse, p, pDest);
		}
		else

			
			switch (p->op) {
			case TK_ALL: {
				int addr = 0;
				int nLimit;
				assert(!pPrior->pLimit);
				pPrior->iLimit = p->iLimit;
				pPrior->iOffset = p->iOffset;
				pPrior->pLimit = p->pLimit;
				pPrior->pOffset = p->pOffset;
				explainSetInteger(iSub1, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, pPrior, &dest);
				p->pLimit = 0;
				p->pOffset = 0;
				if (rc) {
					goto multi_select_end;
				}
				p->pPrior = 0;
				p->iLimit = pPrior->iLimit;
				p->iOffset = pPrior->iOffset;
				if (p->iLimit) {
					addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);
					VdbeComment((v, "Jump ahead if LIMIT reached"));
					if (p->iOffset) {
						sqlite3VdbeAddOp3(v, OP_OffsetLimit,
							p->iLimit, p->iOffset + 1, p->iOffset);
					}
				}
				explainSetInteger(iSub2, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, p, &dest);
				testcase(rc != SQLITE_OK);
				pDelete = p->pPrior;
				p->pPrior = pPrior;
				p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
				if (pPrior->pLimit
					&& sqlite3ExprIsInteger(pPrior->pLimit, &nLimit)
					&& nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)
					) {
					p->nSelectRow = sqlite3LogEst((u64)nLimit);
				}
				if (addr) {
					sqlite3VdbeJumpHere(v, addr);
				}
				break;
			}
			case TK_EXCEPT:
			case TK_UNION: {
				int unionTab;    
				u8 op = 0;       
				int priorOp;     
				Expr *pLimit, *pOffset; 
				int addr;
				SelectDest uniondest;

				testcase(p->op == TK_EXCEPT);
				testcase(p->op == TK_UNION);
				priorOp = SRT_Union;
				if (dest.eDest == priorOp) {
					
					assert(p->pLimit == 0);      
					assert(p->pOffset == 0);     
					unionTab = dest.iSDParm;
				}
				else {
					
					unionTab = pParse->nTab++;
					assert(p->pOrderBy == 0);
					addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);
					assert(p->addrOpenEphm[0] == -1);
					p->addrOpenEphm[0] = addr;
					findRightmost(p)->selFlags |= SF_UsesEphemeral;
					assert(p->pEList);
				}

				
				assert(!pPrior->pOrderBy);
				sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
				explainSetInteger(iSub1, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, pPrior, &uniondest);
				if (rc) {
					goto multi_select_end;
				}

				
				if (p->op == TK_EXCEPT) {
					op = SRT_Except;
				}
				else {
					assert(p->op == TK_UNION);
					op = SRT_Union;
				}
				p->pPrior = 0;
				pLimit = p->pLimit;
				p->pLimit = 0;
				pOffset = p->pOffset;
				p->pOffset = 0;
				uniondest.eDest = op;
				explainSetInteger(iSub2, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, p, &uniondest);
				testcase(rc != SQLITE_OK);
				
				sqlite3ExprListDelete(db, p->pOrderBy);
				pDelete = p->pPrior;
				p->pPrior = pPrior;
				p->pOrderBy = 0;
				if (p->op == TK_UNION) {
					p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
				}
				sqlite3ExprDelete(db, p->pLimit);
				p->pLimit = pLimit;
				p->pOffset = pOffset;
				p->iLimit = 0;
				p->iOffset = 0;

				
				assert(unionTab == dest.iSDParm || dest.eDest != priorOp);
				if (dest.eDest != priorOp) {
					int iCont, iBreak, iStart;
					assert(p->pEList);
					if (dest.eDest == SRT_Output) {
						Select *pFirst = p;
						while (pFirst->pPrior) pFirst = pFirst->pPrior;
						generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
					}
					iBreak = sqlite3VdbeMakeLabel(v);
					iCont = sqlite3VdbeMakeLabel(v);
					computeLimitRegisters(pParse, p, iBreak);
					sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);
					iStart = sqlite3VdbeCurrentAddr(v);
					selectInnerLoop(pParse, p, p->pEList, unionTab,
						0, 0, &dest, iCont, iBreak);
					sqlite3VdbeResolveLabel(v, iCont);
					sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);
					sqlite3VdbeResolveLabel(v, iBreak);
					sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);
				}
				break;
			}
			default: assert(p->op == TK_INTERSECT); {
				int tab1, tab2;
				int iCont, iBreak, iStart;
				Expr *pLimit, *pOffset;
				int addr;
				SelectDest intersectdest;
				int r1;

				
				tab1 = pParse->nTab++;
				tab2 = pParse->nTab++;
				assert(p->pOrderBy == 0);

				addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);
				assert(p->addrOpenEphm[0] == -1);
				p->addrOpenEphm[0] = addr;
				findRightmost(p)->selFlags |= SF_UsesEphemeral;
				assert(p->pEList);

				
				sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);
				explainSetInteger(iSub1, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, pPrior, &intersectdest);
				if (rc) {
					goto multi_select_end;
				}

				
				addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);
				assert(p->addrOpenEphm[1] == -1);
				p->addrOpenEphm[1] = addr;
				p->pPrior = 0;
				pLimit = p->pLimit;
				p->pLimit = 0;
				pOffset = p->pOffset;
				p->pOffset = 0;
				intersectdest.iSDParm = tab2;
				explainSetInteger(iSub2, pParse->iNextSelectId);
				rc = sqlite3Select(pParse, p, &intersectdest);
				testcase(rc != SQLITE_OK);
				pDelete = p->pPrior;
				p->pPrior = pPrior;
				if (p->nSelectRow>pPrior->nSelectRow) p->nSelectRow = pPrior->nSelectRow;
				sqlite3ExprDelete(db, p->pLimit);
				p->pLimit = pLimit;
				p->pOffset = pOffset;

				
				assert(p->pEList);
				if (dest.eDest == SRT_Output) {
					Select *pFirst = p;
					while (pFirst->pPrior) pFirst = pFirst->pPrior;
					generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
				}
				iBreak = sqlite3VdbeMakeLabel(v);
				iCont = sqlite3VdbeMakeLabel(v);
				computeLimitRegisters(pParse, p, iBreak);
				sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);
				r1 = sqlite3GetTempReg(pParse);
				iStart = sqlite3VdbeAddOp2(v, OP_RowKey, tab1, r1);
				sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0); VdbeCoverage(v);
				sqlite3ReleaseTempReg(pParse, r1);
				selectInnerLoop(pParse, p, p->pEList, tab1,
					0, 0, &dest, iCont, iBreak);
				sqlite3VdbeResolveLabel(v, iCont);
				sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);
				sqlite3VdbeResolveLabel(v, iBreak);
				sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);
				sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);
				break;
			}
			}

	explainComposite(pParse, p->op, iSub1, iSub2, p->op != TK_ALL);

	
	if (p->selFlags & SF_UsesEphemeral) {
		int i;                        
		KeyInfo *pKeyInfo;            
		Select *pLoop;                
		CollSeq **apColl;             
		int nCol;                     

		assert(p->pNext == 0);
		nCol = p->pEList->nExpr;
		pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
		if (!pKeyInfo) {
			rc = SQLITE_NOMEM_BKPT;
			goto multi_select_end;
		}
		for (i = 0, apColl = pKeyInfo->aColl; i<nCol; i++, apColl++) {
			*apColl = multiSelectCollSeq(pParse, p, i);
			if (0 == *apColl) {
				*apColl = db->pDfltColl;
			}
		}

		for (pLoop = p; pLoop; pLoop = pLoop->pPrior) {
			for (i = 0; i<2; i++) {
				int addr = pLoop->addrOpenEphm[i];
				if (addr<0) {
					
					assert(pLoop->addrOpenEphm[1]<0);
					break;
				}
				sqlite3VdbeChangeP2(v, addr, nCol);
				sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),
					P4_KEYINFO);
				pLoop->addrOpenEphm[i] = -1;
			}
		}
		sqlite3KeyInfoUnref(pKeyInfo);
	}

multi_select_end:
	pDest->iSdst = dest.iSdst;
	pDest->nSdst = dest.nSdst;
	sqlite3SelectDelete(db, pDelete);
	return rc;
}
#endif 


SQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p) {
	if (p->selFlags & SF_Values) {
		sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
	}
	else {
		sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"
			" do not have the same number of result columns", selectOpName(p->op));
	}
}


static int generateOutputSubroutine(
	Parse *pParse,          
	Select *p,              
	SelectDest *pIn,        
	SelectDest *pDest,      
	int regReturn,          
	int regPrev,            
	KeyInfo *pKeyInfo,      
	int iBreak              
) {
	Vdbe *v = pParse->pVdbe;
	int iContinue;
	int addr;

	addr = sqlite3VdbeCurrentAddr(v);
	iContinue = sqlite3VdbeMakeLabel(v);

	
	if (regPrev) {
		int addr1, addr2;
		addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);
		addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev + 1, pIn->nSdst,
			(char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
		sqlite3VdbeAddOp3(v, OP_Jump, addr2 + 2, iContinue, addr2 + 2); VdbeCoverage(v);
		sqlite3VdbeJumpHere(v, addr1);
		sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev + 1, pIn->nSdst - 1);
		sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);
	}
	if (pParse->db->mallocFailed) return 0;

	
	codeOffset(v, p->iOffset, iContinue);

	assert(pDest->eDest != SRT_Exists);
	assert(pDest->eDest != SRT_Table);
	switch (pDest->eDest) {
		
	case SRT_EphemTab: {
		int r1 = sqlite3GetTempReg(pParse);
		int r2 = sqlite3GetTempReg(pParse);
		sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);
		sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);
		sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);
		sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
		sqlite3ReleaseTempReg(pParse, r2);
		sqlite3ReleaseTempReg(pParse, r1);
		break;
	}

#ifndef SQLITE_OMIT_SUBQUERY
					   
	case SRT_Set: {
		int r1;
		testcase(pIn->nSdst>1);
		r1 = sqlite3GetTempReg(pParse);
		sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst,
			r1, pDest->zAffSdst, pIn->nSdst);
		sqlite3ExprCacheAffinityChange(pParse, pIn->iSdst, pIn->nSdst);
		sqlite3VdbeAddOp2(v, OP_IdxInsert, pDest->iSDParm, r1);
		sqlite3ReleaseTempReg(pParse, r1);
		break;
	}

				  
	case SRT_Mem: {
		assert(pIn->nSdst == 1 || pParse->nErr>0);  testcase(pIn->nSdst != 1);
		sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, 1);
		
		break;
	}
#endif 

				  
	case SRT_Coroutine: {
		if (pDest->iSdst == 0) {
			pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
			pDest->nSdst = pIn->nSdst;
		}
		sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
		sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
		break;
	}

						
	default: {
		assert(pDest->eDest == SRT_Output);
		sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);
		sqlite3ExprCacheAffinityChange(pParse, pIn->iSdst, pIn->nSdst);
		break;
	}
	}

	
	if (p->iLimit) {
		sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
	}

	
	sqlite3VdbeResolveLabel(v, iContinue);
	sqlite3VdbeAddOp1(v, OP_Return, regReturn);

	return addr;
}


#ifndef SQLITE_OMIT_COMPOUND_SELECT
static int multiSelectOrderBy(
	Parse *pParse,        
	Select *p,            
	SelectDest *pDest     
) {
	int i, j;             
	Select *pPrior;       
	Vdbe *v;              
	SelectDest destA;     
	SelectDest destB;     
	int regAddrA;         
	int regAddrB;         
	int addrSelectA;      
	int addrSelectB;      
	int regOutA;          
	int regOutB;          
	int addrOutA;         
	int addrOutB = 0;     
	int addrEofA;         
	int addrEofA_noB;     
	int addrEofB;         
	int addrAltB;         
	int addrAeqB;         
	int addrAgtB;         
	int regLimitA;        
	int regLimitB;        
	int regPrev;          
	int savedLimit;       
	int savedOffset;      
	int labelCmpr;        
	int labelEnd;         
	int addr1;            
	int op;               
	KeyInfo *pKeyDup = 0; 
	KeyInfo *pKeyMerge;   
	sqlite3 *db;          
	ExprList *pOrderBy;   
	int nOrderBy;         
	int *aPermute;        
#ifndef SQLITE_OMIT_EXPLAIN
	int iSub1;            
	int iSub2;            
#endif

	assert(p->pOrderBy != 0);
	assert(pKeyDup == 0); 
	db = pParse->db;
	v = pParse->pVdbe;
	assert(v != 0);       
	labelEnd = sqlite3VdbeMakeLabel(v);
	labelCmpr = sqlite3VdbeMakeLabel(v);


	
	op = p->op;
	pPrior = p->pPrior;
	assert(pPrior->pOrderBy == 0);
	pOrderBy = p->pOrderBy;
	assert(pOrderBy);
	nOrderBy = pOrderBy->nExpr;

	
	if (op != TK_ALL) {
		for (i = 1; db->mallocFailed == 0 && i <= p->pEList->nExpr; i++) {
			struct ExprList_item *pItem;
			for (j = 0, pItem = pOrderBy->a; j<nOrderBy; j++, pItem++) {
				assert(pItem->u.x.iOrderByCol>0);
				if (pItem->u.x.iOrderByCol == i) break;
			}
			if (j == nOrderBy) {
				Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);
				if (pNew == 0) return SQLITE_NOMEM_BKPT;
				pNew->flags |= EP_IntValue;
				pNew->u.iValue = i;
				pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
				if (pOrderBy) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;
			}
		}
	}

	
	aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));
	if (aPermute) {
		struct ExprList_item *pItem;
		aPermute[0] = nOrderBy;
		for (i = 1, pItem = pOrderBy->a; i <= nOrderBy; i++, pItem++) {
			assert(pItem->u.x.iOrderByCol>0);
			assert(pItem->u.x.iOrderByCol <= p->pEList->nExpr);
			aPermute[i] = pItem->u.x.iOrderByCol - 1;
		}
		pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
	}
	else {
		pKeyMerge = 0;
	}

	
	p->pOrderBy = pOrderBy;
	pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);

	
	if (op == TK_ALL) {
		regPrev = 0;
	}
	else {
		int nExpr = p->pEList->nExpr;
		assert(nOrderBy >= nExpr || db->mallocFailed);
		regPrev = pParse->nMem + 1;
		pParse->nMem += nExpr + 1;
		sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);
		pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
		if (pKeyDup) {
			assert(sqlite3KeyInfoIsWriteable(pKeyDup));
			for (i = 0; i<nExpr; i++) {
				pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
				pKeyDup->aSortOrder[i] = 0;
			}
		}
	}

	
	p->pPrior = 0;
	pPrior->pNext = 0;
	sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
	if (pPrior->pPrior == 0) {
		sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
	}

	
	computeLimitRegisters(pParse, p, labelEnd);
	if (p->iLimit && op == TK_ALL) {
		regLimitA = ++pParse->nMem;
		regLimitB = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset + 1 : p->iLimit,
			regLimitA);
		sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);
	}
	else {
		regLimitA = regLimitB = 0;
	}
	sqlite3ExprDelete(db, p->pLimit);
	p->pLimit = 0;
	sqlite3ExprDelete(db, p->pOffset);
	p->pOffset = 0;

	regAddrA = ++pParse->nMem;
	regAddrB = ++pParse->nMem;
	regOutA = ++pParse->nMem;
	regOutB = ++pParse->nMem;
	sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);
	sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);

	
	addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;
	addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);
	VdbeComment((v, "left SELECT"));
	pPrior->iLimit = regLimitA;
	explainSetInteger(iSub1, pParse->iNextSelectId);
	sqlite3Select(pParse, pPrior, &destA);
	sqlite3VdbeEndCoroutine(v, regAddrA);
	sqlite3VdbeJumpHere(v, addr1);

	
	addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;
	addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);
	VdbeComment((v, "right SELECT"));
	savedLimit = p->iLimit;
	savedOffset = p->iOffset;
	p->iLimit = regLimitB;
	p->iOffset = 0;
	explainSetInteger(iSub2, pParse->iNextSelectId);
	sqlite3Select(pParse, p, &destB);
	p->iLimit = savedLimit;
	p->iOffset = savedOffset;
	sqlite3VdbeEndCoroutine(v, regAddrB);

	
	VdbeNoopComment((v, "Output routine for A"));
	addrOutA = generateOutputSubroutine(pParse,
		p, &destA, pDest, regOutA,
		regPrev, pKeyDup, labelEnd);

	
	if (op == TK_ALL || op == TK_UNION) {
		VdbeNoopComment((v, "Output routine for B"));
		addrOutB = generateOutputSubroutine(pParse,
			p, &destB, pDest, regOutB,
			regPrev, pKeyDup, labelEnd);
	}
	sqlite3KeyInfoUnref(pKeyDup);

	
	if (op == TK_EXCEPT || op == TK_INTERSECT) {
		addrEofA_noB = addrEofA = labelEnd;
	}
	else {
		VdbeNoopComment((v, "eof-A subroutine"));
		addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
		addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);
		VdbeCoverage(v);
		sqlite3VdbeGoto(v, addrEofA);
		p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
	}

	
	if (op == TK_INTERSECT) {
		addrEofB = addrEofA;
		if (p->nSelectRow > pPrior->nSelectRow) p->nSelectRow = pPrior->nSelectRow;
	}
	else {
		VdbeNoopComment((v, "eof-B subroutine"));
		addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
		sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);
		sqlite3VdbeGoto(v, addrEofB);
	}

	
	VdbeNoopComment((v, "A-lt-B subroutine"));
	addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
	sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
	sqlite3VdbeGoto(v, labelCmpr);

	
	if (op == TK_ALL) {
		addrAeqB = addrAltB;
	}
	else if (op == TK_INTERSECT) {
		addrAeqB = addrAltB;
		addrAltB++;
	}
	else {
		VdbeNoopComment((v, "A-eq-B subroutine"));
		addrAeqB =
			sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
		sqlite3VdbeGoto(v, labelCmpr);
	}

	
	VdbeNoopComment((v, "A-gt-B subroutine"));
	addrAgtB = sqlite3VdbeCurrentAddr(v);
	if (op == TK_ALL || op == TK_UNION) {
		sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
	}
	sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);
	sqlite3VdbeGoto(v, labelCmpr);

	
	sqlite3VdbeJumpHere(v, addr1);
	sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);
	sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);

	
	sqlite3VdbeResolveLabel(v, labelCmpr);
	sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);
	sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,
		(char*)pKeyMerge, P4_KEYINFO);
	sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);
	sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);

	
	sqlite3VdbeResolveLabel(v, labelEnd);

	
	if (pDest->eDest == SRT_Output) {
		Select *pFirst = pPrior;
		while (pFirst->pPrior) pFirst = pFirst->pPrior;
		generateColumnNames(pParse, pFirst->pSrc, pFirst->pEList);
	}

	
	if (p->pPrior) {
		sqlite3SelectDelete(db, p->pPrior);
	}
	p->pPrior = pPrior;
	pPrior->pNext = p;

	
	explainComposite(pParse, p->op, iSub1, iSub2, 0);
	return pParse->nErr != 0;
}
#endif

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)

static void substExprList(sqlite3*, ExprList*, int, ExprList*);
static void substSelect(sqlite3*, Select *, int, ExprList*, int);


static Expr *substExpr(
	sqlite3 *db,        
	Expr *pExpr,        
	int iTable,         
	ExprList *pEList    
) {
	if (pExpr == 0) return 0;
	if (pExpr->op == TK_COLUMN && pExpr->iTable == iTable) {
		if (pExpr->iColumn<0) {
			pExpr->op = TK_NULL;
		}
		else {
			Expr *pNew;
			assert(pEList != 0 && pExpr->iColumn<pEList->nExpr);
			assert(pExpr->pLeft == 0 && pExpr->pRight == 0);
			pNew = sqlite3ExprDup(db, pEList->a[pExpr->iColumn].pExpr, 0);
			sqlite3ExprDelete(db, pExpr);
			pExpr = pNew;
		}
	}
	else {
		pExpr->pLeft = substExpr(db, pExpr->pLeft, iTable, pEList);
		pExpr->pRight = substExpr(db, pExpr->pRight, iTable, pEList);
		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			substSelect(db, pExpr->x.pSelect, iTable, pEList, 1);
		}
		else {
			substExprList(db, pExpr->x.pList, iTable, pEList);
		}
	}
	return pExpr;
}
static void substExprList(
	sqlite3 *db,         
	ExprList *pList,     
	int iTable,          
	ExprList *pEList     
) {
	int i;
	if (pList == 0) return;
	for (i = 0; i<pList->nExpr; i++) {
		pList->a[i].pExpr = substExpr(db, pList->a[i].pExpr, iTable, pEList);
	}
}
static void substSelect(
	sqlite3 *db,         
	Select *p,           
	int iTable,          
	ExprList *pEList,    
	int doPrior          
) {
	SrcList *pSrc;
	struct SrcList_item *pItem;
	int i;
	if (!p) return;
	do {
		substExprList(db, p->pEList, iTable, pEList);
		substExprList(db, p->pGroupBy, iTable, pEList);
		substExprList(db, p->pOrderBy, iTable, pEList);
		p->pHaving = substExpr(db, p->pHaving, iTable, pEList);
		p->pWhere = substExpr(db, p->pWhere, iTable, pEList);
		pSrc = p->pSrc;
		assert(pSrc != 0);
		for (i = pSrc->nSrc, pItem = pSrc->a; i>0; i--, pItem++) {
			substSelect(db, pItem->pSelect, iTable, pEList, 1);
			if (pItem->fg.isTabFunc) {
				substExprList(db, pItem->u1.pFuncArg, iTable, pEList);
			}
		}
	} while (doPrior && (p = p->pPrior) != 0);
}
#endif 

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)

static int flattenSubquery(
	Parse *pParse,       
	Select *p,           
	int iFrom,           
	int isAgg,           
	int subqueryIsAgg    
) {
	const char *zSavedAuthContext = pParse->zAuthContext;
	Select *pParent;    
	Select *pSub;       
	Select *pSub1;      
	SrcList *pSrc;      
	SrcList *pSubSrc;   
	ExprList *pList;    
	int iParent;        
	int i;              
	Expr *pWhere;                    
	struct SrcList_item *pSubitem;   
	sqlite3 *db = pParse->db;

	
	assert(p != 0);
	assert(p->pPrior == 0);  
	if (OptimizationDisabled(db, SQLITE_QueryFlattener)) return 0;
	pSrc = p->pSrc;
	assert(pSrc && iFrom >= 0 && iFrom<pSrc->nSrc);
	pSubitem = &pSrc->a[iFrom];
	iParent = pSubitem->iCursor;
	pSub = pSubitem->pSelect;
	assert(pSub != 0);
	if (subqueryIsAgg) {
		if (isAgg) return 0;                                
		if (pSrc->nSrc>1) return 0;                         
		if ((p->pWhere && ExprHasProperty(p->pWhere, EP_Subquery))
			|| (sqlite3ExprListFlags(p->pEList) & EP_Subquery) != 0
			|| (sqlite3ExprListFlags(p->pOrderBy) & EP_Subquery) != 0
			) {
			return 0;                                          
		}
	}

	pSubSrc = pSub->pSrc;
	assert(pSubSrc);
	
	if (pSub->pLimit && p->pLimit) return 0;              
	if (pSub->pOffset) return 0;                          
	if ((p->selFlags & SF_Compound) != 0 && pSub->pLimit) {
		return 0;                                            
	}
	if (pSubSrc->nSrc == 0) return 0;                       
	if (pSub->selFlags & SF_Distinct) return 0;           
	if (pSub->pLimit && (pSrc->nSrc>1 || isAgg)) {
		return 0;         
	}
	if ((p->selFlags & SF_Distinct) != 0 && subqueryIsAgg) {
		return 0;         
	}
	if (p->pOrderBy && pSub->pOrderBy) {
		return 0;                                           
	}
	if (isAgg && pSub->pOrderBy) return 0;                
	if (pSub->pLimit && p->pWhere) return 0;              
	if (pSub->pLimit && (p->selFlags & SF_Distinct) != 0) {
		return 0;         
	}
	testcase(pSub->selFlags & SF_Recursive);
	testcase(pSub->selFlags & SF_MinMaxAgg);
	if (pSub->selFlags & (SF_Recursive | SF_MinMaxAgg)) {
		return 0; 
	}
	if ((p->selFlags & SF_Recursive) && pSub->pPrior) {
		return 0; 
	}

	
	if ((pSubitem->fg.jointype & JT_OUTER) != 0) {
		return 0;
	}

	
	if (pSub->pPrior) {
		if (pSub->pOrderBy) {
			return 0;  
		}
		if (isAgg || (p->selFlags & SF_Distinct) != 0 || pSrc->nSrc != 1) {
			return 0;
		}
		for (pSub1 = pSub; pSub1; pSub1 = pSub1->pPrior) {
			testcase((pSub1->selFlags & (SF_Distinct | SF_Aggregate)) == SF_Distinct);
			testcase((pSub1->selFlags & (SF_Distinct | SF_Aggregate)) == SF_Aggregate);
			assert(pSub->pSrc != 0);
			assert(pSub->pEList->nExpr == pSub1->pEList->nExpr);
			if ((pSub1->selFlags & (SF_Distinct | SF_Aggregate)) != 0
				|| (pSub1->pPrior && pSub1->op != TK_ALL)
				|| pSub1->pSrc->nSrc<1
				) {
				return 0;
			}
			testcase(pSub1->pSrc->nSrc>1);
		}

		
		if (p->pOrderBy) {
			int ii;
			for (ii = 0; ii<p->pOrderBy->nExpr; ii++) {
				if (p->pOrderBy->a[ii].u.x.iOrderByCol == 0) return 0;
			}
		}
	}

	
	SELECTTRACE(1, pParse, p, ("flatten %s.%p from term %d\n",
		pSub->zSelName, pSub, iFrom));

	
	pParse->zAuthContext = pSubitem->zName;
	TESTONLY(i = ) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);
	testcase(i == SQLITE_DENY);
	pParse->zAuthContext = zSavedAuthContext;

	
	for (pSub = pSub->pPrior; pSub; pSub = pSub->pPrior) {
		Select *pNew;
		ExprList *pOrderBy = p->pOrderBy;
		Expr *pLimit = p->pLimit;
		Expr *pOffset = p->pOffset;
		Select *pPrior = p->pPrior;
		p->pOrderBy = 0;
		p->pSrc = 0;
		p->pPrior = 0;
		p->pLimit = 0;
		p->pOffset = 0;
		pNew = sqlite3SelectDup(db, p, 0);
		sqlite3SelectSetName(pNew, pSub->zSelName);
		p->pOffset = pOffset;
		p->pLimit = pLimit;
		p->pOrderBy = pOrderBy;
		p->pSrc = pSrc;
		p->op = TK_ALL;
		if (pNew == 0) {
			p->pPrior = pPrior;
		}
		else {
			pNew->pPrior = pPrior;
			if (pPrior) pPrior->pNext = pNew;
			pNew->pNext = p;
			p->pPrior = pNew;
			SELECTTRACE(2, pParse, p,
				("compound-subquery flattener creates %s.%p as peer\n",
					pNew->zSelName, pNew));
		}
		if (db->mallocFailed) return 1;
	}

	
	pSub = pSub1 = pSubitem->pSelect;

	
	sqlite3DbFree(db, pSubitem->zDatabase);
	sqlite3DbFree(db, pSubitem->zName);
	sqlite3DbFree(db, pSubitem->zAlias);
	pSubitem->zDatabase = 0;
	pSubitem->zName = 0;
	pSubitem->zAlias = 0;
	pSubitem->pSelect = 0;

	
	if (ALWAYS(pSubitem->pTab != 0)) {
		Table *pTabToDel = pSubitem->pTab;
		if (pTabToDel->nRef == 1) {
			Parse *pToplevel = sqlite3ParseToplevel(pParse);
			pTabToDel->pNextZombie = pToplevel->pZombieTab;
			pToplevel->pZombieTab = pTabToDel;
		}
		else {
			pTabToDel->nRef--;
		}
		pSubitem->pTab = 0;
	}

	
	for (pParent = p; pParent; pParent = pParent->pPrior, pSub = pSub->pPrior) {
		int nSubSrc;
		u8 jointype = 0;
		pSubSrc = pSub->pSrc;     
		nSubSrc = pSubSrc->nSrc;  
		pSrc = pParent->pSrc;     

		if (pSrc) {
			assert(pParent == p);  
			jointype = pSubitem->fg.jointype;
		}
		else {
			assert(pParent != p);  
			pSrc = pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
			if (pSrc == 0) {
				assert(db->mallocFailed);
				break;
			}
		}

		
		if (nSubSrc>1) {
			pParent->pSrc = pSrc = sqlite3SrcListEnlarge(db, pSrc, nSubSrc - 1, iFrom + 1);
			if (db->mallocFailed) {
				break;
			}
		}

		
		for (i = 0; i<nSubSrc; i++) {
			sqlite3IdListDelete(db, pSrc->a[i + iFrom].pUsing);
			assert(pSrc->a[i + iFrom].fg.isTabFunc == 0);
			pSrc->a[i + iFrom] = pSubSrc->a[i];
			memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
		}
		pSrc->a[iFrom].fg.jointype = jointype;

		
		pList = pParent->pEList;
		for (i = 0; i<pList->nExpr; i++) {
			if (pList->a[i].zName == 0) {
				char *zName = sqlite3DbStrDup(db, pList->a[i].zSpan);
				sqlite3Dequote(zName);
				pList->a[i].zName = zName;
			}
		}
		if (pSub->pOrderBy) {
			
			ExprList *pOrderBy = pSub->pOrderBy;
			for (i = 0; i<pOrderBy->nExpr; i++) {
				pOrderBy->a[i].u.x.iOrderByCol = 0;
			}
			assert(pParent->pOrderBy == 0);
			assert(pSub->pPrior == 0);
			pParent->pOrderBy = pOrderBy;
			pSub->pOrderBy = 0;
		}
		pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);
		if (subqueryIsAgg) {
			assert(pParent->pHaving == 0);
			pParent->pHaving = pParent->pWhere;
			pParent->pWhere = pWhere;
			pParent->pHaving = sqlite3ExprAnd(db,
				sqlite3ExprDup(db, pSub->pHaving, 0), pParent->pHaving
			);
			assert(pParent->pGroupBy == 0);
			pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy, 0);
		}
		else {
			pParent->pWhere = sqlite3ExprAnd(db, pWhere, pParent->pWhere);
		}
		substSelect(db, pParent, iParent, pSub->pEList, 0);

		
		pParent->selFlags |= pSub->selFlags & SF_Distinct;

		
		if (pSub->pLimit) {
			pParent->pLimit = pSub->pLimit;
			pSub->pLimit = 0;
		}
	}

	
	sqlite3SelectDelete(db, pSub1);

#if SELECTTRACE_ENABLED
	if (sqlite3SelectTrace & 0x100) {
		SELECTTRACE(0x100, pParse, p, ("After flattening:\n"));
		sqlite3TreeViewSelect(0, p, 0);
	}
#endif

	return 1;
}
#endif 



#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)

static int pushDownWhereTerms(
	sqlite3 *db,          
	Select *pSubq,        
	Expr *pWhere,         
	int iCursor           
) {
	Expr *pNew;
	int nChng = 0;
	Select *pX;           
	if (pWhere == 0) return 0;
	for (pX = pSubq; pX; pX = pX->pPrior) {
		if ((pX->selFlags & (SF_Aggregate | SF_Recursive)) != 0) {
			testcase(pX->selFlags & SF_Aggregate);
			testcase(pX->selFlags & SF_Recursive);
			testcase(pX != pSubq);
			return 0; 
		}
	}
	if (pSubq->pLimit != 0) {
		return 0; 
	}
	while (pWhere->op == TK_AND) {
		nChng += pushDownWhereTerms(db, pSubq, pWhere->pRight, iCursor);
		pWhere = pWhere->pLeft;
	}
	if (ExprHasProperty(pWhere, EP_FromJoin)) return 0; 
	if (sqlite3ExprIsTableConstant(pWhere, iCursor)) {
		nChng++;
		while (pSubq) {
			pNew = sqlite3ExprDup(db, pWhere, 0);
			pNew = substExpr(db, pNew, iCursor, pSubq->pEList);
			pSubq->pWhere = sqlite3ExprAnd(db, pSubq->pWhere, pNew);
			pSubq = pSubq->pPrior;
		}
	}
	return nChng;
}
#endif 


static u8 minMaxQuery(AggInfo *pAggInfo, ExprList **ppMinMax) {
	int eRet = WHERE_ORDERBY_NORMAL;          

	*ppMinMax = 0;
	if (pAggInfo->nFunc == 1) {
		Expr *pExpr = pAggInfo->aFunc[0].pExpr; 
		ExprList *pEList = pExpr->x.pList;      

		assert(pExpr->op == TK_AGG_FUNCTION);
		if (pEList && pEList->nExpr == 1 && pEList->a[0].pExpr->op == TK_AGG_COLUMN) {
			const char *zFunc = pExpr->u.zToken;
			if (sqlite3StrICmp(zFunc, "min") == 0) {
				eRet = WHERE_ORDERBY_MIN;
				*ppMinMax = pEList;
			}
			else if (sqlite3StrICmp(zFunc, "max") == 0) {
				eRet = WHERE_ORDERBY_MAX;
				*ppMinMax = pEList;
			}
		}
	}

	assert(*ppMinMax == 0 || (*ppMinMax)->nExpr == 1);
	return eRet;
}


static Table *isSimpleCount(Select *p, AggInfo *pAggInfo) {
	Table *pTab;
	Expr *pExpr;

	assert(!p->pGroupBy);

	if (p->pWhere || p->pEList->nExpr != 1
		|| p->pSrc->nSrc != 1 || p->pSrc->a[0].pSelect
		) {
		return 0;
	}
	pTab = p->pSrc->a[0].pTab;
	pExpr = p->pEList->a[0].pExpr;
	assert(pTab && !pTab->pSelect && pExpr);

	if (IsVirtual(pTab)) return 0;
	if (pExpr->op != TK_AGG_FUNCTION) return 0;
	if (NEVER(pAggInfo->nFunc == 0)) return 0;
	if ((pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT) == 0) return 0;
	if (pExpr->flags&EP_Distinct) return 0;

	return pTab;
}


SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom) {
	if (pFrom->pTab && pFrom->fg.isIndexedBy) {
		Table *pTab = pFrom->pTab;
		char *zIndexedBy = pFrom->u1.zIndexedBy;
		Index *pIdx;
		for (pIdx = pTab->pIndex;
			pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);
			pIdx = pIdx->pNext
			);
		if (!pIdx) {
			sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);
			pParse->checkSchema = 1;
			return SQLITE_ERROR;
		}
		pFrom->pIBIndex = pIdx;
	}
	return SQLITE_OK;
}

static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p) {
	int i;
	Select *pNew;
	Select *pX;
	sqlite3 *db;
	struct ExprList_item *a;
	SrcList *pNewSrc;
	Parse *pParse;
	Token dummy;

	if (p->pPrior == 0) return WRC_Continue;
	if (p->pOrderBy == 0) return WRC_Continue;
	for (pX = p; pX && (pX->op == TK_ALL || pX->op == TK_SELECT); pX = pX->pPrior) {}
	if (pX == 0) return WRC_Continue;
	a = p->pOrderBy->a;
	for (i = p->pOrderBy->nExpr - 1; i >= 0; i--) {
		if (a[i].pExpr->flags & EP_Collate) break;
	}
	if (i<0) return WRC_Continue;

	

	pParse = pWalker->pParse;
	db = pParse->db;
	pNew = sqlite3DbMallocZero(db, sizeof(*pNew));
	if (pNew == 0) return WRC_Abort;
	memset(&dummy, 0, sizeof(dummy));
	pNewSrc = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &dummy, pNew, 0, 0);
	if (pNewSrc == 0) return WRC_Abort;
	*pNew = *p;
	p->pSrc = pNewSrc;
	p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));
	p->op = TK_SELECT;
	p->pWhere = 0;
	pNew->pGroupBy = 0;
	pNew->pHaving = 0;
	pNew->pOrderBy = 0;
	p->pPrior = 0;
	p->pNext = 0;
	p->pWith = 0;
	p->selFlags &= ~SF_Compound;
	assert((p->selFlags & SF_Converted) == 0);
	p->selFlags |= SF_Converted;
	assert(pNew->pPrior != 0);
	pNew->pPrior->pNext = pNew;
	pNew->pLimit = 0;
	pNew->pOffset = 0;
	return WRC_Continue;
}


static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom) {
	if (pFrom->fg.isTabFunc) {
		sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);
		return 1;
	}
	return 0;
}

#ifndef SQLITE_OMIT_CTE

static struct Cte *searchWith(
	With *pWith,                    
	struct SrcList_item *pItem,     
	With **ppContext                
) {
	const char *zName;
	if (pItem->zDatabase == 0 && (zName = pItem->zName) != 0) {
		With *p;
		for (p = pWith; p; p = p->pOuter) {
			int i;
			for (i = 0; i<p->nCte; i++) {
				if (sqlite3StrICmp(zName, p->a[i].zName) == 0) {
					*ppContext = p;
					return &p->a[i];
				}
			}
		}
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree) {
	assert(bFree == 0 || (pParse->pWith == 0 && pParse->pWithToFree == 0));
	if (pWith) {
		assert(pParse->pWith != pWith);
		pWith->pOuter = pParse->pWith;
		pParse->pWith = pWith;
		if (bFree) pParse->pWithToFree = pWith;
	}
}


static int withExpand(
	Walker *pWalker,
	struct SrcList_item *pFrom
) {
	Parse *pParse = pWalker->pParse;
	sqlite3 *db = pParse->db;
	struct Cte *pCte;               
	With *pWith;                    

	assert(pFrom->pTab == 0);

	pCte = searchWith(pParse->pWith, pFrom, &pWith);
	if (pCte) {
		Table *pTab;
		ExprList *pEList;
		Select *pSel;
		Select *pLeft;                
		int bMayRecursive;            
		With *pSavedWith;             

									  
		if (pCte->zCteErr) {
			sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
			return SQLITE_ERROR;
		}
		if (cannotBeFunction(pParse, pFrom)) return SQLITE_ERROR;

		assert(pFrom->pTab == 0);
		pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));
		if (pTab == 0) return WRC_Abort;
		pTab->nRef = 1;
		pTab->zName = sqlite3DbStrDup(db, pCte->zName);
		pTab->iPKey = -1;
		pTab->nRowLogEst = 200; assert(200 == sqlite3LogEst(1048576));
		pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;
		pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);
		if (db->mallocFailed) return SQLITE_NOMEM_BKPT;
		assert(pFrom->pSelect);

		
		pSel = pFrom->pSelect;
		bMayRecursive = (pSel->op == TK_ALL || pSel->op == TK_UNION);
		if (bMayRecursive) {
			int i;
			SrcList *pSrc = pFrom->pSelect->pSrc;
			for (i = 0; i<pSrc->nSrc; i++) {
				struct SrcList_item *pItem = &pSrc->a[i];
				if (pItem->zDatabase == 0
					&& pItem->zName != 0
					&& 0 == sqlite3StrICmp(pItem->zName, pCte->zName)
					) {
					pItem->pTab = pTab;
					pItem->fg.isRecursive = 1;
					pTab->nRef++;
					pSel->selFlags |= SF_Recursive;
				}
			}
		}

		
		if (pTab->nRef>2) {
			sqlite3ErrorMsg(
				pParse, "multiple references to recursive table: %s", pCte->zName
			);
			return SQLITE_ERROR;
		}
		assert(pTab->nRef == 1 || ((pSel->selFlags&SF_Recursive) && pTab->nRef == 2));

		pCte->zCteErr = "circular reference: %s";
		pSavedWith = pParse->pWith;
		pParse->pWith = pWith;
		sqlite3WalkSelect(pWalker, bMayRecursive ? pSel->pPrior : pSel);
		pParse->pWith = pWith;

		for (pLeft = pSel; pLeft->pPrior; pLeft = pLeft->pPrior);
		pEList = pLeft->pEList;
		if (pCte->pCols) {
			if (pEList && pEList->nExpr != pCte->pCols->nExpr) {
				sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",
					pCte->zName, pEList->nExpr, pCte->pCols->nExpr
				);
				pParse->pWith = pSavedWith;
				return SQLITE_ERROR;
			}
			pEList = pCte->pCols;
		}

		sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
		if (bMayRecursive) {
			if (pSel->selFlags & SF_Recursive) {
				pCte->zCteErr = "multiple recursive references: %s";
			}
			else {
				pCte->zCteErr = "recursive reference in a subquery: %s";
			}
			sqlite3WalkSelect(pWalker, pSel);
		}
		pCte->zCteErr = 0;
		pParse->pWith = pSavedWith;
	}

	return SQLITE_OK;
}
#endif

#ifndef SQLITE_OMIT_CTE

static void selectPopWith(Walker *pWalker, Select *p) {
	Parse *pParse = pWalker->pParse;
	With *pWith = findRightmost(p)->pWith;
	if (pWith != 0) {
		assert(pParse->pWith == pWith);
		pParse->pWith = pWith->pOuter;
	}
}
#else
#define selectPopWith 0
#endif


static int selectExpander(Walker *pWalker, Select *p) {
	Parse *pParse = pWalker->pParse;
	int i, j, k;
	SrcList *pTabList;
	ExprList *pEList;
	struct SrcList_item *pFrom;
	sqlite3 *db = pParse->db;
	Expr *pE, *pRight, *pExpr;
	u16 selFlags = p->selFlags;

	p->selFlags |= SF_Expanded;
	if (db->mallocFailed) {
		return WRC_Abort;
	}
	if (NEVER(p->pSrc == 0) || (selFlags & SF_Expanded) != 0) {
		return WRC_Prune;
	}
	pTabList = p->pSrc;
	pEList = p->pEList;
	if (pWalker->xSelectCallback2 == selectPopWith) {
		sqlite3WithPush(pParse, findRightmost(p)->pWith, 0);
	}

	
	sqlite3SrcListAssignCursors(pParse, pTabList);

	
	for (i = 0, pFrom = pTabList->a; i<pTabList->nSrc; i++, pFrom++) {
		Table *pTab;
		assert(pFrom->fg.isRecursive == 0 || pFrom->pTab != 0);
		if (pFrom->fg.isRecursive) continue;
		assert(pFrom->pTab == 0);
#ifndef SQLITE_OMIT_CTE
		if (withExpand(pWalker, pFrom)) return WRC_Abort;
		if (pFrom->pTab) {}
		else
#endif
			if (pFrom->zName == 0) {
#ifndef SQLITE_OMIT_SUBQUERY
				Select *pSel = pFrom->pSelect;
				
				assert(pSel != 0);
				assert(pFrom->pTab == 0);
				if (sqlite3WalkSelect(pWalker, pSel)) return WRC_Abort;
				pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));
				if (pTab == 0) return WRC_Abort;
				pTab->nRef = 1;
				pTab->zName = sqlite3MPrintf(db, "sqlite_sq_%p", (void*)pTab);
				while (pSel->pPrior) { pSel = pSel->pPrior; }
				sqlite3ColumnsFromExprList(pParse, pSel->pEList, &pTab->nCol, &pTab->aCol);
				pTab->iPKey = -1;
				pTab->nRowLogEst = 200; assert(200 == sqlite3LogEst(1048576));
				pTab->tabFlags |= TF_Ephemeral;
#endif
			}
			else {
				
				assert(pFrom->pTab == 0);
				pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);
				if (pTab == 0) return WRC_Abort;
				if (pTab->nRef == 0xffff) {
					sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",
						pTab->zName);
					pFrom->pTab = 0;
					return WRC_Abort;
				}
				pTab->nRef++;
				if (!IsVirtual(pTab) && cannotBeFunction(pParse, pFrom)) {
					return WRC_Abort;
				}
#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)
				if (IsVirtual(pTab) || pTab->pSelect) {
					i16 nCol;
					if (sqlite3ViewGetColumnNames(pParse, pTab)) return WRC_Abort;
					assert(pFrom->pSelect == 0);
					pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
					sqlite3SelectSetName(pFrom->pSelect, pTab->zName);
					nCol = pTab->nCol;
					pTab->nCol = -1;
					sqlite3WalkSelect(pWalker, pFrom->pSelect);
					pTab->nCol = nCol;
				}
#endif
			}

			
			if (sqlite3IndexedByLookup(pParse, pFrom)) {
				return WRC_Abort;
			}
	}

	
	if (db->mallocFailed || sqliteProcessJoin(pParse, p)) {
		return WRC_Abort;
	}

	
	for (k = 0; k<pEList->nExpr; k++) {
		pE = pEList->a[k].pExpr;
		if (pE->op == TK_ASTERISK) break;
		assert(pE->op != TK_DOT || pE->pRight != 0);
		assert(pE->op != TK_DOT || (pE->pLeft != 0 && pE->pLeft->op == TK_ID));
		if (pE->op == TK_DOT && pE->pRight->op == TK_ASTERISK) break;
	}
	if (k<pEList->nExpr) {
		
		struct ExprList_item *a = pEList->a;
		ExprList *pNew = 0;
		int flags = pParse->db->flags;
		int longNames = (flags & SQLITE_FullColNames) != 0
			&& (flags & SQLITE_ShortColNames) == 0;

		for (k = 0; k<pEList->nExpr; k++) {
			pE = a[k].pExpr;
			pRight = pE->pRight;
			assert(pE->op != TK_DOT || pRight != 0);
			if (pE->op != TK_ASTERISK
				&& (pE->op != TK_DOT || pRight->op != TK_ASTERISK)
				) {
				
				pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
				if (pNew) {
					pNew->a[pNew->nExpr - 1].zName = a[k].zName;
					pNew->a[pNew->nExpr - 1].zSpan = a[k].zSpan;
					a[k].zName = 0;
					a[k].zSpan = 0;
				}
				a[k].pExpr = 0;
			}
			else {
				
				int tableSeen = 0;      
				char *zTName = 0;       
				if (pE->op == TK_DOT) {
					assert(pE->pLeft != 0);
					assert(!ExprHasProperty(pE->pLeft, EP_IntValue));
					zTName = pE->pLeft->u.zToken;
				}
				for (i = 0, pFrom = pTabList->a; i<pTabList->nSrc; i++, pFrom++) {
					Table *pTab = pFrom->pTab;
					Select *pSub = pFrom->pSelect;
					char *zTabName = pFrom->zAlias;
					const char *zSchemaName = 0;
					int iDb;
					if (zTabName == 0) {
						zTabName = pTab->zName;
					}
					if (db->mallocFailed) break;
					if (pSub == 0 || (pSub->selFlags & SF_NestedFrom) == 0) {
						pSub = 0;
						if (zTName && sqlite3StrICmp(zTName, zTabName) != 0) {
							continue;
						}
						iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
						zSchemaName = iDb >= 0 ? db->aDb[iDb].zDbSName : "*";
					}
					for (j = 0; j<pTab->nCol; j++) {
						char *zName = pTab->aCol[j].zName;
						char *zColname;  
						char *zToFree;   
						Token sColname;  

						assert(zName);
						if (zTName && pSub
							&& sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0) == 0
							) {
							continue;
						}

						
						if ((p->selFlags & SF_IncludeHidden) == 0
							&& IsHiddenColumn(&pTab->aCol[j])
							) {
							continue;
						}
						tableSeen = 1;

						if (i>0 && zTName == 0) {
							if ((pFrom->fg.jointype & JT_NATURAL) != 0
								&& tableAndColumnIndex(pTabList, i, zName, 0, 0)
								) {
								
								continue;
							}
							if (sqlite3IdListIndex(pFrom->pUsing, zName) >= 0) {
								
								continue;
							}
						}
						pRight = sqlite3Expr(db, TK_ID, zName);
						zColname = zName;
						zToFree = 0;
						if (longNames || pTabList->nSrc>1) {
							Expr *pLeft;
							pLeft = sqlite3Expr(db, TK_ID, zTabName);
							pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0);
							if (zSchemaName) {
								pLeft = sqlite3Expr(db, TK_ID, zSchemaName);
								pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr, 0);
							}
							if (longNames) {
								zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
								zToFree = zColname;
							}
						}
						else {
							pExpr = pRight;
						}
						pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
						sqlite3TokenInit(&sColname, zColname);
						sqlite3ExprListSetName(pParse, pNew, &sColname, 0);
						if (pNew && (p->selFlags & SF_NestedFrom) != 0) {
							struct ExprList_item *pX = &pNew->a[pNew->nExpr - 1];
							if (pSub) {
								pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);
								testcase(pX->zSpan == 0);
							}
							else {
								pX->zSpan = sqlite3MPrintf(db, "%s.%s.%s",
									zSchemaName, zTabName, zColname);
								testcase(pX->zSpan == 0);
							}
							pX->bSpanIsTab = 1;
						}
						sqlite3DbFree(db, zToFree);
					}
				}
				if (!tableSeen) {
					if (zTName) {
						sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
					}
					else {
						sqlite3ErrorMsg(pParse, "no tables specified");
					}
				}
			}
		}
		sqlite3ExprListDelete(db, pEList);
		p->pEList = pNew;
	}
#if SQLITE_MAX_COLUMN
	if (p->pEList && p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN]) {
		sqlite3ErrorMsg(pParse, "too many columns in result set");
		return WRC_Abort;
	}
#endif
	return WRC_Continue;
}


SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2) {
	UNUSED_PARAMETER2(NotUsed, NotUsed2);
	return WRC_Continue;
}


static void sqlite3SelectExpand(Parse *pParse, Select *pSelect) {
	Walker w;
	memset(&w, 0, sizeof(w));
	w.xExprCallback = sqlite3ExprWalkNoop;
	w.pParse = pParse;
	if (pParse->hasCompound) {
		w.xSelectCallback = convertCompoundSelectToSubquery;
		sqlite3WalkSelect(&w, pSelect);
	}
	w.xSelectCallback = selectExpander;
	if ((pSelect->selFlags & SF_MultiValue) == 0) {
		w.xSelectCallback2 = selectPopWith;
	}
	sqlite3WalkSelect(&w, pSelect);
}


#ifndef SQLITE_OMIT_SUBQUERY

static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p) {
	Parse *pParse;
	int i;
	SrcList *pTabList;
	struct SrcList_item *pFrom;

	assert(p->selFlags & SF_Resolved);
	assert((p->selFlags & SF_HasTypeInfo) == 0);
	p->selFlags |= SF_HasTypeInfo;
	pParse = pWalker->pParse;
	pTabList = p->pSrc;
	for (i = 0, pFrom = pTabList->a; i<pTabList->nSrc; i++, pFrom++) {
		Table *pTab = pFrom->pTab;
		assert(pTab != 0);
		if ((pTab->tabFlags & TF_Ephemeral) != 0) {
			
			Select *pSel = pFrom->pSelect;
			if (pSel) {
				while (pSel->pPrior) pSel = pSel->pPrior;
				sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel);
			}
		}
	}
}
#endif



static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect) {
#ifndef SQLITE_OMIT_SUBQUERY
	Walker w;
	memset(&w, 0, sizeof(w));
	w.xSelectCallback2 = selectAddSubqueryTypeInfo;
	w.xExprCallback = sqlite3ExprWalkNoop;
	w.pParse = pParse;
	sqlite3WalkSelect(&w, pSelect);
#endif
}



SQLITE_PRIVATE void sqlite3SelectPrep(
	Parse *pParse,         
	Select *p,             
	NameContext *pOuterNC  
) {
	sqlite3 *db;
	if (NEVER(p == 0)) return;
	db = pParse->db;
	if (db->mallocFailed) return;
	if (p->selFlags & SF_HasTypeInfo) return;
	sqlite3SelectExpand(pParse, p);
	if (pParse->nErr || db->mallocFailed) return;
	sqlite3ResolveSelectNames(pParse, p, pOuterNC);
	if (pParse->nErr || db->mallocFailed) return;
	sqlite3SelectAddTypeInfo(pParse, p);
}


static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo) {
	Vdbe *v = pParse->pVdbe;
	int i;
	struct AggInfo_func *pFunc;
	int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
	if (nReg == 0) return;
#ifdef SQLITE_DEBUG
	
	assert(nReg == pAggInfo->mxReg - pAggInfo->mnReg + 1);
	for (i = 0; i<pAggInfo->nColumn; i++) {
		assert(pAggInfo->aCol[i].iMem >= pAggInfo->mnReg
			&& pAggInfo->aCol[i].iMem <= pAggInfo->mxReg);
	}
	for (i = 0; i<pAggInfo->nFunc; i++) {
		assert(pAggInfo->aFunc[i].iMem >= pAggInfo->mnReg
			&& pAggInfo->aFunc[i].iMem <= pAggInfo->mxReg);
	}
#endif
	sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);
	for (pFunc = pAggInfo->aFunc, i = 0; i<pAggInfo->nFunc; i++, pFunc++) {
		if (pFunc->iDistinct >= 0) {
			Expr *pE = pFunc->pExpr;
			assert(!ExprHasProperty(pE, EP_xIsSelect));
			if (pE->x.pList == 0 || pE->x.pList->nExpr != 1) {
				sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "
					"argument");
				pFunc->iDistinct = -1;
			}
			else {
				KeyInfo *pKeyInfo = keyInfoFromExprList(pParse, pE->x.pList, 0, 0);
				sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,
					(char*)pKeyInfo, P4_KEYINFO);
			}
		}
	}
}


static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo) {
	Vdbe *v = pParse->pVdbe;
	int i;
	struct AggInfo_func *pF;
	for (i = 0, pF = pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) {
		ExprList *pList = pF->pExpr->x.pList;
		assert(!ExprHasProperty(pF->pExpr, EP_xIsSelect));
		sqlite3VdbeAddOp4(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0, 0,
			(void*)pF->pFunc, P4_FUNCDEF);
	}
}


static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo) {
	Vdbe *v = pParse->pVdbe;
	int i;
	int regHit = 0;
	int addrHitTest = 0;
	struct AggInfo_func *pF;
	struct AggInfo_col *pC;

	pAggInfo->directMode = 1;
	for (i = 0, pF = pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++) {
		int nArg;
		int addrNext = 0;
		int regAgg;
		ExprList *pList = pF->pExpr->x.pList;
		assert(!ExprHasProperty(pF->pExpr, EP_xIsSelect));
		if (pList) {
			nArg = pList->nExpr;
			regAgg = sqlite3GetTempRange(pParse, nArg);
			sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);
		}
		else {
			nArg = 0;
			regAgg = 0;
		}
		if (pF->iDistinct >= 0) {
			addrNext = sqlite3VdbeMakeLabel(v);
			testcase(nArg == 0);  
			testcase(nArg>1);   
			codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
		}
		if (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL) {
			CollSeq *pColl = 0;
			struct ExprList_item *pItem;
			int j;
			assert(pList != 0);  
			for (j = 0, pItem = pList->a; !pColl && j<nArg; j++, pItem++) {
				pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
			}
			if (!pColl) {
				pColl = pParse->db->pDfltColl;
			}
			if (regHit == 0 && pAggInfo->nAccumulator) regHit = ++pParse->nMem;
			sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);
		}
		sqlite3VdbeAddOp4(v, OP_AggStep0, 0, regAgg, pF->iMem,
			(void*)pF->pFunc, P4_FUNCDEF);
		sqlite3VdbeChangeP5(v, (u8)nArg);
		sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg);
		sqlite3ReleaseTempRange(pParse, regAgg, nArg);
		if (addrNext) {
			sqlite3VdbeResolveLabel(v, addrNext);
			sqlite3ExprCacheClear(pParse);
		}
	}

	
	if (regHit) {
		addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);
	}
	sqlite3ExprCacheClear(pParse);
	for (i = 0, pC = pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++) {
		sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
	}
	pAggInfo->directMode = 0;
	sqlite3ExprCacheClear(pParse);
	if (addrHitTest) {
		sqlite3VdbeJumpHere(v, addrHitTest);
	}
}


#ifndef SQLITE_OMIT_EXPLAIN
static void explainSimpleCount(
	Parse *pParse,                  
	Table *pTab,                    
	Index *pIdx                     
) {
	if (pParse->explain == 2) {
		int bCover = (pIdx != 0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));
		char *zEqp = sqlite3MPrintf(pParse->db, "SCAN TABLE %s%s%s",
			pTab->zName,
			bCover ? " USING COVERING INDEX " : "",
			bCover ? pIdx->zName : ""
		);
		sqlite3VdbeAddOp4(
			pParse->pVdbe, OP_Explain, pParse->iSelectId, 0, 0, zEqp, P4_DYNAMIC
		);
	}
}
#else
# define explainSimpleCount(a,b,c)
#endif


SQLITE_PRIVATE int sqlite3Select(
	Parse *pParse,         
	Select *p,             
	SelectDest *pDest      
) {
	int i, j;              
	WhereInfo *pWInfo;     
	Vdbe *v;               
	int isAgg;             
	ExprList *pEList = 0;  
	SrcList *pTabList;     
	Expr *pWhere;          
	ExprList *pGroupBy;    
	Expr *pHaving;         
	int rc = 1;            
	DistinctCtx sDistinct; 
	SortCtx sSort;         
	AggInfo sAggInfo;      
	int iEnd;              
	sqlite3 *db;           

#ifndef SQLITE_OMIT_EXPLAIN
	int iRestoreSelectId = pParse->iSelectId;
	pParse->iSelectId = pParse->iNextSelectId++;
#endif

	db = pParse->db;
	if (p == 0 || db->mallocFailed || pParse->nErr) {
		return 1;
	}
	if (sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0)) return 1;
	memset(&sAggInfo, 0, sizeof(sAggInfo));
#if SELECTTRACE_ENABLED
	pParse->nSelectIndent++;
	SELECTTRACE(1, pParse, p, ("begin processing:\n"));
	if (sqlite3SelectTrace & 0x100) {
		sqlite3TreeViewSelect(0, p, 0);
	}
#endif

	assert(p->pOrderBy == 0 || pDest->eDest != SRT_DistFifo);
	assert(p->pOrderBy == 0 || pDest->eDest != SRT_Fifo);
	assert(p->pOrderBy == 0 || pDest->eDest != SRT_DistQueue);
	assert(p->pOrderBy == 0 || pDest->eDest != SRT_Queue);
	if (IgnorableOrderby(pDest)) {
		assert(pDest->eDest == SRT_Exists || pDest->eDest == SRT_Union ||
			pDest->eDest == SRT_Except || pDest->eDest == SRT_Discard ||
			pDest->eDest == SRT_Queue || pDest->eDest == SRT_DistFifo ||
			pDest->eDest == SRT_DistQueue || pDest->eDest == SRT_Fifo);
		
		sqlite3ExprListDelete(db, p->pOrderBy);
		p->pOrderBy = 0;
		p->selFlags &= ~SF_Distinct;
	}
	sqlite3SelectPrep(pParse, p, 0);
	memset(&sSort, 0, sizeof(sSort));
	sSort.pOrderBy = p->pOrderBy;
	pTabList = p->pSrc;
	if (pParse->nErr || db->mallocFailed) {
		goto select_end;
	}
	assert(p->pEList != 0);
	isAgg = (p->selFlags & SF_Aggregate) != 0;
#if SELECTTRACE_ENABLED
	if (sqlite3SelectTrace & 0x100) {
		SELECTTRACE(0x100, pParse, p, ("after name resolution:\n"));
		sqlite3TreeViewSelect(0, p, 0);
	}
#endif

	
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
	for (i = 0; !p->pPrior && i<pTabList->nSrc; i++) {
		struct SrcList_item *pItem = &pTabList->a[i];
		Select *pSub = pItem->pSelect;
		int isAggSub;
		Table *pTab = pItem->pTab;
		if (pSub == 0) continue;

		
		if (pTab->nCol != pSub->pEList->nExpr) {
			sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",
				pTab->nCol, pTab->zName, pSub->pEList->nExpr);
			goto select_end;
		}

		isAggSub = (pSub->selFlags & SF_Aggregate) != 0;
		if (flattenSubquery(pParse, p, i, isAgg, isAggSub)) {
			
			if (isAggSub) {
				isAgg = 1;
				p->selFlags |= SF_Aggregate;
			}
			i = -1;
		}
		pTabList = p->pSrc;
		if (db->mallocFailed) goto select_end;
		if (!IgnorableOrderby(pDest)) {
			sSort.pOrderBy = p->pOrderBy;
		}
	}
#endif

	
	v = sqlite3GetVdbe(pParse);
	if (v == 0) goto select_end;

#ifndef SQLITE_OMIT_COMPOUND_SELECT
	
	if (p->pPrior) {
		rc = multiSelect(pParse, p, pDest);
		explainSetInteger(pParse->iSelectId, iRestoreSelectId);
#if SELECTTRACE_ENABLED
		SELECTTRACE(1, pParse, p, ("end compound-select processing\n"));
		pParse->nSelectIndent--;
#endif
		return rc;
	}
#endif

	
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
	for (i = 0; i<pTabList->nSrc; i++) {
		struct SrcList_item *pItem = &pTabList->a[i];
		SelectDest dest;
		Select *pSub = pItem->pSelect;
		if (pSub == 0) continue;

		
		if (pItem->addrFillSub) {
			if (pItem->fg.viaCoroutine == 0) {
				sqlite3VdbeAddOp2(v, OP_Gosub, pItem->regReturn, pItem->addrFillSub);
			}
			continue;
		}

		
		pParse->nHeight += sqlite3SelectExprHeight(p);

		
		if ((pItem->fg.jointype & JT_OUTER) == 0
			&& pushDownWhereTerms(db, pSub, p->pWhere, pItem->iCursor)
			) {
#if SELECTTRACE_ENABLED
			if (sqlite3SelectTrace & 0x100) {
				SELECTTRACE(0x100, pParse, p, ("After WHERE-clause push-down:\n"));
				sqlite3TreeViewSelect(0, p, 0);
			}
#endif
		}

		
		if (i == 0
			&& (pTabList->nSrc == 1
				|| (pTabList->a[1].fg.jointype&(JT_LEFT | JT_CROSS)) != 0)  
			&& (p->selFlags & SF_All) == 0                                   
			&& OptimizationEnabled(db, SQLITE_SubqCoroutine)               
			) {
			
			int addrTop = sqlite3VdbeCurrentAddr(v) + 1;
			pItem->regReturn = ++pParse->nMem;
			sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);
			VdbeComment((v, "%s", pItem->pTab->zName));
			pItem->addrFillSub = addrTop;
			sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);
			explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);
			sqlite3Select(pParse, pSub, &dest);
			pItem->pTab->nRowLogEst = pSub->nSelectRow;
			pItem->fg.viaCoroutine = 1;
			pItem->regResult = dest.iSdst;
			sqlite3VdbeEndCoroutine(v, pItem->regReturn);
			sqlite3VdbeJumpHere(v, addrTop - 1);
			sqlite3ClearTempRegCache(pParse);
		}
		else {
			
			int topAddr;
			int onceAddr = 0;
			int retAddr;
			assert(pItem->addrFillSub == 0);
			pItem->regReturn = ++pParse->nMem;
			topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
			pItem->addrFillSub = topAddr + 1;
			if (pItem->fg.isCorrelated == 0) {
				
				onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
				VdbeComment((v, "materialize \"%s\"", pItem->pTab->zName));
			}
			else {
				VdbeNoopComment((v, "materialize \"%s\"", pItem->pTab->zName));
			}
			sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);
			explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);
			sqlite3Select(pParse, pSub, &dest);
			pItem->pTab->nRowLogEst = pSub->nSelectRow;
			if (onceAddr) sqlite3VdbeJumpHere(v, onceAddr);
			retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);
			VdbeComment((v, "end %s", pItem->pTab->zName));
			sqlite3VdbeChangeP1(v, topAddr, retAddr);
			sqlite3ClearTempRegCache(pParse);
		}
		if (db->mallocFailed) goto select_end;
		pParse->nHeight -= sqlite3SelectExprHeight(p);
	}
#endif

	
	pEList = p->pEList;
	pWhere = p->pWhere;
	pGroupBy = p->pGroupBy;
	pHaving = p->pHaving;
	sDistinct.isTnct = (p->selFlags & SF_Distinct) != 0;

#if SELECTTRACE_ENABLED
	if (sqlite3SelectTrace & 0x400) {
		SELECTTRACE(0x400, pParse, p, ("After all FROM-clause analysis:\n"));
		sqlite3TreeViewSelect(0, p, 0);
	}
#endif

	
	if ((p->selFlags & (SF_Distinct | SF_Aggregate)) == SF_Distinct
		&& sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1) == 0
		) {
		p->selFlags &= ~SF_Distinct;
		pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);
		
		assert(sDistinct.isTnct);

#if SELECTTRACE_ENABLED
		if (sqlite3SelectTrace & 0x400) {
			SELECTTRACE(0x400, pParse, p, ("Transform DISTINCT into GROUP BY:\n"));
			sqlite3TreeViewSelect(0, p, 0);
		}
#endif
	}

	
	if (sSort.pOrderBy) {
		KeyInfo *pKeyInfo;
		pKeyInfo = keyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList->nExpr);
		sSort.iECursor = pParse->nTab++;
		sSort.addrSortIndex =
			sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
				sSort.iECursor, sSort.pOrderBy->nExpr + 1 + pEList->nExpr, 0,
				(char*)pKeyInfo, P4_KEYINFO
			);
	}
	else {
		sSort.addrSortIndex = -1;
	}

	
	if (pDest->eDest == SRT_EphemTab) {
		sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);
	}

	
	iEnd = sqlite3VdbeMakeLabel(v);
	p->nSelectRow = 320;  
	computeLimitRegisters(pParse, p, iEnd);
	if (p->iLimit == 0 && sSort.addrSortIndex >= 0) {
		sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);
		sSort.sortFlags |= SORTFLAG_UseSorter;
	}

	
	if (p->selFlags & SF_Distinct) {
		sDistinct.tabTnct = pParse->nTab++;
		sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
			sDistinct.tabTnct, 0, 0,
			(char*)keyInfoFromExprList(pParse, p->pEList, 0, 0),
			P4_KEYINFO);
		sqlite3VdbeChangeP5(v, BTREE_UNORDERED);
		sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;
	}
	else {
		sDistinct.eTnctType = WHERE_DISTINCT_NOOP;
	}

	if (!isAgg && pGroupBy == 0) {
		
		u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0);
		assert(WHERE_USE_LIMIT == SF_FixedLimit);
		wctrlFlags |= p->selFlags & SF_FixedLimit;

		
		pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
			p->pEList, wctrlFlags, p->nSelectRow);
		if (pWInfo == 0) goto select_end;
		if (sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow) {
			p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
		}
		if (sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo)) {
			sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);
		}
		if (sSort.pOrderBy) {
			sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
			sSort.bOrderedInnerLoop = sqlite3WhereOrderedInnerLoop(pWInfo);
			if (sSort.nOBSat == sSort.pOrderBy->nExpr) {
				sSort.pOrderBy = 0;
			}
		}

		
		if (sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0) {
			sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
		}

		
		selectInnerLoop(pParse, p, pEList, -1, &sSort, &sDistinct, pDest,
			sqlite3WhereContinueLabel(pWInfo),
			sqlite3WhereBreakLabel(pWInfo));

		
		sqlite3WhereEnd(pWInfo);
	}
	else {
		
		NameContext sNC;    
		int iAMem;          
		int iBMem;          
		int iUseFlag;       
		int iAbortFlag;     
		int groupBySort;    
		int addrEnd;        
		int sortPTab = 0;   
		int sortOut = 0;    
		int orderByGrp = 0; 

							
		if (pGroupBy) {
			int k;                        
			struct ExprList_item *pItem;  

			for (k = p->pEList->nExpr, pItem = p->pEList->a; k>0; k--, pItem++) {
				pItem->u.x.iAlias = 0;
			}
			for (k = pGroupBy->nExpr, pItem = pGroupBy->a; k>0; k--, pItem++) {
				pItem->u.x.iAlias = 0;
			}
			assert(66 == sqlite3LogEst(100));
			if (p->nSelectRow>66) p->nSelectRow = 66;
		}
		else {
			assert(0 == sqlite3LogEst(1));
			p->nSelectRow = 0;
		}

		
		if (sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1) == 0) {
			orderByGrp = 1;
		}

		
		addrEnd = sqlite3VdbeMakeLabel(v);

		
		memset(&sNC, 0, sizeof(sNC));
		sNC.pParse = pParse;
		sNC.pSrcList = pTabList;
		sNC.pAggInfo = &sAggInfo;
		sAggInfo.mnReg = pParse->nMem + 1;
		sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;
		sAggInfo.pGroupBy = pGroupBy;
		sqlite3ExprAnalyzeAggList(&sNC, pEList);
		sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
		if (pHaving) {
			sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
		}
		sAggInfo.nAccumulator = sAggInfo.nColumn;
		for (i = 0; i<sAggInfo.nFunc; i++) {
			assert(!ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_xIsSelect));
			sNC.ncFlags |= NC_InAggFunc;
			sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->x.pList);
			sNC.ncFlags &= ~NC_InAggFunc;
		}
		sAggInfo.mxReg = pParse->nMem;
		if (db->mallocFailed) goto select_end;

		
		if (pGroupBy) {
			KeyInfo *pKeyInfo;  
			int addr1;          
			int addrOutputRow;  
			int regOutputRow;   
			int addrSetAbort;   
			int addrTopOfLoop;  
			int addrSortingIdx; 
			int addrReset;      
			int regReset;       

								
			sAggInfo.sortingIdx = pParse->nTab++;
			pKeyInfo = keyInfoFromExprList(pParse, pGroupBy, 0, sAggInfo.nColumn);
			addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen,
				sAggInfo.sortingIdx, sAggInfo.nSortingColumn,
				0, (char*)pKeyInfo, P4_KEYINFO);

			
			iUseFlag = ++pParse->nMem;
			iAbortFlag = ++pParse->nMem;
			regOutputRow = ++pParse->nMem;
			addrOutputRow = sqlite3VdbeMakeLabel(v);
			regReset = ++pParse->nMem;
			addrReset = sqlite3VdbeMakeLabel(v);
			iAMem = pParse->nMem + 1;
			pParse->nMem += pGroupBy->nExpr;
			iBMem = pParse->nMem + 1;
			pParse->nMem += pGroupBy->nExpr;
			sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);
			VdbeComment((v, "clear abort flag"));
			sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);
			VdbeComment((v, "indicate accumulator empty"));
			sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem + pGroupBy->nExpr - 1);

			
			sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
			pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,
				WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0
			);
			if (pWInfo == 0) goto select_end;
			if (sqlite3WhereIsOrdered(pWInfo) == pGroupBy->nExpr) {
				
				groupBySort = 0;
			}
			else {
				
				int regBase;
				int regRecord;
				int nCol;
				int nGroupBy;

				explainTempTable(pParse,
					(sDistinct.isTnct && (p->selFlags&SF_Distinct) == 0) ?
					"DISTINCT" : "GROUP BY");

				groupBySort = 1;
				nGroupBy = pGroupBy->nExpr;
				nCol = nGroupBy;
				j = nGroupBy;
				for (i = 0; i<sAggInfo.nColumn; i++) {
					if (sAggInfo.aCol[i].iSorterColumn >= j) {
						nCol++;
						j++;
					}
				}
				regBase = sqlite3GetTempRange(pParse, nCol);
				sqlite3ExprCacheClear(pParse);
				sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
				j = nGroupBy;
				for (i = 0; i<sAggInfo.nColumn; i++) {
					struct AggInfo_col *pCol = &sAggInfo.aCol[i];
					if (pCol->iSorterColumn >= j) {
						int r1 = j + regBase;
						sqlite3ExprCodeGetColumnToReg(pParse,
							pCol->pTab, pCol->iColumn, pCol->iTable, r1);
						j++;
					}
				}
				regRecord = sqlite3GetTempReg(pParse);
				sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);
				sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);
				sqlite3ReleaseTempReg(pParse, regRecord);
				sqlite3ReleaseTempRange(pParse, regBase, nCol);
				sqlite3WhereEnd(pWInfo);
				sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;
				sortOut = sqlite3GetTempReg(pParse);
				sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);
				sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);
				VdbeComment((v, "GROUP BY sort")); VdbeCoverage(v);
				sAggInfo.useSortingIdx = 1;
				sqlite3ExprCacheClear(pParse);

			}

			
			if (orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder)
				&& (groupBySort || sqlite3WhereIsSorted(pWInfo))
				) {
				sSort.pOrderBy = 0;
				sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
			}

			
			addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
			sqlite3ExprCacheClear(pParse);
			if (groupBySort) {
				sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,
					sortOut, sortPTab);
			}
			for (j = 0; j<pGroupBy->nExpr; j++) {
				if (groupBySort) {
					sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem + j);
				}
				else {
					sAggInfo.directMode = 1;
					sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem + j);
				}
			}
			sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,
				(char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
			addr1 = sqlite3VdbeCurrentAddr(v);
			sqlite3VdbeAddOp3(v, OP_Jump, addr1 + 1, 0, addr1 + 1); VdbeCoverage(v);

			
			sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
			sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
			VdbeComment((v, "output one row"));
			sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);
			VdbeComment((v, "check abort flag"));
			sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
			VdbeComment((v, "reset accumulator"));

			
			sqlite3VdbeJumpHere(v, addr1);
			updateAccumulator(pParse, &sAggInfo);
			sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);
			VdbeComment((v, "indicate data in accumulator"));

			
			if (groupBySort) {
				sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);
				VdbeCoverage(v);
			}
			else {
				sqlite3WhereEnd(pWInfo);
				sqlite3VdbeChangeToNoop(v, addrSortingIdx);
			}

			
			sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
			VdbeComment((v, "output final row"));

			
			sqlite3VdbeGoto(v, addrEnd);

			
			addrSetAbort = sqlite3VdbeCurrentAddr(v);
			sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);
			VdbeComment((v, "set abort flag"));
			sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
			sqlite3VdbeResolveLabel(v, addrOutputRow);
			addrOutputRow = sqlite3VdbeCurrentAddr(v);
			sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow + 2);
			VdbeCoverage(v);
			VdbeComment((v, "Groupby result generator entry point"));
			sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
			finalizeAggFunctions(pParse, &sAggInfo);
			sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow + 1, SQLITE_JUMPIFNULL);
			selectInnerLoop(pParse, p, p->pEList, -1, &sSort,
				&sDistinct, pDest,
				addrOutputRow + 1, addrSetAbort);
			sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
			VdbeComment((v, "end groupby result generator"));

			
			sqlite3VdbeResolveLabel(v, addrReset);
			resetAccumulator(pParse, &sAggInfo);
			sqlite3VdbeAddOp1(v, OP_Return, regReset);

		} 
		else {
			ExprList *pDel = 0;
#ifndef SQLITE_OMIT_BTREECOUNT
			Table *pTab;
			if ((pTab = isSimpleCount(p, &sAggInfo)) != 0) {
				
				const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
				const int iCsr = pParse->nTab++;     
				Index *pIdx;                         
				KeyInfo *pKeyInfo = 0;               
				Index *pBest = 0;                    
				int iRoot = pTab->tnum;              

				sqlite3CodeVerifySchema(pParse, iDb);
				sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

				
				if (!HasRowid(pTab)) pBest = sqlite3PrimaryKeyIndex(pTab);
				for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
					if (pIdx->bUnordered == 0
						&& pIdx->szIdxRow<pTab->szTabRow
						&& pIdx->pPartIdxWhere == 0
						&& (!pBest || pIdx->szIdxRow<pBest->szIdxRow)
						) {
						pBest = pIdx;
					}
				}
				if (pBest) {
					iRoot = pBest->tnum;
					pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
				}

				
				sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);
				if (pKeyInfo) {
					sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);
				}
				sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);
				sqlite3VdbeAddOp1(v, OP_Close, iCsr);
				explainSimpleCount(pParse, pTab, pBest);
			}
			else
#endif 
			{
				
				ExprList *pMinMax = 0;
				u8 flag = WHERE_ORDERBY_NORMAL;

				assert(p->pGroupBy == 0);
				assert(flag == 0);
				if (p->pHaving == 0) {
					flag = minMaxQuery(&sAggInfo, &pMinMax);
				}
				assert(flag == 0 || (pMinMax != 0 && pMinMax->nExpr == 1));

				if (flag) {
					pMinMax = sqlite3ExprListDup(db, pMinMax, 0);
					pDel = pMinMax;
					assert(db->mallocFailed || pMinMax != 0);
					if (!db->mallocFailed) {
						pMinMax->a[0].sortOrder = flag != WHERE_ORDERBY_MIN ? 1 : 0;
						pMinMax->a[0].pExpr->op = TK_COLUMN;
					}
				}

				
				resetAccumulator(pParse, &sAggInfo);
				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMax, 0, flag, 0);
				if (pWInfo == 0) {
					sqlite3ExprListDelete(db, pDel);
					goto select_end;
				}
				updateAccumulator(pParse, &sAggInfo);
				assert(pMinMax == 0 || pMinMax->nExpr == 1);
				if (sqlite3WhereIsOrdered(pWInfo)>0) {
					sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));
					VdbeComment((v, "%s() by index",
						(flag == WHERE_ORDERBY_MIN ? "min" : "max")));
				}
				sqlite3WhereEnd(pWInfo);
				finalizeAggFunctions(pParse, &sAggInfo);
			}

			sSort.pOrderBy = 0;
			sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);
			selectInnerLoop(pParse, p, p->pEList, -1, 0, 0,
				pDest, addrEnd, addrEnd);
			sqlite3ExprListDelete(db, pDel);
		}
		sqlite3VdbeResolveLabel(v, addrEnd);

	} 

	if (sDistinct.eTnctType == WHERE_DISTINCT_UNORDERED) {
		explainTempTable(pParse, "DISTINCT");
	}

	
	if (sSort.pOrderBy) {
		explainTempTable(pParse,
			sSort.nOBSat>0 ? "RIGHT PART OF ORDER BY" : "ORDER BY");
		generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);
	}

	
	sqlite3VdbeResolveLabel(v, iEnd);

	
	rc = (pParse->nErr>0);

	
select_end:
	explainSetInteger(pParse->iSelectId, iRestoreSelectId);

	
	if (rc == SQLITE_OK && pDest->eDest == SRT_Output) {
		generateColumnNames(pParse, pTabList, pEList);
	}

	sqlite3DbFree(db, sAggInfo.aCol);
	sqlite3DbFree(db, sAggInfo.aFunc);
#if SELECTTRACE_ENABLED
	SELECTTRACE(1, pParse, p, ("end processing\n"));
	pParse->nSelectIndent--;
#endif
	return rc;
}








#ifndef SQLITE_OMIT_GET_TABLE


typedef struct TabResult {
	char **azResult;   
	char *zErrMsg;     
	u32 nAlloc;        
	u32 nRow;          
	u32 nColumn;       
	u32 nData;         
	int rc;            
} TabResult;


static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv) {
	TabResult *p = (TabResult*)pArg;  
	int need;                         
	int i;                            
	char *z;                          

									  
	if (p->nRow == 0 && argv != 0) {
		need = nCol * 2;
	}
	else {
		need = nCol;
	}
	if (p->nData + need > p->nAlloc) {
		char **azNew;
		p->nAlloc = p->nAlloc * 2 + need;
		azNew = sqlite3_realloc64(p->azResult, sizeof(char*)*p->nAlloc);
		if (azNew == 0) goto malloc_failed;
		p->azResult = azNew;
	}

	
	if (p->nRow == 0) {
		p->nColumn = nCol;
		for (i = 0; i<nCol; i++) {
			z = sqlite3_mprintf("%s", colv[i]);
			if (z == 0) goto malloc_failed;
			p->azResult[p->nData++] = z;
		}
	}
	else if ((int)p->nColumn != nCol) {
		sqlite3_free(p->zErrMsg);
		p->zErrMsg = sqlite3_mprintf(
			"sqlite3_get_table() called with two or more incompatible queries"
		);
		p->rc = SQLITE_ERROR;
		return 1;
	}

	
	if (argv != 0) {
		for (i = 0; i<nCol; i++) {
			if (argv[i] == 0) {
				z = 0;
			}
			else {
				int n = sqlite3Strlen30(argv[i]) + 1;
				z = sqlite3_malloc64(n);
				if (z == 0) goto malloc_failed;
				memcpy(z, argv[i], n);
			}
			p->azResult[p->nData++] = z;
		}
		p->nRow++;
	}
	return 0;

malloc_failed:
	p->rc = SQLITE_NOMEM_BKPT;
	return 1;
}


SQLITE_API int sqlite3_get_table(
	sqlite3 *db,                
	const char *zSql,           
	char ***pazResult,          
	int *pnRow,                 
	int *pnColumn,              
	char **pzErrMsg             
) {
	int rc;
	TabResult res;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || pazResult == 0) return SQLITE_MISUSE_BKPT;
#endif
	*pazResult = 0;
	if (pnColumn) *pnColumn = 0;
	if (pnRow) *pnRow = 0;
	if (pzErrMsg) *pzErrMsg = 0;
	res.zErrMsg = 0;
	res.nRow = 0;
	res.nColumn = 0;
	res.nData = 1;
	res.nAlloc = 20;
	res.rc = SQLITE_OK;
	res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc);
	if (res.azResult == 0) {
		db->errCode = SQLITE_NOMEM;
		return SQLITE_NOMEM_BKPT;
	}
	res.azResult[0] = 0;
	rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
	assert(sizeof(res.azResult[0]) >= sizeof(res.nData));
	res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
	if ((rc & 0xff) == SQLITE_ABORT) {
		sqlite3_free_table(&res.azResult[1]);
		if (res.zErrMsg) {
			if (pzErrMsg) {
				sqlite3_free(*pzErrMsg);
				*pzErrMsg = sqlite3_mprintf("%s", res.zErrMsg);
			}
			sqlite3_free(res.zErrMsg);
		}
		db->errCode = res.rc;  
		return res.rc;
	}
	sqlite3_free(res.zErrMsg);
	if (rc != SQLITE_OK) {
		sqlite3_free_table(&res.azResult[1]);
		return rc;
	}
	if (res.nAlloc>res.nData) {
		char **azNew;
		azNew = sqlite3_realloc64(res.azResult, sizeof(char*)*res.nData);
		if (azNew == 0) {
			sqlite3_free_table(&res.azResult[1]);
			db->errCode = SQLITE_NOMEM;
			return SQLITE_NOMEM_BKPT;
		}
		res.azResult = azNew;
	}
	*pazResult = &res.azResult[1];
	if (pnColumn) *pnColumn = res.nColumn;
	if (pnRow) *pnRow = res.nRow;
	return rc;
}


SQLITE_API void sqlite3_free_table(
	char **azResult            
) {
	if (azResult) {
		int i, n;
		azResult--;
		assert(azResult != 0);
		n = SQLITE_PTR_TO_INT(azResult[0]);
		for (i = 1; i<n; i++) { if (azResult[i]) sqlite3_free(azResult[i]); }
		sqlite3_free(azResult);
	}
}

#endif 






#ifndef SQLITE_OMIT_TRIGGER

SQLITE_PRIVATE void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep) {
	while (pTriggerStep) {
		TriggerStep * pTmp = pTriggerStep;
		pTriggerStep = pTriggerStep->pNext;

		sqlite3ExprDelete(db, pTmp->pWhere);
		sqlite3ExprListDelete(db, pTmp->pExprList);
		sqlite3SelectDelete(db, pTmp->pSelect);
		sqlite3IdListDelete(db, pTmp->pIdList);

		sqlite3DbFree(db, pTmp);
	}
}


SQLITE_PRIVATE Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab) {
	Schema * const pTmpSchema = pParse->db->aDb[1].pSchema;
	Trigger *pList = 0;                  

	if (pParse->disableTriggers) {
		return 0;
	}

	if (pTmpSchema != pTab->pSchema) {
		HashElem *p;
		assert(sqlite3SchemaMutexHeld(pParse->db, 0, pTmpSchema));
		for (p = sqliteHashFirst(&pTmpSchema->trigHash); p; p = sqliteHashNext(p)) {
			Trigger *pTrig = (Trigger *)sqliteHashData(p);
			if (pTrig->pTabSchema == pTab->pSchema
				&& 0 == sqlite3StrICmp(pTrig->table, pTab->zName)
				) {
				pTrig->pNext = (pList ? pList : pTab->pTrigger);
				pList = pTrig;
			}
		}
	}

	return (pList ? pList : pTab->pTrigger);
}


SQLITE_PRIVATE void sqlite3BeginTrigger(
	Parse *pParse,      
	Token *pName1,      
	Token *pName2,      
	int tr_tm,          
	int op,             
	IdList *pColumns,   
	SrcList *pTableName,
	Expr *pWhen,        
	int isTemp,         
	int noErr           
) {
	Trigger *pTrigger = 0;  
	Table *pTab;            
	char *zName = 0;        
	sqlite3 *db = pParse->db;  
	int iDb;                
	Token *pName;           
	DbFixer sFix;           

	assert(pName1 != 0);   
	assert(pName2 != 0);
	assert(op == TK_INSERT || op == TK_UPDATE || op == TK_DELETE);
	assert(op>0 && op<0xff);
	if (isTemp) {
		
		if (pName2->n>0) {
			sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
			goto trigger_cleanup;
		}
		iDb = 1;
		pName = pName1;
	}
	else {
		
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
		if (iDb<0) {
			goto trigger_cleanup;
		}
	}
	if (!pTableName || db->mallocFailed) {
		goto trigger_cleanup;
	}

	
	if (db->init.busy && iDb != 1) {
		sqlite3DbFree(db, pTableName->a[0].zDatabase);
		pTableName->a[0].zDatabase = 0;
	}

	
	pTab = sqlite3SrcListLookup(pParse, pTableName);
	if (db->init.busy == 0 && pName2->n == 0 && pTab
		&& pTab->pSchema == db->aDb[1].pSchema) {
		iDb = 1;
	}

	
	if (db->mallocFailed) goto trigger_cleanup;
	assert(pTableName->nSrc == 1);
	sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName);
	if (sqlite3FixSrcList(&sFix, pTableName)) {
		goto trigger_cleanup;
	}
	pTab = sqlite3SrcListLookup(pParse, pTableName);
	if (!pTab) {
		
		if (db->init.iDb == 1) {
			
			db->init.orphanTrigger = 1;
		}
		goto trigger_cleanup;
	}
	if (IsVirtual(pTab)) {
		sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
		goto trigger_cleanup;
	}

	
	zName = sqlite3NameFromToken(db, pName);
	if (!zName || SQLITE_OK != sqlite3CheckObjectName(pParse, zName)) {
		goto trigger_cleanup;
	}
	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	if (sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash), zName)) {
		if (!noErr) {
			sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
		}
		else {
			assert(!db->init.busy);
			sqlite3CodeVerifySchema(pParse, iDb);
		}
		goto trigger_cleanup;
	}

	
	if (sqlite3StrNICmp(pTab->zName, "sqlite_", 7) == 0) {
		sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
		goto trigger_cleanup;
	}

	
	if (pTab->pSelect && tr_tm != TK_INSTEAD) {
		sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S",
			(tr_tm == TK_BEFORE) ? "BEFORE" : "AFTER", pTableName, 0);
		goto trigger_cleanup;
	}
	if (!pTab->pSelect && tr_tm == TK_INSTEAD) {
		sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF"
			" trigger on table: %S", pTableName, 0);
		goto trigger_cleanup;
	}

#ifndef SQLITE_OMIT_AUTHORIZATION
	{
		int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
		int code = SQLITE_CREATE_TRIGGER;
		const char *zDb = db->aDb[iTabDb].zDbSName;
		const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;
		if (iTabDb == 1 || isTemp) code = SQLITE_CREATE_TEMP_TRIGGER;
		if (sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig)) {
			goto trigger_cleanup;
		}
		if (sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb), 0, zDb)) {
			goto trigger_cleanup;
		}
	}
#endif

	
	if (tr_tm == TK_INSTEAD) {
		tr_tm = TK_BEFORE;
	}

	
	pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));
	if (pTrigger == 0) goto trigger_cleanup;
	pTrigger->zName = zName;
	zName = 0;
	pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);
	pTrigger->pSchema = db->aDb[iDb].pSchema;
	pTrigger->pTabSchema = pTab->pSchema;
	pTrigger->op = (u8)op;
	pTrigger->tr_tm = tr_tm == TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER;
	pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);
	pTrigger->pColumns = sqlite3IdListDup(db, pColumns);
	assert(pParse->pNewTrigger == 0);
	pParse->pNewTrigger = pTrigger;

trigger_cleanup:
	sqlite3DbFree(db, zName);
	sqlite3SrcListDelete(db, pTableName);
	sqlite3IdListDelete(db, pColumns);
	sqlite3ExprDelete(db, pWhen);
	if (!pParse->pNewTrigger) {
		sqlite3DeleteTrigger(db, pTrigger);
	}
	else {
		assert(pParse->pNewTrigger == pTrigger);
	}
}


SQLITE_PRIVATE void sqlite3FinishTrigger(
	Parse *pParse,          
	TriggerStep *pStepList, 
	Token *pAll             
) {
	Trigger *pTrig = pParse->pNewTrigger;   
	char *zName;                            
	sqlite3 *db = pParse->db;               
	DbFixer sFix;                           
	int iDb;                                
	Token nameToken;                        

	pParse->pNewTrigger = 0;
	if (NEVER(pParse->nErr) || !pTrig) goto triggerfinish_cleanup;
	zName = pTrig->zName;
	iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
	pTrig->step_list = pStepList;
	while (pStepList) {
		pStepList->pTrig = pTrig;
		pStepList = pStepList->pNext;
	}
	sqlite3TokenInit(&nameToken, pTrig->zName);
	sqlite3FixInit(&sFix, pParse, iDb, "trigger", &nameToken);
	if (sqlite3FixTriggerStep(&sFix, pTrig->step_list)
		|| sqlite3FixExpr(&sFix, pTrig->pWhen)
		) {
		goto triggerfinish_cleanup;
	}

	
	if (!db->init.busy) {
		Vdbe *v;
		char *z;

		
		v = sqlite3GetVdbe(pParse);
		if (v == 0) goto triggerfinish_cleanup;
		sqlite3BeginWriteOperation(pParse, 0, iDb);
		z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);
		sqlite3NestedParse(pParse,
			"INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb), zName,
			pTrig->table, z);
		sqlite3DbFree(db, z);
		sqlite3ChangeCookie(pParse, iDb);
		sqlite3VdbeAddParseSchemaOp(v, iDb,
			sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName));
	}

	if (db->init.busy) {
		Trigger *pLink = pTrig;
		Hash *pHash = &db->aDb[iDb].pSchema->trigHash;
		assert(sqlite3SchemaMutexHeld(db, iDb, 0));
		pTrig = sqlite3HashInsert(pHash, zName, pTrig);
		if (pTrig) {
			sqlite3OomFault(db);
		}
		else if (pLink->pSchema == pLink->pTabSchema) {
			Table *pTab;
			pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);
			assert(pTab != 0);
			pLink->pNext = pTab->pTrigger;
			pTab->pTrigger = pLink;
		}
	}

triggerfinish_cleanup:
	sqlite3DeleteTrigger(db, pTrig);
	assert(!pParse->pNewTrigger);
	sqlite3DeleteTriggerStep(db, pStepList);
}


SQLITE_PRIVATE TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect) {
	TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));
	if (pTriggerStep == 0) {
		sqlite3SelectDelete(db, pSelect);
		return 0;
	}
	pTriggerStep->op = TK_SELECT;
	pTriggerStep->pSelect = pSelect;
	pTriggerStep->orconf = OE_Default;
	return pTriggerStep;
}


static TriggerStep *triggerStepAllocate(
	sqlite3 *db,                
	u8 op,                      
	Token *pName                
) {
	TriggerStep *pTriggerStep;

	pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);
	if (pTriggerStep) {
		char *z = (char*)&pTriggerStep[1];
		memcpy(z, pName->z, pName->n);
		sqlite3Dequote(z);
		pTriggerStep->zTarget = z;
		pTriggerStep->op = op;
	}
	return pTriggerStep;
}


SQLITE_PRIVATE TriggerStep *sqlite3TriggerInsertStep(
	sqlite3 *db,        
	Token *pTableName,  
	IdList *pColumn,    
	Select *pSelect,    
	u8 orconf           
) {
	TriggerStep *pTriggerStep;

	assert(pSelect != 0 || db->mallocFailed);

	pTriggerStep = triggerStepAllocate(db, TK_INSERT, pTableName);
	if (pTriggerStep) {
		pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
		pTriggerStep->pIdList = pColumn;
		pTriggerStep->orconf = orconf;
	}
	else {
		sqlite3IdListDelete(db, pColumn);
	}
	sqlite3SelectDelete(db, pSelect);

	return pTriggerStep;
}


SQLITE_PRIVATE TriggerStep *sqlite3TriggerUpdateStep(
	sqlite3 *db,         
	Token *pTableName,   
	ExprList *pEList,    
	Expr *pWhere,        
	u8 orconf            
) {
	TriggerStep *pTriggerStep;

	pTriggerStep = triggerStepAllocate(db, TK_UPDATE, pTableName);
	if (pTriggerStep) {
		pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);
		pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);
		pTriggerStep->orconf = orconf;
	}
	sqlite3ExprListDelete(db, pEList);
	sqlite3ExprDelete(db, pWhere);
	return pTriggerStep;
}


SQLITE_PRIVATE TriggerStep *sqlite3TriggerDeleteStep(
	sqlite3 *db,            
	Token *pTableName,      
	Expr *pWhere            
) {
	TriggerStep *pTriggerStep;

	pTriggerStep = triggerStepAllocate(db, TK_DELETE, pTableName);
	if (pTriggerStep) {
		pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);
		pTriggerStep->orconf = OE_Default;
	}
	sqlite3ExprDelete(db, pWhere);
	return pTriggerStep;
}


SQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger) {
	if (pTrigger == 0) return;
	sqlite3DeleteTriggerStep(db, pTrigger->step_list);
	sqlite3DbFree(db, pTrigger->zName);
	sqlite3DbFree(db, pTrigger->table);
	sqlite3ExprDelete(db, pTrigger->pWhen);
	sqlite3IdListDelete(db, pTrigger->pColumns);
	sqlite3DbFree(db, pTrigger);
}


SQLITE_PRIVATE void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr) {
	Trigger *pTrigger = 0;
	int i;
	const char *zDb;
	const char *zName;
	sqlite3 *db = pParse->db;

	if (db->mallocFailed) goto drop_trigger_cleanup;
	if (SQLITE_OK != sqlite3ReadSchema(pParse)) {
		goto drop_trigger_cleanup;
	}

	assert(pName->nSrc == 1);
	zDb = pName->a[0].zDatabase;
	zName = pName->a[0].zName;
	assert(zDb != 0 || sqlite3BtreeHoldsAllMutexes(db));
	for (i = OMIT_TEMPDB; i<db->nDb; i++) {
		int j = (i<2) ? i ^ 1 : i;  
		if (zDb && sqlite3StrICmp(db->aDb[j].zDbSName, zDb)) continue;
		assert(sqlite3SchemaMutexHeld(db, j, 0));
		pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);
		if (pTrigger) break;
	}
	if (!pTrigger) {
		if (!noErr) {
			sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0);
		}
		else {
			sqlite3CodeVerifyNamedSchema(pParse, zDb);
		}
		pParse->checkSchema = 1;
		goto drop_trigger_cleanup;
	}
	sqlite3DropTriggerPtr(pParse, pTrigger);

drop_trigger_cleanup:
	sqlite3SrcListDelete(db, pName);
}


static Table *tableOfTrigger(Trigger *pTrigger) {
	return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table);
}



SQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger) {
	Table   *pTable;
	Vdbe *v;
	sqlite3 *db = pParse->db;
	int iDb;

	iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
	assert(iDb >= 0 && iDb<db->nDb);
	pTable = tableOfTrigger(pTrigger);
	assert(pTable);
	assert(pTable->pSchema == pTrigger->pSchema || iDb == 1);
#ifndef SQLITE_OMIT_AUTHORIZATION
	{
		int code = SQLITE_DROP_TRIGGER;
		const char *zDb = db->aDb[iDb].zDbSName;
		const char *zTab = SCHEMA_TABLE(iDb);
		if (iDb == 1) code = SQLITE_DROP_TEMP_TRIGGER;
		if (sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
			sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)) {
			return;
		}
	}
#endif

	
	assert(pTable != 0);
	if ((v = sqlite3GetVdbe(pParse)) != 0) {
		sqlite3NestedParse(pParse,
			"DELETE FROM %Q.%s WHERE name=%Q AND type='trigger'",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb), pTrigger->zName
		);
		sqlite3ChangeCookie(pParse, iDb);
		sqlite3VdbeAddOp4(v, OP_DropTrigger, iDb, 0, 0, pTrigger->zName, 0);
	}
}


SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName) {
	Trigger *pTrigger;
	Hash *pHash;

	assert(sqlite3SchemaMutexHeld(db, iDb, 0));
	pHash = &(db->aDb[iDb].pSchema->trigHash);
	pTrigger = sqlite3HashInsert(pHash, zName, 0);
	if (ALWAYS(pTrigger)) {
		if (pTrigger->pSchema == pTrigger->pTabSchema) {
			Table *pTab = tableOfTrigger(pTrigger);
			Trigger **pp;
			for (pp = &pTab->pTrigger; *pp != pTrigger; pp = &((*pp)->pNext));
			*pp = (*pp)->pNext;
		}
		sqlite3DeleteTrigger(db, pTrigger);
		db->flags |= SQLITE_InternChanges;
	}
}


static int checkColumnOverlap(IdList *pIdList, ExprList *pEList) {
	int e;
	if (pIdList == 0 || NEVER(pEList == 0)) return 1;
	for (e = 0; e<pEList->nExpr; e++) {
		if (sqlite3IdListIndex(pIdList, pEList->a[e].zName) >= 0) return 1;
	}
	return 0;
}


SQLITE_PRIVATE Trigger *sqlite3TriggersExist(
	Parse *pParse,          
	Table *pTab,            
	int op,                 
	ExprList *pChanges,     
	int *pMask              
) {
	int mask = 0;
	Trigger *pList = 0;
	Trigger *p;

	if ((pParse->db->flags & SQLITE_EnableTrigger) != 0) {
		pList = sqlite3TriggerList(pParse, pTab);
	}
	assert(pList == 0 || IsVirtual(pTab) == 0);
	for (p = pList; p; p = p->pNext) {
		if (p->op == op && checkColumnOverlap(p->pColumns, pChanges)) {
			mask |= p->tr_tm;
		}
	}
	if (pMask) {
		*pMask = mask;
	}
	return (mask ? pList : 0);
}


static SrcList *targetSrcList(
	Parse *pParse,       
	TriggerStep *pStep   
) {
	sqlite3 *db = pParse->db;
	int iDb;             
	SrcList *pSrc;       

	pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
	if (pSrc) {
		assert(pSrc->nSrc>0);
		pSrc->a[pSrc->nSrc - 1].zName = sqlite3DbStrDup(db, pStep->zTarget);
		iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);
		if (iDb == 0 || iDb >= 2) {
			const char *zDb;
			assert(iDb<db->nDb);
			zDb = db->aDb[iDb].zDbSName;
			pSrc->a[pSrc->nSrc - 1].zDatabase = sqlite3DbStrDup(db, zDb);
		}
	}
	return pSrc;
}


static int codeTriggerProgram(
	Parse *pParse,            
	TriggerStep *pStepList,   
	int orconf                
) {
	TriggerStep *pStep;
	Vdbe *v = pParse->pVdbe;
	sqlite3 *db = pParse->db;

	assert(pParse->pTriggerTab && pParse->pToplevel);
	assert(pStepList);
	assert(v != 0);
	for (pStep = pStepList; pStep; pStep = pStep->pNext) {
		
		pParse->eOrconf = (orconf == OE_Default) ? pStep->orconf : (u8)orconf;
		assert(pParse->okConstFactor == 0);

		switch (pStep->op) {
		case TK_UPDATE: {
			sqlite3Update(pParse,
				targetSrcList(pParse, pStep),
				sqlite3ExprListDup(db, pStep->pExprList, 0),
				sqlite3ExprDup(db, pStep->pWhere, 0),
				pParse->eOrconf
			);
			break;
		}
		case TK_INSERT: {
			sqlite3Insert(pParse,
				targetSrcList(pParse, pStep),
				sqlite3SelectDup(db, pStep->pSelect, 0),
				sqlite3IdListDup(db, pStep->pIdList),
				pParse->eOrconf
			);
			break;
		}
		case TK_DELETE: {
			sqlite3DeleteFrom(pParse,
				targetSrcList(pParse, pStep),
				sqlite3ExprDup(db, pStep->pWhere, 0)
			);
			break;
		}
		default: assert(pStep->op == TK_SELECT); {
			SelectDest sDest;
			Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);
			sqlite3SelectDestInit(&sDest, SRT_Discard, 0);
			sqlite3Select(pParse, pSelect, &sDest);
			sqlite3SelectDelete(db, pSelect);
			break;
		}
		}
		if (pStep->op != TK_SELECT) {
			sqlite3VdbeAddOp0(v, OP_ResetCount);
		}
	}

	return 0;
}

#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS

static const char *onErrorText(int onError) {
	switch (onError) {
	case OE_Abort:    return "abort";
	case OE_Rollback: return "rollback";
	case OE_Fail:     return "fail";
	case OE_Replace:  return "replace";
	case OE_Ignore:   return "ignore";
	case OE_Default:  return "default";
	}
	return "n/a";
}
#endif


static void transferParseError(Parse *pTo, Parse *pFrom) {
	assert(pFrom->zErrMsg == 0 || pFrom->nErr);
	assert(pTo->zErrMsg == 0 || pTo->nErr);
	if (pTo->nErr == 0) {
		pTo->zErrMsg = pFrom->zErrMsg;
		pTo->nErr = pFrom->nErr;
		pTo->rc = pFrom->rc;
	}
	else {
		sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
	}
}


static TriggerPrg *codeRowTrigger(
	Parse *pParse,       
	Trigger *pTrigger,   
	Table *pTab,         
	int orconf           
) {
	Parse *pTop = sqlite3ParseToplevel(pParse);
	sqlite3 *db = pParse->db;   
	TriggerPrg *pPrg;           
	Expr *pWhen = 0;            
	Vdbe *v;                    
	NameContext sNC;            
	SubProgram *pProgram = 0;   
	Parse *pSubParse;           
	int iEndTrigger = 0;        

	assert(pTrigger->zName == 0 || pTab == tableOfTrigger(pTrigger));
	assert(pTop->pVdbe);

	
	pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));
	if (!pPrg) return 0;
	pPrg->pNext = pTop->pTriggerPrg;
	pTop->pTriggerPrg = pPrg;
	pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));
	if (!pProgram) return 0;
	sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
	pPrg->pTrigger = pTrigger;
	pPrg->orconf = orconf;
	pPrg->aColmask[0] = 0xffffffff;
	pPrg->aColmask[1] = 0xffffffff;

	
	pSubParse = sqlite3StackAllocZero(db, sizeof(Parse));
	if (!pSubParse) return 0;
	memset(&sNC, 0, sizeof(sNC));
	sNC.pParse = pSubParse;
	pSubParse->db = db;
	pSubParse->pTriggerTab = pTab;
	pSubParse->pToplevel = pTop;
	pSubParse->zAuthContext = pTrigger->zName;
	pSubParse->eTriggerOp = pTrigger->op;
	pSubParse->nQueryLoop = pParse->nQueryLoop;

	v = sqlite3GetVdbe(pSubParse);
	if (v) {
		VdbeComment((v, "Start: %s.%s (%s %s%s%s ON %s)",
			pTrigger->zName, onErrorText(orconf),
			(pTrigger->tr_tm == TRIGGER_BEFORE ? "BEFORE" : "AFTER"),
			(pTrigger->op == TK_UPDATE ? "UPDATE" : ""),
			(pTrigger->op == TK_INSERT ? "INSERT" : ""),
			(pTrigger->op == TK_DELETE ? "DELETE" : ""),
			pTab->zName
			));
#ifndef SQLITE_OMIT_TRACE
		sqlite3VdbeChangeP4(v, -1,
			sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), P4_DYNAMIC
		);
#endif

		
		if (pTrigger->pWhen) {
			pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
			if (SQLITE_OK == sqlite3ResolveExprNames(&sNC, pWhen)
				&& db->mallocFailed == 0
				) {
				iEndTrigger = sqlite3VdbeMakeLabel(v);
				sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, SQLITE_JUMPIFNULL);
			}
			sqlite3ExprDelete(db, pWhen);
		}

		
		codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);

		
		if (iEndTrigger) {
			sqlite3VdbeResolveLabel(v, iEndTrigger);
		}
		sqlite3VdbeAddOp0(v, OP_Halt);
		VdbeComment((v, "End: %s.%s", pTrigger->zName, onErrorText(orconf)));

		transferParseError(pParse, pSubParse);
		if (db->mallocFailed == 0) {
			pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);
		}
		pProgram->nMem = pSubParse->nMem;
		pProgram->nCsr = pSubParse->nTab;
		pProgram->token = (void *)pTrigger;
		pPrg->aColmask[0] = pSubParse->oldmask;
		pPrg->aColmask[1] = pSubParse->newmask;
		sqlite3VdbeDelete(v);
	}

	assert(!pSubParse->pAinc && !pSubParse->pZombieTab);
	assert(!pSubParse->pTriggerPrg && !pSubParse->nMaxArg);
	sqlite3ParserReset(pSubParse);
	sqlite3StackFree(db, pSubParse);

	return pPrg;
}


static TriggerPrg *getRowTrigger(
	Parse *pParse,       
	Trigger *pTrigger,   
	Table *pTab,         
	int orconf           
) {
	Parse *pRoot = sqlite3ParseToplevel(pParse);
	TriggerPrg *pPrg;

	assert(pTrigger->zName == 0 || pTab == tableOfTrigger(pTrigger));

	
	for (pPrg = pRoot->pTriggerPrg;
		pPrg && (pPrg->pTrigger != pTrigger || pPrg->orconf != orconf);
		pPrg = pPrg->pNext
		);

	
	if (!pPrg) {
		pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);
	}

	return pPrg;
}


SQLITE_PRIVATE void sqlite3CodeRowTriggerDirect(
	Parse *pParse,       
	Trigger *p,          
	Table *pTab,         
	int reg,             
	int orconf,          
	int ignoreJump       
) {
	Vdbe *v = sqlite3GetVdbe(pParse); 
	TriggerPrg *pPrg;
	pPrg = getRowTrigger(pParse, p, pTab, orconf);
	assert(pPrg || pParse->nErr || pParse->db->mallocFailed);

	
	if (pPrg) {
		int bRecursive = (p->zName && 0 == (pParse->db->flags&SQLITE_RecTriggers));

		sqlite3VdbeAddOp4(v, OP_Program, reg, ignoreJump, ++pParse->nMem,
			(const char *)pPrg->pProgram, P4_SUBPROGRAM);
		VdbeComment(
			(v, "Call: %s.%s", (p->zName ? p->zName : "fkey"), onErrorText(orconf)));

		
		sqlite3VdbeChangeP5(v, (u8)bRecursive);
	}
}


SQLITE_PRIVATE void sqlite3CodeRowTrigger(
	Parse *pParse,       
	Trigger *pTrigger,   
	int op,              
	ExprList *pChanges,  
	int tr_tm,           
	Table *pTab,         
	int reg,             
	int orconf,          
	int ignoreJump       
) {
	Trigger *p;          

	assert(op == TK_UPDATE || op == TK_INSERT || op == TK_DELETE);
	assert(tr_tm == TRIGGER_BEFORE || tr_tm == TRIGGER_AFTER);
	assert((op == TK_UPDATE) == (pChanges != 0));

	for (p = pTrigger; p; p = p->pNext) {

		
		assert(p->pSchema != 0);
		assert(p->pTabSchema != 0);
		assert(p->pSchema == p->pTabSchema
			|| p->pSchema == pParse->db->aDb[1].pSchema);

		
		if (p->op == op
			&& p->tr_tm == tr_tm
			&& checkColumnOverlap(p->pColumns, pChanges)
			) {
			sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
		}
	}
}


SQLITE_PRIVATE u32 sqlite3TriggerColmask(
	Parse *pParse,       
	Trigger *pTrigger,   
	ExprList *pChanges,  
	int isNew,           
	int tr_tm,           
	Table *pTab,         
	int orconf           
) {
	const int op = pChanges ? TK_UPDATE : TK_DELETE;
	u32 mask = 0;
	Trigger *p;

	assert(isNew == 1 || isNew == 0);
	for (p = pTrigger; p; p = p->pNext) {
		if (p->op == op && (tr_tm&p->tr_tm)
			&& checkColumnOverlap(p->pColumns, pChanges)
			) {
			TriggerPrg *pPrg;
			pPrg = getRowTrigger(pParse, p, pTab, orconf);
			if (pPrg) {
				mask |= pPrg->aColmask[isNew];
			}
		}
	}

	return mask;
}

#endif 






#ifndef SQLITE_OMIT_VIRTUALTABLE

static void updateVirtualTable(
	Parse *pParse,       
	SrcList *pSrc,       
	Table *pTab,         
	ExprList *pChanges,  
	Expr *pRowidExpr,    
	int *aXRef,          
	Expr *pWhere,        
	int onError          
);
#endif 


SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg) {
	assert(pTab != 0);
	if (!pTab->pSelect) {
		sqlite3_value *pValue = 0;
		u8 enc = ENC(sqlite3VdbeDb(v));
		Column *pCol = &pTab->aCol[i];
		VdbeComment((v, "%s.%s", pTab->zName, pCol->zName));
		assert(i<pTab->nCol);
		sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc,
			pCol->affinity, &pValue);
		if (pValue) {
			sqlite3VdbeChangeP4(v, -1, (const char *)pValue, P4_MEM);
		}
#ifndef SQLITE_OMIT_FLOATING_POINT
		if (pTab->aCol[i].affinity == SQLITE_AFF_REAL) {
			sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);
		}
#endif
	}
}


SQLITE_PRIVATE void sqlite3Update(
	Parse *pParse,         
	SrcList *pTabList,     
	ExprList *pChanges,    
	Expr *pWhere,          
	int onError            
) {
	int i, j;              
	Table *pTab;           
	int addrTop = 0;       
	WhereInfo *pWInfo;     
	Vdbe *v;               
	Index *pIdx;           
	Index *pPk;            
	int nIdx;              
	int iBaseCur;          
	int iDataCur;          
	int iIdxCur;           
	sqlite3 *db;           
	int *aRegIdx = 0;      
	int *aXRef = 0;        
	u8 *aToOpen;           
	u8 chngPk;             
	u8 chngRowid;          
	u8 chngKey;            
	Expr *pRowidExpr = 0;  
	AuthContext sContext;  
	NameContext sNC;       
	int iDb;               
	int okOnePass;         
	int hasFK;             
	int labelBreak;        
	int labelContinue;     

#ifndef SQLITE_OMIT_TRIGGER
	int isView;            
	Trigger *pTrigger;     
	int tmask;             
#endif
	int newmask;           
	int iEph = 0;          
	int nKey = 0;          
	int aiCurOnePass[2];   

						   
	int regRowCount = 0;   
	int regOldRowid = 0;   
	int regNewRowid = 0;   
	int regNew = 0;        
	int regOld = 0;        
	int regRowSet = 0;     
	int regKey = 0;        

	memset(&sContext, 0, sizeof(sContext));
	db = pParse->db;
	if (pParse->nErr || db->mallocFailed) {
		goto update_cleanup;
	}
	assert(pTabList->nSrc == 1);

	
	pTab = sqlite3SrcListLookup(pParse, pTabList);
	if (pTab == 0) goto update_cleanup;
	iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);

	
#ifndef SQLITE_OMIT_TRIGGER
	pTrigger = sqlite3TriggersExist(pParse, pTab, TK_UPDATE, pChanges, &tmask);
	isView = pTab->pSelect != 0;
	assert(pTrigger || tmask == 0);
#else
# define pTrigger 0
# define isView 0
# define tmask 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif

	if (sqlite3ViewGetColumnNames(pParse, pTab)) {
		goto update_cleanup;
	}
	if (sqlite3IsReadOnly(pParse, pTab, tmask)) {
		goto update_cleanup;
	}

	
	pTabList->a[0].iCursor = iBaseCur = iDataCur = pParse->nTab++;
	iIdxCur = iDataCur + 1;
	pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
	for (nIdx = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, nIdx++) {
		if (IsPrimaryKeyIndex(pIdx) && pPk != 0) {
			iDataCur = pParse->nTab;
			pTabList->a[0].iCursor = iDataCur;
		}
		pParse->nTab++;
	}

	
	aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol + nIdx) + nIdx + 2);
	if (aXRef == 0) goto update_cleanup;
	aRegIdx = aXRef + pTab->nCol;
	aToOpen = (u8*)(aRegIdx + nIdx);
	memset(aToOpen, 1, nIdx + 1);
	aToOpen[nIdx + 1] = 0;
	for (i = 0; i<pTab->nCol; i++) aXRef[i] = -1;

	
	memset(&sNC, 0, sizeof(sNC));
	sNC.pParse = pParse;
	sNC.pSrcList = pTabList;

	
	chngRowid = chngPk = 0;
	for (i = 0; i<pChanges->nExpr; i++) {
		if (sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr)) {
			goto update_cleanup;
		}
		for (j = 0; j<pTab->nCol; j++) {
			if (sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName) == 0) {
				if (j == pTab->iPKey) {
					chngRowid = 1;
					pRowidExpr = pChanges->a[i].pExpr;
				}
				else if (pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY) != 0) {
					chngPk = 1;
				}
				aXRef[j] = i;
				break;
			}
		}
		if (j >= pTab->nCol) {
			if (pPk == 0 && sqlite3IsRowid(pChanges->a[i].zName)) {
				j = -1;
				chngRowid = 1;
				pRowidExpr = pChanges->a[i].pExpr;
			}
			else {
				sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
				pParse->checkSchema = 1;
				goto update_cleanup;
			}
		}
#ifndef SQLITE_OMIT_AUTHORIZATION
		{
			int rc;
			rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,
				j<0 ? "ROWID" : pTab->aCol[j].zName,
				db->aDb[iDb].zDbSName);
			if (rc == SQLITE_DENY) {
				goto update_cleanup;
			}
			else if (rc == SQLITE_IGNORE) {
				aXRef[j] = -1;
			}
		}
#endif
	}
	assert((chngRowid & chngPk) == 0);
	assert(chngRowid == 0 || chngRowid == 1);
	assert(chngPk == 0 || chngPk == 1);
	chngKey = chngRowid + chngPk;

	
	pTabList->a[0].colUsed = IsVirtual(pTab) ? ALLBITS : 0;

	hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);

	
	for (j = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, j++) {
		int reg;
		if (chngKey || hasFK || pIdx->pPartIdxWhere || pIdx == pPk) {
			reg = ++pParse->nMem;
		}
		else {
			reg = 0;
			for (i = 0; i<pIdx->nKeyCol; i++) {
				i16 iIdxCol = pIdx->aiColumn[i];
				if (iIdxCol<0 || aXRef[iIdxCol] >= 0) {
					reg = ++pParse->nMem;
					break;
				}
			}
		}
		if (reg == 0) aToOpen[j + 1] = 0;
		aRegIdx[j] = reg;
	}

	
	v = sqlite3GetVdbe(pParse);
	if (v == 0) goto update_cleanup;
	if (pParse->nested == 0) sqlite3VdbeCountChanges(v);
	sqlite3BeginWriteOperation(pParse, 1, iDb);

	
	if (!IsVirtual(pTab)) {
		regRowSet = ++pParse->nMem;
		regOldRowid = regNewRowid = ++pParse->nMem;
		if (chngPk || pTrigger || hasFK) {
			regOld = pParse->nMem + 1;
			pParse->nMem += pTab->nCol;
		}
		if (chngKey || pTrigger || hasFK) {
			regNewRowid = ++pParse->nMem;
		}
		regNew = pParse->nMem + 1;
		pParse->nMem += pTab->nCol;
	}

	
	if (isView) {
		sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
	}

	
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
	if (isView) {
		sqlite3MaterializeView(pParse, pTab, pWhere, iDataCur);
	}
#endif

	
	if (sqlite3ResolveExprNames(&sNC, pWhere)) {
		goto update_cleanup;
	}

#ifndef SQLITE_OMIT_VIRTUALTABLE
	
	if (IsVirtual(pTab)) {
		updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
			pWhere, onError);
		goto update_cleanup;
	}
#endif

	
	if (HasRowid(pTab)) {
		sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);
		pWInfo = sqlite3WhereBegin(
			pParse, pTabList, pWhere, 0, 0,
			WHERE_ONEPASS_DESIRED | WHERE_SEEK_TABLE, iIdxCur
		);
		if (pWInfo == 0) goto update_cleanup;
		okOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);

		
		sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);
		if (!okOnePass) {
			sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);
		}

		
		sqlite3WhereEnd(pWInfo);
	}
	else {
		int iPk;         
		i16 nPk;         
		int addrOpen;    

		assert(pPk != 0);
		nPk = pPk->nKeyCol;
		iPk = pParse->nMem + 1;
		pParse->nMem += nPk;
		regKey = ++pParse->nMem;
		iEph = pParse->nTab++;
		sqlite3VdbeAddOp2(v, OP_Null, 0, iPk);
		addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nPk);
		sqlite3VdbeSetP4KeyInfo(pParse, pPk);
		pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0,
			WHERE_ONEPASS_DESIRED, iIdxCur);
		if (pWInfo == 0) goto update_cleanup;
		okOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
		for (i = 0; i<nPk; i++) {
			assert(pPk->aiColumn[i] >= 0);
			sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pPk->aiColumn[i],
				iPk + i);
		}
		if (okOnePass) {
			sqlite3VdbeChangeToNoop(v, addrOpen);
			nKey = nPk;
			regKey = iPk;
		}
		else {
			sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,
				sqlite3IndexAffinityStr(db, pPk), nPk);
			sqlite3VdbeAddOp2(v, OP_IdxInsert, iEph, regKey);
		}
		sqlite3WhereEnd(pWInfo);
	}

	
	if ((db->flags & SQLITE_CountRows) && !pParse->pTriggerTab) {
		regRowCount = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);
	}

	labelBreak = sqlite3VdbeMakeLabel(v);
	if (!isView) {
		
		if (onError == OE_Replace) {
			memset(aToOpen, 1, nIdx + 1);
		}
		else {
			for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
				if (pIdx->onError == OE_Replace) {
					memset(aToOpen, 1, nIdx + 1);
					break;
				}
			}
		}
		if (okOnePass) {
			if (aiCurOnePass[0] >= 0) aToOpen[aiCurOnePass[0] - iBaseCur] = 0;
			if (aiCurOnePass[1] >= 0) aToOpen[aiCurOnePass[1] - iBaseCur] = 0;
		}
		sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, iBaseCur, aToOpen,
			0, 0);
	}

	
	if (okOnePass) {
		if (aToOpen[iDataCur - iBaseCur] && !isView) {
			assert(pPk);
			sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelBreak, regKey, nKey);
			VdbeCoverageNeverTaken(v);
		}
		labelContinue = labelBreak;
		sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);
		VdbeCoverageIf(v, pPk == 0);
		VdbeCoverageIf(v, pPk != 0);
	}
	else if (pPk) {
		labelContinue = sqlite3VdbeMakeLabel(v);
		sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);
		addrTop = sqlite3VdbeAddOp2(v, OP_RowKey, iEph, regKey);
		sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, 0);
		VdbeCoverage(v);
	}
	else {
		labelContinue = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet, labelBreak,
			regOldRowid);
		VdbeCoverage(v);
		sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);
		VdbeCoverage(v);
	}

	
	assert(chngKey || pTrigger || hasFK || regOldRowid == regNewRowid);
	if (chngRowid) {
		sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
		sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);
	}

	
	if (chngPk || hasFK || pTrigger) {
		u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
		oldmask |= sqlite3TriggerColmask(pParse,
			pTrigger, pChanges, 0, TRIGGER_BEFORE | TRIGGER_AFTER, pTab, onError
		);
		for (i = 0; i<pTab->nCol; i++) {
			if (oldmask == 0xffffffff
				|| (i<32 && (oldmask & MASKBIT32(i)) != 0)
				|| (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY) != 0
				) {
				testcase(oldmask != 0xffffffff && i == 31);
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld + i);
			}
			else {
				sqlite3VdbeAddOp2(v, OP_Null, 0, regOld + i);
			}
		}
		if (chngRowid == 0 && pPk == 0) {
			sqlite3VdbeAddOp2(v, OP_Copy, regOldRowid, regNewRowid);
		}
	}

	
	newmask = sqlite3TriggerColmask(
		pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError
	);
	for (i = 0; i<pTab->nCol; i++) {
		if (i == pTab->iPKey) {
			sqlite3VdbeAddOp2(v, OP_Null, 0, regNew + i);
		}
		else {
			j = aXRef[i];
			if (j >= 0) {
				sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew + i);
			}
			else if (0 == (tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i))) {
				
				testcase(i == 31);
				testcase(i == 32);
				sqlite3ExprCodeGetColumnToReg(pParse, pTab, i, iDataCur, regNew + i);
			}
			else {
				sqlite3VdbeAddOp2(v, OP_Null, 0, regNew + i);
			}
		}
	}

	
	if (tmask&TRIGGER_BEFORE) {
		sqlite3TableAffinity(v, pTab, regNew);
		sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,
			TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);

		
		if (pPk) {
			sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, nKey);
			VdbeCoverage(v);
		}
		else {
			sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);
			VdbeCoverage(v);
		}

		
		for (i = 0; i<pTab->nCol; i++) {
			if (aXRef[i]<0 && i != pTab->iPKey) {
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew + i);
			}
		}
	}

	if (!isView) {
		int addr1 = 0;        
		int bReplace = 0;     

							  
		assert(regOldRowid>0);
		sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
			regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,
			aXRef);

		
		if (hasFK) {
			sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
		}

		
		if (bReplace || chngKey) {
			if (pPk) {
				addr1 = sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, 0, regKey, nKey);
			}
			else {
				addr1 = sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, 0, regOldRowid);
			}
			VdbeCoverageNeverTaken(v);
		}
		sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);

		
		assert(regNew == regNewRowid + 1);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
		sqlite3VdbeAddOp3(v, OP_Delete, iDataCur,
			OPFLAG_ISUPDATE | ((hasFK || chngKey || pPk != 0) ? 0 : OPFLAG_ISNOOP),
			regNewRowid
		);
		if (!pParse->nested) {
			sqlite3VdbeChangeP4(v, -1, (char*)pTab, P4_TABLE);
		}
#else
		if (hasFK || chngKey || pPk != 0) {
			sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);
		}
#endif
		if (bReplace || chngKey) {
			sqlite3VdbeJumpHere(v, addr1);
		}

		if (hasFK) {
			sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);
		}

		
		sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,
			regNewRowid, aRegIdx, 1, 0, 0);

		
		if (hasFK) {
			sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);
		}
	}

	
	if ((db->flags & SQLITE_CountRows) && !pParse->pTriggerTab) {
		sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);
	}

	sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,
		TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);

	
	if (okOnePass) {
		
	}
	else if (pPk) {
		sqlite3VdbeResolveLabel(v, labelContinue);
		sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);
	}
	else {
		sqlite3VdbeGoto(v, labelContinue);
	}
	sqlite3VdbeResolveLabel(v, labelBreak);

	
	for (i = 0, pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext, i++) {
		assert(aRegIdx);
		if (aToOpen[i + 1]) {
			sqlite3VdbeAddOp2(v, OP_Close, iIdxCur + i, 0);
		}
	}
	if (iDataCur<iIdxCur) sqlite3VdbeAddOp2(v, OP_Close, iDataCur, 0);

	
	if (pParse->nested == 0 && pParse->pTriggerTab == 0) {
		sqlite3AutoincrementEnd(pParse);
	}

	
	if ((db->flags&SQLITE_CountRows) && !pParse->pTriggerTab && !pParse->nested) {
		sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);
		sqlite3VdbeSetNumCols(v, 1);
		sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows updated", SQLITE_STATIC);
	}

update_cleanup:
	sqlite3AuthContextPop(&sContext);
	sqlite3DbFree(db, aXRef); 
	sqlite3SrcListDelete(db, pTabList);
	sqlite3ExprListDelete(db, pChanges);
	sqlite3ExprDelete(db, pWhere);
	return;
}

#ifdef isView
#undef isView
#endif
#ifdef pTrigger
#undef pTrigger
#endif

#ifndef SQLITE_OMIT_VIRTUALTABLE

static void updateVirtualTable(
	Parse *pParse,       
	SrcList *pSrc,       
	Table *pTab,         
	ExprList *pChanges,  
	Expr *pRowid,        
	int *aXRef,          
	Expr *pWhere,        
	int onError          
) {
	Vdbe *v = pParse->pVdbe;  
	int ephemTab;             
	int i;                    
	sqlite3 *db = pParse->db; 
	const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
	WhereInfo *pWInfo;
	int nArg = 2 + pTab->nCol;      
	int regArg;                     
	int regRec;                     
	int regRowid;                   
	int iCsr = pSrc->a[0].iCursor;  
	int aDummy[2];                  
	int bOnePass;                   
	int addr;                       

									
	assert(v);
	ephemTab = pParse->nTab++;
	addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);
	regArg = pParse->nMem + 1;
	pParse->nMem += nArg;
	regRec = ++pParse->nMem;
	regRowid = ++pParse->nMem;

	
	pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, WHERE_ONEPASS_DESIRED, 0);
	if (pWInfo == 0) return;

	
	sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);
	if (pRowid) {
		sqlite3ExprCode(pParse, pRowid, regArg + 1);
	}
	else {
		sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg + 1);
	}
	for (i = 0; i<pTab->nCol; i++) {
		if (aXRef[i] >= 0) {
			sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg + 2 + i);
		}
		else {
			sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg + 2 + i);
		}
	}

	bOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);

	if (bOnePass) {
		
		sqlite3VdbeChangeToNoop(v, addr);
		if (sqlite3IsToplevel(pParse)) {
			pParse->isMultiWrite = 0;
		}
	}
	else {
		
		sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);
		sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);
		sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);
	}


	if (bOnePass == 0) {
		
		sqlite3WhereEnd(pWInfo);

		
		addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);

		
		for (i = 0; i<nArg; i++) {
			sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg + i);
		}
	}
	sqlite3VtabMakeWritable(pParse, pTab);
	sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);
	sqlite3VdbeChangeP5(v, onError == OE_Default ? OE_Abort : onError);
	sqlite3MayAbort(pParse);

	
	if (bOnePass == 0) {
		sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr + 1); VdbeCoverage(v);
		sqlite3VdbeJumpHere(v, addr);
		sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);
	}
	else {
		sqlite3WhereEnd(pWInfo);
	}
}
#endif 







#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)


static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql) {
	sqlite3_stmt *pStmt;
	int rc;

	
	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
	if (rc != SQLITE_OK) return rc;
	while (SQLITE_ROW == (rc = sqlite3_step(pStmt))) {
		const char *zSubSql = (const char*)sqlite3_column_text(pStmt, 0);
		assert(sqlite3_strnicmp(zSql, "SELECT", 6) == 0);
		if (zSubSql) {
			assert(zSubSql[0] != 'S');
			rc = execSql(db, pzErrMsg, zSubSql);
			if (rc != SQLITE_OK) break;
		}
	}
	assert(rc != SQLITE_ROW);
	if (rc == SQLITE_DONE) rc = SQLITE_OK;
	if (rc) {
		sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
	}
	(void)sqlite3_finalize(pStmt);
	return rc;
}
static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...) {
	char *z;
	va_list ap;
	int rc;
	va_start(ap, zSql);
	z = sqlite3VMPrintf(db, zSql, ap);
	va_end(ap);
	if (z == 0) return SQLITE_NOMEM;
	rc = execSql(db, pzErrMsg, z);
	sqlite3DbFree(db, z);
	return rc;
}


SQLITE_PRIVATE void sqlite3Vacuum(Parse *pParse, Token *pNm) {
	Vdbe *v = sqlite3GetVdbe(pParse);
	int iDb = pNm ? sqlite3TwoPartName(pParse, pNm, pNm, &pNm) : 0;
	if (v && (iDb >= 2 || iDb == 0)) {
		sqlite3VdbeAddOp1(v, OP_Vacuum, iDb);
		sqlite3VdbeUsesBtree(v, iDb);
	}
	return;
}


SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db, int iDb) {
	int rc = SQLITE_OK;     
	Btree *pMain;           
	Btree *pTemp;           
	int saved_flags;        
	int saved_nChange;      
	int saved_nTotalChange; 
	u8 saved_mTrace;        
	Db *pDb = 0;            
	int isMemDb;            
	int nRes;               
	int nDb;                
	const char *zDbMain;    

	if (!db->autoCommit) {
		sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
		return SQLITE_ERROR;
	}
	if (db->nVdbeActive>1) {
		sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
		return SQLITE_ERROR;
	}

	
	saved_flags = db->flags;
	saved_nChange = db->nChange;
	saved_nTotalChange = db->nTotalChange;
	saved_mTrace = db->mTrace;
	db->flags |= (SQLITE_WriteSchema | SQLITE_IgnoreChecks
		| SQLITE_PreferBuiltin | SQLITE_Vacuum);
	db->flags &= ~(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_CountRows);
	db->mTrace = 0;

	zDbMain = db->aDb[iDb].zDbSName;
	pMain = db->aDb[iDb].pBt;
	isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));

	
	nDb = db->nDb;
	rc = execSql(db, pzErrMsg, "ATTACH''AS vacuum_db");
	if (rc != SQLITE_OK) goto end_of_vacuum;
	assert((db->nDb - 1) == nDb);
	pDb = &db->aDb[nDb];
	assert(strcmp(pDb->zDbSName, "vacuum_db") == 0);
	pTemp = pDb->pBt;

	
	sqlite3BtreeCommit(pTemp);

	nRes = sqlite3BtreeGetOptimalReserve(pMain);

	
#ifdef SQLITE_HAS_CODEC
	if (db->nextPagesize) {
		extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);
		int nKey;
		char *zKey;
		sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);
		if (nKey) db->nextPagesize = 0;
	}
#endif

	sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);
	sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain, 0));
	sqlite3BtreeSetPagerFlags(pTemp, PAGER_SYNCHRONOUS_OFF | PAGER_CACHESPILL);

	
	rc = execSql(db, pzErrMsg, "BEGIN");
	if (rc != SQLITE_OK) goto end_of_vacuum;
	rc = sqlite3BtreeBeginTrans(pMain, 2);
	if (rc != SQLITE_OK) goto end_of_vacuum;

	
	if (sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))
		== PAGER_JOURNALMODE_WAL) {
		db->nextPagesize = 0;
	}

	if (sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)
		|| (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))
		|| NEVER(db->mallocFailed)
		) {
		rc = SQLITE_NOMEM_BKPT;
		goto end_of_vacuum;
	}

#ifndef SQLITE_OMIT_AUTOVACUUM
	sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac >= 0 ? db->nextAutovac :
		sqlite3BtreeGetAutoVacuum(pMain));
#endif

	
	db->init.iDb = nDb; 
	rc = execSqlF(db, pzErrMsg,
		"SELECT sql FROM \"%w\".sqlite_master"
		" WHERE type='table'AND name<>'sqlite_sequence'"
		" AND coalesce(rootpage,1)>0",
		zDbMain
	);
	if (rc != SQLITE_OK) goto end_of_vacuum;
	rc = execSqlF(db, pzErrMsg,
		"SELECT sql FROM \"%w\".sqlite_master"
		" WHERE type='index' AND length(sql)>10",
		zDbMain
	);
	if (rc != SQLITE_OK) goto end_of_vacuum;
	db->init.iDb = 0;

	
	rc = execSqlF(db, pzErrMsg,
		"SELECT'INSERT INTO vacuum_db.'||quote(name)"
		"||' SELECT*FROM\"%w\".'||quote(name)"
		"FROM vacuum_db.sqlite_master "
		"WHERE type='table'AND coalesce(rootpage,1)>0",
		zDbMain
	);
	assert((db->flags & SQLITE_Vacuum) != 0);
	db->flags &= ~SQLITE_Vacuum;
	if (rc != SQLITE_OK) goto end_of_vacuum;

	
	rc = execSqlF(db, pzErrMsg,
		"INSERT INTO vacuum_db.sqlite_master"
		" SELECT*FROM \"%w\".sqlite_master"
		" WHERE type IN('view','trigger')"
		" OR(type='table'AND rootpage=0)",
		zDbMain
	);
	if (rc) goto end_of_vacuum;

	
	{
		u32 meta;
		int i;

		
		static const unsigned char aCopy[] = {
			BTREE_SCHEMA_VERSION,     1,  
			BTREE_DEFAULT_CACHE_SIZE, 0,  
			BTREE_TEXT_ENCODING,      0,  
			BTREE_USER_VERSION,       0,  
			BTREE_APPLICATION_ID,     0,  
		};

		assert(1 == sqlite3BtreeIsInTrans(pTemp));
		assert(1 == sqlite3BtreeIsInTrans(pMain));

		
		for (i = 0; i<ArraySize(aCopy); i += 2) {
			
			sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);
			rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta + aCopy[i + 1]);
			if (NEVER(rc != SQLITE_OK)) goto end_of_vacuum;
		}

		rc = sqlite3BtreeCopyFile(pMain, pTemp);
		if (rc != SQLITE_OK) goto end_of_vacuum;
		rc = sqlite3BtreeCommit(pTemp);
		if (rc != SQLITE_OK) goto end_of_vacuum;
#ifndef SQLITE_OMIT_AUTOVACUUM
		sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));
#endif
	}

	assert(rc == SQLITE_OK);
	rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1);

end_of_vacuum:
	
	db->init.iDb = 0;
	db->flags = saved_flags;
	db->nChange = saved_nChange;
	db->nTotalChange = saved_nTotalChange;
	db->mTrace = saved_mTrace;
	sqlite3BtreeSetPageSize(pMain, -1, -1, 1);

	
	db->autoCommit = 1;

	if (pDb) {
		sqlite3BtreeClose(pDb->pBt);
		pDb->pBt = 0;
		pDb->pSchema = 0;
	}

	
	sqlite3ResetAllSchemasOfConnection(db);

	return rc;
}

#endif  




#ifndef SQLITE_OMIT_VIRTUALTABLE



struct VtabCtx {
	VTable *pVTable;    
	Table *pTab;        
	VtabCtx *pPrior;    
	int bDeclared;      
};


static int createModule(
	sqlite3 *db,                    
	const char *zName,              
	const sqlite3_module *pModule,  
	void *pAux,                     
	void(*xDestroy)(void *)        
) {
	int rc = SQLITE_OK;
	int nName;

	sqlite3_mutex_enter(db->mutex);
	nName = sqlite3Strlen30(zName);
	if (sqlite3HashFind(&db->aModule, zName)) {
		rc = SQLITE_MISUSE_BKPT;
	}
	else {
		Module *pMod;
		pMod = (Module *)sqlite3DbMallocRawNN(db, sizeof(Module) + nName + 1);
		if (pMod) {
			Module *pDel;
			char *zCopy = (char *)(&pMod[1]);
			memcpy(zCopy, zName, nName + 1);
			pMod->zName = zCopy;
			pMod->pModule = pModule;
			pMod->pAux = pAux;
			pMod->xDestroy = xDestroy;
			pMod->pEpoTab = 0;
			pDel = (Module *)sqlite3HashInsert(&db->aModule, zCopy, (void*)pMod);
			assert(pDel == 0 || pDel == pMod);
			if (pDel) {
				sqlite3OomFault(db);
				sqlite3DbFree(db, pDel);
			}
		}
	}
	rc = sqlite3ApiExit(db, rc);
	if (rc != SQLITE_OK && xDestroy) xDestroy(pAux);

	sqlite3_mutex_leave(db->mutex);
	return rc;
}



SQLITE_API int sqlite3_create_module(
	sqlite3 *db,                    
	const char *zName,              
	const sqlite3_module *pModule,  
	void *pAux                      
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zName == 0) return SQLITE_MISUSE_BKPT;
#endif
	return createModule(db, zName, pModule, pAux, 0);
}


SQLITE_API int sqlite3_create_module_v2(
	sqlite3 *db,                    
	const char *zName,              
	const sqlite3_module *pModule,  
	void *pAux,                     
	void(*xDestroy)(void *)        
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zName == 0) return SQLITE_MISUSE_BKPT;
#endif
	return createModule(db, zName, pModule, pAux, xDestroy);
}


SQLITE_PRIVATE void sqlite3VtabLock(VTable *pVTab) {
	pVTab->nRef++;
}



SQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab) {
	VTable *pVtab;
	assert(IsVirtual(pTab));
	for (pVtab = pTab->pVTable; pVtab && pVtab->db != db; pVtab = pVtab->pNext);
	return pVtab;
}


SQLITE_PRIVATE void sqlite3VtabUnlock(VTable *pVTab) {
	sqlite3 *db = pVTab->db;

	assert(db);
	assert(pVTab->nRef>0);
	assert(db->magic == SQLITE_MAGIC_OPEN || db->magic == SQLITE_MAGIC_ZOMBIE);

	pVTab->nRef--;
	if (pVTab->nRef == 0) {
		sqlite3_vtab *p = pVTab->pVtab;
		if (p) {
			p->pModule->xDisconnect(p);
		}
		sqlite3DbFree(db, pVTab);
	}
}


static VTable *vtabDisconnectAll(sqlite3 *db, Table *p) {
	VTable *pRet = 0;
	VTable *pVTable = p->pVTable;
	p->pVTable = 0;

	
	assert(db == 0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema));

	while (pVTable) {
		sqlite3 *db2 = pVTable->db;
		VTable *pNext = pVTable->pNext;
		assert(db2);
		if (db2 == db) {
			pRet = pVTable;
			p->pVTable = pRet;
			pRet->pNext = 0;
		}
		else {
			pVTable->pNext = db2->pDisconnect;
			db2->pDisconnect = pVTable;
		}
		pVTable = pNext;
	}

	assert(!db || pRet);
	return pRet;
}


SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p) {
	VTable **ppVTab;

	assert(IsVirtual(p));
	assert(sqlite3BtreeHoldsAllMutexes(db));
	assert(sqlite3_mutex_held(db->mutex));

	for (ppVTab = &p->pVTable; *ppVTab; ppVTab = &(*ppVTab)->pNext) {
		if ((*ppVTab)->db == db) {
			VTable *pVTab = *ppVTab;
			*ppVTab = pVTab->pNext;
			sqlite3VtabUnlock(pVTab);
			break;
		}
	}
}



SQLITE_PRIVATE void sqlite3VtabUnlockList(sqlite3 *db) {
	VTable *p = db->pDisconnect;
	db->pDisconnect = 0;

	assert(sqlite3BtreeHoldsAllMutexes(db));
	assert(sqlite3_mutex_held(db->mutex));

	if (p) {
		sqlite3ExpirePreparedStatements(db);
		do {
			VTable *pNext = p->pNext;
			sqlite3VtabUnlock(p);
			p = pNext;
		} while (p);
	}
}


SQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table *p) {
	if (!db || db->pnBytesFreed == 0) vtabDisconnectAll(0, p);
	if (p->azModuleArg) {
		int i;
		for (i = 0; i<p->nModuleArg; i++) {
			if (i != 1) sqlite3DbFree(db, p->azModuleArg[i]);
		}
		sqlite3DbFree(db, p->azModuleArg);
	}
}


static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg) {
	int nBytes = sizeof(char *)*(2 + pTable->nModuleArg);
	char **azModuleArg;
	azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
	if (azModuleArg == 0) {
		sqlite3DbFree(db, zArg);
	}
	else {
		int i = pTable->nModuleArg++;
		azModuleArg[i] = zArg;
		azModuleArg[i + 1] = 0;
		pTable->azModuleArg = azModuleArg;
	}
}


SQLITE_PRIVATE void sqlite3VtabBeginParse(
	Parse *pParse,        
	Token *pName1,        
	Token *pName2,        
	Token *pModuleName,   
	int ifNotExists       
) {
	int iDb;              
	Table *pTable;        
	sqlite3 *db;          

	sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
	pTable = pParse->pNewTable;
	if (pTable == 0) return;
	assert(0 == pTable->pIndex);

	db = pParse->db;
	iDb = sqlite3SchemaToIndex(db, pTable->pSchema);
	assert(iDb >= 0);

	pTable->tabFlags |= TF_Virtual;
	pTable->nModuleArg = 0;
	addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));
	addModuleArgument(db, pTable, 0);
	addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));
	assert((pParse->sNameToken.z == pName2->z && pName2->z != 0)
		|| (pParse->sNameToken.z == pName1->z && pName2->z == 0)
	);
	pParse->sNameToken.n = (int)(
		&pModuleName->z[pModuleName->n] - pParse->sNameToken.z
		);

#ifndef SQLITE_OMIT_AUTHORIZATION
	
	if (pTable->azModuleArg) {
		sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName,
			pTable->azModuleArg[0], pParse->db->aDb[iDb].zDbSName);
	}
#endif
}


static void addArgumentToVtab(Parse *pParse) {
	if (pParse->sArg.z && pParse->pNewTable) {
		const char *z = (const char*)pParse->sArg.z;
		int n = pParse->sArg.n;
		sqlite3 *db = pParse->db;
		addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
	}
}


SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd) {
	Table *pTab = pParse->pNewTable;  
	sqlite3 *db = pParse->db;         

	if (pTab == 0) return;
	addArgumentToVtab(pParse);
	pParse->sArg.z = 0;
	if (pTab->nModuleArg<1) return;

	
	if (!db->init.busy) {
		char *zStmt;
		char *zWhere;
		int iDb;
		int iReg;
		Vdbe *v;

		
		if (pEnd) {
			pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;
		}
		zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);

		
		iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
		sqlite3NestedParse(pParse,
			"UPDATE %Q.%s "
			"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "
			"WHERE rowid=#%d",
			db->aDb[iDb].zDbSName, SCHEMA_TABLE(iDb),
			pTab->zName,
			pTab->zName,
			zStmt,
			pParse->regRowid
		);
		sqlite3DbFree(db, zStmt);
		v = sqlite3GetVdbe(pParse);
		sqlite3ChangeCookie(pParse, iDb);

		sqlite3VdbeAddOp0(v, OP_Expire);
		zWhere = sqlite3MPrintf(db, "name='%q' AND type='table'", pTab->zName);
		sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);

		iReg = ++pParse->nMem;
		sqlite3VdbeLoadString(v, iReg, pTab->zName);
		sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);
	}

	
	else {
		Table *pOld;
		Schema *pSchema = pTab->pSchema;
		const char *zName = pTab->zName;
		assert(sqlite3SchemaMutexHeld(db, 0, pSchema));
		pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);
		if (pOld) {
			sqlite3OomFault(db);
			assert(pTab == pOld);  
			return;
		}
		pParse->pNewTable = 0;
	}
}


SQLITE_PRIVATE void sqlite3VtabArgInit(Parse *pParse) {
	addArgumentToVtab(pParse);
	pParse->sArg.z = 0;
	pParse->sArg.n = 0;
}


SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse *pParse, Token *p) {
	Token *pArg = &pParse->sArg;
	if (pArg->z == 0) {
		pArg->z = p->z;
		pArg->n = p->n;
	}
	else {
		assert(pArg->z <= p->z);
		pArg->n = (int)(&p->z[p->n] - pArg->z);
	}
}


static int vtabCallConstructor(
	sqlite3 *db,
	Table *pTab,
	Module *pMod,
	int(*xConstruct)(sqlite3*, void*, int, const char*const*, sqlite3_vtab**, char**),
	char **pzErr
) {
	VtabCtx sCtx;
	VTable *pVTable;
	int rc;
	const char *const*azArg = (const char *const*)pTab->azModuleArg;
	int nArg = pTab->nModuleArg;
	char *zErr = 0;
	char *zModuleName;
	int iDb;
	VtabCtx *pCtx;

	
	for (pCtx = db->pVtabCtx; pCtx; pCtx = pCtx->pPrior) {
		if (pCtx->pTab == pTab) {
			*pzErr = sqlite3MPrintf(db,
				"vtable constructor called recursively: %s", pTab->zName
			);
			return SQLITE_LOCKED;
		}
	}

	zModuleName = sqlite3MPrintf(db, "%s", pTab->zName);
	if (!zModuleName) {
		return SQLITE_NOMEM_BKPT;
	}

	pVTable = sqlite3DbMallocZero(db, sizeof(VTable));
	if (!pVTable) {
		sqlite3DbFree(db, zModuleName);
		return SQLITE_NOMEM_BKPT;
	}
	pVTable->db = db;
	pVTable->pMod = pMod;

	iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
	pTab->azModuleArg[1] = db->aDb[iDb].zDbSName;

	
	assert(&db->pVtabCtx);
	assert(xConstruct);
	sCtx.pTab = pTab;
	sCtx.pVTable = pVTable;
	sCtx.pPrior = db->pVtabCtx;
	sCtx.bDeclared = 0;
	db->pVtabCtx = &sCtx;
	rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);
	db->pVtabCtx = sCtx.pPrior;
	if (rc == SQLITE_NOMEM) sqlite3OomFault(db);
	assert(sCtx.pTab == pTab);

	if (SQLITE_OK != rc) {
		if (zErr == 0) {
			*pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
		}
		else {
			*pzErr = sqlite3MPrintf(db, "%s", zErr);
			sqlite3_free(zErr);
		}
		sqlite3DbFree(db, pVTable);
	}
	else if (ALWAYS(pVTable->pVtab)) {
		
		memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
		pVTable->pVtab->pModule = pMod->pModule;
		pVTable->nRef = 1;
		if (sCtx.bDeclared == 0) {
			const char *zFormat = "vtable constructor did not declare schema: %s";
			*pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
			sqlite3VtabUnlock(pVTable);
			rc = SQLITE_ERROR;
		}
		else {
			int iCol;
			u8 oooHidden = 0;
			
			pVTable->pNext = pTab->pVTable;
			pTab->pVTable = pVTable;

			for (iCol = 0; iCol<pTab->nCol; iCol++) {
				char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");
				int nType;
				int i = 0;
				nType = sqlite3Strlen30(zType);
				for (i = 0; i<nType; i++) {
					if (0 == sqlite3StrNICmp("hidden", &zType[i], 6)
						&& (i == 0 || zType[i - 1] == ' ')
						&& (zType[i + 6] == '\0' || zType[i + 6] == ' ')
						) {
						break;
					}
				}
				if (i<nType) {
					int j;
					int nDel = 6 + (zType[i + 6] ? 1 : 0);
					for (j = i; (j + nDel) <= nType; j++) {
						zType[j] = zType[j + nDel];
					}
					if (zType[i] == '\0' && i>0) {
						assert(zType[i - 1] == ' ');
						zType[i - 1] = '\0';
					}
					pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;
					oooHidden = TF_OOOHidden;
				}
				else {
					pTab->tabFlags |= oooHidden;
				}
			}
		}
	}

	sqlite3DbFree(db, zModuleName);
	return rc;
}


SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab) {
	sqlite3 *db = pParse->db;
	const char *zMod;
	Module *pMod;
	int rc;

	assert(pTab);
	if ((pTab->tabFlags & TF_Virtual) == 0 || sqlite3GetVTable(db, pTab)) {
		return SQLITE_OK;
	}

	
	zMod = pTab->azModuleArg[0];
	pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);

	if (!pMod) {
		const char *zModule = pTab->azModuleArg[0];
		sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
		rc = SQLITE_ERROR;
	}
	else {
		char *zErr = 0;
		rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);
		if (rc != SQLITE_OK) {
			sqlite3ErrorMsg(pParse, "%s", zErr);
		}
		sqlite3DbFree(db, zErr);
	}

	return rc;
}

static int growVTrans(sqlite3 *db) {
	const int ARRAY_INCR = 5;

	
	if ((db->nVTrans%ARRAY_INCR) == 0) {
		VTable **aVTrans;
		int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR);
		aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
		if (!aVTrans) {
			return SQLITE_NOMEM_BKPT;
		}
		memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
		db->aVTrans = aVTrans;
	}

	return SQLITE_OK;
}


static void addToVTrans(sqlite3 *db, VTable *pVTab) {
	
	db->aVTrans[db->nVTrans++] = pVTab;
	sqlite3VtabLock(pVTab);
}


SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr) {
	int rc = SQLITE_OK;
	Table *pTab;
	Module *pMod;
	const char *zMod;

	pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
	assert(pTab && (pTab->tabFlags & TF_Virtual) != 0 && !pTab->pVTable);

	
	zMod = pTab->azModuleArg[0];
	pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);

	
	if (pMod == 0 || pMod->pModule->xCreate == 0 || pMod->pModule->xDestroy == 0) {
		*pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
		rc = SQLITE_ERROR;
	}
	else {
		rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);
	}

	
	if (rc == SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab))) {
		rc = growVTrans(db);
		if (rc == SQLITE_OK) {
			addToVTrans(db, sqlite3GetVTable(db, pTab));
		}
	}

	return rc;
}


SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable) {
	VtabCtx *pCtx;
	Parse *pParse;
	int rc = SQLITE_OK;
	Table *pTab;
	char *zErr = 0;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zCreateTable == 0) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pCtx = db->pVtabCtx;
	if (!pCtx || pCtx->bDeclared) {
		sqlite3Error(db, SQLITE_MISUSE);
		sqlite3_mutex_leave(db->mutex);
		return SQLITE_MISUSE_BKPT;
	}
	pTab = pCtx->pTab;
	assert((pTab->tabFlags & TF_Virtual) != 0);

	pParse = sqlite3StackAllocZero(db, sizeof(*pParse));
	if (pParse == 0) {
		rc = SQLITE_NOMEM_BKPT;
	}
	else {
		pParse->declareVtab = 1;
		pParse->db = db;
		pParse->nQueryLoop = 1;

		if (SQLITE_OK == sqlite3RunParser(pParse, zCreateTable, &zErr)
			&& pParse->pNewTable
			&& !db->mallocFailed
			&& !pParse->pNewTable->pSelect
			&& (pParse->pNewTable->tabFlags & TF_Virtual) == 0
			) {
			if (!pTab->aCol) {
				Table *pNew = pParse->pNewTable;
				Index *pIdx;
				pTab->aCol = pNew->aCol;
				pTab->nCol = pNew->nCol;
				pTab->tabFlags |= pNew->tabFlags & (TF_WithoutRowid | TF_NoVisibleRowid);
				pNew->nCol = 0;
				pNew->aCol = 0;
				assert(pTab->pIndex == 0);
				if (!HasRowid(pNew) && pCtx->pVTable->pMod->pModule->xUpdate != 0) {
					rc = SQLITE_ERROR;
				}
				pIdx = pNew->pIndex;
				if (pIdx) {
					assert(pIdx->pNext == 0);
					pTab->pIndex = pIdx;
					pNew->pIndex = 0;
					pIdx->pTable = pTab;
				}
			}
			pCtx->bDeclared = 1;
		}
		else {
			sqlite3ErrorWithMsg(db, SQLITE_ERROR, (zErr ? "%s" : 0), zErr);
			sqlite3DbFree(db, zErr);
			rc = SQLITE_ERROR;
		}
		pParse->declareVtab = 0;

		if (pParse->pVdbe) {
			sqlite3VdbeFinalize(pParse->pVdbe);
		}
		sqlite3DeleteTable(db, pParse->pNewTable);
		sqlite3ParserReset(pParse);
		sqlite3StackFree(db, pParse);
	}

	assert((rc & 0xff) == rc);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab) {
	int rc = SQLITE_OK;
	Table *pTab;

	pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
	if (pTab != 0 && ALWAYS(pTab->pVTable != 0)) {
		VTable *p;
		int(*xDestroy)(sqlite3_vtab *);
		for (p = pTab->pVTable; p; p = p->pNext) {
			assert(p->pVtab);
			if (p->pVtab->nRef>0) {
				return SQLITE_LOCKED;
			}
		}
		p = vtabDisconnectAll(db, pTab);
		xDestroy = p->pMod->pModule->xDestroy;
		assert(xDestroy != 0);  
		rc = xDestroy(p->pVtab);
		
		if (rc == SQLITE_OK) {
			assert(pTab->pVTable == p && p->pNext == 0);
			p->pVtab = 0;
			pTab->pVTable = 0;
			sqlite3VtabUnlock(p);
		}
	}

	return rc;
}


static void callFinaliser(sqlite3 *db, int offset) {
	int i;
	if (db->aVTrans) {
		VTable **aVTrans = db->aVTrans;
		db->aVTrans = 0;
		for (i = 0; i<db->nVTrans; i++) {
			VTable *pVTab = aVTrans[i];
			sqlite3_vtab *p = pVTab->pVtab;
			if (p) {
				int(*x)(sqlite3_vtab *);
				x = *(int(**)(sqlite3_vtab *))((char *)p->pModule + offset);
				if (x) x(p);
			}
			pVTab->iSavepoint = 0;
			sqlite3VtabUnlock(pVTab);
		}
		sqlite3DbFree(db, aVTrans);
		db->nVTrans = 0;
	}
}


SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, Vdbe *p) {
	int i;
	int rc = SQLITE_OK;
	VTable **aVTrans = db->aVTrans;

	db->aVTrans = 0;
	for (i = 0; rc == SQLITE_OK && i<db->nVTrans; i++) {
		int(*x)(sqlite3_vtab *);
		sqlite3_vtab *pVtab = aVTrans[i]->pVtab;
		if (pVtab && (x = pVtab->pModule->xSync) != 0) {
			rc = x(pVtab);
			sqlite3VtabImportErrmsg(p, pVtab);
		}
	}
	db->aVTrans = aVTrans;
	return rc;
}


SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db) {
	callFinaliser(db, offsetof(sqlite3_module, xRollback));
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db) {
	callFinaliser(db, offsetof(sqlite3_module, xCommit));
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab) {
	int rc = SQLITE_OK;
	const sqlite3_module *pModule;

	
	if (sqlite3VtabInSync(db)) {
		return SQLITE_LOCKED;
	}
	if (!pVTab) {
		return SQLITE_OK;
	}
	pModule = pVTab->pVtab->pModule;

	if (pModule->xBegin) {
		int i;

		
		for (i = 0; i<db->nVTrans; i++) {
			if (db->aVTrans[i] == pVTab) {
				return SQLITE_OK;
			}
		}

		
		rc = growVTrans(db);
		if (rc == SQLITE_OK) {
			rc = pModule->xBegin(pVTab->pVtab);
			if (rc == SQLITE_OK) {
				int iSvpt = db->nStatement + db->nSavepoint;
				addToVTrans(db, pVTab);
				if (iSvpt && pModule->xSavepoint) {
					pVTab->iSavepoint = iSvpt;
					rc = pModule->xSavepoint(pVTab->pVtab, iSvpt - 1);
				}
			}
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint) {
	int rc = SQLITE_OK;

	assert(op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK || op == SAVEPOINT_BEGIN);
	assert(iSavepoint >= -1);
	if (db->aVTrans) {
		int i;
		for (i = 0; rc == SQLITE_OK && i<db->nVTrans; i++) {
			VTable *pVTab = db->aVTrans[i];
			const sqlite3_module *pMod = pVTab->pMod->pModule;
			if (pVTab->pVtab && pMod->iVersion >= 2) {
				int(*xMethod)(sqlite3_vtab *, int);
				switch (op) {
				case SAVEPOINT_BEGIN:
					xMethod = pMod->xSavepoint;
					pVTab->iSavepoint = iSavepoint + 1;
					break;
				case SAVEPOINT_ROLLBACK:
					xMethod = pMod->xRollbackTo;
					break;
				default:
					xMethod = pMod->xRelease;
					break;
				}
				if (xMethod && pVTab->iSavepoint>iSavepoint) {
					rc = xMethod(pVTab->pVtab, iSavepoint);
				}
			}
		}
	}
	return rc;
}


SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(
	sqlite3 *db,    
	FuncDef *pDef,  
	int nArg,       
	Expr *pExpr     
) {
	Table *pTab;
	sqlite3_vtab *pVtab;
	sqlite3_module *pMod;
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value**) = 0;
	void *pArg = 0;
	FuncDef *pNew;
	int rc = 0;
	char *zLowerName;
	unsigned char *z;


	
	if (NEVER(pExpr == 0)) return pDef;
	if (pExpr->op != TK_COLUMN) return pDef;
	pTab = pExpr->pTab;
	if (NEVER(pTab == 0)) return pDef;
	if ((pTab->tabFlags & TF_Virtual) == 0) return pDef;
	pVtab = sqlite3GetVTable(db, pTab)->pVtab;
	assert(pVtab != 0);
	assert(pVtab->pModule != 0);
	pMod = (sqlite3_module *)pVtab->pModule;
	if (pMod->xFindFunction == 0) return pDef;

	
	zLowerName = sqlite3DbStrDup(db, pDef->zName);
	if (zLowerName) {
		for (z = (unsigned char*)zLowerName; *z; z++) {
			*z = sqlite3UpperToLower[*z];
		}
		rc = pMod->xFindFunction(pVtab, nArg, zLowerName, &xSFunc, &pArg);
		sqlite3DbFree(db, zLowerName);
	}
	if (rc == 0) {
		return pDef;
	}

	
	pNew = sqlite3DbMallocZero(db, sizeof(*pNew)
		+ sqlite3Strlen30(pDef->zName) + 1);
	if (pNew == 0) {
		return pDef;
	}
	*pNew = *pDef;
	pNew->zName = (const char*)&pNew[1];
	memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName) + 1);
	pNew->xSFunc = xSFunc;
	pNew->pUserData = pArg;
	pNew->funcFlags |= SQLITE_FUNC_EPHEM;
	return pNew;
}


SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab) {
	Parse *pToplevel = sqlite3ParseToplevel(pParse);
	int i, n;
	Table **apVtabLock;

	assert(IsVirtual(pTab));
	for (i = 0; i<pToplevel->nVtabLock; i++) {
		if (pTab == pToplevel->apVtabLock[i]) return;
	}
	n = (pToplevel->nVtabLock + 1) * sizeof(pToplevel->apVtabLock[0]);
	apVtabLock = sqlite3_realloc64(pToplevel->apVtabLock, n);
	if (apVtabLock) {
		pToplevel->apVtabLock = apVtabLock;
		pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;
	}
	else {
		sqlite3OomFault(pToplevel->db);
	}
}


SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod) {
	const sqlite3_module *pModule = pMod->pModule;
	Table *pTab;
	char *zErr = 0;
	int rc;
	sqlite3 *db = pParse->db;
	if (pMod->pEpoTab) return 1;
	if (pModule->xCreate != 0 && pModule->xCreate != pModule->xConnect) return 0;
	pTab = sqlite3DbMallocZero(db, sizeof(Table));
	if (pTab == 0) return 0;
	pTab->zName = sqlite3DbStrDup(db, pMod->zName);
	if (pTab->zName == 0) {
		sqlite3DbFree(db, pTab);
		return 0;
	}
	pMod->pEpoTab = pTab;
	pTab->nRef = 1;
	pTab->pSchema = db->aDb[0].pSchema;
	pTab->tabFlags |= TF_Virtual;
	pTab->nModuleArg = 0;
	pTab->iPKey = -1;
	addModuleArgument(db, pTab, sqlite3DbStrDup(db, pTab->zName));
	addModuleArgument(db, pTab, 0);
	addModuleArgument(db, pTab, sqlite3DbStrDup(db, pTab->zName));
	rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);
	if (rc) {
		sqlite3ErrorMsg(pParse, "%s", zErr);
		sqlite3DbFree(db, zErr);
		sqlite3VtabEponymousTableClear(db, pMod);
		return 0;
	}
	return 1;
}


SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod) {
	Table *pTab = pMod->pEpoTab;
	if (pTab != 0) {
		
		pTab->tabFlags |= TF_Ephemeral;
		sqlite3DeleteTable(db, pTab);
		pMod->pEpoTab = 0;
	}
}


SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db) {
	static const unsigned char aMap[] = {
		SQLITE_ROLLBACK, SQLITE_ABORT, SQLITE_FAIL, SQLITE_IGNORE, SQLITE_REPLACE
	};
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	assert(OE_Rollback == 1 && OE_Abort == 2 && OE_Fail == 3);
	assert(OE_Ignore == 4 && OE_Replace == 5);
	assert(db->vtabOnConflict >= 1 && db->vtabOnConflict <= 5);
	return (int)aMap[db->vtabOnConflict - 1];
}


SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...) {
	va_list ap;
	int rc = SQLITE_OK;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	va_start(ap, op);
	switch (op) {
	case SQLITE_VTAB_CONSTRAINT_SUPPORT: {
		VtabCtx *p = db->pVtabCtx;
		if (!p) {
			rc = SQLITE_MISUSE_BKPT;
		}
		else {
			assert(p->pTab == 0 || (p->pTab->tabFlags & TF_Virtual) != 0);
			p->pVTable->bConstraint = (u8)va_arg(ap, int);
		}
		break;
	}
	default:
		rc = SQLITE_MISUSE_BKPT;
		break;
	}
	va_end(ap);

	if (rc != SQLITE_OK) sqlite3Error(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}

#endif 










#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)
 int sqlite3WhereTrace;
#endif
#if defined(SQLITE_DEBUG) \
    && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_WHERETRACE))
# define WHERETRACE(K,X)  if(sqlite3WhereTrace&(K)) sqlite3DebugPrintf X
# define WHERETRACE_ENABLED 1
#else
# define WHERETRACE(K,X)
#endif


typedef struct WhereClause WhereClause;
typedef struct WhereMaskSet WhereMaskSet;
typedef struct WhereOrInfo WhereOrInfo;
typedef struct WhereAndInfo WhereAndInfo;
typedef struct WhereLevel WhereLevel;
typedef struct WhereLoop WhereLoop;
typedef struct WherePath WherePath;
typedef struct WhereTerm WhereTerm;
typedef struct WhereLoopBuilder WhereLoopBuilder;
typedef struct WhereScan WhereScan;
typedef struct WhereOrCost WhereOrCost;
typedef struct WhereOrSet WhereOrSet;


struct WhereLevel {
	int iLeftJoin;        
	int iTabCur;          
	int iIdxCur;          
	int addrBrk;          
	int addrNxt;          
	int addrSkip;         
	int addrCont;         
	int addrFirst;        
	int addrBody;         
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
	u32 iLikeRepCntr;     
	int addrLikeRep;      
#endif
	u8 iFrom;             
	u8 op, p3, p5;        
	int p1, p2;           
	union {               
		struct {
			int nIn;              
			struct InLoop {
				int iCur;              
				int addrInTop;         
				u8 eEndLoopOp;         
			} *aInLoop;           
		} in;                 
		Index *pCovidx;       
	} u;
	struct WhereLoop *pWLoop;  
	Bitmask notReady;          
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
	int addrVisit;        
#endif
};


struct WhereLoop {
	Bitmask prereq;       
	Bitmask maskSelf;     
#ifdef SQLITE_DEBUG
	char cId;             
#endif
	u8 iTab;              
	u8 iSortIdx;          
	LogEst rSetup;        
	LogEst rRun;          
	LogEst nOut;          
	union {
		struct {               
			u16 nEq;               
			u16 nBtm;              
			u16 nTop;              
			Index *pIndex;         
		} btree;
		struct {               
			int idxNum;            
			u8 needFree;           
			i8 isOrdered;          
			u16 omitMask;          
			char *idxStr;          
		} vtab;
	} u;
	u32 wsFlags;          
	u16 nLTerm;           
	u16 nSkip;            
						  
# define WHERE_LOOP_XFER_SZ offsetof(WhereLoop,nLSlot)
	u16 nLSlot;           
	WhereTerm **aLTerm;   
	WhereLoop *pNextLoop; 
	WhereTerm *aLTermSpace[3];  
};


struct WhereOrCost {
	Bitmask prereq;     
	LogEst rRun;        
	LogEst nOut;        
};


#define N_OR_COST 3
struct WhereOrSet {
	u16 n;                      
	WhereOrCost a[N_OR_COST];   
};


struct WherePath {
	Bitmask maskLoop;     
	Bitmask revLoop;      
	LogEst nRow;          
	LogEst rCost;         
	LogEst rUnsorted;     
	i8 isOrdered;         
	WhereLoop **aLoop;    
};


struct WhereTerm {
	Expr *pExpr;            
	WhereClause *pWC;       
	LogEst truthProb;       
	u16 wtFlags;            
	u16 eOperator;          
	u8 nChild;              
	u8 eMatchOp;            
	int iParent;            
	int leftCursor;         
	int iField;             
	union {
		int leftColumn;         
		WhereOrInfo *pOrInfo;   
		WhereAndInfo *pAndInfo; 
	} u;
	Bitmask prereqRight;    
	Bitmask prereqAll;      
};


#define TERM_DYNAMIC    0x01   
#define TERM_VIRTUAL    0x02   
#define TERM_CODED      0x04   
#define TERM_COPIED     0x08   
#define TERM_ORINFO     0x10   
#define TERM_ANDINFO    0x20   
#define TERM_OR_OK      0x40   
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
#  define TERM_VNULL    0x80   
#else
#  define TERM_VNULL    0x00   
#endif
#define TERM_LIKEOPT    0x100  
#define TERM_LIKECOND   0x200  
#define TERM_LIKE       0x400  
#define TERM_IS         0x800  


struct WhereScan {
	WhereClause *pOrigWC;      
	WhereClause *pWC;          
	const char *zCollName;     
	Expr *pIdxExpr;            
	char idxaff;               
	unsigned char nEquiv;      
	unsigned char iEquiv;      
	u32 opMask;                
	int k;                     
	int aiCur[11];             
	i16 aiColumn[11];          
};


struct WhereClause {
	WhereInfo *pWInfo;       
	WhereClause *pOuter;     
	u8 op;                   
	int nTerm;               
	int nSlot;               
	WhereTerm *a;            
#if defined(SQLITE_SMALL_STACK)
	WhereTerm aStatic[1];    
#else
	WhereTerm aStatic[8];    
#endif
};


struct WhereOrInfo {
	WhereClause wc;          
	Bitmask indexable;       
};


struct WhereAndInfo {
	WhereClause wc;          
};


struct WhereMaskSet {
	int n;                        
	int ix[BMS];                  
};


#define initMaskSet(P)  (P)->n=0


struct WhereLoopBuilder {
	WhereInfo *pWInfo;        
	WhereClause *pWC;         
	ExprList *pOrderBy;       
	WhereLoop *pNew;          
	WhereOrSet *pOrSet;       
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	UnpackedRecord *pRec;     
	int nRecValid;            
#endif
};


struct WhereInfo {
	Parse *pParse;            
	SrcList *pTabList;        
	ExprList *pOrderBy;       
	ExprList *pDistinctSet;   
	LogEst iLimit;            
	int aiCurOnePass[2];      
	int iContinue;            
	int iBreak;               
	int savedNQueryLoop;      
	u16 wctrlFlags;           
	u8 nLevel;                
	i8 nOBSat;                
	u8 sorted;                
	u8 eOnePass;              
	u8 untestedTerms;         
	u8 eDistinct;             
	u8 bOrderedInnerLoop;     
	int iTop;                 
	WhereLoop *pLoops;        
	Bitmask revMask;          
	LogEst nRowOut;           
	WhereClause sWC;          
	WhereMaskSet sMaskSet;    
	WhereLevel a[1];          
};


SQLITE_PRIVATE Bitmask sqlite3WhereGetMask(WhereMaskSet*, int);
#ifdef WHERETRACE_ENABLED
SQLITE_PRIVATE void sqlite3WhereClausePrint(WhereClause *pWC);
#endif
SQLITE_PRIVATE WhereTerm *sqlite3WhereFindTerm(
	WhereClause *pWC,     
	int iCur,             
	int iColumn,          
	Bitmask notReady,     
	u32 op,               
	Index *pIdx           
);


#ifndef SQLITE_OMIT_EXPLAIN
SQLITE_PRIVATE int sqlite3WhereExplainOneScan(
	Parse *pParse,                  
	SrcList *pTabList,              
	WhereLevel *pLevel,             
	int iLevel,                     
	int iFrom,                      
	u16 wctrlFlags                  
);
#else
# define sqlite3WhereExplainOneScan(u,v,w,x,y,z) 0
#endif 
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_PRIVATE void sqlite3WhereAddScanStatus(
	Vdbe *v,                        
	SrcList *pSrclist,              
	WhereLevel *pLvl,               
	int addrExplain                 
);
#else
# define sqlite3WhereAddScanStatus(a, b, c, d) ((void)d)
#endif
SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
	WhereInfo *pWInfo,   
	int iLevel,          
	Bitmask notReady     
);


SQLITE_PRIVATE void sqlite3WhereClauseInit(WhereClause*, WhereInfo*);
SQLITE_PRIVATE void sqlite3WhereClauseClear(WhereClause*);
SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause*, Expr*, u8);
SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*);
SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*);
SQLITE_PRIVATE void sqlite3WhereExprAnalyze(SrcList*, WhereClause*);
SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(Parse*, struct SrcList_item*, WhereClause*);






#define WO_IN     0x0001
#define WO_EQ     0x0002
#define WO_LT     (WO_EQ<<(TK_LT-TK_EQ))
#define WO_LE     (WO_EQ<<(TK_LE-TK_EQ))
#define WO_GT     (WO_EQ<<(TK_GT-TK_EQ))
#define WO_GE     (WO_EQ<<(TK_GE-TK_EQ))
#define WO_MATCH  0x0040
#define WO_IS     0x0080
#define WO_ISNULL 0x0100
#define WO_OR     0x0200       
#define WO_AND    0x0400       
#define WO_EQUIV  0x0800       
#define WO_NOOP   0x1000       

#define WO_ALL    0x1fff       
#define WO_SINGLE 0x01ff       


#define WHERE_COLUMN_EQ    0x00000001  
#define WHERE_COLUMN_RANGE 0x00000002  
#define WHERE_COLUMN_IN    0x00000004  
#define WHERE_COLUMN_NULL  0x00000008  
#define WHERE_CONSTRAINT   0x0000000f  
#define WHERE_TOP_LIMIT    0x00000010  
#define WHERE_BTM_LIMIT    0x00000020  
#define WHERE_BOTH_LIMIT   0x00000030  
#define WHERE_IDX_ONLY     0x00000040  
#define WHERE_IPK          0x00000100  
#define WHERE_INDEXED      0x00000200  
#define WHERE_VIRTUALTABLE 0x00000400  
#define WHERE_IN_ABLE      0x00000800  
#define WHERE_ONEROW       0x00001000  
#define WHERE_MULTI_OR     0x00002000  
#define WHERE_AUTO_INDEX   0x00004000  
#define WHERE_SKIPSCAN     0x00008000  
#define WHERE_UNQ_WANTED   0x00010000  
#define WHERE_PARTIALIDX   0x00020000  




#ifndef SQLITE_OMIT_EXPLAIN


static const char *explainIndexColumnName(Index *pIdx, int i) {
	i = pIdx->aiColumn[i];
	if (i == XN_EXPR) return "<expr>";
	if (i == XN_ROWID) return "rowid";
	return pIdx->pTable->aCol[i].zName;
}


static void explainAppendTerm(
	StrAccum *pStr,             
	Index *pIdx,                
	int nTerm,                  
	int iTerm,                  
	int bAnd,                   
	const char *zOp             
) {
	int i;

	assert(nTerm >= 1);
	if (bAnd) sqlite3StrAccumAppend(pStr, " AND ", 5);

	if (nTerm>1) sqlite3StrAccumAppend(pStr, "(", 1);
	for (i = 0; i<nTerm; i++) {
		if (i) sqlite3StrAccumAppend(pStr, ",", 1);
		sqlite3StrAccumAppendAll(pStr, explainIndexColumnName(pIdx, iTerm + i));
	}
	if (nTerm>1) sqlite3StrAccumAppend(pStr, ")", 1);

	sqlite3StrAccumAppend(pStr, zOp, 1);

	if (nTerm>1) sqlite3StrAccumAppend(pStr, "(", 1);
	for (i = 0; i<nTerm; i++) {
		if (i) sqlite3StrAccumAppend(pStr, ",", 1);
		sqlite3StrAccumAppend(pStr, "?", 1);
	}
	if (nTerm>1) sqlite3StrAccumAppend(pStr, ")", 1);
}


static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop) {
	Index *pIndex = pLoop->u.btree.pIndex;
	u16 nEq = pLoop->u.btree.nEq;
	u16 nSkip = pLoop->nSkip;
	int i, j;

	if (nEq == 0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT | WHERE_TOP_LIMIT)) == 0) return;
	sqlite3StrAccumAppend(pStr, " (", 2);
	for (i = 0; i<nEq; i++) {
		const char *z = explainIndexColumnName(pIndex, i);
		if (i) sqlite3StrAccumAppend(pStr, " AND ", 5);
		sqlite3XPrintf(pStr, i >= nSkip ? "%s=?" : "ANY(%s)", z);
	}

	j = i;
	if (pLoop->wsFlags&WHERE_BTM_LIMIT) {
		explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");
		i = 1;
	}
	if (pLoop->wsFlags&WHERE_TOP_LIMIT) {
		explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");
	}
	sqlite3StrAccumAppend(pStr, ")", 1);
}


SQLITE_PRIVATE int sqlite3WhereExplainOneScan(
	Parse *pParse,                  
	SrcList *pTabList,              
	WhereLevel *pLevel,             
	int iLevel,                     
	int iFrom,                      
	u16 wctrlFlags                  
) {
	int ret = 0;
#if !defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_STMT_SCANSTATUS)
	if (pParse->explain == 2)
#endif
	{
		struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom];
		Vdbe *v = pParse->pVdbe;      
		sqlite3 *db = pParse->db;     
		int iId = pParse->iSelectId;  
		int isSearch;                 
		WhereLoop *pLoop;             
		u32 flags;                    
		char *zMsg;                   
		StrAccum str;                 
		char zBuf[100];               

		pLoop = pLevel->pWLoop;
		flags = pLoop->wsFlags;
		if ((flags&WHERE_MULTI_OR) || (wctrlFlags&WHERE_OR_SUBCLAUSE)) return 0;

		isSearch = (flags&(WHERE_BTM_LIMIT | WHERE_TOP_LIMIT)) != 0
			|| ((flags&WHERE_VIRTUALTABLE) == 0 && (pLoop->u.btree.nEq>0))
			|| (wctrlFlags&(WHERE_ORDERBY_MIN | WHERE_ORDERBY_MAX));

		sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), SQLITE_MAX_LENGTH);
		sqlite3StrAccumAppendAll(&str, isSearch ? "SEARCH" : "SCAN");
		if (pItem->pSelect) {
			sqlite3XPrintf(&str, " SUBQUERY %d", pItem->iSelectId);
		}
		else {
			sqlite3XPrintf(&str, " TABLE %s", pItem->zName);
		}

		if (pItem->zAlias) {
			sqlite3XPrintf(&str, " AS %s", pItem->zAlias);
		}
		if ((flags & (WHERE_IPK | WHERE_VIRTUALTABLE)) == 0) {
			const char *zFmt = 0;
			Index *pIdx;

			assert(pLoop->u.btree.pIndex != 0);
			pIdx = pLoop->u.btree.pIndex;
			assert(!(flags&WHERE_AUTO_INDEX) || (flags&WHERE_IDX_ONLY));
			if (!HasRowid(pItem->pTab) && IsPrimaryKeyIndex(pIdx)) {
				if (isSearch) {
					zFmt = "PRIMARY KEY";
				}
			}
			else if (flags & WHERE_PARTIALIDX) {
				zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
			}
			else if (flags & WHERE_AUTO_INDEX) {
				zFmt = "AUTOMATIC COVERING INDEX";
			}
			else if (flags & WHERE_IDX_ONLY) {
				zFmt = "COVERING INDEX %s";
			}
			else {
				zFmt = "INDEX %s";
			}
			if (zFmt) {
				sqlite3StrAccumAppend(&str, " USING ", 7);
				sqlite3XPrintf(&str, zFmt, pIdx->zName);
				explainIndexRange(&str, pLoop);
			}
		}
		else if ((flags & WHERE_IPK) != 0 && (flags & WHERE_CONSTRAINT) != 0) {
			const char *zRangeOp;
			if (flags&(WHERE_COLUMN_EQ | WHERE_COLUMN_IN)) {
				zRangeOp = "=";
			}
			else if ((flags&WHERE_BOTH_LIMIT) == WHERE_BOTH_LIMIT) {
				zRangeOp = ">? AND rowid<";
			}
			else if (flags&WHERE_BTM_LIMIT) {
				zRangeOp = ">";
			}
			else {
				assert(flags&WHERE_TOP_LIMIT);
				zRangeOp = "<";
			}
			sqlite3XPrintf(&str, " USING INTEGER PRIMARY KEY (rowid%s?)", zRangeOp);
		}
#ifndef SQLITE_OMIT_VIRTUALTABLE
		else if ((flags & WHERE_VIRTUALTABLE) != 0) {
			sqlite3XPrintf(&str, " VIRTUAL TABLE INDEX %d:%s",
				pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr);
		}
#endif
#ifdef SQLITE_EXPLAIN_ESTIMATED_ROWS
		if (pLoop->nOut >= 10) {
			sqlite3XPrintf(&str, " (~%llu rows)", sqlite3LogEstToInt(pLoop->nOut));
		}
		else {
			sqlite3StrAccumAppend(&str, " (~1 row)", 9);
		}
#endif
		zMsg = sqlite3StrAccumFinish(&str);
		ret = sqlite3VdbeAddOp4(v, OP_Explain, iId, iLevel, iFrom, zMsg, P4_DYNAMIC);
	}
	return ret;
}
#endif 

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS

SQLITE_PRIVATE void sqlite3WhereAddScanStatus(
	Vdbe *v,                        
	SrcList *pSrclist,              
	WhereLevel *pLvl,               
	int addrExplain                 
) {
	const char *zObj = 0;
	WhereLoop *pLoop = pLvl->pWLoop;
	if ((pLoop->wsFlags & WHERE_VIRTUALTABLE) == 0 && pLoop->u.btree.pIndex != 0) {
		zObj = pLoop->u.btree.pIndex->zName;
	}
	else {
		zObj = pSrclist->a[pLvl->iFrom].zName;
	}
	sqlite3VdbeScanStatus(
		v, addrExplain, pLvl->addrBody, pLvl->addrVisit, pLoop->nOut, zObj
	);
}
#endif



static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm) {
	int nLoop = 0;
	while (ALWAYS(pTerm != 0)
		&& (pTerm->wtFlags & TERM_CODED) == 0
		&& (pLevel->iLeftJoin == 0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin))
		&& (pLevel->notReady & pTerm->prereqAll) == 0
		) {
		if (nLoop && (pTerm->wtFlags & TERM_LIKE) != 0) {
			pTerm->wtFlags |= TERM_LIKECOND;
		}
		else {
			pTerm->wtFlags |= TERM_CODED;
		}
		if (pTerm->iParent<0) break;
		pTerm = &pTerm->pWC->a[pTerm->iParent];
		pTerm->nChild--;
		if (pTerm->nChild != 0) break;
		nLoop++;
	}
}


static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff) {
	Vdbe *v = pParse->pVdbe;
	if (zAff == 0) {
		assert(pParse->db->mallocFailed);
		return;
	}
	assert(v != 0);

	
	while (n>0 && zAff[0] == SQLITE_AFF_BLOB) {
		n--;
		base++;
		zAff++;
	}
	while (n>1 && zAff[n - 1] == SQLITE_AFF_BLOB) {
		n--;
	}

	
	if (n>0) {
		sqlite3VdbeAddOp4(v, OP_Affinity, base, n, 0, zAff, n);
		sqlite3ExprCacheAffinityChange(pParse, base, n);
	}
}


static void updateRangeAffinityStr(
	Expr *pRight,                   
	int n,                          
	char *zAff                      
) {
	int i;
	for (i = 0; i<n; i++) {
		Expr *p = sqlite3VectorFieldSubexpr(pRight, i);
		if (sqlite3CompareAffinity(p, zAff[i]) == SQLITE_AFF_BLOB
			|| sqlite3ExprNeedsNoAffinityChange(p, zAff[i])
			) {
			zAff[i] = SQLITE_AFF_BLOB;
		}
	}
}


static int codeEqualityTerm(
	Parse *pParse,      
	WhereTerm *pTerm,   
	WhereLevel *pLevel, 
	int iEq,            
	int bRev,           
	int iTarget         
) {
	Expr *pX = pTerm->pExpr;
	Vdbe *v = pParse->pVdbe;
	int iReg;                  

	assert(pLevel->pWLoop->aLTerm[iEq] == pTerm);
	assert(iTarget>0);
	if (pX->op == TK_EQ || pX->op == TK_IS) {
		iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
	}
	else if (pX->op == TK_ISNULL) {
		iReg = iTarget;
		sqlite3VdbeAddOp2(v, OP_Null, 0, iReg);
#ifndef SQLITE_OMIT_SUBQUERY
	}
	else {
		int eType = IN_INDEX_NOOP;
		int iTab;
		struct InLoop *pIn;
		WhereLoop *pLoop = pLevel->pWLoop;
		int i;
		int nEq = 0;
		int *aiMap = 0;

		if ((pLoop->wsFlags & WHERE_VIRTUALTABLE) == 0
			&& pLoop->u.btree.pIndex != 0
			&& pLoop->u.btree.pIndex->aSortOrder[iEq]
			) {
			testcase(iEq == 0);
			testcase(bRev);
			bRev = !bRev;
		}
		assert(pX->op == TK_IN);
		iReg = iTarget;

		for (i = 0; i<iEq; i++) {
			if (pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr == pX) {
				disableTerm(pLevel, pTerm);
				return iTarget;
			}
		}
		for (i = iEq; i<pLoop->nLTerm; i++) {
			if (ALWAYS(pLoop->aLTerm[i]) && pLoop->aLTerm[i]->pExpr == pX) nEq++;
		}

		if ((pX->flags & EP_xIsSelect) == 0 || pX->x.pSelect->pEList->nExpr == 1) {
			eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0);
		}
		else {
			Select *pSelect = pX->x.pSelect;
			sqlite3 *db = pParse->db;
			u16 savedDbOptFlags = db->dbOptFlags;
			ExprList *pOrigRhs = pSelect->pEList;
			ExprList *pOrigLhs = pX->pLeft->x.pList;
			ExprList *pRhs = 0;         
			ExprList *pLhs = 0;         

			for (i = iEq; i<pLoop->nLTerm; i++) {
				if (pLoop->aLTerm[i]->pExpr == pX) {
					int iField = pLoop->aLTerm[i]->iField - 1;
					Expr *pNewRhs = sqlite3ExprDup(db, pOrigRhs->a[iField].pExpr, 0);
					Expr *pNewLhs = sqlite3ExprDup(db, pOrigLhs->a[iField].pExpr, 0);

					pRhs = sqlite3ExprListAppend(pParse, pRhs, pNewRhs);
					pLhs = sqlite3ExprListAppend(pParse, pLhs, pNewLhs);
				}
			}
			if (!db->mallocFailed) {
				Expr *pLeft = pX->pLeft;

				if (pSelect->pOrderBy) {
					
					ExprList *pOrderBy = pSelect->pOrderBy;
					for (i = 0; i<pOrderBy->nExpr; i++) {
						pOrderBy->a[i].u.x.iOrderByCol = 0;
					}
				}

				
				if (pLhs->nExpr == 1) {
					pX->pLeft = pLhs->a[0].pExpr;
				}
				else {
					pLeft->x.pList = pLhs;
					aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int) * nEq);
					testcase(aiMap == 0);
				}
				pSelect->pEList = pRhs;
				db->dbOptFlags |= SQLITE_QueryFlattener;
				eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap);
				db->dbOptFlags = savedDbOptFlags;
				testcase(aiMap != 0 && aiMap[0] != 0);
				pSelect->pEList = pOrigRhs;
				pLeft->x.pList = pOrigLhs;
				pX->pLeft = pLeft;
			}
			sqlite3ExprListDelete(pParse->db, pLhs);
			sqlite3ExprListDelete(pParse->db, pRhs);
		}

		if (eType == IN_INDEX_INDEX_DESC) {
			testcase(bRev);
			bRev = !bRev;
		}
		iTab = pX->iTable;
		sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);
		VdbeCoverageIf(v, bRev);
		VdbeCoverageIf(v, !bRev);
		assert((pLoop->wsFlags & WHERE_MULTI_OR) == 0);

		pLoop->wsFlags |= WHERE_IN_ABLE;
		if (pLevel->u.in.nIn == 0) {
			pLevel->addrNxt = sqlite3VdbeMakeLabel(v);
		}

		i = pLevel->u.in.nIn;
		pLevel->u.in.nIn += nEq;
		pLevel->u.in.aInLoop =
			sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,
				sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);
		pIn = pLevel->u.in.aInLoop;
		if (pIn) {
			int iMap = 0;               
			pIn += i;
			for (i = iEq; i<pLoop->nLTerm; i++) {
				if (pLoop->aLTerm[i]->pExpr == pX) {
					int iOut = iReg + i - iEq;
					if (eType == IN_INDEX_ROWID) {
						testcase(nEq>1);  
						pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);
					}
					else {
						int iCol = aiMap ? aiMap[iMap++] : 0;
						pIn->addrInTop = sqlite3VdbeAddOp3(v, OP_Column, iTab, iCol, iOut);
					}
					sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);
					if (i == iEq) {
						pIn->iCur = iTab;
						pIn->eEndLoopOp = bRev ? OP_PrevIfOpen : OP_NextIfOpen;
					}
					else {
						pIn->eEndLoopOp = OP_Noop;
					}
					pIn++;
				}
			}
		}
		else {
			pLevel->u.in.nIn = 0;
		}
		sqlite3DbFree(pParse->db, aiMap);
#endif
	}
	disableTerm(pLevel, pTerm);
	return iReg;
}


static int codeAllEqualityTerms(
	Parse *pParse,        
	WhereLevel *pLevel,   
	int bRev,             
	int nExtraReg,        
	char **pzAff          
) {
	u16 nEq;                      
	u16 nSkip;                    
	Vdbe *v = pParse->pVdbe;      
	Index *pIdx;                  
	WhereTerm *pTerm;             
	WhereLoop *pLoop;             
	int j;                        
	int regBase;                  
	int nReg;                     
	char *zAff;                   

								  
	pLoop = pLevel->pWLoop;
	assert((pLoop->wsFlags & WHERE_VIRTUALTABLE) == 0);
	nEq = pLoop->u.btree.nEq;
	nSkip = pLoop->nSkip;
	pIdx = pLoop->u.btree.pIndex;
	assert(pIdx != 0);

	
	regBase = pParse->nMem + 1;
	nReg = pLoop->u.btree.nEq + nExtraReg;
	pParse->nMem += nReg;

	zAff = sqlite3DbStrDup(pParse->db, sqlite3IndexAffinityStr(pParse->db, pIdx));
	assert(zAff != 0 || pParse->db->mallocFailed);

	if (nSkip) {
		int iIdxCur = pLevel->iIdxCur;
		sqlite3VdbeAddOp1(v, (bRev ? OP_Last : OP_Rewind), iIdxCur);
		VdbeCoverageIf(v, bRev == 0);
		VdbeCoverageIf(v, bRev != 0);
		VdbeComment((v, "begin skip-scan on %s", pIdx->zName));
		j = sqlite3VdbeAddOp0(v, OP_Goto);
		pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev ? OP_SeekLT : OP_SeekGT),
			iIdxCur, 0, regBase, nSkip);
		VdbeCoverageIf(v, bRev == 0);
		VdbeCoverageIf(v, bRev != 0);
		sqlite3VdbeJumpHere(v, j);
		for (j = 0; j<nSkip; j++) {
			sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, j, regBase + j);
			testcase(pIdx->aiColumn[j] == XN_EXPR);
			VdbeComment((v, "%s", explainIndexColumnName(pIdx, j)));
		}
	}

	
	assert(zAff == 0 || (int)strlen(zAff) >= nEq);
	for (j = nSkip; j<nEq; j++) {
		int r1;
		pTerm = pLoop->aLTerm[j];
		assert(pTerm != 0);
		
		testcase((pTerm->wtFlags & TERM_CODED) != 0);
		testcase(pTerm->wtFlags & TERM_VIRTUAL);
		r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase + j);
		if (r1 != regBase + j) {
			if (nReg == 1) {
				sqlite3ReleaseTempReg(pParse, regBase);
				regBase = r1;
			}
			else {
				sqlite3VdbeAddOp2(v, OP_SCopy, r1, regBase + j);
			}
		}
		if (pTerm->eOperator & WO_IN) {
			if (pTerm->pExpr->flags & EP_xIsSelect) {
				
				if (zAff) zAff[j] = SQLITE_AFF_BLOB;
			}
		}
		else if ((pTerm->eOperator & WO_ISNULL) == 0) {
			Expr *pRight = pTerm->pExpr->pRight;
			if ((pTerm->wtFlags & TERM_IS) == 0 && sqlite3ExprCanBeNull(pRight)) {
				sqlite3VdbeAddOp2(v, OP_IsNull, regBase + j, pLevel->addrBrk);
				VdbeCoverage(v);
			}
			if (zAff) {
				if (sqlite3CompareAffinity(pRight, zAff[j]) == SQLITE_AFF_BLOB) {
					zAff[j] = SQLITE_AFF_BLOB;
				}
				if (sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j])) {
					zAff[j] = SQLITE_AFF_BLOB;
				}
			}
		}
	}
	*pzAff = zAff;
	return regBase;
}

#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS

static void whereLikeOptimizationStringFixup(
	Vdbe *v,                
	WhereLevel *pLevel,     
	WhereTerm *pTerm        
) {
	if (pTerm->wtFlags & TERM_LIKEOPT) {
		VdbeOp *pOp;
		assert(pLevel->iLikeRepCntr>0);
		pOp = sqlite3VdbeGetOp(v, -1);
		assert(pOp != 0);
		assert(pOp->opcode == OP_String8
			|| pTerm->pWC->pWInfo->pParse->db->mallocFailed);
		pOp->p3 = (int)(pLevel->iLikeRepCntr >> 1);  
		pOp->p5 = (u8)(pLevel->iLikeRepCntr & 1);    
	}
}
#else
# define whereLikeOptimizationStringFixup(A,B,C)
#endif

#ifdef SQLITE_ENABLE_CURSOR_HINTS

struct CCurHint {
	int iTabCur;    
	int iIdxCur;    
	Index *pIdx;    
};


static int codeCursorHintCheckExpr(Walker *pWalker, Expr *pExpr) {
	struct CCurHint *pHint = pWalker->u.pCCurHint;
	assert(pHint->pIdx != 0);
	if (pExpr->op == TK_COLUMN
		&& pExpr->iTable == pHint->iTabCur
		&& sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn)<0
		) {
		pWalker->eCode = 1;
	}
	return WRC_Continue;
}


static int codeCursorHintIsOrFunction(Walker *pWalker, Expr *pExpr) {
	if (pExpr->op == TK_IS
		|| pExpr->op == TK_ISNULL || pExpr->op == TK_ISNOT
		|| pExpr->op == TK_NOTNULL || pExpr->op == TK_CASE
		) {
		pWalker->eCode = 1;
	}
	else if (pExpr->op == TK_FUNCTION) {
		int d1;
		char d2[3];
		if (0 == sqlite3IsLikeFunction(pWalker->pParse->db, pExpr, &d1, d2)) {
			pWalker->eCode = 1;
		}
	}

	return WRC_Continue;
}



static int codeCursorHintFixExpr(Walker *pWalker, Expr *pExpr) {
	int rc = WRC_Continue;
	struct CCurHint *pHint = pWalker->u.pCCurHint;
	if (pExpr->op == TK_COLUMN) {
		if (pExpr->iTable != pHint->iTabCur) {
			Vdbe *v = pWalker->pParse->pVdbe;
			int reg = ++pWalker->pParse->nMem;   
			sqlite3ExprCodeGetColumnOfTable(
				v, pExpr->pTab, pExpr->iTable, pExpr->iColumn, reg
			);
			pExpr->op = TK_REGISTER;
			pExpr->iTable = reg;
		}
		else if (pHint->pIdx != 0) {
			pExpr->iTable = pHint->iIdxCur;
			pExpr->iColumn = sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn);
			assert(pExpr->iColumn >= 0);
		}
	}
	else if (pExpr->op == TK_AGG_FUNCTION) {
		
		rc = WRC_Prune;
	}
	return rc;
}


static void codeCursorHint(
	struct SrcList_item *pTabItem,  
	WhereInfo *pWInfo,    
	WhereLevel *pLevel,   
	WhereTerm *pEndRange  
) {
	Parse *pParse = pWInfo->pParse;
	sqlite3 *db = pParse->db;
	Vdbe *v = pParse->pVdbe;
	Expr *pExpr = 0;
	WhereLoop *pLoop = pLevel->pWLoop;
	int iCur;
	WhereClause *pWC;
	WhereTerm *pTerm;
	int i, j;
	struct CCurHint sHint;
	Walker sWalker;

	if (OptimizationDisabled(db, SQLITE_CursorHints)) return;
	iCur = pLevel->iTabCur;
	assert(iCur == pWInfo->pTabList->a[pLevel->iFrom].iCursor);
	sHint.iTabCur = iCur;
	sHint.iIdxCur = pLevel->iIdxCur;
	sHint.pIdx = pLoop->u.btree.pIndex;
	memset(&sWalker, 0, sizeof(sWalker));
	sWalker.pParse = pParse;
	sWalker.u.pCCurHint = &sHint;
	pWC = &pWInfo->sWC;
	for (i = 0; i<pWC->nTerm; i++) {
		pTerm = &pWC->a[i];
		if (pTerm->wtFlags & (TERM_VIRTUAL | TERM_CODED)) continue;
		if (pTerm->prereqAll & pLevel->notReady) continue;

		
		if (pTabItem->fg.jointype & JT_LEFT) {
			Expr *pExpr = pTerm->pExpr;
			if (!ExprHasProperty(pExpr, EP_FromJoin)
				|| pExpr->iRightJoinTable != pTabItem->iCursor
				) {
				sWalker.eCode = 0;
				sWalker.xExprCallback = codeCursorHintIsOrFunction;
				sqlite3WalkExpr(&sWalker, pTerm->pExpr);
				if (sWalker.eCode) continue;
			}
		}
		else {
			if (ExprHasProperty(pTerm->pExpr, EP_FromJoin)) continue;
		}

		
		if (pLoop->u.btree.nEq == 0 && pTerm != pEndRange) {
			for (j = 0; j<pLoop->nLTerm && pLoop->aLTerm[j] != pTerm; j++) {}
			if (j<pLoop->nLTerm) continue;
		}

		
		if (sqlite3ExprContainsSubquery(pTerm->pExpr)) continue;

		
		if (sHint.pIdx != 0) {
			sWalker.eCode = 0;
			sWalker.xExprCallback = codeCursorHintCheckExpr;
			sqlite3WalkExpr(&sWalker, pTerm->pExpr);
			if (sWalker.eCode) continue;
		}

		
		pExpr = sqlite3ExprAnd(db, pExpr, sqlite3ExprDup(db, pTerm->pExpr, 0));
	}
	if (pExpr != 0) {
		sWalker.xExprCallback = codeCursorHintFixExpr;
		sqlite3WalkExpr(&sWalker, pExpr);
		sqlite3VdbeAddOp4(v, OP_CursorHint,
			(sHint.pIdx ? sHint.iIdxCur : sHint.iTabCur), 0, 0,
			(const char*)pExpr, P4_EXPR);
	}
}
#else
# define codeCursorHint(A,B,C,D)  
#endif 


static void codeDeferredSeek(
	WhereInfo *pWInfo,              
	Index *pIdx,                    
	int iCur,                       
	int iIdxCur                     
) {
	Parse *pParse = pWInfo->pParse; 
	Vdbe *v = pParse->pVdbe;        

	assert(iIdxCur>0);
	assert(pIdx->aiColumn[pIdx->nColumn - 1] == -1);

	sqlite3VdbeAddOp3(v, OP_Seek, iIdxCur, 0, iCur);
	if ((pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)
		&& DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)
		) {
		int i;
		Table *pTab = pIdx->pTable;
		int *ai = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*(pTab->nCol + 1));
		if (ai) {
			ai[0] = pTab->nCol;
			for (i = 0; i<pIdx->nColumn - 1; i++) {
				assert(pIdx->aiColumn[i]<pTab->nCol);
				if (pIdx->aiColumn[i] >= 0) ai[pIdx->aiColumn[i] + 1] = i + 1;
			}
			sqlite3VdbeChangeP4(v, -1, (char*)ai, P4_INTARRAY);
		}
	}
}


static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg) {
	assert(nReg>0);
	if (sqlite3ExprIsVector(p)) {
#ifndef SQLITE_OMIT_SUBQUERY
		if ((p->flags & EP_xIsSelect)) {
			Vdbe *v = pParse->pVdbe;
			int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);
			sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg - 1);
		}
		else
#endif
		{
			int i;
			ExprList *pList = p->x.pList;
			assert(nReg <= pList->nExpr);
			for (i = 0; i<nReg; i++) {
				sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg + i);
			}
		}
	}
	else {
		assert(nReg == 1);
		sqlite3ExprCode(pParse, p, iReg);
	}
}


SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
	WhereInfo *pWInfo,   
	int iLevel,          
	Bitmask notReady     
) {
	int j, k;            
	int iCur;            
	int addrNxt;         
	int omitTable;       
	int bRev;            
	WhereLevel *pLevel;  
	WhereLoop *pLoop;    
	WhereClause *pWC;    
	WhereTerm *pTerm;               
	Parse *pParse;                  
	sqlite3 *db;                    
	Vdbe *v;                        
	struct SrcList_item *pTabItem;  
	int addrBrk;                    
	int addrCont;                   
	int iRowidReg = 0;        
	int iReleaseReg = 0;      

	pParse = pWInfo->pParse;
	v = pParse->pVdbe;
	pWC = &pWInfo->sWC;
	db = pParse->db;
	pLevel = &pWInfo->a[iLevel];
	pLoop = pLevel->pWLoop;
	pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
	iCur = pTabItem->iCursor;
	pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
	bRev = (pWInfo->revMask >> iLevel) & 1;
	omitTable = (pLoop->wsFlags & WHERE_IDX_ONLY) != 0
		&& (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE) == 0;
	VdbeModuleComment((v, "Begin WHERE-loop%d: %s", iLevel, pTabItem->pTab->zName));

	
	addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(v);
	addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(v);

	
	if (pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT) != 0) {
		pLevel->iLeftJoin = ++pParse->nMem;
		sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin);
		VdbeComment((v, "init LEFT JOIN no-match flag"));
	}

	
	if (pTabItem->fg.viaCoroutine) {
		int regYield = pTabItem->regReturn;
		sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);
		pLevel->p2 = sqlite3VdbeAddOp2(v, OP_Yield, regYield, addrBrk);
		VdbeCoverage(v);
		VdbeComment((v, "next row of \"%s\"", pTabItem->pTab->zName));
		pLevel->op = OP_Goto;
	}
	else

#ifndef SQLITE_OMIT_VIRTUALTABLE
		if ((pLoop->wsFlags & WHERE_VIRTUALTABLE) != 0) {
			
			int iReg;   
			int addrNotFound;
			int nConstraint = pLoop->nLTerm;
			int iIn;    

			sqlite3ExprCachePush(pParse);
			iReg = sqlite3GetTempRange(pParse, nConstraint + 2);
			addrNotFound = pLevel->addrBrk;
			for (j = 0; j<nConstraint; j++) {
				int iTarget = iReg + j + 2;
				pTerm = pLoop->aLTerm[j];
				if (NEVER(pTerm == 0)) continue;
				if (pTerm->eOperator & WO_IN) {
					codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
					addrNotFound = pLevel->addrNxt;
				}
				else {
					Expr *pRight = pTerm->pExpr->pRight;
					codeExprOrVector(pParse, pRight, iTarget, 1);
				}
			}
			sqlite3VdbeAddOp2(v, OP_Integer, pLoop->u.vtab.idxNum, iReg);
			sqlite3VdbeAddOp2(v, OP_Integer, nConstraint, iReg + 1);
			sqlite3VdbeAddOp4(v, OP_VFilter, iCur, addrNotFound, iReg,
				pLoop->u.vtab.idxStr,
				pLoop->u.vtab.needFree ? P4_MPRINTF : P4_STATIC);
			VdbeCoverage(v);
			pLoop->u.vtab.needFree = 0;
			pLevel->p1 = iCur;
			pLevel->op = pWInfo->eOnePass ? OP_Noop : OP_VNext;
			pLevel->p2 = sqlite3VdbeCurrentAddr(v);
			iIn = pLevel->u.in.nIn;
			for (j = nConstraint - 1; j >= 0; j--) {
				pTerm = pLoop->aLTerm[j];
				if (j<16 && (pLoop->u.vtab.omitMask >> j) & 1) {
					disableTerm(pLevel, pTerm);
				}
				else if ((pTerm->eOperator & WO_IN) != 0) {
					Expr *pCompare;  
					Expr *pRight;    
					VdbeOp *pOp;     

									 
					assert(pLevel->u.in.aInLoop != 0 || db->mallocFailed);
					if (!db->mallocFailed) {
						assert(iIn>0);
						pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[--iIn].addrInTop);
						assert(pOp->opcode == OP_Column || pOp->opcode == OP_Rowid);
						assert(pOp->opcode != OP_Column || pOp->p3 == iReg + j + 2);
						assert(pOp->opcode != OP_Rowid || pOp->p2 == iReg + j + 2);
						testcase(pOp->opcode == OP_Rowid);
						sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);
					}

					
					pCompare = sqlite3PExpr(pParse, TK_EQ, 0, 0, 0);
					assert(pCompare != 0 || db->mallocFailed);
					if (pCompare) {
						pCompare->pLeft = pTerm->pExpr->pLeft;
						pCompare->pRight = pRight = sqlite3Expr(db, TK_REGISTER, 0);
						if (pRight) {
							pRight->iTable = iReg + j + 2;
							sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 0);
						}
						pCompare->pLeft = 0;
						sqlite3ExprDelete(db, pCompare);
					}
				}
			}
			
			sqlite3ExprCachePop(pParse);
		}
		else
#endif 

			if ((pLoop->wsFlags & WHERE_IPK) != 0
				&& (pLoop->wsFlags & (WHERE_COLUMN_IN | WHERE_COLUMN_EQ)) != 0
				) {
				
				assert(pLoop->u.btree.nEq == 1);
				pTerm = pLoop->aLTerm[0];
				assert(pTerm != 0);
				assert(pTerm->pExpr != 0);
				assert(omitTable == 0);
				testcase(pTerm->wtFlags & TERM_VIRTUAL);
				iReleaseReg = ++pParse->nMem;
				iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
				if (iRowidReg != iReleaseReg) sqlite3ReleaseTempReg(pParse, iReleaseReg);
				addrNxt = pLevel->addrNxt;
				sqlite3VdbeAddOp3(v, OP_SeekRowid, iCur, addrNxt, iRowidReg);
				VdbeCoverage(v);
				sqlite3ExprCacheAffinityChange(pParse, iRowidReg, 1);
				sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
				VdbeComment((v, "pk"));
				pLevel->op = OP_Noop;
			}
			else if ((pLoop->wsFlags & WHERE_IPK) != 0
				&& (pLoop->wsFlags & WHERE_COLUMN_RANGE) != 0
				) {
				
				int testOp = OP_Noop;
				int start;
				int memEndValue = 0;
				WhereTerm *pStart, *pEnd;

				assert(omitTable == 0);
				j = 0;
				pStart = pEnd = 0;
				if (pLoop->wsFlags & WHERE_BTM_LIMIT) pStart = pLoop->aLTerm[j++];
				if (pLoop->wsFlags & WHERE_TOP_LIMIT) pEnd = pLoop->aLTerm[j++];
				assert(pStart != 0 || pEnd != 0);
				if (bRev) {
					pTerm = pStart;
					pStart = pEnd;
					pEnd = pTerm;
				}
				codeCursorHint(pTabItem, pWInfo, pLevel, pEnd);
				if (pStart) {
					Expr *pX;             
					int r1, rTemp;        
					int op;               

										  
					const u8 aMoveOp[] = {
						  OP_SeekGT,
						  OP_SeekLE,
						  OP_SeekLT,
						  OP_SeekGE
					};
					assert(TK_LE == TK_GT + 1);      
					assert(TK_LT == TK_GT + 2);      
					assert(TK_GE == TK_GT + 3);      

					assert((pStart->wtFlags & TERM_VNULL) == 0);
					testcase(pStart->wtFlags & TERM_VIRTUAL);
					pX = pStart->pExpr;
					assert(pX != 0);
					testcase(pStart->leftCursor != iCur); 
					if (sqlite3ExprIsVector(pX->pRight)) {
						r1 = rTemp = sqlite3GetTempReg(pParse);
						codeExprOrVector(pParse, pX->pRight, r1, 1);
						op = aMoveOp[(pX->op - TK_GT) | 0x0001];
					}
					else {
						r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
						disableTerm(pLevel, pStart);
						op = aMoveOp[(pX->op - TK_GT)];
					}
					sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);
					VdbeComment((v, "pk"));
					VdbeCoverageIf(v, pX->op == TK_GT);
					VdbeCoverageIf(v, pX->op == TK_LE);
					VdbeCoverageIf(v, pX->op == TK_LT);
					VdbeCoverageIf(v, pX->op == TK_GE);
					sqlite3ExprCacheAffinityChange(pParse, r1, 1);
					sqlite3ReleaseTempReg(pParse, rTemp);
				}
				else {
					sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iCur, addrBrk);
					VdbeCoverageIf(v, bRev == 0);
					VdbeCoverageIf(v, bRev != 0);
				}
				if (pEnd) {
					Expr *pX;
					pX = pEnd->pExpr;
					assert(pX != 0);
					assert((pEnd->wtFlags & TERM_VNULL) == 0);
					testcase(pEnd->leftCursor != iCur); 
					testcase(pEnd->wtFlags & TERM_VIRTUAL);
					memEndValue = ++pParse->nMem;
					codeExprOrVector(pParse, pX->pRight, memEndValue, 1);
					if (0 == sqlite3ExprIsVector(pX->pRight)
						&& (pX->op == TK_LT || pX->op == TK_GT)
						) {
						testOp = bRev ? OP_Le : OP_Ge;
					}
					else {
						testOp = bRev ? OP_Lt : OP_Gt;
					}
					if (0 == sqlite3ExprIsVector(pX->pRight)) {
						disableTerm(pLevel, pEnd);
					}
				}
				start = sqlite3VdbeCurrentAddr(v);
				pLevel->op = bRev ? OP_Prev : OP_Next;
				pLevel->p1 = iCur;
				pLevel->p2 = start;
				assert(pLevel->p5 == 0);
				if (testOp != OP_Noop) {
					iRowidReg = ++pParse->nMem;
					sqlite3VdbeAddOp2(v, OP_Rowid, iCur, iRowidReg);
					sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
					sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
					VdbeCoverageIf(v, testOp == OP_Le);
					VdbeCoverageIf(v, testOp == OP_Lt);
					VdbeCoverageIf(v, testOp == OP_Ge);
					VdbeCoverageIf(v, testOp == OP_Gt);
					sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL);
				}
			}
			else if (pLoop->wsFlags & WHERE_INDEXED) {
				
				static const u8 aStartOp[] = {
					0,
					0,
					OP_Rewind,           
					OP_Last,             
					OP_SeekGT,           
					OP_SeekLT,           
					OP_SeekGE,           
					OP_SeekLE            
				};
				static const u8 aEndOp[] = {
					OP_IdxGE,            
					OP_IdxGT,            
					OP_IdxLE,            
					OP_IdxLT,            
				};
				u16 nEq = pLoop->u.btree.nEq;     
				u16 nBtm = pLoop->u.btree.nBtm;   
				u16 nTop = pLoop->u.btree.nTop;   
				int regBase;                 
				WhereTerm *pRangeStart = 0;  
				WhereTerm *pRangeEnd = 0;    
				int startEq;                 
				int endEq;                   
				int start_constraints;       
				int nConstraint;             
				Index *pIdx;                 
				int iIdxCur;                 
				int nExtraReg = 0;           
				int op;                      
				char *zStartAff;             
				char *zEndAff = 0;           
				u8 bSeekPastNull = 0;        
				u8 bStopAtNull = 0;          

				pIdx = pLoop->u.btree.pIndex;
				iIdxCur = pLevel->iIdxCur;
				assert(nEq >= pLoop->nSkip);

				
				assert(pWInfo->pOrderBy == 0
					|| pWInfo->pOrderBy->nExpr == 1
					|| (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN) == 0);
				if ((pWInfo->wctrlFlags&WHERE_ORDERBY_MIN) != 0
					&& pWInfo->nOBSat>0
					&& (pIdx->nKeyCol>nEq)
					) {
					assert(pLoop->nSkip == 0);
					bSeekPastNull = 1;
					nExtraReg = 1;
				}

				
				j = nEq;
				if (pLoop->wsFlags & WHERE_BTM_LIMIT) {
					pRangeStart = pLoop->aLTerm[j++];
					nExtraReg = MAX(nExtraReg, pLoop->u.btree.nBtm);
					
					assert((pRangeStart->wtFlags & TERM_LIKEOPT) == 0 ||
						(pLoop->wsFlags & WHERE_TOP_LIMIT) != 0);
				}
				if (pLoop->wsFlags & WHERE_TOP_LIMIT) {
					pRangeEnd = pLoop->aLTerm[j++];
					nExtraReg = MAX(nExtraReg, pLoop->u.btree.nTop);
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
					if ((pRangeEnd->wtFlags & TERM_LIKEOPT) != 0) {
						assert(pRangeStart != 0);                     
						assert(pRangeStart->wtFlags & TERM_LIKEOPT);   
						pLevel->iLikeRepCntr = (u32)++pParse->nMem;
						sqlite3VdbeAddOp2(v, OP_Integer, 1, (int)pLevel->iLikeRepCntr);
						VdbeComment((v, "LIKE loop counter"));
						pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);
						
						testcase(bRev);
						testcase(pIdx->aSortOrder[nEq] == SQLITE_SO_DESC);
						assert((bRev & ~1) == 0);
						pLevel->iLikeRepCntr <<= 1;
						pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq] == SQLITE_SO_DESC);
					}
#endif
					if (pRangeStart == 0) {
						j = pIdx->aiColumn[nEq];
						if ((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) || j == XN_EXPR) {
							bSeekPastNull = 1;
						}
					}
				}
				assert(pRangeEnd == 0 || (pRangeEnd->wtFlags & TERM_VNULL) == 0);

				
				if ((nEq<pIdx->nKeyCol && bRev == (pIdx->aSortOrder[nEq] == SQLITE_SO_ASC))
					|| (bRev && pIdx->nKeyCol == nEq)
					) {
					SWAP(WhereTerm *, pRangeEnd, pRangeStart);
					SWAP(u8, bSeekPastNull, bStopAtNull);
					SWAP(u8, nBtm, nTop);
				}

				
				codeCursorHint(pTabItem, pWInfo, pLevel, pRangeEnd);
				regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, &zStartAff);
				assert(zStartAff == 0 || sqlite3Strlen30(zStartAff) >= nEq);
				if (zStartAff && nTop) {
					zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
				}
				addrNxt = pLevel->addrNxt;

				testcase(pRangeStart && (pRangeStart->eOperator & WO_LE) != 0);
				testcase(pRangeStart && (pRangeStart->eOperator & WO_GE) != 0);
				testcase(pRangeEnd && (pRangeEnd->eOperator & WO_LE) != 0);
				testcase(pRangeEnd && (pRangeEnd->eOperator & WO_GE) != 0);
				startEq = !pRangeStart || pRangeStart->eOperator & (WO_LE | WO_GE);
				endEq = !pRangeEnd || pRangeEnd->eOperator & (WO_LE | WO_GE);
				start_constraints = pRangeStart || nEq>0;

				
				nConstraint = nEq;
				if (pRangeStart) {
					Expr *pRight = pRangeStart->pExpr->pRight;
					codeExprOrVector(pParse, pRight, regBase + nEq, nBtm);
					whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
					if ((pRangeStart->wtFlags & TERM_VNULL) == 0
						&& sqlite3ExprCanBeNull(pRight)
						) {
						sqlite3VdbeAddOp2(v, OP_IsNull, regBase + nEq, addrNxt);
						VdbeCoverage(v);
					}
					if (zStartAff) {
						updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);
					}
					nConstraint += nBtm;
					testcase(pRangeStart->wtFlags & TERM_VIRTUAL);
					if (sqlite3ExprIsVector(pRight) == 0) {
						disableTerm(pLevel, pRangeStart);
					}
					else {
						startEq = 1;
					}
					bSeekPastNull = 0;
				}
				else if (bSeekPastNull) {
					sqlite3VdbeAddOp2(v, OP_Null, 0, regBase + nEq);
					nConstraint++;
					startEq = 0;
					start_constraints = 1;
				}
				codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);
				if (pLoop->nSkip>0 && nConstraint == pLoop->nSkip) {
					
				}
				else {
					op = aStartOp[(start_constraints << 2) + (startEq << 1) + bRev];
					assert(op != 0);
					sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
					VdbeCoverage(v);
					VdbeCoverageIf(v, op == OP_Rewind);  testcase(op == OP_Rewind);
					VdbeCoverageIf(v, op == OP_Last);    testcase(op == OP_Last);
					VdbeCoverageIf(v, op == OP_SeekGT);  testcase(op == OP_SeekGT);
					VdbeCoverageIf(v, op == OP_SeekGE);  testcase(op == OP_SeekGE);
					VdbeCoverageIf(v, op == OP_SeekLE);  testcase(op == OP_SeekLE);
					VdbeCoverageIf(v, op == OP_SeekLT);  testcase(op == OP_SeekLT);
				}

				
				nConstraint = nEq;
				if (pRangeEnd) {
					Expr *pRight = pRangeEnd->pExpr->pRight;
					sqlite3ExprCacheRemove(pParse, regBase + nEq, 1);
					codeExprOrVector(pParse, pRight, regBase + nEq, nTop);
					whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
					if ((pRangeEnd->wtFlags & TERM_VNULL) == 0
						&& sqlite3ExprCanBeNull(pRight)
						) {
						sqlite3VdbeAddOp2(v, OP_IsNull, regBase + nEq, addrNxt);
						VdbeCoverage(v);
					}
					if (zEndAff) {
						updateRangeAffinityStr(pRight, nTop, zEndAff);
						codeApplyAffinity(pParse, regBase + nEq, nTop, zEndAff);
					}
					else {
						assert(pParse->db->mallocFailed);
					}
					nConstraint += nTop;
					testcase(pRangeEnd->wtFlags & TERM_VIRTUAL);

					if (sqlite3ExprIsVector(pRight) == 0) {
						disableTerm(pLevel, pRangeEnd);
					}
					else {
						endEq = 1;
					}
				}
				else if (bStopAtNull) {
					sqlite3VdbeAddOp2(v, OP_Null, 0, regBase + nEq);
					endEq = 0;
					nConstraint++;
				}
				sqlite3DbFree(db, zStartAff);
				sqlite3DbFree(db, zEndAff);

				
				pLevel->p2 = sqlite3VdbeCurrentAddr(v);

				
				if (nConstraint) {
					op = aEndOp[bRev * 2 + endEq];
					sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
					testcase(op == OP_IdxGT);  VdbeCoverageIf(v, op == OP_IdxGT);
					testcase(op == OP_IdxGE);  VdbeCoverageIf(v, op == OP_IdxGE);
					testcase(op == OP_IdxLT);  VdbeCoverageIf(v, op == OP_IdxLT);
					testcase(op == OP_IdxLE);  VdbeCoverageIf(v, op == OP_IdxLE);
				}

				
				if (omitTable) {
					
				}
				else if (HasRowid(pIdx->pTable)) {
					if ((pWInfo->wctrlFlags & WHERE_SEEK_TABLE) != 0) {
						iRowidReg = ++pParse->nMem;
						sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, iRowidReg);
						sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
						sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, iRowidReg);
						VdbeCoverage(v);
					}
					else {
						codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
					}
				}
				else if (iCur != iIdxCur) {
					Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
					iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);
					for (j = 0; j<pPk->nKeyCol; j++) {
						k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);
						sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, iRowidReg + j);
					}
					sqlite3VdbeAddOp4Int(v, OP_NotFound, iCur, addrCont,
						iRowidReg, pPk->nKeyCol); VdbeCoverage(v);
				}

				
				if (pLoop->wsFlags & WHERE_ONEROW) {
					pLevel->op = OP_Noop;
				}
				else if (bRev) {
					pLevel->op = OP_Prev;
				}
				else {
					pLevel->op = OP_Next;
				}
				pLevel->p1 = iIdxCur;
				pLevel->p3 = (pLoop->wsFlags&WHERE_UNQ_WANTED) != 0 ? 1 : 0;
				if ((pLoop->wsFlags & WHERE_CONSTRAINT) == 0) {
					pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;
				}
				else {
					assert(pLevel->p5 == 0);
				}
			}
			else

#ifndef SQLITE_OMIT_OR_OPTIMIZATION
				if (pLoop->wsFlags & WHERE_MULTI_OR) {
					
					WhereClause *pOrWc;    
					SrcList *pOrTab;       
					Index *pCov = 0;             
					int iCovCur = pParse->nTab++;  

					int regReturn = ++pParse->nMem;           
					int regRowset = 0;                        
					int regRowid = 0;                         
					int iLoopBody = sqlite3VdbeMakeLabel(v);  
					int iRetInit;                             
					int untestedTerms = 0;             
					int ii;                            
					u16 wctrlFlags;                    
					Expr *pAndExpr = 0;                
					Table *pTab = pTabItem->pTab;

					pTerm = pLoop->aLTerm[0];
					assert(pTerm != 0);
					assert(pTerm->eOperator & WO_OR);
					assert((pTerm->wtFlags & TERM_ORINFO) != 0);
					pOrWc = &pTerm->u.pOrInfo->wc;
					pLevel->op = OP_Return;
					pLevel->p1 = regReturn;

					
					if (pWInfo->nLevel>1) {
						int nNotReady;                 
						struct SrcList_item *origSrc;     
						nNotReady = pWInfo->nLevel - iLevel - 1;
						pOrTab = sqlite3StackAllocRaw(db,
							sizeof(*pOrTab) + nNotReady * sizeof(pOrTab->a[0]));
						if (pOrTab == 0) return notReady;
						pOrTab->nAlloc = (u8)(nNotReady + 1);
						pOrTab->nSrc = pOrTab->nAlloc;
						memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
						origSrc = pWInfo->pTabList->a;
						for (k = 1; k <= nNotReady; k++) {
							memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
						}
					}
					else {
						pOrTab = pWInfo->pTabList;
					}

					
					if ((pWInfo->wctrlFlags & WHERE_DUPLICATES_OK) == 0) {
						if (HasRowid(pTab)) {
							regRowset = ++pParse->nMem;
							sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset);
						}
						else {
							Index *pPk = sqlite3PrimaryKeyIndex(pTab);
							regRowset = pParse->nTab++;
							sqlite3VdbeAddOp2(v, OP_OpenEphemeral, regRowset, pPk->nKeyCol);
							sqlite3VdbeSetP4KeyInfo(pParse, pPk);
						}
						regRowid = ++pParse->nMem;
					}
					iRetInit = sqlite3VdbeAddOp2(v, OP_Integer, 0, regReturn);

					
					if (pWC->nTerm>1) {
						int iTerm;
						for (iTerm = 0; iTerm<pWC->nTerm; iTerm++) {
							Expr *pExpr = pWC->a[iTerm].pExpr;
							if (&pWC->a[iTerm] == pTerm) continue;
							if (ExprHasProperty(pExpr, EP_FromJoin)) continue;
							testcase(pWC->a[iTerm].wtFlags & TERM_VIRTUAL);
							testcase(pWC->a[iTerm].wtFlags & TERM_CODED);
							if ((pWC->a[iTerm].wtFlags & (TERM_VIRTUAL | TERM_CODED)) != 0) continue;
							if ((pWC->a[iTerm].eOperator & WO_ALL) == 0) continue;
							testcase(pWC->a[iTerm].wtFlags & TERM_ORINFO);
							pExpr = sqlite3ExprDup(db, pExpr, 0);
							pAndExpr = sqlite3ExprAnd(db, pAndExpr, pExpr);
						}
						if (pAndExpr) {
							pAndExpr = sqlite3PExpr(pParse, TK_AND | TKFLG_DONTFOLD, 0, pAndExpr, 0);
						}
					}

					
					wctrlFlags = WHERE_OR_SUBCLAUSE | (pWInfo->wctrlFlags & WHERE_SEEK_TABLE);
					for (ii = 0; ii<pOrWc->nTerm; ii++) {
						WhereTerm *pOrTerm = &pOrWc->a[ii];
						if (pOrTerm->leftCursor == iCur || (pOrTerm->eOperator & WO_AND) != 0) {
							WhereInfo *pSubWInfo;           
							Expr *pOrExpr = pOrTerm->pExpr; 
							int jmp1 = 0;                   
							if (pAndExpr && !ExprHasProperty(pOrExpr, EP_FromJoin)) {
								pAndExpr->pLeft = pOrExpr;
								pOrExpr = pAndExpr;
							}
							
							WHERETRACE(0xffff, ("Subplan for OR-clause:\n"));
							pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0,
								wctrlFlags, iCovCur);
							assert(pSubWInfo || pParse->nErr || db->mallocFailed);
							if (pSubWInfo) {
								WhereLoop *pSubLoop;
								int addrExplain = sqlite3WhereExplainOneScan(
									pParse, pOrTab, &pSubWInfo->a[0], iLevel, pLevel->iFrom, 0
								);
								sqlite3WhereAddScanStatus(v, pOrTab, &pSubWInfo->a[0], addrExplain);

								
								if ((pWInfo->wctrlFlags & WHERE_DUPLICATES_OK) == 0) {
									int r;
									int iSet = ((ii == pOrWc->nTerm - 1) ? -1 : ii);
									if (HasRowid(pTab)) {
										r = sqlite3ExprCodeGetColumn(pParse, pTab, -1, iCur, regRowid, 0);
										jmp1 = sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset, 0,
											r, iSet);
										VdbeCoverage(v);
									}
									else {
										Index *pPk = sqlite3PrimaryKeyIndex(pTab);
										int nPk = pPk->nKeyCol;
										int iPk;

										
										r = sqlite3GetTempRange(pParse, nPk);
										for (iPk = 0; iPk<nPk; iPk++) {
											int iCol = pPk->aiColumn[iPk];
											sqlite3ExprCodeGetColumnToReg(pParse, pTab, iCol, iCur, r + iPk);
										}

										
										if (iSet) {
											jmp1 = sqlite3VdbeAddOp4Int(v, OP_Found, regRowset, 0, r, nPk);
											VdbeCoverage(v);
										}
										if (iSet >= 0) {
											sqlite3VdbeAddOp3(v, OP_MakeRecord, r, nPk, regRowid);
											sqlite3VdbeAddOp3(v, OP_IdxInsert, regRowset, regRowid, 0);
											if (iSet) sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
										}

										
										sqlite3ReleaseTempRange(pParse, r, nPk);
									}
								}

								
								sqlite3VdbeAddOp2(v, OP_Gosub, regReturn, iLoopBody);

								
								if (jmp1) sqlite3VdbeJumpHere(v, jmp1);

								
								if (pSubWInfo->untestedTerms) untestedTerms = 1;

								
								pSubLoop = pSubWInfo->a[0].pWLoop;
								assert((pSubLoop->wsFlags & WHERE_AUTO_INDEX) == 0);
								if ((pSubLoop->wsFlags & WHERE_INDEXED) != 0
									&& (ii == 0 || pSubLoop->u.btree.pIndex == pCov)
									&& (HasRowid(pTab) || !IsPrimaryKeyIndex(pSubLoop->u.btree.pIndex))
									) {
									assert(pSubWInfo->a[0].iIdxCur == iCovCur);
									pCov = pSubLoop->u.btree.pIndex;
								}
								else {
									pCov = 0;
								}

								
								sqlite3WhereEnd(pSubWInfo);
							}
						}
					}
					pLevel->u.pCovidx = pCov;
					if (pCov) pLevel->iIdxCur = iCovCur;
					if (pAndExpr) {
						pAndExpr->pLeft = 0;
						sqlite3ExprDelete(db, pAndExpr);
					}
					sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
					sqlite3VdbeGoto(v, pLevel->addrBrk);
					sqlite3VdbeResolveLabel(v, iLoopBody);

					if (pWInfo->nLevel>1) sqlite3StackFree(db, pOrTab);
					if (!untestedTerms) disableTerm(pLevel, pTerm);
				}
				else
#endif 

				{
					
					static const u8 aStep[] = { OP_Next, OP_Prev };
					static const u8 aStart[] = { OP_Rewind, OP_Last };
					assert(bRev == 0 || bRev == 1);
					if (pTabItem->fg.isRecursive) {
						
						pLevel->op = OP_Noop;
					}
					else {
						codeCursorHint(pTabItem, pWInfo, pLevel, 0);
						pLevel->op = aStep[bRev];
						pLevel->p1 = iCur;
						pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrBrk);
						VdbeCoverageIf(v, bRev == 0);
						VdbeCoverageIf(v, bRev != 0);
						pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;
					}
				}

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
	pLevel->addrVisit = sqlite3VdbeCurrentAddr(v);
#endif

	
	for (pTerm = pWC->a, j = pWC->nTerm; j>0; j--, pTerm++) {
		Expr *pE;
		int skipLikeAddr = 0;
		testcase(pTerm->wtFlags & TERM_VIRTUAL);
		testcase(pTerm->wtFlags & TERM_CODED);
		if (pTerm->wtFlags & (TERM_VIRTUAL | TERM_CODED)) continue;
		if ((pTerm->prereqAll & pLevel->notReady) != 0) {
			testcase(pWInfo->untestedTerms == 0
				&& (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE) != 0);
			pWInfo->untestedTerms = 1;
			continue;
		}
		pE = pTerm->pExpr;
		assert(pE != 0);
		if (pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin)) {
			continue;
		}
		if (pTerm->wtFlags & TERM_LIKECOND) {
			
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
			continue;
#else
			u32 x = pLevel->iLikeRepCntr;
			assert(x>0);
			skipLikeAddr = sqlite3VdbeAddOp1(v, (x & 1) ? OP_IfNot : OP_If, (int)(x >> 1));
			VdbeCoverage(v);
#endif
		}
		sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);
		if (skipLikeAddr) sqlite3VdbeJumpHere(v, skipLikeAddr);
		pTerm->wtFlags |= TERM_CODED;
	}

	
	for (pTerm = pWC->a, j = pWC->nTerm; j>0; j--, pTerm++) {
		Expr *pE, sEAlt;
		WhereTerm *pAlt;
		if (pTerm->wtFlags & (TERM_VIRTUAL | TERM_CODED)) continue;
		if ((pTerm->eOperator & (WO_EQ | WO_IS)) == 0) continue;
		if ((pTerm->eOperator & WO_EQUIV) == 0) continue;
		if (pTerm->leftCursor != iCur) continue;
		if (pLevel->iLeftJoin) continue;
		pE = pTerm->pExpr;
		assert(!ExprHasProperty(pE, EP_FromJoin));
		assert((pTerm->prereqRight & pLevel->notReady) != 0);
		pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.leftColumn, notReady,
			WO_EQ | WO_IN | WO_IS, 0);
		if (pAlt == 0) continue;
		if (pAlt->wtFlags & (TERM_CODED)) continue;
		testcase(pAlt->eOperator & WO_EQ);
		testcase(pAlt->eOperator & WO_IS);
		testcase(pAlt->eOperator & WO_IN);
		VdbeModuleComment((v, "begin transitive constraint"));
		sEAlt = *pAlt->pExpr;
		sEAlt.pLeft = pE->pLeft;
		sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, SQLITE_JUMPIFNULL);
	}

	
	if (pLevel->iLeftJoin) {
		pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
		sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->iLeftJoin);
		VdbeComment((v, "record LEFT JOIN hit"));
		sqlite3ExprCacheClear(pParse);
		for (pTerm = pWC->a, j = 0; j<pWC->nTerm; j++, pTerm++) {
			testcase(pTerm->wtFlags & TERM_VIRTUAL);
			testcase(pTerm->wtFlags & TERM_CODED);
			if (pTerm->wtFlags & (TERM_VIRTUAL | TERM_CODED)) continue;
			if ((pTerm->prereqAll & pLevel->notReady) != 0) {
				assert(pWInfo->untestedTerms);
				continue;
			}
			assert(pTerm->pExpr);
			sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, SQLITE_JUMPIFNULL);
			pTerm->wtFlags |= TERM_CODED;
		}
	}

	return pLevel->notReady;
}








static void exprAnalyze(SrcList*, WhereClause*, int);


static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p) {
	sqlite3WhereClauseClear(&p->wc);
	sqlite3DbFree(db, p);
}


static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p) {
	sqlite3WhereClauseClear(&p->wc);
	sqlite3DbFree(db, p);
}


static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags) {
	WhereTerm *pTerm;
	int idx;
	testcase(wtFlags & TERM_VIRTUAL);
	if (pWC->nTerm >= pWC->nSlot) {
		WhereTerm *pOld = pWC->a;
		sqlite3 *db = pWC->pWInfo->pParse->db;
		pWC->a = sqlite3DbMallocRawNN(db, sizeof(pWC->a[0])*pWC->nSlot * 2);
		if (pWC->a == 0) {
			if (wtFlags & TERM_DYNAMIC) {
				sqlite3ExprDelete(db, p);
			}
			pWC->a = pOld;
			return 0;
		}
		memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
		if (pOld != pWC->aStatic) {
			sqlite3DbFree(db, pOld);
		}
		pWC->nSlot = sqlite3DbMallocSize(db, pWC->a) / sizeof(pWC->a[0]);
	}
	pTerm = &pWC->a[idx = pWC->nTerm++];
	if (p && ExprHasProperty(p, EP_Unlikely)) {
		pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;
	}
	else {
		pTerm->truthProb = 1;
	}
	pTerm->pExpr = sqlite3ExprSkipCollate(p);
	pTerm->wtFlags = wtFlags;
	pTerm->pWC = pWC;
	pTerm->iParent = -1;
	memset(&pTerm->eOperator, 0,
		sizeof(WhereTerm) - offsetof(WhereTerm, eOperator));
	return idx;
}


static int allowedOp(int op) {
	assert(TK_GT>TK_EQ && TK_GT<TK_GE);
	assert(TK_LT>TK_EQ && TK_LT<TK_GE);
	assert(TK_LE>TK_EQ && TK_LE<TK_GE);
	assert(TK_GE == TK_EQ + 4);
	return op == TK_IN || (op >= TK_EQ && op <= TK_GE) || op == TK_ISNULL || op == TK_IS;
}


static void exprCommute(Parse *pParse, Expr *pExpr) {
	u16 expRight = (pExpr->pRight->flags & EP_Collate);
	u16 expLeft = (pExpr->pLeft->flags & EP_Collate);
	assert(allowedOp(pExpr->op) && pExpr->op != TK_IN);
	if (expRight == expLeft) {
		
		if (expRight) {
			
			pExpr->pRight->flags &= ~EP_Collate;
		}
		else if (sqlite3ExprCollSeq(pParse, pExpr->pLeft) != 0) {
			
			pExpr->pLeft->flags |= EP_Collate;
		}
	}
	SWAP(Expr*, pExpr->pRight, pExpr->pLeft);
	if (pExpr->op >= TK_GT) {
		assert(TK_LT == TK_GT + 2);
		assert(TK_GE == TK_LE + 2);
		assert(TK_GT>TK_EQ);
		assert(TK_GT<TK_LE);
		assert(pExpr->op >= TK_GT && pExpr->op <= TK_GE);
		pExpr->op = ((pExpr->op - TK_GT) ^ 2) + TK_GT;
	}
}


static u16 operatorMask(int op) {
	u16 c;
	assert(allowedOp(op));
	if (op == TK_IN) {
		c = WO_IN;
	}
	else if (op == TK_ISNULL) {
		c = WO_ISNULL;
	}
	else if (op == TK_IS) {
		c = WO_IS;
	}
	else {
		assert((WO_EQ << (op - TK_EQ)) < 0x7fff);
		c = (u16)(WO_EQ << (op - TK_EQ));
	}
	assert(op != TK_ISNULL || c == WO_ISNULL);
	assert(op != TK_IN || c == WO_IN);
	assert(op != TK_EQ || c == WO_EQ);
	assert(op != TK_LT || c == WO_LT);
	assert(op != TK_LE || c == WO_LE);
	assert(op != TK_GT || c == WO_GT);
	assert(op != TK_GE || c == WO_GE);
	assert(op != TK_IS || c == WO_IS);
	return c;
}


#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION

static int isLikeOrGlob(
	Parse *pParse,    
	Expr *pExpr,      
	Expr **ppPrefix,  
	int *pisComplete, 
	int *pnoCase      
) {
	const char *z = 0;         
	Expr *pRight, *pLeft;      
	ExprList *pList;           
	int c;                     
	int cnt;                   
	char wc[3];                
	sqlite3 *db = pParse->db;  
	sqlite3_value *pVal = 0;
	int op;                    
	int rc;                    

	if (!sqlite3IsLikeFunction(db, pExpr, pnoCase, wc)) {
		return 0;
	}
#ifdef SQLITE_EBCDIC
	if (*pnoCase) return 0;
#endif
	pList = pExpr->x.pList;
	pLeft = pList->a[1].pExpr;
	if (pLeft->op != TK_COLUMN
		|| sqlite3ExprAffinity(pLeft) != SQLITE_AFF_TEXT
		|| IsVirtual(pLeft->pTab)  
		) {
		
		return 0;
	}
	assert(pLeft->iColumn != (-1)); 

	pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);
	op = pRight->op;
	if (op == TK_VARIABLE) {
		Vdbe *pReprepare = pParse->pReprepare;
		int iCol = pRight->iColumn;
		pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, SQLITE_AFF_BLOB);
		if (pVal && sqlite3_value_type(pVal) == SQLITE_TEXT) {
			z = (char *)sqlite3_value_text(pVal);
		}
		sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
		assert(pRight->op == TK_VARIABLE || pRight->op == TK_REGISTER);
	}
	else if (op == TK_STRING) {
		z = pRight->u.zToken;
	}
	if (z) {
		cnt = 0;
		while ((c = z[cnt]) != 0 && c != wc[0] && c != wc[1] && c != wc[2]) {
			cnt++;
		}
		if (cnt != 0 && 255 != (u8)z[cnt - 1]) {
			Expr *pPrefix;
			*pisComplete = c == wc[0] && z[cnt + 1] == 0;
			pPrefix = sqlite3Expr(db, TK_STRING, z);
			if (pPrefix) pPrefix->u.zToken[cnt] = 0;
			*ppPrefix = pPrefix;
			if (op == TK_VARIABLE) {
				Vdbe *v = pParse->pVdbe;
				sqlite3VdbeSetVarmask(v, pRight->iColumn);
				if (*pisComplete && pRight->u.zToken[1]) {
					
					int r1 = sqlite3GetTempReg(pParse);
					sqlite3ExprCodeTarget(pParse, pRight, r1);
					sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v) - 1, 0);
					sqlite3ReleaseTempReg(pParse, r1);
				}
			}
		}
		else {
			z = 0;
		}
	}

	rc = (z != 0);
	sqlite3ValueFree(pVal);
	return rc;
}
#endif 


#ifndef SQLITE_OMIT_VIRTUALTABLE

static int isMatchOfColumn(
	Expr *pExpr,                    
	unsigned char *peOp2            
) {
	static const struct Op2 {
		const char *zOp;
		unsigned char eOp2;
	} aOp[] = {
		{ "match",  SQLITE_INDEX_CONSTRAINT_MATCH },
		{ "glob",   SQLITE_INDEX_CONSTRAINT_GLOB },
		{ "like",   SQLITE_INDEX_CONSTRAINT_LIKE },
		{ "regexp", SQLITE_INDEX_CONSTRAINT_REGEXP }
	};
	ExprList *pList;
	Expr *pCol;                     
	int i;

	if (pExpr->op != TK_FUNCTION) {
		return 0;
	}
	pList = pExpr->x.pList;
	if (pList == 0 || pList->nExpr != 2) {
		return 0;
	}
	pCol = pList->a[1].pExpr;
	if (pCol->op != TK_COLUMN || !IsVirtual(pCol->pTab)) {
		return 0;
	}
	for (i = 0; i<ArraySize(aOp); i++) {
		if (sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp) == 0) {
			*peOp2 = aOp[i].eOp2;
			return 1;
		}
	}
	return 0;
}
#endif 


static void transferJoinMarkings(Expr *pDerived, Expr *pBase) {
	if (pDerived) {
		pDerived->flags |= pBase->flags & EP_FromJoin;
		pDerived->iRightJoinTable = pBase->iRightJoinTable;
	}
}


static void markTermAsChild(WhereClause *pWC, int iChild, int iParent) {
	pWC->a[iChild].iParent = iParent;
	pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;
	pWC->a[iParent].nChild++;
}


static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N) {
	if (pTerm->eOperator != WO_AND) {
		return N == 0 ? pTerm : 0;
	}
	if (N<pTerm->u.pAndInfo->wc.nTerm) {
		return &pTerm->u.pAndInfo->wc.a[N];
	}
	return 0;
}


static void whereCombineDisjuncts(
	SrcList *pSrc,         
	WhereClause *pWC,      
	WhereTerm *pOne,       
	WhereTerm *pTwo        
) {
	u16 eOp = pOne->eOperator | pTwo->eOperator;
	sqlite3 *db;           
	Expr *pNew;            
	int op;                
	int idxNew;            

	if ((pOne->eOperator & (WO_EQ | WO_LT | WO_LE | WO_GT | WO_GE)) == 0) return;
	if ((pTwo->eOperator & (WO_EQ | WO_LT | WO_LE | WO_GT | WO_GE)) == 0) return;
	if ((eOp & (WO_EQ | WO_LT | WO_LE)) != eOp
		&& (eOp & (WO_EQ | WO_GT | WO_GE)) != eOp) return;
	assert(pOne->pExpr->pLeft != 0 && pOne->pExpr->pRight != 0);
	assert(pTwo->pExpr->pLeft != 0 && pTwo->pExpr->pRight != 0);
	if (sqlite3ExprCompare(pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1)) return;
	if (sqlite3ExprCompare(pOne->pExpr->pRight, pTwo->pExpr->pRight, -1))return;
	
	if ((eOp & (eOp - 1)) != 0) {
		if (eOp & (WO_LT | WO_LE)) {
			eOp = WO_LE;
		}
		else {
			assert(eOp & (WO_GT | WO_GE));
			eOp = WO_GE;
		}
	}
	db = pWC->pWInfo->pParse->db;
	pNew = sqlite3ExprDup(db, pOne->pExpr, 0);
	if (pNew == 0) return;
	for (op = TK_EQ; eOp != (WO_EQ << (op - TK_EQ)); op++) { assert(op<TK_GE); }
	pNew->op = op;
	idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL | TERM_DYNAMIC);
	exprAnalyze(pSrc, pWC, idxNew);
}

#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)

static void exprAnalyzeOrTerm(
	SrcList *pSrc,            
	WhereClause *pWC,         
	int idxTerm               
) {
	WhereInfo *pWInfo = pWC->pWInfo;        
	Parse *pParse = pWInfo->pParse;         
	sqlite3 *db = pParse->db;               
	WhereTerm *pTerm = &pWC->a[idxTerm];    
	Expr *pExpr = pTerm->pExpr;             
	int i;                                  
	WhereClause *pOrWc;       
	WhereTerm *pOrTerm;       
	WhereOrInfo *pOrInfo;     
	Bitmask chngToIN;         
	Bitmask indexable;        

							  
	assert((pTerm->wtFlags & (TERM_DYNAMIC | TERM_ORINFO | TERM_ANDINFO)) == 0);
	assert(pExpr->op == TK_OR);
	pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));
	if (pOrInfo == 0) return;
	pTerm->wtFlags |= TERM_ORINFO;
	pOrWc = &pOrInfo->wc;
	memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
	sqlite3WhereClauseInit(pOrWc, pWInfo);
	sqlite3WhereSplit(pOrWc, pExpr, TK_OR);
	sqlite3WhereExprAnalyze(pSrc, pOrWc);
	if (db->mallocFailed) return;
	assert(pOrWc->nTerm >= 2);

	
	indexable = ~(Bitmask)0;
	chngToIN = ~(Bitmask)0;
	for (i = pOrWc->nTerm - 1, pOrTerm = pOrWc->a; i >= 0 && indexable; i--, pOrTerm++) {
		if ((pOrTerm->eOperator & WO_SINGLE) == 0) {
			WhereAndInfo *pAndInfo;
			assert((pOrTerm->wtFlags & (TERM_ANDINFO | TERM_ORINFO)) == 0);
			chngToIN = 0;
			pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));
			if (pAndInfo) {
				WhereClause *pAndWC;
				WhereTerm *pAndTerm;
				int j;
				Bitmask b = 0;
				pOrTerm->u.pAndInfo = pAndInfo;
				pOrTerm->wtFlags |= TERM_ANDINFO;
				pOrTerm->eOperator = WO_AND;
				pAndWC = &pAndInfo->wc;
				memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
				sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);
				sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, TK_AND);
				sqlite3WhereExprAnalyze(pSrc, pAndWC);
				pAndWC->pOuter = pWC;
				if (!db->mallocFailed) {
					for (j = 0, pAndTerm = pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++) {
						assert(pAndTerm->pExpr);
						if (allowedOp(pAndTerm->pExpr->op)
							|| pAndTerm->eOperator == WO_MATCH
							) {
							b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);
						}
					}
				}
				indexable &= b;
			}
		}
		else if (pOrTerm->wtFlags & TERM_COPIED) {
			
		}
		else {
			Bitmask b;
			b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);
			if (pOrTerm->wtFlags & TERM_VIRTUAL) {
				WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];
				b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);
			}
			indexable &= b;
			if ((pOrTerm->eOperator & WO_EQ) == 0) {
				chngToIN = 0;
			}
			else {
				chngToIN &= b;
			}
		}
	}

	
	pOrInfo->indexable = indexable;
	pTerm->eOperator = indexable == 0 ? 0 : WO_OR;

	
	if (indexable && pOrWc->nTerm == 2) {
		int iOne = 0;
		WhereTerm *pOne;
		while ((pOne = whereNthSubterm(&pOrWc->a[0], iOne++)) != 0) {
			int iTwo = 0;
			WhereTerm *pTwo;
			while ((pTwo = whereNthSubterm(&pOrWc->a[1], iTwo++)) != 0) {
				whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
			}
		}
	}

	
	if (chngToIN) {
		int okToChngToIN = 0;     
		int iColumn = -1;         
		int iCursor = -1;         
		int j = 0;                

								  
		for (j = 0; j<2 && !okToChngToIN; j++) {
			pOrTerm = pOrWc->a;
			for (i = pOrWc->nTerm - 1; i >= 0; i--, pOrTerm++) {
				assert(pOrTerm->eOperator & WO_EQ);
				pOrTerm->wtFlags &= ~TERM_OR_OK;
				if (pOrTerm->leftCursor == iCursor) {
					
					assert(j == 1);
					continue;
				}
				if ((chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,
					pOrTerm->leftCursor)) == 0) {
					
					testcase(pOrTerm->wtFlags & TERM_COPIED);
					testcase(pOrTerm->wtFlags & TERM_VIRTUAL);
					assert(pOrTerm->wtFlags & (TERM_COPIED | TERM_VIRTUAL));
					continue;
				}
				iColumn = pOrTerm->u.leftColumn;
				iCursor = pOrTerm->leftCursor;
				break;
			}
			if (i<0) {
				
				assert(j == 1);
				assert(IsPowerOfTwo(chngToIN));
				assert(chngToIN == sqlite3WhereGetMask(&pWInfo->sMaskSet, iCursor));
				break;
			}
			testcase(j == 1);

			
			okToChngToIN = 1;
			for (; i >= 0 && okToChngToIN; i--, pOrTerm++) {
				assert(pOrTerm->eOperator & WO_EQ);
				if (pOrTerm->leftCursor != iCursor) {
					pOrTerm->wtFlags &= ~TERM_OR_OK;
				}
				else if (pOrTerm->u.leftColumn != iColumn) {
					okToChngToIN = 0;
				}
				else {
					int affLeft, affRight;
					
					affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);
					affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);
					if (affRight != 0 && affRight != affLeft) {
						okToChngToIN = 0;
					}
					else {
						pOrTerm->wtFlags |= TERM_OR_OK;
					}
				}
			}
		}

		
		if (okToChngToIN) {
			Expr *pDup;            
			ExprList *pList = 0;   
			Expr *pLeft = 0;       
			Expr *pNew;            

			for (i = pOrWc->nTerm - 1, pOrTerm = pOrWc->a; i >= 0; i--, pOrTerm++) {
				if ((pOrTerm->wtFlags & TERM_OR_OK) == 0) continue;
				assert(pOrTerm->eOperator & WO_EQ);
				assert(pOrTerm->leftCursor == iCursor);
				assert(pOrTerm->u.leftColumn == iColumn);
				pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);
				pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);
				pLeft = pOrTerm->pExpr->pLeft;
			}
			assert(pLeft != 0);
			pDup = sqlite3ExprDup(db, pLeft, 0);
			pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0, 0);
			if (pNew) {
				int idxNew;
				transferJoinMarkings(pNew, pExpr);
				assert(!ExprHasProperty(pNew, EP_xIsSelect));
				pNew->x.pList = pList;
				idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL | TERM_DYNAMIC);
				testcase(idxNew == 0);
				exprAnalyze(pSrc, pWC, idxNew);
				pTerm = &pWC->a[idxTerm];
				markTermAsChild(pWC, idxNew, idxTerm);
			}
			else {
				sqlite3ExprListDelete(db, pList);
			}
			pTerm->eOperator = WO_NOOP;  
		}
	}
}
#endif 


static int termIsEquivalence(Parse *pParse, Expr *pExpr) {
	char aff1, aff2;
	CollSeq *pColl;
	const char *zColl1, *zColl2;
	if (!OptimizationEnabled(pParse->db, SQLITE_Transitive)) return 0;
	if (pExpr->op != TK_EQ && pExpr->op != TK_IS) return 0;
	if (ExprHasProperty(pExpr, EP_FromJoin)) return 0;
	aff1 = sqlite3ExprAffinity(pExpr->pLeft);
	aff2 = sqlite3ExprAffinity(pExpr->pRight);
	if (aff1 != aff2
		&& (!sqlite3IsNumericAffinity(aff1) || !sqlite3IsNumericAffinity(aff2))
		) {
		return 0;
	}
	pColl = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight);
	if (pColl == 0 || sqlite3StrICmp(pColl->zName, "BINARY") == 0) return 1;
	pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
	zColl1 = pColl ? pColl->zName : 0;
	pColl = sqlite3ExprCollSeq(pParse, pExpr->pRight);
	zColl2 = pColl ? pColl->zName : 0;
	return sqlite3_stricmp(zColl1, zColl2) == 0;
}


static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS) {
	Bitmask mask = 0;
	while (pS) {
		SrcList *pSrc = pS->pSrc;
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);
		mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);
		mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);
		if (ALWAYS(pSrc != 0)) {
			int i;
			for (i = 0; i<pSrc->nSrc; i++) {
				mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);
				mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);
			}
		}
		pS = pS->pPrior;
	}
	return mask;
}


static int exprMightBeIndexed(
	SrcList *pFrom,        
	int op,                
	Bitmask mPrereq,       
	Expr *pExpr,           
	int *piCur,            
	int *piColumn          
) {
	Index *pIdx;
	int i;
	int iCur;

	
	assert(TK_GT + 1 == TK_LE && TK_GT + 2 == TK_LT && TK_GT + 3 == TK_GE);
	assert(TK_IS<TK_GE && TK_ISNULL<TK_GE && TK_IN<TK_GE);
	assert(op <= TK_GE);
	if (pExpr->op == TK_VECTOR && (op >= TK_GT && ALWAYS(op <= TK_GE))) {
		pExpr = pExpr->x.pList->a[0].pExpr;
	}

	if (pExpr->op == TK_COLUMN) {
		*piCur = pExpr->iTable;
		*piColumn = pExpr->iColumn;
		return 1;
	}
	if (mPrereq == 0) return 0;                 
	if ((mPrereq&(mPrereq - 1)) != 0) return 0;   
	for (i = 0; mPrereq>1; i++, mPrereq >>= 1) {}
	iCur = pFrom->a[i].iCursor;
	for (pIdx = pFrom->a[i].pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
		if (pIdx->aColExpr == 0) continue;
		for (i = 0; i<pIdx->nKeyCol; i++) {
			if (pIdx->aiColumn[i] != XN_EXPR) continue;
			if (sqlite3ExprCompare(pExpr, pIdx->aColExpr->a[i].pExpr, iCur) == 0) {
				*piCur = iCur;
				*piColumn = XN_EXPR;
				return 1;
			}
		}
	}
	return 0;
}


static void exprAnalyze(
	SrcList *pSrc,            
	WhereClause *pWC,         
	int idxTerm               
) {
	WhereInfo *pWInfo = pWC->pWInfo; 
	WhereTerm *pTerm;                
	WhereMaskSet *pMaskSet;          
	Expr *pExpr;                     
	Bitmask prereqLeft;              
	Bitmask prereqAll;               
	Bitmask extraRight = 0;          
	Expr *pStr1 = 0;                 
	int isComplete = 0;              
	int noCase = 0;                  
	int op;                          
	Parse *pParse = pWInfo->pParse;  
	sqlite3 *db = pParse->db;        
	unsigned char eOp2;              

	if (db->mallocFailed) {
		return;
	}
	pTerm = &pWC->a[idxTerm];
	pMaskSet = &pWInfo->sMaskSet;
	pExpr = pTerm->pExpr;
	assert(pExpr->op != TK_AS && pExpr->op != TK_COLLATE);
	prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
	op = pExpr->op;
	if (op == TK_IN) {
		assert(pExpr->pRight == 0);
		if (sqlite3ExprCheckIN(pParse, pExpr)) return;
		if (ExprHasProperty(pExpr, EP_xIsSelect)) {
			pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);
		}
		else {
			pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);
		}
	}
	else if (op == TK_ISNULL) {
		pTerm->prereqRight = 0;
	}
	else {
		pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
	}
	prereqAll = sqlite3WhereExprUsage(pMaskSet, pExpr);
	if (ExprHasProperty(pExpr, EP_FromJoin)) {
		Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->iRightJoinTable);
		prereqAll |= x;
		extraRight = x - 1;  
	}
	pTerm->prereqAll = prereqAll;
	pTerm->leftCursor = -1;
	pTerm->iParent = -1;
	pTerm->eOperator = 0;
	if (allowedOp(op)) {
		int iCur, iColumn;
		Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
		Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
		u16 opMask = (pTerm->prereqRight & prereqLeft) == 0 ? WO_ALL : WO_EQUIV;

		if (pTerm->iField>0) {
			assert(op == TK_IN);
			assert(pLeft->op == TK_VECTOR);
			pLeft = pLeft->x.pList->a[pTerm->iField - 1].pExpr;
		}

		if (exprMightBeIndexed(pSrc, op, prereqLeft, pLeft, &iCur, &iColumn)) {
			pTerm->leftCursor = iCur;
			pTerm->u.leftColumn = iColumn;
			pTerm->eOperator = operatorMask(op) & opMask;
		}
		if (op == TK_IS) pTerm->wtFlags |= TERM_IS;
		if (pRight
			&& exprMightBeIndexed(pSrc, op, pTerm->prereqRight, pRight, &iCur, &iColumn)
			) {
			WhereTerm *pNew;
			Expr *pDup;
			u16 eExtraOp = 0;        
			assert(pTerm->iField == 0);
			if (pTerm->leftCursor >= 0) {
				int idxNew;
				pDup = sqlite3ExprDup(db, pExpr, 0);
				if (db->mallocFailed) {
					sqlite3ExprDelete(db, pDup);
					return;
				}
				idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL | TERM_DYNAMIC);
				if (idxNew == 0) return;
				pNew = &pWC->a[idxNew];
				markTermAsChild(pWC, idxNew, idxTerm);
				if (op == TK_IS) pNew->wtFlags |= TERM_IS;
				pTerm = &pWC->a[idxTerm];
				pTerm->wtFlags |= TERM_COPIED;

				if (termIsEquivalence(pParse, pDup)) {
					pTerm->eOperator |= WO_EQUIV;
					eExtraOp = WO_EQUIV;
				}
			}
			else {
				pDup = pExpr;
				pNew = pTerm;
			}
			exprCommute(pParse, pDup);
			pNew->leftCursor = iCur;
			pNew->u.leftColumn = iColumn;
			testcase((prereqLeft | extraRight) != prereqLeft);
			pNew->prereqRight = prereqLeft | extraRight;
			pNew->prereqAll = prereqAll;
			pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;
		}
	}

#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION
	
	else if (pExpr->op == TK_BETWEEN && pWC->op == TK_AND) {
		ExprList *pList = pExpr->x.pList;
		int i;
		static const u8 ops[] = { TK_GE, TK_LE };
		assert(pList != 0);
		assert(pList->nExpr == 2);
		for (i = 0; i<2; i++) {
			Expr *pNewExpr;
			int idxNew;
			pNewExpr = sqlite3PExpr(pParse, ops[i],
				sqlite3ExprDup(db, pExpr->pLeft, 0),
				sqlite3ExprDup(db, pList->a[i].pExpr, 0), 0);
			transferJoinMarkings(pNewExpr, pExpr);
			idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL | TERM_DYNAMIC);
			testcase(idxNew == 0);
			exprAnalyze(pSrc, pWC, idxNew);
			pTerm = &pWC->a[idxTerm];
			markTermAsChild(pWC, idxNew, idxTerm);
		}
	}
#endif 

#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)
	
	else if (pExpr->op == TK_OR) {
		assert(pWC->op == TK_AND);
		exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
		pTerm = &pWC->a[idxTerm];
	}
#endif 

#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION
	
	if (pWC->op == TK_AND
		&& isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
		) {
		Expr *pLeft;       
		Expr *pStr2;       
		Expr *pNewExpr1;
		Expr *pNewExpr2;
		int idxNew1;
		int idxNew2;
		const char *zCollSeqName;     
		const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;

		pLeft = pExpr->x.pList->a[1].pExpr;
		pStr2 = sqlite3ExprDup(db, pStr1, 0);

		
		if (noCase && !pParse->db->mallocFailed) {
			int i;
			char c;
			pTerm->wtFlags |= TERM_LIKE;
			for (i = 0; (c = pStr1->u.zToken[i]) != 0; i++) {
				pStr1->u.zToken[i] = sqlite3Toupper(c);
				pStr2->u.zToken[i] = sqlite3Tolower(c);
			}
		}

		if (!db->mallocFailed) {
			u8 c, *pC;       
			pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken) - 1];
			c = *pC;
			if (noCase) {
				
				if (c == 'A' - 1) isComplete = 0;
				c = sqlite3UpperToLower[c];
			}
			*pC = c + 1;
		}
		zCollSeqName = noCase ? "NOCASE" : "BINARY";
		pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);
		pNewExpr1 = sqlite3PExpr(pParse, TK_GE,
			sqlite3ExprAddCollateString(pParse, pNewExpr1, zCollSeqName),
			pStr1, 0);
		transferJoinMarkings(pNewExpr1, pExpr);
		idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);
		testcase(idxNew1 == 0);
		exprAnalyze(pSrc, pWC, idxNew1);
		pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);
		pNewExpr2 = sqlite3PExpr(pParse, TK_LT,
			sqlite3ExprAddCollateString(pParse, pNewExpr2, zCollSeqName),
			pStr2, 0);
		transferJoinMarkings(pNewExpr2, pExpr);
		idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);
		testcase(idxNew2 == 0);
		exprAnalyze(pSrc, pWC, idxNew2);
		pTerm = &pWC->a[idxTerm];
		if (isComplete) {
			markTermAsChild(pWC, idxNew1, idxTerm);
			markTermAsChild(pWC, idxNew2, idxTerm);
		}
	}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE
	
	if (pWC->op == TK_AND && isMatchOfColumn(pExpr, &eOp2)) {
		int idxNew;
		Expr *pRight, *pLeft;
		WhereTerm *pNewTerm;
		Bitmask prereqColumn, prereqExpr;

		pRight = pExpr->x.pList->a[0].pExpr;
		pLeft = pExpr->x.pList->a[1].pExpr;
		prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);
		prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);
		if ((prereqExpr & prereqColumn) == 0) {
			Expr *pNewExpr;
			pNewExpr = sqlite3PExpr(pParse, TK_MATCH,
				0, sqlite3ExprDup(db, pRight, 0), 0);
			idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL | TERM_DYNAMIC);
			testcase(idxNew == 0);
			pNewTerm = &pWC->a[idxNew];
			pNewTerm->prereqRight = prereqExpr;
			pNewTerm->leftCursor = pLeft->iTable;
			pNewTerm->u.leftColumn = pLeft->iColumn;
			pNewTerm->eOperator = WO_MATCH;
			pNewTerm->eMatchOp = eOp2;
			markTermAsChild(pWC, idxNew, idxTerm);
			pTerm = &pWC->a[idxTerm];
			pTerm->wtFlags |= TERM_COPIED;
			pNewTerm->prereqAll = pTerm->prereqAll;
		}
	}
#endif 

	
	if (pWC->op == TK_AND
		&& (pExpr->op == TK_EQ || pExpr->op == TK_IS)
		&& sqlite3ExprIsVector(pExpr->pLeft)
		&& ((pExpr->pLeft->flags & EP_xIsSelect) == 0
			|| (pExpr->pRight->flags & EP_xIsSelect) == 0
			)) {
		int nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
		int i;
		assert(nLeft == sqlite3ExprVectorSize(pExpr->pRight));
		for (i = 0; i<nLeft; i++) {
			int idxNew;
			Expr *pNew;
			Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i);
			Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i);

			pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight, 0);
			transferJoinMarkings(pNew, pExpr);
			idxNew = whereClauseInsert(pWC, pNew, TERM_DYNAMIC);
			exprAnalyze(pSrc, pWC, idxNew);
		}
		pTerm = &pWC->a[idxTerm];
		pTerm->wtFlags = TERM_CODED | TERM_VIRTUAL;  
		pTerm->eOperator = 0;
	}

	
	if (pWC->op == TK_AND && pExpr->op == TK_IN && pTerm->iField == 0
		&& pExpr->pLeft->op == TK_VECTOR
		&& pExpr->x.pSelect->pPrior == 0
		) {
		int i;
		for (i = 0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++) {
			int idxNew;
			idxNew = whereClauseInsert(pWC, pExpr, TERM_VIRTUAL);
			pWC->a[idxNew].iField = i + 1;
			exprAnalyze(pSrc, pWC, idxNew);
			markTermAsChild(pWC, idxNew, idxTerm);
		}
	}

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	
	if (pExpr->op == TK_NOTNULL
		&& pExpr->pLeft->op == TK_COLUMN
		&& pExpr->pLeft->iColumn >= 0
		&& OptimizationEnabled(db, SQLITE_Stat34)
		) {
		Expr *pNewExpr;
		Expr *pLeft = pExpr->pLeft;
		int idxNew;
		WhereTerm *pNewTerm;

		pNewExpr = sqlite3PExpr(pParse, TK_GT,
			sqlite3ExprDup(db, pLeft, 0),
			sqlite3ExprAlloc(db, TK_NULL, 0, 0), 0);

		idxNew = whereClauseInsert(pWC, pNewExpr,
			TERM_VIRTUAL | TERM_DYNAMIC | TERM_VNULL);
		if (idxNew) {
			pNewTerm = &pWC->a[idxNew];
			pNewTerm->prereqRight = 0;
			pNewTerm->leftCursor = pLeft->iTable;
			pNewTerm->u.leftColumn = pLeft->iColumn;
			pNewTerm->eOperator = WO_GT;
			markTermAsChild(pWC, idxNew, idxTerm);
			pTerm = &pWC->a[idxTerm];
			pTerm->wtFlags |= TERM_COPIED;
			pNewTerm->prereqAll = pTerm->prereqAll;
		}
	}
#endif 

	
	testcase(pTerm != &pWC->a[idxTerm]);
	pTerm = &pWC->a[idxTerm];
	pTerm->prereqRight |= extraRight;
}




SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op) {
	Expr *pE2 = sqlite3ExprSkipCollate(pExpr);
	pWC->op = op;
	if (pE2 == 0) return;
	if (pE2->op != op) {
		whereClauseInsert(pWC, pExpr, 0);
	}
	else {
		sqlite3WhereSplit(pWC, pE2->pLeft, op);
		sqlite3WhereSplit(pWC, pE2->pRight, op);
	}
}


SQLITE_PRIVATE void sqlite3WhereClauseInit(
	WhereClause *pWC,        
	WhereInfo *pWInfo        
) {
	pWC->pWInfo = pWInfo;
	pWC->pOuter = 0;
	pWC->nTerm = 0;
	pWC->nSlot = ArraySize(pWC->aStatic);
	pWC->a = pWC->aStatic;
}


SQLITE_PRIVATE void sqlite3WhereClauseClear(WhereClause *pWC) {
	int i;
	WhereTerm *a;
	sqlite3 *db = pWC->pWInfo->pParse->db;
	for (i = pWC->nTerm - 1, a = pWC->a; i >= 0; i--, a++) {
		if (a->wtFlags & TERM_DYNAMIC) {
			sqlite3ExprDelete(db, a->pExpr);
		}
		if (a->wtFlags & TERM_ORINFO) {
			whereOrInfoDelete(db, a->u.pOrInfo);
		}
		else if (a->wtFlags & TERM_ANDINFO) {
			whereAndInfoDelete(db, a->u.pAndInfo);
		}
	}
	if (pWC->a != pWC->aStatic) {
		sqlite3DbFree(db, pWC->a);
	}
}



SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p) {
	Bitmask mask;
	if (p == 0) return 0;
	if (p->op == TK_COLUMN) {
		mask = sqlite3WhereGetMask(pMaskSet, p->iTable);
		return mask;
	}
	assert(!ExprHasProperty(p, EP_TokenOnly));
	mask = p->pRight ? sqlite3WhereExprUsage(pMaskSet, p->pRight) : 0;
	if (p->pLeft) mask |= sqlite3WhereExprUsage(pMaskSet, p->pLeft);
	if (ExprHasProperty(p, EP_xIsSelect)) {
		mask |= exprSelectUsage(pMaskSet, p->x.pSelect);
	}
	else if (p->x.pList) {
		mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);
	}
	return mask;
}
SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList) {
	int i;
	Bitmask mask = 0;
	if (pList) {
		for (i = 0; i<pList->nExpr; i++) {
			mask |= sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);
		}
	}
	return mask;
}



SQLITE_PRIVATE void sqlite3WhereExprAnalyze(
	SrcList *pTabList,       
	WhereClause *pWC         
) {
	int i;
	for (i = pWC->nTerm - 1; i >= 0; i--) {
		exprAnalyze(pTabList, pWC, i);
	}
}


SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(
	Parse *pParse,                    
	struct SrcList_item *pItem,       
	WhereClause *pWC                  
) {
	Table *pTab;
	int j, k;
	ExprList *pArgs;
	Expr *pColRef;
	Expr *pTerm;
	if (pItem->fg.isTabFunc == 0) return;
	pTab = pItem->pTab;
	assert(pTab != 0);
	pArgs = pItem->u1.pFuncArg;
	if (pArgs == 0) return;
	for (j = k = 0; j<pArgs->nExpr; j++) {
		while (k<pTab->nCol && (pTab->aCol[k].colFlags & COLFLAG_HIDDEN) == 0) { k++; }
		if (k >= pTab->nCol) {
			sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",
				pTab->zName, j);
			return;
		}
		pColRef = sqlite3ExprAlloc(pParse->db, TK_COLUMN, 0, 0);
		if (pColRef == 0) return;
		pColRef->iTable = pItem->iCursor;
		pColRef->iColumn = k++;
		pColRef->pTab = pTab;
		pTerm = sqlite3PExpr(pParse, TK_EQ, pColRef,
			sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);
		whereClauseInsert(pWC, pTerm, TERM_DYNAMIC);
	}
}








static int whereLoopResize(sqlite3*, WhereLoop*, int);


#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)
 int sqlite3WhereTrace = 0;
#endif



SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo) {
	return pWInfo->nRowOut;
}


SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo *pWInfo) {
	return pWInfo->eDistinct;
}


SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo *pWInfo) {
	return pWInfo->nOBSat;
}


SQLITE_PRIVATE int sqlite3WhereOrderedInnerLoop(WhereInfo *pWInfo) {
	return pWInfo->bOrderedInnerLoop;
}


SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo *pWInfo) {
	assert(pWInfo->iContinue != 0);
	return pWInfo->iContinue;
}


SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo *pWInfo) {
	return pWInfo->iBreak;
}


SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur) {
	memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int) * 2);
#ifdef WHERETRACE_ENABLED
	if (sqlite3WhereTrace && pWInfo->eOnePass != ONEPASS_OFF) {
		sqlite3DebugPrintf("%s cursors: %d %d\n",
			pWInfo->eOnePass == ONEPASS_SINGLE ? "ONEPASS_SINGLE" : "ONEPASS_MULTI",
			aiCur[0], aiCur[1]);
	}
#endif
	return pWInfo->eOnePass;
}


static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc) {
	pDest->n = pSrc->n;
	memcpy(pDest->a, pSrc->a, pDest->n * sizeof(pDest->a[0]));
}


static int whereOrInsert(
	WhereOrSet *pSet,      
	Bitmask prereq,        
	LogEst rRun,           
	LogEst nOut            
) {
	u16 i;
	WhereOrCost *p;
	for (i = pSet->n, p = pSet->a; i>0; i--, p++) {
		if (rRun <= p->rRun && (prereq & p->prereq) == prereq) {
			goto whereOrInsert_done;
		}
		if (p->rRun <= rRun && (p->prereq & prereq) == p->prereq) {
			return 0;
		}
	}
	if (pSet->n<N_OR_COST) {
		p = &pSet->a[pSet->n++];
		p->nOut = nOut;
	}
	else {
		p = pSet->a;
		for (i = 1; i<pSet->n; i++) {
			if (p->rRun>pSet->a[i].rRun) p = pSet->a + i;
		}
		if (p->rRun <= rRun) return 0;
	}
whereOrInsert_done:
	p->prereq = prereq;
	p->rRun = rRun;
	if (p->nOut>nOut) p->nOut = nOut;
	return 1;
}


SQLITE_PRIVATE Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor) {
	int i;
	assert(pMaskSet->n <= (int)sizeof(Bitmask) * 8);
	for (i = 0; i<pMaskSet->n; i++) {
		if (pMaskSet->ix[i] == iCursor) {
			return MASKBIT(i);
		}
	}
	return 0;
}


static void createMask(WhereMaskSet *pMaskSet, int iCursor) {
	assert(pMaskSet->n < ArraySize(pMaskSet->ix));
	pMaskSet->ix[pMaskSet->n++] = iCursor;
}


static WhereTerm *whereScanNext(WhereScan *pScan) {
	int iCur;            
	i16 iColumn;         
	Expr *pX;            
	WhereClause *pWC;    
	WhereTerm *pTerm;    
	int k = pScan->k;    

	while (pScan->iEquiv <= pScan->nEquiv) {
		iCur = pScan->aiCur[pScan->iEquiv - 1];
		iColumn = pScan->aiColumn[pScan->iEquiv - 1];
		if (iColumn == XN_EXPR && pScan->pIdxExpr == 0) return 0;
		while ((pWC = pScan->pWC) != 0) {
			for (pTerm = pWC->a + k; k<pWC->nTerm; k++, pTerm++) {
				if (pTerm->leftCursor == iCur
					&& pTerm->u.leftColumn == iColumn
					&& (iColumn != XN_EXPR
						|| sqlite3ExprCompare(pTerm->pExpr->pLeft, pScan->pIdxExpr, iCur) == 0)
					&& (pScan->iEquiv <= 1 || !ExprHasProperty(pTerm->pExpr, EP_FromJoin))
					) {
					if ((pTerm->eOperator & WO_EQUIV) != 0
						&& pScan->nEquiv<ArraySize(pScan->aiCur)
						&& (pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight))->op == TK_COLUMN
						) {
						int j;
						for (j = 0; j<pScan->nEquiv; j++) {
							if (pScan->aiCur[j] == pX->iTable
								&& pScan->aiColumn[j] == pX->iColumn) {
								break;
							}
						}
						if (j == pScan->nEquiv) {
							pScan->aiCur[j] = pX->iTable;
							pScan->aiColumn[j] = pX->iColumn;
							pScan->nEquiv++;
						}
					}
					if ((pTerm->eOperator & pScan->opMask) != 0) {
						
						if (pScan->zCollName && (pTerm->eOperator & WO_ISNULL) == 0) {
							CollSeq *pColl;
							Parse *pParse = pWC->pWInfo->pParse;
							pX = pTerm->pExpr;
							if (!sqlite3IndexAffinityOk(pX, pScan->idxaff)) {
								continue;
							}
							assert(pX->pLeft);
							pColl = sqlite3BinaryCompareCollSeq(pParse,
								pX->pLeft, pX->pRight);
							if (pColl == 0) pColl = pParse->db->pDfltColl;
							if (sqlite3StrICmp(pColl->zName, pScan->zCollName)) {
								continue;
							}
						}
						if ((pTerm->eOperator & (WO_EQ | WO_IS)) != 0
							&& (pX = pTerm->pExpr->pRight)->op == TK_COLUMN
							&& pX->iTable == pScan->aiCur[0]
							&& pX->iColumn == pScan->aiColumn[0]
							) {
							testcase(pTerm->eOperator & WO_IS);
							continue;
						}
						pScan->k = k + 1;
						return pTerm;
					}
				}
			}
			pScan->pWC = pScan->pWC->pOuter;
			k = 0;
		}
		pScan->pWC = pScan->pOrigWC;
		k = 0;
		pScan->iEquiv++;
	}
	return 0;
}


static WhereTerm *whereScanInit(
	WhereScan *pScan,       
	WhereClause *pWC,       
	int iCur,               
	int iColumn,            
	u32 opMask,             
	Index *pIdx             
) {
	int j = 0;

	
	pScan->pOrigWC = pWC;
	pScan->pWC = pWC;
	pScan->pIdxExpr = 0;
	if (pIdx) {
		j = iColumn;
		iColumn = pIdx->aiColumn[j];
		if (iColumn == XN_EXPR) pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;
		if (iColumn == pIdx->pTable->iPKey) iColumn = XN_ROWID;
	}
	if (pIdx && iColumn >= 0) {
		pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;
		pScan->zCollName = pIdx->azColl[j];
	}
	else {
		pScan->idxaff = 0;
		pScan->zCollName = 0;
	}
	pScan->opMask = opMask;
	pScan->k = 0;
	pScan->aiCur[0] = iCur;
	pScan->aiColumn[0] = iColumn;
	pScan->nEquiv = 1;
	pScan->iEquiv = 1;
	return whereScanNext(pScan);
}


SQLITE_PRIVATE WhereTerm *sqlite3WhereFindTerm(
	WhereClause *pWC,     
	int iCur,             
	int iColumn,          
	Bitmask notReady,     
	u32 op,               
	Index *pIdx           
) {
	WhereTerm *pResult = 0;
	WhereTerm *p;
	WhereScan scan;

	p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx);
	op &= WO_EQ | WO_IS;
	while (p) {
		if ((p->prereqRight & notReady) == 0) {
			if (p->prereqRight == 0 && (p->eOperator&op) != 0) {
				testcase(p->eOperator & WO_IS);
				return p;
			}
			if (pResult == 0) pResult = p;
		}
		p = whereScanNext(&scan);
	}
	return pResult;
}


static int findIndexCol(
	Parse *pParse,                  
	ExprList *pList,                
	int iBase,                      
	Index *pIdx,                    
	int iCol                        
) {
	int i;
	const char *zColl = pIdx->azColl[iCol];

	for (i = 0; i<pList->nExpr; i++) {
		Expr *p = sqlite3ExprSkipCollate(pList->a[i].pExpr);
		if (p->op == TK_COLUMN
			&& p->iColumn == pIdx->aiColumn[iCol]
			&& p->iTable == iBase
			) {
			CollSeq *pColl = sqlite3ExprCollSeq(pParse, pList->a[i].pExpr);
			if (pColl && 0 == sqlite3StrICmp(pColl->zName, zColl)) {
				return i;
			}
		}
	}

	return -1;
}


static int indexColumnNotNull(Index *pIdx, int iCol) {
	int j;
	assert(pIdx != 0);
	assert(iCol >= 0 && iCol<pIdx->nColumn);
	j = pIdx->aiColumn[iCol];
	if (j >= 0) {
		return pIdx->pTable->aCol[j].notNull;
	}
	else if (j == (-1)) {
		return 1;
	}
	else {
		assert(j == (-2));
		return 0;  

	}
}


static int isDistinctRedundant(
	Parse *pParse,            
	SrcList *pTabList,        
	WhereClause *pWC,         
	ExprList *pDistinct       
) {
	Table *pTab;
	Index *pIdx;
	int i;
	int iBase;

	
	if (pTabList->nSrc != 1) return 0;
	iBase = pTabList->a[0].iCursor;
	pTab = pTabList->a[0].pTab;

	
	for (i = 0; i<pDistinct->nExpr; i++) {
		Expr *p = sqlite3ExprSkipCollate(pDistinct->a[i].pExpr);
		if (p->op == TK_COLUMN && p->iTable == iBase && p->iColumn<0) return 1;
	}

	
	for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
		if (!IsUniqueIndex(pIdx)) continue;
		for (i = 0; i<pIdx->nKeyCol; i++) {
			if (0 == sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, WO_EQ, pIdx)) {
				if (findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0) break;
				if (indexColumnNotNull(pIdx, i) == 0) break;
			}
		}
		if (i == pIdx->nKeyCol) {
			
			return 1;
		}
	}

	return 0;
}



static LogEst estLog(LogEst N) {
	return N <= 10 ? 0 : sqlite3LogEst(N) - 33;
}


static void translateColumnToCopy(
	Vdbe *v,            
	int iStart,         
	int iTabCur,        
	int iRegister,      
	int bIncrRowid      
) {
	VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);
	int iEnd = sqlite3VdbeCurrentAddr(v);
	for (; iStart<iEnd; iStart++, pOp++) {
		if (pOp->p1 != iTabCur) continue;
		if (pOp->opcode == OP_Column) {
			pOp->opcode = OP_Copy;
			pOp->p1 = pOp->p2 + iRegister;
			pOp->p2 = pOp->p3;
			pOp->p3 = 0;
		}
		else if (pOp->opcode == OP_Rowid) {
			if (bIncrRowid) {
				
				pOp->opcode = OP_AddImm;
				pOp->p1 = pOp->p2;
				pOp->p2 = 1;
			}
			else {
				pOp->opcode = OP_Null;
				pOp->p1 = 0;
				pOp->p3 = 0;
			}
		}
	}
}


#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(WHERETRACE_ENABLED)
static void TRACE_IDX_INPUTS(sqlite3_index_info *p) {
	int i;
	if (!sqlite3WhereTrace) return;
	for (i = 0; i<p->nConstraint; i++) {
		sqlite3DebugPrintf("  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n",
			i,
			p->aConstraint[i].iColumn,
			p->aConstraint[i].iTermOffset,
			p->aConstraint[i].op,
			p->aConstraint[i].usable);
	}
	for (i = 0; i<p->nOrderBy; i++) {
		sqlite3DebugPrintf("  orderby[%d]: col=%d desc=%d\n",
			i,
			p->aOrderBy[i].iColumn,
			p->aOrderBy[i].desc);
	}
}
static void TRACE_IDX_OUTPUTS(sqlite3_index_info *p) {
	int i;
	if (!sqlite3WhereTrace) return;
	for (i = 0; i<p->nConstraint; i++) {
		sqlite3DebugPrintf("  usage[%d]: argvIdx=%d omit=%d\n",
			i,
			p->aConstraintUsage[i].argvIndex,
			p->aConstraintUsage[i].omit);
	}
	sqlite3DebugPrintf("  idxNum=%d\n", p->idxNum);
	sqlite3DebugPrintf("  idxStr=%s\n", p->idxStr);
	sqlite3DebugPrintf("  orderByConsumed=%d\n", p->orderByConsumed);
	sqlite3DebugPrintf("  estimatedCost=%g\n", p->estimatedCost);
	sqlite3DebugPrintf("  estimatedRows=%lld\n", p->estimatedRows);
}
#else
#define TRACE_IDX_INPUTS(A)
#define TRACE_IDX_OUTPUTS(A)
#endif

#ifndef SQLITE_OMIT_AUTOMATIC_INDEX

static int termCanDriveIndex(
	WhereTerm *pTerm,              
	struct SrcList_item *pSrc,     
	Bitmask notReady               
) {
	char aff;
	if (pTerm->leftCursor != pSrc->iCursor) return 0;
	if ((pTerm->eOperator & (WO_EQ | WO_IS)) == 0) return 0;
	if ((pTerm->prereqRight & notReady) != 0) return 0;
	if (pTerm->u.leftColumn<0) return 0;
	aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;
	if (!sqlite3IndexAffinityOk(pTerm->pExpr, aff)) return 0;
	testcase(pTerm->pExpr->op == TK_IS);
	return 1;
}
#endif


#ifndef SQLITE_OMIT_AUTOMATIC_INDEX

static void constructAutomaticIndex(
	Parse *pParse,              
	WhereClause *pWC,           
	struct SrcList_item *pSrc,  
	Bitmask notReady,           
	WhereLevel *pLevel          
) {
	int nKeyCol;                
	WhereTerm *pTerm;           
	WhereTerm *pWCEnd;          
	Index *pIdx;                
	Vdbe *v;                    
	int addrInit;               
	Table *pTable;              
	int addrTop;                
	int regRecord;              
	int n;                      
	int i;                      
	int mxBitCol;               
	CollSeq *pColl;             
	WhereLoop *pLoop;           
	char *zNotUsed;             
	Bitmask idxCols;            
	Bitmask extraCols;          
	u8 sentWarning = 0;         
	Expr *pPartial = 0;         
	int iContinue = 0;          
	struct SrcList_item *pTabItem;  
	int addrCounter = 0;        
	int regBase;                

								
	v = pParse->pVdbe;
	assert(v != 0);
	addrInit = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);

	
	nKeyCol = 0;
	pTable = pSrc->pTab;
	pWCEnd = &pWC->a[pWC->nTerm];
	pLoop = pLevel->pWLoop;
	idxCols = 0;
	for (pTerm = pWC->a; pTerm<pWCEnd; pTerm++) {
		Expr *pExpr = pTerm->pExpr;
		assert(!ExprHasProperty(pExpr, EP_FromJoin)    
			|| pExpr->iRightJoinTable != pSrc->iCursor   
			|| pLoop->prereq != 0);                     
		if (pLoop->prereq == 0
			&& (pTerm->wtFlags & TERM_VIRTUAL) == 0
			&& !ExprHasProperty(pExpr, EP_FromJoin)
			&& sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor)) {
			pPartial = sqlite3ExprAnd(pParse->db, pPartial,
				sqlite3ExprDup(pParse->db, pExpr, 0));
		}
		if (termCanDriveIndex(pTerm, pSrc, notReady)) {
			int iCol = pTerm->u.leftColumn;
			Bitmask cMask = iCol >= BMS ? MASKBIT(BMS - 1) : MASKBIT(iCol);
			testcase(iCol == BMS);
			testcase(iCol == BMS - 1);
			if (!sentWarning) {
				sqlite3_log(SQLITE_WARNING_AUTOINDEX,
					"automatic index on %s(%s)", pTable->zName,
					pTable->aCol[iCol].zName);
				sentWarning = 1;
			}
			if ((idxCols & cMask) == 0) {
				if (whereLoopResize(pParse->db, pLoop, nKeyCol + 1)) {
					goto end_auto_index_create;
				}
				pLoop->aLTerm[nKeyCol++] = pTerm;
				idxCols |= cMask;
			}
		}
	}
	assert(nKeyCol>0);
	pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;
	pLoop->wsFlags = WHERE_COLUMN_EQ | WHERE_IDX_ONLY | WHERE_INDEXED
		| WHERE_AUTO_INDEX;

	
	extraCols = pSrc->colUsed & (~idxCols | MASKBIT(BMS - 1));
	mxBitCol = MIN(BMS - 1, pTable->nCol);
	testcase(pTable->nCol == BMS - 1);
	testcase(pTable->nCol == BMS - 2);
	for (i = 0; i<mxBitCol; i++) {
		if (extraCols & MASKBIT(i)) nKeyCol++;
	}
	if (pSrc->colUsed & MASKBIT(BMS - 1)) {
		nKeyCol += pTable->nCol - BMS + 1;
	}

	
	pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol + 1, 0, &zNotUsed);
	if (pIdx == 0) goto end_auto_index_create;
	pLoop->u.btree.pIndex = pIdx;
	pIdx->zName = "auto-index";
	pIdx->pTable = pTable;
	n = 0;
	idxCols = 0;
	for (pTerm = pWC->a; pTerm<pWCEnd; pTerm++) {
		if (termCanDriveIndex(pTerm, pSrc, notReady)) {
			int iCol = pTerm->u.leftColumn;
			Bitmask cMask = iCol >= BMS ? MASKBIT(BMS - 1) : MASKBIT(iCol);
			testcase(iCol == BMS - 1);
			testcase(iCol == BMS);
			if ((idxCols & cMask) == 0) {
				Expr *pX = pTerm->pExpr;
				idxCols |= cMask;
				pIdx->aiColumn[n] = pTerm->u.leftColumn;
				pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
				pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;
				n++;
			}
		}
	}
	assert((u32)n == pLoop->u.btree.nEq);

	
	for (i = 0; i<mxBitCol; i++) {
		if (extraCols & MASKBIT(i)) {
			pIdx->aiColumn[n] = i;
			pIdx->azColl[n] = sqlite3StrBINARY;
			n++;
		}
	}
	if (pSrc->colUsed & MASKBIT(BMS - 1)) {
		for (i = BMS - 1; i<pTable->nCol; i++) {
			pIdx->aiColumn[n] = i;
			pIdx->azColl[n] = sqlite3StrBINARY;
			n++;
		}
	}
	assert(n == nKeyCol);
	pIdx->aiColumn[n] = XN_ROWID;
	pIdx->azColl[n] = sqlite3StrBINARY;

	
	assert(pLevel->iIdxCur >= 0);
	pLevel->iIdxCur = pParse->nTab++;
	sqlite3VdbeAddOp2(v, OP_OpenAutoindex, pLevel->iIdxCur, nKeyCol + 1);
	sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
	VdbeComment((v, "for %s", pTable->zName));

	
	sqlite3ExprCachePush(pParse);
	pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];
	if (pTabItem->fg.viaCoroutine) {
		int regYield = pTabItem->regReturn;
		addrCounter = sqlite3VdbeAddOp2(v, OP_Integer, 0, 0);
		sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);
		addrTop = sqlite3VdbeAddOp1(v, OP_Yield, regYield);
		VdbeCoverage(v);
		VdbeComment((v, "next row of \"%s\"", pTabItem->pTab->zName));
	}
	else {
		addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, pLevel->iTabCur); VdbeCoverage(v);
	}
	if (pPartial) {
		iContinue = sqlite3VdbeMakeLabel(v);
		sqlite3ExprIfFalse(pParse, pPartial, iContinue, SQLITE_JUMPIFNULL);
		pLoop->wsFlags |= WHERE_PARTIALIDX;
	}
	regRecord = sqlite3GetTempReg(pParse);
	regBase = sqlite3GenerateIndexKey(
		pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0
	);
	sqlite3VdbeAddOp2(v, OP_IdxInsert, pLevel->iIdxCur, regRecord);
	sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
	if (pPartial) sqlite3VdbeResolveLabel(v, iContinue);
	if (pTabItem->fg.viaCoroutine) {
		sqlite3VdbeChangeP2(v, addrCounter, regBase + n);
		translateColumnToCopy(v, addrTop, pLevel->iTabCur, pTabItem->regResult, 1);
		sqlite3VdbeGoto(v, addrTop);
		pTabItem->fg.viaCoroutine = 0;
	}
	else {
		sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop + 1); VdbeCoverage(v);
	}
	sqlite3VdbeChangeP5(v, SQLITE_STMTSTATUS_AUTOINDEX);
	sqlite3VdbeJumpHere(v, addrTop);
	sqlite3ReleaseTempReg(pParse, regRecord);
	sqlite3ExprCachePop(pParse);

	
	sqlite3VdbeJumpHere(v, addrInit);

end_auto_index_create:
	sqlite3ExprDelete(pParse->db, pPartial);
}
#endif 

#ifndef SQLITE_OMIT_VIRTUALTABLE

static sqlite3_index_info *allocateIndexInfo(
	Parse *pParse,
	WhereClause *pWC,
	Bitmask mUnusable,              
	struct SrcList_item *pSrc,
	ExprList *pOrderBy,
	u16 *pmNoOmit                   
) {
	int i, j;
	int nTerm;
	struct sqlite3_index_constraint *pIdxCons;
	struct sqlite3_index_orderby *pIdxOrderBy;
	struct sqlite3_index_constraint_usage *pUsage;
	WhereTerm *pTerm;
	int nOrderBy;
	sqlite3_index_info *pIdxInfo;
	u16 mNoOmit = 0;

	
	for (i = nTerm = 0, pTerm = pWC->a; i<pWC->nTerm; i++, pTerm++) {
		if (pTerm->leftCursor != pSrc->iCursor) continue;
		if (pTerm->prereqRight & mUnusable) continue;
		assert(IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV));
		testcase(pTerm->eOperator & WO_IN);
		testcase(pTerm->eOperator & WO_ISNULL);
		testcase(pTerm->eOperator & WO_IS);
		testcase(pTerm->eOperator & WO_ALL);
		if ((pTerm->eOperator & ~(WO_ISNULL | WO_EQUIV | WO_IS)) == 0) continue;
		if (pTerm->wtFlags & TERM_VNULL) continue;
		assert(pTerm->u.leftColumn >= (-1));
		nTerm++;
	}

	
	nOrderBy = 0;
	if (pOrderBy) {
		int n = pOrderBy->nExpr;
		for (i = 0; i<n; i++) {
			Expr *pExpr = pOrderBy->a[i].pExpr;
			if (pExpr->op != TK_COLUMN || pExpr->iTable != pSrc->iCursor) break;
		}
		if (i == n) {
			nOrderBy = n;
		}
	}

	
	pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)
		+ (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm
		+ sizeof(*pIdxOrderBy)*nOrderBy);
	if (pIdxInfo == 0) {
		sqlite3ErrorMsg(pParse, "out of memory");
		return 0;
	}

	
	pIdxCons = (struct sqlite3_index_constraint*)&pIdxInfo[1];
	pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];
	pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];
	*(int*)&pIdxInfo->nConstraint = nTerm;
	*(int*)&pIdxInfo->nOrderBy = nOrderBy;
	*(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint = pIdxCons;
	*(struct sqlite3_index_orderby**)&pIdxInfo->aOrderBy = pIdxOrderBy;
	*(struct sqlite3_index_constraint_usage**)&pIdxInfo->aConstraintUsage =
		pUsage;

	for (i = j = 0, pTerm = pWC->a; i<pWC->nTerm; i++, pTerm++) {
		u8 op;
		if (pTerm->leftCursor != pSrc->iCursor) continue;
		if (pTerm->prereqRight & mUnusable) continue;
		assert(IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV));
		testcase(pTerm->eOperator & WO_IN);
		testcase(pTerm->eOperator & WO_IS);
		testcase(pTerm->eOperator & WO_ISNULL);
		testcase(pTerm->eOperator & WO_ALL);
		if ((pTerm->eOperator & ~(WO_ISNULL | WO_EQUIV | WO_IS)) == 0) continue;
		if (pTerm->wtFlags & TERM_VNULL) continue;
		assert(pTerm->u.leftColumn >= (-1));
		pIdxCons[j].iColumn = pTerm->u.leftColumn;
		pIdxCons[j].iTermOffset = i;
		op = (u8)pTerm->eOperator & WO_ALL;
		if (op == WO_IN) op = WO_EQ;
		if (op == WO_MATCH) {
			op = pTerm->eMatchOp;
		}
		pIdxCons[j].op = op;
		
		assert(WO_EQ == SQLITE_INDEX_CONSTRAINT_EQ);
		assert(WO_LT == SQLITE_INDEX_CONSTRAINT_LT);
		assert(WO_LE == SQLITE_INDEX_CONSTRAINT_LE);
		assert(WO_GT == SQLITE_INDEX_CONSTRAINT_GT);
		assert(WO_GE == SQLITE_INDEX_CONSTRAINT_GE);
		assert(WO_MATCH == SQLITE_INDEX_CONSTRAINT_MATCH);
		assert(pTerm->eOperator & (WO_IN | WO_EQ | WO_LT | WO_LE | WO_GT | WO_GE | WO_MATCH));

		if (op & (WO_LT | WO_LE | WO_GT | WO_GE)
			&& sqlite3ExprIsVector(pTerm->pExpr->pRight)
			) {
			if (i<16) mNoOmit |= (1 << i);
			if (op == WO_LT) pIdxCons[j].op = WO_LE;
			if (op == WO_GT) pIdxCons[j].op = WO_GE;
		}

		j++;
	}
	for (i = 0; i<nOrderBy; i++) {
		Expr *pExpr = pOrderBy->a[i].pExpr;
		pIdxOrderBy[i].iColumn = pExpr->iColumn;
		pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder;
	}

	*pmNoOmit = mNoOmit;
	return pIdxInfo;
}


static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p) {
	sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
	int rc;

	TRACE_IDX_INPUTS(p);
	rc = pVtab->pModule->xBestIndex(pVtab, p);
	TRACE_IDX_OUTPUTS(p);

	if (rc != SQLITE_OK) {
		if (rc == SQLITE_NOMEM) {
			sqlite3OomFault(pParse->db);
		}
		else if (!pVtab->zErrMsg) {
			sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
		}
		else {
			sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
		}
	}
	sqlite3_free(pVtab->zErrMsg);
	pVtab->zErrMsg = 0;

#if 0
	
	for (i = 0; i<p->nConstraint; i++) {
		if (!p->aConstraint[i].usable && p->aConstraintUsage[i].argvIndex>0) {
			sqlite3ErrorMsg(pParse,
				"table %s: xBestIndex returned an invalid plan", pTab->zName);
		}
	}
#endif

	return pParse->nErr;
}
#endif 

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static int whereKeyStats(
	Parse *pParse,              
	Index *pIdx,                
	UnpackedRecord *pRec,       
	int roundUp,                
	tRowcnt *aStat              
) {
	IndexSample *aSample = pIdx->aSample;
	int iCol;                   
	int i;                      
	int iSample;                
	int iMin = 0;               
	int iTest;                  
	int res;                    
	int nField;                 
	tRowcnt iLower = 0;         

#ifndef SQLITE_DEBUG
	UNUSED_PARAMETER(pParse);
#endif
	assert(pRec != 0);
	assert(pIdx->nSample>0);
	assert(pRec->nField>0 && pRec->nField <= pIdx->nSampleCol);

	
	nField = pRec->nField;
	iCol = 0;
	iSample = pIdx->nSample * nField;
	do {
		int iSamp;                    
		int n;                        

		iTest = (iMin + iSample) / 2;
		iSamp = iTest / nField;
		if (iSamp>0) {
			
			for (n = (iTest % nField) + 1; n<nField; n++) {
				if (aSample[iSamp - 1].anLt[n - 1] != aSample[iSamp].anLt[n - 1]) break;
			}
		}
		else {
			n = iTest + 1;
		}

		pRec->nField = n;
		res = sqlite3VdbeRecordCompare(aSample[iSamp].n, aSample[iSamp].p, pRec);
		if (res<0) {
			iLower = aSample[iSamp].anLt[n - 1] + aSample[iSamp].anEq[n - 1];
			iMin = iTest + 1;
		}
		else if (res == 0 && n<nField) {
			iLower = aSample[iSamp].anLt[n - 1];
			iMin = iTest + 1;
			res = -1;
		}
		else {
			iSample = iTest;
			iCol = n - 1;
		}
	} while (res && iMin<iSample);
	i = iSample / nField;

#ifdef SQLITE_DEBUG
	
	if (pParse->db->mallocFailed == 0) {
		if (res == 0) {
			
			assert(i<pIdx->nSample);
			assert(iCol == nField - 1);
			pRec->nField = nField;
			assert(0 == sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)
				|| pParse->db->mallocFailed
			);
		}
		else {
			
			assert(i <= pIdx->nSample && i >= 0);
			pRec->nField = iCol + 1;
			assert(i == pIdx->nSample
				|| sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)>0
				|| pParse->db->mallocFailed);

			
			if (iCol>0) {
				pRec->nField = iCol;
				assert(sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec) <= 0
					|| pParse->db->mallocFailed);
			}
			if (i>0) {
				pRec->nField = nField;
				assert(sqlite3VdbeRecordCompare(aSample[i - 1].n, aSample[i - 1].p, pRec)<0
					|| pParse->db->mallocFailed);
			}
		}
	}
#endif 

	if (res == 0) {
		
		assert(iCol == nField - 1);
		aStat[0] = aSample[i].anLt[iCol];
		aStat[1] = aSample[i].anEq[iCol];
	}
	else {
		
		tRowcnt iUpper, iGap;
		if (i >= pIdx->nSample) {
			iUpper = sqlite3LogEstToInt(pIdx->aiRowLogEst[0]);
		}
		else {
			iUpper = aSample[i].anLt[iCol];
		}

		if (iLower >= iUpper) {
			iGap = 0;
		}
		else {
			iGap = iUpper - iLower;
		}
		if (roundUp) {
			iGap = (iGap * 2) / 3;
		}
		else {
			iGap = iGap / 3;
		}
		aStat[0] = iLower + iGap;
		aStat[1] = pIdx->aAvgEq[iCol];
	}

	
	pRec->nField = nField;
	return i;
}
#endif 


static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew) {
	LogEst nRet = nNew;
	if (pTerm) {
		if (pTerm->truthProb <= 0) {
			nRet += pTerm->truthProb;
		}
		else if ((pTerm->wtFlags & TERM_VNULL) == 0) {
			nRet -= 20;        assert(20 == sqlite3LogEst(4));
		}
	}
	return nRet;
}


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

SQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3 *db, Index *pIdx, int iCol) {
	assert(iCol >= 0 && iCol<pIdx->nColumn);
	if (!pIdx->zColAff) {
		if (sqlite3IndexAffinityStr(db, pIdx) == 0) return SQLITE_AFF_BLOB;
	}
	return pIdx->zColAff[iCol];
}
#endif


#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static int whereRangeSkipScanEst(
	Parse *pParse,       
	WhereTerm *pLower,   
	WhereTerm *pUpper,   
	WhereLoop *pLoop,    
	int *pbDone          
) {
	Index *p = pLoop->u.btree.pIndex;
	int nEq = pLoop->u.btree.nEq;
	sqlite3 *db = pParse->db;
	int nLower = -1;
	int nUpper = p->nSample + 1;
	int rc = SQLITE_OK;
	u8 aff = sqlite3IndexColumnAffinity(db, p, nEq);
	CollSeq *pColl;

	sqlite3_value *p1 = 0;          
	sqlite3_value *p2 = 0;          
	sqlite3_value *pVal = 0;        

	pColl = sqlite3LocateCollSeq(pParse, p->azColl[nEq]);
	if (pLower) {
		rc = sqlite3Stat4ValueFromExpr(pParse, pLower->pExpr->pRight, aff, &p1);
		nLower = 0;
	}
	if (pUpper && rc == SQLITE_OK) {
		rc = sqlite3Stat4ValueFromExpr(pParse, pUpper->pExpr->pRight, aff, &p2);
		nUpper = p2 ? 0 : p->nSample;
	}

	if (p1 || p2) {
		int i;
		int nDiff;
		for (i = 0; rc == SQLITE_OK && i<p->nSample; i++) {
			rc = sqlite3Stat4Column(db, p->aSample[i].p, p->aSample[i].n, nEq, &pVal);
			if (rc == SQLITE_OK && p1) {
				int res = sqlite3MemCompare(p1, pVal, pColl);
				if (res >= 0) nLower++;
			}
			if (rc == SQLITE_OK && p2) {
				int res = sqlite3MemCompare(p2, pVal, pColl);
				if (res >= 0) nUpper++;
			}
		}
		nDiff = (nUpper - nLower);
		if (nDiff <= 0) nDiff = 1;

		
		if (nDiff != 1 || pUpper == 0 || pLower == 0) {
			int nAdjust = (sqlite3LogEst(p->nSample) - sqlite3LogEst(nDiff));
			pLoop->nOut -= nAdjust;
			*pbDone = 1;
			WHERETRACE(0x10, ("range skip-scan regions: %u..%u  adjust=%d est=%d\n",
				nLower, nUpper, nAdjust*-1, pLoop->nOut));
		}

	}
	else {
		assert(*pbDone == 0);
	}

	sqlite3ValueFree(p1);
	sqlite3ValueFree(p2);
	sqlite3ValueFree(pVal);

	return rc;
}
#endif 


static int whereRangeScanEst(
	Parse *pParse,       
	WhereLoopBuilder *pBuilder,
	WhereTerm *pLower,   
	WhereTerm *pUpper,   
	WhereLoop *pLoop     
) {
	int rc = SQLITE_OK;
	int nOut = pLoop->nOut;
	LogEst nNew;

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
	Index *p = pLoop->u.btree.pIndex;
	int nEq = pLoop->u.btree.nEq;

	if (p->nSample>0 && nEq<p->nSampleCol) {
		if (nEq == pBuilder->nRecValid) {
			UnpackedRecord *pRec = pBuilder->pRec;
			tRowcnt a[2];
			int nBtm = pLoop->u.btree.nBtm;
			int nTop = pLoop->u.btree.nTop;

			
			tRowcnt iLower;     
			tRowcnt iUpper;     
			int iLwrIdx = -2;   
			int iUprIdx = -1;   

			if (pRec) {
				testcase(pRec->nField != pBuilder->nRecValid);
				pRec->nField = pBuilder->nRecValid;
			}
			
			if (nEq == 0) {
				iLower = 0;
				iUpper = p->nRowEst0;
			}
			else {
				
				whereKeyStats(pParse, p, pRec, 0, a);
				iLower = a[0];
				iUpper = a[0] + a[1];
			}

			assert(pLower == 0 || (pLower->eOperator & (WO_GT | WO_GE)) != 0);
			assert(pUpper == 0 || (pUpper->eOperator & (WO_LT | WO_LE)) != 0);
			assert(p->aSortOrder != 0);
			if (p->aSortOrder[nEq]) {
				
				SWAP(WhereTerm*, pLower, pUpper);
				SWAP(int, nBtm, nTop);
			}

			
			if (pLower) {
				int n;                    
				Expr *pExpr = pLower->pExpr->pRight;
				rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nBtm, nEq, &n);
				if (rc == SQLITE_OK && n) {
					tRowcnt iNew;
					u16 mask = WO_GT | WO_LE;
					if (sqlite3ExprVectorSize(pExpr)>n) mask = (WO_LE | WO_LT);
					iLwrIdx = whereKeyStats(pParse, p, pRec, 0, a);
					iNew = a[0] + ((pLower->eOperator & mask) ? a[1] : 0);
					if (iNew>iLower) iLower = iNew;
					nOut--;
					pLower = 0;
				}
			}

			
			if (pUpper) {
				int n;                    
				Expr *pExpr = pUpper->pExpr->pRight;
				rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nTop, nEq, &n);
				if (rc == SQLITE_OK && n) {
					tRowcnt iNew;
					u16 mask = WO_GT | WO_LE;
					if (sqlite3ExprVectorSize(pExpr)>n) mask = (WO_LE | WO_LT);
					iUprIdx = whereKeyStats(pParse, p, pRec, 1, a);
					iNew = a[0] + ((pUpper->eOperator & mask) ? a[1] : 0);
					if (iNew<iUpper) iUpper = iNew;
					nOut--;
					pUpper = 0;
				}
			}

			pBuilder->pRec = pRec;
			if (rc == SQLITE_OK) {
				if (iUpper>iLower) {
					nNew = sqlite3LogEst(iUpper - iLower);
					
					if (iLwrIdx == iUprIdx) nNew -= 20;  assert(20 == sqlite3LogEst(4));
				}
				else {
					nNew = 10;        assert(10 == sqlite3LogEst(2));
				}
				if (nNew<nOut) {
					nOut = nNew;
				}
				WHERETRACE(0x10, ("STAT4 range scan: %u..%u  est=%d\n",
					(u32)iLower, (u32)iUpper, nOut));
			}
		}
		else {
			int bDone = 0;
			rc = whereRangeSkipScanEst(pParse, pLower, pUpper, pLoop, &bDone);
			if (bDone) return rc;
		}
	}
#else
	UNUSED_PARAMETER(pParse);
	UNUSED_PARAMETER(pBuilder);
	assert(pLower || pUpper);
#endif
	assert(pUpper == 0 || (pUpper->wtFlags & TERM_VNULL) == 0);
	nNew = whereRangeAdjust(pLower, nOut);
	nNew = whereRangeAdjust(pUpper, nNew);

	
	if (pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0) {
		nNew -= 20;
	}

	nOut -= (pLower != 0) + (pUpper != 0);
	if (nNew<10) nNew = 10;
	if (nNew<nOut) nOut = nNew;
#if defined(WHERETRACE_ENABLED)
	if (pLoop->nOut>nOut) {
		WHERETRACE(0x10, ("Range scan lowers nOut from %d to %d\n",
			pLoop->nOut, nOut));
	}
#endif
	pLoop->nOut = (LogEst)nOut;
	return rc;
}

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static int whereEqualScanEst(
	Parse *pParse,       
	WhereLoopBuilder *pBuilder,
	Expr *pExpr,         
	tRowcnt *pnRow       
) {
	Index *p = pBuilder->pNew->u.btree.pIndex;
	int nEq = pBuilder->pNew->u.btree.nEq;
	UnpackedRecord *pRec = pBuilder->pRec;
	int rc;                   
	tRowcnt a[2];             
	int bOk;

	assert(nEq >= 1);
	assert(nEq <= p->nColumn);
	assert(p->aSample != 0);
	assert(p->nSample>0);
	assert(pBuilder->nRecValid<nEq);

	
	if (pBuilder->nRecValid<(nEq - 1)) {
		return SQLITE_NOTFOUND;
	}

	
	if (nEq >= p->nColumn) {
		*pnRow = 1;
		return SQLITE_OK;
	}

	rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, 1, nEq - 1, &bOk);
	pBuilder->pRec = pRec;
	if (rc != SQLITE_OK) return rc;
	if (bOk == 0) return SQLITE_NOTFOUND;
	pBuilder->nRecValid = nEq;

	whereKeyStats(pParse, p, pRec, 0, a);
	WHERETRACE(0x10, ("equality scan regions %s(%d): %d\n",
		p->zName, nEq - 1, (int)a[1]));
	*pnRow = a[1];

	return rc;
}
#endif 

#ifdef SQLITE_ENABLE_STAT3_OR_STAT4

static int whereInScanEst(
	Parse *pParse,       
	WhereLoopBuilder *pBuilder,
	ExprList *pList,     
	tRowcnt *pnRow       
) {
	Index *p = pBuilder->pNew->u.btree.pIndex;
	i64 nRow0 = sqlite3LogEstToInt(p->aiRowLogEst[0]);
	int nRecValid = pBuilder->nRecValid;
	int rc = SQLITE_OK;     
	tRowcnt nEst;           
	tRowcnt nRowEst = 0;    
	int i;                  

	assert(p->aSample != 0);
	for (i = 0; rc == SQLITE_OK && i<pList->nExpr; i++) {
		nEst = nRow0;
		rc = whereEqualScanEst(pParse, pBuilder, pList->a[i].pExpr, &nEst);
		nRowEst += nEst;
		pBuilder->nRecValid = nRecValid;
	}

	if (rc == SQLITE_OK) {
		if (nRowEst > nRow0) nRowEst = nRow0;
		*pnRow = nRowEst;
		WHERETRACE(0x10, ("IN row estimate: est=%d\n", nRowEst));
	}
	assert(pBuilder->nRecValid == nRecValid);
	return rc;
}
#endif 


#ifdef WHERETRACE_ENABLED

static void whereTermPrint(WhereTerm *pTerm, int iTerm) {
	if (pTerm == 0) {
		sqlite3DebugPrintf("TERM-%-3d NULL\n", iTerm);
	}
	else {
		char zType[4];
		char zLeft[50];
		memcpy(zType, "...", 4);
		if (pTerm->wtFlags & TERM_VIRTUAL) zType[0] = 'V';
		if (pTerm->eOperator & WO_EQUIV) zType[1] = 'E';
		if (ExprHasProperty(pTerm->pExpr, EP_FromJoin)) zType[2] = 'L';
		if (pTerm->eOperator & WO_SINGLE) {
			sqlite3_snprintf(sizeof(zLeft), zLeft, "left={%d:%d}",
				pTerm->leftCursor, pTerm->u.leftColumn);
		}
		else if ((pTerm->eOperator & WO_OR) != 0 && pTerm->u.pOrInfo != 0) {
			sqlite3_snprintf(sizeof(zLeft), zLeft, "indexable=0x%lld",
				pTerm->u.pOrInfo->indexable);
		}
		else {
			sqlite3_snprintf(sizeof(zLeft), zLeft, "left=%d", pTerm->leftCursor);
		}
		sqlite3DebugPrintf(
			"TERM-%-3d %p %s %-12s prob=%-3d op=0x%03x wtFlags=0x%04x",
			iTerm, pTerm, zType, zLeft, pTerm->truthProb,
			pTerm->eOperator, pTerm->wtFlags);
		if (pTerm->iField) {
			sqlite3DebugPrintf(" iField=%d\n", pTerm->iField);
		}
		else {
			sqlite3DebugPrintf("\n");
		}
		sqlite3TreeViewExpr(0, pTerm->pExpr, 0);
	}
}
#endif

#ifdef WHERETRACE_ENABLED

SQLITE_PRIVATE void sqlite3WhereClausePrint(WhereClause *pWC) {
	int i;
	for (i = 0; i<pWC->nTerm; i++) {
		whereTermPrint(&pWC->a[i], i);
	}
}
#endif

#ifdef WHERETRACE_ENABLED

static void whereLoopPrint(WhereLoop *p, WhereClause *pWC) {
	WhereInfo *pWInfo = pWC->pWInfo;
	int nb = 1 + (pWInfo->pTabList->nSrc + 3) / 4;
	struct SrcList_item *pItem = pWInfo->pTabList->a + p->iTab;
	Table *pTab = pItem->pTab;
	Bitmask mAll = (((Bitmask)1) << (nb * 4)) - 1;
	sqlite3DebugPrintf("%c%2d.%0*llx.%0*llx", p->cId,
		p->iTab, nb, p->maskSelf, nb, p->prereq & mAll);
	sqlite3DebugPrintf(" %12s",
		pItem->zAlias ? pItem->zAlias : pTab->zName);
	if ((p->wsFlags & WHERE_VIRTUALTABLE) == 0) {
		const char *zName;
		if (p->u.btree.pIndex && (zName = p->u.btree.pIndex->zName) != 0) {
			if (strncmp(zName, "sqlite_autoindex_", 17) == 0) {
				int i = sqlite3Strlen30(zName) - 1;
				while (zName[i] != '_') i--;
				zName += i;
			}
			sqlite3DebugPrintf(".%-16s %2d", zName, p->u.btree.nEq);
		}
		else {
			sqlite3DebugPrintf("%20s", "");
		}
	}
	else {
		char *z;
		if (p->u.vtab.idxStr) {
			z = sqlite3_mprintf("(%d,\"%s\",%x)",
				p->u.vtab.idxNum, p->u.vtab.idxStr, p->u.vtab.omitMask);
		}
		else {
			z = sqlite3_mprintf("(%d,%x)", p->u.vtab.idxNum, p->u.vtab.omitMask);
		}
		sqlite3DebugPrintf(" %-19s", z);
		sqlite3_free(z);
	}
	if (p->wsFlags & WHERE_SKIPSCAN) {
		sqlite3DebugPrintf(" f %05x %d-%d", p->wsFlags, p->nLTerm, p->nSkip);
	}
	else {
		sqlite3DebugPrintf(" f %05x N %d", p->wsFlags, p->nLTerm);
	}
	sqlite3DebugPrintf(" cost %d,%d,%d\n", p->rSetup, p->rRun, p->nOut);
	if (p->nLTerm && (sqlite3WhereTrace & 0x100) != 0) {
		int i;
		for (i = 0; i<p->nLTerm; i++) {
			whereTermPrint(p->aLTerm[i], i);
		}
	}
}
#endif


static void whereLoopInit(WhereLoop *p) {
	p->aLTerm = p->aLTermSpace;
	p->nLTerm = 0;
	p->nLSlot = ArraySize(p->aLTermSpace);
	p->wsFlags = 0;
}


static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p) {
	if (p->wsFlags & (WHERE_VIRTUALTABLE | WHERE_AUTO_INDEX)) {
		if ((p->wsFlags & WHERE_VIRTUALTABLE) != 0 && p->u.vtab.needFree) {
			sqlite3_free(p->u.vtab.idxStr);
			p->u.vtab.needFree = 0;
			p->u.vtab.idxStr = 0;
		}
		else if ((p->wsFlags & WHERE_AUTO_INDEX) != 0 && p->u.btree.pIndex != 0) {
			sqlite3DbFree(db, p->u.btree.pIndex->zColAff);
			sqlite3DbFree(db, p->u.btree.pIndex);
			p->u.btree.pIndex = 0;
		}
	}
}


static void whereLoopClear(sqlite3 *db, WhereLoop *p) {
	if (p->aLTerm != p->aLTermSpace) sqlite3DbFree(db, p->aLTerm);
	whereLoopClearUnion(db, p);
	whereLoopInit(p);
}


static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n) {
	WhereTerm **paNew;
	if (p->nLSlot >= n) return SQLITE_OK;
	n = (n + 7)&~7;
	paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);
	if (paNew == 0) return SQLITE_NOMEM_BKPT;
	memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
	if (p->aLTerm != p->aLTermSpace) sqlite3DbFree(db, p->aLTerm);
	p->aLTerm = paNew;
	p->nLSlot = n;
	return SQLITE_OK;
}


static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom) {
	whereLoopClearUnion(db, pTo);
	if (whereLoopResize(db, pTo, pFrom->nLTerm)) {
		memset(&pTo->u, 0, sizeof(pTo->u));
		return SQLITE_NOMEM_BKPT;
	}
	memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);
	memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm * sizeof(pTo->aLTerm[0]));
	if (pFrom->wsFlags & WHERE_VIRTUALTABLE) {
		pFrom->u.vtab.needFree = 0;
	}
	else if ((pFrom->wsFlags & WHERE_AUTO_INDEX) != 0) {
		pFrom->u.btree.pIndex = 0;
	}
	return SQLITE_OK;
}


static void whereLoopDelete(sqlite3 *db, WhereLoop *p) {
	whereLoopClear(db, p);
	sqlite3DbFree(db, p);
}


static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo) {
	if (ALWAYS(pWInfo)) {
		int i;
		for (i = 0; i<pWInfo->nLevel; i++) {
			WhereLevel *pLevel = &pWInfo->a[i];
			if (pLevel->pWLoop && (pLevel->pWLoop->wsFlags & WHERE_IN_ABLE)) {
				sqlite3DbFree(db, pLevel->u.in.aInLoop);
			}
		}
		sqlite3WhereClauseClear(&pWInfo->sWC);
		while (pWInfo->pLoops) {
			WhereLoop *p = pWInfo->pLoops;
			pWInfo->pLoops = p->pNextLoop;
			whereLoopDelete(db, p);
		}
		sqlite3DbFree(db, pWInfo);
	}
}


static int whereLoopCheaperProperSubset(
	const WhereLoop *pX,       
	const WhereLoop *pY        
) {
	int i, j;
	if (pX->nLTerm - pX->nSkip >= pY->nLTerm - pY->nSkip) {
		return 0; 
	}
	if (pY->nSkip > pX->nSkip) return 0;
	if (pX->rRun >= pY->rRun) {
		if (pX->rRun > pY->rRun) return 0;    
		if (pX->nOut > pY->nOut) return 0;    
	}
	for (i = pX->nLTerm - 1; i >= 0; i--) {
		if (pX->aLTerm[i] == 0) continue;
		for (j = pY->nLTerm - 1; j >= 0; j--) {
			if (pY->aLTerm[j] == pX->aLTerm[i]) break;
		}
		if (j<0) return 0;  
	}
	return 1;  
}


static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate) {
	if ((pTemplate->wsFlags & WHERE_INDEXED) == 0) return;
	for (; p; p = p->pNextLoop) {
		if (p->iTab != pTemplate->iTab) continue;
		if ((p->wsFlags & WHERE_INDEXED) == 0) continue;
		if (whereLoopCheaperProperSubset(p, pTemplate)) {
			
			WHERETRACE(0x80, ("subset cost adjustment %d,%d to %d,%d\n",
				pTemplate->rRun, pTemplate->nOut, p->rRun, p->nOut - 1));
			pTemplate->rRun = p->rRun;
			pTemplate->nOut = p->nOut - 1;
		}
		else if (whereLoopCheaperProperSubset(pTemplate, p)) {
			
			WHERETRACE(0x80, ("subset cost adjustment %d,%d to %d,%d\n",
				pTemplate->rRun, pTemplate->nOut, p->rRun, p->nOut + 1));
			pTemplate->rRun = p->rRun;
			pTemplate->nOut = p->nOut + 1;
		}
	}
}


static WhereLoop **whereLoopFindLesser(
	WhereLoop **ppPrev,
	const WhereLoop *pTemplate
) {
	WhereLoop *p;
	for (p = (*ppPrev); p; ppPrev = &p->pNextLoop, p = *ppPrev) {
		if (p->iTab != pTemplate->iTab || p->iSortIdx != pTemplate->iSortIdx) {
			
			continue;
		}
		
		assert(p->rSetup == 0 || pTemplate->rSetup == 0
			|| p->rSetup == pTemplate->rSetup);

		
		assert(p->rSetup >= pTemplate->rSetup);

		
		if ((p->wsFlags & WHERE_AUTO_INDEX) != 0
			&& (pTemplate->nSkip) == 0
			&& (pTemplate->wsFlags & WHERE_INDEXED) != 0
			&& (pTemplate->wsFlags & WHERE_COLUMN_EQ) != 0
			&& (p->prereq & pTemplate->prereq) == pTemplate->prereq
			) {
			break;
		}

		
		if ((p->prereq & pTemplate->prereq) == p->prereq    
			&& p->rSetup <= pTemplate->rSetup                  
			&& p->rRun <= pTemplate->rRun                      
			&& p->nOut <= pTemplate->nOut                      
			) {
			return 0;  
		}

		
		if ((p->prereq & pTemplate->prereq) == pTemplate->prereq   
			&& p->rRun >= pTemplate->rRun                             
			&& p->nOut >= pTemplate->nOut                             
			) {
			assert(p->rSetup >= pTemplate->rSetup); 
			break;   
		}
	}
	return ppPrev;
}


static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate) {
	WhereLoop **ppPrev, *p;
	WhereInfo *pWInfo = pBuilder->pWInfo;
	sqlite3 *db = pWInfo->pParse->db;
	int rc;

	
	if (pBuilder->pOrSet != 0) {
		if (pTemplate->nLTerm) {
#if WHERETRACE_ENABLED
			u16 n = pBuilder->pOrSet->n;
			int x =
#endif
				whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
					pTemplate->nOut);
#if WHERETRACE_ENABLED 
			if (sqlite3WhereTrace & 0x8) {
				sqlite3DebugPrintf(x ? "   or-%d:  " : "   or-X:  ", n);
				whereLoopPrint(pTemplate, pBuilder->pWC);
			}
#endif
		}
		return SQLITE_OK;
	}

	
	whereLoopAdjustCost(pWInfo->pLoops, pTemplate);
	ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);

	if (ppPrev == 0) {
		
#if WHERETRACE_ENABLED 
		if (sqlite3WhereTrace & 0x8) {
			sqlite3DebugPrintf("   skip: ");
			whereLoopPrint(pTemplate, pBuilder->pWC);
		}
#endif
		return SQLITE_OK;
	}
	else {
		p = *ppPrev;
	}

	
#if WHERETRACE_ENABLED 
	if (sqlite3WhereTrace & 0x8) {
		if (p != 0) {
			sqlite3DebugPrintf("replace: ");
			whereLoopPrint(p, pBuilder->pWC);
		}
		sqlite3DebugPrintf("    add: ");
		whereLoopPrint(pTemplate, pBuilder->pWC);
	}
#endif
	if (p == 0) {
		
		*ppPrev = p = sqlite3DbMallocRawNN(db, sizeof(WhereLoop));
		if (p == 0) return SQLITE_NOMEM_BKPT;
		whereLoopInit(p);
		p->pNextLoop = 0;
	}
	else {
		
		WhereLoop **ppTail = &p->pNextLoop;
		WhereLoop *pToDel;
		while (*ppTail) {
			ppTail = whereLoopFindLesser(ppTail, pTemplate);
			if (ppTail == 0) break;
			pToDel = *ppTail;
			if (pToDel == 0) break;
			*ppTail = pToDel->pNextLoop;
#if WHERETRACE_ENABLED 
			if (sqlite3WhereTrace & 0x8) {
				sqlite3DebugPrintf(" delete: ");
				whereLoopPrint(pToDel, pBuilder->pWC);
			}
#endif
			whereLoopDelete(db, pToDel);
		}
	}
	rc = whereLoopXfer(db, p, pTemplate);
	if ((p->wsFlags & WHERE_VIRTUALTABLE) == 0) {
		Index *pIndex = p->u.btree.pIndex;
		if (pIndex && pIndex->tnum == 0) {
			p->u.btree.pIndex = 0;
		}
	}
	return rc;
}


static void whereLoopOutputAdjust(
	WhereClause *pWC,      
	WhereLoop *pLoop,      
	LogEst nRow            
) {
	WhereTerm *pTerm, *pX;
	Bitmask notAllowed = ~(pLoop->prereq | pLoop->maskSelf);
	int i, j, k;
	LogEst iReduce = 0;    

	assert((pLoop->wsFlags & WHERE_AUTO_INDEX) == 0);
	for (i = pWC->nTerm, pTerm = pWC->a; i>0; i--, pTerm++) {
		if ((pTerm->wtFlags & TERM_VIRTUAL) != 0) break;
		if ((pTerm->prereqAll & pLoop->maskSelf) == 0) continue;
		if ((pTerm->prereqAll & notAllowed) != 0) continue;
		for (j = pLoop->nLTerm - 1; j >= 0; j--) {
			pX = pLoop->aLTerm[j];
			if (pX == 0) continue;
			if (pX == pTerm) break;
			if (pX->iParent >= 0 && (&pWC->a[pX->iParent]) == pTerm) break;
		}
		if (j<0) {
			if (pTerm->truthProb <= 0) {
				
				pLoop->nOut += pTerm->truthProb;
			}
			else {
				
				pLoop->nOut--;
				if (pTerm->eOperator&(WO_EQ | WO_IS)) {
					Expr *pRight = pTerm->pExpr->pRight;
					testcase(pTerm->pExpr->op == TK_IS);
					if (sqlite3ExprIsInteger(pRight, &k) && k >= (-1) && k <= 1) {
						k = 10;
					}
					else {
						k = 20;
					}
					if (iReduce<k) iReduce = k;
				}
			}
		}
	}
	if (pLoop->nOut > nRow - iReduce)  pLoop->nOut = nRow - iReduce;
}


static int whereRangeVectorLen(
	Parse *pParse,       
	int iCur,            
	Index *pIdx,         
	int nEq,             
	WhereTerm *pTerm     
) {
	int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);
	int i;

	nCmp = MIN(nCmp, (pIdx->nColumn - nEq));
	for (i = 1; i<nCmp; i++) {
		
		char aff;                     
		char idxaff = 0;              
		CollSeq *pColl;               
		Expr *pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;
		Expr *pRhs = pTerm->pExpr->pRight;
		if (pRhs->flags & EP_xIsSelect) {
			pRhs = pRhs->x.pSelect->pEList->a[i].pExpr;
		}
		else {
			pRhs = pRhs->x.pList->a[i].pExpr;
		}

		
		if (pLhs->op != TK_COLUMN
			|| pLhs->iTable != iCur
			|| pLhs->iColumn != pIdx->aiColumn[i + nEq]
			|| pIdx->aSortOrder[i + nEq] != pIdx->aSortOrder[nEq]
			) {
			break;
		}

		testcase(pLhs->iColumn == XN_ROWID);
		aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs));
		idxaff = sqlite3TableColumnAffinity(pIdx->pTable, pLhs->iColumn);
		if (aff != idxaff) break;

		pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
		if (pColl == 0) break;
		if (sqlite3StrICmp(pColl->zName, pIdx->azColl[i + nEq])) break;
	}
	return i;
}


#ifdef SQLITE_ENABLE_COSTMULT
# define ApplyCostMultiplier(C,T)  C += T
#else
# define ApplyCostMultiplier(C,T)
#endif


static int whereLoopAddBtreeIndex(
	WhereLoopBuilder *pBuilder,     
	struct SrcList_item *pSrc,      
	Index *pProbe,                  
	LogEst nInMul                   
) {
	WhereInfo *pWInfo = pBuilder->pWInfo;  
	Parse *pParse = pWInfo->pParse;        
	sqlite3 *db = pParse->db;       
	WhereLoop *pNew;                
	WhereTerm *pTerm;               
	int opMask;                     
	WhereScan scan;                 
	Bitmask saved_prereq;           
	u16 saved_nLTerm;               
	u16 saved_nEq;                  
	u16 saved_nBtm;                 
	u16 saved_nTop;                 
	u16 saved_nSkip;                
	u32 saved_wsFlags;              
	LogEst saved_nOut;              
	int rc = SQLITE_OK;             
	LogEst rSize;                   
	LogEst rLogSize;                
	WhereTerm *pTop = 0, *pBtm = 0; 

	pNew = pBuilder->pNew;
	if (db->mallocFailed) return SQLITE_NOMEM_BKPT;
	WHERETRACE(0x800, ("BEGIN addBtreeIdx(%s), nEq=%d\n",
		pProbe->zName, pNew->u.btree.nEq));

	assert((pNew->wsFlags & WHERE_VIRTUALTABLE) == 0);
	assert((pNew->wsFlags & WHERE_TOP_LIMIT) == 0);
	if (pNew->wsFlags & WHERE_BTM_LIMIT) {
		opMask = WO_LT | WO_LE;
	}
	else {
		assert(pNew->u.btree.nBtm == 0);
		opMask = WO_EQ | WO_IN | WO_GT | WO_GE | WO_LT | WO_LE | WO_ISNULL | WO_IS;
	}
	if (pProbe->bUnordered) opMask &= ~(WO_GT | WO_GE | WO_LT | WO_LE);

	assert(pNew->u.btree.nEq<pProbe->nColumn);

	saved_nEq = pNew->u.btree.nEq;
	saved_nBtm = pNew->u.btree.nBtm;
	saved_nTop = pNew->u.btree.nTop;
	saved_nSkip = pNew->nSkip;
	saved_nLTerm = pNew->nLTerm;
	saved_wsFlags = pNew->wsFlags;
	saved_prereq = pNew->prereq;
	saved_nOut = pNew->nOut;
	pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,
		opMask, pProbe);
	pNew->rSetup = 0;
	rSize = pProbe->aiRowLogEst[0];
	rLogSize = estLog(rSize);
	for (; rc == SQLITE_OK && pTerm != 0; pTerm = whereScanNext(&scan)) {
		u16 eOp = pTerm->eOperator;   
		LogEst rCostIdx;
		LogEst nOutUnadjusted;        
		int nIn = 0;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		int nRecValid = pBuilder->nRecValid;
#endif
		if ((eOp == WO_ISNULL || (pTerm->wtFlags&TERM_VNULL) != 0)
			&& indexColumnNotNull(pProbe, saved_nEq)
			) {
			continue; 
		}
		if (pTerm->prereqRight & pNew->maskSelf) continue;

		
		if (pTerm->wtFlags & TERM_LIKEOPT && pTerm->eOperator == WO_LT) continue;

		
		if ((pSrc->fg.jointype & JT_LEFT) != 0
			&& !ExprHasProperty(pTerm->pExpr, EP_FromJoin)
			&& (eOp & (WO_IS | WO_ISNULL)) != 0
			) {
			testcase(eOp & WO_IS);
			testcase(eOp & WO_ISNULL);
			continue;
		}

		pNew->wsFlags = saved_wsFlags;
		pNew->u.btree.nEq = saved_nEq;
		pNew->u.btree.nBtm = saved_nBtm;
		pNew->u.btree.nTop = saved_nTop;
		pNew->nLTerm = saved_nLTerm;
		if (whereLoopResize(db, pNew, pNew->nLTerm + 1)) break; 
		pNew->aLTerm[pNew->nLTerm++] = pTerm;
		pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~pNew->maskSelf;

		assert(nInMul == 0
			|| (pNew->wsFlags & WHERE_COLUMN_NULL) != 0
			|| (pNew->wsFlags & WHERE_COLUMN_IN) != 0
			|| (pNew->wsFlags & WHERE_SKIPSCAN) != 0
		);

		if (eOp & WO_IN) {
			Expr *pExpr = pTerm->pExpr;
			pNew->wsFlags |= WHERE_COLUMN_IN;
			if (ExprHasProperty(pExpr, EP_xIsSelect)) {
				
				int i;
				nIn = 46;  assert(46 == sqlite3LogEst(25));

				
				for (i = 0; i<pNew->nLTerm - 1; i++) {
					if (pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr == pExpr) nIn = 0;
				}
			}
			else if (ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr)) {
				
				nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
				assert(nIn>0);  
			}
		}
		else if (eOp & (WO_EQ | WO_IS)) {
			int iCol = pProbe->aiColumn[saved_nEq];
			pNew->wsFlags |= WHERE_COLUMN_EQ;
			assert(saved_nEq == pNew->u.btree.nEq);
			if (iCol == XN_ROWID
				|| (iCol>0 && nInMul == 0 && saved_nEq == pProbe->nKeyCol - 1)
				) {
				if (iCol >= 0 && pProbe->uniqNotNull == 0) {
					pNew->wsFlags |= WHERE_UNQ_WANTED;
				}
				else {
					pNew->wsFlags |= WHERE_ONEROW;
				}
			}
		}
		else if (eOp & WO_ISNULL) {
			pNew->wsFlags |= WHERE_COLUMN_NULL;
		}
		else if (eOp & (WO_GT | WO_GE)) {
			testcase(eOp & WO_GT);
			testcase(eOp & WO_GE);
			pNew->wsFlags |= WHERE_COLUMN_RANGE | WHERE_BTM_LIMIT;
			pNew->u.btree.nBtm = whereRangeVectorLen(
				pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm
			);
			pBtm = pTerm;
			pTop = 0;
			if (pTerm->wtFlags & TERM_LIKEOPT) {
				
				pTop = &pTerm[1];
				assert((pTop - (pTerm->pWC->a))<pTerm->pWC->nTerm);
				assert(pTop->wtFlags & TERM_LIKEOPT);
				assert(pTop->eOperator == WO_LT);
				if (whereLoopResize(db, pNew, pNew->nLTerm + 1)) break; 
				pNew->aLTerm[pNew->nLTerm++] = pTop;
				pNew->wsFlags |= WHERE_TOP_LIMIT;
				pNew->u.btree.nTop = 1;
			}
		}
		else {
			assert(eOp & (WO_LT | WO_LE));
			testcase(eOp & WO_LT);
			testcase(eOp & WO_LE);
			pNew->wsFlags |= WHERE_COLUMN_RANGE | WHERE_TOP_LIMIT;
			pNew->u.btree.nTop = whereRangeVectorLen(
				pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm
			);
			pTop = pTerm;
			pBtm = (pNew->wsFlags & WHERE_BTM_LIMIT) != 0 ?
				pNew->aLTerm[pNew->nLTerm - 2] : 0;
		}

		
		assert(pNew->nOut == saved_nOut);
		if (pNew->wsFlags & WHERE_COLUMN_RANGE) {
			
			whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
		}
		else {
			int nEq = ++pNew->u.btree.nEq;
			assert(eOp & (WO_ISNULL | WO_EQ | WO_IN | WO_IS));

			assert(pNew->nOut == saved_nOut);
			if (pTerm->truthProb <= 0 && pProbe->aiColumn[saved_nEq] >= 0) {
				assert((eOp & WO_IN) || nIn == 0);
				testcase(eOp & WO_IN);
				pNew->nOut += pTerm->truthProb;
				pNew->nOut -= nIn;
			}
			else {
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
				tRowcnt nOut = 0;
				if (nInMul == 0
					&& pProbe->nSample
					&& pNew->u.btree.nEq <= pProbe->nSampleCol
					&& ((eOp & WO_IN) == 0 || !ExprHasProperty(pTerm->pExpr, EP_xIsSelect))
					) {
					Expr *pExpr = pTerm->pExpr;
					if ((eOp & (WO_EQ | WO_ISNULL | WO_IS)) != 0) {
						testcase(eOp & WO_EQ);
						testcase(eOp & WO_IS);
						testcase(eOp & WO_ISNULL);
						rc = whereEqualScanEst(pParse, pBuilder, pExpr->pRight, &nOut);
					}
					else {
						rc = whereInScanEst(pParse, pBuilder, pExpr->x.pList, &nOut);
					}
					if (rc == SQLITE_NOTFOUND) rc = SQLITE_OK;
					if (rc != SQLITE_OK) break;          
					if (nOut) {
						pNew->nOut = sqlite3LogEst(nOut);
						if (pNew->nOut>saved_nOut) pNew->nOut = saved_nOut;
						pNew->nOut -= nIn;
					}
				}
				if (nOut == 0)
#endif
				{
					pNew->nOut += (pProbe->aiRowLogEst[nEq] - pProbe->aiRowLogEst[nEq - 1]);
					if (eOp & WO_ISNULL) {
						
						pNew->nOut += 10;
					}
				}
			}
		}

		
		rCostIdx = pNew->nOut + 1 + (15 * pProbe->szIdxRow) / pSrc->pTab->szTabRow;
		pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
		if ((pNew->wsFlags & (WHERE_IDX_ONLY | WHERE_IPK)) == 0) {
			pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);
		}
		ApplyCostMultiplier(pNew->rRun, pProbe->pTable->costMult);

		nOutUnadjusted = pNew->nOut;
		pNew->rRun += nInMul + nIn;
		pNew->nOut += nInMul + nIn;
		whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);
		rc = whereLoopInsert(pBuilder, pNew);

		if (pNew->wsFlags & WHERE_COLUMN_RANGE) {
			pNew->nOut = saved_nOut;
		}
		else {
			pNew->nOut = nOutUnadjusted;
		}

		if ((pNew->wsFlags & WHERE_TOP_LIMIT) == 0
			&& pNew->u.btree.nEq<pProbe->nColumn
			) {
			whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul + nIn);
		}
		pNew->nOut = saved_nOut;
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		pBuilder->nRecValid = nRecValid;
#endif
	}
	pNew->prereq = saved_prereq;
	pNew->u.btree.nEq = saved_nEq;
	pNew->u.btree.nBtm = saved_nBtm;
	pNew->u.btree.nTop = saved_nTop;
	pNew->nSkip = saved_nSkip;
	pNew->wsFlags = saved_wsFlags;
	pNew->nOut = saved_nOut;
	pNew->nLTerm = saved_nLTerm;

	
	assert(42 == sqlite3LogEst(18));
	if (saved_nEq == saved_nSkip
		&& saved_nEq + 1<pProbe->nKeyCol
		&& pProbe->noSkipScan == 0
		&& pProbe->aiRowLogEst[saved_nEq + 1] >= 42  
		&& (rc = whereLoopResize(db, pNew, pNew->nLTerm + 1)) == SQLITE_OK
		) {
		LogEst nIter;
		pNew->u.btree.nEq++;
		pNew->nSkip++;
		pNew->aLTerm[pNew->nLTerm++] = 0;
		pNew->wsFlags |= WHERE_SKIPSCAN;
		nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq + 1];
		pNew->nOut -= nIter;
		
		nIter += 5;
		whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nIter + nInMul);
		pNew->nOut = saved_nOut;
		pNew->u.btree.nEq = saved_nEq;
		pNew->nSkip = saved_nSkip;
		pNew->wsFlags = saved_wsFlags;
	}

	WHERETRACE(0x800, ("END addBtreeIdx(%s), nEq=%d, rc=%d\n",
		pProbe->zName, saved_nEq, rc));
	return rc;
}


static int indexMightHelpWithOrderBy(
	WhereLoopBuilder *pBuilder,
	Index *pIndex,
	int iCursor
) {
	ExprList *pOB;
	ExprList *aColExpr;
	int ii, jj;

	if (pIndex->bUnordered) return 0;
	if ((pOB = pBuilder->pWInfo->pOrderBy) == 0) return 0;
	for (ii = 0; ii<pOB->nExpr; ii++) {
		Expr *pExpr = sqlite3ExprSkipCollate(pOB->a[ii].pExpr);
		if (pExpr->op == TK_COLUMN && pExpr->iTable == iCursor) {
			if (pExpr->iColumn<0) return 1;
			for (jj = 0; jj<pIndex->nKeyCol; jj++) {
				if (pExpr->iColumn == pIndex->aiColumn[jj]) return 1;
			}
		}
		else if ((aColExpr = pIndex->aColExpr) != 0) {
			for (jj = 0; jj<pIndex->nKeyCol; jj++) {
				if (pIndex->aiColumn[jj] != XN_EXPR) continue;
				if (sqlite3ExprCompare(pExpr, aColExpr->a[jj].pExpr, iCursor) == 0) {
					return 1;
				}
			}
		}
	}
	return 0;
}


static Bitmask columnsInIndex(Index *pIdx) {
	Bitmask m = 0;
	int j;
	for (j = pIdx->nColumn - 1; j >= 0; j--) {
		int x = pIdx->aiColumn[j];
		if (x >= 0) {
			testcase(x == BMS - 1);
			testcase(x == BMS - 2);
			if (x<BMS - 1) m |= MASKBIT(x);
		}
	}
	return m;
}


static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere) {
	int i;
	WhereTerm *pTerm;
	while (pWhere->op == TK_AND) {
		if (!whereUsablePartialIndex(iTab, pWC, pWhere->pLeft)) return 0;
		pWhere = pWhere->pRight;
	}
	for (i = 0, pTerm = pWC->a; i<pWC->nTerm; i++, pTerm++) {
		Expr *pExpr = pTerm->pExpr;
		if (sqlite3ExprImpliesExpr(pExpr, pWhere, iTab)
			&& (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable == iTab)
			) {
			return 1;
		}
	}
	return 0;
}


static int whereLoopAddBtree(
	WhereLoopBuilder *pBuilder, 
	Bitmask mPrereq             
) {
	WhereInfo *pWInfo;          
	Index *pProbe;              
	Index sPk;                  
	LogEst aiRowEstPk[2];       
	i16 aiColumnPk = -1;        
	SrcList *pTabList;          
	struct SrcList_item *pSrc;  
	WhereLoop *pNew;            
	int rc = SQLITE_OK;         
	int iSortIdx = 1;           
	int b;                      
	LogEst rSize;               
	LogEst rLogSize;            
	WhereClause *pWC;           
	Table *pTab;                

	pNew = pBuilder->pNew;
	pWInfo = pBuilder->pWInfo;
	pTabList = pWInfo->pTabList;
	pSrc = pTabList->a + pNew->iTab;
	pTab = pSrc->pTab;
	pWC = pBuilder->pWC;
	assert(!IsVirtual(pSrc->pTab));

	if (pSrc->pIBIndex) {
		
		pProbe = pSrc->pIBIndex;
	}
	else if (!HasRowid(pTab)) {
		pProbe = pTab->pIndex;
	}
	else {
		
		Index *pFirst;                  
		memset(&sPk, 0, sizeof(Index));
		sPk.nKeyCol = 1;
		sPk.nColumn = 1;
		sPk.aiColumn = &aiColumnPk;
		sPk.aiRowLogEst = aiRowEstPk;
		sPk.onError = OE_Replace;
		sPk.pTable = pTab;
		sPk.szIdxRow = pTab->szTabRow;
		aiRowEstPk[0] = pTab->nRowLogEst;
		aiRowEstPk[1] = 0;
		pFirst = pSrc->pTab->pIndex;
		if (pSrc->fg.notIndexed == 0) {
			
			sPk.pNext = pFirst;
		}
		pProbe = &sPk;
	}
	rSize = pTab->nRowLogEst;
	rLogSize = estLog(rSize);

#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
	
	if (!pBuilder->pOrSet      
		&& (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE) == 0
		&& (pWInfo->pParse->db->flags & SQLITE_AutoIndex) != 0
		&& pSrc->pIBIndex == 0      
		&& !pSrc->fg.notIndexed   
		&& HasRowid(pTab)         
		&& !pSrc->fg.isCorrelated 
		&& !pSrc->fg.isRecursive  
		) {
		
		WhereTerm *pTerm;
		WhereTerm *pWCEnd = pWC->a + pWC->nTerm;
		for (pTerm = pWC->a; rc == SQLITE_OK && pTerm<pWCEnd; pTerm++) {
			if (pTerm->prereqRight & pNew->maskSelf) continue;
			if (termCanDriveIndex(pTerm, pSrc, 0)) {
				pNew->u.btree.nEq = 1;
				pNew->nSkip = 0;
				pNew->u.btree.pIndex = 0;
				pNew->nLTerm = 1;
				pNew->aLTerm[0] = pTerm;
				
				pNew->rSetup = rLogSize + rSize + 4;
				if (pTab->pSelect == 0 && (pTab->tabFlags & TF_Ephemeral) == 0) {
					pNew->rSetup += 24;
				}
				ApplyCostMultiplier(pNew->rSetup, pTab->costMult);
				if (pNew->rSetup<0) pNew->rSetup = 0;
				
				pNew->nOut = 43;  assert(43 == sqlite3LogEst(20));
				pNew->rRun = sqlite3LogEstAdd(rLogSize, pNew->nOut);
				pNew->wsFlags = WHERE_AUTO_INDEX;
				pNew->prereq = mPrereq | pTerm->prereqRight;
				rc = whereLoopInsert(pBuilder, pNew);
			}
		}
	}
#endif 

	
	for (; rc == SQLITE_OK && pProbe; pProbe = pProbe->pNext, iSortIdx++) {
		if (pProbe->pPartIdxWhere != 0
			&& !whereUsablePartialIndex(pSrc->iCursor, pWC, pProbe->pPartIdxWhere)) {
			testcase(pNew->iTab != pSrc->iCursor);  
			continue;  
		}
		rSize = pProbe->aiRowLogEst[0];
		pNew->u.btree.nEq = 0;
		pNew->u.btree.nBtm = 0;
		pNew->u.btree.nTop = 0;
		pNew->nSkip = 0;
		pNew->nLTerm = 0;
		pNew->iSortIdx = 0;
		pNew->rSetup = 0;
		pNew->prereq = mPrereq;
		pNew->nOut = rSize;
		pNew->u.btree.pIndex = pProbe;
		b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);
		
		assert((pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED) == 0 || b == 0);
		if (pProbe->tnum <= 0) {
			
			pNew->wsFlags = WHERE_IPK;

			
			pNew->iSortIdx = b ? iSortIdx : 0;
			
			pNew->rRun = rSize + 16;
			ApplyCostMultiplier(pNew->rRun, pTab->costMult);
			whereLoopOutputAdjust(pWC, pNew, rSize);
			rc = whereLoopInsert(pBuilder, pNew);
			pNew->nOut = rSize;
			if (rc) break;
		}
		else {
			Bitmask m;
			if (pProbe->isCovering) {
				pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;
				m = 0;
			}
			else {
				m = pSrc->colUsed & ~columnsInIndex(pProbe);
				pNew->wsFlags = (m == 0) ? (WHERE_IDX_ONLY | WHERE_INDEXED) : WHERE_INDEXED;
			}

			
			if (b
				|| !HasRowid(pTab)
				|| pProbe->pPartIdxWhere != 0
				|| (m == 0
					&& pProbe->bUnordered == 0
					&& (pProbe->szIdxRow<pTab->szTabRow)
					&& (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED) == 0
					&& sqlite3GlobalConfig.bUseCis
					&& OptimizationEnabled(pWInfo->pParse->db, SQLITE_CoverIdxScan)
					)
				) {
				pNew->iSortIdx = b ? iSortIdx : 0;

				
				pNew->rRun = rSize + 1 + (15 * pProbe->szIdxRow) / pTab->szTabRow;
				if (m != 0) {
					
					LogEst nLookup = rSize + 16;  
					int ii;
					int iCur = pSrc->iCursor;
					WhereClause *pWC2 = &pWInfo->sWC;
					for (ii = 0; ii<pWC2->nTerm; ii++) {
						WhereTerm *pTerm = &pWC2->a[ii];
						if (!sqlite3ExprCoveredByIndex(pTerm->pExpr, iCur, pProbe)) {
							break;
						}
						
						if (pTerm->truthProb <= 0) {
							nLookup += pTerm->truthProb;
						}
						else {
							nLookup--;
							if (pTerm->eOperator & (WO_EQ | WO_IS)) nLookup -= 19;
						}
					}

					pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);
				}
				ApplyCostMultiplier(pNew->rRun, pTab->costMult);
				whereLoopOutputAdjust(pWC, pNew, rSize);
				rc = whereLoopInsert(pBuilder, pNew);
				pNew->nOut = rSize;
				if (rc) break;
			}
		}

		rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);
#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
		sqlite3Stat4ProbeFree(pBuilder->pRec);
		pBuilder->nRecValid = 0;
		pBuilder->pRec = 0;
#endif

		
		if (pSrc->pIBIndex) break;
	}
	return rc;
}

#ifndef SQLITE_OMIT_VIRTUALTABLE


static int whereLoopAddVirtualOne(
	WhereLoopBuilder *pBuilder,
	Bitmask mPrereq,                
	Bitmask mUsable,                
	u16 mExclude,                   
	sqlite3_index_info *pIdxInfo,   
	u16 mNoOmit,                    
	int *pbIn                       
) {
	WhereClause *pWC = pBuilder->pWC;
	struct sqlite3_index_constraint *pIdxCons;
	struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;
	int i;
	int mxTerm;
	int rc = SQLITE_OK;
	WhereLoop *pNew = pBuilder->pNew;
	Parse *pParse = pBuilder->pWInfo->pParse;
	struct SrcList_item *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];
	int nConstraint = pIdxInfo->nConstraint;

	assert((mUsable & mPrereq) == mPrereq);
	*pbIn = 0;
	pNew->prereq = mPrereq;

	
	pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
	for (i = 0; i<nConstraint; i++, pIdxCons++) {
		WhereTerm *pTerm = &pWC->a[pIdxCons->iTermOffset];
		pIdxCons->usable = 0;
		if ((pTerm->prereqRight & mUsable) == pTerm->prereqRight
			&& (pTerm->eOperator & mExclude) == 0
			) {
			pIdxCons->usable = 1;
		}
	}

	
	memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
	assert(pIdxInfo->needToFreeIdxStr == 0);
	pIdxInfo->idxStr = 0;
	pIdxInfo->idxNum = 0;
	pIdxInfo->orderByConsumed = 0;
	pIdxInfo->estimatedCost = SQLITE_BIG_DBL / (double)2;
	pIdxInfo->estimatedRows = 25;
	pIdxInfo->idxFlags = 0;
	pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;

	
	rc = vtabBestIndex(pParse, pSrc->pTab, pIdxInfo);
	if (rc) return rc;

	mxTerm = -1;
	assert(pNew->nLSlot >= nConstraint);
	for (i = 0; i<nConstraint; i++) pNew->aLTerm[i] = 0;
	pNew->u.vtab.omitMask = 0;
	pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
	for (i = 0; i<nConstraint; i++, pIdxCons++) {
		int iTerm;
		if ((iTerm = pUsage[i].argvIndex - 1) >= 0) {
			WhereTerm *pTerm;
			int j = pIdxCons->iTermOffset;
			if (iTerm >= nConstraint
				|| j<0
				|| j >= pWC->nTerm
				|| pNew->aLTerm[iTerm] != 0
				|| pIdxCons->usable == 0
				) {
				rc = SQLITE_ERROR;
				sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc->pTab->zName);
				return rc;
			}
			testcase(iTerm == nConstraint - 1);
			testcase(j == 0);
			testcase(j == pWC->nTerm - 1);
			pTerm = &pWC->a[j];
			pNew->prereq |= pTerm->prereqRight;
			assert(iTerm<pNew->nLSlot);
			pNew->aLTerm[iTerm] = pTerm;
			if (iTerm>mxTerm) mxTerm = iTerm;
			testcase(iTerm == 15);
			testcase(iTerm == 16);
			if (iTerm<16 && pUsage[i].omit) pNew->u.vtab.omitMask |= 1 << iTerm;
			if ((pTerm->eOperator & WO_IN) != 0) {
				
				pIdxInfo->orderByConsumed = 0;
				pIdxInfo->idxFlags &= ~SQLITE_INDEX_SCAN_UNIQUE;
				*pbIn = 1; assert((mExclude & WO_IN) == 0);
			}
		}
	}
	pNew->u.vtab.omitMask &= ~mNoOmit;

	pNew->nLTerm = mxTerm + 1;
	assert(pNew->nLTerm <= pNew->nLSlot);
	pNew->u.vtab.idxNum = pIdxInfo->idxNum;
	pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr;
	pIdxInfo->needToFreeIdxStr = 0;
	pNew->u.vtab.idxStr = pIdxInfo->idxStr;
	pNew->u.vtab.isOrdered = (i8)(pIdxInfo->orderByConsumed ?
		pIdxInfo->nOrderBy : 0);
	pNew->rSetup = 0;
	pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);
	pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);

	
	if (pIdxInfo->idxFlags & SQLITE_INDEX_SCAN_UNIQUE) {
		pNew->wsFlags |= WHERE_ONEROW;
	}
	else {
		pNew->wsFlags &= ~WHERE_ONEROW;
	}
	rc = whereLoopInsert(pBuilder, pNew);
	if (pNew->u.vtab.needFree) {
		sqlite3_free(pNew->u.vtab.idxStr);
		pNew->u.vtab.needFree = 0;
	}
	WHERETRACE(0xffff, ("  bIn=%d prereqIn=%04llx prereqOut=%04llx\n",
		*pbIn, (sqlite3_uint64)mPrereq,
		(sqlite3_uint64)(pNew->prereq & ~mPrereq)));

	return rc;
}



static int whereLoopAddVirtual(
	WhereLoopBuilder *pBuilder,  
	Bitmask mPrereq,             
	Bitmask mUnusable            
) {
	int rc = SQLITE_OK;          
	WhereInfo *pWInfo;           
	Parse *pParse;               
	WhereClause *pWC;            
	struct SrcList_item *pSrc;   
	sqlite3_index_info *p;       
	int nConstraint;             
	int bIn;                     
	WhereLoop *pNew;
	Bitmask mBest;               
	u16 mNoOmit;

	assert((mPrereq & mUnusable) == 0);
	pWInfo = pBuilder->pWInfo;
	pParse = pWInfo->pParse;
	pWC = pBuilder->pWC;
	pNew = pBuilder->pNew;
	pSrc = &pWInfo->pTabList->a[pNew->iTab];
	assert(IsVirtual(pSrc->pTab));
	p = allocateIndexInfo(pParse, pWC, mUnusable, pSrc, pBuilder->pOrderBy,
		&mNoOmit);
	if (p == 0) return SQLITE_NOMEM_BKPT;
	pNew->rSetup = 0;
	pNew->wsFlags = WHERE_VIRTUALTABLE;
	pNew->nLTerm = 0;
	pNew->u.vtab.needFree = 0;
	nConstraint = p->nConstraint;
	if (whereLoopResize(pParse->db, pNew, nConstraint)) {
		sqlite3DbFree(pParse->db, p);
		return SQLITE_NOMEM_BKPT;
	}

	
	WHERETRACE(0x40, ("  VirtualOne: all usable\n"));
	rc = whereLoopAddVirtualOne(pBuilder, mPrereq, ALLBITS, 0, p, mNoOmit, &bIn);

	
	if (rc == SQLITE_OK && (mBest = (pNew->prereq & ~mPrereq)) != 0) {
		int seenZero = 0;             
		int seenZeroNoIN = 0;         
		Bitmask mPrev = 0;
		Bitmask mBestNoIn = 0;

		
		if (bIn) {
			WHERETRACE(0x40, ("  VirtualOne: all usable w/o IN\n"));
			rc = whereLoopAddVirtualOne(
				pBuilder, mPrereq, ALLBITS, WO_IN, p, mNoOmit, &bIn);
			assert(bIn == 0);
			mBestNoIn = pNew->prereq & ~mPrereq;
			if (mBestNoIn == 0) {
				seenZero = 1;
				seenZeroNoIN = 1;
			}
		}

		
		while (rc == SQLITE_OK) {
			int i;
			Bitmask mNext = ALLBITS;
			assert(mNext>0);
			for (i = 0; i<nConstraint; i++) {
				Bitmask mThis = (
					pWC->a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq
					);
				if (mThis>mPrev && mThis<mNext) mNext = mThis;
			}
			mPrev = mNext;
			if (mNext == ALLBITS) break;
			if (mNext == mBest || mNext == mBestNoIn) continue;
			WHERETRACE(0x40, ("  VirtualOne: mPrev=%04llx mNext=%04llx\n",
				(sqlite3_uint64)mPrev, (sqlite3_uint64)mNext));
			rc = whereLoopAddVirtualOne(
				pBuilder, mPrereq, mNext | mPrereq, 0, p, mNoOmit, &bIn);
			if (pNew->prereq == mPrereq) {
				seenZero = 1;
				if (bIn == 0) seenZeroNoIN = 1;
			}
		}

		
		if (rc == SQLITE_OK && seenZero == 0) {
			WHERETRACE(0x40, ("  VirtualOne: all disabled\n"));
			rc = whereLoopAddVirtualOne(
				pBuilder, mPrereq, mPrereq, 0, p, mNoOmit, &bIn);
			if (bIn == 0) seenZeroNoIN = 1;
		}

		
		if (rc == SQLITE_OK && seenZeroNoIN == 0) {
			WHERETRACE(0x40, ("  VirtualOne: all disabled and w/o IN\n"));
			rc = whereLoopAddVirtualOne(
				pBuilder, mPrereq, mPrereq, WO_IN, p, mNoOmit, &bIn);
		}
	}

	if (p->needToFreeIdxStr) sqlite3_free(p->idxStr);
	sqlite3DbFree(pParse->db, p);
	return rc;
}
#endif 


static int whereLoopAddOr(
	WhereLoopBuilder *pBuilder,
	Bitmask mPrereq,
	Bitmask mUnusable
) {
	WhereInfo *pWInfo = pBuilder->pWInfo;
	WhereClause *pWC;
	WhereLoop *pNew;
	WhereTerm *pTerm, *pWCEnd;
	int rc = SQLITE_OK;
	int iCur;
	WhereClause tempWC;
	WhereLoopBuilder sSubBuild;
	WhereOrSet sSum, sCur;
	struct SrcList_item *pItem;

	pWC = pBuilder->pWC;
	pWCEnd = pWC->a + pWC->nTerm;
	pNew = pBuilder->pNew;
	memset(&sSum, 0, sizeof(sSum));
	pItem = pWInfo->pTabList->a + pNew->iTab;
	iCur = pItem->iCursor;

	for (pTerm = pWC->a; pTerm<pWCEnd && rc == SQLITE_OK; pTerm++) {
		if ((pTerm->eOperator & WO_OR) != 0
			&& (pTerm->u.pOrInfo->indexable & pNew->maskSelf) != 0
			) {
			WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;
			WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];
			WhereTerm *pOrTerm;
			int once = 1;
			int i, j;

			sSubBuild = *pBuilder;
			sSubBuild.pOrderBy = 0;
			sSubBuild.pOrSet = &sCur;

			WHERETRACE(0x200, ("Begin processing OR-clause %p\n", pTerm));
			for (pOrTerm = pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++) {
				if ((pOrTerm->eOperator & WO_AND) != 0) {
					sSubBuild.pWC = &pOrTerm->u.pAndInfo->wc;
				}
				else if (pOrTerm->leftCursor == iCur) {
					tempWC.pWInfo = pWC->pWInfo;
					tempWC.pOuter = pWC;
					tempWC.op = TK_AND;
					tempWC.nTerm = 1;
					tempWC.a = pOrTerm;
					sSubBuild.pWC = &tempWC;
				}
				else {
					continue;
				}
				sCur.n = 0;
#ifdef WHERETRACE_ENABLED
				WHERETRACE(0x200, ("OR-term %d of %p has %d subterms:\n",
					(int)(pOrTerm - pOrWC->a), pTerm, sSubBuild.pWC->nTerm));
				if (sqlite3WhereTrace & 0x400) {
					sqlite3WhereClausePrint(sSubBuild.pWC);
				}
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
				if (IsVirtual(pItem->pTab)) {
					rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable);
				}
				else
#endif
				{
					rc = whereLoopAddBtree(&sSubBuild, mPrereq);
				}
				if (rc == SQLITE_OK) {
					rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable);
				}
				assert(rc == SQLITE_OK || sCur.n == 0);
				if (sCur.n == 0) {
					sSum.n = 0;
					break;
				}
				else if (once) {
					whereOrMove(&sSum, &sCur);
					once = 0;
				}
				else {
					WhereOrSet sPrev;
					whereOrMove(&sPrev, &sSum);
					sSum.n = 0;
					for (i = 0; i<sPrev.n; i++) {
						for (j = 0; j<sCur.n; j++) {
							whereOrInsert(&sSum, sPrev.a[i].prereq | sCur.a[j].prereq,
								sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun),
								sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));
						}
					}
				}
			}
			pNew->nLTerm = 1;
			pNew->aLTerm[0] = pTerm;
			pNew->wsFlags = WHERE_MULTI_OR;
			pNew->rSetup = 0;
			pNew->iSortIdx = 0;
			memset(&pNew->u, 0, sizeof(pNew->u));
			for (i = 0; rc == SQLITE_OK && i<sSum.n; i++) {
				
				pNew->rRun = sSum.a[i].rRun + 1;
				pNew->nOut = sSum.a[i].nOut;
				pNew->prereq = sSum.a[i].prereq;
				rc = whereLoopInsert(pBuilder, pNew);
			}
			WHERETRACE(0x200, ("End processing OR-clause %p\n", pTerm));
		}
	}
	return rc;
}


static int whereLoopAddAll(WhereLoopBuilder *pBuilder) {
	WhereInfo *pWInfo = pBuilder->pWInfo;
	Bitmask mPrereq = 0;
	Bitmask mPrior = 0;
	int iTab;
	SrcList *pTabList = pWInfo->pTabList;
	struct SrcList_item *pItem;
	struct SrcList_item *pEnd = &pTabList->a[pWInfo->nLevel];
	sqlite3 *db = pWInfo->pParse->db;
	int rc = SQLITE_OK;
	WhereLoop *pNew;
	u8 priorJointype = 0;

	
	pNew = pBuilder->pNew;
	whereLoopInit(pNew);
	for (iTab = 0, pItem = pTabList->a; pItem<pEnd; iTab++, pItem++) {
		Bitmask mUnusable = 0;
		pNew->iTab = iTab;
		pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);
		if (((pItem->fg.jointype | priorJointype) & (JT_LEFT | JT_CROSS)) != 0) {
			
			mPrereq = mPrior;
		}
		priorJointype = pItem->fg.jointype;
#ifndef SQLITE_OMIT_VIRTUALTABLE
		if (IsVirtual(pItem->pTab)) {
			struct SrcList_item *p;
			for (p = &pItem[1]; p<pEnd; p++) {
				if (mUnusable || (p->fg.jointype & (JT_LEFT | JT_CROSS))) {
					mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);
				}
			}
			rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);
		}
		else
#endif 
		{
			rc = whereLoopAddBtree(pBuilder, mPrereq);
		}
		if (rc == SQLITE_OK) {
			rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);
		}
		mPrior |= pNew->maskSelf;
		if (rc || db->mallocFailed) break;
	}

	whereLoopClear(db, pNew);
	return rc;
}


static i8 wherePathSatisfiesOrderBy(
	WhereInfo *pWInfo,    
	ExprList *pOrderBy,   
	WherePath *pPath,     
	u16 wctrlFlags,       
	u16 nLoop,            
	WhereLoop *pLast,     
	Bitmask *pRevMask     
) {
	u8 revSet;            
	u8 rev;               
	u8 revIdx;            
	u8 isOrderDistinct;   
	u8 distinctColumns;   
	u8 isMatch;           
	u16 eqOpMask;         
	u16 nKeyCol;          
	u16 nColumn;          
	u16 nOrderBy;         
	int iLoop;            
	int i, j;             
	int iCur;             
	int iColumn;          
	WhereLoop *pLoop = 0; 
	WhereTerm *pTerm;     
	Expr *pOBExpr;        
	CollSeq *pColl;       
	Index *pIndex;        
	sqlite3 *db = pWInfo->pParse->db;  
	Bitmask obSat = 0;    
	Bitmask obDone;       
	Bitmask orderDistinctMask;  
	Bitmask ready;              

								

	assert(pOrderBy != 0);
	if (nLoop && OptimizationDisabled(db, SQLITE_OrderByIdxJoin)) return 0;

	nOrderBy = pOrderBy->nExpr;
	testcase(nOrderBy == BMS - 1);
	if (nOrderBy>BMS - 1) return 0;  
	isOrderDistinct = 1;
	obDone = MASKBIT(nOrderBy) - 1;
	orderDistinctMask = 0;
	ready = 0;
	eqOpMask = WO_EQ | WO_IS | WO_ISNULL;
	if (wctrlFlags & WHERE_ORDERBY_LIMIT) eqOpMask |= WO_IN;
	for (iLoop = 0; isOrderDistinct && obSat<obDone && iLoop <= nLoop; iLoop++) {
		if (iLoop>0) ready |= pLoop->maskSelf;
		if (iLoop<nLoop) {
			pLoop = pPath->aLoop[iLoop];
			if (wctrlFlags & WHERE_ORDERBY_LIMIT) continue;
		}
		else {
			pLoop = pLast;
		}
		if (pLoop->wsFlags & WHERE_VIRTUALTABLE) {
			if (pLoop->u.vtab.isOrdered) obSat = obDone;
			break;
		}
		iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;

		
		for (i = 0; i<nOrderBy; i++) {
			if (MASKBIT(i) & obSat) continue;
			pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr);
			if (pOBExpr->op != TK_COLUMN) continue;
			if (pOBExpr->iTable != iCur) continue;
			pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,
				~ready, eqOpMask, 0);
			if (pTerm == 0) continue;
			if (pTerm->eOperator == WO_IN) {
				
				assert(wctrlFlags & WHERE_ORDERBY_LIMIT);
				for (j = 0; j<pLoop->nLTerm && pTerm != pLoop->aLTerm[j]; j++) {}
				if (j >= pLoop->nLTerm) continue;
			}
			if ((pTerm->eOperator&(WO_EQ | WO_IS)) != 0 && pOBExpr->iColumn >= 0) {
				const char *z1, *z2;
				pColl = sqlite3ExprCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
				if (!pColl) pColl = db->pDfltColl;
				z1 = pColl->zName;
				pColl = sqlite3ExprCollSeq(pWInfo->pParse, pTerm->pExpr);
				if (!pColl) pColl = db->pDfltColl;
				z2 = pColl->zName;
				if (sqlite3StrICmp(z1, z2) != 0) continue;
				testcase(pTerm->pExpr->op == TK_IS);
			}
			obSat |= MASKBIT(i);
		}

		if ((pLoop->wsFlags & WHERE_ONEROW) == 0) {
			if (pLoop->wsFlags & WHERE_IPK) {
				pIndex = 0;
				nKeyCol = 0;
				nColumn = 1;
			}
			else if ((pIndex = pLoop->u.btree.pIndex) == 0 || pIndex->bUnordered) {
				return 0;
			}
			else {
				nKeyCol = pIndex->nKeyCol;
				nColumn = pIndex->nColumn;
				assert(nColumn == nKeyCol + 1 || !HasRowid(pIndex->pTable));
				assert(pIndex->aiColumn[nColumn - 1] == XN_ROWID
					|| !HasRowid(pIndex->pTable));
				isOrderDistinct = IsUniqueIndex(pIndex);
			}

			
			rev = revSet = 0;
			distinctColumns = 0;
			for (j = 0; j<nColumn; j++) {
				u8 bOnce = 1; 

				assert(j >= pLoop->u.btree.nEq
					|| (pLoop->aLTerm[j] == 0) == (j<pLoop->nSkip)
				);
				if (j<pLoop->u.btree.nEq && j >= pLoop->nSkip) {
					u16 eOp = pLoop->aLTerm[j]->eOperator;

					
					if ((eOp & eqOpMask) != 0) {
						if (eOp & WO_ISNULL) {
							testcase(isOrderDistinct);
							isOrderDistinct = 0;
						}
						continue;
					}
					else if (ALWAYS(eOp & WO_IN)) {
						
						Expr *pX = pLoop->aLTerm[j]->pExpr;
						for (i = j + 1; i<pLoop->u.btree.nEq; i++) {
							if (pLoop->aLTerm[i]->pExpr == pX) {
								assert((pLoop->aLTerm[i]->eOperator & WO_IN));
								bOnce = 0;
								break;
							}
						}
					}
				}

				
				if (pIndex) {
					iColumn = pIndex->aiColumn[j];
					revIdx = pIndex->aSortOrder[j];
					if (iColumn == pIndex->pTable->iPKey) iColumn = -1;
				}
				else {
					iColumn = XN_ROWID;
					revIdx = 0;
				}

				
				if (isOrderDistinct
					&& iColumn >= 0
					&& j >= pLoop->u.btree.nEq
					&& pIndex->pTable->aCol[iColumn].notNull == 0
					) {
					isOrderDistinct = 0;
				}

				
				isMatch = 0;
				for (i = 0; bOnce && i<nOrderBy; i++) {
					if (MASKBIT(i) & obSat) continue;
					pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr);
					testcase(wctrlFlags & WHERE_GROUPBY);
					testcase(wctrlFlags & WHERE_DISTINCTBY);
					if ((wctrlFlags & (WHERE_GROUPBY | WHERE_DISTINCTBY)) == 0) bOnce = 0;
					if (iColumn >= (-1)) {
						if (pOBExpr->op != TK_COLUMN) continue;
						if (pOBExpr->iTable != iCur) continue;
						if (pOBExpr->iColumn != iColumn) continue;
					}
					else {
						if (sqlite3ExprCompare(pOBExpr, pIndex->aColExpr->a[j].pExpr, iCur)) {
							continue;
						}
					}
					if (iColumn >= 0) {
						pColl = sqlite3ExprCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
						if (!pColl) pColl = db->pDfltColl;
						if (sqlite3StrICmp(pColl->zName, pIndex->azColl[j]) != 0) continue;
					}
					isMatch = 1;
					break;
				}
				if (isMatch && (wctrlFlags & WHERE_GROUPBY) == 0) {
					
					if (revSet) {
						if ((rev ^ revIdx) != pOrderBy->a[i].sortOrder) isMatch = 0;
					}
					else {
						rev = revIdx ^ pOrderBy->a[i].sortOrder;
						if (rev) *pRevMask |= MASKBIT(iLoop);
						revSet = 1;
					}
				}
				if (isMatch) {
					if (iColumn == XN_ROWID) {
						testcase(distinctColumns == 0);
						distinctColumns = 1;
					}
					obSat |= MASKBIT(i);
				}
				else {
					
					if (j == 0 || j<nKeyCol) {
						testcase(isOrderDistinct != 0);
						isOrderDistinct = 0;
					}
					break;
				}
			} 
			if (distinctColumns) {
				testcase(isOrderDistinct == 0);
				isOrderDistinct = 1;
			}
		} 

		  
		if (isOrderDistinct) {
			orderDistinctMask |= pLoop->maskSelf;
			for (i = 0; i<nOrderBy; i++) {
				Expr *p;
				Bitmask mTerm;
				if (MASKBIT(i) & obSat) continue;
				p = pOrderBy->a[i].pExpr;
				mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet, p);
				if (mTerm == 0 && !sqlite3ExprIsConstant(p)) continue;
				if ((mTerm&~orderDistinctMask) == 0) {
					obSat |= MASKBIT(i);
				}
			}
		}
	} 
	if (obSat == obDone) return (i8)nOrderBy;
	if (!isOrderDistinct) {
		for (i = nOrderBy - 1; i>0; i--) {
			Bitmask m = MASKBIT(i) - 1;
			if ((obSat&m) == m) return i;
		}
		return 0;
	}
	return -1;
}



SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo *pWInfo) {
	assert(pWInfo->wctrlFlags & WHERE_GROUPBY);
	assert(pWInfo->wctrlFlags & WHERE_SORTBYGROUP);
	return pWInfo->sorted;
}

#ifdef WHERETRACE_ENABLED

static const char *wherePathName(WherePath *pPath, int nLoop, WhereLoop *pLast) {
	static char zName[65];
	int i;
	for (i = 0; i<nLoop; i++) { zName[i] = pPath->aLoop[i]->cId; }
	if (pLast) zName[i++] = pLast->cId;
	zName[i] = 0;
	return zName;
}
#endif


static LogEst whereSortingCost(
	WhereInfo *pWInfo,
	LogEst nRow,
	int nOrderBy,
	int nSorted
) {
	
	LogEst rScale, rSortCost;
	assert(nOrderBy>0 && 66 == sqlite3LogEst(100));
	rScale = sqlite3LogEst((nOrderBy - nSorted) * 100 / nOrderBy) - 66;
	rSortCost = nRow + rScale + 16;

	
	if ((pWInfo->wctrlFlags & WHERE_USE_LIMIT) != 0 && pWInfo->iLimit<nRow) {
		nRow = pWInfo->iLimit;
	}
	rSortCost += estLog(nRow);
	return rSortCost;
}


static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst) {
	int mxChoice;             
	int nLoop;                
	Parse *pParse;            
	sqlite3 *db;              
	int iLoop;                
	int ii, jj;               
	int mxI = 0;              
	int nOrderBy;             
	LogEst mxCost = 0;        
	LogEst mxUnsorted = 0;    
	int nTo, nFrom;           
	WherePath *aFrom;         
	WherePath *aTo;           
	WherePath *pFrom;         
	WherePath *pTo;           
	WhereLoop *pWLoop;        
	WhereLoop **pX;           
	LogEst *aSortCost = 0;    
	char *pSpace;             
	int nSpace;               

	pParse = pWInfo->pParse;
	db = pParse->db;
	nLoop = pWInfo->nLevel;
	
	mxChoice = (nLoop <= 1) ? 1 : (nLoop == 2 ? 5 : 10);
	assert(nLoop <= pWInfo->pTabList->nSrc);
	WHERETRACE(0x002, ("---- begin solver.  (nRowEst=%d)\n", nRowEst));

	
	if (pWInfo->pOrderBy == 0 || nRowEst == 0) {
		nOrderBy = 0;
	}
	else {
		nOrderBy = pWInfo->pOrderBy->nExpr;
	}

	
	nSpace = (sizeof(WherePath) + sizeof(WhereLoop*)*nLoop)*mxChoice * 2;
	nSpace += sizeof(LogEst) * nOrderBy;
	pSpace = sqlite3DbMallocRawNN(db, nSpace);
	if (pSpace == 0) return SQLITE_NOMEM_BKPT;
	aTo = (WherePath*)pSpace;
	aFrom = aTo + mxChoice;
	memset(aFrom, 0, sizeof(aFrom[0]));
	pX = (WhereLoop**)(aFrom + mxChoice);
	for (ii = mxChoice * 2, pFrom = aTo; ii>0; ii--, pFrom++, pX += nLoop) {
		pFrom->aLoop = pX;
	}
	if (nOrderBy) {
		
		aSortCost = (LogEst*)pX;
		memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
	}
	assert(aSortCost == 0 || &pSpace[nSpace] == (char*)&aSortCost[nOrderBy]);
	assert(aSortCost != 0 || &pSpace[nSpace] == (char*)pX);

	
	aFrom[0].nRow = MIN(pParse->nQueryLoop, 48);  assert(48 == sqlite3LogEst(28));
	nFrom = 1;
	assert(aFrom[0].isOrdered == 0);
	if (nOrderBy) {
		
		aFrom[0].isOrdered = nLoop>0 ? -1 : nOrderBy;
	}

	
	for (iLoop = 0; iLoop<nLoop; iLoop++) {
		nTo = 0;
		for (ii = 0, pFrom = aFrom; ii<nFrom; ii++, pFrom++) {
			for (pWLoop = pWInfo->pLoops; pWLoop; pWLoop = pWLoop->pNextLoop) {
				LogEst nOut;                      
				LogEst rCost;                     
				LogEst rUnsorted;                 
				i8 isOrdered = pFrom->isOrdered;  
				Bitmask maskNew;                  
				Bitmask revMask = 0;              

				if ((pWLoop->prereq & ~pFrom->maskLoop) != 0) continue;
				if ((pWLoop->maskSelf & pFrom->maskLoop) != 0) continue;
				if ((pWLoop->wsFlags & WHERE_AUTO_INDEX) != 0 && pFrom->nRow<10) {
					
					assert(10 == sqlite3LogEst(2));
					continue;
				}
				
				rUnsorted = sqlite3LogEstAdd(pWLoop->rSetup, pWLoop->rRun + pFrom->nRow);
				rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom->rUnsorted);
				nOut = pFrom->nRow + pWLoop->nOut;
				maskNew = pFrom->maskLoop | pWLoop->maskSelf;
				if (isOrdered<0) {
					isOrdered = wherePathSatisfiesOrderBy(pWInfo,
						pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,
						iLoop, pWLoop, &revMask);
				}
				else {
					revMask = pFrom->revLoop;
				}
				if (isOrdered >= 0 && isOrdered<nOrderBy) {
					if (aSortCost[isOrdered] == 0) {
						aSortCost[isOrdered] = whereSortingCost(
							pWInfo, nRowEst, nOrderBy, isOrdered
						);
					}
					rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]);

					WHERETRACE(0x002,
						("---- sort cost=%-3d (%d/%d) increases cost %3d to %-3d\n",
							aSortCost[isOrdered], (nOrderBy - isOrdered), nOrderBy,
							rUnsorted, rCost));
				}
				else {
					rCost = rUnsorted;
				}

				
				for (jj = 0, pTo = aTo; jj<nTo; jj++, pTo++) {
					if (pTo->maskLoop == maskNew
						&& ((pTo->isOrdered^isOrdered) & 0x80) == 0
						) {
						testcase(jj == nTo - 1);
						break;
					}
				}
				if (jj >= nTo) {
					
					if (nTo >= mxChoice
						&& (rCost>mxCost || (rCost == mxCost && rUnsorted >= mxUnsorted))
						) {
						
#ifdef WHERETRACE_ENABLED 
						if (sqlite3WhereTrace & 0x4) {
							sqlite3DebugPrintf("Skip   %s cost=%-3d,%3d order=%c\n",
								wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
								isOrdered >= 0 ? isOrdered + '0' : '?');
						}
#endif
						continue;
					}
					
					if (nTo<mxChoice) {
						
						jj = nTo++;
					}
					else {
						
						jj = mxI;
					}
					pTo = &aTo[jj];
#ifdef WHERETRACE_ENABLED 
					if (sqlite3WhereTrace & 0x4) {
						sqlite3DebugPrintf("New    %s cost=%-3d,%3d order=%c\n",
							wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
							isOrdered >= 0 ? isOrdered + '0' : '?');
					}
#endif
				}
				else {
					
					if (pTo->rCost<rCost || (pTo->rCost == rCost && pTo->nRow <= nOut)) {
#ifdef WHERETRACE_ENABLED 
						if (sqlite3WhereTrace & 0x4) {
							sqlite3DebugPrintf(
								"Skip   %s cost=%-3d,%3d order=%c",
								wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
								isOrdered >= 0 ? isOrdered + '0' : '?');
							sqlite3DebugPrintf("   vs %s cost=%-3d,%d order=%c\n",
								wherePathName(pTo, iLoop + 1, 0), pTo->rCost, pTo->nRow,
								pTo->isOrdered >= 0 ? pTo->isOrdered + '0' : '?');
						}
#endif
						
						testcase(pTo->rCost == rCost);
						continue;
					}
					testcase(pTo->rCost == rCost + 1);
					
#ifdef WHERETRACE_ENABLED 
					if (sqlite3WhereTrace & 0x4) {
						sqlite3DebugPrintf(
							"Update %s cost=%-3d,%3d order=%c",
							wherePathName(pFrom, iLoop, pWLoop), rCost, nOut,
							isOrdered >= 0 ? isOrdered + '0' : '?');
						sqlite3DebugPrintf("  was %s cost=%-3d,%3d order=%c\n",
							wherePathName(pTo, iLoop + 1, 0), pTo->rCost, pTo->nRow,
							pTo->isOrdered >= 0 ? pTo->isOrdered + '0' : '?');
					}
#endif
				}
				
				pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;
				pTo->revLoop = revMask;
				pTo->nRow = nOut;
				pTo->rCost = rCost;
				pTo->rUnsorted = rUnsorted;
				pTo->isOrdered = isOrdered;
				memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
				pTo->aLoop[iLoop] = pWLoop;
				if (nTo >= mxChoice) {
					mxI = 0;
					mxCost = aTo[0].rCost;
					mxUnsorted = aTo[0].nRow;
					for (jj = 1, pTo = &aTo[1]; jj<mxChoice; jj++, pTo++) {
						if (pTo->rCost>mxCost
							|| (pTo->rCost == mxCost && pTo->rUnsorted>mxUnsorted)
							) {
							mxCost = pTo->rCost;
							mxUnsorted = pTo->rUnsorted;
							mxI = jj;
						}
					}
				}
			}
		}

#ifdef WHERETRACE_ENABLED  
		if (sqlite3WhereTrace & 0x02) {
			sqlite3DebugPrintf("---- after round %d ----\n", iLoop);
			for (ii = 0, pTo = aTo; ii<nTo; ii++, pTo++) {
				sqlite3DebugPrintf(" %s cost=%-3d nrow=%-3d order=%c",
					wherePathName(pTo, iLoop + 1, 0), pTo->rCost, pTo->nRow,
					pTo->isOrdered >= 0 ? (pTo->isOrdered + '0') : '?');
				if (pTo->isOrdered>0) {
					sqlite3DebugPrintf(" rev=0x%llx\n", pTo->revLoop);
				}
				else {
					sqlite3DebugPrintf("\n");
				}
			}
		}
#endif

		
		pFrom = aTo;
		aTo = aFrom;
		aFrom = pFrom;
		nFrom = nTo;
	}

	if (nFrom == 0) {
		sqlite3ErrorMsg(pParse, "no query solution");
		sqlite3DbFree(db, pSpace);
		return SQLITE_ERROR;
	}

	
	pFrom = aFrom;
	for (ii = 1; ii<nFrom; ii++) {
		if (pFrom->rCost>aFrom[ii].rCost) pFrom = &aFrom[ii];
	}
	assert(pWInfo->nLevel == nLoop);
	
	for (iLoop = 0; iLoop<nLoop; iLoop++) {
		WhereLevel *pLevel = pWInfo->a + iLoop;
		pLevel->pWLoop = pWLoop = pFrom->aLoop[iLoop];
		pLevel->iFrom = pWLoop->iTab;
		pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor;
	}
	if ((pWInfo->wctrlFlags & WHERE_WANT_DISTINCT) != 0
		&& (pWInfo->wctrlFlags & WHERE_DISTINCTBY) == 0
		&& pWInfo->eDistinct == WHERE_DISTINCT_NOOP
		&& nRowEst
		) {
		Bitmask notUsed;
		int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pDistinctSet, pFrom,
			WHERE_DISTINCTBY, nLoop - 1, pFrom->aLoop[nLoop - 1], &notUsed);
		if (rc == pWInfo->pDistinctSet->nExpr) {
			pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;
		}
	}
	if (pWInfo->pOrderBy) {
		if (pWInfo->wctrlFlags & WHERE_DISTINCTBY) {
			if (pFrom->isOrdered == pWInfo->pOrderBy->nExpr) {
				pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;
			}
		}
		else {
			pWInfo->nOBSat = pFrom->isOrdered;
			pWInfo->revMask = pFrom->revLoop;
			if (pWInfo->nOBSat <= 0) {
				pWInfo->nOBSat = 0;
				if (nLoop>0) {
					u32 wsFlags = pFrom->aLoop[nLoop - 1]->wsFlags;
					if ((wsFlags & WHERE_ONEROW) == 0
						&& (wsFlags&(WHERE_IPK | WHERE_COLUMN_IN)) != (WHERE_IPK | WHERE_COLUMN_IN)
						) {
						Bitmask m = 0;
						int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,
							WHERE_ORDERBY_LIMIT, nLoop - 1, pFrom->aLoop[nLoop - 1], &m);
						testcase(wsFlags & WHERE_IPK);
						testcase(wsFlags & WHERE_COLUMN_IN);
						if (rc == pWInfo->pOrderBy->nExpr) {
							pWInfo->bOrderedInnerLoop = 1;
							pWInfo->revMask = m;
						}
					}
				}
			}
		}
		if ((pWInfo->wctrlFlags & WHERE_SORTBYGROUP)
			&& pWInfo->nOBSat == pWInfo->pOrderBy->nExpr && nLoop>0
			) {
			Bitmask revMask = 0;
			int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy,
				pFrom, 0, nLoop - 1, pFrom->aLoop[nLoop - 1], &revMask
			);
			assert(pWInfo->sorted == 0);
			if (nOrder == pWInfo->pOrderBy->nExpr) {
				pWInfo->sorted = 1;
				pWInfo->revMask = revMask;
			}
		}
	}


	pWInfo->nRowOut = pFrom->nRow;

	
	sqlite3DbFree(db, pSpace);
	return SQLITE_OK;
}


static int whereShortCut(WhereLoopBuilder *pBuilder) {
	WhereInfo *pWInfo;
	struct SrcList_item *pItem;
	WhereClause *pWC;
	WhereTerm *pTerm;
	WhereLoop *pLoop;
	int iCur;
	int j;
	Table *pTab;
	Index *pIdx;

	pWInfo = pBuilder->pWInfo;
	if (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE) return 0;
	assert(pWInfo->pTabList->nSrc >= 1);
	pItem = pWInfo->pTabList->a;
	pTab = pItem->pTab;
	if (IsVirtual(pTab)) return 0;
	if (pItem->fg.isIndexedBy) return 0;
	iCur = pItem->iCursor;
	pWC = &pWInfo->sWC;
	pLoop = pBuilder->pNew;
	pLoop->wsFlags = 0;
	pLoop->nSkip = 0;
	pTerm = sqlite3WhereFindTerm(pWC, iCur, -1, 0, WO_EQ | WO_IS, 0);
	if (pTerm) {
		testcase(pTerm->eOperator & WO_IS);
		pLoop->wsFlags = WHERE_COLUMN_EQ | WHERE_IPK | WHERE_ONEROW;
		pLoop->aLTerm[0] = pTerm;
		pLoop->nLTerm = 1;
		pLoop->u.btree.nEq = 1;
		
		pLoop->rRun = 33;  
	}
	else {
		for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {
			int opMask;
			assert(pLoop->aLTermSpace == pLoop->aLTerm);
			if (!IsUniqueIndex(pIdx)
				|| pIdx->pPartIdxWhere != 0
				|| pIdx->nKeyCol>ArraySize(pLoop->aLTermSpace)
				) continue;
			opMask = pIdx->uniqNotNull ? (WO_EQ | WO_IS) : WO_EQ;
			for (j = 0; j<pIdx->nKeyCol; j++) {
				pTerm = sqlite3WhereFindTerm(pWC, iCur, j, 0, opMask, pIdx);
				if (pTerm == 0) break;
				testcase(pTerm->eOperator & WO_IS);
				pLoop->aLTerm[j] = pTerm;
			}
			if (j != pIdx->nKeyCol) continue;
			pLoop->wsFlags = WHERE_COLUMN_EQ | WHERE_ONEROW | WHERE_INDEXED;
			if (pIdx->isCovering || (pItem->colUsed & ~columnsInIndex(pIdx)) == 0) {
				pLoop->wsFlags |= WHERE_IDX_ONLY;
			}
			pLoop->nLTerm = j;
			pLoop->u.btree.nEq = j;
			pLoop->u.btree.pIndex = pIdx;
			
			pLoop->rRun = 39;  
			break;
		}
	}
	if (pLoop->wsFlags) {
		pLoop->nOut = (LogEst)1;
		pWInfo->a[0].pWLoop = pLoop;
		pLoop->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
		pWInfo->a[0].iTabCur = iCur;
		pWInfo->nRowOut = 1;
		if (pWInfo->pOrderBy) pWInfo->nOBSat = pWInfo->pOrderBy->nExpr;
		if (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT) {
			pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;
		}
#ifdef SQLITE_DEBUG
		pLoop->cId = '0';
#endif
		return 1;
	}
	return 0;
}


SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
	Parse *pParse,          
	SrcList *pTabList,      
	Expr *pWhere,           
	ExprList *pOrderBy,     
	ExprList *pDistinctSet, 
	u16 wctrlFlags,         
	int iAuxArg             
) {
	int nByteWInfo;            
	int nTabList;              
	WhereInfo *pWInfo;         
	Vdbe *v = pParse->pVdbe;   
	Bitmask notReady;          
	WhereLoopBuilder sWLB;     
	WhereMaskSet *pMaskSet;    
	WhereLevel *pLevel;        
	WhereLoop *pLoop;          
	int ii;                    
	sqlite3 *db;               
	int rc;                    
	u8 bFordelete = 0;         

	assert((wctrlFlags & WHERE_ONEPASS_MULTIROW) == 0 || (
		(wctrlFlags & WHERE_ONEPASS_DESIRED) != 0
		&& (wctrlFlags & WHERE_OR_SUBCLAUSE) == 0
		));

	
	assert((wctrlFlags & WHERE_OR_SUBCLAUSE) == 0
		|| (wctrlFlags & WHERE_USE_LIMIT) == 0);

	
	db = pParse->db;
	memset(&sWLB, 0, sizeof(sWLB));

	
	testcase(pOrderBy && pOrderBy->nExpr == BMS - 1);
	if (pOrderBy && pOrderBy->nExpr >= BMS) pOrderBy = 0;
	sWLB.pOrderBy = pOrderBy;

	
	if (OptimizationDisabled(db, SQLITE_DistinctOpt)) {
		wctrlFlags &= ~WHERE_WANT_DISTINCT;
	}

	
	testcase(pTabList->nSrc == BMS);
	if (pTabList->nSrc>BMS) {
		sqlite3ErrorMsg(pParse, "at most %d tables in a join", BMS);
		return 0;
	}

	
	nTabList = (wctrlFlags & WHERE_OR_SUBCLAUSE) ? 1 : pTabList->nSrc;

	
	nByteWInfo = ROUND8(sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel));
	pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));
	if (db->mallocFailed) {
		sqlite3DbFree(db, pWInfo);
		pWInfo = 0;
		goto whereBeginError;
	}
	pWInfo->pParse = pParse;
	pWInfo->pTabList = pTabList;
	pWInfo->pOrderBy = pOrderBy;
	pWInfo->pDistinctSet = pDistinctSet;
	pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;
	pWInfo->nLevel = nTabList;
	pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(v);
	pWInfo->wctrlFlags = wctrlFlags;
	pWInfo->iLimit = iAuxArg;
	pWInfo->savedNQueryLoop = pParse->nQueryLoop;
	memset(&pWInfo->nOBSat, 0,
		offsetof(WhereInfo, sWC) - offsetof(WhereInfo, nOBSat));
	memset(&pWInfo->a[0], 0, sizeof(WhereLoop) + nTabList * sizeof(WhereLevel));
	assert(pWInfo->eOnePass == ONEPASS_OFF);  
	pMaskSet = &pWInfo->sMaskSet;
	sWLB.pWInfo = pWInfo;
	sWLB.pWC = &pWInfo->sWC;
	sWLB.pNew = (WhereLoop*)(((char*)pWInfo) + nByteWInfo);
	assert(EIGHT_BYTE_ALIGNMENT(sWLB.pNew));
	whereLoopInit(sWLB.pNew);
#ifdef SQLITE_DEBUG
	sWLB.pNew->cId = '*';
#endif

	
	initMaskSet(pMaskSet);
	sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);
	sqlite3WhereSplit(&pWInfo->sWC, pWhere, TK_AND);

	
	for (ii = 0; ii<sWLB.pWC->nTerm; ii++) {
		if (nTabList == 0 || sqlite3ExprIsConstantNotJoin(sWLB.pWC->a[ii].pExpr)) {
			sqlite3ExprIfFalse(pParse, sWLB.pWC->a[ii].pExpr, pWInfo->iBreak,
				SQLITE_JUMPIFNULL);
			sWLB.pWC->a[ii].wtFlags |= TERM_CODED;
		}
	}

	
	if (nTabList == 0) {
		if (pOrderBy) pWInfo->nOBSat = pOrderBy->nExpr;
		if (wctrlFlags & WHERE_WANT_DISTINCT) {
			pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;
		}
	}

	
	for (ii = 0; ii<pTabList->nSrc; ii++) {
		createMask(pMaskSet, pTabList->a[ii].iCursor);
		sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);
	}
#ifdef SQLITE_DEBUG
	for (ii = 0; ii<pTabList->nSrc; ii++) {
		Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);
		assert(m == MASKBIT(ii));
	}
#endif

	
	sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);
	if (db->mallocFailed) goto whereBeginError;

	if (wctrlFlags & WHERE_WANT_DISTINCT) {
		if (isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pDistinctSet)) {
			
			pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;
		}
		else if (pOrderBy == 0) {
			
			pWInfo->wctrlFlags |= WHERE_DISTINCTBY;
			pWInfo->pOrderBy = pDistinctSet;
		}
	}

	
#if defined(WHERETRACE_ENABLED)
	if (sqlite3WhereTrace & 0xffff) {
		sqlite3DebugPrintf("*** Optimizer Start *** (wctrlFlags: 0x%x", wctrlFlags);
		if (wctrlFlags & WHERE_USE_LIMIT) {
			sqlite3DebugPrintf(", limit: %d", iAuxArg);
		}
		sqlite3DebugPrintf(")\n");
	}
	if (sqlite3WhereTrace & 0x100) { 
		sqlite3WhereClausePrint(sWLB.pWC);
	}
#endif

	if (nTabList != 1 || whereShortCut(&sWLB) == 0) {
		rc = whereLoopAddAll(&sWLB);
		if (rc) goto whereBeginError;

#ifdef WHERETRACE_ENABLED
		if (sqlite3WhereTrace) {    
			WhereLoop *p;
			int i;
			static const char zLabel[] = "0123456789abcdefghijklmnopqrstuvwyxz"
				"ABCDEFGHIJKLMNOPQRSTUVWYXZ";
			for (p = pWInfo->pLoops, i = 0; p; p = p->pNextLoop, i++) {
				p->cId = zLabel[i % sizeof(zLabel)];
				whereLoopPrint(p, sWLB.pWC);
			}
		}
#endif

		wherePathSolver(pWInfo, 0);
		if (db->mallocFailed) goto whereBeginError;
		if (pWInfo->pOrderBy) {
			wherePathSolver(pWInfo, pWInfo->nRowOut + 1);
			if (db->mallocFailed) goto whereBeginError;
		}
	}
	if (pWInfo->pOrderBy == 0 && (db->flags & SQLITE_ReverseOrder) != 0) {
		pWInfo->revMask = ALLBITS;
	}
	if (pParse->nErr || NEVER(db->mallocFailed)) {
		goto whereBeginError;
	}
#ifdef WHERETRACE_ENABLED
	if (sqlite3WhereTrace) {
		sqlite3DebugPrintf("---- Solution nRow=%d", pWInfo->nRowOut);
		if (pWInfo->nOBSat>0) {
			sqlite3DebugPrintf(" ORDERBY=%d,0x%llx", pWInfo->nOBSat, pWInfo->revMask);
		}
		switch (pWInfo->eDistinct) {
		case WHERE_DISTINCT_UNIQUE: {
			sqlite3DebugPrintf("  DISTINCT=unique");
			break;
		}
		case WHERE_DISTINCT_ORDERED: {
			sqlite3DebugPrintf("  DISTINCT=ordered");
			break;
		}
		case WHERE_DISTINCT_UNORDERED: {
			sqlite3DebugPrintf("  DISTINCT=unordered");
			break;
		}
		}
		sqlite3DebugPrintf("\n");
		for (ii = 0; ii<pWInfo->nLevel; ii++) {
			whereLoopPrint(pWInfo->a[ii].pWLoop, sWLB.pWC);
		}
	}
#endif
	
	if (pWInfo->nLevel >= 2
		&& pDistinctSet != 0
		&& OptimizationEnabled(db, SQLITE_OmitNoopJoin)
		) {
		Bitmask tabUsed = sqlite3WhereExprListUsage(pMaskSet, pDistinctSet);
		if (sWLB.pOrderBy) {
			tabUsed |= sqlite3WhereExprListUsage(pMaskSet, sWLB.pOrderBy);
		}
		while (pWInfo->nLevel >= 2) {
			WhereTerm *pTerm, *pEnd;
			pLoop = pWInfo->a[pWInfo->nLevel - 1].pWLoop;
			if ((pWInfo->pTabList->a[pLoop->iTab].fg.jointype & JT_LEFT) == 0) break;
			if ((wctrlFlags & WHERE_WANT_DISTINCT) == 0
				&& (pLoop->wsFlags & WHERE_ONEROW) == 0
				) {
				break;
			}
			if ((tabUsed & pLoop->maskSelf) != 0) break;
			pEnd = sWLB.pWC->a + sWLB.pWC->nTerm;
			for (pTerm = sWLB.pWC->a; pTerm<pEnd; pTerm++) {
				if ((pTerm->prereqAll & pLoop->maskSelf) != 0
					&& !ExprHasProperty(pTerm->pExpr, EP_FromJoin)
					) {
					break;
				}
			}
			if (pTerm<pEnd) break;
			WHERETRACE(0xffff, ("-> drop loop %c not used\n", pLoop->cId));
			pWInfo->nLevel--;
			nTabList--;
		}
	}
	WHERETRACE(0xffff, ("*** Optimizer Finished ***\n"));
	pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;

	
	assert((wctrlFlags & WHERE_ONEPASS_DESIRED) == 0 || pWInfo->nLevel == 1);
	if ((wctrlFlags & WHERE_ONEPASS_DESIRED) != 0) {
		int wsFlags = pWInfo->a[0].pWLoop->wsFlags;
		int bOnerow = (wsFlags & WHERE_ONEROW) != 0;
		if (bOnerow
			|| ((wctrlFlags & WHERE_ONEPASS_MULTIROW) != 0
				&& 0 == (wsFlags & WHERE_VIRTUALTABLE))
			) {
			pWInfo->eOnePass = bOnerow ? ONEPASS_SINGLE : ONEPASS_MULTI;
			if (HasRowid(pTabList->a[0].pTab) && (wsFlags & WHERE_IDX_ONLY)) {
				if (wctrlFlags & WHERE_ONEPASS_MULTIROW) {
					bFordelete = OPFLAG_FORDELETE;
				}
				pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~WHERE_IDX_ONLY);
			}
		}
	}

	
	for (ii = 0, pLevel = pWInfo->a; ii<nTabList; ii++, pLevel++) {
		Table *pTab;     
		int iDb;         
		struct SrcList_item *pTabItem;

		pTabItem = &pTabList->a[pLevel->iFrom];
		pTab = pTabItem->pTab;
		iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
		pLoop = pLevel->pWLoop;
		if ((pTab->tabFlags & TF_Ephemeral) != 0 || pTab->pSelect) {
			
		}
		else
#ifndef SQLITE_OMIT_VIRTUALTABLE
			if ((pLoop->wsFlags & WHERE_VIRTUALTABLE) != 0) {
				const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
				int iCur = pTabItem->iCursor;
				sqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0, pVTab, P4_VTAB);
			}
			else if (IsVirtual(pTab)) {
				
			}
			else
#endif
				if ((pLoop->wsFlags & WHERE_IDX_ONLY) == 0
					&& (wctrlFlags & WHERE_OR_SUBCLAUSE) == 0) {
					int op = OP_OpenRead;
					if (pWInfo->eOnePass != ONEPASS_OFF) {
						op = OP_OpenWrite;
						pWInfo->aiCurOnePass[0] = pTabItem->iCursor;
					};
					sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
					assert(pTabItem->iCursor == pLevel->iTabCur);
					testcase(pWInfo->eOnePass == ONEPASS_OFF && pTab->nCol == BMS - 1);
					testcase(pWInfo->eOnePass == ONEPASS_OFF && pTab->nCol == BMS);
					if (pWInfo->eOnePass == ONEPASS_OFF && pTab->nCol<BMS && HasRowid(pTab)) {
						Bitmask b = pTabItem->colUsed;
						int n = 0;
						for (; b; b = b >> 1, n++) {}
						sqlite3VdbeChangeP4(v, -1, SQLITE_INT_TO_PTR(n), P4_INT32);
						assert(n <= pTab->nCol);
					}
#ifdef SQLITE_ENABLE_CURSOR_HINTS
					if (pLoop->u.btree.pIndex != 0) {
						sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ | bFordelete);
					}
					else
#endif
					{
						sqlite3VdbeChangeP5(v, bFordelete);
					}
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
					sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, pTabItem->iCursor, 0, 0,
						(const u8*)&pTabItem->colUsed, P4_INT64);
#endif
				}
				else {
					sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
				}
				if (pLoop->wsFlags & WHERE_INDEXED) {
					Index *pIx = pLoop->u.btree.pIndex;
					int iIndexCur;
					int op = OP_OpenRead;
					
					assert(iAuxArg != 0 || (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED) == 0);
					if (!HasRowid(pTab) && IsPrimaryKeyIndex(pIx)
						&& (wctrlFlags & WHERE_OR_SUBCLAUSE) != 0
						) {
						
						iIndexCur = pLevel->iTabCur;
						op = 0;
					}
					else if (pWInfo->eOnePass != ONEPASS_OFF) {
						Index *pJ = pTabItem->pTab->pIndex;
						iIndexCur = iAuxArg;
						assert(wctrlFlags & WHERE_ONEPASS_DESIRED);
						while (ALWAYS(pJ) && pJ != pIx) {
							iIndexCur++;
							pJ = pJ->pNext;
						}
						op = OP_OpenWrite;
						pWInfo->aiCurOnePass[1] = iIndexCur;
					}
					else if (iAuxArg && (wctrlFlags & WHERE_OR_SUBCLAUSE) != 0) {
						iIndexCur = iAuxArg;
						op = OP_ReopenIdx;
					}
					else {
						iIndexCur = pParse->nTab++;
					}
					pLevel->iIdxCur = iIndexCur;
					assert(pIx->pSchema == pTab->pSchema);
					assert(iIndexCur >= 0);
					if (op) {
						sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);
						sqlite3VdbeSetP4KeyInfo(pParse, pIx);
						if ((pLoop->wsFlags & WHERE_CONSTRAINT) != 0
							&& (pLoop->wsFlags & (WHERE_COLUMN_RANGE | WHERE_SKIPSCAN)) == 0
							&& (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN) == 0
							) {
							sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ); 
						}
						VdbeComment((v, "%s", pIx->zName));
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
						{
							u64 colUsed = 0;
							int ii, jj;
							for (ii = 0; ii<pIx->nColumn; ii++) {
								jj = pIx->aiColumn[ii];
								if (jj<0) continue;
								if (jj>63) jj = 63;
								if ((pTabItem->colUsed & MASKBIT(jj)) == 0) continue;
								colUsed |= ((u64)1) << (ii<63 ? ii : 63);
							}
							sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, iIndexCur, 0, 0,
								(u8*)&colUsed, P4_INT64);
						}
#endif 
					}
				}
				if (iDb >= 0) sqlite3CodeVerifySchema(pParse, iDb);
	}
	pWInfo->iTop = sqlite3VdbeCurrentAddr(v);
	if (db->mallocFailed) goto whereBeginError;

	
	notReady = ~(Bitmask)0;
	for (ii = 0; ii<nTabList; ii++) {
		int addrExplain;
		int wsFlags;
		pLevel = &pWInfo->a[ii];
		wsFlags = pLevel->pWLoop->wsFlags;
#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
		if ((pLevel->pWLoop->wsFlags & WHERE_AUTO_INDEX) != 0) {
			constructAutomaticIndex(pParse, &pWInfo->sWC,
				&pTabList->a[pLevel->iFrom], notReady, pLevel);
			if (db->mallocFailed) goto whereBeginError;
		}
#endif
		addrExplain = sqlite3WhereExplainOneScan(
			pParse, pTabList, pLevel, ii, pLevel->iFrom, wctrlFlags
		);
		pLevel->addrBody = sqlite3VdbeCurrentAddr(v);
		notReady = sqlite3WhereCodeOneLoopStart(pWInfo, ii, notReady);
		pWInfo->iContinue = pLevel->addrCont;
		if ((wsFlags&WHERE_MULTI_OR) == 0 && (wctrlFlags&WHERE_OR_SUBCLAUSE) == 0) {
			sqlite3WhereAddScanStatus(v, pTabList, pLevel, addrExplain);
		}
	}

	
	VdbeModuleComment((v, "Begin WHERE-core"));
	return pWInfo;

	
whereBeginError:
	if (pWInfo) {
		pParse->nQueryLoop = pWInfo->savedNQueryLoop;
		whereInfoFree(db, pWInfo);
	}
	return 0;
}


SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo) {
	Parse *pParse = pWInfo->pParse;
	Vdbe *v = pParse->pVdbe;
	int i;
	WhereLevel *pLevel;
	WhereLoop *pLoop;
	SrcList *pTabList = pWInfo->pTabList;
	sqlite3 *db = pParse->db;

	
	VdbeModuleComment((v, "End WHERE-core"));
	sqlite3ExprCacheClear(pParse);
	for (i = pWInfo->nLevel - 1; i >= 0; i--) {
		int addr;
		pLevel = &pWInfo->a[i];
		pLoop = pLevel->pWLoop;
		sqlite3VdbeResolveLabel(v, pLevel->addrCont);
		if (pLevel->op != OP_Noop) {
			sqlite3VdbeAddOp3(v, pLevel->op, pLevel->p1, pLevel->p2, pLevel->p3);
			sqlite3VdbeChangeP5(v, pLevel->p5);
			VdbeCoverage(v);
			VdbeCoverageIf(v, pLevel->op == OP_Next);
			VdbeCoverageIf(v, pLevel->op == OP_Prev);
			VdbeCoverageIf(v, pLevel->op == OP_VNext);
		}
		if (pLoop->wsFlags & WHERE_IN_ABLE && pLevel->u.in.nIn>0) {
			struct InLoop *pIn;
			int j;
			sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
			for (j = pLevel->u.in.nIn, pIn = &pLevel->u.in.aInLoop[j - 1]; j>0; j--, pIn--) {
				sqlite3VdbeJumpHere(v, pIn->addrInTop + 1);
				if (pIn->eEndLoopOp != OP_Noop) {
					sqlite3VdbeAddOp2(v, pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);
					VdbeCoverage(v);
					VdbeCoverageIf(v, pIn->eEndLoopOp == OP_PrevIfOpen);
					VdbeCoverageIf(v, pIn->eEndLoopOp == OP_NextIfOpen);
				}
				sqlite3VdbeJumpHere(v, pIn->addrInTop - 1);
			}
		}
		sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
		if (pLevel->addrSkip) {
			sqlite3VdbeGoto(v, pLevel->addrSkip);
			VdbeComment((v, "next skip-scan on %s", pLoop->u.btree.pIndex->zName));
			sqlite3VdbeJumpHere(v, pLevel->addrSkip);
			sqlite3VdbeJumpHere(v, pLevel->addrSkip - 2);
		}
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
		if (pLevel->addrLikeRep) {
			sqlite3VdbeAddOp2(v, OP_DecrJumpZero, (int)(pLevel->iLikeRepCntr >> 1),
				pLevel->addrLikeRep);
			VdbeCoverage(v);
		}
#endif
		if (pLevel->iLeftJoin) {
			int ws = pLoop->wsFlags;
			addr = sqlite3VdbeAddOp1(v, OP_IfPos, pLevel->iLeftJoin); VdbeCoverage(v);
			assert((ws & WHERE_IDX_ONLY) == 0 || (ws & WHERE_INDEXED) != 0);
			if ((ws & WHERE_IDX_ONLY) == 0) {
				sqlite3VdbeAddOp1(v, OP_NullRow, pTabList->a[i].iCursor);
			}
			if ((ws & WHERE_INDEXED)
				|| ((ws & WHERE_MULTI_OR) && pLevel->u.pCovidx)
				) {
				sqlite3VdbeAddOp1(v, OP_NullRow, pLevel->iIdxCur);
			}
			if (pLevel->op == OP_Return) {
				sqlite3VdbeAddOp2(v, OP_Gosub, pLevel->p1, pLevel->addrFirst);
			}
			else {
				sqlite3VdbeGoto(v, pLevel->addrFirst);
			}
			sqlite3VdbeJumpHere(v, addr);
		}
		VdbeModuleComment((v, "End WHERE-loop%d: %s", i,
			pWInfo->pTabList->a[pLevel->iFrom].pTab->zName));
	}

	
	sqlite3VdbeResolveLabel(v, pWInfo->iBreak);

	assert(pWInfo->nLevel <= pTabList->nSrc);
	for (i = 0, pLevel = pWInfo->a; i<pWInfo->nLevel; i++, pLevel++) {
		int k, last;
		VdbeOp *pOp;
		Index *pIdx = 0;
		struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom];
		Table *pTab = pTabItem->pTab;
		assert(pTab != 0);
		pLoop = pLevel->pWLoop;

		
		if (pTabItem->fg.viaCoroutine && !db->mallocFailed) {
			translateColumnToCopy(v, pLevel->addrBody, pLevel->iTabCur,
				pTabItem->regResult, 0);
			continue;
		}

		
		if ((pTab->tabFlags & TF_Ephemeral) == 0
			&& pTab->pSelect == 0
			&& (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE) == 0
			) {
			int ws = pLoop->wsFlags;
			if (pWInfo->eOnePass == ONEPASS_OFF && (ws & WHERE_IDX_ONLY) == 0) {
				sqlite3VdbeAddOp1(v, OP_Close, pTabItem->iCursor);
			}
			if ((ws & WHERE_INDEXED) != 0
				&& (ws & (WHERE_IPK | WHERE_AUTO_INDEX)) == 0
				&& pLevel->iIdxCur != pWInfo->aiCurOnePass[1]
				) {
				sqlite3VdbeAddOp1(v, OP_Close, pLevel->iIdxCur);
			}
		}

		
		if (pLoop->wsFlags & (WHERE_INDEXED | WHERE_IDX_ONLY)) {
			pIdx = pLoop->u.btree.pIndex;
		}
		else if (pLoop->wsFlags & WHERE_MULTI_OR) {
			pIdx = pLevel->u.pCovidx;
		}
		if (pIdx
			&& (pWInfo->eOnePass == ONEPASS_OFF || !HasRowid(pIdx->pTable))
			&& !db->mallocFailed
			) {
			last = sqlite3VdbeCurrentAddr(v);
			k = pLevel->addrBody;
			pOp = sqlite3VdbeGetOp(v, k);
			for (; k<last; k++, pOp++) {
				if (pOp->p1 != pLevel->iTabCur) continue;
				if (pOp->opcode == OP_Column) {
					int x = pOp->p2;
					assert(pIdx->pTable == pTab);
					if (!HasRowid(pTab)) {
						Index *pPk = sqlite3PrimaryKeyIndex(pTab);
						x = pPk->aiColumn[x];
						assert(x >= 0);
					}
					x = sqlite3ColumnOfIndex(pIdx, x);
					if (x >= 0) {
						pOp->p2 = x;
						pOp->p1 = pLevel->iIdxCur;
					}
					assert((pLoop->wsFlags & WHERE_IDX_ONLY) == 0 || x >= 0);
				}
				else if (pOp->opcode == OP_Rowid) {
					pOp->p1 = pLevel->iIdxCur;
					pOp->opcode = OP_IdxRowid;
				}
			}
		}
	}

	
	pParse->nQueryLoop = pWInfo->savedNQueryLoop;
	whereInfoFree(db, pWInfo);
	return;
}










#define YYNOERRORRECOVERY 1


#define yytestcase(X) testcase(X)


#define YYPARSEFREENEVERNULL 1


#define YYMALLOCARGTYPE  u64


struct LimitVal {
	Expr *pLimit;    
	Expr *pOffset;   
};


struct TrigEvent { int a; IdList * b; };


static void disableLookaside(Parse *pParse) {
	pParse->disableLookaside++;
	pParse->db->lookaside.bDisable++;
}



static void parserDoubleLinkSelect(Parse *pParse, Select *p) {
	if (p->pPrior) {
		Select *pNext = 0, *pLoop;
		int mxSelect, cnt = 0;
		for (pLoop = p; pLoop; pNext = pLoop, pLoop = pLoop->pPrior, cnt++) {
			pLoop->pNext = pNext;
			pLoop->selFlags |= SF_Compound;
		}
		if ((p->selFlags & SF_MultiValue) == 0 &&
			(mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0 &&
			cnt>mxSelect
			) {
			sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
		}
	}
}


static void spanSet(ExprSpan *pOut, Token *pStart, Token *pEnd) {
	pOut->zStart = pStart->z;
	pOut->zEnd = &pEnd->z[pEnd->n];
}


static void spanExpr(ExprSpan *pOut, Parse *pParse, int op, Token t) {
	Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr) + t.n + 1);
	if (p) {
		memset(p, 0, sizeof(Expr));
		p->op = (u8)op;
		p->flags = EP_Leaf;
		p->iAgg = -1;
		p->u.zToken = (char*)&p[1];
		memcpy(p->u.zToken, t.z, t.n);
		p->u.zToken[t.n] = 0;
		if (sqlite3Isquote(p->u.zToken[0])) {
			if (p->u.zToken[0] == '"') p->flags |= EP_DblQuoted;
			sqlite3Dequote(p->u.zToken);
		}
#if SQLITE_MAX_EXPR_DEPTH>0
		p->nHeight = 1;
#endif  
	}
	pOut->pExpr = p;
	pOut->zStart = t.z;
	pOut->zEnd = &t.z[t.n];
}


static void spanBinaryExpr(
	Parse *pParse,      
	int op,             
	ExprSpan *pLeft,    
	ExprSpan *pRight    
) {
	pLeft->pExpr = sqlite3PExpr(pParse, op, pLeft->pExpr, pRight->pExpr, 0);
	pLeft->zEnd = pRight->zEnd;
}


static void exprNot(Parse *pParse, int doNot, ExprSpan *pSpan) {
	if (doNot) {
		pSpan->pExpr = sqlite3PExpr(pParse, TK_NOT, pSpan->pExpr, 0, 0);
	}
}


static void spanUnaryPostfix(
	Parse *pParse,         
	int op,                
	ExprSpan *pOperand,    
	Token *pPostOp         
) {
	pOperand->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);
	pOperand->zEnd = &pPostOp->z[pPostOp->n];
}


static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op) {
	sqlite3 *db = pParse->db;
	if (pA && pY && pY->op == TK_NULL) {
		pA->op = (u8)op;
		sqlite3ExprDelete(db, pA->pRight);
		pA->pRight = 0;
	}
}


static void spanUnaryPrefix(
	ExprSpan *pOut,        
	Parse *pParse,         
	int op,                
	ExprSpan *pOperand,    
	Token *pPreOp         
) {
	pOut->zStart = pPreOp->z;
	pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);
	pOut->zEnd = pOperand->zEnd;
}


static ExprList *parserAddExprIdListTerm(
	Parse *pParse,
	ExprList *pPrior,
	Token *pIdToken,
	int hasCollate,
	int sortOrder
) {
	ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);
	if ((hasCollate || sortOrder != SQLITE_SO_UNDEFINED)
		&& pParse->db->init.busy == 0
		) {
		sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",
			pIdToken->n, pIdToken->z);
	}
	sqlite3ExprListSetName(pParse, p, pIdToken, 1);
	return p;
}





#ifndef INTERFACE
# define INTERFACE 1
#endif

#define YYCODETYPE unsigned char
#define YYNOCODE 252
#define YYACTIONTYPE unsigned short int
#define YYWILDCARD 96
#define sqlite3ParserTOKENTYPE Token
typedef union {
	int yyinit;
	sqlite3ParserTOKENTYPE yy0;
	Expr* yy72;
	TriggerStep* yy145;
	ExprList* yy148;
	SrcList* yy185;
	ExprSpan yy190;
	int yy194;
	Select* yy243;
	IdList* yy254;
	With* yy285;
	struct TrigEvent yy332;
	struct LimitVal yy354;
	struct { int value; int mask; } yy497;
} YYMINORTYPE;
#ifndef YYSTACKDEPTH
#define YYSTACKDEPTH 100
#endif
#define sqlite3ParserARG_SDECL Parse *pParse;
#define sqlite3ParserARG_PDECL ,Parse *pParse
#define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse
#define sqlite3ParserARG_STORE yypParser->pParse = pParse
#define YYFALLBACK 1
#define YYNSTATE             456
#define YYNRULE              332
#define YY_MAX_SHIFT         455
#define YY_MIN_SHIFTREDUCE   668
#define YY_MAX_SHIFTREDUCE   999
#define YY_MIN_REDUCE        1000
#define YY_MAX_REDUCE        1331
#define YY_ERROR_ACTION      1332
#define YY_ACCEPT_ACTION     1333
#define YY_NO_ACTION         1334



#ifndef yytestcase
# define yytestcase(X)
#endif



#define YY_ACTTAB_COUNT (1567)
static const YYACTIONTYPE yy_action[] = {
	   325,  832,  351,  825,    5,  203,  203,  819,   99,  100,
	    90,  842,  842,  854,  857,  846,  846,   97,   97,   98,
	    98,   98,   98,  301,   96,   96,   96,   96,   95,   95,
	    94,   94,   94,   93,  351,  325,  977,  977,  824,  824,
	   826,  947,  354,   99,  100,   90,  842,  842,  854,  857,
	   846,  846,   97,   97,   98,   98,   98,   98,  338,   96,
	    96,   96,   96,   95,   95,   94,   94,   94,   93,  351,
	    95,   95,   94,   94,   94,   93,  351,  791,  977,  977,
	   325,   94,   94,   94,   93,  351,  792,   75,   99,  100,
	    90,  842,  842,  854,  857,  846,  846,   97,   97,   98,
	    98,   98,   98,  450,   96,   96,   96,   96,   95,   95,
	    94,   94,   94,   93,  351, 1333,  155,  155,    2,  325,
	   275,  146,  132,   52,   52,   93,  351,   99,  100,   90,
	   842,  842,  854,  857,  846,  846,   97,   97,   98,   98,
	    98,   98,  101,   96,   96,   96,   96,   95,   95,   94,
	    94,   94,   93,  351,  958,  958,  325,  268,  428,  413,
	   411,   61,  752,  752,   99,  100,   90,  842,  842,  854,
	   857,  846,  846,   97,   97,   98,   98,   98,   98,   60,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  325,  270,  329,  273,  277,  959,  960,  250,   99,
	   100,   90,  842,  842,  854,  857,  846,  846,   97,   97,
	    98,   98,   98,   98,  301,   96,   96,   96,   96,   95,
	    95,   94,   94,   94,   93,  351,  325,  938, 1326,  698,
	   706, 1326,  242,  412,   99,  100,   90,  842,  842,  854,
	   857,  846,  846,   97,   97,   98,   98,   98,   98,  347,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  325,  938, 1327,  384,  699, 1327,  381,  379,   99,
	   100,   90,  842,  842,  854,  857,  846,  846,   97,   97,
	    98,   98,   98,   98,  701,   96,   96,   96,   96,   95,
	    95,   94,   94,   94,   93,  351,  325,   92,   89,  178,
	   833,  936,  373,  700,   99,  100,   90,  842,  842,  854,
	   857,  846,  846,   97,   97,   98,   98,   98,   98,  375,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  325, 1276,  947,  354,  818,  936,  739,  739,   99,
	   100,   90,  842,  842,  854,  857,  846,  846,   97,   97,
	    98,   98,   98,   98,  230,   96,   96,   96,   96,   95,
	    95,   94,   94,   94,   93,  351,  325,  969,  227,   92,
	    89,  178,  373,  300,   99,  100,   90,  842,  842,  854,
	   857,  846,  846,   97,   97,   98,   98,   98,   98,  921,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  325,  449,  447,  447,  447,  147,  737,  737,   99,
	   100,   90,  842,  842,  854,  857,  846,  846,   97,   97,
	    98,   98,   98,   98,  296,   96,   96,   96,   96,   95,
	    95,   94,   94,   94,   93,  351,  325,  419,  231,  958,
	   958,  158,   25,  422,   99,  100,   90,  842,  842,  854,
	   857,  846,  846,   97,   97,   98,   98,   98,   98,  450,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  443,  224,  224,  420,  958,  958,  962,  325,   52,
	    52,  959,  960,  176,  415,   78,   99,  100,   90,  842,
	   842,  854,  857,  846,  846,   97,   97,   98,   98,   98,
	    98,  379,   96,   96,   96,   96,   95,   95,   94,   94,
	    94,   93,  351,  325,  428,  418,  298,  959,  960,  962,
	    81,   99,   88,   90,  842,  842,  854,  857,  846,  846,
	    97,   97,   98,   98,   98,   98,  717,   96,   96,   96,
	    96,   95,   95,   94,   94,   94,   93,  351,  325,  843,
	   843,  855,  858,  996,  318,  343,  379,  100,   90,  842,
	   842,  854,  857,  846,  846,   97,   97,   98,   98,   98,
	    98,  450,   96,   96,   96,   96,   95,   95,   94,   94,
	    94,   93,  351,  325,  350,  350,  350,  260,  377,  340,
	   929,   52,   52,   90,  842,  842,  854,  857,  846,  846,
	    97,   97,   98,   98,   98,   98,  361,   96,   96,   96,
	    96,   95,   95,   94,   94,   94,   93,  351,   86,  445,
	   847,    3, 1203,  361,  360,  378,  344,  813,  958,  958,
	  1300,   86,  445,  729,    3,  212,  169,  287,  405,  282,
	   404,  199,  232,  450,  300,  760,   83,   84,  280,  245,
	   262,  365,  251,   85,  352,  352,   92,   89,  178,   83,
	    84,  242,  412,   52,   52,  448,   85,  352,  352,  246,
	   959,  960,  194,  455,  670,  402,  399,  398,  448,  243,
	   221,  114,  434,  776,  361,  450,  397,  268,  747,  224,
	   224,  132,  132,  198,  832,  434,  452,  451,  428,  427,
	   819,  415,  734,  713,  132,   52,   52,  832,  268,  452,
	   451,  734,  194,  819,  363,  402,  399,  398,  450, 1271,
	  1271,   23,  958,  958,   86,  445,  397,    3,  228,  429,
	   895,  824,  824,  826,  827,   19,  203,  720,   52,   52,
	   428,  408,  439,  249,  824,  824,  826,  827,   19,  229,
	   403,  153,   83,   84,  761,  177,  241,  450,  721,   85,
	   352,  352,  120,  157,  959,  960,   58,  977,  409,  355,
	   330,  448,  268,  428,  430,  320,  790,   32,   32,   86,
	   445,  776,    3,  341,   98,   98,   98,   98,  434,   96,
	    96,   96,   96,   95,   95,   94,   94,   94,   93,  351,
	   832,  120,  452,  451,  813,  887,  819,   83,   84,  977,
	   813,  132,  410,  920,   85,  352,  352,  132,  407,  789,
	   958,  958,   92,   89,  178,  917,  448,  262,  370,  261,
	    82,  914,   80,  262,  370,  261,  776,  824,  824,  826,
	   827,   19,  934,  434,   96,   96,   96,   96,   95,   95,
	    94,   94,   94,   93,  351,  832,   74,  452,  451,  958,
	   958,  819,  959,  960,  120,   92,   89,  178,  945,    2,
	   918,  965,  268,    1,  976,   76,  445,  762,    3,  708,
	   901,  901,  387,  958,  958,  757,  919,  371,  740,  778,
	   756,  257,  824,  824,  826,  827,   19,  417,  741,  450,
	    24,  959,  960,   83,   84,  369,  958,  958,  177,  226,
	    85,  352,  352,  885,  315,  314,  313,  215,  311,   10,
	    10,  683,  448,  349,  348,  959,  960,  909,  777,  157,
	   120,  958,  958,  337,  776,  416,  711,  310,  450,  434,
	   450,  321,  450,  791,  103,  200,  175,  450,  959,  960,
	   908,  832,  792,  452,  451,    9,    9,  819,   10,   10,
	    52,   52,   51,   51,  180,  716,  248,   10,   10,  171,
	   170,  167,  339,  959,  960,  247,  984,  702,  702,  450,
	   715,  233,  686,  982,  889,  983,  182,  914,  824,  824,
	   826,  827,   19,  183,  256,  423,  132,  181,  394,   10,
	    10,  889,  891,  749,  958,  958,  917,  268,  985,  198,
	   985,  349,  348,  425,  415,  299,  817,  832,  326,  825,
	   120,  332,  133,  819,  268,   98,   98,   98,   98,   91,
	    96,   96,   96,   96,   95,   95,   94,   94,   94,   93,
	   351,  157,  810,  371,  382,  359,  959,  960,  358,  268,
	   450,  918,  368,  324,  824,  824,  826,  450,  709,  450,
	   264,  380,  889,  450,  877,  746,  253,  919,  255,  433,
	    36,   36,  234,  450,  234,  120,  269,   37,   37,   12,
	    12,  334,  272,   27,   27,  450,  330,  118,  450,  162,
	   742,  280,  450,   38,   38,  450,  985,  356,  985,  450,
	   709, 1210,  450,  132,  450,   39,   39,  450,   40,   40,
	   450,  362,   41,   41,  450,   42,   42,  450,  254,   28,
	    28,  450,   29,   29,   31,   31,  450,   43,   43,  450,
	    44,   44,  450,  714,   45,   45,  450,   11,   11,  767,
	   450,   46,   46,  450,  268,  450,  105,  105,  450,   47,
	    47,  450,   48,   48,  450,  237,   33,   33,  450,  172,
	    49,   49,  450,   50,   50,   34,   34,  274,  122,  122,
	   450,  123,  123,  450,  124,  124,  450,  898,   56,   56,
	   450,  897,   35,   35,  450,  267,  450,  817,  450,  817,
	   106,  106,  450,   53,   53,  385,  107,  107,  450,  817,
	   108,  108,  817,  450,  104,  104,  121,  121,  119,  119,
	   450,  117,  112,  112,  450,  276,  450,  225,  111,  111,
	   450,  730,  450,  109,  109,  450,  673,  674,  675,  912,
	   110,  110,  317,  998,   55,   55,   57,   57,  692,  331,
	    54,   54,   26,   26,  696,   30,   30,  317,  937,  197,
	   196,  195,  335,  281,  336,  446,  331,  745,  689,  436,
	   440,  444,  120,   72,  386,  223,  175,  345,  757,  933,
	    20,  286,  319,  756,  815,  372,  374,  202,  202,  202,
	   263,  395,  285,   74,  208,   21,  696,  719,  718,  884,
	   120,  120,  120,  120,  120,  754,  278,  828,   77,   74,
	   726,  727,  785,  783,  880,  202,  999,  208,  894,  893,
	   894,  893,  694,  816,  763,  116,  774, 1290,  431,  432,
	   302,  999,  390,  303,  823,  697,  691,  680,  159,  289,
	   679,  884,  681,  952,  291,  218,  293,    7,  316,  828,
	   173,  805,  259,  364,  252,  911,  376,  713,  295,  435,
	   308,  168,  955,  993,  135,  400,  990,  284,  882,  881,
	   205,  928,  926,   59,  333,   62,  144,  156,  130,   72,
	   802,  366,  367,  393,  137,  185,  189,  160,  139,  383,
	    67,  896,  140,  141,  142,  148,  389,  812,  775,  266,
	   219,  190,  154,  391,  913,  876,  271,  406,  191,  322,
	   682,  733,  192,  342,  732,  724,  731,  711,  723,  421,
	   705,   71,  323,    6,  204,  771,  288,   79,  297,  346,
	   772,  704,  290,  283,  703,  770,  292,  294,  967,  239,
	   769,  102,  862,  438,  426,  240,  424,  442,   73,  213,
	   688,  238,   22,  453,  953,  214,  217,  216,  454,  677,
	   676,  671,  753,  125,  115,  235,  126,  669,  353,  166,
	   127,  244,  179,  357,  306,  304,  305,  307,  113,  892,
	   327,  890,  811,  328,  134,  128,  136,  138,  743,  258,
	   907,  184,  143,  129,  910,  186,   63,   64,  145,  187,
	   906,   65,    8,   66,   13,  188,  202,  899,  265,  149,
	   987,  388,  150,  685,  161,  392,  285,  193,  279,  396,
	   151,  401,   68,   14,   15,  722,   69,  236,  831,  131,
	   830,  860,   70,  751,   16,  414,  755,    4,  174,  220,
	   222,  784,  201,  152,  779,   77,   74,   17,   18,  875,
	   861,  859,  916,  864,  915,  207,  206,  942,  163,  437,
	   948,  943,  164,  209, 1002,  441,  863,  165,  210,  829,
	   695,   87,  312,  211, 1292, 1291,  309,
};
static const YYCODETYPE yy_lookahead[] = {
	    19,   95,   53,   97,   22,   24,   24,  101,   27,   28,
	    29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
	    39,   40,   41,  152,   43,   44,   45,   46,   47,   48,
	    49,   50,   51,   52,   53,   19,   55,   55,  132,  133,
	   134,    1,    2,   27,   28,   29,   30,   31,   32,   33,
	    34,   35,   36,   37,   38,   39,   40,   41,  187,   43,
	    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
	    47,   48,   49,   50,   51,   52,   53,   61,   97,   97,
	    19,   49,   50,   51,   52,   53,   70,   26,   27,   28,
	    29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
	    39,   40,   41,  152,   43,   44,   45,   46,   47,   48,
	    49,   50,   51,   52,   53,  144,  145,  146,  147,   19,
	    16,   22,   92,  172,  173,   52,   53,   27,   28,   29,
	    30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
	    40,   41,   81,   43,   44,   45,   46,   47,   48,   49,
	    50,   51,   52,   53,   55,   56,   19,  152,  207,  208,
	   115,   24,  117,  118,   27,   28,   29,   30,   31,   32,
	    33,   34,   35,   36,   37,   38,   39,   40,   41,   79,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,   19,   88,  157,   90,   23,   97,   98,  193,   27,
	    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
	    38,   39,   40,   41,  152,   43,   44,   45,   46,   47,
	    48,   49,   50,   51,   52,   53,   19,   22,   23,  172,
	    23,   26,  119,  120,   27,   28,   29,   30,   31,   32,
	    33,   34,   35,   36,   37,   38,   39,   40,   41,  187,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,   19,   22,   23,  228,   23,   26,  231,  152,   27,
	    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
	    38,   39,   40,   41,  172,   43,   44,   45,   46,   47,
	    48,   49,   50,   51,   52,   53,   19,  221,  222,  223,
	    23,   96,  152,  172,   27,   28,   29,   30,   31,   32,
	    33,   34,   35,   36,   37,   38,   39,   40,   41,  152,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,   19,    0,    1,    2,   23,   96,  190,  191,   27,
	    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
	    38,   39,   40,   41,  238,   43,   44,   45,   46,   47,
	    48,   49,   50,   51,   52,   53,   19,  185,  218,  221,
	   222,  223,  152,  152,   27,   28,   29,   30,   31,   32,
	    33,   34,   35,   36,   37,   38,   39,   40,   41,  241,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,   19,  152,  168,  169,  170,   22,  190,  191,   27,
	    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
	    38,   39,   40,   41,  152,   43,   44,   45,   46,   47,
	    48,   49,   50,   51,   52,   53,   19,   19,  218,   55,
	    56,   24,   22,  152,   27,   28,   29,   30,   31,   32,
	    33,   34,   35,   36,   37,   38,   39,   40,   41,  152,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,  250,  194,  195,   56,   55,   56,   55,   19,  172,
	   173,   97,   98,  152,  206,  138,   27,   28,   29,   30,
	    31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
	    41,  152,   43,   44,   45,   46,   47,   48,   49,   50,
	    51,   52,   53,   19,  207,  208,  152,   97,   98,   97,
	   138,   27,   28,   29,   30,   31,   32,   33,   34,   35,
	    36,   37,   38,   39,   40,   41,  181,   43,   44,   45,
	    46,   47,   48,   49,   50,   51,   52,   53,   19,   30,
	    31,   32,   33,  247,  248,   19,  152,   28,   29,   30,
	    31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
	    41,  152,   43,   44,   45,   46,   47,   48,   49,   50,
	    51,   52,   53,   19,  168,  169,  170,  238,   19,   53,
	   152,  172,  173,   29,   30,   31,   32,   33,   34,   35,
	    36,   37,   38,   39,   40,   41,  152,   43,   44,   45,
	    46,   47,   48,   49,   50,   51,   52,   53,   19,   20,
	   101,   22,   23,  169,  170,   56,  207,   85,   55,   56,
	    23,   19,   20,   26,   22,   99,  100,  101,  102,  103,
	   104,  105,  238,  152,  152,  210,   47,   48,  112,  152,
	   108,  109,  110,   54,   55,   56,  221,  222,  223,   47,
	    48,  119,  120,  172,  173,   66,   54,   55,   56,  152,
	    97,   98,   99,  148,  149,  102,  103,  104,   66,  154,
	    23,  156,   83,   26,  230,  152,  113,  152,  163,  194,
	   195,   92,   92,   30,   95,   83,   97,   98,  207,  208,
	   101,  206,  179,  180,   92,  172,  173,   95,  152,   97,
	    98,  188,   99,  101,  219,  102,  103,  104,  152,  119,
	   120,  196,   55,   56,   19,   20,  113,   22,  193,  163,
	    11,  132,  133,  134,  135,  136,   24,   65,  172,  173,
	   207,  208,  250,  152,  132,  133,  134,  135,  136,  193,
	    78,   84,   47,   48,   49,   98,  199,  152,   86,   54,
	    55,   56,  196,  152,   97,   98,  209,   55,  163,  244,
	   107,   66,  152,  207,  208,  164,  175,  172,  173,   19,
	    20,  124,   22,  111,   38,   39,   40,   41,   83,   43,
	    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
	    95,  196,   97,   98,   85,  152,  101,   47,   48,   97,
	    85,   92,  207,  193,   54,   55,   56,   92,   49,  175,
	    55,   56,  221,  222,  223,   12,   66,  108,  109,  110,
	   137,  163,  139,  108,  109,  110,   26,  132,  133,  134,
	   135,  136,  152,   83,   43,   44,   45,   46,   47,   48,
	    49,   50,   51,   52,   53,   95,   26,   97,   98,   55,
	    56,  101,   97,   98,  196,  221,  222,  223,  146,  147,
	    57,  171,  152,   22,   26,   19,   20,   49,   22,  179,
	   108,  109,  110,   55,   56,  116,   73,  219,   75,  124,
	   121,  152,  132,  133,  134,  135,  136,  163,   85,  152,
	   232,   97,   98,   47,   48,  237,   55,   56,   98,    5,
	    54,   55,   56,  193,   10,   11,   12,   13,   14,  172,
	   173,   17,   66,   47,   48,   97,   98,  152,  124,  152,
	   196,   55,   56,  186,  124,  152,  106,  160,  152,   83,
	   152,  164,  152,   61,   22,  211,  212,  152,   97,   98,
	   152,   95,   70,   97,   98,  172,  173,  101,  172,  173,
	   172,  173,  172,  173,   60,  181,   62,  172,  173,   47,
	    48,  123,  186,   97,   98,   71,  100,   55,   56,  152,
	   181,  186,   21,  107,  152,  109,   82,  163,  132,  133,
	   134,  135,  136,   89,   16,  207,   92,   93,   19,  172,
	   173,  169,  170,  195,   55,   56,   12,  152,  132,   30,
	   134,   47,   48,  186,  206,  225,  152,   95,  114,   97,
	   196,  245,  246,  101,  152,   38,   39,   40,   41,   42,
	    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
	    53,  152,  163,  219,  152,  141,   97,   98,  193,  152,
	   152,   57,   91,  164,  132,  133,  134,  152,   55,  152,
	   152,  237,  230,  152,  103,  193,   88,   73,   90,   75,
	   172,  173,  183,  152,  185,  196,  152,  172,  173,  172,
	   173,  217,  152,  172,  173,  152,  107,   22,  152,   24,
	   193,  112,  152,  172,  173,  152,  132,  242,  134,  152,
	    97,  140,  152,   92,  152,  172,  173,  152,  172,  173,
	   152,  100,  172,  173,  152,  172,  173,  152,  140,  172,
	   173,  152,  172,  173,  172,  173,  152,  172,  173,  152,
	   172,  173,  152,  152,  172,  173,  152,  172,  173,  213,
	   152,  172,  173,  152,  152,  152,  172,  173,  152,  172,
	   173,  152,  172,  173,  152,  210,  172,  173,  152,   26,
	   172,  173,  152,  172,  173,  172,  173,  152,  172,  173,
	   152,  172,  173,  152,  172,  173,  152,   59,  172,  173,
	   152,   63,  172,  173,  152,  193,  152,  152,  152,  152,
	   172,  173,  152,  172,  173,   77,  172,  173,  152,  152,
	   172,  173,  152,  152,  172,  173,  172,  173,  172,  173,
	   152,   22,  172,  173,  152,  152,  152,   22,  172,  173,
	   152,  152,  152,  172,  173,  152,    7,    8,    9,  163,
	   172,  173,   22,   23,  172,  173,  172,  173,  166,  167,
	   172,  173,  172,  173,   55,  172,  173,   22,   23,  108,
	   109,  110,  217,  152,  217,  166,  167,  163,  163,  163,
	   163,  163,  196,  130,  217,  211,  212,  217,  116,   23,
	    22,  101,   26,  121,   23,   23,   23,   26,   26,   26,
	    23,   23,  112,   26,   26,   37,   97,  100,  101,   55,
	   196,  196,  196,  196,  196,   23,   23,   55,   26,   26,
	     7,    8,   23,  152,   23,   26,   96,   26,  132,  132,
	   134,  134,   23,  152,  152,   26,  152,  122,  152,  191,
	   152,   96,  234,  152,  152,  152,  152,  152,  197,  210,
	   152,   97,  152,  152,  210,  233,  210,  198,  150,   97,
	   184,  201,  239,  214,  214,  201,  239,  180,  214,  227,
	   200,  198,  155,   67,  243,  176,   69,  175,  175,  175,
	   122,  159,  159,  240,  159,  240,   22,  220,   27,  130,
	   201,   18,  159,   18,  189,  158,  158,  220,  192,  159,
	   137,  236,  192,  192,  192,  189,   74,  189,  159,  235,
	   159,  158,   22,  177,  201,  201,  159,  107,  158,  177,
	   159,  174,  158,   76,  174,  182,  174,  106,  182,  125,
	   174,  107,  177,   22,  159,  216,  215,  137,  159,   53,
	   216,  176,  215,  174,  174,  216,  215,  215,  174,  229,
	   216,  129,  224,  177,  126,  229,  127,  177,  128,   25,
	   162,  226,   26,  161,   13,  153,    6,  153,  151,  151,
	   151,  151,  205,  165,  178,  178,  165,    4,    3,   22,
	   165,  142,   15,   94,  202,  204,  203,  201,   16,   23,
	   249,   23,  120,  249,  246,  111,  131,  123,   20,   16,
	     1,  125,  123,  111,   56,   64,   37,   37,  131,  122,
	     1,   37,    5,   37,   22,  107,   26,   80,  140,   80,
	    87,   72,  107,   20,   24,   19,  112,  105,   23,   79,
	    22,   79,   22,   22,   22,   58,   22,   79,   23,   68,
	    23,   23,   26,  116,   22,   26,   23,   22,  122,   23,
	    23,   56,   64,   22,  124,   26,   26,   64,   64,   23,
	    23,   23,   23,   11,   23,   22,   26,   23,   22,   24,
	     1,   23,   22,   26,  251,   24,   23,   22,  122,   23,
	    23,   22,   15,  122,  122,  122,   23,
};
#define YY_SHIFT_USE_DFLT (1567)
#define YY_SHIFT_COUNT    (455)
#define YY_SHIFT_MIN      (-94)
#define YY_SHIFT_MAX      (1549)
static const short yy_shift_ofst[] = {
	    40,  599,  904,  612,  760,  760,  760,  760,  725,  -19,
	    16,   16,  100,  760,  760,  760,  760,  760,  760,  760,
	   876,  876,  573,  542,  719,  600,   61,  137,  172,  207,
	   242,  277,  312,  347,  382,  417,  459,  459,  459,  459,
	   459,  459,  459,  459,  459,  459,  459,  459,  459,  459,
	   459,  459,  459,  494,  459,  529,  564,  564,  705,  760,
	   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
	   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
	   760,  760,  760,  760,  760,  760,  760,  760,  760,  760,
	   856,  760,  760,  760,  760,  760,  760,  760,  760,  760,
	   760,  760,  760,  760,  987,  746,  746,  746,  746,  746,
	   801,   23,   32,  949,  961,  979,  964,  964,  949,   73,
	   113,  -51, 1567, 1567, 1567,  536,  536,  536,   99,   99,
	   813,  813,  667,  205,  240,  949,  949,  949,  949,  949,
	   949,  949,  949,  949,  949,  949,  949,  949,  949,  949,
	   949,  949,  949,  949,  949,  332, 1011,  422,  422,  113,
	    30,   30,   30,   30,   30,   30, 1567, 1567, 1567,  922,
	   -94,  -94,  384,  613,  828,  420,  765,  804,  851,  949,
	   949,  949,  949,  949,  949,  949,  949,  949,  949,  949,
	   949,  949,  949,  949,  949,  672,  672,  672,  949,  949,
	   657,  949,  949,  949,  -18,  949,  949,  994,  949,  949,
	   949,  949,  949,  949,  949,  949,  949,  949,  772, 1118,
	   712,  712,  712,  810,   45,  769, 1219, 1133,  418,  418,
	   569, 1133,  569,  830,  607,  663,  882,  418,  693,  882,
	   882,  848, 1152, 1065, 1286, 1238, 1238, 1287, 1287, 1238,
	  1344, 1341, 1239, 1353, 1353, 1353, 1353, 1238, 1355, 1239,
	  1344, 1341, 1341, 1239, 1238, 1355, 1243, 1312, 1238, 1238,
	  1355, 1370, 1238, 1355, 1238, 1355, 1370, 1290, 1290, 1290,
	  1327, 1370, 1290, 1301, 1290, 1327, 1290, 1290, 1284, 1304,
	  1284, 1304, 1284, 1304, 1284, 1304, 1238, 1391, 1238, 1280,
	  1370, 1366, 1366, 1370, 1302, 1308, 1310, 1309, 1239, 1414,
	  1416, 1431, 1431, 1440, 1440, 1440, 1440, 1567, 1567, 1567,
	  1567, 1567, 1567, 1567, 1567,  519,  978, 1210, 1225,  104,
	  1141, 1189, 1246, 1248, 1251, 1252, 1253, 1257, 1258, 1273,
	  1003, 1187, 1293, 1170, 1272, 1279, 1234, 1281, 1176, 1177,
	  1289, 1242, 1195, 1453, 1455, 1437, 1319, 1447, 1369, 1452,
	  1446, 1448, 1352, 1345, 1364, 1354, 1458, 1356, 1463, 1479,
	  1359, 1357, 1449, 1450, 1454, 1456, 1372, 1428, 1421, 1367,
	  1489, 1487, 1472, 1388, 1358, 1417, 1470, 1419, 1413, 1429,
	  1395, 1480, 1483, 1486, 1394, 1402, 1488, 1430, 1490, 1491,
	  1485, 1492, 1432, 1457, 1494, 1438, 1451, 1495, 1497, 1498,
	  1496, 1407, 1502, 1503, 1505, 1499, 1406, 1506, 1507, 1475,
	  1468, 1511, 1410, 1509, 1473, 1510, 1474, 1516, 1509, 1517,
	  1518, 1519, 1520, 1521, 1523, 1532, 1524, 1526, 1525, 1527,
	  1528, 1530, 1531, 1527, 1533, 1535, 1536, 1537, 1539, 1436,
	  1441, 1442, 1443, 1543, 1547, 1549,
};
#define YY_REDUCE_USE_DFLT (-130)
#define YY_REDUCE_COUNT (324)
#define YY_REDUCE_MIN   (-129)
#define YY_REDUCE_MAX   (1300)
static const short yy_reduce_ofst[] = {
	   -29,  566,  525,  605,  -49,  307,  491,  533,  668,  435,
	   601,  644,  148,  747,  786,  795,  419,  788,  827,  790,
	   454,  832,  889,  495,  824,  734,   76,   76,   76,   76,
	    76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
	    76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
	    76,   76,   76,   76,   76,   76,   76,   76,  783,  898,
	   905,  907,  911,  921,  933,  936,  940,  943,  947,  950,
	   952,  955,  958,  962,  965,  969,  974,  977,  980,  984,
	   988,  991,  993,  996,  999, 1002, 1006, 1010, 1018, 1021,
	  1024, 1028, 1032, 1034, 1036, 1040, 1046, 1051, 1058, 1062,
	  1064, 1068, 1070, 1073,   76,   76,   76,   76,   76,   76,
	    76,   76,   76,  855,   36,  523,  235,  416,  777,   76,
	   278,   76,   76,   76,   76,  700,  700,  700,  150,  220,
	   147,  217,  221,  306,  306,  611,    5,  535,  556,  620,
	   720,  872,  897,  116,  864,  349, 1035, 1037,  404, 1047,
	   992, -129, 1050,  492,   62,  722,  879, 1072, 1089,  808,
	  1066, 1094, 1095, 1096, 1097, 1098,  776, 1054,  557,   57,
	   112,  131,  167,  182,  250,  272,  291,  331,  364,  438,
	   497,  517,  591,  653,  690,  739,  775,  798,  892,  908,
	   924,  930, 1015, 1063, 1069,  355,  784,  799,  981, 1101,
	   926, 1151, 1161, 1162,  945, 1164, 1166, 1128, 1168, 1171,
	  1172,  250, 1173, 1174, 1175, 1178, 1180, 1181, 1088, 1102,
	  1119, 1124, 1126,  926, 1131, 1139, 1188, 1140, 1129, 1130,
	  1103, 1144, 1107, 1179, 1156, 1167, 1182, 1134, 1122, 1183,
	  1184, 1150, 1153, 1197, 1111, 1202, 1203, 1123, 1125, 1205,
	  1147, 1185, 1169, 1186, 1190, 1191, 1192, 1213, 1217, 1193,
	  1157, 1196, 1198, 1194, 1220, 1218, 1145, 1154, 1229, 1231,
	  1233, 1216, 1237, 1240, 1241, 1244, 1222, 1227, 1230, 1232,
	  1223, 1235, 1236, 1245, 1249, 1226, 1250, 1254, 1199, 1201,
	  1204, 1207, 1209, 1211, 1214, 1212, 1255, 1208, 1259, 1215,
	  1256, 1200, 1206, 1260, 1247, 1261, 1263, 1262, 1266, 1278,
	  1282, 1292, 1294, 1297, 1298, 1299, 1300, 1221, 1224, 1228,
	  1288, 1291, 1276, 1277, 1295,
};
static const YYACTIONTYPE yy_default[] = {
	  1281, 1271, 1271, 1271, 1203, 1203, 1203, 1203, 1271, 1096,
	  1125, 1125, 1255, 1332, 1332, 1332, 1332, 1332, 1332, 1202,
	  1332, 1332, 1332, 1332, 1271, 1100, 1131, 1332, 1332, 1332,
	  1332, 1204, 1205, 1332, 1332, 1332, 1254, 1256, 1141, 1140,
	  1139, 1138, 1237, 1112, 1136, 1129, 1133, 1204, 1198, 1199,
	  1197, 1201, 1205, 1332, 1132, 1167, 1182, 1166, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1176, 1181, 1188, 1180, 1177, 1169,
	  1168, 1170, 1171, 1332, 1019, 1067, 1332, 1332, 1332, 1172,
	  1332, 1173, 1185, 1184, 1183, 1262, 1289, 1288, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1281, 1271, 1025, 1025, 1332,
	  1271, 1271, 1271, 1271, 1271, 1271, 1267, 1100, 1091, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1259, 1257, 1332, 1218, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1096, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1283, 1332, 1232,
	  1096, 1096, 1096, 1098, 1080, 1090, 1004, 1135, 1114, 1114,
	  1321, 1135, 1321, 1042, 1303, 1039, 1125, 1114, 1200, 1125,
	  1125, 1097, 1090, 1332, 1324, 1105, 1105, 1323, 1323, 1105,
	  1146, 1070, 1135, 1076, 1076, 1076, 1076, 1105, 1016, 1135,
	  1146, 1070, 1070, 1135, 1105, 1016, 1236, 1318, 1105, 1105,
	  1016, 1211, 1105, 1016, 1105, 1016, 1211, 1068, 1068, 1068,
	  1057, 1211, 1068, 1042, 1068, 1057, 1068, 1068, 1118, 1113,
	  1118, 1113, 1118, 1113, 1118, 1113, 1105, 1206, 1105, 1332,
	  1211, 1215, 1215, 1211, 1130, 1119, 1128, 1126, 1135, 1022,
	  1060, 1286, 1286, 1282, 1282, 1282, 1282, 1329, 1329, 1267,
	  1298, 1298, 1044, 1044, 1298, 1332, 1332, 1332, 1332, 1332,
	  1332, 1293, 1332, 1220, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1152, 1332, 1000, 1264, 1332, 1332, 1263, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1320,
	  1332, 1332, 1332, 1332, 1332, 1332, 1235, 1234, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
	  1332, 1082, 1332, 1332, 1332, 1307, 1332, 1332, 1332, 1332,
	  1332, 1332, 1332, 1127, 1332, 1120, 1332, 1332, 1311, 1332,
	  1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1273,
	  1332, 1332, 1332, 1272, 1332, 1332, 1332, 1332, 1332, 1154,
	  1332, 1153, 1157, 1332, 1010, 1332,
};



#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
	0,  
	0,  
	55,  
	55,  
	55,  
	55,  
	0,  
	55,  
	55,  
	55,  
	0,  
	55,  
	55,  
	55,  
	55,  
	0,  
	0,  
	0,  
	55,  
	0,  
	0,  
	55,  
	0,  
	0,  
	0,  
	55,  
	0,  
	0,  
	0,  
	0,  
	55,  
	55,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	0,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
	55,  
};
#endif 


struct yyStackEntry {
	YYACTIONTYPE stateno;  
	YYCODETYPE major;      
	YYMINORTYPE minor;     
};
typedef struct yyStackEntry yyStackEntry;


struct yyParser {
	yyStackEntry *yytos;          
#ifdef YYTRACKMAXSTACKDEPTH
	int yyhwm;                    
#endif
#ifndef YYNOERRORRECOVERY
	int yyerrcnt;                 
#endif
	sqlite3ParserARG_SDECL                
#if YYSTACKDEPTH<=0
		int yystksz;                  
	yyStackEntry *yystack;        
	yyStackEntry yystk0;          
#else
		yyStackEntry yystack[YYSTACKDEPTH];  
#endif
};
typedef struct yyParser yyParser;

#ifndef NDEBUG

static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif 

#ifndef NDEBUG

SQLITE_PRIVATE void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt) {
	yyTraceFILE = TraceFILE;
	yyTracePrompt = zTracePrompt;
	if (yyTraceFILE == 0) yyTracePrompt = 0;
	else if (yyTracePrompt == 0) yyTraceFILE = 0;
}
#endif 

#ifndef NDEBUG

static const char *const yyTokenName[] = {
	"$",             "SEMI",          "EXPLAIN",       "QUERY",
	"PLAN",          "BEGIN",         "TRANSACTION",   "DEFERRED",
	"IMMEDIATE",     "EXCLUSIVE",     "COMMIT",        "END",
	"ROLLBACK",      "SAVEPOINT",     "RELEASE",       "TO",
	"TABLE",         "CREATE",        "IF",            "NOT",
	"EXISTS",        "TEMP",          "LP",            "RP",
	"AS",            "WITHOUT",       "COMMA",         "OR",
	"AND",           "IS",            "MATCH",         "LIKE_KW",
	"BETWEEN",       "IN",            "ISNULL",        "NOTNULL",
	"NE",            "EQ",            "GT",            "LE",
	"LT",            "GE",            "ESCAPE",        "BITAND",
	"BITOR",         "LSHIFT",        "RSHIFT",        "PLUS",
	"MINUS",         "STAR",          "SLASH",         "REM",
	"CONCAT",        "COLLATE",       "BITNOT",        "ID",
	"INDEXED",       "ABORT",         "ACTION",        "AFTER",
	"ANALYZE",       "ASC",           "ATTACH",        "BEFORE",
	"BY",            "CASCADE",       "CAST",          "COLUMNKW",
	"CONFLICT",      "DATABASE",      "DESC",          "DETACH",
	"EACH",          "FAIL",          "FOR",           "IGNORE",
	"INITIALLY",     "INSTEAD",       "NO",            "KEY",
	"OF",            "OFFSET",        "PRAGMA",        "RAISE",
	"RECURSIVE",     "REPLACE",       "RESTRICT",      "ROW",
	"TRIGGER",       "VACUUM",        "VIEW",          "VIRTUAL",
	"WITH",          "REINDEX",       "RENAME",        "CTIME_KW",
	"ANY",           "STRING",        "JOIN_KW",       "CONSTRAINT",
	"DEFAULT",       "NULL",          "PRIMARY",       "UNIQUE",
	"CHECK",         "REFERENCES",    "AUTOINCR",      "ON",
	"INSERT",        "DELETE",        "UPDATE",        "SET",
	"DEFERRABLE",    "FOREIGN",       "DROP",          "UNION",
	"ALL",           "EXCEPT",        "INTERSECT",     "SELECT",
	"VALUES",        "DISTINCT",      "DOT",           "FROM",
	"JOIN",          "USING",         "ORDER",         "GROUP",
	"HAVING",        "LIMIT",         "WHERE",         "INTO",
	"FLOAT",         "BLOB",          "INTEGER",       "VARIABLE",
	"CASE",          "WHEN",          "THEN",          "ELSE",
	"INDEX",         "ALTER",         "ADD",           "error",
	"input",         "cmdlist",       "ecmd",          "explain",
	"cmdx",          "cmd",           "transtype",     "trans_opt",
	"nm",            "savepoint_opt",  "create_table",  "create_table_args",
	"createkw",      "temp",          "ifnotexists",   "dbnm",
	"columnlist",    "conslist_opt",  "table_options",  "select",
	"columnname",    "carglist",      "typetoken",     "typename",
	"signed",        "plus_num",      "minus_num",     "ccons",
	"term",          "expr",          "onconf",        "sortorder",
	"autoinc",       "eidlist_opt",   "refargs",       "defer_subclause",
	"refarg",        "refact",        "init_deferred_pred_opt",  "conslist",
	"tconscomma",    "tcons",         "sortlist",      "eidlist",
	"defer_subclause_opt",  "orconf",        "resolvetype",   "raisetype",
	"ifexists",      "fullname",      "selectnowith",  "oneselect",
	"with",          "multiselect_op",  "distinct",      "selcollist",
	"from",          "where_opt",     "groupby_opt",   "having_opt",
	"orderby_opt",   "limit_opt",     "values",        "nexprlist",
	"exprlist",      "sclp",          "as",            "seltablist",
	"stl_prefix",    "joinop",        "indexed_opt",   "on_opt",
	"using_opt",     "idlist",        "setlist",       "insert_cmd",
	"idlist_opt",    "likeop",        "between_op",    "in_op",
	"paren_exprlist",  "case_operand",  "case_exprlist",  "case_else",
	"uniqueflag",    "collate",       "nmnum",         "trigger_decl",
	"trigger_cmd_list",  "trigger_time",  "trigger_event",  "foreach_clause",
	"when_clause",   "trigger_cmd",   "trnm",          "tridxby",
	"database_kw_opt",  "key_opt",       "add_column_fullname",  "kwcolumn_opt",
	"create_vtab",   "vtabarglist",   "vtabarg",       "vtabargtoken",
	"lp",            "anylist",       "wqlist",
};
#endif 

#ifndef NDEBUG

static const char *const yyRuleName[] = {
	 "explain ::= EXPLAIN",
	 "explain ::= EXPLAIN QUERY PLAN",
	 "cmdx ::= cmd",
	 "cmd ::= BEGIN transtype trans_opt",
	 "transtype ::=",
	 "transtype ::= DEFERRED",
	 "transtype ::= IMMEDIATE",
	 "transtype ::= EXCLUSIVE",
	 "cmd ::= COMMIT trans_opt",
	 "cmd ::= END trans_opt",
	 "cmd ::= ROLLBACK trans_opt",
	 "cmd ::= SAVEPOINT nm",
	 "cmd ::= RELEASE savepoint_opt nm",
	 "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm",
	 "create_table ::= createkw temp TABLE ifnotexists nm dbnm",
	 "createkw ::= CREATE",
	 "ifnotexists ::=",
	 "ifnotexists ::= IF NOT EXISTS",
	 "temp ::= TEMP",
	 "temp ::=",
	 "create_table_args ::= LP columnlist conslist_opt RP table_options",
	 "create_table_args ::= AS select",
	 "table_options ::=",
	 "table_options ::= WITHOUT nm",
	 "columnname ::= nm typetoken",
	 "typetoken ::=",
	 "typetoken ::= typename LP signed RP",
	 "typetoken ::= typename LP signed COMMA signed RP",
	 "typename ::= typename ID|STRING",
	 "ccons ::= CONSTRAINT nm",
	 "ccons ::= DEFAULT term",
	 "ccons ::= DEFAULT LP expr RP",
	 "ccons ::= DEFAULT PLUS term",
	 "ccons ::= DEFAULT MINUS term",
	 "ccons ::= DEFAULT ID|INDEXED",
	 "ccons ::= NOT NULL onconf",
	 "ccons ::= PRIMARY KEY sortorder onconf autoinc",
	 "ccons ::= UNIQUE onconf",
	 "ccons ::= CHECK LP expr RP",
	 "ccons ::= REFERENCES nm eidlist_opt refargs",
	 "ccons ::= defer_subclause",
	 "ccons ::= COLLATE ID|STRING",
	 "autoinc ::=",
	 "autoinc ::= AUTOINCR",
	 "refargs ::=",
	 "refargs ::= refargs refarg",
	 "refarg ::= MATCH nm",
	 "refarg ::= ON INSERT refact",
	 "refarg ::= ON DELETE refact",
	 "refarg ::= ON UPDATE refact",
	 "refact ::= SET NULL",
	 "refact ::= SET DEFAULT",
	 "refact ::= CASCADE",
	 "refact ::= RESTRICT",
	 "refact ::= NO ACTION",
	 "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
	 "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
	 "init_deferred_pred_opt ::=",
	 "init_deferred_pred_opt ::= INITIALLY DEFERRED",
	 "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
	 "conslist_opt ::=",
	 "tconscomma ::= COMMA",
	 "tcons ::= CONSTRAINT nm",
	 "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
	 "tcons ::= UNIQUE LP sortlist RP onconf",
	 "tcons ::= CHECK LP expr RP onconf",
	 "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
	 "defer_subclause_opt ::=",
	 "onconf ::=",
	 "onconf ::= ON CONFLICT resolvetype",
	 "orconf ::=",
	 "orconf ::= OR resolvetype",
	 "resolvetype ::= IGNORE",
	 "resolvetype ::= REPLACE",
	 "cmd ::= DROP TABLE ifexists fullname",
	 "ifexists ::= IF EXISTS",
	 "ifexists ::=",
	 "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
	 "cmd ::= DROP VIEW ifexists fullname",
	 "cmd ::= select",
	 "select ::= with selectnowith",
	 "selectnowith ::= selectnowith multiselect_op oneselect",
	 "multiselect_op ::= UNION",
	 "multiselect_op ::= UNION ALL",
	 "multiselect_op ::= EXCEPT|INTERSECT",
	 "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",
	 "values ::= VALUES LP nexprlist RP",
	 "values ::= values COMMA LP exprlist RP",
	 "distinct ::= DISTINCT",
	 "distinct ::= ALL",
	 "distinct ::=",
	 "sclp ::=",
	 "selcollist ::= sclp expr as",
	 "selcollist ::= sclp STAR",
	 "selcollist ::= sclp nm DOT STAR",
	 "as ::= AS nm",
	 "as ::=",
	 "from ::=",
	 "from ::= FROM seltablist",
	 "stl_prefix ::= seltablist joinop",
	 "stl_prefix ::=",
	 "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
	 "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
	 "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
	 "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
	 "dbnm ::=",
	 "dbnm ::= DOT nm",
	 "fullname ::= nm dbnm",
	 "joinop ::= COMMA|JOIN",
	 "joinop ::= JOIN_KW JOIN",
	 "joinop ::= JOIN_KW nm JOIN",
	 "joinop ::= JOIN_KW nm nm JOIN",
	 "on_opt ::= ON expr",
	 "on_opt ::=",
	 "indexed_opt ::=",
	 "indexed_opt ::= INDEXED BY nm",
	 "indexed_opt ::= NOT INDEXED",
	 "using_opt ::= USING LP idlist RP",
	 "using_opt ::=",
	 "orderby_opt ::=",
	 "orderby_opt ::= ORDER BY sortlist",
	 "sortlist ::= sortlist COMMA expr sortorder",
	 "sortlist ::= expr sortorder",
	 "sortorder ::= ASC",
	 "sortorder ::= DESC",
	 "sortorder ::=",
	 "groupby_opt ::=",
	 "groupby_opt ::= GROUP BY nexprlist",
	 "having_opt ::=",
	 "having_opt ::= HAVING expr",
	 "limit_opt ::=",
	 "limit_opt ::= LIMIT expr",
	 "limit_opt ::= LIMIT expr OFFSET expr",
	 "limit_opt ::= LIMIT expr COMMA expr",
	 "cmd ::= with DELETE FROM fullname indexed_opt where_opt",
	 "where_opt ::=",
	 "where_opt ::= WHERE expr",
	 "cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt",
	 "setlist ::= setlist COMMA nm EQ expr",
	 "setlist ::= setlist COMMA LP idlist RP EQ expr",
	 "setlist ::= nm EQ expr",
	 "setlist ::= LP idlist RP EQ expr",
	 "cmd ::= with insert_cmd INTO fullname idlist_opt select",
	 "cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES",
	 "insert_cmd ::= INSERT orconf",
	 "insert_cmd ::= REPLACE",
	 "idlist_opt ::=",
	 "idlist_opt ::= LP idlist RP",
	 "idlist ::= idlist COMMA nm",
	 "idlist ::= nm",
	 "expr ::= LP expr RP",
	 "term ::= NULL",
	 "expr ::= ID|INDEXED",
	 "expr ::= JOIN_KW",
	 "expr ::= nm DOT nm",
	 "expr ::= nm DOT nm DOT nm",
	 "term ::= FLOAT|BLOB",
	 "term ::= STRING",
	 "term ::= INTEGER",
	 "expr ::= VARIABLE",
	 "expr ::= expr COLLATE ID|STRING",
	 "expr ::= CAST LP expr AS typetoken RP",
	 "expr ::= ID|INDEXED LP distinct exprlist RP",
	 "expr ::= ID|INDEXED LP STAR RP",
	 "term ::= CTIME_KW",
	 "expr ::= LP nexprlist COMMA expr RP",
	 "expr ::= expr AND expr",
	 "expr ::= expr OR expr",
	 "expr ::= expr LT|GT|GE|LE expr",
	 "expr ::= expr EQ|NE expr",
	 "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
	 "expr ::= expr PLUS|MINUS expr",
	 "expr ::= expr STAR|SLASH|REM expr",
	 "expr ::= expr CONCAT expr",
	 "likeop ::= LIKE_KW|MATCH",
	 "likeop ::= NOT LIKE_KW|MATCH",
	 "expr ::= expr likeop expr",
	 "expr ::= expr likeop expr ESCAPE expr",
	 "expr ::= expr ISNULL|NOTNULL",
	 "expr ::= expr NOT NULL",
	 "expr ::= expr IS expr",
	 "expr ::= expr IS NOT expr",
	 "expr ::= NOT expr",
	 "expr ::= BITNOT expr",
	 "expr ::= MINUS expr",
	 "expr ::= PLUS expr",
	 "between_op ::= BETWEEN",
	 "between_op ::= NOT BETWEEN",
	 "expr ::= expr between_op expr AND expr",
	 "in_op ::= IN",
	 "in_op ::= NOT IN",
	 "expr ::= expr in_op LP exprlist RP",
	 "expr ::= LP select RP",
	 "expr ::= expr in_op LP select RP",
	 "expr ::= expr in_op nm dbnm paren_exprlist",
	 "expr ::= EXISTS LP select RP",
	 "expr ::= CASE case_operand case_exprlist case_else END",
	 "case_exprlist ::= case_exprlist WHEN expr THEN expr",
	 "case_exprlist ::= WHEN expr THEN expr",
	 "case_else ::= ELSE expr",
	 "case_else ::=",
	 "case_operand ::= expr",
	 "case_operand ::=",
	 "exprlist ::=",
	 "nexprlist ::= nexprlist COMMA expr",
	 "nexprlist ::= expr",
	 "paren_exprlist ::=",
	 "paren_exprlist ::= LP exprlist RP",
	 "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
	 "uniqueflag ::= UNIQUE",
	 "uniqueflag ::=",
	 "eidlist_opt ::=",
	 "eidlist_opt ::= LP eidlist RP",
	 "eidlist ::= eidlist COMMA nm collate sortorder",
	 "eidlist ::= nm collate sortorder",
	 "collate ::=",
	 "collate ::= COLLATE ID|STRING",
	 "cmd ::= DROP INDEX ifexists fullname",
	 "cmd ::= VACUUM",
	 "cmd ::= VACUUM nm",
	 "cmd ::= PRAGMA nm dbnm",
	 "cmd ::= PRAGMA nm dbnm EQ nmnum",
	 "cmd ::= PRAGMA nm dbnm LP nmnum RP",
	 "cmd ::= PRAGMA nm dbnm EQ minus_num",
	 "cmd ::= PRAGMA nm dbnm LP minus_num RP",
	 "plus_num ::= PLUS INTEGER|FLOAT",
	 "minus_num ::= MINUS INTEGER|FLOAT",
	 "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
	 "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
	 "trigger_time ::= BEFORE",
	 "trigger_time ::= AFTER",
	 "trigger_time ::= INSTEAD OF",
	 "trigger_time ::=",
	 "trigger_event ::= DELETE|INSERT",
	 "trigger_event ::= UPDATE",
	 "trigger_event ::= UPDATE OF idlist",
	 "when_clause ::=",
	 "when_clause ::= WHEN expr",
	 "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
	 "trigger_cmd_list ::= trigger_cmd SEMI",
	 "trnm ::= nm DOT nm",
	 "tridxby ::= INDEXED BY nm",
	 "tridxby ::= NOT INDEXED",
	 "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt",
	 "trigger_cmd ::= insert_cmd INTO trnm idlist_opt select",
	 "trigger_cmd ::= DELETE FROM trnm tridxby where_opt",
	 "trigger_cmd ::= select",
	 "expr ::= RAISE LP IGNORE RP",
	 "expr ::= RAISE LP raisetype COMMA nm RP",
	 "raisetype ::= ROLLBACK",
	 "raisetype ::= ABORT",
	 "raisetype ::= FAIL",
	 "cmd ::= DROP TRIGGER ifexists fullname",
	 "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
	 "cmd ::= DETACH database_kw_opt expr",
	 "key_opt ::=",
	 "key_opt ::= KEY expr",
	 "cmd ::= REINDEX",
	 "cmd ::= REINDEX nm dbnm",
	 "cmd ::= ANALYZE",
	 "cmd ::= ANALYZE nm dbnm",
	 "cmd ::= ALTER TABLE fullname RENAME TO nm",
	 "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",
	 "add_column_fullname ::= fullname",
	 "cmd ::= create_vtab",
	 "cmd ::= create_vtab LP vtabarglist RP",
	 "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
	 "vtabarg ::=",
	 "vtabargtoken ::= ANY",
	 "vtabargtoken ::= lp anylist RP",
	 "lp ::= LP",
	 "with ::=",
	 "with ::= WITH wqlist",
	 "with ::= WITH RECURSIVE wqlist",
	 "wqlist ::= nm eidlist_opt AS LP select RP",
	 "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
	 "input ::= cmdlist",
	 "cmdlist ::= cmdlist ecmd",
	 "cmdlist ::= ecmd",
	 "ecmd ::= SEMI",
	 "ecmd ::= explain cmdx SEMI",
	 "explain ::=",
	 "trans_opt ::=",
	 "trans_opt ::= TRANSACTION",
	 "trans_opt ::= TRANSACTION nm",
	 "savepoint_opt ::= SAVEPOINT",
	 "savepoint_opt ::=",
	 "cmd ::= create_table create_table_args",
	 "columnlist ::= columnlist COMMA columnname carglist",
	 "columnlist ::= columnname carglist",
	 "nm ::= ID|INDEXED",
	 "nm ::= STRING",
	 "nm ::= JOIN_KW",
	 "typetoken ::= typename",
	 "typename ::= ID|STRING",
	 "signed ::= plus_num",
	 "signed ::= minus_num",
	 "carglist ::= carglist ccons",
	 "carglist ::=",
	 "ccons ::= NULL onconf",
	 "conslist_opt ::= COMMA conslist",
	 "conslist ::= conslist tconscomma tcons",
	 "conslist ::= tcons",
	 "tconscomma ::=",
	 "defer_subclause_opt ::= defer_subclause",
	 "resolvetype ::= raisetype",
	 "selectnowith ::= oneselect",
	 "oneselect ::= values",
	 "sclp ::= selcollist COMMA",
	 "as ::= ID|STRING",
	 "expr ::= term",
	 "exprlist ::= nexprlist",
	 "nmnum ::= plus_num",
	 "nmnum ::= nm",
	 "nmnum ::= ON",
	 "nmnum ::= DELETE",
	 "nmnum ::= DEFAULT",
	 "plus_num ::= INTEGER|FLOAT",
	 "foreach_clause ::=",
	 "foreach_clause ::= FOR EACH ROW",
	 "trnm ::= nm",
	 "tridxby ::=",
	 "database_kw_opt ::= DATABASE",
	 "database_kw_opt ::=",
	 "kwcolumn_opt ::=",
	 "kwcolumn_opt ::= COLUMNKW",
	 "vtabarglist ::= vtabarg",
	 "vtabarglist ::= vtabarglist COMMA vtabarg",
	 "vtabarg ::= vtabarg vtabargtoken",
	 "anylist ::=",
	 "anylist ::= anylist LP anylist RP",
	 "anylist ::= anylist ANY",
};
#endif 


#if YYSTACKDEPTH<=0

static int yyGrowStack(yyParser *p) {
	int newSize;
	int idx;
	yyStackEntry *pNew;

	newSize = p->yystksz * 2 + 100;
	idx = p->yytos ? (int)(p->yytos - p->yystack) : 0;
	if (p->yystack == &p->yystk0) {
		pNew = malloc(newSize * sizeof(pNew[0]));
		if (pNew) pNew[0] = p->yystk0;
	}
	else {
		pNew = realloc(p->yystack, newSize * sizeof(pNew[0]));
	}
	if (pNew) {
		p->yystack = pNew;
		p->yytos = &p->yystack[idx];
#ifndef NDEBUG
		if (yyTraceFILE) {
			fprintf(yyTraceFILE, "%sStack grows from %d to %d entries.\n",
				yyTracePrompt, p->yystksz, newSize);
		}
#endif
		p->yystksz = newSize;
	}
	return pNew == 0;
}
#endif


#ifndef YYMALLOCARGTYPE
# define YYMALLOCARGTYPE size_t
#endif


SQLITE_PRIVATE void *sqlite3ParserAlloc(void *(*mallocProc)(YYMALLOCARGTYPE)) {
	yyParser *pParser;
	pParser = (yyParser*)(*mallocProc)((YYMALLOCARGTYPE)sizeof(yyParser));
	if (pParser) {
#ifdef YYTRACKMAXSTACKDEPTH
		pParser->yyhwm = 0;
#endif
#if YYSTACKDEPTH<=0
		pParser->yytos = NULL;
		pParser->yystack = NULL;
		pParser->yystksz = 0;
		if (yyGrowStack(pParser)) {
			pParser->yystack = &pParser->yystk0;
			pParser->yystksz = 1;
		}
#endif
#ifndef YYNOERRORRECOVERY
		pParser->yyerrcnt = -1;
#endif
		pParser->yytos = pParser->yystack;
		pParser->yystack[0].stateno = 0;
		pParser->yystack[0].major = 0;
	}
	return pParser;
}


static void yy_destructor(
	yyParser *yypParser,    
	YYCODETYPE yymajor,     
	YYMINORTYPE *yypminor   
) {
	sqlite3ParserARG_FETCH;
	switch (yymajor) {
		
		
	case 163: 
	case 194: 
	case 195: 
	case 206: 
	{
		sqlite3SelectDelete(pParse->db, (yypminor->yy243));
	}
	break;
	case 172: 
	case 173: 
	{
		sqlite3ExprDelete(pParse->db, (yypminor->yy190).pExpr);
	}
	break;
	case 177: 
	case 186: 
	case 187: 
	case 199: 
	case 202: 
	case 204: 
	case 207: 
	case 208: 
	case 209: 
	case 218: 
	case 224: 
	case 226: 
	{
		sqlite3ExprListDelete(pParse->db, (yypminor->yy148));
	}
	break;
	case 193: 
	case 200: 
	case 211: 
	case 212: 
	{
		sqlite3SrcListDelete(pParse->db, (yypminor->yy185));
	}
	break;
	case 196: 
	case 250: 
	{
		sqlite3WithDelete(pParse->db, (yypminor->yy285));
	}
	break;
	case 201: 
	case 203: 
	case 215: 
	case 225: 
	case 227: 
	case 236: 
	case 241: 
	{
		sqlite3ExprDelete(pParse->db, (yypminor->yy72));
	}
	break;
	case 216: 
	case 217: 
	case 220: 
	{
		sqlite3IdListDelete(pParse->db, (yypminor->yy254));
	}
	break;
	case 232: 
	case 237: 
	{
		sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy145));
	}
	break;
	case 234: 
	{
		sqlite3IdListDelete(pParse->db, (yypminor->yy332).b);
	}
	break;
	
	default:  break;   
	}
}


static void yy_pop_parser_stack(yyParser *pParser) {
	yyStackEntry *yytos;
	assert(pParser->yytos != 0);
	assert(pParser->yytos > pParser->yystack);
	yytos = pParser->yytos--;
#ifndef NDEBUG
	if (yyTraceFILE) {
		fprintf(yyTraceFILE, "%sPopping %s\n",
			yyTracePrompt,
			yyTokenName[yytos->major]);
	}
#endif
	yy_destructor(pParser, yytos->major, &yytos->minor);
}


SQLITE_PRIVATE void sqlite3ParserFree(
	void *p,                    
	void(*freeProc)(void*)     
) {
	yyParser *pParser = (yyParser*)p;
#ifndef YYPARSEFREENEVERNULL
	if (pParser == 0) return;
#endif
	while (pParser->yytos>pParser->yystack) yy_pop_parser_stack(pParser);
#if YYSTACKDEPTH<=0
	if (pParser->yystack != &pParser->yystk0) free(pParser->yystack);
#endif
	(*freeProc)((void*)pParser);
}


#ifdef YYTRACKMAXSTACKDEPTH
SQLITE_PRIVATE int sqlite3ParserStackPeak(void *p) {
	yyParser *pParser = (yyParser*)p;
	return pParser->yyhwm;
}
#endif


static unsigned int yy_find_shift_action(
	yyParser *pParser,        
	YYCODETYPE iLookAhead     
) {
	int i;
	int stateno = pParser->yytos->stateno;

	if (stateno >= YY_MIN_REDUCE) return stateno;
	assert(stateno <= YY_SHIFT_COUNT);
	do {
		i = yy_shift_ofst[stateno];
		assert(iLookAhead != YYNOCODE);
		i += iLookAhead;
		if (i<0 || i >= YY_ACTTAB_COUNT || yy_lookahead[i] != iLookAhead) {
#ifdef YYFALLBACK
			YYCODETYPE iFallback;            
			if (iLookAhead<sizeof(yyFallback) / sizeof(yyFallback[0])
				&& (iFallback = yyFallback[iLookAhead]) != 0) {
#ifndef NDEBUG
				if (yyTraceFILE) {
					fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
						yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
				}
#endif
				assert(yyFallback[iFallback] == 0); 
				iLookAhead = iFallback;
				continue;
			}
#endif
#ifdef YYWILDCARD
			{
				int j = i - iLookAhead + YYWILDCARD;
				if (
#if YY_SHIFT_MIN+YYWILDCARD<0
					j >= 0 &&
#endif
#if YY_SHIFT_MAX+YYWILDCARD>=YY_ACTTAB_COUNT
					j<YY_ACTTAB_COUNT &&
#endif
					yy_lookahead[j] == YYWILDCARD && iLookAhead>0
					) {
#ifndef NDEBUG
					if (yyTraceFILE) {
						fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
							yyTracePrompt, yyTokenName[iLookAhead],
							yyTokenName[YYWILDCARD]);
					}
#endif 
					return yy_action[j];
				}
			}
#endif 
			return yy_default[stateno];
		}
		else {
			return yy_action[i];
		}
	} while (1);
}


static int yy_find_reduce_action(
	int stateno,              
	YYCODETYPE iLookAhead     
) {
	int i;
#ifdef YYERRORSYMBOL
	if (stateno>YY_REDUCE_COUNT) {
		return yy_default[stateno];
	}
#else
	assert(stateno <= YY_REDUCE_COUNT);
#endif
	i = yy_reduce_ofst[stateno];
	assert(i != YY_REDUCE_USE_DFLT);
	assert(iLookAhead != YYNOCODE);
	i += iLookAhead;
#ifdef YYERRORSYMBOL
	if (i<0 || i >= YY_ACTTAB_COUNT || yy_lookahead[i] != iLookAhead) {
		return yy_default[stateno];
	}
#else
	assert(i >= 0 && i<YY_ACTTAB_COUNT);
	assert(yy_lookahead[i] == iLookAhead);
#endif
	return yy_action[i];
}


static void yyStackOverflow(yyParser *yypParser) {
	sqlite3ParserARG_FETCH;
	yypParser->yytos--;
#ifndef NDEBUG
	if (yyTraceFILE) {
		fprintf(yyTraceFILE, "%sStack Overflow!\n", yyTracePrompt);
	}
#endif
	while (yypParser->yytos>yypParser->yystack) yy_pop_parser_stack(yypParser);
	
	

	sqlite3ErrorMsg(pParse, "parser stack overflow");
	
	sqlite3ParserARG_STORE; 
}


#ifndef NDEBUG
static void yyTraceShift(yyParser *yypParser, int yyNewState) {
	if (yyTraceFILE) {
		if (yyNewState<YYNSTATE) {
			fprintf(yyTraceFILE, "%sShift '%s', go to state %d\n",
				yyTracePrompt, yyTokenName[yypParser->yytos->major],
				yyNewState);
		}
		else {
			fprintf(yyTraceFILE, "%sShift '%s'\n",
				yyTracePrompt, yyTokenName[yypParser->yytos->major]);
		}
	}
}
#else
# define yyTraceShift(X,Y)
#endif


static void yy_shift(
	yyParser *yypParser,          
	int yyNewState,               
	int yyMajor,                  
	sqlite3ParserTOKENTYPE yyMinor        
) {
	yyStackEntry *yytos;
	yypParser->yytos++;
#ifdef YYTRACKMAXSTACKDEPTH
	if ((int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm) {
		yypParser->yyhwm++;
		assert(yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack));
	}
#endif
#if YYSTACKDEPTH>0 
	if (yypParser->yytos >= &yypParser->yystack[YYSTACKDEPTH]) {
		yyStackOverflow(yypParser);
		return;
	}
#else
	if (yypParser->yytos >= &yypParser->yystack[yypParser->yystksz]) {
		if (yyGrowStack(yypParser)) {
			yyStackOverflow(yypParser);
			return;
		}
	}
#endif
	if (yyNewState > YY_MAX_SHIFT) {
		yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
	}
	yytos = yypParser->yytos;
	yytos->stateno = (YYACTIONTYPE)yyNewState;
	yytos->major = (YYCODETYPE)yyMajor;
	yytos->minor.yy0 = yyMinor;
	yyTraceShift(yypParser, yyNewState);
}


static const struct {
	YYCODETYPE lhs;         
	unsigned char nrhs;     
} yyRuleInfo[] = {
	{ 147, 1 },
	{ 147, 3 },
	{ 148, 1 },
	{ 149, 3 },
	{ 150, 0 },
	{ 150, 1 },
	{ 150, 1 },
	{ 150, 1 },
	{ 149, 2 },
	{ 149, 2 },
	{ 149, 2 },
	{ 149, 2 },
	{ 149, 3 },
	{ 149, 5 },
	{ 154, 6 },
	{ 156, 1 },
	{ 158, 0 },
	{ 158, 3 },
	{ 157, 1 },
	{ 157, 0 },
	{ 155, 5 },
	{ 155, 2 },
	{ 162, 0 },
	{ 162, 2 },
	{ 164, 2 },
	{ 166, 0 },
	{ 166, 4 },
	{ 166, 6 },
	{ 167, 2 },
	{ 171, 2 },
	{ 171, 2 },
	{ 171, 4 },
	{ 171, 3 },
	{ 171, 3 },
	{ 171, 2 },
	{ 171, 3 },
	{ 171, 5 },
	{ 171, 2 },
	{ 171, 4 },
	{ 171, 4 },
	{ 171, 1 },
	{ 171, 2 },
	{ 176, 0 },
	{ 176, 1 },
	{ 178, 0 },
	{ 178, 2 },
	{ 180, 2 },
	{ 180, 3 },
	{ 180, 3 },
	{ 180, 3 },
	{ 181, 2 },
	{ 181, 2 },
	{ 181, 1 },
	{ 181, 1 },
	{ 181, 2 },
	{ 179, 3 },
	{ 179, 2 },
	{ 182, 0 },
	{ 182, 2 },
	{ 182, 2 },
	{ 161, 0 },
	{ 184, 1 },
	{ 185, 2 },
	{ 185, 7 },
	{ 185, 5 },
	{ 185, 5 },
	{ 185, 10 },
	{ 188, 0 },
	{ 174, 0 },
	{ 174, 3 },
	{ 189, 0 },
	{ 189, 2 },
	{ 190, 1 },
	{ 190, 1 },
	{ 149, 4 },
	{ 192, 2 },
	{ 192, 0 },
	{ 149, 9 },
	{ 149, 4 },
	{ 149, 1 },
	{ 163, 2 },
	{ 194, 3 },
	{ 197, 1 },
	{ 197, 2 },
	{ 197, 1 },
	{ 195, 9 },
	{ 206, 4 },
	{ 206, 5 },
	{ 198, 1 },
	{ 198, 1 },
	{ 198, 0 },
	{ 209, 0 },
	{ 199, 3 },
	{ 199, 2 },
	{ 199, 4 },
	{ 210, 2 },
	{ 210, 0 },
	{ 200, 0 },
	{ 200, 2 },
	{ 212, 2 },
	{ 212, 0 },
	{ 211, 7 },
	{ 211, 9 },
	{ 211, 7 },
	{ 211, 7 },
	{ 159, 0 },
	{ 159, 2 },
	{ 193, 2 },
	{ 213, 1 },
	{ 213, 2 },
	{ 213, 3 },
	{ 213, 4 },
	{ 215, 2 },
	{ 215, 0 },
	{ 214, 0 },
	{ 214, 3 },
	{ 214, 2 },
	{ 216, 4 },
	{ 216, 0 },
	{ 204, 0 },
	{ 204, 3 },
	{ 186, 4 },
	{ 186, 2 },
	{ 175, 1 },
	{ 175, 1 },
	{ 175, 0 },
	{ 202, 0 },
	{ 202, 3 },
	{ 203, 0 },
	{ 203, 2 },
	{ 205, 0 },
	{ 205, 2 },
	{ 205, 4 },
	{ 205, 4 },
	{ 149, 6 },
	{ 201, 0 },
	{ 201, 2 },
	{ 149, 8 },
	{ 218, 5 },
	{ 218, 7 },
	{ 218, 3 },
	{ 218, 5 },
	{ 149, 6 },
	{ 149, 7 },
	{ 219, 2 },
	{ 219, 1 },
	{ 220, 0 },
	{ 220, 3 },
	{ 217, 3 },
	{ 217, 1 },
	{ 173, 3 },
	{ 172, 1 },
	{ 173, 1 },
	{ 173, 1 },
	{ 173, 3 },
	{ 173, 5 },
	{ 172, 1 },
	{ 172, 1 },
	{ 172, 1 },
	{ 173, 1 },
	{ 173, 3 },
	{ 173, 6 },
	{ 173, 5 },
	{ 173, 4 },
	{ 172, 1 },
	{ 173, 5 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 3 },
	{ 221, 1 },
	{ 221, 2 },
	{ 173, 3 },
	{ 173, 5 },
	{ 173, 2 },
	{ 173, 3 },
	{ 173, 3 },
	{ 173, 4 },
	{ 173, 2 },
	{ 173, 2 },
	{ 173, 2 },
	{ 173, 2 },
	{ 222, 1 },
	{ 222, 2 },
	{ 173, 5 },
	{ 223, 1 },
	{ 223, 2 },
	{ 173, 5 },
	{ 173, 3 },
	{ 173, 5 },
	{ 173, 5 },
	{ 173, 4 },
	{ 173, 5 },
	{ 226, 5 },
	{ 226, 4 },
	{ 227, 2 },
	{ 227, 0 },
	{ 225, 1 },
	{ 225, 0 },
	{ 208, 0 },
	{ 207, 3 },
	{ 207, 1 },
	{ 224, 0 },
	{ 224, 3 },
	{ 149, 12 },
	{ 228, 1 },
	{ 228, 0 },
	{ 177, 0 },
	{ 177, 3 },
	{ 187, 5 },
	{ 187, 3 },
	{ 229, 0 },
	{ 229, 2 },
	{ 149, 4 },
	{ 149, 1 },
	{ 149, 2 },
	{ 149, 3 },
	{ 149, 5 },
	{ 149, 6 },
	{ 149, 5 },
	{ 149, 6 },
	{ 169, 2 },
	{ 170, 2 },
	{ 149, 5 },
	{ 231, 11 },
	{ 233, 1 },
	{ 233, 1 },
	{ 233, 2 },
	{ 233, 0 },
	{ 234, 1 },
	{ 234, 1 },
	{ 234, 3 },
	{ 236, 0 },
	{ 236, 2 },
	{ 232, 3 },
	{ 232, 2 },
	{ 238, 3 },
	{ 239, 3 },
	{ 239, 2 },
	{ 237, 7 },
	{ 237, 5 },
	{ 237, 5 },
	{ 237, 1 },
	{ 173, 4 },
	{ 173, 6 },
	{ 191, 1 },
	{ 191, 1 },
	{ 191, 1 },
	{ 149, 4 },
	{ 149, 6 },
	{ 149, 3 },
	{ 241, 0 },
	{ 241, 2 },
	{ 149, 1 },
	{ 149, 3 },
	{ 149, 1 },
	{ 149, 3 },
	{ 149, 6 },
	{ 149, 7 },
	{ 242, 1 },
	{ 149, 1 },
	{ 149, 4 },
	{ 244, 8 },
	{ 246, 0 },
	{ 247, 1 },
	{ 247, 3 },
	{ 248, 1 },
	{ 196, 0 },
	{ 196, 2 },
	{ 196, 3 },
	{ 250, 6 },
	{ 250, 8 },
	{ 144, 1 },
	{ 145, 2 },
	{ 145, 1 },
	{ 146, 1 },
	{ 146, 3 },
	{ 147, 0 },
	{ 151, 0 },
	{ 151, 1 },
	{ 151, 2 },
	{ 153, 1 },
	{ 153, 0 },
	{ 149, 2 },
	{ 160, 4 },
	{ 160, 2 },
	{ 152, 1 },
	{ 152, 1 },
	{ 152, 1 },
	{ 166, 1 },
	{ 167, 1 },
	{ 168, 1 },
	{ 168, 1 },
	{ 165, 2 },
	{ 165, 0 },
	{ 171, 2 },
	{ 161, 2 },
	{ 183, 3 },
	{ 183, 1 },
	{ 184, 0 },
	{ 188, 1 },
	{ 190, 1 },
	{ 194, 1 },
	{ 195, 1 },
	{ 209, 2 },
	{ 210, 1 },
	{ 173, 1 },
	{ 208, 1 },
	{ 230, 1 },
	{ 230, 1 },
	{ 230, 1 },
	{ 230, 1 },
	{ 230, 1 },
	{ 169, 1 },
	{ 235, 0 },
	{ 235, 3 },
	{ 238, 1 },
	{ 239, 0 },
	{ 240, 1 },
	{ 240, 0 },
	{ 243, 0 },
	{ 243, 1 },
	{ 245, 1 },
	{ 245, 3 },
	{ 246, 2 },
	{ 249, 0 },
	{ 249, 4 },
	{ 249, 2 },
};

static void yy_accept(yyParser*);  

								   
static void yy_reduce(
	yyParser *yypParser,         
	unsigned int yyruleno        
) {
	int yygoto;                     
	int yyact;                      
	yyStackEntry *yymsp;            
	int yysize;                     
	sqlite3ParserARG_FETCH;
	yymsp = yypParser->yytos;
#ifndef NDEBUG
	if (yyTraceFILE && yyruleno<(int)(sizeof(yyRuleName) / sizeof(yyRuleName[0]))) {
		yysize = yyRuleInfo[yyruleno].nrhs;
		fprintf(yyTraceFILE, "%sReduce [%s], go to state %d.\n", yyTracePrompt,
			yyRuleName[yyruleno], yymsp[-yysize].stateno);
	}
#endif 

	
	if (yyRuleInfo[yyruleno].nrhs == 0) {
#ifdef YYTRACKMAXSTACKDEPTH
		if ((int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm) {
			yypParser->yyhwm++;
			assert(yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack));
		}
#endif
#if YYSTACKDEPTH>0 
		if (yypParser->yytos >= &yypParser->yystack[YYSTACKDEPTH - 1]) {
			yyStackOverflow(yypParser);
			return;
		}
#else
		if (yypParser->yytos >= &yypParser->yystack[yypParser->yystksz - 1]) {
			if (yyGrowStack(yypParser)) {
				yyStackOverflow(yypParser);
				return;
			}
			yymsp = yypParser->yytos;
		}
#endif
	}

	switch (yyruleno) {
		
		
		YYMINORTYPE yylhsminor;
	case 0: 
	{ pParse->explain = 1; }
	break;
	case 1: 
	{ pParse->explain = 2; }
	break;
	case 2: 
	{ sqlite3FinishCoding(pParse); }
	break;
	case 3: 
	{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy194); }
	break;
	case 4: 
	{yymsp[1].minor.yy194 = TK_DEFERRED; }
	break;
	case 5: 
	case 6:  yytestcase(yyruleno == 6);
	case 7:  yytestcase(yyruleno == 7);
	{yymsp[0].minor.yy194 = yymsp[0].major; }
	break;
	case 8: 
	case 9:  yytestcase(yyruleno == 9);
	{sqlite3CommitTransaction(pParse); }
	break;
	case 10: 
	{sqlite3RollbackTransaction(pParse); }
	break;
	case 11: 
	{
		sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &yymsp[0].minor.yy0);
	}
	break;
	case 12: 
	{
		sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &yymsp[0].minor.yy0);
	}
	break;
	case 13: 
	{
		sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0);
	}
	break;
	case 14: 
	{
		sqlite3StartTable(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy194, 0, 0, yymsp[-2].minor.yy194);
	}
	break;
	case 15: 
	{disableLookaside(pParse); }
	break;
	case 16: 
	case 19:  yytestcase(yyruleno == 19);
	case 22:  yytestcase(yyruleno == 22);
	case 42:  yytestcase(yyruleno == 42);
	case 57:  yytestcase(yyruleno == 57);
	case 67:  yytestcase(yyruleno == 67);
	case 76:  yytestcase(yyruleno == 76);
	case 90:  yytestcase(yyruleno == 90);
	case 215:  yytestcase(yyruleno == 215);
	{yymsp[1].minor.yy194 = 0; }
	break;
	case 17: 
	{yymsp[-2].minor.yy194 = 1; }
	break;
	case 18: 
	case 43:  yytestcase(yyruleno == 43);
	{yymsp[0].minor.yy194 = 1; }
	break;
	case 20: 
	{
		sqlite3EndTable(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, yymsp[0].minor.yy194, 0);
	}
	break;
	case 21: 
	{
		sqlite3EndTable(pParse, 0, 0, 0, yymsp[0].minor.yy243);
		sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy243);
	}
	break;
	case 23: 
	{
		if (yymsp[0].minor.yy0.n == 5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z, "rowid", 5) == 0) {
			yymsp[-1].minor.yy194 = TF_WithoutRowid | TF_NoVisibleRowid;
		}
		else {
			yymsp[-1].minor.yy194 = 0;
			sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);
		}
	}
	break;
	case 24: 
	{sqlite3AddColumn(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0); }
	break;
	case 25: 
	case 60:  yytestcase(yyruleno == 60);
	case 96:  yytestcase(yyruleno == 96);
	{yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0; }
	break;
	case 26: 
	{
		yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
	}
	break;
	case 27: 
	{
		yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);
	}
	break;
	case 28: 
	{yymsp[-1].minor.yy0.n = yymsp[0].minor.yy0.n + (int)(yymsp[0].minor.yy0.z - yymsp[-1].minor.yy0.z); }
	break;
	case 29: 
	case 62:  yytestcase(yyruleno == 62);
	{pParse->constraintName = yymsp[0].minor.yy0; }
	break;
	case 30: 
	case 32:  yytestcase(yyruleno == 32);
	{sqlite3AddDefaultValue(pParse, &yymsp[0].minor.yy190); }
	break;
	case 31: 
	{sqlite3AddDefaultValue(pParse, &yymsp[-1].minor.yy190); }
	break;
	case 33: 
	{
		ExprSpan v;
		v.pExpr = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy190.pExpr, 0, 0);
		v.zStart = yymsp[-1].minor.yy0.z;
		v.zEnd = yymsp[0].minor.yy190.zEnd;
		sqlite3AddDefaultValue(pParse, &v);
	}
	break;
	case 34: 
	{
		ExprSpan v;
		spanExpr(&v, pParse, TK_STRING, yymsp[0].minor.yy0);
		sqlite3AddDefaultValue(pParse, &v);
	}
	break;
	case 35: 
	{sqlite3AddNotNull(pParse, yymsp[0].minor.yy194); }
	break;
	case 36: 
	{sqlite3AddPrimaryKey(pParse, 0, yymsp[-1].minor.yy194, yymsp[0].minor.yy194, yymsp[-2].minor.yy194); }
	break;
	case 37: 
	{sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy194, 0, 0, 0, 0,
		SQLITE_IDXTYPE_UNIQUE); }
	break;
	case 38: 
	{sqlite3AddCheckConstraint(pParse, yymsp[-1].minor.yy190.pExpr); }
	break;
	case 39: 
	{sqlite3CreateForeignKey(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy148, yymsp[0].minor.yy194); }
	break;
	case 40: 
	{sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy194); }
	break;
	case 41: 
	{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0); }
	break;
	case 44: 
	{ yymsp[1].minor.yy194 = OE_None * 0x0101; }
	break;
	case 45: 
	{ yymsp[-1].minor.yy194 = (yymsp[-1].minor.yy194 & ~yymsp[0].minor.yy497.mask) | yymsp[0].minor.yy497.value; }
	break;
	case 46: 
	{ yymsp[-1].minor.yy497.value = 0;     yymsp[-1].minor.yy497.mask = 0x000000; }
	break;
	case 47: 
	{ yymsp[-2].minor.yy497.value = 0;     yymsp[-2].minor.yy497.mask = 0x000000; }
	break;
	case 48: 
	{ yymsp[-2].minor.yy497.value = yymsp[0].minor.yy194;     yymsp[-2].minor.yy497.mask = 0x0000ff; }
	break;
	case 49: 
	{ yymsp[-2].minor.yy497.value = yymsp[0].minor.yy194 << 8;  yymsp[-2].minor.yy497.mask = 0x00ff00; }
	break;
	case 50: 
	{ yymsp[-1].minor.yy194 = OE_SetNull;  }
	break;
	case 51: 
	{ yymsp[-1].minor.yy194 = OE_SetDflt;  }
	break;
	case 52: 
	{ yymsp[0].minor.yy194 = OE_Cascade;  }
	break;
	case 53: 
	{ yymsp[0].minor.yy194 = OE_Restrict; }
	break;
	case 54: 
	{ yymsp[-1].minor.yy194 = OE_None;     }
	break;
	case 55: 
	{yymsp[-2].minor.yy194 = 0; }
	break;
	case 56: 
	case 71:  yytestcase(yyruleno == 71);
	case 144:  yytestcase(yyruleno == 144);
	{yymsp[-1].minor.yy194 = yymsp[0].minor.yy194; }
	break;
	case 58: 
	case 75:  yytestcase(yyruleno == 75);
	case 187:  yytestcase(yyruleno == 187);
	case 190:  yytestcase(yyruleno == 190);
	case 216:  yytestcase(yyruleno == 216);
	{yymsp[-1].minor.yy194 = 1; }
	break;
	case 59: 
	{yymsp[-1].minor.yy194 = 0; }
	break;
	case 61: 
	{pParse->constraintName.n = 0; }
	break;
	case 63: 
	{sqlite3AddPrimaryKey(pParse, yymsp[-3].minor.yy148, yymsp[0].minor.yy194, yymsp[-2].minor.yy194, 0); }
	break;
	case 64: 
	{sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[-2].minor.yy148, yymsp[0].minor.yy194, 0, 0, 0, 0,
		SQLITE_IDXTYPE_UNIQUE); }
	break;
	case 65: 
	{sqlite3AddCheckConstraint(pParse, yymsp[-2].minor.yy190.pExpr); }
	break;
	case 66: 
	{
		sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy148, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy148, yymsp[-1].minor.yy194);
		sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy194);
	}
	break;
	case 68: 
	case 70:  yytestcase(yyruleno == 70);
	{yymsp[1].minor.yy194 = OE_Default; }
	break;
	case 69: 
	{yymsp[-2].minor.yy194 = yymsp[0].minor.yy194; }
	break;
	case 72: 
	{yymsp[0].minor.yy194 = OE_Ignore; }
	break;
	case 73: 
	case 145:  yytestcase(yyruleno == 145);
	{yymsp[0].minor.yy194 = OE_Replace; }
	break;
	case 74: 
	{
		sqlite3DropTable(pParse, yymsp[0].minor.yy185, 0, yymsp[-1].minor.yy194);
	}
	break;
	case 77: 
	{
		sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy148, yymsp[0].minor.yy243, yymsp[-7].minor.yy194, yymsp[-5].minor.yy194);
	}
	break;
	case 78: 
	{
		sqlite3DropTable(pParse, yymsp[0].minor.yy185, 1, yymsp[-1].minor.yy194);
	}
	break;
	case 79: 
	{
		SelectDest dest = { SRT_Output, 0, 0, 0, 0, 0 };
		sqlite3Select(pParse, yymsp[0].minor.yy243, &dest);
		sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy243);
	}
	break;
	case 80: 
	{
		Select *p = yymsp[0].minor.yy243;
		if (p) {
			p->pWith = yymsp[-1].minor.yy285;
			parserDoubleLinkSelect(pParse, p);
		}
		else {
			sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy285);
		}
		yymsp[-1].minor.yy243 = p; 
	}
	break;
	case 81: 
	{
		Select *pRhs = yymsp[0].minor.yy243;
		Select *pLhs = yymsp[-2].minor.yy243;
		if (pRhs && pRhs->pPrior) {
			SrcList *pFrom;
			Token x;
			x.n = 0;
			parserDoubleLinkSelect(pParse, pRhs);
			pFrom = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &x, pRhs, 0, 0);
			pRhs = sqlite3SelectNew(pParse, 0, pFrom, 0, 0, 0, 0, 0, 0, 0);
		}
		if (pRhs) {
			pRhs->op = (u8)yymsp[-1].minor.yy194;
			pRhs->pPrior = pLhs;
			if (ALWAYS(pLhs)) pLhs->selFlags &= ~SF_MultiValue;
			pRhs->selFlags &= ~SF_MultiValue;
			if (yymsp[-1].minor.yy194 != TK_ALL) pParse->hasCompound = 1;
		}
		else {
			sqlite3SelectDelete(pParse->db, pLhs);
		}
		yymsp[-2].minor.yy243 = pRhs;
	}
	break;
	case 82: 
	case 84:  yytestcase(yyruleno == 84);
	{yymsp[0].minor.yy194 = yymsp[0].major; }
	break;
	case 83: 
	{yymsp[-1].minor.yy194 = TK_ALL; }
	break;
	case 85: 
	{
#if SELECTTRACE_ENABLED
		Token s = yymsp[-8].minor.yy0; 
#endif
		yymsp[-8].minor.yy243 = sqlite3SelectNew(pParse, yymsp[-6].minor.yy148, yymsp[-5].minor.yy185, yymsp[-4].minor.yy72, yymsp[-3].minor.yy148, yymsp[-2].minor.yy72, yymsp[-1].minor.yy148, yymsp[-7].minor.yy194, yymsp[0].minor.yy354.pLimit, yymsp[0].minor.yy354.pOffset);
#if SELECTTRACE_ENABLED
		
		if (yymsp[-8].minor.yy243 != 0) {
			const char *z = s.z + 6;
			int i;
			sqlite3_snprintf(sizeof(yymsp[-8].minor.yy243->zSelName), yymsp[-8].minor.yy243->zSelName, "#%d",
				++pParse->nSelect);
			while (z[0] == ' ') z++;
			if (z[0] == '/' && z[1] == '*') {
				z += 2;
				while (z[0] == ' ') z++;
				for (i = 0; sqlite3Isalnum(z[i]); i++) {}
				sqlite3_snprintf(sizeof(yymsp[-8].minor.yy243->zSelName), yymsp[-8].minor.yy243->zSelName, "%.*s", i, z);
			}
		}
#endif 
	}
	break;
	case 86: 
	{
		yymsp[-3].minor.yy243 = sqlite3SelectNew(pParse, yymsp[-1].minor.yy148, 0, 0, 0, 0, 0, SF_Values, 0, 0);
	}
	break;
	case 87: 
	{
		Select *pRight, *pLeft = yymsp[-4].minor.yy243;
		pRight = sqlite3SelectNew(pParse, yymsp[-1].minor.yy148, 0, 0, 0, 0, 0, SF_Values | SF_MultiValue, 0, 0);
		if (ALWAYS(pLeft)) pLeft->selFlags &= ~SF_MultiValue;
		if (pRight) {
			pRight->op = TK_ALL;
			pRight->pPrior = pLeft;
			yymsp[-4].minor.yy243 = pRight;
		}
		else {
			yymsp[-4].minor.yy243 = pLeft;
		}
	}
	break;
	case 88: 
	{yymsp[0].minor.yy194 = SF_Distinct; }
	break;
	case 89: 
	{yymsp[0].minor.yy194 = SF_All; }
	break;
	case 91: 
	case 119:  yytestcase(yyruleno == 119);
	case 126:  yytestcase(yyruleno == 126);
	case 203:  yytestcase(yyruleno == 203);
	case 206:  yytestcase(yyruleno == 206);
	case 211:  yytestcase(yyruleno == 211);
	{yymsp[1].minor.yy148 = 0; }
	break;
	case 92: 
	{
		yymsp[-2].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy148, yymsp[-1].minor.yy190.pExpr);
		if (yymsp[0].minor.yy0.n>0) sqlite3ExprListSetName(pParse, yymsp[-2].minor.yy148, &yymsp[0].minor.yy0, 1);
		sqlite3ExprListSetSpan(pParse, yymsp[-2].minor.yy148, &yymsp[-1].minor.yy190);
	}
	break;
	case 93: 
	{
		Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);
		yymsp[-1].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy148, p);
	}
	break;
	case 94: 
	{
		Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0, 0);
		Expr *pLeft = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);
		Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0);
		yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy148, pDot);
	}
	break;
	case 95: 
	case 106:  yytestcase(yyruleno == 106);
	case 225:  yytestcase(yyruleno == 225);
	case 226:  yytestcase(yyruleno == 226);
	{yymsp[-1].minor.yy0 = yymsp[0].minor.yy0; }
	break;
	case 97: 
	{yymsp[1].minor.yy185 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy185)); }
	break;
	case 98: 
	{
		yymsp[-1].minor.yy185 = yymsp[0].minor.yy185;
		sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy185);
	}
	break;
	case 99: 
	{
		if (ALWAYS(yymsp[-1].minor.yy185 && yymsp[-1].minor.yy185->nSrc>0)) yymsp[-1].minor.yy185->a[yymsp[-1].minor.yy185->nSrc - 1].fg.jointype = (u8)yymsp[0].minor.yy194;
	}
	break;
	case 100: 
	{yymsp[1].minor.yy185 = 0; }
	break;
	case 101: 
	{
		yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy185, &yymsp[-5].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, 0, yymsp[-1].minor.yy72, yymsp[0].minor.yy254);
		sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy185, &yymsp[-2].minor.yy0);
	}
	break;
	case 102: 
	{
		yymsp[-8].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-8].minor.yy185, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, &yymsp[-2].minor.yy0, 0, yymsp[-1].minor.yy72, yymsp[0].minor.yy254);
		sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy185, yymsp[-4].minor.yy148);
	}
	break;
	case 103: 
	{
		yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy185, 0, 0, &yymsp[-2].minor.yy0, yymsp[-4].minor.yy243, yymsp[-1].minor.yy72, yymsp[0].minor.yy254);
	}
	break;
	case 104: 
	{
		if (yymsp[-6].minor.yy185 == 0 && yymsp[-2].minor.yy0.n == 0 && yymsp[-1].minor.yy72 == 0 && yymsp[0].minor.yy254 == 0) {
			yymsp[-6].minor.yy185 = yymsp[-4].minor.yy185;
		}
		else if (yymsp[-4].minor.yy185->nSrc == 1) {
			yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy185, 0, 0, &yymsp[-2].minor.yy0, 0, yymsp[-1].minor.yy72, yymsp[0].minor.yy254);
			if (yymsp[-6].minor.yy185) {
				struct SrcList_item *pNew = &yymsp[-6].minor.yy185->a[yymsp[-6].minor.yy185->nSrc - 1];
				struct SrcList_item *pOld = yymsp[-4].minor.yy185->a;
				pNew->zName = pOld->zName;
				pNew->zDatabase = pOld->zDatabase;
				pNew->pSelect = pOld->pSelect;
				pOld->zName = pOld->zDatabase = 0;
				pOld->pSelect = 0;
			}
			sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy185);
		}
		else {
			Select *pSubquery;
			sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy185);
			pSubquery = sqlite3SelectNew(pParse, 0, yymsp[-4].minor.yy185, 0, 0, 0, 0, SF_NestedFrom, 0, 0);
			yymsp[-6].minor.yy185 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy185, 0, 0, &yymsp[-2].minor.yy0, pSubquery, yymsp[-1].minor.yy72, yymsp[0].minor.yy254);
		}
	}
	break;
	case 105: 
	case 114:  yytestcase(yyruleno == 114);
	{yymsp[1].minor.yy0.z = 0; yymsp[1].minor.yy0.n = 0; }
	break;
	case 107: 
	{yymsp[-1].minor.yy185 = sqlite3SrcListAppend(pParse->db, 0, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0); }
	break;
	case 108: 
	{ yymsp[0].minor.yy194 = JT_INNER; }
	break;
	case 109: 
	{yymsp[-1].minor.yy194 = sqlite3JoinType(pParse, &yymsp[-1].minor.yy0, 0, 0);  }
	break;
	case 110: 
	{yymsp[-2].minor.yy194 = sqlite3JoinType(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, 0); }
	break;
	case 111: 
	{yymsp[-3].minor.yy194 = sqlite3JoinType(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);}
	break;
	case 112: 
	case 129:  yytestcase(yyruleno == 129);
	case 136:  yytestcase(yyruleno == 136);
	case 199:  yytestcase(yyruleno == 199);
	{yymsp[-1].minor.yy72 = yymsp[0].minor.yy190.pExpr; }
	break;
	case 113: 
	case 128:  yytestcase(yyruleno == 128);
	case 135:  yytestcase(yyruleno == 135);
	case 200:  yytestcase(yyruleno == 200);
	case 202:  yytestcase(yyruleno == 202);
	{yymsp[1].minor.yy72 = 0; }
	break;
	case 115: 
	{yymsp[-2].minor.yy0 = yymsp[0].minor.yy0; }
	break;
	case 116: 
	{yymsp[-1].minor.yy0.z = 0; yymsp[-1].minor.yy0.n = 1; }
	break;
	case 117: 
	{yymsp[-3].minor.yy254 = yymsp[-1].minor.yy254; }
	break;
	case 118: 
	case 146:  yytestcase(yyruleno == 146);
	{yymsp[1].minor.yy254 = 0; }
	break;
	case 120: 
	case 127:  yytestcase(yyruleno == 127);
	{yymsp[-2].minor.yy148 = yymsp[0].minor.yy148; }
	break;
	case 121: 
	{
		yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy148, yymsp[-1].minor.yy190.pExpr);
		sqlite3ExprListSetSortOrder(yymsp[-3].minor.yy148, yymsp[0].minor.yy194);
	}
	break;
	case 122: 
	{
		yymsp[-1].minor.yy148 = sqlite3ExprListAppend(pParse, 0, yymsp[-1].minor.yy190.pExpr); 
		sqlite3ExprListSetSortOrder(yymsp[-1].minor.yy148, yymsp[0].minor.yy194);
	}
	break;
	case 123: 
	{yymsp[0].minor.yy194 = SQLITE_SO_ASC; }
	break;
	case 124: 
	{yymsp[0].minor.yy194 = SQLITE_SO_DESC; }
	break;
	case 125: 
	{yymsp[1].minor.yy194 = SQLITE_SO_UNDEFINED; }
	break;
	case 130: 
	{yymsp[1].minor.yy354.pLimit = 0; yymsp[1].minor.yy354.pOffset = 0; }
	break;
	case 131: 
	{yymsp[-1].minor.yy354.pLimit = yymsp[0].minor.yy190.pExpr; yymsp[-1].minor.yy354.pOffset = 0; }
	break;
	case 132: 
	{yymsp[-3].minor.yy354.pLimit = yymsp[-2].minor.yy190.pExpr; yymsp[-3].minor.yy354.pOffset = yymsp[0].minor.yy190.pExpr; }
	break;
	case 133: 
	{yymsp[-3].minor.yy354.pOffset = yymsp[-2].minor.yy190.pExpr; yymsp[-3].minor.yy354.pLimit = yymsp[0].minor.yy190.pExpr; }
	break;
	case 134: 
	{
		sqlite3WithPush(pParse, yymsp[-5].minor.yy285, 1);
		sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy185, &yymsp[-1].minor.yy0);
		sqlite3DeleteFrom(pParse, yymsp[-2].minor.yy185, yymsp[0].minor.yy72);
	}
	break;
	case 137: 
	{
		sqlite3WithPush(pParse, yymsp[-7].minor.yy285, 1);
		sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy185, &yymsp[-3].minor.yy0);
		sqlite3ExprListCheckLength(pParse, yymsp[-1].minor.yy148, "set list");
		sqlite3Update(pParse, yymsp[-4].minor.yy185, yymsp[-1].minor.yy148, yymsp[0].minor.yy72, yymsp[-5].minor.yy194);
	}
	break;
	case 138: 
	{
		yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy148, yymsp[0].minor.yy190.pExpr);
		sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy148, &yymsp[-2].minor.yy0, 1);
	}
	break;
	case 139: 
	{
		yymsp[-6].minor.yy148 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy148, yymsp[-3].minor.yy254, yymsp[0].minor.yy190.pExpr);
	}
	break;
	case 140: 
	{
		yylhsminor.yy148 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy190.pExpr);
		sqlite3ExprListSetName(pParse, yylhsminor.yy148, &yymsp[-2].minor.yy0, 1);
	}
	yymsp[-2].minor.yy148 = yylhsminor.yy148;
	break;
	case 141: 
	{
		yymsp[-4].minor.yy148 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy254, yymsp[0].minor.yy190.pExpr);
	}
	break;
	case 142: 
	{
		sqlite3WithPush(pParse, yymsp[-5].minor.yy285, 1);
		sqlite3Insert(pParse, yymsp[-2].minor.yy185, yymsp[0].minor.yy243, yymsp[-1].minor.yy254, yymsp[-4].minor.yy194);
	}
	break;
	case 143: 
	{
		sqlite3WithPush(pParse, yymsp[-6].minor.yy285, 1);
		sqlite3Insert(pParse, yymsp[-3].minor.yy185, 0, yymsp[-2].minor.yy254, yymsp[-5].minor.yy194);
	}
	break;
	case 147: 
	{yymsp[-2].minor.yy254 = yymsp[-1].minor.yy254; }
	break;
	case 148: 
	{yymsp[-2].minor.yy254 = sqlite3IdListAppend(pParse->db, yymsp[-2].minor.yy254, &yymsp[0].minor.yy0); }
	break;
	case 149: 
	{yymsp[0].minor.yy254 = sqlite3IdListAppend(pParse->db, 0, &yymsp[0].minor.yy0); }
	break;
	case 150: 
	{spanSet(&yymsp[-2].minor.yy190, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);   yymsp[-2].minor.yy190.pExpr = yymsp[-1].minor.yy190.pExpr; }
	break;
	case 151: 
	case 156:  yytestcase(yyruleno == 156);
	case 157:  yytestcase(yyruleno == 157);
	{spanExpr(&yymsp[0].minor.yy190, pParse, yymsp[0].major, yymsp[0].minor.yy0);}
	break;
	case 152: 
	case 153:  yytestcase(yyruleno == 153);
	{spanExpr(&yymsp[0].minor.yy190, pParse, TK_ID, yymsp[0].minor.yy0); }
	break;
	case 154: 
	{
		Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
		Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);
		spanSet(&yymsp[-2].minor.yy190, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0); 
		yymsp[-2].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp2, 0);
	}
	break;
	case 155: 
	{
		Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-4].minor.yy0, 1);
		Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
		Expr *temp3 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);
		Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3, 0);
		spanSet(&yymsp[-4].minor.yy190, &yymsp[-4].minor.yy0, &yymsp[0].minor.yy0); 
		yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp4, 0);
	}
	break;
	case 158: 
	{
		yylhsminor.yy190.pExpr = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);
		yylhsminor.yy190.zStart = yymsp[0].minor.yy0.z;
		yylhsminor.yy190.zEnd = yymsp[0].minor.yy0.z + yymsp[0].minor.yy0.n;
		if (yylhsminor.yy190.pExpr) yylhsminor.yy190.pExpr->flags |= EP_Leaf;
	}
	yymsp[0].minor.yy190 = yylhsminor.yy190;
	break;
	case 159: 
	{
		if (!(yymsp[0].minor.yy0.z[0] == '#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1]))) {
			u32 n = yymsp[0].minor.yy0.n;
			spanExpr(&yymsp[0].minor.yy190, pParse, TK_VARIABLE, yymsp[0].minor.yy0);
			sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy190.pExpr, n);
		}
		else {
			
			Token t = yymsp[0].minor.yy0; 
			assert(t.n >= 2);
			spanSet(&yymsp[0].minor.yy190, &t, &t);
			if (pParse->nested == 0) {
				sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &t);
				yymsp[0].minor.yy190.pExpr = 0;
			}
			else {
				yymsp[0].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_REGISTER, 0, 0, 0);
				if (yymsp[0].minor.yy190.pExpr) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy190.pExpr->iTable);
			}
		}
	}
	break;
	case 160: 
	{
		yymsp[-2].minor.yy190.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy190.pExpr, &yymsp[0].minor.yy0, 1);
		yymsp[-2].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
	}
	break;
	case 161: 
	{
		spanSet(&yymsp[-5].minor.yy190, &yymsp[-5].minor.yy0, &yymsp[0].minor.yy0); 
		yymsp[-5].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_CAST, yymsp[-3].minor.yy190.pExpr, 0, &yymsp[-1].minor.yy0);
	}
	break;
	case 162: 
	{
		if (yymsp[-1].minor.yy148 && yymsp[-1].minor.yy148->nExpr>pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG]) {
			sqlite3ErrorMsg(pParse, "too many arguments on function %T", &yymsp[-4].minor.yy0);
		}
		yylhsminor.yy190.pExpr = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy148, &yymsp[-4].minor.yy0);
		spanSet(&yylhsminor.yy190, &yymsp[-4].minor.yy0, &yymsp[0].minor.yy0);
		if (yymsp[-2].minor.yy194 == SF_Distinct && yylhsminor.yy190.pExpr) {
			yylhsminor.yy190.pExpr->flags |= EP_Distinct;
		}
	}
	yymsp[-4].minor.yy190 = yylhsminor.yy190;
	break;
	case 163: 
	{
		yylhsminor.yy190.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0);
		spanSet(&yylhsminor.yy190, &yymsp[-3].minor.yy0, &yymsp[0].minor.yy0);
	}
	yymsp[-3].minor.yy190 = yylhsminor.yy190;
	break;
	case 164: 
	{
		yylhsminor.yy190.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0);
		spanSet(&yylhsminor.yy190, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
	}
	yymsp[0].minor.yy190 = yylhsminor.yy190;
	break;
	case 165: 
	{
		ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy148, yymsp[-1].minor.yy190.pExpr);
		yylhsminor.yy190.pExpr = sqlite3PExpr(pParse, TK_VECTOR, 0, 0, 0);
		if (yylhsminor.yy190.pExpr) {
			yylhsminor.yy190.pExpr->x.pList = pList;
			spanSet(&yylhsminor.yy190, &yymsp[-4].minor.yy0, &yymsp[0].minor.yy0);
		}
		else {
			sqlite3ExprListDelete(pParse->db, pList);
		}
	}
	yymsp[-4].minor.yy190 = yylhsminor.yy190;
	break;
	case 166: 
	case 167:  yytestcase(yyruleno == 167);
	case 168:  yytestcase(yyruleno == 168);
	case 169:  yytestcase(yyruleno == 169);
	case 170:  yytestcase(yyruleno == 170);
	case 171:  yytestcase(yyruleno == 171);
	case 172:  yytestcase(yyruleno == 172);
	case 173:  yytestcase(yyruleno == 173);
	{spanBinaryExpr(pParse, yymsp[-1].major, &yymsp[-2].minor.yy190, &yymsp[0].minor.yy190); }
	break;
	case 174: 
	{yymsp[0].minor.yy0 = yymsp[0].minor.yy0;}
	break;
	case 175: 
	{yymsp[-1].minor.yy0 = yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n |= 0x80000000; }
	break;
	case 176: 
	{
		ExprList *pList;
		int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
		yymsp[-1].minor.yy0.n &= 0x7fffffff;
		pList = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy190.pExpr);
		pList = sqlite3ExprListAppend(pParse, pList, yymsp[-2].minor.yy190.pExpr);
		yymsp[-2].minor.yy190.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0);
		exprNot(pParse, bNot, &yymsp[-2].minor.yy190);
		yymsp[-2].minor.yy190.zEnd = yymsp[0].minor.yy190.zEnd;
		if (yymsp[-2].minor.yy190.pExpr) yymsp[-2].minor.yy190.pExpr->flags |= EP_InfixFunc;
	}
	break;
	case 177: 
	{
		ExprList *pList;
		int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
		yymsp[-3].minor.yy0.n &= 0x7fffffff;
		pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy190.pExpr);
		pList = sqlite3ExprListAppend(pParse, pList, yymsp[-4].minor.yy190.pExpr);
		pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy190.pExpr);
		yymsp[-4].minor.yy190.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0);
		exprNot(pParse, bNot, &yymsp[-4].minor.yy190);
		yymsp[-4].minor.yy190.zEnd = yymsp[0].minor.yy190.zEnd;
		if (yymsp[-4].minor.yy190.pExpr) yymsp[-4].minor.yy190.pExpr->flags |= EP_InfixFunc;
	}
	break;
	case 178: 
	{spanUnaryPostfix(pParse, yymsp[0].major, &yymsp[-1].minor.yy190, &yymsp[0].minor.yy0); }
	break;
	case 179: 
	{spanUnaryPostfix(pParse, TK_NOTNULL, &yymsp[-2].minor.yy190, &yymsp[0].minor.yy0); }
	break;
	case 180: 
	{
		spanBinaryExpr(pParse, TK_IS, &yymsp[-2].minor.yy190, &yymsp[0].minor.yy190);
		binaryToUnaryIfNull(pParse, yymsp[0].minor.yy190.pExpr, yymsp[-2].minor.yy190.pExpr, TK_ISNULL);
	}
	break;
	case 181: 
	{
		spanBinaryExpr(pParse, TK_ISNOT, &yymsp[-3].minor.yy190, &yymsp[0].minor.yy190);
		binaryToUnaryIfNull(pParse, yymsp[0].minor.yy190.pExpr, yymsp[-3].minor.yy190.pExpr, TK_NOTNULL);
	}
	break;
	case 182: 
	case 183:  yytestcase(yyruleno == 183);
	{spanUnaryPrefix(&yymsp[-1].minor.yy190, pParse, yymsp[-1].major, &yymsp[0].minor.yy190, &yymsp[-1].minor.yy0);}
	break;
	case 184: 
	{spanUnaryPrefix(&yymsp[-1].minor.yy190, pParse, TK_UMINUS, &yymsp[0].minor.yy190, &yymsp[-1].minor.yy0);}
	break;
	case 185: 
	{spanUnaryPrefix(&yymsp[-1].minor.yy190, pParse, TK_UPLUS, &yymsp[0].minor.yy190, &yymsp[-1].minor.yy0);}
	break;
	case 186: 
	case 189:  yytestcase(yyruleno == 189);
	{yymsp[0].minor.yy194 = 0; }
	break;
	case 188: 
	{
		ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy190.pExpr);
		pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy190.pExpr);
		yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy190.pExpr, 0, 0);
		if (yymsp[-4].minor.yy190.pExpr) {
			yymsp[-4].minor.yy190.pExpr->x.pList = pList;
		}
		else {
			sqlite3ExprListDelete(pParse->db, pList);
		}
		exprNot(pParse, yymsp[-3].minor.yy194, &yymsp[-4].minor.yy190);
		yymsp[-4].minor.yy190.zEnd = yymsp[0].minor.yy190.zEnd;
	}
	break;
	case 191: 
	{
		if (yymsp[-1].minor.yy148 == 0) {
			
			sqlite3ExprDelete(pParse->db, yymsp[-4].minor.yy190.pExpr);
			yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_INTEGER, 0, 0, &sqlite3IntTokens[yymsp[-3].minor.yy194]);
		}
		else if (yymsp[-1].minor.yy148->nExpr == 1) {
			
			Expr *pRHS = yymsp[-1].minor.yy148->a[0].pExpr;
			yymsp[-1].minor.yy148->a[0].pExpr = 0;
			sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy148);
			
			if (ALWAYS(pRHS)) {
				pRHS->flags &= ~EP_Collate;
				pRHS->flags |= EP_Generic;
			}
			yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, yymsp[-3].minor.yy194 ? TK_NE : TK_EQ, yymsp[-4].minor.yy190.pExpr, pRHS, 0);
		}
		else {
			yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy190.pExpr, 0, 0);
			if (yymsp[-4].minor.yy190.pExpr) {
				yymsp[-4].minor.yy190.pExpr->x.pList = yymsp[-1].minor.yy148;
				sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy190.pExpr);
			}
			else {
				sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy148);
			}
			exprNot(pParse, yymsp[-3].minor.yy194, &yymsp[-4].minor.yy190);
		}
		yymsp[-4].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
	}
	break;
	case 192: 
	{
		spanSet(&yymsp[-2].minor.yy190, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0); 
		yymsp[-2].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0);
		sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy190.pExpr, yymsp[-1].minor.yy243);
	}
	break;
	case 193: 
	{
		yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy190.pExpr, 0, 0);
		sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy190.pExpr, yymsp[-1].minor.yy243);
		exprNot(pParse, yymsp[-3].minor.yy194, &yymsp[-4].minor.yy190);
		yymsp[-4].minor.yy190.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
	}
	break;
	case 194: 
	{
		SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);
		Select *pSelect = sqlite3SelectNew(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0, 0);
		if (yymsp[0].minor.yy148)  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy148);
		yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy190.pExpr, 0, 0);
		sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy190.pExpr, pSelect);
		exprNot(pParse, yymsp[-3].minor.yy194, &yymsp[-4].minor.yy190);
		yymsp[-4].minor.yy190.zEnd = yymsp[-1].minor.yy0.z ? &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n] : &yymsp[-2].minor.yy0.z[yymsp[-2].minor.yy0.n];
	}
	break;
	case 195: 
	{
		Expr *p;
		spanSet(&yymsp[-3].minor.yy190, &yymsp[-3].minor.yy0, &yymsp[0].minor.yy0); 
		p = yymsp[-3].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0);
		sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy243);
	}
	break;
	case 196: 
	{
		spanSet(&yymsp[-4].minor.yy190, &yymsp[-4].minor.yy0, &yymsp[0].minor.yy0);  
		yymsp[-4].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy72, 0, 0);
		if (yymsp[-4].minor.yy190.pExpr) {
			yymsp[-4].minor.yy190.pExpr->x.pList = yymsp[-1].minor.yy72 ? sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy148, yymsp[-1].minor.yy72) : yymsp[-2].minor.yy148;
			sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy190.pExpr);
		}
		else {
			sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy148);
			sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy72);
		}
	}
	break;
	case 197: 
	{
		yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy148, yymsp[-2].minor.yy190.pExpr);
		yymsp[-4].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy148, yymsp[0].minor.yy190.pExpr);
	}
	break;
	case 198: 
	{
		yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy190.pExpr);
		yymsp[-3].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy148, yymsp[0].minor.yy190.pExpr);
	}
	break;
	case 201: 
	{yymsp[0].minor.yy72 = yymsp[0].minor.yy190.pExpr; }
	break;
	case 204: 
	{yymsp[-2].minor.yy148 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy148, yymsp[0].minor.yy190.pExpr); }
	break;
	case 205: 
	{yymsp[0].minor.yy148 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy190.pExpr); }
	break;
	case 207: 
	case 212:  yytestcase(yyruleno == 212);
	{yymsp[-2].minor.yy148 = yymsp[-1].minor.yy148; }
	break;
	case 208: 
	{
		sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,
			sqlite3SrcListAppend(pParse->db, 0, &yymsp[-4].minor.yy0, 0), yymsp[-2].minor.yy148, yymsp[-10].minor.yy194,
			&yymsp[-11].minor.yy0, yymsp[0].minor.yy72, SQLITE_SO_ASC, yymsp[-8].minor.yy194, SQLITE_IDXTYPE_APPDEF);
	}
	break;
	case 209: 
	case 250:  yytestcase(yyruleno == 250);
	{yymsp[0].minor.yy194 = OE_Abort; }
	break;
	case 210: 
	{yymsp[1].minor.yy194 = OE_None; }
	break;
	case 213: 
	{
		yymsp[-4].minor.yy148 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy148, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy194, yymsp[0].minor.yy194);
	}
	break;
	case 214: 
	{
		yymsp[-2].minor.yy148 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy194, yymsp[0].minor.yy194); 
	}
	break;
	case 217: 
	{sqlite3DropIndex(pParse, yymsp[0].minor.yy185, yymsp[-1].minor.yy194); }
	break;
	case 218: 
	{sqlite3Vacuum(pParse, 0); }
	break;
	case 219: 
	{sqlite3Vacuum(pParse, &yymsp[0].minor.yy0); }
	break;
	case 220: 
	{sqlite3Pragma(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, 0, 0); }
	break;
	case 221: 
	{sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 0); }
	break;
	case 222: 
	{sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 0); }
	break;
	case 223: 
	{sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 1); }
	break;
	case 224: 
	{sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 1); }
	break;
	case 227: 
	{
		Token all;
		all.z = yymsp[-3].minor.yy0.z;
		all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;
		sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy145, &all);
	}
	break;
	case 228: 
	{
		sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy194, yymsp[-4].minor.yy332.a, yymsp[-4].minor.yy332.b, yymsp[-2].minor.yy185, yymsp[0].minor.yy72, yymsp[-10].minor.yy194, yymsp[-8].minor.yy194);
		yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n == 0 ? yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0); 
	}
	break;
	case 229: 
	{ yymsp[0].minor.yy194 = TK_BEFORE; }
	break;
	case 230: 
	{ yymsp[0].minor.yy194 = TK_AFTER;  }
	break;
	case 231: 
	{ yymsp[-1].minor.yy194 = TK_INSTEAD; }
	break;
	case 232: 
	{ yymsp[1].minor.yy194 = TK_BEFORE; }
	break;
	case 233: 
	case 234:  yytestcase(yyruleno == 234);
	{yymsp[0].minor.yy332.a = yymsp[0].major;  yymsp[0].minor.yy332.b = 0; }
	break;
	case 235: 
	{yymsp[-2].minor.yy332.a = TK_UPDATE; yymsp[-2].minor.yy332.b = yymsp[0].minor.yy254; }
	break;
	case 236: 
	case 255:  yytestcase(yyruleno == 255);
	{ yymsp[1].minor.yy72 = 0; }
	break;
	case 237: 
	case 256:  yytestcase(yyruleno == 256);
	{ yymsp[-1].minor.yy72 = yymsp[0].minor.yy190.pExpr; }
	break;
	case 238: 
	{
		assert(yymsp[-2].minor.yy145 != 0);
		yymsp[-2].minor.yy145->pLast->pNext = yymsp[-1].minor.yy145;
		yymsp[-2].minor.yy145->pLast = yymsp[-1].minor.yy145;
	}
	break;
	case 239: 
	{
		assert(yymsp[-1].minor.yy145 != 0);
		yymsp[-1].minor.yy145->pLast = yymsp[-1].minor.yy145;
	}
	break;
	case 240: 
	{
		yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;
		sqlite3ErrorMsg(pParse,
			"qualified table names are not allowed on INSERT, UPDATE, and DELETE "
			"statements within triggers");
	}
	break;
	case 241: 
	{
		sqlite3ErrorMsg(pParse,
			"the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
			"within triggers");
	}
	break;
	case 242: 
	{
		sqlite3ErrorMsg(pParse,
			"the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
			"within triggers");
	}
	break;
	case 243: 
	{yymsp[-6].minor.yy145 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-4].minor.yy0, yymsp[-1].minor.yy148, yymsp[0].minor.yy72, yymsp[-5].minor.yy194); }
	break;
	case 244: 
	{yymsp[-4].minor.yy145 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy254, yymsp[0].minor.yy243, yymsp[-4].minor.yy194);}
	break;
	case 245: 
	{yymsp[-4].minor.yy145 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[0].minor.yy72); }
	break;
	case 246: 
	{yymsp[0].minor.yy145 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy243); }
	break;
	case 247: 
	{
		spanSet(&yymsp[-3].minor.yy190, &yymsp[-3].minor.yy0, &yymsp[0].minor.yy0);  
		yymsp[-3].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, 0);
		if (yymsp[-3].minor.yy190.pExpr) {
			yymsp[-3].minor.yy190.pExpr->affinity = OE_Ignore;
		}
	}
	break;
	case 248: 
	{
		spanSet(&yymsp[-5].minor.yy190, &yymsp[-5].minor.yy0, &yymsp[0].minor.yy0);  
		yymsp[-5].minor.yy190.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, &yymsp[-1].minor.yy0);
		if (yymsp[-5].minor.yy190.pExpr) {
			yymsp[-5].minor.yy190.pExpr->affinity = (char)yymsp[-3].minor.yy194;
		}
	}
	break;
	case 249: 
	{yymsp[0].minor.yy194 = OE_Rollback; }
	break;
	case 251: 
	{yymsp[0].minor.yy194 = OE_Fail; }
	break;
	case 252: 
	{
		sqlite3DropTrigger(pParse, yymsp[0].minor.yy185, yymsp[-1].minor.yy194);
	}
	break;
	case 253: 
	{
		sqlite3Attach(pParse, yymsp[-3].minor.yy190.pExpr, yymsp[-1].minor.yy190.pExpr, yymsp[0].minor.yy72);
	}
	break;
	case 254: 
	{
		sqlite3Detach(pParse, yymsp[0].minor.yy190.pExpr);
	}
	break;
	case 257: 
	{sqlite3Reindex(pParse, 0, 0); }
	break;
	case 258: 
	{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0); }
	break;
	case 259: 
	{sqlite3Analyze(pParse, 0, 0); }
	break;
	case 260: 
	{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0); }
	break;
	case 261: 
	{
		sqlite3AlterRenameTable(pParse, yymsp[-3].minor.yy185, &yymsp[0].minor.yy0);
	}
	break;
	case 262: 
	{
		yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z - yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;
		sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);
	}
	break;
	case 263: 
	{
		disableLookaside(pParse);
		sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy185);
	}
	break;
	case 264: 
	{sqlite3VtabFinishParse(pParse, 0); }
	break;
	case 265: 
	{sqlite3VtabFinishParse(pParse, &yymsp[0].minor.yy0); }
	break;
	case 266: 
	{
		sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy194);
	}
	break;
	case 267: 
	{sqlite3VtabArgInit(pParse); }
	break;
	case 268: 
	case 269:  yytestcase(yyruleno == 269);
	case 270:  yytestcase(yyruleno == 270);
	{sqlite3VtabArgExtend(pParse, &yymsp[0].minor.yy0); }
	break;
	case 271: 
	{yymsp[1].minor.yy285 = 0; }
	break;
	case 272: 
	{ yymsp[-1].minor.yy285 = yymsp[0].minor.yy285; }
	break;
	case 273: 
	{ yymsp[-2].minor.yy285 = yymsp[0].minor.yy285; }
	break;
	case 274: 
	{
		yymsp[-5].minor.yy285 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy148, yymsp[-1].minor.yy243); 
	}
	break;
	case 275: 
	{
		yymsp[-7].minor.yy285 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy285, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy148, yymsp[-1].minor.yy243);
	}
	break;
	default:
		 yytestcase(yyruleno == 276);
		 yytestcase(yyruleno == 277);
		 assert(yyruleno != 278);
		 yytestcase(yyruleno == 279);
		 yytestcase(yyruleno == 280);
		 yytestcase(yyruleno == 281);
		 yytestcase(yyruleno == 282);
		 yytestcase(yyruleno == 283);
		 yytestcase(yyruleno == 284);
		 yytestcase(yyruleno == 285);
		 yytestcase(yyruleno == 286);
		 yytestcase(yyruleno == 287);
		 yytestcase(yyruleno == 288);
		 yytestcase(yyruleno == 289);
		 yytestcase(yyruleno == 290);
		 yytestcase(yyruleno == 291);
		 yytestcase(yyruleno == 292);
		 yytestcase(yyruleno == 293);
		 yytestcase(yyruleno == 294);
		 assert(yyruleno != 295);
		 assert(yyruleno != 296);
		 yytestcase(yyruleno == 297);
		 yytestcase(yyruleno == 298);
		 yytestcase(yyruleno == 299);
		 yytestcase(yyruleno == 300);
		 yytestcase(yyruleno == 301);
		 assert(yyruleno != 302);
		 yytestcase(yyruleno == 303);
		 assert(yyruleno != 304);
		 assert(yyruleno != 305);
		 assert(yyruleno != 306);
		 yytestcase(yyruleno == 307);
		 yytestcase(yyruleno == 308);
		 yytestcase(yyruleno == 309);
		 assert(yyruleno != 310);
		 yytestcase(yyruleno == 311);
		 assert(yyruleno != 312);
		 assert(yyruleno != 313);
		 yytestcase(yyruleno == 314);
		 yytestcase(yyruleno == 315);
		 yytestcase(yyruleno == 316);
		 yytestcase(yyruleno == 317);
		 yytestcase(yyruleno == 318);
		 yytestcase(yyruleno == 319);
		 yytestcase(yyruleno == 320);
		 yytestcase(yyruleno == 321);
		 yytestcase(yyruleno == 322);
		 yytestcase(yyruleno == 323);
		 yytestcase(yyruleno == 324);
		 yytestcase(yyruleno == 325);
		 yytestcase(yyruleno == 326);
		 yytestcase(yyruleno == 327);
		 yytestcase(yyruleno == 328);
		 yytestcase(yyruleno == 329);
		 yytestcase(yyruleno == 330);
		 yytestcase(yyruleno == 331);
		break;
		
	};
	assert(yyruleno<sizeof(yyRuleInfo) / sizeof(yyRuleInfo[0]));
	yygoto = yyRuleInfo[yyruleno].lhs;
	yysize = yyRuleInfo[yyruleno].nrhs;
	yyact = yy_find_reduce_action(yymsp[-yysize].stateno, (YYCODETYPE)yygoto);
	if (yyact <= YY_MAX_SHIFTREDUCE) {
		if (yyact>YY_MAX_SHIFT) {
			yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
		}
		yymsp -= yysize - 1;
		yypParser->yytos = yymsp;
		yymsp->stateno = (YYACTIONTYPE)yyact;
		yymsp->major = (YYCODETYPE)yygoto;
		yyTraceShift(yypParser, yyact);
	}
	else {
		assert(yyact == YY_ACCEPT_ACTION);
		yypParser->yytos -= yysize;
		yy_accept(yypParser);
	}
}


#ifndef YYNOERRORRECOVERY
static void yy_parse_failed(
	yyParser *yypParser           
) {
	sqlite3ParserARG_FETCH;
#ifndef NDEBUG
	if (yyTraceFILE) {
		fprintf(yyTraceFILE, "%sFail!\n", yyTracePrompt);
	}
#endif
	while (yypParser->yytos>yypParser->yystack) yy_pop_parser_stack(yypParser);
	
	
	
	sqlite3ParserARG_STORE; 
}
#endif 


static void yy_syntax_error(
	yyParser *yypParser,           
	int yymajor,                   
	sqlite3ParserTOKENTYPE yyminor         
) {
	sqlite3ParserARG_FETCH;
#define TOKEN yyminor
	

	UNUSED_PARAMETER(yymajor);  
	assert(TOKEN.z[0]);  
	sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN);
	
	sqlite3ParserARG_STORE; 
}


static void yy_accept(
	yyParser *yypParser           
) {
	sqlite3ParserARG_FETCH;
#ifndef NDEBUG
	if (yyTraceFILE) {
		fprintf(yyTraceFILE, "%sAccept!\n", yyTracePrompt);
	}
#endif
#ifndef YYNOERRORRECOVERY
	yypParser->yyerrcnt = -1;
#endif
	assert(yypParser->yytos == yypParser->yystack);
	
	
	
	sqlite3ParserARG_STORE; 
}


SQLITE_PRIVATE void sqlite3Parser(
	void *yyp,                   
	int yymajor,                 
	sqlite3ParserTOKENTYPE yyminor       
	sqlite3ParserARG_PDECL               
) {
	YYMINORTYPE yyminorunion;
	unsigned int yyact;   
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
	int yyendofinput;     
#endif
#ifdef YYERRORSYMBOL
	int yyerrorhit = 0;   
#endif
	yyParser *yypParser;  

	yypParser = (yyParser*)yyp;
	assert(yypParser->yytos != 0);
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
	yyendofinput = (yymajor == 0);
#endif
	sqlite3ParserARG_STORE;

#ifndef NDEBUG
	if (yyTraceFILE) {
		fprintf(yyTraceFILE, "%sInput '%s'\n", yyTracePrompt, yyTokenName[yymajor]);
	}
#endif

	do {
		yyact = yy_find_shift_action(yypParser, (YYCODETYPE)yymajor);
		if (yyact <= YY_MAX_SHIFTREDUCE) {
			yy_shift(yypParser, yyact, yymajor, yyminor);
#ifndef YYNOERRORRECOVERY
			yypParser->yyerrcnt--;
#endif
			yymajor = YYNOCODE;
		}
		else if (yyact <= YY_MAX_REDUCE) {
			yy_reduce(yypParser, yyact - YY_MIN_REDUCE);
		}
		else {
			assert(yyact == YY_ERROR_ACTION);
			yyminorunion.yy0 = yyminor;
#ifdef YYERRORSYMBOL
			int yymx;
#endif
#ifndef NDEBUG
			if (yyTraceFILE) {
				fprintf(yyTraceFILE, "%sSyntax Error!\n", yyTracePrompt);
			}
#endif
#ifdef YYERRORSYMBOL
			
			if (yypParser->yyerrcnt<0) {
				yy_syntax_error(yypParser, yymajor, yyminor);
			}
			yymx = yypParser->yytos->major;
			if (yymx == YYERRORSYMBOL || yyerrorhit) {
#ifndef NDEBUG
				if (yyTraceFILE) {
					fprintf(yyTraceFILE, "%sDiscard input token %s\n",
						yyTracePrompt, yyTokenName[yymajor]);
				}
#endif
				yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
				yymajor = YYNOCODE;
			}
			else {
				while (yypParser->yytos >= yypParser->yystack
					&& yymx != YYERRORSYMBOL
					&& (yyact = yy_find_reduce_action(
						yypParser->yytos->stateno,
						YYERRORSYMBOL)) >= YY_MIN_REDUCE
					) {
					yy_pop_parser_stack(yypParser);
				}
				if (yypParser->yytos < yypParser->yystack || yymajor == 0) {
					yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
					yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
					yypParser->yyerrcnt = -1;
#endif
					yymajor = YYNOCODE;
				}
				else if (yymx != YYERRORSYMBOL) {
					yy_shift(yypParser, yyact, YYERRORSYMBOL, yyminor);
				}
			}
			yypParser->yyerrcnt = 3;
			yyerrorhit = 1;
#elif defined(YYNOERRORRECOVERY)
			
			yy_syntax_error(yypParser, yymajor, yyminor);
			yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
			yymajor = YYNOCODE;

#else  
			
			if (yypParser->yyerrcnt <= 0) {
				yy_syntax_error(yypParser, yymajor, yyminor);
			}
			yypParser->yyerrcnt = 3;
			yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
			if (yyendofinput) {
				yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
				yypParser->yyerrcnt = -1;
#endif
			}
			yymajor = YYNOCODE;
#endif
		}
	} while (yymajor != YYNOCODE && yypParser->yytos>yypParser->yystack);
#ifndef NDEBUG
	if (yyTraceFILE) {
		yyStackEntry *i;
		char cDiv = '[';
		fprintf(yyTraceFILE, "%sReturn. Stack=", yyTracePrompt);
		for (i = &yypParser->yystack[1]; i <= yypParser->yytos; i++) {
			fprintf(yyTraceFILE, "%c%s", cDiv, yyTokenName[i->major]);
			cDiv = ' ';
		}
		fprintf(yyTraceFILE, "]\n");
	}
#endif
	return;
}








#define CC_X          0    
#define CC_KYWD       1    
#define CC_ID         2    
#define CC_DIGIT      3    
#define CC_DOLLAR     4    
#define CC_VARALPHA   5    
#define CC_VARNUM     6    
#define CC_SPACE      7    
#define CC_QUOTE      8    
#define CC_QUOTE2     9    
#define CC_PIPE      10    
#define CC_MINUS     11    
#define CC_LT        12    
#define CC_GT        13    
#define CC_EQ        14    
#define CC_BANG      15    
#define CC_SLASH     16    
#define CC_LP        17    
#define CC_RP        18    
#define CC_SEMI      19    
#define CC_PLUS      20    
#define CC_STAR      21    
#define CC_PERCENT   22    
#define CC_COMMA     23    
#define CC_AND       24    
#define CC_TILDA     25    
#define CC_DOT       26    
#define CC_ILLEGAL   27    

static const unsigned char aiClass[] = {
#ifdef SQLITE_ASCII
	
	   27, 27, 27, 27, 27, 27, 27, 27, 27,  7,  7, 27,  7,  7, 27, 27,
	   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	    7, 15,  8,  5,  4, 22, 24,  8, 17, 18, 21, 20, 23, 11, 26, 16,
	    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  5, 19, 12, 14, 13,  6,
	    5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  9, 27, 27, 27,  1,
	    8,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1, 27, 10, 27, 25, 27,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2
#endif
#ifdef SQLITE_EBCDIC
	
	   27, 27, 27, 27, 27,  7, 27, 27, 27, 27, 27, 27,  7,  7, 27, 27,
	   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	   27, 27, 27, 27, 27,  7, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	    7, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 12, 17, 20, 10,
	   24, 27, 27, 27, 27, 27, 27, 27, 27, 27, 15,  4, 21, 18, 19, 27,
	   11, 16, 27, 27, 27, 27, 27, 27, 27, 27, 27, 23, 22,  1, 13,  7,
	   27, 27, 27, 27, 27, 27, 27, 27, 27,  8,  5,  5,  5,  8, 14,  8,
	   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,
	   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,
	   25,  1,  1,  1,  1,  1,  1,  0,  1,  1, 27, 27, 27, 27, 27, 27,
	   27, 27, 27, 27, 27, 27, 27, 27, 27, 27,  9, 27, 27, 27, 27, 27,
	   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,
	   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,
	   27, 27,  1,  1,  1,  1,  1,  0,  1,  1, 27, 27, 27, 27, 27, 27,
	    3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 27, 27, 27, 27, 27, 27,
#endif
};


#ifdef SQLITE_ASCII
# define charMap(X) sqlite3UpperToLower[(unsigned char)X]
#endif
#ifdef SQLITE_EBCDIC
# define charMap(X) ebcdicToAscii[(unsigned char)X]
const unsigned char ebcdicToAscii[] = {
	
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  
	0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  
	0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
	0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  
	0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  
	0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
};
#endif






static int keywordCode(const char *z, int n, int *pType) {
	
	
	
	
	
	
	
	
	
	
	
	static const char zText[553] = {
		'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
		'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
		'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
		'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
		'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
		'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
		'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
		'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
		'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
		'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
		'U','E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S',
		'E','A','T','T','A','C','H','A','V','I','N','G','R','O','U','P','D','A',
		'T','E','B','E','G','I','N','N','E','R','E','C','U','R','S','I','V','E',
		'B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C','A',
		'S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L','A',
		'T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A',
		'T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E','J',
		'O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A','L',
		'Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U','E',
		'S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W','H',
		'E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C','E',
		'A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E',
		'M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M',
		'I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R',
		'R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M','A',
		'R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
		'R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L','O',
		'B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S','T',
		'R','I','C','T','R','I','G','H','T','R','O','L','L','B','A','C','K','R',
		'O','W','U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M',
		'V','I','E','W','I','N','I','T','I','A','L','L','Y',
	};
	static const unsigned char aHash[127] = {
		76, 105, 117,  74,   0,  45,   0,   0,  82,   0,  77,   0,   0,
		42,  12,  78,  15,   0, 116,  85,  54, 112,   0,  19,   0,   0,
		121,   0, 119, 115,   0,  22,  93,   0,   9,   0,   0,  70,  71,
		0,  69,   6,   0,  48,  90, 102,   0, 118, 101,   0,   0,  44,
		0, 103,  24,   0,  17,   0, 122,  53,  23,   0,   5, 110,  25,
		96,   0,   0, 124, 106,  60, 123,  57,  28,  55,   0,  91,   0,
		100,  26,   0,  99,   0,   0,   0,  95,  92,  97,  88, 109,  14,
		39, 108,   0,  81,   0,  18,  89, 111,  32,   0, 120,  80, 113,
		62,  46,  84,   0,   0,  94,  40,  59, 114,   0,  36,   0,   0,
		29,   0,  86,  63,  64,   0,  20,  61,   0,  56,
	};
	static const unsigned char aNext[124] = {
		0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
		0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
		0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
		0,   0,   0,   0,  33,   0,  21,   0,   0,   0,   0,   0,  50,
		0,  43,   3,  47,   0,   0,   0,   0,  30,   0,  58,   0,  38,
		0,   0,   0,   1,  66,   0,   0,  67,   0,  41,   0,   0,   0,
		0,   0,   0,  49,  65,   0,   0,   0,   0,  31,  52,  16,  34,
		10,   0,   0,   0,   0,   0,   0,   0,  11,  72,  79,   0,   8,
		0, 104,  98,   0, 107,   0,  87,   0,  75,  51,   0,  27,  37,
		73,  83,   0,  35,  68,   0,   0,
	};
	static const unsigned char aLen[124] = {
		7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
		7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,
		11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,
		4,   6,   2,   3,   9,   4,   2,   6,   5,   7,   4,   5,   7,
		6,   6,   5,   6,   5,   5,   9,   7,   7,   3,   2,   4,   4,
		7,   3,   6,   4,   7,   6,  12,   6,   9,   4,   6,   5,   4,
		7,   6,   5,   6,   7,   5,   4,   5,   6,   5,   7,   3,   7,
		13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   8,   8,
		2,   4,   4,   4,   4,   4,   2,   2,   6,   5,   8,   5,   8,
		3,   5,   5,   6,   4,   9,   3,
	};
	static const unsigned short int aOffset[124] = {
		0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
		36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
		86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
		159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 184, 188, 192,
		199, 204, 209, 212, 218, 221, 225, 234, 240, 240, 240, 243, 246,
		250, 251, 255, 261, 265, 272, 278, 290, 296, 305, 307, 313, 318,
		320, 327, 332, 337, 343, 349, 354, 358, 361, 367, 371, 378, 380,
		387, 389, 391, 400, 404, 410, 416, 424, 429, 429, 445, 452, 459,
		460, 467, 471, 475, 479, 483, 486, 488, 490, 496, 500, 508, 513,
		521, 524, 529, 534, 540, 544, 549,
	};
	static const unsigned char aCode[124] = {
		TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,
		TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,
		TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,
		TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,
		TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,
		TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,
		TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,
		TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,
		TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,
		TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,
		TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_GROUP,
		TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RECURSIVE,  TK_BETWEEN,
		TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,
		TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,
		TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,
		TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,
		TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,
		TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,
		TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,
		TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,
		TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,
		TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,
		TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,
		TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,
		TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,
	};
	int i, j;
	const char *zKW;
	if (n >= 2) {
		i = ((charMap(z[0]) * 4) ^ (charMap(z[n - 1]) * 3) ^ n) % 127;
		for (i = ((int)aHash[i]) - 1; i >= 0; i = ((int)aNext[i]) - 1) {
			if (aLen[i] != n) continue;
			j = 0;
			zKW = &zText[aOffset[i]];
#ifdef SQLITE_ASCII
			while (j<n && (z[j] & ~0x20) == zKW[j]) { j++; }
#endif
#ifdef SQLITE_EBCDIC
			while (j<n && toupper(z[j]) == zKW[j]) { j++; }
#endif
			if (j<n) continue;
			testcase(i == 0); 
			testcase(i == 1); 
			testcase(i == 2); 
			testcase(i == 3); 
			testcase(i == 4); 
			testcase(i == 5); 
			testcase(i == 6); 
			testcase(i == 7); 
			testcase(i == 8); 
			testcase(i == 9); 
			testcase(i == 10); 
			testcase(i == 11); 
			testcase(i == 12); 
			testcase(i == 13); 
			testcase(i == 14); 
			testcase(i == 15); 
			testcase(i == 16); 
			testcase(i == 17); 
			testcase(i == 18); 
			testcase(i == 19); 
			testcase(i == 20); 
			testcase(i == 21); 
			testcase(i == 22); 
			testcase(i == 23); 
			testcase(i == 24); 
			testcase(i == 25); 
			testcase(i == 26); 
			testcase(i == 27); 
			testcase(i == 28); 
			testcase(i == 29); 
			testcase(i == 30); 
			testcase(i == 31); 
			testcase(i == 32); 
			testcase(i == 33); 
			testcase(i == 34); 
			testcase(i == 35); 
			testcase(i == 36); 
			testcase(i == 37); 
			testcase(i == 38); 
			testcase(i == 39); 
			testcase(i == 40); 
			testcase(i == 41); 
			testcase(i == 42); 
			testcase(i == 43); 
			testcase(i == 44); 
			testcase(i == 45); 
			testcase(i == 46); 
			testcase(i == 47); 
			testcase(i == 48); 
			testcase(i == 49); 
			testcase(i == 50); 
			testcase(i == 51); 
			testcase(i == 52); 
			testcase(i == 53); 
			testcase(i == 54); 
			testcase(i == 55); 
			testcase(i == 56); 
			testcase(i == 57); 
			testcase(i == 58); 
			testcase(i == 59); 
			testcase(i == 60); 
			testcase(i == 61); 
			testcase(i == 62); 
			testcase(i == 63); 
			testcase(i == 64); 
			testcase(i == 65); 
			testcase(i == 66); 
			testcase(i == 67); 
			testcase(i == 68); 
			testcase(i == 69); 
			testcase(i == 70); 
			testcase(i == 71); 
			testcase(i == 72); 
			testcase(i == 73); 
			testcase(i == 74); 
			testcase(i == 75); 
			testcase(i == 76); 
			testcase(i == 77); 
			testcase(i == 78); 
			testcase(i == 79); 
			testcase(i == 80); 
			testcase(i == 81); 
			testcase(i == 82); 
			testcase(i == 83); 
			testcase(i == 84); 
			testcase(i == 85); 
			testcase(i == 86); 
			testcase(i == 87); 
			testcase(i == 88); 
			testcase(i == 89); 
			testcase(i == 90); 
			testcase(i == 91); 
			testcase(i == 92); 
			testcase(i == 93); 
			testcase(i == 94); 
			testcase(i == 95); 
			testcase(i == 96); 
			testcase(i == 97); 
			testcase(i == 98); 
			testcase(i == 99); 
			testcase(i == 100); 
			testcase(i == 101); 
			testcase(i == 102); 
			testcase(i == 103); 
			testcase(i == 104); 
			testcase(i == 105); 
			testcase(i == 106); 
			testcase(i == 107); 
			testcase(i == 108); 
			testcase(i == 109); 
			testcase(i == 110); 
			testcase(i == 111); 
			testcase(i == 112); 
			testcase(i == 113); 
			testcase(i == 114); 
			testcase(i == 115); 
			testcase(i == 116); 
			testcase(i == 117); 
			testcase(i == 118); 
			testcase(i == 119); 
			testcase(i == 120); 
			testcase(i == 121); 
			testcase(i == 122); 
			testcase(i == 123); 
			*pType = aCode[i];
			break;
		}
	}
	return n;
}
SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n) {
	int id = TK_ID;
	keywordCode((char*)z, n, &id);
	return id;
}
#define SQLITE_N_KEYWORD 124






#ifdef SQLITE_ASCII
#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[] = {
	
	0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  
	0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  
	1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  
	0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  
};
#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif


#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_PRIVATE int sqlite3IsIdChar(u8 c) { return IdChar(c); }
#endif



SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType) {
	int i, c;
	switch (aiClass[*z]) {  
	case CC_SPACE: {
		testcase(z[0] == ' ');
		testcase(z[0] == '\t');
		testcase(z[0] == '\n');
		testcase(z[0] == '\f');
		testcase(z[0] == '\r');
		for (i = 1; sqlite3Isspace(z[i]); i++) {}
		*tokenType = TK_SPACE;
		return i;
	}
	case CC_MINUS: {
		if (z[1] == '-') {
			for (i = 2; (c = z[i]) != 0 && c != '\n'; i++) {}
			*tokenType = TK_SPACE;   
			return i;
		}
		*tokenType = TK_MINUS;
		return 1;
	}
	case CC_LP: {
		*tokenType = TK_LP;
		return 1;
	}
	case CC_RP: {
		*tokenType = TK_RP;
		return 1;
	}
	case CC_SEMI: {
		*tokenType = TK_SEMI;
		return 1;
	}
	case CC_PLUS: {
		*tokenType = TK_PLUS;
		return 1;
	}
	case CC_STAR: {
		*tokenType = TK_STAR;
		return 1;
	}
	case CC_SLASH: {
		if (z[1] != '*' || z[2] == 0) {
			*tokenType = TK_SLASH;
			return 1;
		}
		for (i = 3, c = z[2]; (c != '*' || z[i] != '/') && (c = z[i]) != 0; i++) {}
		if (c) i++;
		*tokenType = TK_SPACE;   
		return i;
	}
	case CC_PERCENT: {
		*tokenType = TK_REM;
		return 1;
	}
	case CC_EQ: {
		*tokenType = TK_EQ;
		return 1 + (z[1] == '=');
	}
	case CC_LT: {
		if ((c = z[1]) == '=') {
			*tokenType = TK_LE;
			return 2;
		}
		else if (c == '>') {
			*tokenType = TK_NE;
			return 2;
		}
		else if (c == '<') {
			*tokenType = TK_LSHIFT;
			return 2;
		}
		else {
			*tokenType = TK_LT;
			return 1;
		}
	}
	case CC_GT: {
		if ((c = z[1]) == '=') {
			*tokenType = TK_GE;
			return 2;
		}
		else if (c == '>') {
			*tokenType = TK_RSHIFT;
			return 2;
		}
		else {
			*tokenType = TK_GT;
			return 1;
		}
	}
	case CC_BANG: {
		if (z[1] != '=') {
			*tokenType = TK_ILLEGAL;
			return 1;
		}
		else {
			*tokenType = TK_NE;
			return 2;
		}
	}
	case CC_PIPE: {
		if (z[1] != '|') {
			*tokenType = TK_BITOR;
			return 1;
		}
		else {
			*tokenType = TK_CONCAT;
			return 2;
		}
	}
	case CC_COMMA: {
		*tokenType = TK_COMMA;
		return 1;
	}
	case CC_AND: {
		*tokenType = TK_BITAND;
		return 1;
	}
	case CC_TILDA: {
		*tokenType = TK_BITNOT;
		return 1;
	}
	case CC_QUOTE: {
		int delim = z[0];
		testcase(delim == '`');
		testcase(delim == '\'');
		testcase(delim == '"');
		for (i = 1; (c = z[i]) != 0; i++) {
			if (c == delim) {
				if (z[i + 1] == delim) {
					i++;
				}
				else {
					break;
				}
			}
		}
		if (c == '\'') {
			*tokenType = TK_STRING;
			return i + 1;
		}
		else if (c != 0) {
			*tokenType = TK_ID;
			return i + 1;
		}
		else {
			*tokenType = TK_ILLEGAL;
			return i;
		}
	}
	case CC_DOT: {
#ifndef SQLITE_OMIT_FLOATING_POINT
		if (!sqlite3Isdigit(z[1]))
#endif
		{
			*tokenType = TK_DOT;
			return 1;
		}
		
	}
	case CC_DIGIT: {
		testcase(z[0] == '0');  testcase(z[0] == '1');  testcase(z[0] == '2');
		testcase(z[0] == '3');  testcase(z[0] == '4');  testcase(z[0] == '5');
		testcase(z[0] == '6');  testcase(z[0] == '7');  testcase(z[0] == '8');
		testcase(z[0] == '9');
		*tokenType = TK_INTEGER;
#ifndef SQLITE_OMIT_HEX_INTEGER
		if (z[0] == '0' && (z[1] == 'x' || z[1] == 'X') && sqlite3Isxdigit(z[2])) {
			for (i = 3; sqlite3Isxdigit(z[i]); i++) {}
			return i;
		}
#endif
		for (i = 0; sqlite3Isdigit(z[i]); i++) {}
#ifndef SQLITE_OMIT_FLOATING_POINT
		if (z[i] == '.') {
			i++;
			while (sqlite3Isdigit(z[i])) { i++; }
			*tokenType = TK_FLOAT;
		}
		if ((z[i] == 'e' || z[i] == 'E') &&
			(sqlite3Isdigit(z[i + 1])
				|| ((z[i + 1] == '+' || z[i + 1] == '-') && sqlite3Isdigit(z[i + 2]))
				)
			) {
			i += 2;
			while (sqlite3Isdigit(z[i])) { i++; }
			*tokenType = TK_FLOAT;
		}
#endif
		while (IdChar(z[i])) {
			*tokenType = TK_ILLEGAL;
			i++;
		}
		return i;
	}
	case CC_QUOTE2: {
		for (i = 1, c = z[0]; c != ']' && (c = z[i]) != 0; i++) {}
		*tokenType = c == ']' ? TK_ID : TK_ILLEGAL;
		return i;
	}
	case CC_VARNUM: {
		*tokenType = TK_VARIABLE;
		for (i = 1; sqlite3Isdigit(z[i]); i++) {}
		return i;
	}
	case CC_DOLLAR:
	case CC_VARALPHA: {
		int n = 0;
		testcase(z[0] == '$');  testcase(z[0] == '@');
		testcase(z[0] == ':');  testcase(z[0] == '#');
		*tokenType = TK_VARIABLE;
		for (i = 1; (c = z[i]) != 0; i++) {
			if (IdChar(c)) {
				n++;
#ifndef SQLITE_OMIT_TCL_VARIABLE
			}
			else if (c == '(' && n>0) {
				do {
					i++;
				} while ((c = z[i]) != 0 && !sqlite3Isspace(c) && c != ')');
				if (c == ')') {
					i++;
				}
				else {
					*tokenType = TK_ILLEGAL;
				}
				break;
			}
			else if (c == ':' && z[i + 1] == ':') {
				i++;
#endif
			}
			else {
				break;
			}
		}
		if (n == 0) *tokenType = TK_ILLEGAL;
		return i;
	}
	case CC_KYWD: {
		for (i = 1; aiClass[z[i]] <= CC_KYWD; i++) {}
		if (IdChar(z[i])) {
			
			i++;
			break;
		}
		*tokenType = TK_ID;
		return keywordCode((char*)z, i, tokenType);
	}
	case CC_X: {
#ifndef SQLITE_OMIT_BLOB_LITERAL
		testcase(z[0] == 'x'); testcase(z[0] == 'X');
		if (z[1] == '\'') {
			*tokenType = TK_BLOB;
			for (i = 2; sqlite3Isxdigit(z[i]); i++) {}
			if (z[i] != '\'' || i % 2) {
				*tokenType = TK_ILLEGAL;
				while (z[i] && z[i] != '\'') { i++; }
			}
			if (z[i]) i++;
			return i;
		}
#endif
		
	}
	case CC_ID: {
		i = 1;
		break;
	}
	default: {
		*tokenType = TK_ILLEGAL;
		return 1;
	}
	}
	while (IdChar(z[i])) { i++; }
	*tokenType = TK_ID;
	return i;
}


SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg) {
	int nErr = 0;                   
	int i;                          
	void *pEngine;                  
	int tokenType;                  
	int lastTokenParsed = -1;       
	sqlite3 *db = pParse->db;       
	int mxSqlLen;                   

	assert(zSql != 0);
	mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
	if (db->nVdbeActive == 0) {
		db->u1.isInterrupted = 0;
	}
	pParse->rc = SQLITE_OK;
	pParse->zTail = zSql;
	i = 0;
	assert(pzErrMsg != 0);
	
	pEngine = sqlite3ParserAlloc(sqlite3Malloc);
	if (pEngine == 0) {
		sqlite3OomFault(db);
		return SQLITE_NOMEM_BKPT;
	}
	assert(pParse->pNewTable == 0);
	assert(pParse->pNewTrigger == 0);
	assert(pParse->nVar == 0);
	assert(pParse->nzVar == 0);
	assert(pParse->azVar == 0);
	while (1) {
		assert(i >= 0);
		if (zSql[i] != 0) {
			pParse->sLastToken.z = &zSql[i];
			pParse->sLastToken.n = sqlite3GetToken((u8*)&zSql[i], &tokenType);
			i += pParse->sLastToken.n;
			if (i>mxSqlLen) {
				pParse->rc = SQLITE_TOOBIG;
				break;
			}
		}
		else {
			
			if (lastTokenParsed == TK_SEMI) {
				tokenType = 0;
			}
			else if (lastTokenParsed == 0) {
				break;
			}
			else {
				tokenType = TK_SEMI;
			}
		}
		if (tokenType >= TK_SPACE) {
			assert(tokenType == TK_SPACE || tokenType == TK_ILLEGAL);
			if (db->u1.isInterrupted) {
				pParse->rc = SQLITE_INTERRUPT;
				break;
			}
			if (tokenType == TK_ILLEGAL) {
				sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"",
					&pParse->sLastToken);
				break;
			}
		}
		else {
			sqlite3Parser(pEngine, tokenType, pParse->sLastToken, pParse);
			lastTokenParsed = tokenType;
			if (pParse->rc != SQLITE_OK || db->mallocFailed) break;
		}
	}
	assert(nErr == 0);
	pParse->zTail = &zSql[i];
#ifdef YYTRACKMAXSTACKDEPTH
	sqlite3_mutex_enter(sqlite3MallocMutex());
	sqlite3StatusHighwater(SQLITE_STATUS_PARSER_STACK,
		sqlite3ParserStackPeak(pEngine)
	);
	sqlite3_mutex_leave(sqlite3MallocMutex());
#endif 
	sqlite3ParserFree(pEngine, sqlite3_free);
	if (db->mallocFailed) {
		pParse->rc = SQLITE_NOMEM_BKPT;
	}
	if (pParse->rc != SQLITE_OK && pParse->rc != SQLITE_DONE && pParse->zErrMsg == 0) {
		pParse->zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr(pParse->rc));
	}
	assert(pzErrMsg != 0);
	if (pParse->zErrMsg) {
		*pzErrMsg = pParse->zErrMsg;
		sqlite3_log(pParse->rc, "%s", *pzErrMsg);
		pParse->zErrMsg = 0;
		nErr++;
	}
	if (pParse->pVdbe && pParse->nErr>0 && pParse->nested == 0) {
		sqlite3VdbeDelete(pParse->pVdbe);
		pParse->pVdbe = 0;
	}
#ifndef SQLITE_OMIT_SHARED_CACHE
	if (pParse->nested == 0) {
		sqlite3DbFree(db, pParse->aTableLock);
		pParse->aTableLock = 0;
		pParse->nTableLock = 0;
	}
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
	sqlite3_free(pParse->apVtabLock);
#endif

	if (!IN_DECLARE_VTAB) {
		
		sqlite3DeleteTable(db, pParse->pNewTable);
	}

	if (pParse->pWithToFree) sqlite3WithDelete(db, pParse->pWithToFree);
	sqlite3DeleteTrigger(db, pParse->pNewTrigger);
	for (i = pParse->nzVar - 1; i >= 0; i--) sqlite3DbFree(db, pParse->azVar[i]);
	sqlite3DbFree(db, pParse->azVar);
	while (pParse->pAinc) {
		AutoincInfo *p = pParse->pAinc;
		pParse->pAinc = p->pNext;
		sqlite3DbFree(db, p);
	}
	while (pParse->pZombieTab) {
		Table *p = pParse->pZombieTab;
		pParse->pZombieTab = p->pNextZombie;
		sqlite3DeleteTable(db, p);
	}
	assert(nErr == 0 || pParse->rc != SQLITE_OK);
	return nErr;
}





#ifndef SQLITE_OMIT_COMPLETE


#ifndef SQLITE_AMALGAMATION
#ifdef SQLITE_ASCII
#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[];
#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif
#endif 



#define tkSEMI    0
#define tkWS      1
#define tkOTHER   2
#ifndef SQLITE_OMIT_TRIGGER
#define tkEXPLAIN 3
#define tkCREATE  4
#define tkTEMP    5
#define tkTRIGGER 6
#define tkEND     7
#endif


SQLITE_API int sqlite3_complete(const char *zSql) {
	u8 state = 0;   
	u8 token;       

#ifndef SQLITE_OMIT_TRIGGER
					
	static const u8 trans[8][8] = {
		
		
		{ 1,  0,     2,       3,      4,    2,       2,   2, },
		{ 1,  1,     2,       3,      4,    2,       2,   2, },
		{ 1,  2,     2,       2,      2,    2,       2,   2, },
		{ 1,  3,     3,       2,      4,    2,       2,   2, },
		{ 1,  4,     2,       2,      2,    4,       5,   2, },
		{ 6,  5,     5,       5,      5,    5,       5,   5, },
		{ 6,  6,     5,       5,      5,    5,       5,   7, },
		{ 1,  7,     5,       5,      5,    5,       5,   5, },
	};
#else
					
	static const u8 trans[3][3] = {
		
		
		{ 1,  0,     2, },
		{ 1,  1,     2, },
		{ 1,  2,     2, },
	};
#endif 

#ifdef SQLITE_ENABLE_API_ARMOR
	if (zSql == 0) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif

	while (*zSql) {
		switch (*zSql) {
		case ';': {  
			token = tkSEMI;
			break;
		}
		case ' ':
		case '\r':
		case '\t':
		case '\n':
		case '\f': {  
			token = tkWS;
			break;
		}
		case '/': {   
			if (zSql[1] != '*') {
				token = tkOTHER;
				break;
			}
			zSql += 2;
			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) { zSql++; }
			if (zSql[0] == 0) return 0;
			zSql++;
			token = tkWS;
			break;
		}
		case '-': {   
			if (zSql[1] != '-') {
				token = tkOTHER;
				break;
			}
			while (*zSql && *zSql != '\n') { zSql++; }
			if (*zSql == 0) return state == 1;
			token = tkWS;
			break;
		}
		case '[': {   
			zSql++;
			while (*zSql && *zSql != ']') { zSql++; }
			if (*zSql == 0) return 0;
			token = tkOTHER;
			break;
		}
		case '`':     
		case '"':     
		case '\'': {
			int c = *zSql;
			zSql++;
			while (*zSql && *zSql != c) { zSql++; }
			if (*zSql == 0) return 0;
			token = tkOTHER;
			break;
		}
		default: {
#ifdef SQLITE_EBCDIC
			unsigned char c;
#endif
			if (IdChar((u8)*zSql)) {
				
				int nId;
				for (nId = 1; IdChar(zSql[nId]); nId++) {}
#ifdef SQLITE_OMIT_TRIGGER
				token = tkOTHER;
#else
				switch (*zSql) {
				case 'c': case 'C': {
					if (nId == 6 && sqlite3StrNICmp(zSql, "create", 6) == 0) {
						token = tkCREATE;
					}
					else {
						token = tkOTHER;
					}
					break;
				}
				case 't': case 'T': {
					if (nId == 7 && sqlite3StrNICmp(zSql, "trigger", 7) == 0) {
						token = tkTRIGGER;
					}
					else if (nId == 4 && sqlite3StrNICmp(zSql, "temp", 4) == 0) {
						token = tkTEMP;
					}
					else if (nId == 9 && sqlite3StrNICmp(zSql, "temporary", 9) == 0) {
						token = tkTEMP;
					}
					else {
						token = tkOTHER;
					}
					break;
				}
				case 'e':  case 'E': {
					if (nId == 3 && sqlite3StrNICmp(zSql, "end", 3) == 0) {
						token = tkEND;
					}
					else
#ifndef SQLITE_OMIT_EXPLAIN
						if (nId == 7 && sqlite3StrNICmp(zSql, "explain", 7) == 0) {
							token = tkEXPLAIN;
						}
						else
#endif
						{
							token = tkOTHER;
						}
					break;
				}
				default: {
					token = tkOTHER;
					break;
				}
				}
#endif 
				zSql += nId - 1;
			}
			else {
				
				token = tkOTHER;
			}
			break;
		}
		}
		state = trans[state][token];
		zSql++;
	}
	return state == 1;
}

#ifndef SQLITE_OMIT_UTF16

SQLITE_API int sqlite3_complete16(const void *zSql) {
	sqlite3_value *pVal;
	char const *zSql8;
	int rc;

#ifndef SQLITE_OMIT_AUTOINIT
	rc = sqlite3_initialize();
	if (rc) return rc;
#endif
	pVal = sqlite3ValueNew(0);
	sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC);
	zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8);
	if (zSql8) {
		rc = sqlite3_complete(zSql8);
	}
	else {
		rc = SQLITE_NOMEM_BKPT;
	}
	sqlite3ValueFree(pVal);
	return rc & 0xff;
}
#endif 
#endif 






#ifdef SQLITE_ENABLE_FTS3





#if 0
extern "C" {
#endif  

	SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db);

#if 0
}  
#endif  

   
   
#endif
#ifdef SQLITE_ENABLE_RTREE
   
   
   
   

#if 0
extern "C" {
#endif  

	SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db);

#if 0
}  
#endif  

   
   
#endif
#ifdef SQLITE_ENABLE_ICU
   
   
   
   

#if 0
extern "C" {
#endif  

	SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db);

#if 0
}  
#endif  


   
   
#endif
#ifdef SQLITE_ENABLE_JSON1
SQLITE_PRIVATE int sqlite3Json1Init(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_FTS5
SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);
#endif

#ifndef SQLITE_AMALGAMATION

SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
#endif


SQLITE_API const char *sqlite3_libversion(void) { return sqlite3_version; }


SQLITE_API const char *sqlite3_sourceid(void) { return SQLITE_SOURCE_ID; }


SQLITE_API int sqlite3_libversion_number(void) { return SQLITE_VERSION_NUMBER; }


SQLITE_API int sqlite3_threadsafe(void) { return SQLITE_THREADSAFE; }


#ifdef SQLITE_HAVE_OS_TRACE
# ifndef SQLITE_DEBUG_OS_TRACE
#   define SQLITE_DEBUG_OS_TRACE 0
# endif
int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
#endif

#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)

SQLITE_API void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...) = 0;
#endif


SQLITE_API char *sqlite3_temp_directory = 0;


SQLITE_API char *sqlite3_data_directory = 0;


SQLITE_API int sqlite3_initialize(void) {
	MUTEX_LOGIC(sqlite3_mutex *pMaster; )       
		int rc;                                      
#ifdef SQLITE_EXTRA_INIT
	int bRunExtraInit = 0;                       
#endif

#ifdef SQLITE_OMIT_WSD
	rc = sqlite3_wsd_init(4096, 24);
	if (rc != SQLITE_OK) {
		return rc;
	}
#endif

	
	assert(SQLITE_PTRSIZE == sizeof(char*));

	
	if (sqlite3GlobalConfig.isInit) return SQLITE_OK;

	
	rc = sqlite3MutexInit();
	if (rc) return rc;

	
	MUTEX_LOGIC(pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )
		sqlite3_mutex_enter(pMaster);
	sqlite3GlobalConfig.isMutexInit = 1;
	if (!sqlite3GlobalConfig.isMallocInit) {
		rc = sqlite3MallocInit();
	}
	if (rc == SQLITE_OK) {
		sqlite3GlobalConfig.isMallocInit = 1;
		if (!sqlite3GlobalConfig.pInitMutex) {
			sqlite3GlobalConfig.pInitMutex =
				sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);
			if (sqlite3GlobalConfig.bCoreMutex && !sqlite3GlobalConfig.pInitMutex) {
				rc = SQLITE_NOMEM_BKPT;
			}
		}
	}
	if (rc == SQLITE_OK) {
		sqlite3GlobalConfig.nRefInitMutex++;
	}
	sqlite3_mutex_leave(pMaster);

	
	if (rc != SQLITE_OK) {
		return rc;
	}

	
	sqlite3_mutex_enter(sqlite3GlobalConfig.pInitMutex);
	if (sqlite3GlobalConfig.isInit == 0 && sqlite3GlobalConfig.inProgress == 0) {
		sqlite3GlobalConfig.inProgress = 1;
#ifdef SQLITE_ENABLE_SQLLOG
		{
			extern void sqlite3_init_sqllog(void);
			sqlite3_init_sqllog();
		}
#endif
		memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
		sqlite3RegisterBuiltinFunctions();
		if (sqlite3GlobalConfig.isPCacheInit == 0) {
			rc = sqlite3PcacheInitialize();
		}
		if (rc == SQLITE_OK) {
			sqlite3GlobalConfig.isPCacheInit = 1;
			rc = sqlite3OsInit();
		}
		if (rc == SQLITE_OK) {
			sqlite3PCacheBufferSetup(sqlite3GlobalConfig.pPage,
				sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);
			sqlite3GlobalConfig.isInit = 1;
#ifdef SQLITE_EXTRA_INIT
			bRunExtraInit = 1;
#endif
		}
		sqlite3GlobalConfig.inProgress = 0;
	}
	sqlite3_mutex_leave(sqlite3GlobalConfig.pInitMutex);

	
	sqlite3_mutex_enter(pMaster);
	sqlite3GlobalConfig.nRefInitMutex--;
	if (sqlite3GlobalConfig.nRefInitMutex <= 0) {
		assert(sqlite3GlobalConfig.nRefInitMutex == 0);
		sqlite3_mutex_free(sqlite3GlobalConfig.pInitMutex);
		sqlite3GlobalConfig.pInitMutex = 0;
	}
	sqlite3_mutex_leave(pMaster);

	
#ifndef NDEBUG
#ifndef SQLITE_OMIT_FLOATING_POINT
	
	if (rc == SQLITE_OK) {
		u64 x = (((u64)1) << 63) - 1;
		double y;
		assert(sizeof(x) == 8);
		assert(sizeof(x) == sizeof(y));
		memcpy(&y, &x, 8);
		assert(sqlite3IsNaN(y));
	}
#endif
#endif

	
#ifdef SQLITE_EXTRA_INIT
	if (bRunExtraInit) {
		int SQLITE_EXTRA_INIT(const char*);
		rc = SQLITE_EXTRA_INIT(0);
	}
#endif

	return rc;
}


SQLITE_API int sqlite3_shutdown(void) {
#ifdef SQLITE_OMIT_WSD
	int rc = sqlite3_wsd_init(4096, 24);
	if (rc != SQLITE_OK) {
		return rc;
	}
#endif

	if (sqlite3GlobalConfig.isInit) {
#ifdef SQLITE_EXTRA_SHUTDOWN
		void SQLITE_EXTRA_SHUTDOWN(void);
		SQLITE_EXTRA_SHUTDOWN();
#endif
		sqlite3_os_end();
		sqlite3_reset_auto_extension();
		sqlite3GlobalConfig.isInit = 0;
	}
	if (sqlite3GlobalConfig.isPCacheInit) {
		sqlite3PcacheShutdown();
		sqlite3GlobalConfig.isPCacheInit = 0;
	}
	if (sqlite3GlobalConfig.isMallocInit) {
		sqlite3MallocEnd();
		sqlite3GlobalConfig.isMallocInit = 0;

#ifndef SQLITE_OMIT_SHUTDOWN_DIRECTORIES
		
		sqlite3_data_directory = 0;
		sqlite3_temp_directory = 0;
#endif
	}
	if (sqlite3GlobalConfig.isMutexInit) {
		sqlite3MutexEnd();
		sqlite3GlobalConfig.isMutexInit = 0;
	}

	return SQLITE_OK;
}


SQLITE_API int sqlite3_config(int op, ...) {
	va_list ap;
	int rc = SQLITE_OK;

	
	if (sqlite3GlobalConfig.isInit) return SQLITE_MISUSE_BKPT;

	va_start(ap, op);
	switch (op) {

		
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0  
	case SQLITE_CONFIG_SINGLETHREAD: {
		
		sqlite3GlobalConfig.bCoreMutex = 0;  
		sqlite3GlobalConfig.bFullMutex = 0;  
		break;
	}
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 
	case SQLITE_CONFIG_MULTITHREAD: {
		
		sqlite3GlobalConfig.bCoreMutex = 1;  
		sqlite3GlobalConfig.bFullMutex = 0;  
		break;
	}
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 
	case SQLITE_CONFIG_SERIALIZED: {
		
		sqlite3GlobalConfig.bCoreMutex = 1;  
		sqlite3GlobalConfig.bFullMutex = 1;  
		break;
	}
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 
	case SQLITE_CONFIG_MUTEX: {
		
		sqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*);
		break;
	}
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 
	case SQLITE_CONFIG_GETMUTEX: {
		
		*va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex;
		break;
	}
#endif

	case SQLITE_CONFIG_MALLOC: {
		
		sqlite3GlobalConfig.m = *va_arg(ap, sqlite3_mem_methods*);
		break;
	}
	case SQLITE_CONFIG_GETMALLOC: {
		
		if (sqlite3GlobalConfig.m.xMalloc == 0) sqlite3MemSetDefault();
		*va_arg(ap, sqlite3_mem_methods*) = sqlite3GlobalConfig.m;
		break;
	}
	case SQLITE_CONFIG_MEMSTATUS: {
		
		sqlite3GlobalConfig.bMemstat = va_arg(ap, int);
		break;
	}
	case SQLITE_CONFIG_SCRATCH: {
		
		sqlite3GlobalConfig.pScratch = va_arg(ap, void*);
		sqlite3GlobalConfig.szScratch = va_arg(ap, int);
		sqlite3GlobalConfig.nScratch = va_arg(ap, int);
		break;
	}
	case SQLITE_CONFIG_PAGECACHE: {
		
		sqlite3GlobalConfig.pPage = va_arg(ap, void*);
		sqlite3GlobalConfig.szPage = va_arg(ap, int);
		sqlite3GlobalConfig.nPage = va_arg(ap, int);
		break;
	}
	case SQLITE_CONFIG_PCACHE_HDRSZ: {
		
		*va_arg(ap, int*) =
			sqlite3HeaderSizeBtree() +
			sqlite3HeaderSizePcache() +
			sqlite3HeaderSizePcache1();
		break;
	}

	case SQLITE_CONFIG_PCACHE: {
		
		break;
	}
	case SQLITE_CONFIG_GETPCACHE: {
		
		rc = SQLITE_ERROR;
		break;
	}

	case SQLITE_CONFIG_PCACHE2: {
		
		sqlite3GlobalConfig.pcache2 = *va_arg(ap, sqlite3_pcache_methods2*);
		break;
	}
	case SQLITE_CONFIG_GETPCACHE2: {
		
		if (sqlite3GlobalConfig.pcache2.xInit == 0) {
			sqlite3PCacheSetDefault();
		}
		*va_arg(ap, sqlite3_pcache_methods2*) = sqlite3GlobalConfig.pcache2;
		break;
	}

								   
#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
	case SQLITE_CONFIG_HEAP: {
		
		sqlite3GlobalConfig.pHeap = va_arg(ap, void*);
		sqlite3GlobalConfig.nHeap = va_arg(ap, int);
		sqlite3GlobalConfig.mnReq = va_arg(ap, int);

		if (sqlite3GlobalConfig.mnReq<1) {
			sqlite3GlobalConfig.mnReq = 1;
		}
		else if (sqlite3GlobalConfig.mnReq>(1 << 12)) {
			
			sqlite3GlobalConfig.mnReq = (1 << 12);
		}

		if (sqlite3GlobalConfig.pHeap == 0) {
			
			memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));
		}
		else {
			
#ifdef SQLITE_ENABLE_MEMSYS3
			sqlite3GlobalConfig.m = *sqlite3MemGetMemsys3();
#endif
#ifdef SQLITE_ENABLE_MEMSYS5
			sqlite3GlobalConfig.m = *sqlite3MemGetMemsys5();
#endif
		}
		break;
	}
#endif

	case SQLITE_CONFIG_LOOKASIDE: {
		sqlite3GlobalConfig.szLookaside = va_arg(ap, int);
		sqlite3GlobalConfig.nLookaside = va_arg(ap, int);
		break;
	}

								  
	case SQLITE_CONFIG_LOG: {
		
		typedef void(*LOGFUNC_t)(void*, int, const char*);
		sqlite3GlobalConfig.xLog = va_arg(ap, LOGFUNC_t);
		sqlite3GlobalConfig.pLogArg = va_arg(ap, void*);
		break;
	}

							
	case SQLITE_CONFIG_URI: {
		
		sqlite3GlobalConfig.bOpenUri = va_arg(ap, int);
		break;
	}

	case SQLITE_CONFIG_COVERING_INDEX_SCAN: {
		
		sqlite3GlobalConfig.bUseCis = va_arg(ap, int);
		break;
	}

#ifdef SQLITE_ENABLE_SQLLOG
	case SQLITE_CONFIG_SQLLOG: {
		typedef void(*SQLLOGFUNC_t)(void*, sqlite3*, const char*, int);
		sqlite3GlobalConfig.xSqllog = va_arg(ap, SQLLOGFUNC_t);
		sqlite3GlobalConfig.pSqllogArg = va_arg(ap, void *);
		break;
	}
#endif

	case SQLITE_CONFIG_MMAP_SIZE: {
		
		sqlite3_int64 szMmap = va_arg(ap, sqlite3_int64);
		sqlite3_int64 mxMmap = va_arg(ap, sqlite3_int64);
		
		if (mxMmap<0 || mxMmap>SQLITE_MAX_MMAP_SIZE) {
			mxMmap = SQLITE_MAX_MMAP_SIZE;
		}
		if (szMmap<0) szMmap = SQLITE_DEFAULT_MMAP_SIZE;
		if (szMmap>mxMmap) szMmap = mxMmap;
		sqlite3GlobalConfig.mxMmap = mxMmap;
		sqlite3GlobalConfig.szMmap = szMmap;
		break;
	}

#if SQLITE_OS_WIN && defined(SQLITE_WIN32_MALLOC) 
	case SQLITE_CONFIG_WIN32_HEAPSIZE: {
		
		sqlite3GlobalConfig.nHeap = va_arg(ap, int);
		break;
	}
#endif

	case SQLITE_CONFIG_PMASZ: {
		sqlite3GlobalConfig.szPma = va_arg(ap, unsigned int);
		break;
	}

	case SQLITE_CONFIG_STMTJRNL_SPILL: {
		sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);
		break;
	}

	default: {
		rc = SQLITE_ERROR;
		break;
	}
	}
	va_end(ap);
	return rc;
}


static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt) {
#ifndef SQLITE_OMIT_LOOKASIDE
	void *pStart;
	if (db->lookaside.nOut) {
		return SQLITE_BUSY;
	}
	
	if (db->lookaside.bMalloced) {
		sqlite3_free(db->lookaside.pStart);
	}
	
	sz = ROUNDDOWN8(sz);  
	if (sz <= (int)sizeof(LookasideSlot*)) sz = 0;
	if (cnt<0) cnt = 0;
	if (sz == 0 || cnt == 0) {
		sz = 0;
		pStart = 0;
	}
	else if (pBuf == 0) {
		sqlite3BeginBenignMalloc();
		pStart = sqlite3Malloc(sz*cnt);  
		sqlite3EndBenignMalloc();
		if (pStart) cnt = sqlite3MallocSize(pStart) / sz;
	}
	else {
		pStart = pBuf;
	}
	db->lookaside.pStart = pStart;
	db->lookaside.pFree = 0;
	db->lookaside.sz = (u16)sz;
	if (pStart) {
		int i;
		LookasideSlot *p;
		assert(sz > (int)sizeof(LookasideSlot*));
		p = (LookasideSlot*)pStart;
		for (i = cnt - 1; i >= 0; i--) {
			p->pNext = db->lookaside.pFree;
			db->lookaside.pFree = p;
			p = (LookasideSlot*)&((u8*)p)[sz];
		}
		db->lookaside.pEnd = p;
		db->lookaside.bDisable = 0;
		db->lookaside.bMalloced = pBuf == 0 ? 1 : 0;
	}
	else {
		db->lookaside.pStart = db;
		db->lookaside.pEnd = db;
		db->lookaside.bDisable = 1;
		db->lookaside.bMalloced = 0;
	}
#endif 
	return SQLITE_OK;
}


SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return db->mutex;
}


SQLITE_API int sqlite3_db_release_memory(sqlite3 *db) {
	int i;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	sqlite3BtreeEnterAll(db);
	for (i = 0; i<db->nDb; i++) {
		Btree *pBt = db->aDb[i].pBt;
		if (pBt) {
			Pager *pPager = sqlite3BtreePager(pBt);
			sqlite3PagerShrink(pPager);
		}
	}
	sqlite3BtreeLeaveAll(db);
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}


SQLITE_API int sqlite3_db_cacheflush(sqlite3 *db) {
	int i;
	int rc = SQLITE_OK;
	int bSeenBusy = 0;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	sqlite3BtreeEnterAll(db);
	for (i = 0; rc == SQLITE_OK && i<db->nDb; i++) {
		Btree *pBt = db->aDb[i].pBt;
		if (pBt && sqlite3BtreeIsInTrans(pBt)) {
			Pager *pPager = sqlite3BtreePager(pBt);
			rc = sqlite3PagerFlush(pPager);
			if (rc == SQLITE_BUSY) {
				bSeenBusy = 1;
				rc = SQLITE_OK;
			}
		}
	}
	sqlite3BtreeLeaveAll(db);
	sqlite3_mutex_leave(db->mutex);
	return ((rc == SQLITE_OK && bSeenBusy) ? SQLITE_BUSY : rc);
}


SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...) {
	va_list ap;
	int rc;
	va_start(ap, op);
	switch (op) {
	case SQLITE_DBCONFIG_MAINDBNAME: {
		db->aDb[0].zDbSName = va_arg(ap, char*);
		rc = SQLITE_OK;
		break;
	}
	case SQLITE_DBCONFIG_LOOKASIDE: {
		void *pBuf = va_arg(ap, void*); 
		int sz = va_arg(ap, int);       
		int cnt = va_arg(ap, int);      
		rc = setupLookaside(db, pBuf, sz, cnt);
		break;
	}
	default: {
		static const struct {
			int op;      
			u32 mask;    
		} aFlagOp[] = {
			{ SQLITE_DBCONFIG_ENABLE_FKEY,           SQLITE_ForeignKeys },
			{ SQLITE_DBCONFIG_ENABLE_TRIGGER,        SQLITE_EnableTrigger },
			{ SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_Fts3Tokenizer },
			{ SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_LoadExtension },
		};
		unsigned int i;
		rc = SQLITE_ERROR; 
		for (i = 0; i<ArraySize(aFlagOp); i++) {
			if (aFlagOp[i].op == op) {
				int onoff = va_arg(ap, int);
				int *pRes = va_arg(ap, int*);
				int oldFlags = db->flags;
				if (onoff>0) {
					db->flags |= aFlagOp[i].mask;
				}
				else if (onoff == 0) {
					db->flags &= ~aFlagOp[i].mask;
				}
				if (oldFlags != db->flags) {
					sqlite3ExpirePreparedStatements(db);
				}
				if (pRes) {
					*pRes = (db->flags & aFlagOp[i].mask) != 0;
				}
				rc = SQLITE_OK;
				break;
			}
		}
		break;
	}
	}
	va_end(ap);
	return rc;
}



static int allSpaces(const char *z, int n) {
	while (n>0 && z[n - 1] == ' ') { n--; }
	return n == 0;
}


static int binCollFunc(
	void *padFlag,
	int nKey1, const void *pKey1,
	int nKey2, const void *pKey2
) {
	int rc, n;
	n = nKey1<nKey2 ? nKey1 : nKey2;
	
	rc = memcmp(pKey1, pKey2, n);
	if (rc == 0) {
		if (padFlag
			&& allSpaces(((char*)pKey1) + n, nKey1 - n)
			&& allSpaces(((char*)pKey2) + n, nKey2 - n)
			) {
			
		}
		else {
			rc = nKey1 - nKey2;
		}
	}
	return rc;
}


static int nocaseCollatingFunc(
	void *NotUsed,
	int nKey1, const void *pKey1,
	int nKey2, const void *pKey2
) {
	int r = sqlite3StrNICmp(
		(const char *)pKey1, (const char *)pKey2, (nKey1<nKey2) ? nKey1 : nKey2);
	UNUSED_PARAMETER(NotUsed);
	if (0 == r) {
		r = nKey1 - nKey2;
	}
	return r;
}


SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return db->lastRowid;
}


SQLITE_API int sqlite3_changes(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return db->nChange;
}


SQLITE_API int sqlite3_total_changes(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return db->nTotalChange;
}


SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *db) {
	while (db->pSavepoint) {
		Savepoint *pTmp = db->pSavepoint;
		db->pSavepoint = pTmp->pNext;
		sqlite3DbFree(db, pTmp);
	}
	db->nSavepoint = 0;
	db->nStatement = 0;
	db->isTransactionSavepoint = 0;
}


static void functionDestroy(sqlite3 *db, FuncDef *p) {
	FuncDestructor *pDestructor = p->u.pDestructor;
	if (pDestructor) {
		pDestructor->nRef--;
		if (pDestructor->nRef == 0) {
			pDestructor->xDestroy(pDestructor->pUserData);
			sqlite3DbFree(db, pDestructor);
		}
	}
}


static void disconnectAllVtab(sqlite3 *db) {
#ifndef SQLITE_OMIT_VIRTUALTABLE
	int i;
	HashElem *p;
	sqlite3BtreeEnterAll(db);
	for (i = 0; i<db->nDb; i++) {
		Schema *pSchema = db->aDb[i].pSchema;
		if (db->aDb[i].pSchema) {
			for (p = sqliteHashFirst(&pSchema->tblHash); p; p = sqliteHashNext(p)) {
				Table *pTab = (Table *)sqliteHashData(p);
				if (IsVirtual(pTab)) sqlite3VtabDisconnect(db, pTab);
			}
		}
	}
	for (p = sqliteHashFirst(&db->aModule); p; p = sqliteHashNext(p)) {
		Module *pMod = (Module *)sqliteHashData(p);
		if (pMod->pEpoTab) {
			sqlite3VtabDisconnect(db, pMod->pEpoTab);
		}
	}
	sqlite3VtabUnlockList(db);
	sqlite3BtreeLeaveAll(db);
#else
	UNUSED_PARAMETER(db);
#endif
}


static int connectionIsBusy(sqlite3 *db) {
	int j;
	assert(sqlite3_mutex_held(db->mutex));
	if (db->pVdbe) return 1;
	for (j = 0; j<db->nDb; j++) {
		Btree *pBt = db->aDb[j].pBt;
		if (pBt && sqlite3BtreeIsInBackup(pBt)) return 1;
	}
	return 0;
}


static int sqlite3Close(sqlite3 *db, int forceZombie) {
	if (!db) {
		
		return SQLITE_OK;
	}
	if (!sqlite3SafetyCheckSickOrOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
	sqlite3_mutex_enter(db->mutex);
	if (db->mTrace & SQLITE_TRACE_CLOSE) {
		db->xTrace(SQLITE_TRACE_CLOSE, db->pTraceArg, db, 0);
	}

	
	disconnectAllVtab(db);

	
	sqlite3VtabRollback(db);

	
	if (!forceZombie && connectionIsBusy(db)) {
		sqlite3ErrorWithMsg(db, SQLITE_BUSY, "unable to close due to unfinalized "
			"statements or unfinished backups");
		sqlite3_mutex_leave(db->mutex);
		return SQLITE_BUSY;
	}

#ifdef SQLITE_ENABLE_SQLLOG
	if (sqlite3GlobalConfig.xSqllog) {
		
		sqlite3GlobalConfig.xSqllog(sqlite3GlobalConfig.pSqllogArg, db, 0, 2);
	}
#endif

	
	db->magic = SQLITE_MAGIC_ZOMBIE;
	sqlite3LeaveMutexAndCloseZombie(db);
	return SQLITE_OK;
}


SQLITE_API int sqlite3_close(sqlite3 *db) { return sqlite3Close(db, 0); }
SQLITE_API int sqlite3_close_v2(sqlite3 *db) { return sqlite3Close(db, 1); }



SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db) {
	HashElem *i;                    
	int j;

	
	if (db->magic != SQLITE_MAGIC_ZOMBIE || connectionIsBusy(db)) {
		sqlite3_mutex_leave(db->mutex);
		return;
	}

	

	
	sqlite3RollbackAll(db, SQLITE_OK);

	
	sqlite3CloseSavepoints(db);

	
	for (j = 0; j<db->nDb; j++) {
		struct Db *pDb = &db->aDb[j];
		if (pDb->pBt) {
			sqlite3BtreeClose(pDb->pBt);
			pDb->pBt = 0;
			if (j != 1) {
				pDb->pSchema = 0;
			}
		}
	}
	
	if (db->aDb[1].pSchema) {
		sqlite3SchemaClear(db->aDb[1].pSchema);
	}
	sqlite3VtabUnlockList(db);

	
	sqlite3CollapseDatabaseArray(db);
	assert(db->nDb <= 2);
	assert(db->aDb == db->aDbStatic);

	
	sqlite3ConnectionClosed(db);

	for (i = sqliteHashFirst(&db->aFunc); i; i = sqliteHashNext(i)) {
		FuncDef *pNext, *p;
		p = sqliteHashData(i);
		do {
			functionDestroy(db, p);
			pNext = p->pNext;
			sqlite3DbFree(db, p);
			p = pNext;
		} while (p);
	}
	sqlite3HashClear(&db->aFunc);
	for (i = sqliteHashFirst(&db->aCollSeq); i; i = sqliteHashNext(i)) {
		CollSeq *pColl = (CollSeq *)sqliteHashData(i);
		
		for (j = 0; j<3; j++) {
			if (pColl[j].xDel) {
				pColl[j].xDel(pColl[j].pUser);
			}
		}
		sqlite3DbFree(db, pColl);
	}
	sqlite3HashClear(&db->aCollSeq);
#ifndef SQLITE_OMIT_VIRTUALTABLE
	for (i = sqliteHashFirst(&db->aModule); i; i = sqliteHashNext(i)) {
		Module *pMod = (Module *)sqliteHashData(i);
		if (pMod->xDestroy) {
			pMod->xDestroy(pMod->pAux);
		}
		sqlite3VtabEponymousTableClear(db, pMod);
		sqlite3DbFree(db, pMod);
	}
	sqlite3HashClear(&db->aModule);
#endif

	sqlite3Error(db, SQLITE_OK); 
	sqlite3ValueFree(db->pErr);
	sqlite3CloseExtensions(db);
#if SQLITE_USER_AUTHENTICATION
	sqlite3_free(db->auth.zAuthUser);
	sqlite3_free(db->auth.zAuthPW);
#endif

	db->magic = SQLITE_MAGIC_ERROR;

	
	sqlite3DbFree(db, db->aDb[1].pSchema);
	sqlite3_mutex_leave(db->mutex);
	db->magic = SQLITE_MAGIC_CLOSED;
	sqlite3_mutex_free(db->mutex);
	assert(db->lookaside.nOut == 0);  
	if (db->lookaside.bMalloced) {
		sqlite3_free(db->lookaside.pStart);
	}
	sqlite3_free(db);
}


SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db, int tripCode) {
	int i;
	int inTrans = 0;
	int schemaChange;
	assert(sqlite3_mutex_held(db->mutex));
	sqlite3BeginBenignMalloc();

	
	sqlite3BtreeEnterAll(db);
	schemaChange = (db->flags & SQLITE_InternChanges) != 0 && db->init.busy == 0;

	for (i = 0; i<db->nDb; i++) {
		Btree *p = db->aDb[i].pBt;
		if (p) {
			if (sqlite3BtreeIsInTrans(p)) {
				inTrans = 1;
			}
			sqlite3BtreeRollback(p, tripCode, !schemaChange);
		}
	}
	sqlite3VtabRollback(db);
	sqlite3EndBenignMalloc();

	if ((db->flags&SQLITE_InternChanges) != 0 && db->init.busy == 0) {
		sqlite3ExpirePreparedStatements(db);
		sqlite3ResetAllSchemasOfConnection(db);
	}
	sqlite3BtreeLeaveAll(db);

	
	db->nDeferredCons = 0;
	db->nDeferredImmCons = 0;
	db->flags &= ~SQLITE_DeferFKs;

	
	if (db->xRollbackCallback && (inTrans || !db->autoCommit)) {
		db->xRollbackCallback(db->pRollbackArg);
	}
}


#if defined(SQLITE_NEED_ERR_NAME)
SQLITE_PRIVATE const char *sqlite3ErrName(int rc) {
	const char *zName = 0;
	int i, origRc = rc;
	for (i = 0; i<2 && zName == 0; i++, rc &= 0xff) {
		switch (rc) {
		case SQLITE_OK:                 zName = "SQLITE_OK";                break;
		case SQLITE_ERROR:              zName = "SQLITE_ERROR";             break;
		case SQLITE_INTERNAL:           zName = "SQLITE_INTERNAL";          break;
		case SQLITE_PERM:               zName = "SQLITE_PERM";              break;
		case SQLITE_ABORT:              zName = "SQLITE_ABORT";             break;
		case SQLITE_ABORT_ROLLBACK:     zName = "SQLITE_ABORT_ROLLBACK";    break;
		case SQLITE_BUSY:               zName = "SQLITE_BUSY";              break;
		case SQLITE_BUSY_RECOVERY:      zName = "SQLITE_BUSY_RECOVERY";     break;
		case SQLITE_BUSY_SNAPSHOT:      zName = "SQLITE_BUSY_SNAPSHOT";     break;
		case SQLITE_LOCKED:             zName = "SQLITE_LOCKED";            break;
		case SQLITE_LOCKED_SHAREDCACHE: zName = "SQLITE_LOCKED_SHAREDCACHE"; break;
		case SQLITE_NOMEM:              zName = "SQLITE_NOMEM";             break;
		case SQLITE_READONLY:           zName = "SQLITE_READONLY";          break;
		case SQLITE_READONLY_RECOVERY:  zName = "SQLITE_READONLY_RECOVERY"; break;
		case SQLITE_READONLY_CANTLOCK:  zName = "SQLITE_READONLY_CANTLOCK"; break;
		case SQLITE_READONLY_ROLLBACK:  zName = "SQLITE_READONLY_ROLLBACK"; break;
		case SQLITE_READONLY_DBMOVED:   zName = "SQLITE_READONLY_DBMOVED";  break;
		case SQLITE_INTERRUPT:          zName = "SQLITE_INTERRUPT";         break;
		case SQLITE_IOERR:              zName = "SQLITE_IOERR";             break;
		case SQLITE_IOERR_READ:         zName = "SQLITE_IOERR_READ";        break;
		case SQLITE_IOERR_SHORT_READ:   zName = "SQLITE_IOERR_SHORT_READ";  break;
		case SQLITE_IOERR_WRITE:        zName = "SQLITE_IOERR_WRITE";       break;
		case SQLITE_IOERR_FSYNC:        zName = "SQLITE_IOERR_FSYNC";       break;
		case SQLITE_IOERR_DIR_FSYNC:    zName = "SQLITE_IOERR_DIR_FSYNC";   break;
		case SQLITE_IOERR_TRUNCATE:     zName = "SQLITE_IOERR_TRUNCATE";    break;
		case SQLITE_IOERR_FSTAT:        zName = "SQLITE_IOERR_FSTAT";       break;
		case SQLITE_IOERR_UNLOCK:       zName = "SQLITE_IOERR_UNLOCK";      break;
		case SQLITE_IOERR_RDLOCK:       zName = "SQLITE_IOERR_RDLOCK";      break;
		case SQLITE_IOERR_DELETE:       zName = "SQLITE_IOERR_DELETE";      break;
		case SQLITE_IOERR_NOMEM:        zName = "SQLITE_IOERR_NOMEM";       break;
		case SQLITE_IOERR_ACCESS:       zName = "SQLITE_IOERR_ACCESS";      break;
		case SQLITE_IOERR_CHECKRESERVEDLOCK:
			zName = "SQLITE_IOERR_CHECKRESERVEDLOCK"; break;
		case SQLITE_IOERR_LOCK:         zName = "SQLITE_IOERR_LOCK";        break;
		case SQLITE_IOERR_CLOSE:        zName = "SQLITE_IOERR_CLOSE";       break;
		case SQLITE_IOERR_DIR_CLOSE:    zName = "SQLITE_IOERR_DIR_CLOSE";   break;
		case SQLITE_IOERR_SHMOPEN:      zName = "SQLITE_IOERR_SHMOPEN";     break;
		case SQLITE_IOERR_SHMSIZE:      zName = "SQLITE_IOERR_SHMSIZE";     break;
		case SQLITE_IOERR_SHMLOCK:      zName = "SQLITE_IOERR_SHMLOCK";     break;
		case SQLITE_IOERR_SHMMAP:       zName = "SQLITE_IOERR_SHMMAP";      break;
		case SQLITE_IOERR_SEEK:         zName = "SQLITE_IOERR_SEEK";        break;
		case SQLITE_IOERR_DELETE_NOENT: zName = "SQLITE_IOERR_DELETE_NOENT"; break;
		case SQLITE_IOERR_MMAP:         zName = "SQLITE_IOERR_MMAP";        break;
		case SQLITE_IOERR_GETTEMPPATH:  zName = "SQLITE_IOERR_GETTEMPPATH"; break;
		case SQLITE_IOERR_CONVPATH:     zName = "SQLITE_IOERR_CONVPATH";    break;
		case SQLITE_CORRUPT:            zName = "SQLITE_CORRUPT";           break;
		case SQLITE_CORRUPT_VTAB:       zName = "SQLITE_CORRUPT_VTAB";      break;
		case SQLITE_NOTFOUND:           zName = "SQLITE_NOTFOUND";          break;
		case SQLITE_FULL:               zName = "SQLITE_FULL";              break;
		case SQLITE_CANTOPEN:           zName = "SQLITE_CANTOPEN";          break;
		case SQLITE_CANTOPEN_NOTEMPDIR: zName = "SQLITE_CANTOPEN_NOTEMPDIR"; break;
		case SQLITE_CANTOPEN_ISDIR:     zName = "SQLITE_CANTOPEN_ISDIR";    break;
		case SQLITE_CANTOPEN_FULLPATH:  zName = "SQLITE_CANTOPEN_FULLPATH"; break;
		case SQLITE_CANTOPEN_CONVPATH:  zName = "SQLITE_CANTOPEN_CONVPATH"; break;
		case SQLITE_PROTOCOL:           zName = "SQLITE_PROTOCOL";          break;
		case SQLITE_EMPTY:              zName = "SQLITE_EMPTY";             break;
		case SQLITE_SCHEMA:             zName = "SQLITE_SCHEMA";            break;
		case SQLITE_TOOBIG:             zName = "SQLITE_TOOBIG";            break;
		case SQLITE_CONSTRAINT:         zName = "SQLITE_CONSTRAINT";        break;
		case SQLITE_CONSTRAINT_UNIQUE:  zName = "SQLITE_CONSTRAINT_UNIQUE"; break;
		case SQLITE_CONSTRAINT_TRIGGER: zName = "SQLITE_CONSTRAINT_TRIGGER"; break;
		case SQLITE_CONSTRAINT_FOREIGNKEY:
			zName = "SQLITE_CONSTRAINT_FOREIGNKEY";   break;
		case SQLITE_CONSTRAINT_CHECK:   zName = "SQLITE_CONSTRAINT_CHECK";  break;
		case SQLITE_CONSTRAINT_PRIMARYKEY:
			zName = "SQLITE_CONSTRAINT_PRIMARYKEY";   break;
		case SQLITE_CONSTRAINT_NOTNULL: zName = "SQLITE_CONSTRAINT_NOTNULL"; break;
		case SQLITE_CONSTRAINT_COMMITHOOK:
			zName = "SQLITE_CONSTRAINT_COMMITHOOK";   break;
		case SQLITE_CONSTRAINT_VTAB:    zName = "SQLITE_CONSTRAINT_VTAB";   break;
		case SQLITE_CONSTRAINT_FUNCTION:
			zName = "SQLITE_CONSTRAINT_FUNCTION";     break;
		case SQLITE_CONSTRAINT_ROWID:   zName = "SQLITE_CONSTRAINT_ROWID";  break;
		case SQLITE_MISMATCH:           zName = "SQLITE_MISMATCH";          break;
		case SQLITE_MISUSE:             zName = "SQLITE_MISUSE";            break;
		case SQLITE_NOLFS:              zName = "SQLITE_NOLFS";             break;
		case SQLITE_AUTH:               zName = "SQLITE_AUTH";              break;
		case SQLITE_FORMAT:             zName = "SQLITE_FORMAT";            break;
		case SQLITE_RANGE:              zName = "SQLITE_RANGE";             break;
		case SQLITE_NOTADB:             zName = "SQLITE_NOTADB";            break;
		case SQLITE_ROW:                zName = "SQLITE_ROW";               break;
		case SQLITE_NOTICE:             zName = "SQLITE_NOTICE";            break;
		case SQLITE_NOTICE_RECOVER_WAL: zName = "SQLITE_NOTICE_RECOVER_WAL"; break;
		case SQLITE_NOTICE_RECOVER_ROLLBACK:
			zName = "SQLITE_NOTICE_RECOVER_ROLLBACK"; break;
		case SQLITE_WARNING:            zName = "SQLITE_WARNING";           break;
		case SQLITE_WARNING_AUTOINDEX:  zName = "SQLITE_WARNING_AUTOINDEX"; break;
		case SQLITE_DONE:               zName = "SQLITE_DONE";              break;
		}
	}
	if (zName == 0) {
		static char zBuf[50];
		sqlite3_snprintf(sizeof(zBuf), zBuf, "SQLITE_UNKNOWN(%d)", origRc);
		zName = zBuf;
	}
	return zName;
}
#endif


SQLITE_PRIVATE const char *sqlite3ErrStr(int rc) {
	static const char* const aMsg[] = {
		 "not an error",
		 "SQL logic error or missing database",
		 0,
		 "access permission denied",
		 "callback requested query abort",
		 "database is locked",
		 "database table is locked",
		 "out of memory",
		 "attempt to write a readonly database",
		 "interrupted",
		 "disk I/O error",
		 "database disk image is malformed",
		 "unknown operation",
		 "database or disk is full",
		 "unable to open database file",
		 "locking protocol",
		 "table contains no data",
		 "database schema has changed",
		 "string or blob too big",
		 "constraint failed",
		 "datatype mismatch",
		 "library routine called out of sequence",
		 "large file support is disabled",
		 "authorization denied",
		 "auxiliary database format error",
		 "bind or column index out of range",
		 "file is encrypted or is not a database",
	};
	const char *zErr = "unknown error";
	switch (rc) {
	case SQLITE_ABORT_ROLLBACK: {
		zErr = "abort due to ROLLBACK";
		break;
	}
	default: {
		rc &= 0xff;
		if (ALWAYS(rc >= 0) && rc<ArraySize(aMsg) && aMsg[rc] != 0) {
			zErr = aMsg[rc];
		}
		break;
	}
	}
	return zErr;
}


static int sqliteDefaultBusyCallback(
	void *ptr,               
	int count                
) {
#if SQLITE_OS_WIN || HAVE_USLEEP
	static const u8 delays[] =
	{ 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };
	static const u8 totals[] =
	{ 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };
# define NDELAY ArraySize(delays)
	sqlite3 *db = (sqlite3 *)ptr;
	int timeout = db->busyTimeout;
	int delay, prior;

	assert(count >= 0);
	if (count < NDELAY) {
		delay = delays[count];
		prior = totals[count];
	}
	else {
		delay = delays[NDELAY - 1];
		prior = totals[NDELAY - 1] + delay*(count - (NDELAY - 1));
	}
	if (prior + delay > timeout) {
		delay = timeout - prior;
		if (delay <= 0) return 0;
	}
	sqlite3OsSleep(db->pVfs, delay * 1000);
	return 1;
#else
	sqlite3 *db = (sqlite3 *)ptr;
	int timeout = ((sqlite3 *)ptr)->busyTimeout;
	if ((count + 1) * 1000 > timeout) {
		return 0;
	}
	sqlite3OsSleep(db->pVfs, 1000000);
	return 1;
#endif
}


SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p) {
	int rc;
	if (NEVER(p == 0) || p->xFunc == 0 || p->nBusy<0) return 0;
	rc = p->xFunc(p->pArg, p->nBusy);
	if (rc == 0) {
		p->nBusy = -1;
	}
	else {
		p->nBusy++;
	}
	return rc;
}


SQLITE_API int sqlite3_busy_handler(
	sqlite3 *db,
	int(*xBusy)(void*, int),
	void *pArg
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	db->busyHandler.xFunc = xBusy;
	db->busyHandler.pArg = pArg;
	db->busyHandler.nBusy = 0;
	db->busyTimeout = 0;
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}

#ifndef SQLITE_OMIT_PROGRESS_CALLBACK

SQLITE_API void sqlite3_progress_handler(
	sqlite3 *db,
	int nOps,
	int(*xProgress)(void*),
	void *pArg
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	if (nOps>0) {
		db->xProgress = xProgress;
		db->nProgressOps = (unsigned)nOps;
		db->pProgressArg = pArg;
	}
	else {
		db->xProgress = 0;
		db->nProgressOps = 0;
		db->pProgressArg = 0;
	}
	sqlite3_mutex_leave(db->mutex);
}
#endif



SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	if (ms>0) {
		sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db);
		db->busyTimeout = ms;
	}
	else {
		sqlite3_busy_handler(db, 0, 0);
	}
	return SQLITE_OK;
}


SQLITE_API void sqlite3_interrupt(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return;
	}
#endif
	db->u1.isInterrupted = 1;
}



SQLITE_PRIVATE int sqlite3CreateFunc(
	sqlite3 *db,
	const char *zFunctionName,
	int nArg,
	int enc,
	void *pUserData,
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value **),
	void(*xStep)(sqlite3_context*, int, sqlite3_value **),
	void(*xFinal)(sqlite3_context*),
	FuncDestructor *pDestructor
) {
	FuncDef *p;
	int nName;
	int extraFlags;

	assert(sqlite3_mutex_held(db->mutex));
	if (zFunctionName == 0 ||
		(xSFunc && (xFinal || xStep)) ||
		(!xSFunc && (xFinal && !xStep)) ||
		(!xSFunc && (!xFinal && xStep)) ||
		(nArg<-1 || nArg>SQLITE_MAX_FUNCTION_ARG) ||
		(255<(nName = sqlite3Strlen30(zFunctionName)))) {
		return SQLITE_MISUSE_BKPT;
	}

	assert(SQLITE_FUNC_CONSTANT == SQLITE_DETERMINISTIC);
	extraFlags = enc &  SQLITE_DETERMINISTIC;
	enc &= (SQLITE_FUNC_ENCMASK | SQLITE_ANY);

#ifndef SQLITE_OMIT_UTF16
	
	if (enc == SQLITE_UTF16) {
		enc = SQLITE_UTF16NATIVE;
	}
	else if (enc == SQLITE_ANY) {
		int rc;
		rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF8 | extraFlags,
			pUserData, xSFunc, xStep, xFinal, pDestructor);
		if (rc == SQLITE_OK) {
			rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF16LE | extraFlags,
				pUserData, xSFunc, xStep, xFinal, pDestructor);
		}
		if (rc != SQLITE_OK) {
			return rc;
		}
		enc = SQLITE_UTF16BE;
	}
#else
	enc = SQLITE_UTF8;
#endif

	
	p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);
	if (p && (p->funcFlags & SQLITE_FUNC_ENCMASK) == enc && p->nArg == nArg) {
		if (db->nVdbeActive) {
			sqlite3ErrorWithMsg(db, SQLITE_BUSY,
				"unable to delete/modify user-function due to active statements");
			assert(!db->mallocFailed);
			return SQLITE_BUSY;
		}
		else {
			sqlite3ExpirePreparedStatements(db);
		}
	}

	p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 1);
	assert(p || db->mallocFailed);
	if (!p) {
		return SQLITE_NOMEM_BKPT;
	}

	
	functionDestroy(db, p);

	if (pDestructor) {
		pDestructor->nRef++;
	}
	p->u.pDestructor = pDestructor;
	p->funcFlags = (p->funcFlags & SQLITE_FUNC_ENCMASK) | extraFlags;
	testcase(p->funcFlags & SQLITE_DETERMINISTIC);
	p->xSFunc = xSFunc ? xSFunc : xStep;
	p->xFinalize = xFinal;
	p->pUserData = pUserData;
	p->nArg = (u16)nArg;
	return SQLITE_OK;
}


SQLITE_API int sqlite3_create_function(
	sqlite3 *db,
	const char *zFunc,
	int nArg,
	int enc,
	void *p,
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value **),
	void(*xStep)(sqlite3_context*, int, sqlite3_value **),
	void(*xFinal)(sqlite3_context*)
) {
	return sqlite3_create_function_v2(db, zFunc, nArg, enc, p, xSFunc, xStep,
		xFinal, 0);
}

SQLITE_API int sqlite3_create_function_v2(
	sqlite3 *db,
	const char *zFunc,
	int nArg,
	int enc,
	void *p,
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value **),
	void(*xStep)(sqlite3_context*, int, sqlite3_value **),
	void(*xFinal)(sqlite3_context*),
	void(*xDestroy)(void *)
) {
	int rc = SQLITE_ERROR;
	FuncDestructor *pArg = 0;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	if (xDestroy) {
		pArg = (FuncDestructor *)sqlite3DbMallocZero(db, sizeof(FuncDestructor));
		if (!pArg) {
			xDestroy(p);
			goto out;
		}
		pArg->xDestroy = xDestroy;
		pArg->pUserData = p;
	}
	rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, pArg);
	if (pArg && pArg->nRef == 0) {
		assert(rc != SQLITE_OK);
		xDestroy(p);
		sqlite3DbFree(db, pArg);
	}

out:
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}

#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_create_function16(
	sqlite3 *db,
	const void *zFunctionName,
	int nArg,
	int eTextRep,
	void *p,
	void(*xSFunc)(sqlite3_context*, int, sqlite3_value**),
	void(*xStep)(sqlite3_context*, int, sqlite3_value**),
	void(*xFinal)(sqlite3_context*)
) {
	int rc;
	char *zFunc8;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zFunctionName == 0) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	assert(!db->mallocFailed);
	zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, SQLITE_UTF16NATIVE);
	rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc, xStep, xFinal, 0);
	sqlite3DbFree(db, zFunc8);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}
#endif



SQLITE_API int sqlite3_overload_function(
	sqlite3 *db,
	const char *zName,
	int nArg
) {
	int rc = SQLITE_OK;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zName == 0 || nArg<-2) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	if (sqlite3FindFunction(db, zName, nArg, SQLITE_UTF8, 0) == 0) {
		rc = sqlite3CreateFunc(db, zName, nArg, SQLITE_UTF8,
			0, sqlite3InvalidFunction, 0, 0, 0);
	}
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}

#ifndef SQLITE_OMIT_TRACE

#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*, const char*), void *pArg) {
	void *pOld;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pOld = db->pTraceArg;
	db->mTrace = xTrace ? SQLITE_TRACE_LEGACY : 0;
	db->xTrace = (int(*)(u32, void*, void*, void*))xTrace;
	db->pTraceArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pOld;
}
#endif 


SQLITE_API int sqlite3_trace_v2(
	sqlite3 *db,                               
	unsigned mTrace,                           
	int(*xTrace)(unsigned, void*, void*, void*),  
	void *pArg                                 
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	if (mTrace == 0) xTrace = 0;
	if (xTrace == 0) mTrace = 0;
	db->mTrace = mTrace;
	db->xTrace = xTrace;
	db->pTraceArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API void *sqlite3_profile(
	sqlite3 *db,
	void(*xProfile)(void*, const char*, sqlite_uint64),
	void *pArg
) {
	void *pOld;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pOld = db->pProfileArg;
	db->xProfile = xProfile;
	db->pProfileArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pOld;
}
#endif 
#endif 


SQLITE_API void *sqlite3_commit_hook(
	sqlite3 *db,              
	int(*xCallback)(void*),  
	void *pArg                
) {
	void *pOld;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pOld = db->pCommitArg;
	db->xCommitCallback = xCallback;
	db->pCommitArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pOld;
}


SQLITE_API void *sqlite3_update_hook(
	sqlite3 *db,              
	void(*xCallback)(void*, int, char const *, char const *, sqlite_int64),
	void *pArg                
) {
	void *pRet;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pRet = db->pUpdateArg;
	db->xUpdateCallback = xCallback;
	db->pUpdateArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pRet;
}


SQLITE_API void *sqlite3_rollback_hook(
	sqlite3 *db,              
	void(*xCallback)(void*), 
	void *pArg                
) {
	void *pRet;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pRet = db->pRollbackArg;
	db->xRollbackCallback = xCallback;
	db->pRollbackArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pRet;
}

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

SQLITE_API void *sqlite3_preupdate_hook(
	sqlite3 *db,              
	void(*xCallback)(         
		void*, sqlite3*, int, char const*, char const*, sqlite3_int64, sqlite3_int64),
	void *pArg                
) {
	void *pRet;
	sqlite3_mutex_enter(db->mutex);
	pRet = db->pPreUpdateArg;
	db->xPreUpdateCallback = xCallback;
	db->pPreUpdateArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pRet;
}
#endif 

#ifndef SQLITE_OMIT_WAL

SQLITE_PRIVATE int sqlite3WalDefaultHook(
	void *pClientData,     
	sqlite3 *db,           
	const char *zDb,       
	int nFrame             
) {
	if (nFrame >= SQLITE_PTR_TO_INT(pClientData)) {
		sqlite3BeginBenignMalloc();
		sqlite3_wal_checkpoint(db, zDb);
		sqlite3EndBenignMalloc();
	}
	return SQLITE_OK;
}
#endif 


SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame) {
#ifdef SQLITE_OMIT_WAL
	UNUSED_PARAMETER(db);
	UNUSED_PARAMETER(nFrame);
#else
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	if (nFrame>0) {
		sqlite3_wal_hook(db, sqlite3WalDefaultHook, SQLITE_INT_TO_PTR(nFrame));
	}
	else {
		sqlite3_wal_hook(db, 0, 0);
	}
#endif
	return SQLITE_OK;
}


SQLITE_API void *sqlite3_wal_hook(
	sqlite3 *db,                    
	int(*xCallback)(void *, sqlite3*, const char*, int),
	void *pArg                      
) {
#ifndef SQLITE_OMIT_WAL
	void *pRet;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	pRet = db->pWalArg;
	db->xWalCallback = xCallback;
	db->pWalArg = pArg;
	sqlite3_mutex_leave(db->mutex);
	return pRet;
#else
	return 0;
#endif
}


SQLITE_API int sqlite3_wal_checkpoint_v2(
	sqlite3 *db,                    
	const char *zDb,                
	int eMode,                      
	int *pnLog,                     
	int *pnCkpt                     
) {
#ifdef SQLITE_OMIT_WAL
	return SQLITE_OK;
#else
	int rc;                         
	int iDb = SQLITE_MAX_ATTACHED;  

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif

	
	if (pnLog) *pnLog = -1;
	if (pnCkpt) *pnCkpt = -1;

	assert(SQLITE_CHECKPOINT_PASSIVE == 0);
	assert(SQLITE_CHECKPOINT_FULL == 1);
	assert(SQLITE_CHECKPOINT_RESTART == 2);
	assert(SQLITE_CHECKPOINT_TRUNCATE == 3);
	if (eMode<SQLITE_CHECKPOINT_PASSIVE || eMode>SQLITE_CHECKPOINT_TRUNCATE) {
		
		return SQLITE_MISUSE;
	}

	sqlite3_mutex_enter(db->mutex);
	if (zDb && zDb[0]) {
		iDb = sqlite3FindDbName(db, zDb);
	}
	if (iDb<0) {
		rc = SQLITE_ERROR;
		sqlite3ErrorWithMsg(db, SQLITE_ERROR, "unknown database: %s", zDb);
	}
	else {
		db->busyHandler.nBusy = 0;
		rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
		sqlite3Error(db, rc);
	}
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
#endif
}



SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb) {
	
	return sqlite3_wal_checkpoint_v2(db, zDb, SQLITE_CHECKPOINT_PASSIVE, 0, 0);
}

#ifndef SQLITE_OMIT_WAL

SQLITE_PRIVATE int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt) {
	int rc = SQLITE_OK;             
	int i;                          
	int bBusy = 0;                  

	assert(sqlite3_mutex_held(db->mutex));
	assert(!pnLog || *pnLog == -1);
	assert(!pnCkpt || *pnCkpt == -1);

	for (i = 0; i<db->nDb && rc == SQLITE_OK; i++) {
		if (i == iDb || iDb == SQLITE_MAX_ATTACHED) {
			rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);
			pnLog = 0;
			pnCkpt = 0;
			if (rc == SQLITE_BUSY) {
				bBusy = 1;
				rc = SQLITE_OK;
			}
		}
	}

	return (rc == SQLITE_OK && bBusy) ? SQLITE_BUSY : rc;
}
#endif 


SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3 *db) {
#if SQLITE_TEMP_STORE==1
	return (db->temp_store == 2);
#endif
#if SQLITE_TEMP_STORE==2
	return (db->temp_store != 1);
#endif
#if SQLITE_TEMP_STORE==3
	UNUSED_PARAMETER(db);
	return 1;
#endif
#if SQLITE_TEMP_STORE<1 || SQLITE_TEMP_STORE>3
	UNUSED_PARAMETER(db);
	return 0;
#endif
}


SQLITE_API const char *sqlite3_errmsg(sqlite3 *db) {
	const char *z;
	if (!db) {
		return sqlite3ErrStr(SQLITE_NOMEM_BKPT);
	}
	if (!sqlite3SafetyCheckSickOrOk(db)) {
		return sqlite3ErrStr(SQLITE_MISUSE_BKPT);
	}
	sqlite3_mutex_enter(db->mutex);
	if (db->mallocFailed) {
		z = sqlite3ErrStr(SQLITE_NOMEM_BKPT);
	}
	else {
		testcase(db->pErr == 0);
		z = (char*)sqlite3_value_text(db->pErr);
		assert(!db->mallocFailed);
		if (z == 0) {
			z = sqlite3ErrStr(db->errCode);
		}
	}
	sqlite3_mutex_leave(db->mutex);
	return z;
}

#ifndef SQLITE_OMIT_UTF16

SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db) {
	static const u16 outOfMem[] = {
		'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
	};
	static const u16 misuse[] = {
		'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ',
		'r', 'o', 'u', 't', 'i', 'n', 'e', ' ',
		'c', 'a', 'l', 'l', 'e', 'd', ' ',
		'o', 'u', 't', ' ',
		'o', 'f', ' ',
		's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0
	};

	const void *z;
	if (!db) {
		return (void *)outOfMem;
	}
	if (!sqlite3SafetyCheckSickOrOk(db)) {
		return (void *)misuse;
	}
	sqlite3_mutex_enter(db->mutex);
	if (db->mallocFailed) {
		z = (void *)outOfMem;
	}
	else {
		z = sqlite3_value_text16(db->pErr);
		if (z == 0) {
			sqlite3ErrorWithMsg(db, db->errCode, sqlite3ErrStr(db->errCode));
			z = sqlite3_value_text16(db->pErr);
		}
		
		sqlite3OomClear(db);
	}
	sqlite3_mutex_leave(db->mutex);
	return z;
}
#endif 


SQLITE_API int sqlite3_errcode(sqlite3 *db) {
	if (db && !sqlite3SafetyCheckSickOrOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
	if (!db || db->mallocFailed) {
		return SQLITE_NOMEM_BKPT;
	}
	return db->errCode & db->errMask;
}
SQLITE_API int sqlite3_extended_errcode(sqlite3 *db) {
	if (db && !sqlite3SafetyCheckSickOrOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
	if (!db || db->mallocFailed) {
		return SQLITE_NOMEM_BKPT;
	}
	return db->errCode;
}
SQLITE_API int sqlite3_system_errno(sqlite3 *db) {
	return db ? db->iSysErrno : 0;
}


SQLITE_API const char *sqlite3_errstr(int rc) {
	return sqlite3ErrStr(rc);
}


static int createCollation(
	sqlite3* db,
	const char *zName,
	u8 enc,
	void* pCtx,
	int(*xCompare)(void*, int, const void*, int, const void*),
	void(*xDel)(void*)
) {
	CollSeq *pColl;
	int enc2;

	assert(sqlite3_mutex_held(db->mutex));

	
	enc2 = enc;
	testcase(enc2 == SQLITE_UTF16);
	testcase(enc2 == SQLITE_UTF16_ALIGNED);
	if (enc2 == SQLITE_UTF16 || enc2 == SQLITE_UTF16_ALIGNED) {
		enc2 = SQLITE_UTF16NATIVE;
	}
	if (enc2<SQLITE_UTF8 || enc2>SQLITE_UTF16BE) {
		return SQLITE_MISUSE_BKPT;
	}

	
	pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);
	if (pColl && pColl->xCmp) {
		if (db->nVdbeActive) {
			sqlite3ErrorWithMsg(db, SQLITE_BUSY,
				"unable to delete/modify collation sequence due to active statements");
			return SQLITE_BUSY;
		}
		sqlite3ExpirePreparedStatements(db);

		
		if ((pColl->enc & ~SQLITE_UTF16_ALIGNED) == enc2) {
			CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);
			int j;
			for (j = 0; j<3; j++) {
				CollSeq *p = &aColl[j];
				if (p->enc == pColl->enc) {
					if (p->xDel) {
						p->xDel(p->pUser);
					}
					p->xCmp = 0;
				}
			}
		}
	}

	pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);
	if (pColl == 0) return SQLITE_NOMEM_BKPT;
	pColl->xCmp = xCompare;
	pColl->pUser = pCtx;
	pColl->xDel = xDel;
	pColl->enc = (u8)(enc2 | (enc & SQLITE_UTF16_ALIGNED));
	sqlite3Error(db, SQLITE_OK);
	return SQLITE_OK;
}



static const int aHardLimit[] = {
	SQLITE_MAX_LENGTH,
	SQLITE_MAX_SQL_LENGTH,
	SQLITE_MAX_COLUMN,
	SQLITE_MAX_EXPR_DEPTH,
	SQLITE_MAX_COMPOUND_SELECT,
	SQLITE_MAX_VDBE_OP,
	SQLITE_MAX_FUNCTION_ARG,
	SQLITE_MAX_ATTACHED,
	SQLITE_MAX_LIKE_PATTERN_LENGTH,
	SQLITE_MAX_VARIABLE_NUMBER,      
	SQLITE_MAX_TRIGGER_DEPTH,
	SQLITE_MAX_WORKER_THREADS,
};


#if SQLITE_MAX_LENGTH<100
# error SQLITE_MAX_LENGTH must be at least 100
#endif
#if SQLITE_MAX_SQL_LENGTH<100
# error SQLITE_MAX_SQL_LENGTH must be at least 100
#endif
#if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH
# error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH
#endif
#if SQLITE_MAX_COMPOUND_SELECT<2
# error SQLITE_MAX_COMPOUND_SELECT must be at least 2
#endif
#if SQLITE_MAX_VDBE_OP<40
# error SQLITE_MAX_VDBE_OP must be at least 40
#endif
#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>127
# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 127
#endif
#if SQLITE_MAX_ATTACHED<0 || SQLITE_MAX_ATTACHED>125
# error SQLITE_MAX_ATTACHED must be between 0 and 125
#endif
#if SQLITE_MAX_LIKE_PATTERN_LENGTH<1
# error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1
#endif
#if SQLITE_MAX_COLUMN>32767
# error SQLITE_MAX_COLUMN must not exceed 32767
#endif
#if SQLITE_MAX_TRIGGER_DEPTH<1
# error SQLITE_MAX_TRIGGER_DEPTH must be at least 1
#endif
#if SQLITE_MAX_WORKER_THREADS<0 || SQLITE_MAX_WORKER_THREADS>50
# error SQLITE_MAX_WORKER_THREADS must be between 0 and 50
#endif



SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit) {
	int oldLimit;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return -1;
	}
#endif

	
	assert(aHardLimit[SQLITE_LIMIT_LENGTH] == SQLITE_MAX_LENGTH);
	assert(aHardLimit[SQLITE_LIMIT_SQL_LENGTH] == SQLITE_MAX_SQL_LENGTH);
	assert(aHardLimit[SQLITE_LIMIT_COLUMN] == SQLITE_MAX_COLUMN);
	assert(aHardLimit[SQLITE_LIMIT_EXPR_DEPTH] == SQLITE_MAX_EXPR_DEPTH);
	assert(aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT] == SQLITE_MAX_COMPOUND_SELECT);
	assert(aHardLimit[SQLITE_LIMIT_VDBE_OP] == SQLITE_MAX_VDBE_OP);
	assert(aHardLimit[SQLITE_LIMIT_FUNCTION_ARG] == SQLITE_MAX_FUNCTION_ARG);
	assert(aHardLimit[SQLITE_LIMIT_ATTACHED] == SQLITE_MAX_ATTACHED);
	assert(aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ==
		SQLITE_MAX_LIKE_PATTERN_LENGTH);
	assert(aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER] == SQLITE_MAX_VARIABLE_NUMBER);
	assert(aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH] == SQLITE_MAX_TRIGGER_DEPTH);
	assert(aHardLimit[SQLITE_LIMIT_WORKER_THREADS] == SQLITE_MAX_WORKER_THREADS);
	assert(SQLITE_LIMIT_WORKER_THREADS == (SQLITE_N_LIMIT - 1));


	if (limitId<0 || limitId >= SQLITE_N_LIMIT) {
		return -1;
	}
	oldLimit = db->aLimit[limitId];
	if (newLimit >= 0) {                   
		if (newLimit>aHardLimit[limitId]) {
			newLimit = aHardLimit[limitId];  
		}
		db->aLimit[limitId] = newLimit;
	}
	return oldLimit;                     
}


SQLITE_PRIVATE int sqlite3ParseUri(
	const char *zDefaultVfs,        
	const char *zUri,               
	unsigned int *pFlags,           
	sqlite3_vfs **ppVfs,            
	char **pzFile,                  
	char **pzErrMsg                 
) {
	int rc = SQLITE_OK;
	unsigned int flags = *pFlags;
	const char *zVfs = zDefaultVfs;
	char *zFile;
	char c;
	int nUri = sqlite3Strlen30(zUri);

	assert(*pzErrMsg == 0);

	if (((flags & SQLITE_OPEN_URI)             
		|| sqlite3GlobalConfig.bOpenUri) 
		&& nUri >= 5 && memcmp(zUri, "file:", 5) == 0 
		) {
		char *zOpt;
		int eState;                   
		int iIn;                      
		int iOut = 0;                 
		u64 nByte = nUri + 2;           

										
		flags |= SQLITE_OPEN_URI;

		for (iIn = 0; iIn<nUri; iIn++) nByte += (zUri[iIn] == '&');
		zFile = sqlite3_malloc64(nByte);
		if (!zFile) return SQLITE_NOMEM_BKPT;

		iIn = 5;
#ifdef SQLITE_ALLOW_URI_AUTHORITY
		if (strncmp(zUri + 5, "///", 3) == 0) {
			iIn = 7;
			
			if (strncmp(zUri + 7, "///", 3) == 0) { iIn++; }
		}
		else if (strncmp(zUri + 5, "//localhost/", 12) == 0) {
			iIn = 16;
		}
#else
		
		if (zUri[5] == '/' && zUri[6] == '/') {
			iIn = 7;
			while (zUri[iIn] && zUri[iIn] != '/') iIn++;
			if (iIn != 7 && (iIn != 16 || memcmp("localhost", &zUri[7], 9))) {
				*pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s",
					iIn - 7, &zUri[7]);
				rc = SQLITE_ERROR;
				goto parse_uri_out;
			}
		}
#endif

		
		eState = 0;
		while ((c = zUri[iIn]) != 0 && c != '#') {
			iIn++;
			if (c == '%'
				&& sqlite3Isxdigit(zUri[iIn])
				&& sqlite3Isxdigit(zUri[iIn + 1])
				) {
				int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);
				octet += sqlite3HexToInt(zUri[iIn++]);

				assert(octet >= 0 && octet<256);
				if (octet == 0) {
					
					while ((c = zUri[iIn]) != 0 && c != '#'
						&& (eState != 0 || c != '?')
						&& (eState != 1 || (c != '=' && c != '&'))
						&& (eState != 2 || c != '&')
						) {
						iIn++;
					}
					continue;
				}
				c = octet;
			}
			else if (eState == 1 && (c == '&' || c == '=')) {
				if (zFile[iOut - 1] == 0) {
					
					while (zUri[iIn] && zUri[iIn] != '#' && zUri[iIn - 1] != '&') iIn++;
					continue;
				}
				if (c == '&') {
					zFile[iOut++] = '\0';
				}
				else {
					eState = 2;
				}
				c = 0;
			}
			else if ((eState == 0 && c == '?') || (eState == 2 && c == '&')) {
				c = 0;
				eState = 1;
			}
			zFile[iOut++] = c;
		}
		if (eState == 1) zFile[iOut++] = '\0';
		zFile[iOut++] = '\0';
		zFile[iOut++] = '\0';

		
		zOpt = &zFile[sqlite3Strlen30(zFile) + 1];
		while (zOpt[0]) {
			int nOpt = sqlite3Strlen30(zOpt);
			char *zVal = &zOpt[nOpt + 1];
			int nVal = sqlite3Strlen30(zVal);

			if (nOpt == 3 && memcmp("vfs", zOpt, 3) == 0) {
				zVfs = zVal;
			}
			else {
				struct OpenMode {
					const char *z;
					int mode;
				} *aMode = 0;
				char *zModeType = 0;
				int mask = 0;
				int limit = 0;

				if (nOpt == 5 && memcmp("cache", zOpt, 5) == 0) {
					static struct OpenMode aCacheMode[] = {
						{ "shared",  SQLITE_OPEN_SHAREDCACHE },
						{ "private", SQLITE_OPEN_PRIVATECACHE },
						{ 0, 0 }
					};

					mask = SQLITE_OPEN_SHAREDCACHE | SQLITE_OPEN_PRIVATECACHE;
					aMode = aCacheMode;
					limit = mask;
					zModeType = "cache";
				}
				if (nOpt == 4 && memcmp("mode", zOpt, 4) == 0) {
					static struct OpenMode aOpenMode[] = {
						{ "ro",  SQLITE_OPEN_READONLY },
						{ "rw",  SQLITE_OPEN_READWRITE },
						{ "rwc", SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE },
						{ "memory", SQLITE_OPEN_MEMORY },
						{ 0, 0 }
					};

					mask = SQLITE_OPEN_READONLY | SQLITE_OPEN_READWRITE
						| SQLITE_OPEN_CREATE | SQLITE_OPEN_MEMORY;
					aMode = aOpenMode;
					limit = mask & flags;
					zModeType = "access";
				}

				if (aMode) {
					int i;
					int mode = 0;
					for (i = 0; aMode[i].z; i++) {
						const char *z = aMode[i].z;
						if (nVal == sqlite3Strlen30(z) && 0 == memcmp(zVal, z, nVal)) {
							mode = aMode[i].mode;
							break;
						}
					}
					if (mode == 0) {
						*pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
						rc = SQLITE_ERROR;
						goto parse_uri_out;
					}
					if ((mode & ~SQLITE_OPEN_MEMORY)>limit) {
						*pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s",
							zModeType, zVal);
						rc = SQLITE_PERM;
						goto parse_uri_out;
					}
					flags = (flags & ~mask) | mode;
				}
			}

			zOpt = &zVal[nVal + 1];
		}

	}
	else {
		zFile = sqlite3_malloc64(nUri + 2);
		if (!zFile) return SQLITE_NOMEM_BKPT;
		memcpy(zFile, zUri, nUri);
		zFile[nUri] = '\0';
		zFile[nUri + 1] = '\0';
		flags &= ~SQLITE_OPEN_URI;
	}

	*ppVfs = sqlite3_vfs_find(zVfs);
	if (*ppVfs == 0) {
		*pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
		rc = SQLITE_ERROR;
	}
parse_uri_out:
	if (rc != SQLITE_OK) {
		sqlite3_free(zFile);
		zFile = 0;
	}
	*pFlags = flags;
	*pzFile = zFile;
	return rc;
}



static int openDatabase(
	const char *zFilename, 
	sqlite3 **ppDb,        
	unsigned int flags,    
	const char *zVfs       
) {
	sqlite3 *db;                    
	int rc;                         
	int isThreadsafe;               
	char *zOpen = 0;                
	char *zErrMsg = 0;              

#ifdef SQLITE_ENABLE_API_ARMOR
	if (ppDb == 0) return SQLITE_MISUSE_BKPT;
#endif
	*ppDb = 0;
#ifndef SQLITE_OMIT_AUTOINIT
	rc = sqlite3_initialize();
	if (rc) return rc;
#endif

	
	assert(SQLITE_OPEN_READONLY == 0x01);
	assert(SQLITE_OPEN_READWRITE == 0x02);
	assert(SQLITE_OPEN_CREATE == 0x04);
	testcase((1 << (flags & 7)) == 0x02); 
	testcase((1 << (flags & 7)) == 0x04); 
	testcase((1 << (flags & 7)) == 0x40); 
	if (((1 << (flags & 7)) & 0x46) == 0) {
		return SQLITE_MISUSE_BKPT;  
	}

	if (sqlite3GlobalConfig.bCoreMutex == 0) {
		isThreadsafe = 0;
	}
	else if (flags & SQLITE_OPEN_NOMUTEX) {
		isThreadsafe = 0;
	}
	else if (flags & SQLITE_OPEN_FULLMUTEX) {
		isThreadsafe = 1;
	}
	else {
		isThreadsafe = sqlite3GlobalConfig.bFullMutex;
	}
	if (flags & SQLITE_OPEN_PRIVATECACHE) {
		flags &= ~SQLITE_OPEN_SHAREDCACHE;
	}
	else if (sqlite3GlobalConfig.sharedCacheEnabled) {
		flags |= SQLITE_OPEN_SHAREDCACHE;
	}

	
	flags &= ~(SQLITE_OPEN_DELETEONCLOSE |
		SQLITE_OPEN_EXCLUSIVE |
		SQLITE_OPEN_MAIN_DB |
		SQLITE_OPEN_TEMP_DB |
		SQLITE_OPEN_TRANSIENT_DB |
		SQLITE_OPEN_MAIN_JOURNAL |
		SQLITE_OPEN_TEMP_JOURNAL |
		SQLITE_OPEN_SUBJOURNAL |
		SQLITE_OPEN_MASTER_JOURNAL |
		SQLITE_OPEN_NOMUTEX |
		SQLITE_OPEN_FULLMUTEX |
		SQLITE_OPEN_WAL
		);

	
	db = sqlite3MallocZero(sizeof(sqlite3));
	if (db == 0) goto opendb_out;
	if (isThreadsafe) {
		db->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);
		if (db->mutex == 0) {
			sqlite3_free(db);
			db = 0;
			goto opendb_out;
		}
	}
	sqlite3_mutex_enter(db->mutex);
	db->errMask = 0xff;
	db->nDb = 2;
	db->magic = SQLITE_MAGIC_BUSY;
	db->aDb = db->aDbStatic;

	assert(sizeof(db->aLimit) == sizeof(aHardLimit));
	memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
	db->aLimit[SQLITE_LIMIT_WORKER_THREADS] = SQLITE_DEFAULT_WORKER_THREADS;
	db->autoCommit = 1;
	db->nextAutovac = -1;
	db->szMmap = sqlite3GlobalConfig.szMmap;
	db->nextPagesize = 0;
	db->nMaxSorterMmap = 0x7FFFFFFF;
	db->flags |= SQLITE_ShortColNames | SQLITE_EnableTrigger | SQLITE_CacheSpill
#if !defined(SQLITE_DEFAULT_AUTOMATIC_INDEX) || SQLITE_DEFAULT_AUTOMATIC_INDEX
		| SQLITE_AutoIndex
#endif
#if SQLITE_DEFAULT_CKPTFULLFSYNC
		| SQLITE_CkptFullFSync
#endif
#if SQLITE_DEFAULT_FILE_FORMAT<4
		| SQLITE_LegacyFileFmt
#endif
#ifdef SQLITE_ENABLE_LOAD_EXTENSION
		| SQLITE_LoadExtension
#endif
#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS
		| SQLITE_RecTriggers
#endif
#if defined(SQLITE_DEFAULT_FOREIGN_KEYS) && SQLITE_DEFAULT_FOREIGN_KEYS
		| SQLITE_ForeignKeys
#endif
#if defined(SQLITE_REVERSE_UNORDERED_SELECTS)
		| SQLITE_ReverseOrder
#endif
#if defined(SQLITE_ENABLE_OVERSIZE_CELL_CHECK)
		| SQLITE_CellSizeCk
#endif
#if defined(SQLITE_ENABLE_FTS3_TOKENIZER)
		| SQLITE_Fts3Tokenizer
#endif
		;
	sqlite3HashInit(&db->aCollSeq);
#ifndef SQLITE_OMIT_VIRTUALTABLE
	sqlite3HashInit(&db->aModule);
#endif

	
	createCollation(db, sqlite3StrBINARY, SQLITE_UTF8, 0, binCollFunc, 0);
	createCollation(db, sqlite3StrBINARY, SQLITE_UTF16BE, 0, binCollFunc, 0);
	createCollation(db, sqlite3StrBINARY, SQLITE_UTF16LE, 0, binCollFunc, 0);
	createCollation(db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, 0);
	createCollation(db, "RTRIM", SQLITE_UTF8, (void*)1, binCollFunc, 0);
	if (db->mallocFailed) {
		goto opendb_out;
	}
	
	db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, sqlite3StrBINARY, 0);
	assert(db->pDfltColl != 0);

	
	db->openFlags = flags;
	rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);
	if (rc != SQLITE_OK) {
		if (rc == SQLITE_NOMEM) sqlite3OomFault(db);
		sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);
		sqlite3_free(zErrMsg);
		goto opendb_out;
	}

	
	rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0,
		flags | SQLITE_OPEN_MAIN_DB);
	if (rc != SQLITE_OK) {
		if (rc == SQLITE_IOERR_NOMEM) {
			rc = SQLITE_NOMEM_BKPT;
		}
		sqlite3Error(db, rc);
		goto opendb_out;
	}
	sqlite3BtreeEnter(db->aDb[0].pBt);
	db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);
	if (!db->mallocFailed) ENC(db) = SCHEMA_ENC(db);
	sqlite3BtreeLeave(db->aDb[0].pBt);
	db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);

	
	db->aDb[0].zDbSName = "main";
	db->aDb[0].safety_level = SQLITE_DEFAULT_SYNCHRONOUS + 1;
	db->aDb[1].zDbSName = "temp";
	db->aDb[1].safety_level = PAGER_SYNCHRONOUS_OFF;

	db->magic = SQLITE_MAGIC_OPEN;
	if (db->mallocFailed) {
		goto opendb_out;
	}

	
	sqlite3Error(db, SQLITE_OK);
	sqlite3RegisterPerConnectionBuiltinFunctions(db);
	rc = sqlite3_errcode(db);

#ifdef SQLITE_ENABLE_FTS5
	
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3Fts5Init(db);
	}
#endif

	
	if (rc == SQLITE_OK) {
		sqlite3AutoLoadExtensions(db);
		rc = sqlite3_errcode(db);
		if (rc != SQLITE_OK) {
			goto opendb_out;
		}
	}

#ifdef SQLITE_ENABLE_FTS1
	if (!db->mallocFailed) {
		extern int sqlite3Fts1Init(sqlite3*);
		rc = sqlite3Fts1Init(db);
	}
#endif

#ifdef SQLITE_ENABLE_FTS2
	if (!db->mallocFailed && rc == SQLITE_OK) {
		extern int sqlite3Fts2Init(sqlite3*);
		rc = sqlite3Fts2Init(db);
	}
#endif

#ifdef SQLITE_ENABLE_FTS3 
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3Fts3Init(db);
	}
#endif

#ifdef SQLITE_ENABLE_ICU
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3IcuInit(db);
	}
#endif

#ifdef SQLITE_ENABLE_RTREE
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3RtreeInit(db);
	}
#endif

#ifdef SQLITE_ENABLE_DBSTAT_VTAB
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3DbstatRegister(db);
	}
#endif

#ifdef SQLITE_ENABLE_JSON1
	if (!db->mallocFailed && rc == SQLITE_OK) {
		rc = sqlite3Json1Init(db);
	}
#endif

	
#ifdef SQLITE_DEFAULT_LOCKING_MODE
	db->dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE;
	sqlite3PagerLockingMode(sqlite3BtreePager(db->aDb[0].pBt),
		SQLITE_DEFAULT_LOCKING_MODE);
#endif

	if (rc) sqlite3Error(db, rc);

	
	setupLookaside(db, 0, sqlite3GlobalConfig.szLookaside,
		sqlite3GlobalConfig.nLookaside);

	sqlite3_wal_autocheckpoint(db, SQLITE_DEFAULT_WAL_AUTOCHECKPOINT);

opendb_out:
	if (db) {
		assert(db->mutex != 0 || isThreadsafe == 0
			|| sqlite3GlobalConfig.bFullMutex == 0);
		sqlite3_mutex_leave(db->mutex);
	}
	rc = sqlite3_errcode(db);
	assert(db != 0 || rc == SQLITE_NOMEM);
	if (rc == SQLITE_NOMEM) {
		sqlite3_close(db);
		db = 0;
	}
	else if (rc != SQLITE_OK) {
		db->magic = SQLITE_MAGIC_SICK;
	}
	*ppDb = db;
#ifdef SQLITE_ENABLE_SQLLOG
	if (sqlite3GlobalConfig.xSqllog) {
		
		void *pArg = sqlite3GlobalConfig.pSqllogArg;
		sqlite3GlobalConfig.xSqllog(pArg, db, zFilename, 0);
	}
#endif
#if defined(SQLITE_HAS_CODEC)
	if (rc == SQLITE_OK) {
		const char *zHexKey = sqlite3_uri_parameter(zOpen, "hexkey");
		if (zHexKey && zHexKey[0]) {
			u8 iByte;
			int i;
			char zKey[40];
			for (i = 0, iByte = 0; i<sizeof(zKey) * 2 && sqlite3Isxdigit(zHexKey[i]); i++) {
				iByte = (iByte << 4) + sqlite3HexToInt(zHexKey[i]);
				if ((i & 1) != 0) zKey[i / 2] = iByte;
			}
			sqlite3_key_v2(db, 0, zKey, i / 2);
		}
	}
#endif
	sqlite3_free(zOpen);
	return rc & 0xff;
}


SQLITE_API int sqlite3_open(
	const char *zFilename,
	sqlite3 **ppDb
) {
	return openDatabase(zFilename, ppDb,
		SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);
}
SQLITE_API int sqlite3_open_v2(
	const char *filename,   
	sqlite3 **ppDb,         
	int flags,              
	const char *zVfs        
) {
	return openDatabase(filename, ppDb, (unsigned int)flags, zVfs);
}

#ifndef SQLITE_OMIT_UTF16

SQLITE_API int sqlite3_open16(
	const void *zFilename,
	sqlite3 **ppDb
) {
	char const *zFilename8;   
	sqlite3_value *pVal;
	int rc;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (ppDb == 0) return SQLITE_MISUSE_BKPT;
#endif
	*ppDb = 0;
#ifndef SQLITE_OMIT_AUTOINIT
	rc = sqlite3_initialize();
	if (rc) return rc;
#endif
	if (zFilename == 0) zFilename = "\000\000";
	pVal = sqlite3ValueNew(0);
	sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC);
	zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8);
	if (zFilename8) {
		rc = openDatabase(zFilename8, ppDb,
			SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);
		assert(*ppDb || rc == SQLITE_NOMEM);
		if (rc == SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded)) {
			SCHEMA_ENC(*ppDb) = ENC(*ppDb) = SQLITE_UTF16NATIVE;
		}
	}
	else {
		rc = SQLITE_NOMEM_BKPT;
	}
	sqlite3ValueFree(pVal);

	return rc & 0xff;
}
#endif 


SQLITE_API int sqlite3_create_collation(
	sqlite3* db,
	const char *zName,
	int enc,
	void* pCtx,
	int(*xCompare)(void*, int, const void*, int, const void*)
) {
	return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, 0);
}


SQLITE_API int sqlite3_create_collation_v2(
	sqlite3* db,
	const char *zName,
	int enc,
	void* pCtx,
	int(*xCompare)(void*, int, const void*, int, const void*),
	void(*xDel)(void*)
) {
	int rc;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zName == 0) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	assert(!db->mallocFailed);
	rc = createCollation(db, zName, (u8)enc, pCtx, xCompare, xDel);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}

#ifndef SQLITE_OMIT_UTF16

SQLITE_API int sqlite3_create_collation16(
	sqlite3* db,
	const void *zName,
	int enc,
	void* pCtx,
	int(*xCompare)(void*, int, const void*, int, const void*)
) {
	int rc = SQLITE_OK;
	char *zName8;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zName == 0) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	assert(!db->mallocFailed);
	zName8 = sqlite3Utf16to8(db, zName, -1, SQLITE_UTF16NATIVE);
	if (zName8) {
		rc = createCollation(db, zName8, (u8)enc, pCtx, xCompare, 0);
		sqlite3DbFree(db, zName8);
	}
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}
#endif 


SQLITE_API int sqlite3_collation_needed(
	sqlite3 *db,
	void *pCollNeededArg,
	void(*xCollNeeded)(void*, sqlite3*, int eTextRep, const char*)
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	db->xCollNeeded = xCollNeeded;
	db->xCollNeeded16 = 0;
	db->pCollNeededArg = pCollNeededArg;
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}

#ifndef SQLITE_OMIT_UTF16

SQLITE_API int sqlite3_collation_needed16(
	sqlite3 *db,
	void *pCollNeededArg,
	void(*xCollNeeded16)(void*, sqlite3*, int eTextRep, const void*)
) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	db->xCollNeeded = 0;
	db->xCollNeeded16 = xCollNeeded16;
	db->pCollNeededArg = pCollNeededArg;
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}
#endif 

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API int sqlite3_global_recover(void) {
	return SQLITE_OK;
}
#endif


SQLITE_API int sqlite3_get_autocommit(sqlite3 *db) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	return db->autoCommit;
}


static int reportError(int iErr, int lineno, const char *zType) {
	sqlite3_log(iErr, "%s at line %d of [%.10s]",
		zType, lineno, 20 + sqlite3_sourceid());
	return iErr;
}
SQLITE_PRIVATE int sqlite3CorruptError(int lineno) {
	testcase(sqlite3GlobalConfig.xLog != 0);
	return reportError(SQLITE_CORRUPT, lineno, "database corruption");
}
SQLITE_PRIVATE int sqlite3MisuseError(int lineno) {
	testcase(sqlite3GlobalConfig.xLog != 0);
	return reportError(SQLITE_MISUSE, lineno, "misuse");
}
SQLITE_PRIVATE int sqlite3CantopenError(int lineno) {
	testcase(sqlite3GlobalConfig.xLog != 0);
	return reportError(SQLITE_CANTOPEN, lineno, "cannot open file");
}
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NomemError(int lineno) {
	testcase(sqlite3GlobalConfig.xLog != 0);
	return reportError(SQLITE_NOMEM, lineno, "OOM");
}
SQLITE_PRIVATE int sqlite3IoerrnomemError(int lineno) {
	testcase(sqlite3GlobalConfig.xLog != 0);
	return reportError(SQLITE_IOERR_NOMEM, lineno, "I/O OOM error");
}
#endif

#ifndef SQLITE_OMIT_DEPRECATED

SQLITE_API void sqlite3_thread_cleanup(void) {
}
#endif


SQLITE_API int sqlite3_table_column_metadata(
	sqlite3 *db,                
	const char *zDbName,        
	const char *zTableName,     
	const char *zColumnName,    
	char const **pzDataType,    
	char const **pzCollSeq,     
	int *pNotNull,              
	int *pPrimaryKey,           
	int *pAutoinc               
) {
	int rc;
	char *zErrMsg = 0;
	Table *pTab = 0;
	Column *pCol = 0;
	int iCol = 0;
	char const *zDataType = 0;
	char const *zCollSeq = 0;
	int notnull = 0;
	int primarykey = 0;
	int autoinc = 0;


#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db) || zTableName == 0) {
		return SQLITE_MISUSE_BKPT;
	}
#endif

	
	sqlite3_mutex_enter(db->mutex);
	sqlite3BtreeEnterAll(db);
	rc = sqlite3Init(db, &zErrMsg);
	if (SQLITE_OK != rc) {
		goto error_out;
	}

	
	pTab = sqlite3FindTable(db, zTableName, zDbName);
	if (!pTab || pTab->pSelect) {
		pTab = 0;
		goto error_out;
	}

	
	if (zColumnName == 0) {
		
	}
	else {
		for (iCol = 0; iCol<pTab->nCol; iCol++) {
			pCol = &pTab->aCol[iCol];
			if (0 == sqlite3StrICmp(pCol->zName, zColumnName)) {
				break;
			}
		}
		if (iCol == pTab->nCol) {
			if (HasRowid(pTab) && sqlite3IsRowid(zColumnName)) {
				iCol = pTab->iPKey;
				pCol = iCol >= 0 ? &pTab->aCol[iCol] : 0;
			}
			else {
				pTab = 0;
				goto error_out;
			}
		}
	}

	
	if (pCol) {
		zDataType = sqlite3ColumnType(pCol, 0);
		zCollSeq = pCol->zColl;
		notnull = pCol->notNull != 0;
		primarykey = (pCol->colFlags & COLFLAG_PRIMKEY) != 0;
		autoinc = pTab->iPKey == iCol && (pTab->tabFlags & TF_Autoincrement) != 0;
	}
	else {
		zDataType = "INTEGER";
		primarykey = 1;
	}
	if (!zCollSeq) {
		zCollSeq = sqlite3StrBINARY;
	}

error_out:
	sqlite3BtreeLeaveAll(db);

	
	if (pzDataType) *pzDataType = zDataType;
	if (pzCollSeq) *pzCollSeq = zCollSeq;
	if (pNotNull) *pNotNull = notnull;
	if (pPrimaryKey) *pPrimaryKey = primarykey;
	if (pAutoinc) *pAutoinc = autoinc;

	if (SQLITE_OK == rc && !pTab) {
		sqlite3DbFree(db, zErrMsg);
		zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,
			zColumnName);
		rc = SQLITE_ERROR;
	}
	sqlite3ErrorWithMsg(db, rc, (zErrMsg ? "%s" : 0), zErrMsg);
	sqlite3DbFree(db, zErrMsg);
	rc = sqlite3ApiExit(db, rc);
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_API int sqlite3_sleep(int ms) {
	sqlite3_vfs *pVfs;
	int rc;
	pVfs = sqlite3_vfs_find(0);
	if (pVfs == 0) return 0;

	
	rc = (sqlite3OsSleep(pVfs, 1000 * ms) / 1000);
	return rc;
}


SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff) {
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	db->errMask = onoff ? 0xffffffff : 0xff;
	sqlite3_mutex_leave(db->mutex);
	return SQLITE_OK;
}


SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg) {
	int rc = SQLITE_ERROR;
	Btree *pBtree;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) return SQLITE_MISUSE_BKPT;
#endif
	sqlite3_mutex_enter(db->mutex);
	pBtree = sqlite3DbNameToBtree(db, zDbName);
	if (pBtree) {
		Pager *pPager;
		sqlite3_file *fd;
		sqlite3BtreeEnter(pBtree);
		pPager = sqlite3BtreePager(pBtree);
		assert(pPager != 0);
		fd = sqlite3PagerFile(pPager);
		assert(fd != 0);
		if (op == SQLITE_FCNTL_FILE_POINTER) {
			*(sqlite3_file**)pArg = fd;
			rc = SQLITE_OK;
		}
		else if (op == SQLITE_FCNTL_VFS_POINTER) {
			*(sqlite3_vfs**)pArg = sqlite3PagerVfs(pPager);
			rc = SQLITE_OK;
		}
		else if (op == SQLITE_FCNTL_JOURNAL_POINTER) {
			*(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);
			rc = SQLITE_OK;
		}
		else if (fd->pMethods) {
			rc = sqlite3OsFileControl(fd, op, pArg);
		}
		else {
			rc = SQLITE_NOTFOUND;
		}
		sqlite3BtreeLeave(pBtree);
	}
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_API int sqlite3_test_control(int op, ...) {
	int rc = 0;
#ifdef SQLITE_OMIT_BUILTIN_TEST
	UNUSED_PARAMETER(op);
#else
	va_list ap;
	va_start(ap, op);
	switch (op) {

		
	case SQLITE_TESTCTRL_PRNG_SAVE: {
		sqlite3PrngSaveState();
		break;
	}

									
	case SQLITE_TESTCTRL_PRNG_RESTORE: {
		sqlite3PrngRestoreState();
		break;
	}

									   
	case SQLITE_TESTCTRL_PRNG_RESET: {
		sqlite3_randomness(0, 0);
		break;
	}

									 
	case SQLITE_TESTCTRL_BITVEC_TEST: {
		int sz = va_arg(ap, int);
		int *aProg = va_arg(ap, int*);
		rc = sqlite3BitvecBuiltinTest(sz, aProg);
		break;
	}

									  
	case SQLITE_TESTCTRL_FAULT_INSTALL: {
		
		typedef int(*TESTCALLBACKFUNC_t)(int);
		sqlite3GlobalConfig.xTestCallback = va_arg(ap, TESTCALLBACKFUNC_t);
		rc = sqlite3FaultSim(0);
		break;
	}

										
	case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {
		typedef void(*void_function)(void);
		void_function xBenignBegin;
		void_function xBenignEnd;
		xBenignBegin = va_arg(ap, void_function);
		xBenignEnd = va_arg(ap, void_function);
		sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
		break;
	}

											  
	case SQLITE_TESTCTRL_PENDING_BYTE: {
		rc = PENDING_BYTE;
#ifndef SQLITE_OMIT_WSD
		{
			unsigned int newVal = va_arg(ap, unsigned int);
			if (newVal) sqlite3PendingByte = newVal;
		}
#endif
		break;
	}

									   
	case SQLITE_TESTCTRL_ASSERT: {
		volatile int x = 0;
		assert(  (x = va_arg(ap, int)) != 0);
		rc = x;
		break;
	}


								 
	case SQLITE_TESTCTRL_ALWAYS: {
		int x = va_arg(ap, int);
		rc = ALWAYS(x);
		break;
	}

								 
	case SQLITE_TESTCTRL_BYTEORDER: {
		rc = SQLITE_BYTEORDER * 100 + SQLITE_LITTLEENDIAN * 10 + SQLITE_BIGENDIAN;
		break;
	}

									
	case SQLITE_TESTCTRL_RESERVE: {
		sqlite3 *db = va_arg(ap, sqlite3*);
		int x = va_arg(ap, int);
		sqlite3_mutex_enter(db->mutex);
		sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);
		sqlite3_mutex_leave(db->mutex);
		break;
	}

								  
	case SQLITE_TESTCTRL_OPTIMIZATIONS: {
		sqlite3 *db = va_arg(ap, sqlite3*);
		db->dbOptFlags = (u16)(va_arg(ap, int) & 0xffff);
		break;
	}

#ifdef SQLITE_N_KEYWORD
										
	case SQLITE_TESTCTRL_ISKEYWORD: {
		const char *zWord = va_arg(ap, const char*);
		int n = sqlite3Strlen30(zWord);
		rc = (sqlite3KeywordCode((u8*)zWord, n) != TK_ID) ? SQLITE_N_KEYWORD : 0;
		break;
	}
#endif 

									
	case SQLITE_TESTCTRL_SCRATCHMALLOC: {
		void *pFree, **ppNew;
		int sz;
		sz = va_arg(ap, int);
		ppNew = va_arg(ap, void**);
		pFree = va_arg(ap, void*);
		if (sz) *ppNew = sqlite3ScratchMalloc(sz);
		sqlite3ScratchFree(pFree);
		break;
	}

										
	case SQLITE_TESTCTRL_LOCALTIME_FAULT: {
		sqlite3GlobalConfig.bLocaltimeFault = va_arg(ap, int);
		break;
	}

										  
	case SQLITE_TESTCTRL_NEVER_CORRUPT: {
		sqlite3GlobalConfig.neverCorrupt = va_arg(ap, int);
		break;
	}

										
	case SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: {
		sqlite3GlobalConfig.iOnceResetThreshold = va_arg(ap, int);
		break;
	}

											   
	case SQLITE_TESTCTRL_VDBE_COVERAGE: {
#ifdef SQLITE_VDBE_COVERAGE
		typedef void(*branch_callback)(void*, int, u8, u8);
		sqlite3GlobalConfig.xVdbeBranch = va_arg(ap, branch_callback);
		sqlite3GlobalConfig.pVdbeBranchArg = va_arg(ap, void*);
#endif
		break;
	}

										
	case SQLITE_TESTCTRL_SORTER_MMAP: {
		sqlite3 *db = va_arg(ap, sqlite3*);
		db->nMaxSorterMmap = va_arg(ap, int);
		break;
	}

									  
	case SQLITE_TESTCTRL_ISINIT: {
		if (sqlite3GlobalConfig.isInit == 0) rc = SQLITE_ERROR;
		break;
	}

								 
	case SQLITE_TESTCTRL_IMPOSTER: {
		sqlite3 *db = va_arg(ap, sqlite3*);
		sqlite3_mutex_enter(db->mutex);
		db->init.iDb = sqlite3FindDbName(db, va_arg(ap, const char*));
		db->init.busy = db->init.imposterTable = va_arg(ap, int);
		db->init.newTnum = va_arg(ap, int);
		if (db->init.busy == 0 && db->init.newTnum>0) {
			sqlite3ResetAllSchemasOfConnection(db);
		}
		sqlite3_mutex_leave(db->mutex);
		break;
	}
	}
	va_end(ap);
#endif 
	return rc;
}


SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam) {
	if (zFilename == 0 || zParam == 0) return 0;
	zFilename += sqlite3Strlen30(zFilename) + 1;
	while (zFilename[0]) {
		int x = strcmp(zFilename, zParam);
		zFilename += sqlite3Strlen30(zFilename) + 1;
		if (x == 0) return zFilename;
		zFilename += sqlite3Strlen30(zFilename) + 1;
	}
	return 0;
}


SQLITE_API int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt) {
	const char *z = sqlite3_uri_parameter(zFilename, zParam);
	bDflt = bDflt != 0;
	return z ? sqlite3GetBoolean(z, bDflt) : bDflt;
}


SQLITE_API sqlite3_int64 sqlite3_uri_int64(
	const char *zFilename,    
	const char *zParam,       
	sqlite3_int64 bDflt       
) {
	const char *z = sqlite3_uri_parameter(zFilename, zParam);
	sqlite3_int64 v;
	if (z && sqlite3DecOrHexToI64(z, &v) == SQLITE_OK) {
		bDflt = v;
	}
	return bDflt;
}


SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName) {
	int i;
	for (i = 0; i<db->nDb; i++) {
		if (db->aDb[i].pBt
			&& (zDbName == 0 || sqlite3StrICmp(zDbName, db->aDb[i].zDbSName) == 0)
			) {
			return db->aDb[i].pBt;
		}
	}
	return 0;
}


SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName) {
	Btree *pBt;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return 0;
	}
#endif
	pBt = sqlite3DbNameToBtree(db, zDbName);
	return pBt ? sqlite3BtreeGetFilename(pBt) : 0;
}


SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName) {
	Btree *pBt;
#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		(void)SQLITE_MISUSE_BKPT;
		return -1;
	}
#endif
	pBt = sqlite3DbNameToBtree(db, zDbName);
	return pBt ? sqlite3BtreeIsReadonly(pBt) : -1;
}

#ifdef SQLITE_ENABLE_SNAPSHOT

SQLITE_API int sqlite3_snapshot_get(
	sqlite3 *db,
	const char *zDb,
	sqlite3_snapshot **ppSnapshot
) {
	int rc = SQLITE_ERROR;
#ifndef SQLITE_OMIT_WAL
	int iDb;

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);

	iDb = sqlite3FindDbName(db, zDb);
	if (iDb == 0 || iDb>1) {
		Btree *pBt = db->aDb[iDb].pBt;
		if (0 == sqlite3BtreeIsInTrans(pBt)) {
			rc = sqlite3BtreeBeginTrans(pBt, 0);
			if (rc == SQLITE_OK) {
				rc = sqlite3PagerSnapshotGet(sqlite3BtreePager(pBt), ppSnapshot);
			}
		}
	}

	sqlite3_mutex_leave(db->mutex);
#endif   
	return rc;
}


SQLITE_API int sqlite3_snapshot_open(
	sqlite3 *db,
	const char *zDb,
	sqlite3_snapshot *pSnapshot
) {
	int rc = SQLITE_ERROR;
#ifndef SQLITE_OMIT_WAL

#ifdef SQLITE_ENABLE_API_ARMOR
	if (!sqlite3SafetyCheckOk(db)) {
		return SQLITE_MISUSE_BKPT;
	}
#endif
	sqlite3_mutex_enter(db->mutex);
	if (db->autoCommit == 0) {
		int iDb;
		iDb = sqlite3FindDbName(db, zDb);
		if (iDb == 0 || iDb>1) {
			Btree *pBt = db->aDb[iDb].pBt;
			if (0 == sqlite3BtreeIsInReadTrans(pBt)) {
				rc = sqlite3PagerSnapshotOpen(sqlite3BtreePager(pBt), pSnapshot);
				if (rc == SQLITE_OK) {
					rc = sqlite3BtreeBeginTrans(pBt, 0);
					sqlite3PagerSnapshotOpen(sqlite3BtreePager(pBt), 0);
				}
			}
		}
	}

	sqlite3_mutex_leave(db->mutex);
#endif   
	return rc;
}


SQLITE_API void sqlite3_snapshot_free(sqlite3_snapshot *pSnapshot) {
	sqlite3_free(pSnapshot);
}
#endif 








#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY



#define assertMutexHeld() \
  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )


static sqlite3 *SQLITE_WSD sqlite3BlockedList = 0;

#ifndef NDEBUG

static void checkListProperties(sqlite3 *db) {
	sqlite3 *p;
	for (p = sqlite3BlockedList; p; p = p->pNextBlocked) {
		int seen = 0;
		sqlite3 *p2;

		
		assert(p->pUnlockConnection || p->pBlockingConnection);

		
		for (p2 = sqlite3BlockedList; p2 != p; p2 = p2->pNextBlocked) {
			if (p2->xUnlockNotify == p->xUnlockNotify) seen = 1;
			assert(p2->xUnlockNotify == p->xUnlockNotify || !seen);
			assert(db == 0 || p->pUnlockConnection != db);
			assert(db == 0 || p->pBlockingConnection != db);
		}
	}
}
#else
# define checkListProperties(x)
#endif


static void removeFromBlockedList(sqlite3 *db) {
	sqlite3 **pp;
	assertMutexHeld();
	for (pp = &sqlite3BlockedList; *pp; pp = &(*pp)->pNextBlocked) {
		if (*pp == db) {
			*pp = (*pp)->pNextBlocked;
			break;
		}
	}
}


static void addToBlockedList(sqlite3 *db) {
	sqlite3 **pp;
	assertMutexHeld();
	for (
		pp = &sqlite3BlockedList;
		*pp && (*pp)->xUnlockNotify != db->xUnlockNotify;
		pp = &(*pp)->pNextBlocked
		);
	db->pNextBlocked = *pp;
	*pp = db;
}


static void enterMutex(void) {
	sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));
	checkListProperties(0);
}


static void leaveMutex(void) {
	assertMutexHeld();
	checkListProperties(0);
	sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));
}


SQLITE_API int sqlite3_unlock_notify(
	sqlite3 *db,
	void(*xNotify)(void **, int),
	void *pArg
) {
	int rc = SQLITE_OK;

	sqlite3_mutex_enter(db->mutex);
	enterMutex();

	if (xNotify == 0) {
		removeFromBlockedList(db);
		db->pBlockingConnection = 0;
		db->pUnlockConnection = 0;
		db->xUnlockNotify = 0;
		db->pUnlockArg = 0;
	}
	else if (0 == db->pBlockingConnection) {
		
		xNotify(&pArg, 1);
	}
	else {
		sqlite3 *p;

		for (p = db->pBlockingConnection; p && p != db; p = p->pUnlockConnection) {}
		if (p) {
			rc = SQLITE_LOCKED;              
		}
		else {
			db->pUnlockConnection = db->pBlockingConnection;
			db->xUnlockNotify = xNotify;
			db->pUnlockArg = pArg;
			removeFromBlockedList(db);
			addToBlockedList(db);
		}
	}

	leaveMutex();
	assert(!db->mallocFailed);
	sqlite3ErrorWithMsg(db, rc, (rc ? "database is deadlocked" : 0));
	sqlite3_mutex_leave(db->mutex);
	return rc;
}


SQLITE_PRIVATE void sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker) {
	enterMutex();
	if (db->pBlockingConnection == 0 && db->pUnlockConnection == 0) {
		addToBlockedList(db);
	}
	db->pBlockingConnection = pBlocker;
	leaveMutex();
}


SQLITE_PRIVATE void sqlite3ConnectionUnlocked(sqlite3 *db) {
	void(*xUnlockNotify)(void **, int) = 0; 
	int nArg = 0;                            
	sqlite3 **pp;                            
	void **aArg;               
	void **aDyn = 0;           
	void *aStatic[16];         

	aArg = aStatic;
	enterMutex();         

						  
	for (pp = &sqlite3BlockedList; *pp; ) {
		sqlite3 *p = *pp;

		
		if (p->pBlockingConnection == db) {
			p->pBlockingConnection = 0;
		}

		
		if (p->pUnlockConnection == db) {
			assert(p->xUnlockNotify);
			if (p->xUnlockNotify != xUnlockNotify && nArg != 0) {
				xUnlockNotify(aArg, nArg);
				nArg = 0;
			}

			sqlite3BeginBenignMalloc();
			assert(aArg == aDyn || (aDyn == 0 && aArg == aStatic));
			assert(nArg <= (int)ArraySize(aStatic) || aArg == aDyn);
			if ((!aDyn && nArg == (int)ArraySize(aStatic))
				|| (aDyn && nArg == (int)(sqlite3MallocSize(aDyn) / sizeof(void*)))
				) {
				
				void **pNew = (void **)sqlite3Malloc(nArg * sizeof(void *) * 2);
				if (pNew) {
					memcpy(pNew, aArg, nArg * sizeof(void *));
					sqlite3_free(aDyn);
					aDyn = aArg = pNew;
				}
				else {
					
					xUnlockNotify(aArg, nArg);
					nArg = 0;
				}
			}
			sqlite3EndBenignMalloc();

			aArg[nArg++] = p->pUnlockArg;
			xUnlockNotify = p->xUnlockNotify;
			p->pUnlockConnection = 0;
			p->xUnlockNotify = 0;
			p->pUnlockArg = 0;
		}

		
		if (p->pBlockingConnection == 0 && p->pUnlockConnection == 0) {
			
			*pp = p->pNextBlocked;
			p->pNextBlocked = 0;
		}
		else {
			pp = &p->pNextBlocked;
		}
	}

	if (nArg != 0) {
		xUnlockNotify(aArg, nArg);
	}
	sqlite3_free(aDyn);
	leaveMutex();         
}


SQLITE_PRIVATE void sqlite3ConnectionClosed(sqlite3 *db) {
	sqlite3ConnectionUnlocked(db);
	enterMutex();
	removeFromBlockedList(db);
	checkListProperties(db);
	leaveMutex();
}
#endif












#ifndef _FTSINT_H
#define _FTSINT_H

#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) 
# define NDEBUG 1
#endif


#ifdef SQLITE_OMIT_VIRTUALTABLE
# undef SQLITE_ENABLE_FTS3
# undef SQLITE_ENABLE_FTS4
#endif


#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)
# define SQLITE_ENABLE_FTS3
#endif

#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)


#ifndef SQLITE_CORE

SQLITE_EXTENSION_INIT3
#endif





#ifndef _FTS3_TOKENIZER_H_
#define _FTS3_TOKENIZER_H_





typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;
typedef struct sqlite3_tokenizer sqlite3_tokenizer;
typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;

struct sqlite3_tokenizer_module {

	
	int iVersion;

	
	int(*xCreate)(
		int argc,                           
		const char *const*argv,             
		sqlite3_tokenizer **ppTokenizer     
		);

	
	int(*xDestroy)(sqlite3_tokenizer *pTokenizer);

	
	int(*xOpen)(
		sqlite3_tokenizer *pTokenizer,       
		const char *pInput, int nBytes,      
		sqlite3_tokenizer_cursor **ppCursor  
		);

	
	int(*xClose)(sqlite3_tokenizer_cursor *pCursor);

	
	
	int(*xNext)(
		sqlite3_tokenizer_cursor *pCursor,   
		const char **ppToken, int *pnBytes,  
		int *piStartOffset,  
		int *piEndOffset,    
		int *piPosition      
		);

	

	
	int(*xLanguageid)(sqlite3_tokenizer_cursor *pCsr, int iLangid);
};

struct sqlite3_tokenizer {
	const sqlite3_tokenizer_module *pModule;  
											  
};

struct sqlite3_tokenizer_cursor {
	sqlite3_tokenizer *pTokenizer;       
										 
};

int fts3_global_term_cnt(int iTerm, int iCol);
int fts3_term_cnt(int iTerm, int iCol);


#endif 






#ifndef _FTS3_HASH_H_
#define _FTS3_HASH_H_


typedef struct Fts3Hash Fts3Hash;
typedef struct Fts3HashElem Fts3HashElem;


struct Fts3Hash {
	char keyClass;          
	char copyKey;           
	int count;              
	Fts3HashElem *first;    
	int htsize;             
	struct _fts3ht {        
		int count;               
		Fts3HashElem *chain;     
	} *ht;
};


struct Fts3HashElem {
	Fts3HashElem *next, *prev; 
	void *data;                
	void *pKey; int nKey;      
};


#define FTS3_HASH_STRING    1
#define FTS3_HASH_BINARY    2


SQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey);
SQLITE_PRIVATE void *sqlite3Fts3HashInsert(Fts3Hash*, const void *pKey, int nKey, void *pData);
SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash*, const void *pKey, int nKey);
SQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash*);
SQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(const Fts3Hash *, const void *, int);


#define fts3HashInit     sqlite3Fts3HashInit
#define fts3HashInsert   sqlite3Fts3HashInsert
#define fts3HashFind     sqlite3Fts3HashFind
#define fts3HashClear    sqlite3Fts3HashClear
#define fts3HashFindElem sqlite3Fts3HashFindElem


#define fts3HashFirst(H)  ((H)->first)
#define fts3HashNext(E)   ((E)->next)
#define fts3HashData(E)   ((E)->data)
#define fts3HashKey(E)    ((E)->pKey)
#define fts3HashKeysize(E) ((E)->nKey)


#define fts3HashCount(H)  ((H)->count)

#endif 





#ifndef SQLITE_FTS3_MAX_EXPR_DEPTH
# define SQLITE_FTS3_MAX_EXPR_DEPTH 12
#endif



#define FTS3_MERGE_COUNT 16


#define FTS3_MAX_PENDING_DATA (1*1024*1024)


#define SizeofArray(X) ((int)(sizeof(X)/sizeof(X[0])))


#ifndef MIN
# define MIN(x,y) ((x)<(y)?(x):(y))
#endif
#ifndef MAX
# define MAX(x,y) ((x)>(y)?(x):(y))
#endif


#define FTS3_VARINT_MAX 10


#define FTS3_SEGDIR_MAXLEVEL      1024
#define FTS3_SEGDIR_MAXLEVEL_STR "1024"


#ifndef testcase
# define testcase(X)
#endif


#define POS_COLUMN  (1)     
#define POS_END     (0)      


#ifndef SQLITE_AMALGAMATION

#ifdef SQLITE_COVERAGE_TEST
# define ALWAYS(x) (1)
# define NEVER(X)  (0)
#elif defined(SQLITE_DEBUG)
# define ALWAYS(x) sqlite3Fts3Always((x)!=0)
# define NEVER(x) sqlite3Fts3Never((x)!=0)
SQLITE_PRIVATE int sqlite3Fts3Always(int b);
SQLITE_PRIVATE int sqlite3Fts3Never(int b);
#else
# define ALWAYS(x) (x)
# define NEVER(x)  (x)
#endif


typedef unsigned char u8;         
typedef short int i16;            
typedef unsigned int u32;         
typedef sqlite3_uint64 u64;       
typedef sqlite3_int64 i64;        

								  
#define UNUSED_PARAMETER(x) (void)(x)

								  
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) 
# define NDEBUG 1
#endif

								  
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
# define TESTONLY(X)  X
#else
# define TESTONLY(X)
#endif

#endif 

#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3Fts3Corrupt(void);
# define FTS_CORRUPT_VTAB sqlite3Fts3Corrupt()
#else
# define FTS_CORRUPT_VTAB SQLITE_CORRUPT_VTAB
#endif

typedef struct Fts3Table Fts3Table;
typedef struct Fts3Cursor Fts3Cursor;
typedef struct Fts3Expr Fts3Expr;
typedef struct Fts3Phrase Fts3Phrase;
typedef struct Fts3PhraseToken Fts3PhraseToken;

typedef struct Fts3Doclist Fts3Doclist;
typedef struct Fts3SegFilter Fts3SegFilter;
typedef struct Fts3DeferredToken Fts3DeferredToken;
typedef struct Fts3SegReader Fts3SegReader;
typedef struct Fts3MultiSegReader Fts3MultiSegReader;

typedef struct MatchinfoBuffer MatchinfoBuffer;


struct Fts3Table {
	sqlite3_vtab base;              
	sqlite3 *db;                    
	const char *zDb;                
	const char *zName;              
	int nColumn;                    
	char **azColumn;                
	u8 *abNotindexed;               
	sqlite3_tokenizer *pTokenizer;  
	char *zContentTbl;              
	char *zLanguageid;              
	int nAutoincrmerge;             
	u32 nLeafAdd;                   

									
	sqlite3_stmt *aStmt[40];

	char *zReadExprlist;
	char *zWriteExprlist;

	int nNodeSize;                  
	u8 bFts4;                       
	u8 bHasStat;                    
	u8 bHasDocsize;                 
	u8 bDescIdx;                    
	u8 bIgnoreSavepoint;            
	int nPgsz;                      
	char *zSegmentsTbl;             
	sqlite3_blob *pSegments;        

									
	int nIndex;                     
	struct Fts3Index {
		int nPrefix;                  
		Fts3Hash hPending;            
	} *aIndex;
	int nMaxPendingData;            
	int nPendingData;               
	sqlite_int64 iPrevDocid;        
	int iPrevLangid;                
	int bPrevDelete;                

#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
									
	int inTransaction;     
	int mxSavepoint;       
#endif

#ifdef SQLITE_TEST
						   
	int bNoIncrDoclist;
#endif
};


struct Fts3Cursor {
	sqlite3_vtab_cursor base;       
	i16 eSearch;                    
	u8 isEof;                       
	u8 isRequireSeek;               
	sqlite3_stmt *pStmt;            
	Fts3Expr *pExpr;                
	int iLangid;                    
	int nPhrase;                    
	Fts3DeferredToken *pDeferred;   
	sqlite3_int64 iPrevId;          
	char *pNextId;                  
	char *aDoclist;                 
	int nDoclist;                   
	u8 bDesc;                       
	int eEvalmode;                  
	int nRowAvg;                    
	sqlite3_int64 nDoc;             
	i64 iMinDocid;                  
	i64 iMaxDocid;                  
	int isMatchinfoNeeded;          
	MatchinfoBuffer *pMIBuffer;     
};

#define FTS3_EVAL_FILTER    0
#define FTS3_EVAL_NEXT      1
#define FTS3_EVAL_MATCHINFO 2


#define FTS3_FULLSCAN_SEARCH 0    
#define FTS3_DOCID_SEARCH    1    
#define FTS3_FULLTEXT_SEARCH 2    


#define FTS3_HAVE_LANGID    0x00010000      
#define FTS3_HAVE_DOCID_GE  0x00020000      
#define FTS3_HAVE_DOCID_LE  0x00040000      

struct Fts3Doclist {
	char *aAll;                    
	int nAll;                      
	char *pNextDocid;              

	sqlite3_int64 iDocid;          
	int bFreeList;                 
	char *pList;                   
	int nList;                     
};


struct Fts3PhraseToken {
	char *z;                        
	int n;                          
	int isPrefix;                   
	int bFirst;                     

									
	Fts3DeferredToken *pDeferred;   
	Fts3MultiSegReader *pSegcsr;    
};

struct Fts3Phrase {
	
	Fts3Doclist doclist;
	int bIncr;                 
	int iDoclistToken;

	
	char *pOrPoslist;
	i64 iOrDocid;

	
	int nToken;                
	int iColumn;               
	Fts3PhraseToken aToken[1]; 
};


struct Fts3Expr {
	int eType;                 
	int nNear;                 
	Fts3Expr *pParent;         
	Fts3Expr *pLeft;           
	Fts3Expr *pRight;          
	Fts3Phrase *pPhrase;       

							   
	sqlite3_int64 iDocid;      
	u8 bEof;                   
	u8 bStart;                 
	u8 bDeferred;              

							   
	int iPhrase;               
	u32 *aMI;                  
};


#define FTSQUERY_NEAR   1
#define FTSQUERY_NOT    2
#define FTSQUERY_AND    3
#define FTSQUERY_OR     4
#define FTSQUERY_PHRASE 5



SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(sqlite3_vtab*, int, sqlite3_value**, sqlite3_int64*);
SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *);
SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *);
SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *);
SQLITE_PRIVATE int sqlite3Fts3SegReaderNew(int, int, sqlite3_int64,
	sqlite3_int64, sqlite3_int64, const char *, int, Fts3SegReader**);
SQLITE_PRIVATE int sqlite3Fts3SegReaderPending(
	Fts3Table*, int, const char*, int, int, Fts3SegReader**);
SQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *);
SQLITE_PRIVATE int sqlite3Fts3AllSegdirs(Fts3Table*, int, int, int, sqlite3_stmt **);
SQLITE_PRIVATE int sqlite3Fts3ReadBlock(Fts3Table*, sqlite3_int64, char **, int*, int*);

SQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(Fts3Table *, sqlite3_stmt **);
SQLITE_PRIVATE int sqlite3Fts3SelectDocsize(Fts3Table *, sqlite3_int64, sqlite3_stmt **);

#ifndef SQLITE_DISABLE_FTS4_DEFERRED
SQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *);
SQLITE_PRIVATE int sqlite3Fts3DeferToken(Fts3Cursor *, Fts3PhraseToken *, int);
SQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *);
SQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *);
SQLITE_PRIVATE int sqlite3Fts3DeferredTokenList(Fts3DeferredToken *, char **, int *);
#else
# define sqlite3Fts3FreeDeferredTokens(x)
# define sqlite3Fts3DeferToken(x,y,z) SQLITE_OK
# define sqlite3Fts3CacheDeferredDoclists(x) SQLITE_OK
# define sqlite3Fts3FreeDeferredDoclists(x)
# define sqlite3Fts3DeferredTokenList(x,y,z) SQLITE_OK
#endif

SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *);
SQLITE_PRIVATE int sqlite3Fts3MaxLevel(Fts3Table *, int *);


#define FTS3_SEGCURSOR_PENDING        -1
#define FTS3_SEGCURSOR_ALL            -2

SQLITE_PRIVATE int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3MultiSegReader*, Fts3SegFilter*);
SQLITE_PRIVATE int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3MultiSegReader *);
SQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(Fts3MultiSegReader *);

SQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(Fts3Table *,
	int, int, int, const char *, int, int, int, Fts3MultiSegReader *);


#define FTS3_SEGMENT_REQUIRE_POS   0x00000001
#define FTS3_SEGMENT_IGNORE_EMPTY  0x00000002
#define FTS3_SEGMENT_COLUMN_FILTER 0x00000004
#define FTS3_SEGMENT_PREFIX        0x00000008
#define FTS3_SEGMENT_SCAN          0x00000010
#define FTS3_SEGMENT_FIRST         0x00000020


struct Fts3SegFilter {
	const char *zTerm;
	int nTerm;
	int iCol;
	int flags;
};

struct Fts3MultiSegReader {
	
	Fts3SegReader **apSegment;      
	int nSegment;                   
	int nAdvance;                   
	Fts3SegFilter *pFilter;         
	char *aBuffer;                  
	int nBuffer;                    

	int iColFilter;                 
	int bRestart;

	
	int nCost;                      
	int bLookup;                    

									
	char *zTerm;                    
	int nTerm;                      
	char *aDoclist;                 
	int nDoclist;                   
};

SQLITE_PRIVATE int sqlite3Fts3Incrmerge(Fts3Table*, int, int);

#define fts3GetVarint32(p, piVal) (                                           \
  (*(u8*)(p)&0x80) ? sqlite3Fts3GetVarint32(p, piVal) : (*piVal=*(u8*)(p), 1) \
)


SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char**, const char*, ...);
SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *, sqlite3_int64);
SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);
SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *, int *);
SQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64);
SQLITE_PRIVATE void sqlite3Fts3Dequote(char *);
SQLITE_PRIVATE void sqlite3Fts3DoclistPrev(int, char*, int, char**, sqlite3_int64*, int*, u8*);
SQLITE_PRIVATE int sqlite3Fts3EvalPhraseStats(Fts3Cursor *, Fts3Expr *, u32 *);
SQLITE_PRIVATE int sqlite3Fts3FirstFilter(sqlite3_int64, char *, int, char *);
SQLITE_PRIVATE void sqlite3Fts3CreateStatTable(int*, Fts3Table*);
SQLITE_PRIVATE int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc);


SQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *, int *);
SQLITE_PRIVATE int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);
SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *,
	sqlite3_tokenizer **, char **
);
SQLITE_PRIVATE int sqlite3Fts3IsIdChar(char);


SQLITE_PRIVATE void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*);
SQLITE_PRIVATE void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,
	const char *, const char *, int, int
);
SQLITE_PRIVATE void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *);
SQLITE_PRIVATE void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p);


SQLITE_PRIVATE int sqlite3Fts3ExprParse(sqlite3_tokenizer *, int,
	char **, int, int, int, const char *, int, Fts3Expr **, char **
);
SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *);
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3 *db);
SQLITE_PRIVATE int sqlite3Fts3InitTerm(sqlite3 *db);
#endif

SQLITE_PRIVATE int sqlite3Fts3OpenTokenizer(sqlite3_tokenizer *, int, const char *, int,
	sqlite3_tokenizer_cursor **
);


SQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db);

SQLITE_PRIVATE void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *);

SQLITE_PRIVATE int sqlite3Fts3MsrIncrStart(
	Fts3Table*, Fts3MultiSegReader*, int, const char*, int);
SQLITE_PRIVATE int sqlite3Fts3MsrIncrNext(
	Fts3Table *, Fts3MultiSegReader *, sqlite3_int64 *, char **, int *);
SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(Fts3Cursor *, Fts3Expr *, int iCol, char **);
SQLITE_PRIVATE int sqlite3Fts3MsrOvfl(Fts3Cursor *, Fts3MultiSegReader *, int *);
SQLITE_PRIVATE int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr);


SQLITE_PRIVATE int sqlite3Fts3InitTok(sqlite3*, Fts3Hash *);


#ifndef SQLITE_DISABLE_FTS3_UNICODE
SQLITE_PRIVATE int sqlite3FtsUnicodeFold(int, int);
SQLITE_PRIVATE int sqlite3FtsUnicodeIsalnum(int);
SQLITE_PRIVATE int sqlite3FtsUnicodeIsdiacritic(int);
#endif

#endif 
#endif 



#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)

#if defined(SQLITE_ENABLE_FTS3) && !defined(SQLITE_CORE)
# define SQLITE_CORE 1
#endif









#ifndef SQLITE_CORE 

SQLITE_EXTENSION_INIT1
#endif

static int fts3EvalNext(Fts3Cursor *pCsr);
static int fts3EvalStart(Fts3Cursor *pCsr);
static int fts3TermSegReaderCursor(
	Fts3Cursor *, const char *, int, int, Fts3MultiSegReader **);

#ifndef SQLITE_AMALGAMATION
# if defined(SQLITE_DEBUG)
SQLITE_PRIVATE int sqlite3Fts3Always(int b) { assert(b); return b; }
SQLITE_PRIVATE int sqlite3Fts3Never(int b) { assert(!b); return b; }
# endif
#endif


SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *p, sqlite_int64 v) {
	unsigned char *q = (unsigned char *)p;
	sqlite_uint64 vu = v;
	do {
		*q++ = (unsigned char)((vu & 0x7f) | 0x80);
		vu >>= 7;
	} while (vu != 0);
	q[-1] &= 0x7f;  
	assert(q - (unsigned char *)p <= FTS3_VARINT_MAX);
	return (int)(q - (unsigned char *)p);
}

#define GETVARINT_STEP(v, ptr, shift, mask1, mask2, var, ret) \
  v = (v & mask1) | ( (*ptr++) << shift );                    \
  if( (v & mask2)==0 ){ var = v; return ret; }
#define GETVARINT_INIT(v, ptr, shift, mask1, mask2, var, ret) \
  v = (*ptr++);                                               \
  if( (v & mask2)==0 ){ var = v; return ret; }


SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v) {
	const char *pStart = p;
	u32 a;
	u64 b;
	int shift;

	GETVARINT_INIT(a, p, 0, 0x00, 0x80, *v, 1);
	GETVARINT_STEP(a, p, 7, 0x7F, 0x4000, *v, 2);
	GETVARINT_STEP(a, p, 14, 0x3FFF, 0x200000, *v, 3);
	GETVARINT_STEP(a, p, 21, 0x1FFFFF, 0x10000000, *v, 4);
	b = (a & 0x0FFFFFFF);

	for (shift = 28; shift <= 63; shift += 7) {
		u64 c = *p++;
		b += (c & 0x7F) << shift;
		if ((c & 0x80) == 0) break;
	}
	*v = b;
	return (int)(p - pStart);
}


SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *p, int *pi) {
	u32 a;

#ifndef fts3GetVarint32
	GETVARINT_INIT(a, p, 0, 0x00, 0x80, *pi, 1);
#else
	a = (*p++);
	assert(a & 0x80);
#endif

	GETVARINT_STEP(a, p, 7, 0x7F, 0x4000, *pi, 2);
	GETVARINT_STEP(a, p, 14, 0x3FFF, 0x200000, *pi, 3);
	GETVARINT_STEP(a, p, 21, 0x1FFFFF, 0x10000000, *pi, 4);
	a = (a & 0x0FFFFFFF);
	*pi = (int)(a | ((u32)(*p & 0x0F) << 28));
	return 5;
}


SQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64 v) {
	int i = 0;
	do {
		i++;
		v >>= 7;
	} while (v != 0);
	return i;
}


SQLITE_PRIVATE void sqlite3Fts3Dequote(char *z) {
	char quote;                     

	quote = z[0];
	if (quote == '[' || quote == '\'' || quote == '"' || quote == '`') {
		int iIn = 1;                  
		int iOut = 0;                 

									  
		if (quote == '[') quote = ']';

		while (z[iIn]) {
			if (z[iIn] == quote) {
				if (z[iIn + 1] != quote) break;
				z[iOut++] = quote;
				iIn += 2;
			}
			else {
				z[iOut++] = z[iIn++];
			}
		}
		z[iOut] = '\0';
	}
}


static void fts3GetDeltaVarint(char **pp, sqlite3_int64 *pVal) {
	sqlite3_int64 iVal;
	*pp += sqlite3Fts3GetVarint(*pp, &iVal);
	*pVal += iVal;
}


static void fts3GetReverseVarint(
	char **pp,
	char *pStart,
	sqlite3_int64 *pVal
) {
	sqlite3_int64 iVal;
	char *p;

	
	for (p = (*pp) - 2; p >= pStart && *p & 0x80; p--);
	p++;
	*pp = p;

	sqlite3Fts3GetVarint(p, &iVal);
	*pVal = iVal;
}


static int fts3DisconnectMethod(sqlite3_vtab *pVtab) {
	Fts3Table *p = (Fts3Table *)pVtab;
	int i;

	assert(p->nPendingData == 0);
	assert(p->pSegments == 0);

	
	for (i = 0; i<SizeofArray(p->aStmt); i++) {
		sqlite3_finalize(p->aStmt[i]);
	}
	sqlite3_free(p->zSegmentsTbl);
	sqlite3_free(p->zReadExprlist);
	sqlite3_free(p->zWriteExprlist);
	sqlite3_free(p->zContentTbl);
	sqlite3_free(p->zLanguageid);

	
	p->pTokenizer->pModule->xDestroy(p->pTokenizer);

	sqlite3_free(p);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char **pzErr, const char *zFormat, ...) {
	va_list ap;
	sqlite3_free(*pzErr);
	va_start(ap, zFormat);
	*pzErr = sqlite3_vmprintf(zFormat, ap);
	va_end(ap);
}


static void fts3DbExec(
	int *pRc,              
	sqlite3 *db,           
	const char *zFormat,   
	...                    
) {
	va_list ap;
	char *zSql;
	if (*pRc) return;
	va_start(ap, zFormat);
	zSql = sqlite3_vmprintf(zFormat, ap);
	va_end(ap);
	if (zSql == 0) {
		*pRc = SQLITE_NOMEM;
	}
	else {
		*pRc = sqlite3_exec(db, zSql, 0, 0, 0);
		sqlite3_free(zSql);
	}
}


static int fts3DestroyMethod(sqlite3_vtab *pVtab) {
	Fts3Table *p = (Fts3Table *)pVtab;
	int rc = SQLITE_OK;              
	const char *zDb = p->zDb;        
	sqlite3 *db = p->db;             

									 
	if (p->zContentTbl == 0) {
		fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_content'", zDb, p->zName);
	}
	fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_segments'", zDb, p->zName);
	fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_segdir'", zDb, p->zName);
	fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_docsize'", zDb, p->zName);
	fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_stat'", zDb, p->zName);

	
	return (rc == SQLITE_OK ? fts3DisconnectMethod(pVtab) : rc);
}



static void fts3DeclareVtab(int *pRc, Fts3Table *p) {
	if (*pRc == SQLITE_OK) {
		int i;                        
		int rc;                       
		char *zSql;                   
		char *zCols;                  
		const char *zLanguageid;

		zLanguageid = (p->zLanguageid ? p->zLanguageid : "__langid");
		sqlite3_vtab_config(p->db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);

		
		zCols = sqlite3_mprintf("%Q, ", p->azColumn[0]);
		for (i = 1; zCols && i<p->nColumn; i++) {
			zCols = sqlite3_mprintf("%z%Q, ", zCols, p->azColumn[i]);
		}

		
		zSql = sqlite3_mprintf(
			"CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN, %Q HIDDEN)",
			zCols, p->zName, zLanguageid
		);
		if (!zCols || !zSql) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_declare_vtab(p->db, zSql);
		}

		sqlite3_free(zSql);
		sqlite3_free(zCols);
		*pRc = rc;
	}
}


SQLITE_PRIVATE void sqlite3Fts3CreateStatTable(int *pRc, Fts3Table *p) {
	fts3DbExec(pRc, p->db,
		"CREATE TABLE IF NOT EXISTS %Q.'%q_stat'"
		"(id INTEGER PRIMARY KEY, value BLOB);",
		p->zDb, p->zName
	);
	if ((*pRc) == SQLITE_OK) p->bHasStat = 1;
}


static int fts3CreateTables(Fts3Table *p) {
	int rc = SQLITE_OK;             
	int i;                          
	sqlite3 *db = p->db;            

	if (p->zContentTbl == 0) {
		const char *zLanguageid = p->zLanguageid;
		char *zContentCols;           

									  
		zContentCols = sqlite3_mprintf("docid INTEGER PRIMARY KEY");
		for (i = 0; zContentCols && i<p->nColumn; i++) {
			char *z = p->azColumn[i];
			zContentCols = sqlite3_mprintf("%z, 'c%d%q'", zContentCols, i, z);
		}
		if (zLanguageid && zContentCols) {
			zContentCols = sqlite3_mprintf("%z, langid", zContentCols, zLanguageid);
		}
		if (zContentCols == 0) rc = SQLITE_NOMEM;

		
		fts3DbExec(&rc, db,
			"CREATE TABLE %Q.'%q_content'(%s)",
			p->zDb, p->zName, zContentCols
		);
		sqlite3_free(zContentCols);
	}

	
	fts3DbExec(&rc, db,
		"CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);",
		p->zDb, p->zName
	);
	fts3DbExec(&rc, db,
		"CREATE TABLE %Q.'%q_segdir'("
		"level INTEGER,"
		"idx INTEGER,"
		"start_block INTEGER,"
		"leaves_end_block INTEGER,"
		"end_block INTEGER,"
		"root BLOB,"
		"PRIMARY KEY(level, idx)"
		");",
		p->zDb, p->zName
	);
	if (p->bHasDocsize) {
		fts3DbExec(&rc, db,
			"CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);",
			p->zDb, p->zName
		);
	}
	assert(p->bHasStat == p->bFts4);
	if (p->bHasStat) {
		sqlite3Fts3CreateStatTable(&rc, p);
	}
	return rc;
}


static void fts3DatabasePageSize(int *pRc, Fts3Table *p) {
	if (*pRc == SQLITE_OK) {
		int rc;                       
		char *zSql;                   
		sqlite3_stmt *pStmt;          

		zSql = sqlite3_mprintf("PRAGMA %Q.page_size", p->zDb);
		if (!zSql) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
			if (rc == SQLITE_OK) {
				sqlite3_step(pStmt);
				p->nPgsz = sqlite3_column_int(pStmt, 0);
				rc = sqlite3_finalize(pStmt);
			}
			else if (rc == SQLITE_AUTH) {
				p->nPgsz = 1024;
				rc = SQLITE_OK;
			}
		}
		assert(p->nPgsz>0 || rc != SQLITE_OK);
		sqlite3_free(zSql);
		*pRc = rc;
	}
}


static int fts3IsSpecialColumn(
	const char *z,
	int *pnKey,
	char **pzValue
) {
	char *zValue;
	const char *zCsr = z;

	while (*zCsr != '=') {
		if (*zCsr == '\0') return 0;
		zCsr++;
	}

	*pnKey = (int)(zCsr - z);
	zValue = sqlite3_mprintf("%s", &zCsr[1]);
	if (zValue) {
		sqlite3Fts3Dequote(zValue);
	}
	*pzValue = zValue;
	return 1;
}


static void fts3Appendf(
	int *pRc,                       
	char **pz,                      
	const char *zFormat,            
	...                             
) {
	if (*pRc == SQLITE_OK) {
		va_list ap;
		char *z;
		va_start(ap, zFormat);
		z = sqlite3_vmprintf(zFormat, ap);
		va_end(ap);
		if (z && *pz) {
			char *z2 = sqlite3_mprintf("%s%s", *pz, z);
			sqlite3_free(z);
			z = z2;
		}
		if (z == 0) *pRc = SQLITE_NOMEM;
		sqlite3_free(*pz);
		*pz = z;
	}
}


static char *fts3QuoteId(char const *zInput) {
	int nRet;
	char *zRet;
	nRet = 2 + (int)strlen(zInput) * 2 + 1;
	zRet = sqlite3_malloc(nRet);
	if (zRet) {
		int i;
		char *z = zRet;
		*(z++) = '"';
		for (i = 0; zInput[i]; i++) {
			if (zInput[i] == '"') *(z++) = '"';
			*(z++) = zInput[i];
		}
		*(z++) = '"';
		*(z++) = '\0';
	}
	return zRet;
}


static char *fts3ReadExprList(Fts3Table *p, const char *zFunc, int *pRc) {
	char *zRet = 0;
	char *zFree = 0;
	char *zFunction;
	int i;

	if (p->zContentTbl == 0) {
		if (!zFunc) {
			zFunction = "";
		}
		else {
			zFree = zFunction = fts3QuoteId(zFunc);
		}
		fts3Appendf(pRc, &zRet, "docid");
		for (i = 0; i<p->nColumn; i++) {
			fts3Appendf(pRc, &zRet, ",%s(x.'c%d%q')", zFunction, i, p->azColumn[i]);
		}
		if (p->zLanguageid) {
			fts3Appendf(pRc, &zRet, ", x.%Q", "langid");
		}
		sqlite3_free(zFree);
	}
	else {
		fts3Appendf(pRc, &zRet, "rowid");
		for (i = 0; i<p->nColumn; i++) {
			fts3Appendf(pRc, &zRet, ", x.'%q'", p->azColumn[i]);
		}
		if (p->zLanguageid) {
			fts3Appendf(pRc, &zRet, ", x.%Q", p->zLanguageid);
		}
	}
	fts3Appendf(pRc, &zRet, " FROM '%q'.'%q%s' AS x",
		p->zDb,
		(p->zContentTbl ? p->zContentTbl : p->zName),
		(p->zContentTbl ? "" : "_content")
	);
	return zRet;
}


static char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc) {
	char *zRet = 0;
	char *zFree = 0;
	char *zFunction;
	int i;

	if (!zFunc) {
		zFunction = "";
	}
	else {
		zFree = zFunction = fts3QuoteId(zFunc);
	}
	fts3Appendf(pRc, &zRet, "?");
	for (i = 0; i<p->nColumn; i++) {
		fts3Appendf(pRc, &zRet, ",%s(?)", zFunction);
	}
	if (p->zLanguageid) {
		fts3Appendf(pRc, &zRet, ", ?");
	}
	sqlite3_free(zFree);
	return zRet;
}


static int fts3GobbleInt(const char **pp, int *pnOut) {
	const int MAX_NPREFIX = 10000000;
	const char *p;                  
	int nInt = 0;                   

	for (p = *pp; p[0] >= '0' && p[0] <= '9'; p++) {
		nInt = nInt * 10 + (p[0] - '0');
		if (nInt>MAX_NPREFIX) {
			nInt = 0;
			break;
		}
	}
	if (p == *pp) return SQLITE_ERROR;
	*pnOut = nInt;
	*pp = p;
	return SQLITE_OK;
}


static int fts3PrefixParameter(
	const char *zParam,             
	int *pnIndex,                   
	struct Fts3Index **apIndex      
) {
	struct Fts3Index *aIndex;       
	int nIndex = 1;                 

	if (zParam && zParam[0]) {
		const char *p;
		nIndex++;
		for (p = zParam; *p; p++) {
			if (*p == ',') nIndex++;
		}
	}

	aIndex = sqlite3_malloc(sizeof(struct Fts3Index) * nIndex);
	*apIndex = aIndex;
	if (!aIndex) {
		return SQLITE_NOMEM;
	}

	memset(aIndex, 0, sizeof(struct Fts3Index) * nIndex);
	if (zParam) {
		const char *p = zParam;
		int i;
		for (i = 1; i<nIndex; i++) {
			int nPrefix = 0;
			if (fts3GobbleInt(&p, &nPrefix)) return SQLITE_ERROR;
			assert(nPrefix >= 0);
			if (nPrefix == 0) {
				nIndex--;
				i--;
			}
			else {
				aIndex[i].nPrefix = nPrefix;
			}
			p++;
		}
	}

	*pnIndex = nIndex;
	return SQLITE_OK;
}


static int fts3ContentColumns(
	sqlite3 *db,                    
	const char *zDb,                
	const char *zTbl,               
	const char ***pazCol,           
	int *pnCol,                     
	int *pnStr,                     
	char **pzErr                    
) {
	int rc = SQLITE_OK;             
	char *zSql;                     
	sqlite3_stmt *pStmt = 0;        

	zSql = sqlite3_mprintf("SELECT * FROM %Q.%Q", zDb, zTbl);
	if (!zSql) {
		rc = SQLITE_NOMEM;
	}
	else {
		rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
		if (rc != SQLITE_OK) {
			sqlite3Fts3ErrMsg(pzErr, "%s", sqlite3_errmsg(db));
		}
	}
	sqlite3_free(zSql);

	if (rc == SQLITE_OK) {
		const char **azCol;           
		int nStr = 0;                 
		int nCol;                     
		int i;                        

									  
		nCol = sqlite3_column_count(pStmt);
		for (i = 0; i<nCol; i++) {
			const char *zCol = sqlite3_column_name(pStmt, i);
			nStr += (int)strlen(zCol) + 1;
		}

		
		azCol = (const char **)sqlite3_malloc(sizeof(char *) * nCol + nStr);
		if (azCol == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			char *p = (char *)&azCol[nCol];
			for (i = 0; i<nCol; i++) {
				const char *zCol = sqlite3_column_name(pStmt, i);
				int n = (int)strlen(zCol) + 1;
				memcpy(p, zCol, n);
				azCol[i] = p;
				p += n;
			}
		}
		sqlite3_finalize(pStmt);

		
		*pnCol = nCol;
		*pnStr = nStr;
		*pazCol = azCol;
	}

	return rc;
}


static int fts3InitVtab(
	int isCreate,                   
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVTab,          
	char **pzErr                    
) {
	Fts3Hash *pHash = (Fts3Hash *)pAux;
	Fts3Table *p = 0;               
	int rc = SQLITE_OK;             
	int i;                          
	int nByte;                      
	int iCol;                       
	int nString = 0;                
	int nCol = 0;                   
	char *zCsr;                     
	int nDb;                        
	int nName;                      
	int isFts4 = (argv[0][3] == '4'); 
	const char **aCol;              
	sqlite3_tokenizer *pTokenizer = 0;        

	int nIndex = 0;                 
	struct Fts3Index *aIndex = 0;   

									
	int bNoDocsize = 0;             
	int bDescIdx = 0;               
	char *zPrefix = 0;              
	char *zCompress = 0;            
	char *zUncompress = 0;          
	char *zContent = 0;             
	char *zLanguageid = 0;          
	char **azNotindexed = 0;        
	int nNotindexed = 0;            

	assert(strlen(argv[0]) == 4);
	assert((sqlite3_strnicmp(argv[0], "fts4", 4) == 0 && isFts4)
		|| (sqlite3_strnicmp(argv[0], "fts3", 4) == 0 && !isFts4)
	);

	nDb = (int)strlen(argv[1]) + 1;
	nName = (int)strlen(argv[2]) + 1;

	nByte = sizeof(const char *) * (argc - 2);
	aCol = (const char **)sqlite3_malloc(nByte);
	if (aCol) {
		memset((void*)aCol, 0, nByte);
		azNotindexed = (char **)sqlite3_malloc(nByte);
	}
	if (azNotindexed) {
		memset(azNotindexed, 0, nByte);
	}
	if (!aCol || !azNotindexed) {
		rc = SQLITE_NOMEM;
		goto fts3_init_out;
	}

	
	for (i = 3; rc == SQLITE_OK && i<argc; i++) {
		char const *z = argv[i];
		int nKey;
		char *zVal;

		
		if (!pTokenizer
			&& strlen(z)>8
			&& 0 == sqlite3_strnicmp(z, "tokenize", 8)
			&& 0 == sqlite3Fts3IsIdChar(z[8])
			) {
			rc = sqlite3Fts3InitTokenizer(pHash, &z[9], &pTokenizer, pzErr);
		}

		
		else if (isFts4 && fts3IsSpecialColumn(z, &nKey, &zVal)) {
			struct Fts4Option {
				const char *zOpt;
				int nOpt;
			} aFts4Opt[] = {
				{ "matchinfo",   9 },     
				{ "prefix",      6 },     
				{ "compress",    8 },     
				{ "uncompress", 10 },     
				{ "order",       5 },     
				{ "content",     7 },     
				{ "languageid", 10 },     
				{ "notindexed", 10 }      
			};

			int iOpt;
			if (!zVal) {
				rc = SQLITE_NOMEM;
			}
			else {
				for (iOpt = 0; iOpt<SizeofArray(aFts4Opt); iOpt++) {
					struct Fts4Option *pOp = &aFts4Opt[iOpt];
					if (nKey == pOp->nOpt && !sqlite3_strnicmp(z, pOp->zOpt, pOp->nOpt)) {
						break;
					}
				}
				if (iOpt == SizeofArray(aFts4Opt)) {
					sqlite3Fts3ErrMsg(pzErr, "unrecognized parameter: %s", z);
					rc = SQLITE_ERROR;
				}
				else {
					switch (iOpt) {
					case 0:               
						if (strlen(zVal) != 4 || sqlite3_strnicmp(zVal, "fts3", 4)) {
							sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo: %s", zVal);
							rc = SQLITE_ERROR;
						}
						bNoDocsize = 1;
						break;

					case 1:               
						sqlite3_free(zPrefix);
						zPrefix = zVal;
						zVal = 0;
						break;

					case 2:               
						sqlite3_free(zCompress);
						zCompress = zVal;
						zVal = 0;
						break;

					case 3:               
						sqlite3_free(zUncompress);
						zUncompress = zVal;
						zVal = 0;
						break;

					case 4:               
						if ((strlen(zVal) != 3 || sqlite3_strnicmp(zVal, "asc", 3))
							&& (strlen(zVal) != 4 || sqlite3_strnicmp(zVal, "desc", 4))
							) {
							sqlite3Fts3ErrMsg(pzErr, "unrecognized order: %s", zVal);
							rc = SQLITE_ERROR;
						}
						bDescIdx = (zVal[0] == 'd' || zVal[0] == 'D');
						break;

					case 5:              
						sqlite3_free(zContent);
						zContent = zVal;
						zVal = 0;
						break;

					case 6:              
						assert(iOpt == 6);
						sqlite3_free(zLanguageid);
						zLanguageid = zVal;
						zVal = 0;
						break;

					case 7:              
						azNotindexed[nNotindexed++] = zVal;
						zVal = 0;
						break;
					}
				}
				sqlite3_free(zVal);
			}
		}

		
		else {
			nString += (int)(strlen(z) + 1);
			aCol[nCol++] = z;
		}
	}

	
	if (rc == SQLITE_OK && zContent) {
		sqlite3_free(zCompress);
		sqlite3_free(zUncompress);
		zCompress = 0;
		zUncompress = 0;
		if (nCol == 0) {
			sqlite3_free((void*)aCol);
			aCol = 0;
			rc = fts3ContentColumns(db, argv[1], zContent, &aCol, &nCol, &nString, pzErr);

			
			if (rc == SQLITE_OK && zLanguageid) {
				int j;
				for (j = 0; j<nCol; j++) {
					if (sqlite3_stricmp(zLanguageid, aCol[j]) == 0) {
						int k;
						for (k = j; k<nCol; k++) aCol[k] = aCol[k + 1];
						nCol--;
						break;
					}
				}
			}
		}
	}
	if (rc != SQLITE_OK) goto fts3_init_out;

	if (nCol == 0) {
		assert(nString == 0);
		aCol[0] = "content";
		nString = 8;
		nCol = 1;
	}

	if (pTokenizer == 0) {
		rc = sqlite3Fts3InitTokenizer(pHash, "simple", &pTokenizer, pzErr);
		if (rc != SQLITE_OK) goto fts3_init_out;
	}
	assert(pTokenizer);

	rc = fts3PrefixParameter(zPrefix, &nIndex, &aIndex);
	if (rc == SQLITE_ERROR) {
		assert(zPrefix);
		sqlite3Fts3ErrMsg(pzErr, "error parsing prefix parameter: %s", zPrefix);
	}
	if (rc != SQLITE_OK) goto fts3_init_out;

	
	nByte = sizeof(Fts3Table) +                  
		nCol * sizeof(char *) +              
		nIndex * sizeof(struct Fts3Index) +  
		nCol * sizeof(u8) +                  
		nName +                              
		nDb +                                
		nString;                             
	p = (Fts3Table*)sqlite3_malloc(nByte);
	if (p == 0) {
		rc = SQLITE_NOMEM;
		goto fts3_init_out;
	}
	memset(p, 0, nByte);
	p->db = db;
	p->nColumn = nCol;
	p->nPendingData = 0;
	p->azColumn = (char **)&p[1];
	p->pTokenizer = pTokenizer;
	p->nMaxPendingData = FTS3_MAX_PENDING_DATA;
	p->bHasDocsize = (isFts4 && bNoDocsize == 0);
	p->bHasStat = isFts4;
	p->bFts4 = isFts4;
	p->bDescIdx = bDescIdx;
	p->nAutoincrmerge = 0xff;   
	p->zContentTbl = zContent;
	p->zLanguageid = zLanguageid;
	zContent = 0;
	zLanguageid = 0;
	TESTONLY(p->inTransaction = -1);
	TESTONLY(p->mxSavepoint = -1);

	p->aIndex = (struct Fts3Index *)&p->azColumn[nCol];
	memcpy(p->aIndex, aIndex, sizeof(struct Fts3Index) * nIndex);
	p->nIndex = nIndex;
	for (i = 0; i<nIndex; i++) {
		fts3HashInit(&p->aIndex[i].hPending, FTS3_HASH_STRING, 1);
	}
	p->abNotindexed = (u8 *)&p->aIndex[nIndex];

	
	zCsr = (char *)&p->abNotindexed[nCol];
	p->zName = zCsr;
	memcpy(zCsr, argv[2], nName);
	zCsr += nName;
	p->zDb = zCsr;
	memcpy(zCsr, argv[1], nDb);
	zCsr += nDb;

	
	for (iCol = 0; iCol<nCol; iCol++) {
		char *z;
		int n = 0;
		z = (char *)sqlite3Fts3NextToken(aCol[iCol], &n);
		memcpy(zCsr, z, n);
		zCsr[n] = '\0';
		sqlite3Fts3Dequote(zCsr);
		p->azColumn[iCol] = zCsr;
		zCsr += n + 1;
		assert(zCsr <= &((char *)p)[nByte]);
	}

	
	for (iCol = 0; iCol<nCol; iCol++) {
		int n = (int)strlen(p->azColumn[iCol]);
		for (i = 0; i<nNotindexed; i++) {
			char *zNot = azNotindexed[i];
			if (zNot && n == (int)strlen(zNot)
				&& 0 == sqlite3_strnicmp(p->azColumn[iCol], zNot, n)
				) {
				p->abNotindexed[iCol] = 1;
				sqlite3_free(zNot);
				azNotindexed[i] = 0;
			}
		}
	}
	for (i = 0; i<nNotindexed; i++) {
		if (azNotindexed[i]) {
			sqlite3Fts3ErrMsg(pzErr, "no such column: %s", azNotindexed[i]);
			rc = SQLITE_ERROR;
		}
	}

	if (rc == SQLITE_OK && (zCompress == 0) != (zUncompress == 0)) {
		char const *zMiss = (zCompress == 0 ? "compress" : "uncompress");
		rc = SQLITE_ERROR;
		sqlite3Fts3ErrMsg(pzErr, "missing %s parameter in fts4 constructor", zMiss);
	}
	p->zReadExprlist = fts3ReadExprList(p, zUncompress, &rc);
	p->zWriteExprlist = fts3WriteExprList(p, zCompress, &rc);
	if (rc != SQLITE_OK) goto fts3_init_out;

	
	if (isCreate) {
		rc = fts3CreateTables(p);
	}

	
	if (!isFts4 && !isCreate) {
		p->bHasStat = 2;
	}

	
	fts3DatabasePageSize(&rc, p);
	p->nNodeSize = p->nPgsz - 35;

	
	fts3DeclareVtab(&rc, p);

fts3_init_out:
	sqlite3_free(zPrefix);
	sqlite3_free(aIndex);
	sqlite3_free(zCompress);
	sqlite3_free(zUncompress);
	sqlite3_free(zContent);
	sqlite3_free(zLanguageid);
	for (i = 0; i<nNotindexed; i++) sqlite3_free(azNotindexed[i]);
	sqlite3_free((void *)aCol);
	sqlite3_free((void *)azNotindexed);
	if (rc != SQLITE_OK) {
		if (p) {
			fts3DisconnectMethod((sqlite3_vtab *)p);
		}
		else if (pTokenizer) {
			pTokenizer->pModule->xDestroy(pTokenizer);
		}
	}
	else {
		assert(p->pSegments == 0);
		*ppVTab = &p->base;
	}
	return rc;
}


static int fts3ConnectMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);
}
static int fts3CreateMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts3InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);
}


static void fts3SetEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow) {
#if SQLITE_VERSION_NUMBER>=3008002
	if (sqlite3_libversion_number() >= 3008002) {
		pIdxInfo->estimatedRows = nRow;
	}
#endif
}


static void fts3SetUniqueFlag(sqlite3_index_info *pIdxInfo) {
#if SQLITE_VERSION_NUMBER>=3008012
	if (sqlite3_libversion_number() >= 3008012) {
		pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;
	}
#endif
}


static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo) {
	Fts3Table *p = (Fts3Table *)pVTab;
	int i;                          
	int iCons = -1;                 

	int iLangidCons = -1;           
	int iDocidGe = -1;              
	int iDocidLe = -1;              
	int iIdx;

	
	pInfo->idxNum = FTS3_FULLSCAN_SEARCH;
	pInfo->estimatedCost = 5000000;
	for (i = 0; i<pInfo->nConstraint; i++) {
		int bDocid;                 
		struct sqlite3_index_constraint *pCons = &pInfo->aConstraint[i];
		if (pCons->usable == 0) {
			if (pCons->op == SQLITE_INDEX_CONSTRAINT_MATCH) {
				
				pInfo->idxNum = FTS3_FULLSCAN_SEARCH;
				pInfo->estimatedCost = 1e50;
				fts3SetEstimatedRows(pInfo, ((sqlite3_int64)1) << 50);
				return SQLITE_OK;
			}
			continue;
		}

		bDocid = (pCons->iColumn<0 || pCons->iColumn == p->nColumn + 1);

		
		if (iCons<0 && pCons->op == SQLITE_INDEX_CONSTRAINT_EQ && bDocid) {
			pInfo->idxNum = FTS3_DOCID_SEARCH;
			pInfo->estimatedCost = 1.0;
			iCons = i;
		}

		
		if (pCons->op == SQLITE_INDEX_CONSTRAINT_MATCH
			&& pCons->iColumn >= 0 && pCons->iColumn <= p->nColumn
			) {
			pInfo->idxNum = FTS3_FULLTEXT_SEARCH + pCons->iColumn;
			pInfo->estimatedCost = 2.0;
			iCons = i;
		}

		
		if (pCons->op == SQLITE_INDEX_CONSTRAINT_EQ
			&& pCons->iColumn == p->nColumn + 2
			) {
			iLangidCons = i;
		}

		if (bDocid) {
			switch (pCons->op) {
			case SQLITE_INDEX_CONSTRAINT_GE:
			case SQLITE_INDEX_CONSTRAINT_GT:
				iDocidGe = i;
				break;

			case SQLITE_INDEX_CONSTRAINT_LE:
			case SQLITE_INDEX_CONSTRAINT_LT:
				iDocidLe = i;
				break;
			}
		}
	}

	
	if (pInfo->idxNum == FTS3_DOCID_SEARCH) fts3SetUniqueFlag(pInfo);

	iIdx = 1;
	if (iCons >= 0) {
		pInfo->aConstraintUsage[iCons].argvIndex = iIdx++;
		pInfo->aConstraintUsage[iCons].omit = 1;
	}
	if (iLangidCons >= 0) {
		pInfo->idxNum |= FTS3_HAVE_LANGID;
		pInfo->aConstraintUsage[iLangidCons].argvIndex = iIdx++;
	}
	if (iDocidGe >= 0) {
		pInfo->idxNum |= FTS3_HAVE_DOCID_GE;
		pInfo->aConstraintUsage[iDocidGe].argvIndex = iIdx++;
	}
	if (iDocidLe >= 0) {
		pInfo->idxNum |= FTS3_HAVE_DOCID_LE;
		pInfo->aConstraintUsage[iDocidLe].argvIndex = iIdx++;
	}

	
	if (pInfo->nOrderBy == 1) {
		struct sqlite3_index_orderby *pOrder = &pInfo->aOrderBy[0];
		if (pOrder->iColumn<0 || pOrder->iColumn == p->nColumn + 1) {
			if (pOrder->desc) {
				pInfo->idxStr = "DESC";
			}
			else {
				pInfo->idxStr = "ASC";
			}
			pInfo->orderByConsumed = 1;
		}
	}

	assert(p->pSegments == 0);
	return SQLITE_OK;
}


static int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr) {
	sqlite3_vtab_cursor *pCsr;               

	UNUSED_PARAMETER(pVTab);

	
	*ppCsr = pCsr = (sqlite3_vtab_cursor *)sqlite3_malloc(sizeof(Fts3Cursor));
	if (!pCsr) {
		return SQLITE_NOMEM;
	}
	memset(pCsr, 0, sizeof(Fts3Cursor));
	return SQLITE_OK;
}


static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
	assert(((Fts3Table *)pCsr->base.pVtab)->pSegments == 0);
	sqlite3_finalize(pCsr->pStmt);
	sqlite3Fts3ExprFree(pCsr->pExpr);
	sqlite3Fts3FreeDeferredTokens(pCsr);
	sqlite3_free(pCsr->aDoclist);
	sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
	assert(((Fts3Table *)pCsr->base.pVtab)->pSegments == 0);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}


static int fts3CursorSeekStmt(Fts3Cursor *pCsr, sqlite3_stmt **ppStmt) {
	int rc = SQLITE_OK;
	if (pCsr->pStmt == 0) {
		Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
		char *zSql;
		zSql = sqlite3_mprintf("SELECT %s WHERE rowid = ?", p->zReadExprlist);
		if (!zSql) return SQLITE_NOMEM;
		rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
		sqlite3_free(zSql);
	}
	*ppStmt = pCsr->pStmt;
	return rc;
}


static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr) {
	int rc = SQLITE_OK;
	if (pCsr->isRequireSeek) {
		sqlite3_stmt *pStmt = 0;

		rc = fts3CursorSeekStmt(pCsr, &pStmt);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);
			pCsr->isRequireSeek = 0;
			if (SQLITE_ROW == sqlite3_step(pCsr->pStmt)) {
				return SQLITE_OK;
			}
			else {
				rc = sqlite3_reset(pCsr->pStmt);
				if (rc == SQLITE_OK && ((Fts3Table *)pCsr->base.pVtab)->zContentTbl == 0) {
					
					rc = FTS_CORRUPT_VTAB;
					pCsr->isEof = 1;
				}
			}
		}
	}

	if (rc != SQLITE_OK && pContext) {
		sqlite3_result_error_code(pContext, rc);
	}
	return rc;
}


static int fts3ScanInteriorNode(
	const char *zTerm,              
	int nTerm,                      
	const char *zNode,              
	int nNode,                      
	sqlite3_int64 *piFirst,         
	sqlite3_int64 *piLast           
) {
	int rc = SQLITE_OK;             
	const char *zCsr = zNode;       
	const char *zEnd = &zCsr[nNode];
	char *zBuffer = 0;              
	int nAlloc = 0;                 
	int isFirstTerm = 1;            
	sqlite3_int64 iChild;           

									
	zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);
	zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);
	if (zCsr>zEnd) {
		return FTS_CORRUPT_VTAB;
	}

	while (zCsr<zEnd && (piFirst || piLast)) {
		int cmp;                      
		int nSuffix;                  
		int nPrefix = 0;              
		int nBuffer;                  

									  
		if (!isFirstTerm) {
			zCsr += fts3GetVarint32(zCsr, &nPrefix);
		}
		isFirstTerm = 0;
		zCsr += fts3GetVarint32(zCsr, &nSuffix);

		if (nPrefix<0 || nSuffix<0 || &zCsr[nSuffix]>zEnd) {
			rc = FTS_CORRUPT_VTAB;
			goto finish_scan;
		}
		if (nPrefix + nSuffix>nAlloc) {
			char *zNew;
			nAlloc = (nPrefix + nSuffix) * 2;
			zNew = (char *)sqlite3_realloc(zBuffer, nAlloc);
			if (!zNew) {
				rc = SQLITE_NOMEM;
				goto finish_scan;
			}
			zBuffer = zNew;
		}
		assert(zBuffer);
		memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
		nBuffer = nPrefix + nSuffix;
		zCsr += nSuffix;

		
		cmp = memcmp(zTerm, zBuffer, (nBuffer>nTerm ? nTerm : nBuffer));
		if (piFirst && (cmp<0 || (cmp == 0 && nBuffer>nTerm))) {
			*piFirst = iChild;
			piFirst = 0;
		}

		if (piLast && cmp<0) {
			*piLast = iChild;
			piLast = 0;
		}

		iChild++;
	};

	if (piFirst) *piFirst = iChild;
	if (piLast) *piLast = iChild;

finish_scan:
	sqlite3_free(zBuffer);
	return rc;
}



static int fts3SelectLeaf(
	Fts3Table *p,                   
	const char *zTerm,              
	int nTerm,                      
	const char *zNode,              
	int nNode,                      
	sqlite3_int64 *piLeaf,          
	sqlite3_int64 *piLeaf2          
) {
	int rc = SQLITE_OK;             
	int iHeight;                    

	assert(piLeaf || piLeaf2);

	fts3GetVarint32(zNode, &iHeight);
	rc = fts3ScanInteriorNode(zTerm, nTerm, zNode, nNode, piLeaf, piLeaf2);
	assert(!piLeaf2 || !piLeaf || rc != SQLITE_OK || (*piLeaf <= *piLeaf2));

	if (rc == SQLITE_OK && iHeight>1) {
		char *zBlob = 0;              
		int nBlob = 0;                

		if (piLeaf && piLeaf2 && (*piLeaf != *piLeaf2)) {
			rc = sqlite3Fts3ReadBlock(p, *piLeaf, &zBlob, &nBlob, 0);
			if (rc == SQLITE_OK) {
				rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, 0);
			}
			sqlite3_free(zBlob);
			piLeaf = 0;
			zBlob = 0;
		}

		if (rc == SQLITE_OK) {
			rc = sqlite3Fts3ReadBlock(p, piLeaf ? *piLeaf : *piLeaf2, &zBlob, &nBlob, 0);
		}
		if (rc == SQLITE_OK) {
			rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, piLeaf2);
		}
		sqlite3_free(zBlob);
	}

	return rc;
}


static void fts3PutDeltaVarint(
	char **pp,                      
	sqlite3_int64 *piPrev,          
	sqlite3_int64 iVal              
) {
	assert(iVal - *piPrev > 0 || (*piPrev == 0 && iVal == 0));
	*pp += sqlite3Fts3PutVarint(*pp, iVal - *piPrev);
	*piPrev = iVal;
}


static void fts3PoslistCopy(char **pp, char **ppPoslist) {
	char *pEnd = *ppPoslist;
	char c = 0;

	
	while (*pEnd | c) {
		c = *pEnd++ & 0x80;
		testcase(c != 0 && (*pEnd) == 0);
	}
	pEnd++;  

	if (pp) {
		int n = (int)(pEnd - *ppPoslist);
		char *p = *pp;
		memcpy(p, *ppPoslist, n);
		p += n;
		*pp = p;
	}
	*ppPoslist = pEnd;
}


static void fts3ColumnlistCopy(char **pp, char **ppPoslist) {
	char *pEnd = *ppPoslist;
	char c = 0;

	
	while (0xFE & (*pEnd | c)) {
		c = *pEnd++ & 0x80;
		testcase(c != 0 && ((*pEnd) & 0xfe) == 0);
	}
	if (pp) {
		int n = (int)(pEnd - *ppPoslist);
		char *p = *pp;
		memcpy(p, *ppPoslist, n);
		p += n;
		*pp = p;
	}
	*ppPoslist = pEnd;
}


#define POSITION_LIST_END 0x7fffffff


static void fts3ReadNextPos(
	char **pp,                    
	sqlite3_int64 *pi             
) {
	if ((**pp) & 0xFE) {
		fts3GetDeltaVarint(pp, pi);
		*pi -= 2;
	}
	else {
		*pi = POSITION_LIST_END;
	}
}


static int fts3PutColNumber(char **pp, int iCol) {
	int n = 0;                      
	if (iCol) {
		char *p = *pp;                
		n = 1 + sqlite3Fts3PutVarint(&p[1], iCol);
		*p = 0x01;
		*pp = &p[n];
	}
	return n;
}


static void fts3PoslistMerge(
	char **pp,                      
	char **pp1,                     
	char **pp2                      
) {
	char *p = *pp;
	char *p1 = *pp1;
	char *p2 = *pp2;

	while (*p1 || *p2) {
		int iCol1;         
		int iCol2;         

		if (*p1 == POS_COLUMN) fts3GetVarint32(&p1[1], &iCol1);
		else if (*p1 == POS_END) iCol1 = POSITION_LIST_END;
		else iCol1 = 0;

		if (*p2 == POS_COLUMN) fts3GetVarint32(&p2[1], &iCol2);
		else if (*p2 == POS_END) iCol2 = POSITION_LIST_END;
		else iCol2 = 0;

		if (iCol1 == iCol2) {
			sqlite3_int64 i1 = 0;       
			sqlite3_int64 i2 = 0;       
			sqlite3_int64 iPrev = 0;
			int n = fts3PutColNumber(&p, iCol1);
			p1 += n;
			p2 += n;

			
			fts3GetDeltaVarint(&p1, &i1);
			fts3GetDeltaVarint(&p2, &i2);
			do {
				fts3PutDeltaVarint(&p, &iPrev, (i1<i2) ? i1 : i2);
				iPrev -= 2;
				if (i1 == i2) {
					fts3ReadNextPos(&p1, &i1);
					fts3ReadNextPos(&p2, &i2);
				}
				else if (i1<i2) {
					fts3ReadNextPos(&p1, &i1);
				}
				else {
					fts3ReadNextPos(&p2, &i2);
				}
			} while (i1 != POSITION_LIST_END || i2 != POSITION_LIST_END);
		}
		else if (iCol1<iCol2) {
			p1 += fts3PutColNumber(&p, iCol1);
			fts3ColumnlistCopy(&p, &p1);
		}
		else {
			p2 += fts3PutColNumber(&p, iCol2);
			fts3ColumnlistCopy(&p, &p2);
		}
	}

	*p++ = POS_END;
	*pp = p;
	*pp1 = p1 + 1;
	*pp2 = p2 + 1;
}


static int fts3PoslistPhraseMerge(
	char **pp,                      
	int nToken,                     
	int isSaveLeft,                 
	int isExact,                    
	char **pp1,                     
	char **pp2                      
) {
	char *p = *pp;
	char *p1 = *pp1;
	char *p2 = *pp2;
	int iCol1 = 0;
	int iCol2 = 0;

	
	assert(isSaveLeft == 0 || isExact == 0);

	assert(p != 0 && *p1 != 0 && *p2 != 0);
	if (*p1 == POS_COLUMN) {
		p1++;
		p1 += fts3GetVarint32(p1, &iCol1);
	}
	if (*p2 == POS_COLUMN) {
		p2++;
		p2 += fts3GetVarint32(p2, &iCol2);
	}

	while (1) {
		if (iCol1 == iCol2) {
			char *pSave = p;
			sqlite3_int64 iPrev = 0;
			sqlite3_int64 iPos1 = 0;
			sqlite3_int64 iPos2 = 0;

			if (iCol1) {
				*p++ = POS_COLUMN;
				p += sqlite3Fts3PutVarint(p, iCol1);
			}

			assert(*p1 != POS_END && *p1 != POS_COLUMN);
			assert(*p2 != POS_END && *p2 != POS_COLUMN);
			fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;
			fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;

			while (1) {
				if (iPos2 == iPos1 + nToken
					|| (isExact == 0 && iPos2>iPos1 && iPos2 <= iPos1 + nToken)
					) {
					sqlite3_int64 iSave;
					iSave = isSaveLeft ? iPos1 : iPos2;
					fts3PutDeltaVarint(&p, &iPrev, iSave + 2); iPrev -= 2;
					pSave = 0;
					assert(p);
				}
				if ((!isSaveLeft && iPos2 <= (iPos1 + nToken)) || iPos2 <= iPos1) {
					if ((*p2 & 0xFE) == 0) break;
					fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;
				}
				else {
					if ((*p1 & 0xFE) == 0) break;
					fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;
				}
			}

			if (pSave) {
				assert(pp && p);
				p = pSave;
			}

			fts3ColumnlistCopy(0, &p1);
			fts3ColumnlistCopy(0, &p2);
			assert((*p1 & 0xFE) == 0 && (*p2 & 0xFE) == 0);
			if (0 == *p1 || 0 == *p2) break;

			p1++;
			p1 += fts3GetVarint32(p1, &iCol1);
			p2++;
			p2 += fts3GetVarint32(p2, &iCol2);
		}

		
		else if (iCol1<iCol2) {
			fts3ColumnlistCopy(0, &p1);
			if (0 == *p1) break;
			p1++;
			p1 += fts3GetVarint32(p1, &iCol1);
		}
		else {
			fts3ColumnlistCopy(0, &p2);
			if (0 == *p2) break;
			p2++;
			p2 += fts3GetVarint32(p2, &iCol2);
		}
	}

	fts3PoslistCopy(0, &p2);
	fts3PoslistCopy(0, &p1);
	*pp1 = p1;
	*pp2 = p2;
	if (*pp == p) {
		return 0;
	}
	*p++ = 0x00;
	*pp = p;
	return 1;
}


static int fts3PoslistNearMerge(
	char **pp,                      
	char *aTmp,                     
	int nRight,                     
	int nLeft,                      
	char **pp1,                     
	char **pp2                      
) {
	char *p1 = *pp1;
	char *p2 = *pp2;

	char *pTmp1 = aTmp;
	char *pTmp2;
	char *aTmp2;
	int res = 1;

	fts3PoslistPhraseMerge(&pTmp1, nRight, 0, 0, pp1, pp2);
	aTmp2 = pTmp2 = pTmp1;
	*pp1 = p1;
	*pp2 = p2;
	fts3PoslistPhraseMerge(&pTmp2, nLeft, 1, 0, pp2, pp1);
	if (pTmp1 != aTmp && pTmp2 != aTmp2) {
		fts3PoslistMerge(pp, &aTmp, &aTmp2);
	}
	else if (pTmp1 != aTmp) {
		fts3PoslistCopy(pp, &aTmp);
	}
	else if (pTmp2 != aTmp2) {
		fts3PoslistCopy(pp, &aTmp2);
	}
	else {
		res = 0;
	}

	return res;
}


typedef struct TermSelect TermSelect;
struct TermSelect {
	char *aaOutput[16];             
	int anOutput[16];               
};


static void fts3GetDeltaVarint3(
	char **pp,                      
	char *pEnd,                     
	int bDescIdx,                   
	sqlite3_int64 *pVal             
) {
	if (*pp >= pEnd) {
		*pp = 0;
	}
	else {
		sqlite3_int64 iVal;
		*pp += sqlite3Fts3GetVarint(*pp, &iVal);
		if (bDescIdx) {
			*pVal -= iVal;
		}
		else {
			*pVal += iVal;
		}
	}
}


static void fts3PutDeltaVarint3(
	char **pp,                      
	int bDescIdx,                   
	sqlite3_int64 *piPrev,          
	int *pbFirst,                   
	sqlite3_int64 iVal              
) {
	sqlite3_int64 iWrite;
	if (bDescIdx == 0 || *pbFirst == 0) {
		iWrite = iVal - *piPrev;
	}
	else {
		iWrite = *piPrev - iVal;
	}
	assert(*pbFirst || *piPrev == 0);
	assert(*pbFirst == 0 || iWrite>0);
	*pp += sqlite3Fts3PutVarint(*pp, iWrite);
	*piPrev = iVal;
	*pbFirst = 1;
}



#define DOCID_CMP(i1, i2) ((bDescDoclist?-1:1) * (i1-i2))


static int fts3DoclistOrMerge(
	int bDescDoclist,               
	char *a1, int n1,               
	char *a2, int n2,               
	char **paOut, int *pnOut        
) {
	sqlite3_int64 i1 = 0;
	sqlite3_int64 i2 = 0;
	sqlite3_int64 iPrev = 0;
	char *pEnd1 = &a1[n1];
	char *pEnd2 = &a2[n2];
	char *p1 = a1;
	char *p2 = a2;
	char *p;
	char *aOut;
	int bFirstOut = 0;

	*paOut = 0;
	*pnOut = 0;

	
	aOut = sqlite3_malloc(n1 + n2 + FTS3_VARINT_MAX - 1);
	if (!aOut) return SQLITE_NOMEM;

	p = aOut;
	fts3GetDeltaVarint3(&p1, pEnd1, 0, &i1);
	fts3GetDeltaVarint3(&p2, pEnd2, 0, &i2);
	while (p1 || p2) {
		sqlite3_int64 iDiff = DOCID_CMP(i1, i2);

		if (p2 && p1 && iDiff == 0) {
			fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);
			fts3PoslistMerge(&p, &p1, &p2);
			fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);
			fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);
		}
		else if (!p2 || (p1 && iDiff<0)) {
			fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);
			fts3PoslistCopy(&p, &p1);
			fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);
		}
		else {
			fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i2);
			fts3PoslistCopy(&p, &p2);
			fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);
		}
	}

	*paOut = aOut;
	*pnOut = (int)(p - aOut);
	assert(*pnOut <= n1 + n2 + FTS3_VARINT_MAX - 1);
	return SQLITE_OK;
}


static int fts3DoclistPhraseMerge(
	int bDescDoclist,               
	int nDist,                      
	char *aLeft, int nLeft,         
	char **paRight, int *pnRight    
) {
	sqlite3_int64 i1 = 0;
	sqlite3_int64 i2 = 0;
	sqlite3_int64 iPrev = 0;
	char *aRight = *paRight;
	char *pEnd1 = &aLeft[nLeft];
	char *pEnd2 = &aRight[*pnRight];
	char *p1 = aLeft;
	char *p2 = aRight;
	char *p;
	int bFirstOut = 0;
	char *aOut;

	assert(nDist>0);
	if (bDescDoclist) {
		aOut = sqlite3_malloc(*pnRight + FTS3_VARINT_MAX);
		if (aOut == 0) return SQLITE_NOMEM;
	}
	else {
		aOut = aRight;
	}
	p = aOut;

	fts3GetDeltaVarint3(&p1, pEnd1, 0, &i1);
	fts3GetDeltaVarint3(&p2, pEnd2, 0, &i2);

	while (p1 && p2) {
		sqlite3_int64 iDiff = DOCID_CMP(i1, i2);
		if (iDiff == 0) {
			char *pSave = p;
			sqlite3_int64 iPrevSave = iPrev;
			int bFirstOutSave = bFirstOut;

			fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);
			if (0 == fts3PoslistPhraseMerge(&p, nDist, 0, 1, &p1, &p2)) {
				p = pSave;
				iPrev = iPrevSave;
				bFirstOut = bFirstOutSave;
			}
			fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);
			fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);
		}
		else if (iDiff<0) {
			fts3PoslistCopy(0, &p1);
			fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);
		}
		else {
			fts3PoslistCopy(0, &p2);
			fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);
		}
	}

	*pnRight = (int)(p - aOut);
	if (bDescDoclist) {
		sqlite3_free(aRight);
		*paRight = aOut;
	}

	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3FirstFilter(
	sqlite3_int64 iDelta,           
	char *pList,                    
	int nList,                      
	char *pOut                      
) {
	int nOut = 0;
	int bWritten = 0;               
	char *p = pList;
	char *pEnd = &pList[nList];

	if (*p != 0x01) {
		if (*p == 0x02) {
			nOut += sqlite3Fts3PutVarint(&pOut[nOut], iDelta);
			pOut[nOut++] = 0x02;
			bWritten = 1;
		}
		fts3ColumnlistCopy(0, &p);
	}

	while (p<pEnd && *p == 0x01) {
		sqlite3_int64 iCol;
		p++;
		p += sqlite3Fts3GetVarint(p, &iCol);
		if (*p == 0x02) {
			if (bWritten == 0) {
				nOut += sqlite3Fts3PutVarint(&pOut[nOut], iDelta);
				bWritten = 1;
			}
			pOut[nOut++] = 0x01;
			nOut += sqlite3Fts3PutVarint(&pOut[nOut], iCol);
			pOut[nOut++] = 0x02;
		}
		fts3ColumnlistCopy(0, &p);
	}
	if (bWritten) {
		pOut[nOut++] = 0x00;
	}

	return nOut;
}



static int fts3TermSelectFinishMerge(Fts3Table *p, TermSelect *pTS) {
	char *aOut = 0;
	int nOut = 0;
	int i;

	
	for (i = 0; i<SizeofArray(pTS->aaOutput); i++) {
		if (pTS->aaOutput[i]) {
			if (!aOut) {
				aOut = pTS->aaOutput[i];
				nOut = pTS->anOutput[i];
				pTS->aaOutput[i] = 0;
			}
			else {
				int nNew;
				char *aNew;

				int rc = fts3DoclistOrMerge(p->bDescIdx,
					pTS->aaOutput[i], pTS->anOutput[i], aOut, nOut, &aNew, &nNew
				);
				if (rc != SQLITE_OK) {
					sqlite3_free(aOut);
					return rc;
				}

				sqlite3_free(pTS->aaOutput[i]);
				sqlite3_free(aOut);
				pTS->aaOutput[i] = 0;
				aOut = aNew;
				nOut = nNew;
			}
		}
	}

	pTS->aaOutput[0] = aOut;
	pTS->anOutput[0] = nOut;
	return SQLITE_OK;
}


static int fts3TermSelectMerge(
	Fts3Table *p,                   
	TermSelect *pTS,                
	char *aDoclist,                 
	int nDoclist                    
) {
	if (pTS->aaOutput[0] == 0) {
		
		pTS->aaOutput[0] = sqlite3_malloc(nDoclist + FTS3_VARINT_MAX + 1);
		pTS->anOutput[0] = nDoclist;
		if (pTS->aaOutput[0]) {
			memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
		}
		else {
			return SQLITE_NOMEM;
		}
	}
	else {
		char *aMerge = aDoclist;
		int nMerge = nDoclist;
		int iOut;

		for (iOut = 0; iOut<SizeofArray(pTS->aaOutput); iOut++) {
			if (pTS->aaOutput[iOut] == 0) {
				assert(iOut>0);
				pTS->aaOutput[iOut] = aMerge;
				pTS->anOutput[iOut] = nMerge;
				break;
			}
			else {
				char *aNew;
				int nNew;

				int rc = fts3DoclistOrMerge(p->bDescIdx, aMerge, nMerge,
					pTS->aaOutput[iOut], pTS->anOutput[iOut], &aNew, &nNew
				);
				if (rc != SQLITE_OK) {
					if (aMerge != aDoclist) sqlite3_free(aMerge);
					return rc;
				}

				if (aMerge != aDoclist) sqlite3_free(aMerge);
				sqlite3_free(pTS->aaOutput[iOut]);
				pTS->aaOutput[iOut] = 0;

				aMerge = aNew;
				nMerge = nNew;
				if ((iOut + 1) == SizeofArray(pTS->aaOutput)) {
					pTS->aaOutput[iOut] = aMerge;
					pTS->anOutput[iOut] = nMerge;
				}
			}
		}
	}
	return SQLITE_OK;
}


static int fts3SegReaderCursorAppend(
	Fts3MultiSegReader *pCsr,
	Fts3SegReader *pNew
) {
	if ((pCsr->nSegment % 16) == 0) {
		Fts3SegReader **apNew;
		int nByte = (pCsr->nSegment + 16) * sizeof(Fts3SegReader*);
		apNew = (Fts3SegReader **)sqlite3_realloc(pCsr->apSegment, nByte);
		if (!apNew) {
			sqlite3Fts3SegReaderFree(pNew);
			return SQLITE_NOMEM;
		}
		pCsr->apSegment = apNew;
	}
	pCsr->apSegment[pCsr->nSegment++] = pNew;
	return SQLITE_OK;
}


static int fts3SegReaderCursor(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int iLevel,                     
	const char *zTerm,              
	int nTerm,                      
	int isPrefix,                   
	int isScan,                     
	Fts3MultiSegReader *pCsr        
) {
	int rc = SQLITE_OK;             
	sqlite3_stmt *pStmt = 0;        
	int rc2;                        

									
	if (iLevel<0 && p->aIndex) {
		Fts3SegReader *pSeg = 0;
		rc = sqlite3Fts3SegReaderPending(p, iIndex, zTerm, nTerm, isPrefix || isScan, &pSeg);
		if (rc == SQLITE_OK && pSeg) {
			rc = fts3SegReaderCursorAppend(pCsr, pSeg);
		}
	}

	if (iLevel != FTS3_SEGCURSOR_PENDING) {
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts3AllSegdirs(p, iLangid, iIndex, iLevel, &pStmt);
		}

		while (rc == SQLITE_OK && SQLITE_ROW == (rc = sqlite3_step(pStmt))) {
			Fts3SegReader *pSeg = 0;

			
			sqlite3_int64 iStartBlock = sqlite3_column_int64(pStmt, 1);
			sqlite3_int64 iLeavesEndBlock = sqlite3_column_int64(pStmt, 2);
			sqlite3_int64 iEndBlock = sqlite3_column_int64(pStmt, 3);
			int nRoot = sqlite3_column_bytes(pStmt, 4);
			char const *zRoot = sqlite3_column_blob(pStmt, 4);

			
			if (iStartBlock && zTerm) {
				sqlite3_int64 *pi = (isPrefix ? &iLeavesEndBlock : 0);
				rc = fts3SelectLeaf(p, zTerm, nTerm, zRoot, nRoot, &iStartBlock, pi);
				if (rc != SQLITE_OK) goto finished;
				if (isPrefix == 0 && isScan == 0) iLeavesEndBlock = iStartBlock;
			}

			rc = sqlite3Fts3SegReaderNew(pCsr->nSegment + 1,
				(isPrefix == 0 && isScan == 0),
				iStartBlock, iLeavesEndBlock,
				iEndBlock, zRoot, nRoot, &pSeg
			);
			if (rc != SQLITE_OK) goto finished;
			rc = fts3SegReaderCursorAppend(pCsr, pSeg);
		}
	}

finished:
	rc2 = sqlite3_reset(pStmt);
	if (rc == SQLITE_DONE) rc = rc2;

	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int iLevel,                     
	const char *zTerm,              
	int nTerm,                      
	int isPrefix,                   
	int isScan,                     
	Fts3MultiSegReader *pCsr       
) {
	assert(iIndex >= 0 && iIndex<p->nIndex);
	assert(iLevel == FTS3_SEGCURSOR_ALL
		|| iLevel == FTS3_SEGCURSOR_PENDING
		|| iLevel >= 0
	);
	assert(iLevel<FTS3_SEGDIR_MAXLEVEL);
	assert(FTS3_SEGCURSOR_ALL<0 && FTS3_SEGCURSOR_PENDING<0);
	assert(isPrefix == 0 || isScan == 0);

	memset(pCsr, 0, sizeof(Fts3MultiSegReader));
	return fts3SegReaderCursor(
		p, iLangid, iIndex, iLevel, zTerm, nTerm, isPrefix, isScan, pCsr
	);
}


static int fts3SegReaderCursorAddZero(
	Fts3Table *p,                   
	int iLangid,
	const char *zTerm,              
	int nTerm,                      
	Fts3MultiSegReader *pCsr        
) {
	return fts3SegReaderCursor(p,
		iLangid, 0, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 0, 0, pCsr
	);
}


static int fts3TermSegReaderCursor(
	Fts3Cursor *pCsr,               
	const char *zTerm,              
	int nTerm,                      
	int isPrefix,                   
	Fts3MultiSegReader **ppSegcsr   
) {
	Fts3MultiSegReader *pSegcsr;    
	int rc = SQLITE_NOMEM;          

	pSegcsr = sqlite3_malloc(sizeof(Fts3MultiSegReader));
	if (pSegcsr) {
		int i;
		int bFound = 0;               
		Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;

		if (isPrefix) {
			for (i = 1; bFound == 0 && i<p->nIndex; i++) {
				if (p->aIndex[i].nPrefix == nTerm) {
					bFound = 1;
					rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,
						i, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 0, 0, pSegcsr
					);
					pSegcsr->bLookup = 1;
				}
			}

			for (i = 1; bFound == 0 && i<p->nIndex; i++) {
				if (p->aIndex[i].nPrefix == nTerm + 1) {
					bFound = 1;
					rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,
						i, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 1, 0, pSegcsr
					);
					if (rc == SQLITE_OK) {
						rc = fts3SegReaderCursorAddZero(
							p, pCsr->iLangid, zTerm, nTerm, pSegcsr
						);
					}
				}
			}
		}

		if (bFound == 0) {
			rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,
				0, FTS3_SEGCURSOR_ALL, zTerm, nTerm, isPrefix, 0, pSegcsr
			);
			pSegcsr->bLookup = !isPrefix;
		}
	}

	*ppSegcsr = pSegcsr;
	return rc;
}


static void fts3SegReaderCursorFree(Fts3MultiSegReader *pSegcsr) {
	sqlite3Fts3SegReaderFinish(pSegcsr);
	sqlite3_free(pSegcsr);
}


static int fts3TermSelect(
	Fts3Table *p,                   
	Fts3PhraseToken *pTok,          
	int iColumn,                    
	int *pnOut,                     
	char **ppOut                    
) {
	int rc;                         
	Fts3MultiSegReader *pSegcsr;    
	TermSelect tsc;                 
	Fts3SegFilter filter;           

	pSegcsr = pTok->pSegcsr;
	memset(&tsc, 0, sizeof(TermSelect));

	filter.flags = FTS3_SEGMENT_IGNORE_EMPTY | FTS3_SEGMENT_REQUIRE_POS
		| (pTok->isPrefix ? FTS3_SEGMENT_PREFIX : 0)
		| (pTok->bFirst ? FTS3_SEGMENT_FIRST : 0)
		| (iColumn<p->nColumn ? FTS3_SEGMENT_COLUMN_FILTER : 0);
	filter.iCol = iColumn;
	filter.zTerm = pTok->z;
	filter.nTerm = pTok->n;

	rc = sqlite3Fts3SegReaderStart(p, pSegcsr, &filter);
	while (SQLITE_OK == rc
		&& SQLITE_ROW == (rc = sqlite3Fts3SegReaderStep(p, pSegcsr))
		) {
		rc = fts3TermSelectMerge(p, &tsc, pSegcsr->aDoclist, pSegcsr->nDoclist);
	}

	if (rc == SQLITE_OK) {
		rc = fts3TermSelectFinishMerge(p, &tsc);
	}
	if (rc == SQLITE_OK) {
		*ppOut = tsc.aaOutput[0];
		*pnOut = tsc.anOutput[0];
	}
	else {
		int i;
		for (i = 0; i<SizeofArray(tsc.aaOutput); i++) {
			sqlite3_free(tsc.aaOutput[i]);
		}
	}

	fts3SegReaderCursorFree(pSegcsr);
	pTok->pSegcsr = 0;
	return rc;
}


static int fts3DoclistCountDocids(char *aList, int nList) {
	int nDoc = 0;                   
	if (aList) {
		char *aEnd = &aList[nList];   
		char *p = aList;              
		while (p<aEnd) {
			nDoc++;
			while ((*p++) & 0x80);     
			fts3PoslistCopy(0, &p);   
		}
	}

	return nDoc;
}


static int fts3NextMethod(sqlite3_vtab_cursor *pCursor) {
	int rc;
	Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
	if (pCsr->eSearch == FTS3_DOCID_SEARCH || pCsr->eSearch == FTS3_FULLSCAN_SEARCH) {
		if (SQLITE_ROW != sqlite3_step(pCsr->pStmt)) {
			pCsr->isEof = 1;
			rc = sqlite3_reset(pCsr->pStmt);
		}
		else {
			pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0);
			rc = SQLITE_OK;
		}
	}
	else {
		rc = fts3EvalNext((Fts3Cursor *)pCursor);
	}
	assert(((Fts3Table *)pCsr->base.pVtab)->pSegments == 0);
	return rc;
}


#ifndef SQLITE_AMALGAMATION
# define LARGEST_INT64  (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
#endif


static sqlite3_int64 fts3DocidRange(sqlite3_value *pVal, i64 iDefault) {
	if (pVal) {
		int eType = sqlite3_value_numeric_type(pVal);
		if (eType == SQLITE_INTEGER) {
			return sqlite3_value_int64(pVal);
		}
	}
	return iDefault;
}


static int fts3FilterMethod(
	sqlite3_vtab_cursor *pCursor,   
	int idxNum,                     
	const char *idxStr,             
	int nVal,                       
	sqlite3_value **apVal           
) {
	int rc = SQLITE_OK;
	char *zSql;                     
	int eSearch;
	Fts3Table *p = (Fts3Table *)pCursor->pVtab;
	Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;

	sqlite3_value *pCons = 0;       
	sqlite3_value *pLangid = 0;     
	sqlite3_value *pDocidGe = 0;    
	sqlite3_value *pDocidLe = 0;    
	int iIdx;

	UNUSED_PARAMETER(idxStr);
	UNUSED_PARAMETER(nVal);

	eSearch = (idxNum & 0x0000FFFF);
	assert(eSearch >= 0 && eSearch <= (FTS3_FULLTEXT_SEARCH + p->nColumn));
	assert(p->pSegments == 0);

	
	iIdx = 0;
	if (eSearch != FTS3_FULLSCAN_SEARCH) pCons = apVal[iIdx++];
	if (idxNum & FTS3_HAVE_LANGID) pLangid = apVal[iIdx++];
	if (idxNum & FTS3_HAVE_DOCID_GE) pDocidGe = apVal[iIdx++];
	if (idxNum & FTS3_HAVE_DOCID_LE) pDocidLe = apVal[iIdx++];
	assert(iIdx == nVal);

	
	sqlite3_finalize(pCsr->pStmt);
	sqlite3_free(pCsr->aDoclist);
	sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
	sqlite3Fts3ExprFree(pCsr->pExpr);
	memset(&pCursor[1], 0, sizeof(Fts3Cursor) - sizeof(sqlite3_vtab_cursor));

	
	pCsr->iMinDocid = fts3DocidRange(pDocidGe, SMALLEST_INT64);
	pCsr->iMaxDocid = fts3DocidRange(pDocidLe, LARGEST_INT64);

	if (idxStr) {
		pCsr->bDesc = (idxStr[0] == 'D');
	}
	else {
		pCsr->bDesc = p->bDescIdx;
	}
	pCsr->eSearch = (i16)eSearch;

	if (eSearch != FTS3_DOCID_SEARCH && eSearch != FTS3_FULLSCAN_SEARCH) {
		int iCol = eSearch - FTS3_FULLTEXT_SEARCH;
		const char *zQuery = (const char *)sqlite3_value_text(pCons);

		if (zQuery == 0 && sqlite3_value_type(pCons) != SQLITE_NULL) {
			return SQLITE_NOMEM;
		}

		pCsr->iLangid = 0;
		if (pLangid) pCsr->iLangid = sqlite3_value_int(pLangid);

		assert(p->base.zErrMsg == 0);
		rc = sqlite3Fts3ExprParse(p->pTokenizer, pCsr->iLangid,
			p->azColumn, p->bFts4, p->nColumn, iCol, zQuery, -1, &pCsr->pExpr,
			&p->base.zErrMsg
		);
		if (rc != SQLITE_OK) {
			return rc;
		}

		rc = fts3EvalStart(pCsr);
		sqlite3Fts3SegmentsClose(p);
		if (rc != SQLITE_OK) return rc;
		pCsr->pNextId = pCsr->aDoclist;
		pCsr->iPrevId = 0;
	}

	
	if (eSearch == FTS3_FULLSCAN_SEARCH) {
		if (pDocidGe || pDocidLe) {
			zSql = sqlite3_mprintf(
				"SELECT %s WHERE rowid BETWEEN %lld AND %lld ORDER BY rowid %s",
				p->zReadExprlist, pCsr->iMinDocid, pCsr->iMaxDocid,
				(pCsr->bDesc ? "DESC" : "ASC")
			);
		}
		else {
			zSql = sqlite3_mprintf("SELECT %s ORDER BY rowid %s",
				p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")
			);
		}
		if (zSql) {
			rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
			sqlite3_free(zSql);
		}
		else {
			rc = SQLITE_NOMEM;
		}
	}
	else if (eSearch == FTS3_DOCID_SEARCH) {
		rc = fts3CursorSeekStmt(pCsr, &pCsr->pStmt);
		if (rc == SQLITE_OK) {
			rc = sqlite3_bind_value(pCsr->pStmt, 1, pCons);
		}
	}
	if (rc != SQLITE_OK) return rc;

	return fts3NextMethod(pCursor);
}


static int fts3EofMethod(sqlite3_vtab_cursor *pCursor) {
	return ((Fts3Cursor *)pCursor)->isEof;
}


static int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid) {
	Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
	*pRowid = pCsr->iPrevId;
	return SQLITE_OK;
}


static int fts3ColumnMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite3_context *pCtx,          
	int iCol                        
) {
	int rc = SQLITE_OK;             
	Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
	Fts3Table *p = (Fts3Table *)pCursor->pVtab;

	
	assert(iCol >= 0 && iCol <= p->nColumn + 2);

	if (iCol == p->nColumn + 1) {
		
		sqlite3_result_int64(pCtx, pCsr->iPrevId);
	}
	else if (iCol == p->nColumn) {
		
		sqlite3_result_blob(pCtx, &pCsr, sizeof(pCsr), SQLITE_TRANSIENT);
	}
	else if (iCol == p->nColumn + 2 && pCsr->pExpr) {
		sqlite3_result_int64(pCtx, pCsr->iLangid);
	}
	else {
		
		rc = fts3CursorSeek(0, pCsr);

		if (rc == SQLITE_OK) {
			if (iCol == p->nColumn + 2) {
				int iLangid = 0;
				if (p->zLanguageid) {
					iLangid = sqlite3_column_int(pCsr->pStmt, p->nColumn + 1);
				}
				sqlite3_result_int(pCtx, iLangid);
			}
			else if (sqlite3_data_count(pCsr->pStmt)>(iCol + 1)) {
				sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol + 1));
			}
		}
	}

	assert(((Fts3Table *)pCsr->base.pVtab)->pSegments == 0);
	return rc;
}


static int fts3UpdateMethod(
	sqlite3_vtab *pVtab,            
	int nArg,                       
	sqlite3_value **apVal,          
	sqlite_int64 *pRowid            
) {
	return sqlite3Fts3UpdateMethod(pVtab, nArg, apVal, pRowid);
}


static int fts3SyncMethod(sqlite3_vtab *pVtab) {

	
	const u32 nMinMerge = 64;       

	Fts3Table *p = (Fts3Table*)pVtab;
	int rc = sqlite3Fts3PendingTermsFlush(p);

	if (rc == SQLITE_OK
		&& p->nLeafAdd>(nMinMerge / 16)
		&& p->nAutoincrmerge && p->nAutoincrmerge != 0xff
		) {
		int mxLevel = 0;              
		int A;                        

		rc = sqlite3Fts3MaxLevel(p, &mxLevel);
		assert(rc == SQLITE_OK || mxLevel == 0);
		A = p->nLeafAdd * mxLevel;
		A += (A / 2);
		if (A>(int)nMinMerge) rc = sqlite3Fts3Incrmerge(p, A, p->nAutoincrmerge);
	}
	sqlite3Fts3SegmentsClose(p);
	return rc;
}


static int fts3SetHasStat(Fts3Table *p) {
	int rc = SQLITE_OK;
	if (p->bHasStat == 2) {
		const char *zFmt = "SELECT 1 FROM %Q.sqlite_master WHERE tbl_name='%q_stat'";
		char *zSql = sqlite3_mprintf(zFmt, p->zDb, p->zName);
		if (zSql) {
			sqlite3_stmt *pStmt = 0;
			rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
			if (rc == SQLITE_OK) {
				int bHasStat = (sqlite3_step(pStmt) == SQLITE_ROW);
				rc = sqlite3_finalize(pStmt);
				if (rc == SQLITE_OK) p->bHasStat = bHasStat;
			}
			sqlite3_free(zSql);
		}
		else {
			rc = SQLITE_NOMEM;
		}
	}
	return rc;
}


static int fts3BeginMethod(sqlite3_vtab *pVtab) {
	Fts3Table *p = (Fts3Table*)pVtab;
	UNUSED_PARAMETER(pVtab);
	assert(p->pSegments == 0);
	assert(p->nPendingData == 0);
	assert(p->inTransaction != 1);
	TESTONLY(p->inTransaction = 1);
	TESTONLY(p->mxSavepoint = -1; );
	p->nLeafAdd = 0;
	return fts3SetHasStat(p);
}


static int fts3CommitMethod(sqlite3_vtab *pVtab) {
	TESTONLY(Fts3Table *p = (Fts3Table*)pVtab);
	UNUSED_PARAMETER(pVtab);
	assert(p->nPendingData == 0);
	assert(p->inTransaction != 0);
	assert(p->pSegments == 0);
	TESTONLY(p->inTransaction = 0);
	TESTONLY(p->mxSavepoint = -1; );
	return SQLITE_OK;
}


static int fts3RollbackMethod(sqlite3_vtab *pVtab) {
	Fts3Table *p = (Fts3Table*)pVtab;
	sqlite3Fts3PendingTermsClear(p);
	assert(p->inTransaction != 0);
	TESTONLY(p->inTransaction = 0);
	TESTONLY(p->mxSavepoint = -1; );
	return SQLITE_OK;
}


static void fts3ReversePoslist(char *pStart, char **ppPoslist) {
	char *p = &(*ppPoslist)[-2];
	char c = 0;

	
	while (p>pStart && (c = *p--) == 0);

	
	while (p>pStart && (*p & 0x80) | c) {
		c = *p--;
	}
	assert(p == pStart || c == 0);

	
	if (p>pStart || (c == 0 && *ppPoslist>&p[2])) { p = &p[2]; }
	while (*p++ & 0x80);
	*ppPoslist = p;
}


static int fts3FunctionArg(
	sqlite3_context *pContext,      
	const char *zFunc,              
	sqlite3_value *pVal,            
	Fts3Cursor **ppCsr              
) {
	Fts3Cursor *pRet;
	if (sqlite3_value_type(pVal) != SQLITE_BLOB
		|| sqlite3_value_bytes(pVal) != sizeof(Fts3Cursor *)
		) {
		char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
		sqlite3_result_error(pContext, zErr, -1);
		sqlite3_free(zErr);
		return SQLITE_ERROR;
	}
	memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
	*ppCsr = pRet;
	return SQLITE_OK;
}


static void fts3SnippetFunc(
	sqlite3_context *pContext,      
	int nVal,                       
	sqlite3_value **apVal           
) {
	Fts3Cursor *pCsr;               
	const char *zStart = "<b>";
	const char *zEnd = "</b>";
	const char *zEllipsis = "<b>...</b>";
	int iCol = -1;
	int nToken = 15;                

									
	assert(nVal >= 1);

	if (nVal>6) {
		sqlite3_result_error(pContext,
			"wrong number of arguments to function snippet()", -1);
		return;
	}
	if (fts3FunctionArg(pContext, "snippet", apVal[0], &pCsr)) return;

	switch (nVal) {
	case 6: nToken = sqlite3_value_int(apVal[5]);
	case 5: iCol = sqlite3_value_int(apVal[4]);
	case 4: zEllipsis = (const char*)sqlite3_value_text(apVal[3]);
	case 3: zEnd = (const char*)sqlite3_value_text(apVal[2]);
	case 2: zStart = (const char*)sqlite3_value_text(apVal[1]);
	}
	if (!zEllipsis || !zEnd || !zStart) {
		sqlite3_result_error_nomem(pContext);
	}
	else if (nToken == 0) {
		sqlite3_result_text(pContext, "", -1, SQLITE_STATIC);
	}
	else if (SQLITE_OK == fts3CursorSeek(pContext, pCsr)) {
		sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);
	}
}


static void fts3OffsetsFunc(
	sqlite3_context *pContext,      
	int nVal,                       
	sqlite3_value **apVal           
) {
	Fts3Cursor *pCsr;               

	UNUSED_PARAMETER(nVal);

	assert(nVal == 1);
	if (fts3FunctionArg(pContext, "offsets", apVal[0], &pCsr)) return;
	assert(pCsr);
	if (SQLITE_OK == fts3CursorSeek(pContext, pCsr)) {
		sqlite3Fts3Offsets(pContext, pCsr);
	}
}


static void fts3OptimizeFunc(
	sqlite3_context *pContext,      
	int nVal,                       
	sqlite3_value **apVal           
) {
	int rc;                         
	Fts3Table *p;                   
	Fts3Cursor *pCursor;            

	UNUSED_PARAMETER(nVal);

	assert(nVal == 1);
	if (fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor)) return;
	p = (Fts3Table *)pCursor->base.pVtab;
	assert(p);

	rc = sqlite3Fts3Optimize(p);

	switch (rc) {
	case SQLITE_OK:
		sqlite3_result_text(pContext, "Index optimized", -1, SQLITE_STATIC);
		break;
	case SQLITE_DONE:
		sqlite3_result_text(pContext, "Index already optimal", -1, SQLITE_STATIC);
		break;
	default:
		sqlite3_result_error_code(pContext, rc);
		break;
	}
}


static void fts3MatchinfoFunc(
	sqlite3_context *pContext,      
	int nVal,                       
	sqlite3_value **apVal           
) {
	Fts3Cursor *pCsr;               
	assert(nVal == 1 || nVal == 2);
	if (SQLITE_OK == fts3FunctionArg(pContext, "matchinfo", apVal[0], &pCsr)) {
		const char *zArg = 0;
		if (nVal>1) {
			zArg = (const char *)sqlite3_value_text(apVal[1]);
		}
		sqlite3Fts3Matchinfo(pContext, pCsr, zArg);
	}
}


static int fts3FindFunctionMethod(
	sqlite3_vtab *pVtab,            
	int nArg,                       
	const char *zName,              
	void(**pxFunc)(sqlite3_context*, int, sqlite3_value**), 
	void **ppArg                    
) {
	struct Overloaded {
		const char *zName;
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**);
	} aOverload[] = {
		{ "snippet", fts3SnippetFunc },
		{ "offsets", fts3OffsetsFunc },
		{ "optimize", fts3OptimizeFunc },
		{ "matchinfo", fts3MatchinfoFunc },
	};
	int i;                          

	UNUSED_PARAMETER(pVtab);
	UNUSED_PARAMETER(nArg);
	UNUSED_PARAMETER(ppArg);

	for (i = 0; i<SizeofArray(aOverload); i++) {
		if (strcmp(zName, aOverload[i].zName) == 0) {
			*pxFunc = aOverload[i].xFunc;
			return 1;
		}
	}

	
	return 0;
}


static int fts3RenameMethod(
	sqlite3_vtab *pVtab,            
	const char *zName               
) {
	Fts3Table *p = (Fts3Table *)pVtab;
	sqlite3 *db = p->db;            
	int rc;                         

									
	rc = fts3SetHasStat(p);

	
	assert(p->nPendingData == 0);
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts3PendingTermsFlush(p);
	}

	if (p->zContentTbl == 0) {
		fts3DbExec(&rc, db,
			"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';",
			p->zDb, p->zName, zName
		);
	}

	if (p->bHasDocsize) {
		fts3DbExec(&rc, db,
			"ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';",
			p->zDb, p->zName, zName
		);
	}
	if (p->bHasStat) {
		fts3DbExec(&rc, db,
			"ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';",
			p->zDb, p->zName, zName
		);
	}
	fts3DbExec(&rc, db,
		"ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';",
		p->zDb, p->zName, zName
	);
	fts3DbExec(&rc, db,
		"ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';",
		p->zDb, p->zName, zName
	);
	return rc;
}


static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	int rc = SQLITE_OK;
	UNUSED_PARAMETER(iSavepoint);
	assert(((Fts3Table *)pVtab)->inTransaction);
	assert(((Fts3Table *)pVtab)->mxSavepoint < iSavepoint);
	TESTONLY(((Fts3Table *)pVtab)->mxSavepoint = iSavepoint);
	if (((Fts3Table *)pVtab)->bIgnoreSavepoint == 0) {
		rc = fts3SyncMethod(pVtab);
	}
	return rc;
}


static int fts3ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	TESTONLY(Fts3Table *p = (Fts3Table*)pVtab);
	UNUSED_PARAMETER(iSavepoint);
	UNUSED_PARAMETER(pVtab);
	assert(p->inTransaction);
	assert(p->mxSavepoint >= iSavepoint);
	TESTONLY(p->mxSavepoint = iSavepoint - 1);
	return SQLITE_OK;
}


static int fts3RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	Fts3Table *p = (Fts3Table*)pVtab;
	UNUSED_PARAMETER(iSavepoint);
	assert(p->inTransaction);
	assert(p->mxSavepoint >= iSavepoint);
	TESTONLY(p->mxSavepoint = iSavepoint);
	sqlite3Fts3PendingTermsClear(p);
	return SQLITE_OK;
}

static const sqlite3_module fts3Module = {
	 2,
	 fts3CreateMethod,
	 fts3ConnectMethod,
	 fts3BestIndexMethod,
	 fts3DisconnectMethod,
	 fts3DestroyMethod,
	 fts3OpenMethod,
	 fts3CloseMethod,
	 fts3FilterMethod,
	 fts3NextMethod,
	 fts3EofMethod,
	 fts3ColumnMethod,
	 fts3RowidMethod,
	 fts3UpdateMethod,
	 fts3BeginMethod,
	 fts3SyncMethod,
	 fts3CommitMethod,
	 fts3RollbackMethod,
	 fts3FindFunctionMethod,
	       fts3RenameMethod,
	 fts3SavepointMethod,
	 fts3ReleaseMethod,
	 fts3RollbackToMethod,
};


static void hashDestroy(void *p) {
	Fts3Hash *pHash = (Fts3Hash *)p;
	sqlite3Fts3HashClear(pHash);
	sqlite3_free(pHash);
}


SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);
SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(sqlite3_tokenizer_module const**ppModule);
#ifndef SQLITE_DISABLE_FTS3_UNICODE
SQLITE_PRIVATE void sqlite3Fts3UnicodeTokenizer(sqlite3_tokenizer_module const**ppModule);
#endif
#ifdef SQLITE_ENABLE_ICU
SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(sqlite3_tokenizer_module const**ppModule);
#endif


SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db) {
	int rc = SQLITE_OK;
	Fts3Hash *pHash = 0;
	const sqlite3_tokenizer_module *pSimple = 0;
	const sqlite3_tokenizer_module *pPorter = 0;
#ifndef SQLITE_DISABLE_FTS3_UNICODE
	const sqlite3_tokenizer_module *pUnicode = 0;
#endif

#ifdef SQLITE_ENABLE_ICU
	const sqlite3_tokenizer_module *pIcu = 0;
	sqlite3Fts3IcuTokenizerModule(&pIcu);
#endif

#ifndef SQLITE_DISABLE_FTS3_UNICODE
	sqlite3Fts3UnicodeTokenizer(&pUnicode);
#endif

#ifdef SQLITE_TEST
	rc = sqlite3Fts3InitTerm(db);
	if (rc != SQLITE_OK) return rc;
#endif

	rc = sqlite3Fts3InitAux(db);
	if (rc != SQLITE_OK) return rc;

	sqlite3Fts3SimpleTokenizerModule(&pSimple);
	sqlite3Fts3PorterTokenizerModule(&pPorter);

	
	pHash = sqlite3_malloc(sizeof(Fts3Hash));
	if (!pHash) {
		rc = SQLITE_NOMEM;
	}
	else {
		sqlite3Fts3HashInit(pHash, FTS3_HASH_STRING, 1);
	}

	
	if (rc == SQLITE_OK) {
		if (sqlite3Fts3HashInsert(pHash, "simple", 7, (void *)pSimple)
			|| sqlite3Fts3HashInsert(pHash, "porter", 7, (void *)pPorter)

#ifndef SQLITE_DISABLE_FTS3_UNICODE
			|| sqlite3Fts3HashInsert(pHash, "unicode61", 10, (void *)pUnicode)
#endif
#ifdef SQLITE_ENABLE_ICU
			|| (pIcu && sqlite3Fts3HashInsert(pHash, "icu", 4, (void *)pIcu))
#endif
			) {
			rc = SQLITE_NOMEM;
		}
	}

#ifdef SQLITE_TEST
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts3ExprInitTestInterface(db);
	}
#endif

	
	if (SQLITE_OK == rc
		&& SQLITE_OK == (rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))
		&& SQLITE_OK == (rc = sqlite3_overload_function(db, "snippet", -1))
		&& SQLITE_OK == (rc = sqlite3_overload_function(db, "offsets", 1))
		&& SQLITE_OK == (rc = sqlite3_overload_function(db, "matchinfo", 1))
		&& SQLITE_OK == (rc = sqlite3_overload_function(db, "matchinfo", 2))
		&& SQLITE_OK == (rc = sqlite3_overload_function(db, "optimize", 1))
		) {
		rc = sqlite3_create_module_v2(
			db, "fts3", &fts3Module, (void *)pHash, hashDestroy
		);
		if (rc == SQLITE_OK) {
			rc = sqlite3_create_module_v2(
				db, "fts4", &fts3Module, (void *)pHash, 0
			);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts3InitTok(db, (void *)pHash);
		}
		return rc;
	}


	
	assert(rc != SQLITE_OK);
	if (pHash) {
		sqlite3Fts3HashClear(pHash);
		sqlite3_free(pHash);
	}
	return rc;
}


static void fts3EvalAllocateReaders(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	int *pnToken,                   
	int *pnOr,                      
	int *pRc                        
) {
	if (pExpr && SQLITE_OK == *pRc) {
		if (pExpr->eType == FTSQUERY_PHRASE) {
			int i;
			int nToken = pExpr->pPhrase->nToken;
			*pnToken += nToken;
			for (i = 0; i<nToken; i++) {
				Fts3PhraseToken *pToken = &pExpr->pPhrase->aToken[i];
				int rc = fts3TermSegReaderCursor(pCsr,
					pToken->z, pToken->n, pToken->isPrefix, &pToken->pSegcsr
				);
				if (rc != SQLITE_OK) {
					*pRc = rc;
					return;
				}
			}
			assert(pExpr->pPhrase->iDoclistToken == 0);
			pExpr->pPhrase->iDoclistToken = -1;
		}
		else {
			*pnOr += (pExpr->eType == FTSQUERY_OR);
			fts3EvalAllocateReaders(pCsr, pExpr->pLeft, pnToken, pnOr, pRc);
			fts3EvalAllocateReaders(pCsr, pExpr->pRight, pnToken, pnOr, pRc);
		}
	}
}


static int fts3EvalPhraseMergeToken(
	Fts3Table *pTab,                
	Fts3Phrase *p,                  
	int iToken,                     
	char *pList,                    
	int nList                       
) {
	int rc = SQLITE_OK;
	assert(iToken != p->iDoclistToken);

	if (pList == 0) {
		sqlite3_free(p->doclist.aAll);
		p->doclist.aAll = 0;
		p->doclist.nAll = 0;
	}

	else if (p->iDoclistToken<0) {
		p->doclist.aAll = pList;
		p->doclist.nAll = nList;
	}

	else if (p->doclist.aAll == 0) {
		sqlite3_free(pList);
	}

	else {
		char *pLeft;
		char *pRight;
		int nLeft;
		int nRight;
		int nDiff;

		if (p->iDoclistToken<iToken) {
			pLeft = p->doclist.aAll;
			nLeft = p->doclist.nAll;
			pRight = pList;
			nRight = nList;
			nDiff = iToken - p->iDoclistToken;
		}
		else {
			pRight = p->doclist.aAll;
			nRight = p->doclist.nAll;
			pLeft = pList;
			nLeft = nList;
			nDiff = p->iDoclistToken - iToken;
		}

		rc = fts3DoclistPhraseMerge(
			pTab->bDescIdx, nDiff, pLeft, nLeft, &pRight, &nRight
		);
		sqlite3_free(pLeft);
		p->doclist.aAll = pRight;
		p->doclist.nAll = nRight;
	}

	if (iToken>p->iDoclistToken) p->iDoclistToken = iToken;
	return rc;
}


static int fts3EvalPhraseLoad(
	Fts3Cursor *pCsr,               
	Fts3Phrase *p                   
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int iToken;
	int rc = SQLITE_OK;

	for (iToken = 0; rc == SQLITE_OK && iToken<p->nToken; iToken++) {
		Fts3PhraseToken *pToken = &p->aToken[iToken];
		assert(pToken->pDeferred == 0 || pToken->pSegcsr == 0);

		if (pToken->pSegcsr) {
			int nThis = 0;
			char *pThis = 0;
			rc = fts3TermSelect(pTab, pToken, p->iColumn, &nThis, &pThis);
			if (rc == SQLITE_OK) {
				rc = fts3EvalPhraseMergeToken(pTab, p, iToken, pThis, nThis);
			}
		}
		assert(pToken->pSegcsr == 0);
	}

	return rc;
}


static int fts3EvalDeferredPhrase(Fts3Cursor *pCsr, Fts3Phrase *pPhrase) {
	int iToken;                     
	char *aPoslist = 0;             
	int nPoslist = 0;               
	int iPrev = -1;                 

	assert(pPhrase->doclist.bFreeList == 0);

	for (iToken = 0; iToken<pPhrase->nToken; iToken++) {
		Fts3PhraseToken *pToken = &pPhrase->aToken[iToken];
		Fts3DeferredToken *pDeferred = pToken->pDeferred;

		if (pDeferred) {
			char *pList;
			int nList;
			int rc = sqlite3Fts3DeferredTokenList(pDeferred, &pList, &nList);
			if (rc != SQLITE_OK) return rc;

			if (pList == 0) {
				sqlite3_free(aPoslist);
				pPhrase->doclist.pList = 0;
				pPhrase->doclist.nList = 0;
				return SQLITE_OK;

			}
			else if (aPoslist == 0) {
				aPoslist = pList;
				nPoslist = nList;

			}
			else {
				char *aOut = pList;
				char *p1 = aPoslist;
				char *p2 = aOut;

				assert(iPrev >= 0);
				fts3PoslistPhraseMerge(&aOut, iToken - iPrev, 0, 1, &p1, &p2);
				sqlite3_free(aPoslist);
				aPoslist = pList;
				nPoslist = (int)(aOut - aPoslist);
				if (nPoslist == 0) {
					sqlite3_free(aPoslist);
					pPhrase->doclist.pList = 0;
					pPhrase->doclist.nList = 0;
					return SQLITE_OK;
				}
			}
			iPrev = iToken;
		}
	}

	if (iPrev >= 0) {
		int nMaxUndeferred = pPhrase->iDoclistToken;
		if (nMaxUndeferred<0) {
			pPhrase->doclist.pList = aPoslist;
			pPhrase->doclist.nList = nPoslist;
			pPhrase->doclist.iDocid = pCsr->iPrevId;
			pPhrase->doclist.bFreeList = 1;
		}
		else {
			int nDistance;
			char *p1;
			char *p2;
			char *aOut;

			if (nMaxUndeferred>iPrev) {
				p1 = aPoslist;
				p2 = pPhrase->doclist.pList;
				nDistance = nMaxUndeferred - iPrev;
			}
			else {
				p1 = pPhrase->doclist.pList;
				p2 = aPoslist;
				nDistance = iPrev - nMaxUndeferred;
			}

			aOut = (char *)sqlite3_malloc(nPoslist + 8);
			if (!aOut) {
				sqlite3_free(aPoslist);
				return SQLITE_NOMEM;
			}

			pPhrase->doclist.pList = aOut;
			if (fts3PoslistPhraseMerge(&aOut, nDistance, 0, 1, &p1, &p2)) {
				pPhrase->doclist.bFreeList = 1;
				pPhrase->doclist.nList = (int)(aOut - pPhrase->doclist.pList);
			}
			else {
				sqlite3_free(aOut);
				pPhrase->doclist.pList = 0;
				pPhrase->doclist.nList = 0;
			}
			sqlite3_free(aPoslist);
		}
	}

	return SQLITE_OK;
}


#define MAX_INCR_PHRASE_TOKENS 4


static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc = SQLITE_OK;             
	int i;

	
	int bHaveIncr = 0;
	int bIncrOk = (bOptOk
		&& pCsr->bDesc == pTab->bDescIdx
		&& p->nToken <= MAX_INCR_PHRASE_TOKENS && p->nToken>0
#ifdef SQLITE_TEST
		&& pTab->bNoIncrDoclist == 0
#endif
		);
	for (i = 0; bIncrOk == 1 && i<p->nToken; i++) {
		Fts3PhraseToken *pToken = &p->aToken[i];
		if (pToken->bFirst || (pToken->pSegcsr != 0 && !pToken->pSegcsr->bLookup)) {
			bIncrOk = 0;
		}
		if (pToken->pSegcsr) bHaveIncr = 1;
	}

	if (bIncrOk && bHaveIncr) {
		
		int iCol = (p->iColumn >= pTab->nColumn ? -1 : p->iColumn);
		for (i = 0; rc == SQLITE_OK && i<p->nToken; i++) {
			Fts3PhraseToken *pToken = &p->aToken[i];
			Fts3MultiSegReader *pSegcsr = pToken->pSegcsr;
			if (pSegcsr) {
				rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n);
			}
		}
		p->bIncr = 1;
	}
	else {
		
		rc = fts3EvalPhraseLoad(pCsr, p);
		p->bIncr = 0;
	}

	assert(rc != SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr == 0 || p->bIncr);
	return rc;
}


SQLITE_PRIVATE void sqlite3Fts3DoclistPrev(
	int bDescIdx,                   
	char *aDoclist,                 
	int nDoclist,                   
	char **ppIter,                  
	sqlite3_int64 *piDocid,         
	int *pnList,                    
	u8 *pbEof                       
) {
	char *p = *ppIter;

	assert(nDoclist>0);
	assert(*pbEof == 0);
	assert(p || *piDocid == 0);
	assert(!p || (p>aDoclist && p<&aDoclist[nDoclist]));

	if (p == 0) {
		sqlite3_int64 iDocid = 0;
		char *pNext = 0;
		char *pDocid = aDoclist;
		char *pEnd = &aDoclist[nDoclist];
		int iMul = 1;

		while (pDocid<pEnd) {
			sqlite3_int64 iDelta;
			pDocid += sqlite3Fts3GetVarint(pDocid, &iDelta);
			iDocid += (iMul * iDelta);
			pNext = pDocid;
			fts3PoslistCopy(0, &pDocid);
			while (pDocid<pEnd && *pDocid == 0) pDocid++;
			iMul = (bDescIdx ? -1 : 1);
		}

		*pnList = (int)(pEnd - pNext);
		*ppIter = pNext;
		*piDocid = iDocid;
	}
	else {
		int iMul = (bDescIdx ? -1 : 1);
		sqlite3_int64 iDelta;
		fts3GetReverseVarint(&p, aDoclist, &iDelta);
		*piDocid -= (iMul * iDelta);

		if (p == aDoclist) {
			*pbEof = 1;
		}
		else {
			char *pSave = p;
			fts3ReversePoslist(aDoclist, &p);
			*pnList = (int)(pSave - p);
		}
		*ppIter = p;
	}
}


SQLITE_PRIVATE void sqlite3Fts3DoclistNext(
	int bDescIdx,                   
	char *aDoclist,                 
	int nDoclist,                   
	char **ppIter,                  
	sqlite3_int64 *piDocid,         
	u8 *pbEof                       
) {
	char *p = *ppIter;

	assert(nDoclist>0);
	assert(*pbEof == 0);
	assert(p || *piDocid == 0);
	assert(!p || (p >= aDoclist && p <= &aDoclist[nDoclist]));

	if (p == 0) {
		p = aDoclist;
		p += sqlite3Fts3GetVarint(p, piDocid);
	}
	else {
		fts3PoslistCopy(0, &p);
		while (p<&aDoclist[nDoclist] && *p == 0) p++;
		if (p >= &aDoclist[nDoclist]) {
			*pbEof = 1;
		}
		else {
			sqlite3_int64 iVar;
			p += sqlite3Fts3GetVarint(p, &iVar);
			*piDocid += ((bDescIdx ? -1 : 1) * iVar);
		}
	}

	*ppIter = p;
}


static void fts3EvalDlPhraseNext(
	Fts3Table *pTab,
	Fts3Doclist *pDL,
	u8 *pbEof
) {
	char *pIter;                            
	char *pEnd = &pDL->aAll[pDL->nAll];     

	if (pDL->pNextDocid) {
		pIter = pDL->pNextDocid;
	}
	else {
		pIter = pDL->aAll;
	}

	if (pIter >= pEnd) {
		
		*pbEof = 1;
	}
	else {
		sqlite3_int64 iDelta;
		pIter += sqlite3Fts3GetVarint(pIter, &iDelta);
		if (pTab->bDescIdx == 0 || pDL->pNextDocid == 0) {
			pDL->iDocid += iDelta;
		}
		else {
			pDL->iDocid -= iDelta;
		}
		pDL->pList = pIter;
		fts3PoslistCopy(0, &pIter);
		pDL->nList = (int)(pIter - pDL->pList);

		
		while (pIter<pEnd && *pIter == 0) pIter++;

		pDL->pNextDocid = pIter;
		assert(pIter >= &pDL->aAll[pDL->nAll] || *pIter);
		*pbEof = 0;
	}
}


typedef struct TokenDoclist TokenDoclist;
struct TokenDoclist {
	int bIgnore;
	sqlite3_int64 iDocid;
	char *pList;
	int nList;
};


static int incrPhraseTokenNext(
	Fts3Table *pTab,                
	Fts3Phrase *pPhrase,            
	int iToken,                     
	TokenDoclist *p,                
	u8 *pbEof                       
) {
	int rc = SQLITE_OK;

	if (pPhrase->iDoclistToken == iToken) {
		assert(p->bIgnore == 0);
		assert(pPhrase->aToken[iToken].pSegcsr == 0);
		fts3EvalDlPhraseNext(pTab, &pPhrase->doclist, pbEof);
		p->pList = pPhrase->doclist.pList;
		p->nList = pPhrase->doclist.nList;
		p->iDocid = pPhrase->doclist.iDocid;
	}
	else {
		Fts3PhraseToken *pToken = &pPhrase->aToken[iToken];
		assert(pToken->pDeferred == 0);
		assert(pToken->pSegcsr || pPhrase->iDoclistToken >= 0);
		if (pToken->pSegcsr) {
			assert(p->bIgnore == 0);
			rc = sqlite3Fts3MsrIncrNext(
				pTab, pToken->pSegcsr, &p->iDocid, &p->pList, &p->nList
			);
			if (p->pList == 0) *pbEof = 1;
		}
		else {
			p->bIgnore = 1;
		}
	}

	return rc;
}



static int fts3EvalIncrPhraseNext(
	Fts3Cursor *pCsr,               
	Fts3Phrase *p,                  
	u8 *pbEof                       
) {
	int rc = SQLITE_OK;
	Fts3Doclist *pDL = &p->doclist;
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	u8 bEof = 0;

	
	assert(p->bIncr == 1);

	if (p->nToken == 1 && p->bIncr) {
		rc = sqlite3Fts3MsrIncrNext(pTab, p->aToken[0].pSegcsr,
			&pDL->iDocid, &pDL->pList, &pDL->nList
		);
		if (pDL->pList == 0) bEof = 1;
	}
	else {
		int bDescDoclist = pCsr->bDesc;
		struct TokenDoclist a[MAX_INCR_PHRASE_TOKENS];

		memset(a, 0, sizeof(a));
		assert(p->nToken <= MAX_INCR_PHRASE_TOKENS);
		assert(p->iDoclistToken<MAX_INCR_PHRASE_TOKENS);

		while (bEof == 0) {
			int bMaxSet = 0;
			sqlite3_int64 iMax = 0;     
			int i;                      

										
			for (i = 0; rc == SQLITE_OK && i<p->nToken && bEof == 0; i++) {
				rc = incrPhraseTokenNext(pTab, p, i, &a[i], &bEof);
				if (a[i].bIgnore == 0 && (bMaxSet == 0 || DOCID_CMP(iMax, a[i].iDocid)<0)) {
					iMax = a[i].iDocid;
					bMaxSet = 1;
				}
			}
			assert(rc != SQLITE_OK || (p->nToken >= 1 && a[p->nToken - 1].bIgnore == 0));
			assert(rc != SQLITE_OK || bMaxSet);

			
			for (i = 0; i<p->nToken; i++) {
				while (rc == SQLITE_OK && bEof == 0
					&& a[i].bIgnore == 0 && DOCID_CMP(a[i].iDocid, iMax)<0
					) {
					rc = incrPhraseTokenNext(pTab, p, i, &a[i], &bEof);
					if (DOCID_CMP(a[i].iDocid, iMax)>0) {
						iMax = a[i].iDocid;
						i = 0;
					}
				}
			}

			
			if (bEof == 0) {
				int nList = 0;
				int nByte = a[p->nToken - 1].nList;
				char *aDoclist = sqlite3_malloc(nByte + 1);
				if (!aDoclist) return SQLITE_NOMEM;
				memcpy(aDoclist, a[p->nToken - 1].pList, nByte + 1);

				for (i = 0; i<(p->nToken - 1); i++) {
					if (a[i].bIgnore == 0) {
						char *pL = a[i].pList;
						char *pR = aDoclist;
						char *pOut = aDoclist;
						int nDist = p->nToken - 1 - i;
						int res = fts3PoslistPhraseMerge(&pOut, nDist, 0, 1, &pL, &pR);
						if (res == 0) break;
						nList = (int)(pOut - aDoclist);
					}
				}
				if (i == (p->nToken - 1)) {
					pDL->iDocid = iMax;
					pDL->pList = aDoclist;
					pDL->nList = nList;
					pDL->bFreeList = 1;
					break;
				}
				sqlite3_free(aDoclist);
			}
		}
	}

	*pbEof = bEof;
	return rc;
}


static int fts3EvalPhraseNext(
	Fts3Cursor *pCsr,               
	Fts3Phrase *p,                  
	u8 *pbEof                       
) {
	int rc = SQLITE_OK;
	Fts3Doclist *pDL = &p->doclist;
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;

	if (p->bIncr) {
		rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof);
	}
	else if (pCsr->bDesc != pTab->bDescIdx && pDL->nAll) {
		sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll,
			&pDL->pNextDocid, &pDL->iDocid, &pDL->nList, pbEof
		);
		pDL->pList = pDL->pNextDocid;
	}
	else {
		fts3EvalDlPhraseNext(pTab, pDL, pbEof);
	}

	return rc;
}


static void fts3EvalStartReaders(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	int *pRc                        
) {
	if (pExpr && SQLITE_OK == *pRc) {
		if (pExpr->eType == FTSQUERY_PHRASE) {
			int nToken = pExpr->pPhrase->nToken;
			if (nToken) {
				int i;
				for (i = 0; i<nToken; i++) {
					if (pExpr->pPhrase->aToken[i].pDeferred == 0) break;
				}
				pExpr->bDeferred = (i == nToken);
			}
			*pRc = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase);
		}
		else {
			fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);
			fts3EvalStartReaders(pCsr, pExpr->pRight, pRc);
			pExpr->bDeferred = (pExpr->pLeft->bDeferred && pExpr->pRight->bDeferred);
		}
	}
}


typedef struct Fts3TokenAndCost Fts3TokenAndCost;
struct Fts3TokenAndCost {
	Fts3Phrase *pPhrase;            
	int iToken;                     
	Fts3PhraseToken *pToken;        
	Fts3Expr *pRoot;                
	int nOvfl;                      
	int iCol;                       
};


static void fts3EvalTokenCosts(
	Fts3Cursor *pCsr,               
	Fts3Expr *pRoot,                
	Fts3Expr *pExpr,                
	Fts3TokenAndCost **ppTC,        
	Fts3Expr ***ppOr,               
	int *pRc                        
) {
	if (*pRc == SQLITE_OK) {
		if (pExpr->eType == FTSQUERY_PHRASE) {
			Fts3Phrase *pPhrase = pExpr->pPhrase;
			int i;
			for (i = 0; *pRc == SQLITE_OK && i<pPhrase->nToken; i++) {
				Fts3TokenAndCost *pTC = (*ppTC)++;
				pTC->pPhrase = pPhrase;
				pTC->iToken = i;
				pTC->pRoot = pRoot;
				pTC->pToken = &pPhrase->aToken[i];
				pTC->iCol = pPhrase->iColumn;
				*pRc = sqlite3Fts3MsrOvfl(pCsr, pTC->pToken->pSegcsr, &pTC->nOvfl);
			}
		}
		else if (pExpr->eType != FTSQUERY_NOT) {
			assert(pExpr->eType == FTSQUERY_OR
				|| pExpr->eType == FTSQUERY_AND
				|| pExpr->eType == FTSQUERY_NEAR
			);
			assert(pExpr->pLeft && pExpr->pRight);
			if (pExpr->eType == FTSQUERY_OR) {
				pRoot = pExpr->pLeft;
				**ppOr = pRoot;
				(*ppOr)++;
			}
			fts3EvalTokenCosts(pCsr, pRoot, pExpr->pLeft, ppTC, ppOr, pRc);
			if (pExpr->eType == FTSQUERY_OR) {
				pRoot = pExpr->pRight;
				**ppOr = pRoot;
				(*ppOr)++;
			}
			fts3EvalTokenCosts(pCsr, pRoot, pExpr->pRight, ppTC, ppOr, pRc);
		}
	}
}


static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage) {
	if (pCsr->nRowAvg == 0) {
		
		int rc;
		Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
		sqlite3_stmt *pStmt;
		sqlite3_int64 nDoc = 0;
		sqlite3_int64 nByte = 0;
		const char *pEnd;
		const char *a;

		rc = sqlite3Fts3SelectDoctotal(p, &pStmt);
		if (rc != SQLITE_OK) return rc;
		a = sqlite3_column_blob(pStmt, 0);
		assert(a);

		pEnd = &a[sqlite3_column_bytes(pStmt, 0)];
		a += sqlite3Fts3GetVarint(a, &nDoc);
		while (a<pEnd) {
			a += sqlite3Fts3GetVarint(a, &nByte);
		}
		if (nDoc == 0 || nByte == 0) {
			sqlite3_reset(pStmt);
			return FTS_CORRUPT_VTAB;
		}

		pCsr->nDoc = nDoc;
		pCsr->nRowAvg = (int)(((nByte / nDoc) + p->nPgsz) / p->nPgsz);
		assert(pCsr->nRowAvg>0);
		rc = sqlite3_reset(pStmt);
		if (rc != SQLITE_OK) return rc;
	}

	*pnPage = pCsr->nRowAvg;
	return SQLITE_OK;
}


static int fts3EvalSelectDeferred(
	Fts3Cursor *pCsr,               
	Fts3Expr *pRoot,                
	Fts3TokenAndCost *aTC,          
	int nTC                         
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int nDocSize = 0;               
	int rc = SQLITE_OK;             
	int ii;                         
	int nOvfl = 0;                  
	int nToken = 0;                 

	int nMinEst = 0;                
	int nLoad4 = 1;                 

									
	if (pTab->zContentTbl) {
		return SQLITE_OK;
	}

	
	for (ii = 0; ii<nTC; ii++) {
		if (aTC[ii].pRoot == pRoot) {
			nOvfl += aTC[ii].nOvfl;
			nToken++;
		}
	}
	if (nOvfl == 0 || nToken<2) return SQLITE_OK;

	
	rc = fts3EvalAverageDocsize(pCsr, &nDocSize);
	assert(rc != SQLITE_OK || nDocSize>0);


	
	for (ii = 0; ii<nToken && rc == SQLITE_OK; ii++) {
		int iTC;                      
		Fts3TokenAndCost *pTC = 0;    

									  
		for (iTC = 0; iTC<nTC; iTC++) {
			if (aTC[iTC].pToken && aTC[iTC].pRoot == pRoot
				&& (!pTC || aTC[iTC].nOvfl<pTC->nOvfl)
				) {
				pTC = &aTC[iTC];
			}
		}
		assert(pTC);

		if (ii && pTC->nOvfl >= ((nMinEst + (nLoad4 / 4) - 1) / (nLoad4 / 4))*nDocSize) {
			
			Fts3PhraseToken *pToken = pTC->pToken;
			rc = sqlite3Fts3DeferToken(pCsr, pToken, pTC->iCol);
			fts3SegReaderCursorFree(pToken->pSegcsr);
			pToken->pSegcsr = 0;
		}
		else {
			
			if (ii<12) nLoad4 = nLoad4 * 4;

			if (ii == 0 || (pTC->pPhrase->nToken>1 && ii != nToken - 1)) {
				
				Fts3PhraseToken *pToken = pTC->pToken;
				int nList = 0;
				char *pList = 0;
				rc = fts3TermSelect(pTab, pToken, pTC->iCol, &nList, &pList);
				assert(rc == SQLITE_OK || pList == 0);
				if (rc == SQLITE_OK) {
					rc = fts3EvalPhraseMergeToken(
						pTab, pTC->pPhrase, pTC->iToken, pList, nList
					);
				}
				if (rc == SQLITE_OK) {
					int nCount;
					nCount = fts3DoclistCountDocids(
						pTC->pPhrase->doclist.aAll, pTC->pPhrase->doclist.nAll
					);
					if (ii == 0 || nCount<nMinEst) nMinEst = nCount;
				}
			}
		}
		pTC->pToken = 0;
	}

	return rc;
}


static int fts3EvalStart(Fts3Cursor *pCsr) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc = SQLITE_OK;
	int nToken = 0;
	int nOr = 0;

	
	fts3EvalAllocateReaders(pCsr, pCsr->pExpr, &nToken, &nOr, &rc);

	
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
	if (rc == SQLITE_OK && nToken>1 && pTab->bFts4) {
		Fts3TokenAndCost *aTC;
		Fts3Expr **apOr;
		aTC = (Fts3TokenAndCost *)sqlite3_malloc(
			sizeof(Fts3TokenAndCost) * nToken
			+ sizeof(Fts3Expr *) * nOr * 2
		);
		apOr = (Fts3Expr **)&aTC[nToken];

		if (!aTC) {
			rc = SQLITE_NOMEM;
		}
		else {
			int ii;
			Fts3TokenAndCost *pTC = aTC;
			Fts3Expr **ppOr = apOr;

			fts3EvalTokenCosts(pCsr, 0, pCsr->pExpr, &pTC, &ppOr, &rc);
			nToken = (int)(pTC - aTC);
			nOr = (int)(ppOr - apOr);

			if (rc == SQLITE_OK) {
				rc = fts3EvalSelectDeferred(pCsr, 0, aTC, nToken);
				for (ii = 0; rc == SQLITE_OK && ii<nOr; ii++) {
					rc = fts3EvalSelectDeferred(pCsr, apOr[ii], aTC, nToken);
				}
			}

			sqlite3_free(aTC);
		}
	}
#endif

	fts3EvalStartReaders(pCsr, pCsr->pExpr, &rc);
	return rc;
}


static void fts3EvalInvalidatePoslist(Fts3Phrase *pPhrase) {
	if (pPhrase->doclist.bFreeList) {
		sqlite3_free(pPhrase->doclist.pList);
	}
	pPhrase->doclist.pList = 0;
	pPhrase->doclist.nList = 0;
	pPhrase->doclist.bFreeList = 0;
}


static int fts3EvalNearTrim(
	int nNear,                      
	char *aTmp,                     
	char **paPoslist,               
	int *pnToken,                   
	Fts3Phrase *pPhrase             
) {
	int nParam1 = nNear + pPhrase->nToken;
	int nParam2 = nNear + *pnToken;
	int nNew;
	char *p2;
	char *pOut;
	int res;

	assert(pPhrase->doclist.pList);

	p2 = pOut = pPhrase->doclist.pList;
	res = fts3PoslistNearMerge(
		&pOut, aTmp, nParam1, nParam2, paPoslist, &p2
	);
	if (res) {
		nNew = (int)(pOut - pPhrase->doclist.pList) - 1;
		assert(pPhrase->doclist.pList[nNew] == '\0');
		assert(nNew <= pPhrase->doclist.nList && nNew>0);
		memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);
		pPhrase->doclist.nList = nNew;
		*paPoslist = pPhrase->doclist.pList;
		*pnToken = pPhrase->nToken;
	}

	return res;
}


static void fts3EvalNextRow(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	int *pRc                        
) {
	if (*pRc == SQLITE_OK) {
		int bDescDoclist = pCsr->bDesc;         
		assert(pExpr->bEof == 0);
		pExpr->bStart = 1;

		switch (pExpr->eType) {
		case FTSQUERY_NEAR:
		case FTSQUERY_AND: {
			Fts3Expr *pLeft = pExpr->pLeft;
			Fts3Expr *pRight = pExpr->pRight;
			assert(!pLeft->bDeferred || !pRight->bDeferred);

			if (pLeft->bDeferred) {
				
				fts3EvalNextRow(pCsr, pRight, pRc);
				pExpr->iDocid = pRight->iDocid;
				pExpr->bEof = pRight->bEof;
			}
			else if (pRight->bDeferred) {
				
				fts3EvalNextRow(pCsr, pLeft, pRc);
				pExpr->iDocid = pLeft->iDocid;
				pExpr->bEof = pLeft->bEof;
			}
			else {
				
				fts3EvalNextRow(pCsr, pLeft, pRc);
				fts3EvalNextRow(pCsr, pRight, pRc);
				while (!pLeft->bEof && !pRight->bEof && *pRc == SQLITE_OK) {
					sqlite3_int64 iDiff = DOCID_CMP(pLeft->iDocid, pRight->iDocid);
					if (iDiff == 0) break;
					if (iDiff<0) {
						fts3EvalNextRow(pCsr, pLeft, pRc);
					}
					else {
						fts3EvalNextRow(pCsr, pRight, pRc);
					}
				}
				pExpr->iDocid = pLeft->iDocid;
				pExpr->bEof = (pLeft->bEof || pRight->bEof);
				if (pExpr->eType == FTSQUERY_NEAR && pExpr->bEof) {
					if (pRight->pPhrase && pRight->pPhrase->doclist.aAll) {
						Fts3Doclist *pDl = &pRight->pPhrase->doclist;
						while (*pRc == SQLITE_OK && pRight->bEof == 0) {
							memset(pDl->pList, 0, pDl->nList);
							fts3EvalNextRow(pCsr, pRight, pRc);
						}
					}
					if (pLeft->pPhrase && pLeft->pPhrase->doclist.aAll) {
						Fts3Doclist *pDl = &pLeft->pPhrase->doclist;
						while (*pRc == SQLITE_OK && pLeft->bEof == 0) {
							memset(pDl->pList, 0, pDl->nList);
							fts3EvalNextRow(pCsr, pLeft, pRc);
						}
					}
				}
			}
			break;
		}

		case FTSQUERY_OR: {
			Fts3Expr *pLeft = pExpr->pLeft;
			Fts3Expr *pRight = pExpr->pRight;
			sqlite3_int64 iCmp = DOCID_CMP(pLeft->iDocid, pRight->iDocid);

			assert(pLeft->bStart || pLeft->iDocid == pRight->iDocid);
			assert(pRight->bStart || pLeft->iDocid == pRight->iDocid);

			if (pRight->bEof || (pLeft->bEof == 0 && iCmp<0)) {
				fts3EvalNextRow(pCsr, pLeft, pRc);
			}
			else if (pLeft->bEof || (pRight->bEof == 0 && iCmp>0)) {
				fts3EvalNextRow(pCsr, pRight, pRc);
			}
			else {
				fts3EvalNextRow(pCsr, pLeft, pRc);
				fts3EvalNextRow(pCsr, pRight, pRc);
			}

			pExpr->bEof = (pLeft->bEof && pRight->bEof);
			iCmp = DOCID_CMP(pLeft->iDocid, pRight->iDocid);
			if (pRight->bEof || (pLeft->bEof == 0 && iCmp<0)) {
				pExpr->iDocid = pLeft->iDocid;
			}
			else {
				pExpr->iDocid = pRight->iDocid;
			}

			break;
		}

		case FTSQUERY_NOT: {
			Fts3Expr *pLeft = pExpr->pLeft;
			Fts3Expr *pRight = pExpr->pRight;

			if (pRight->bStart == 0) {
				fts3EvalNextRow(pCsr, pRight, pRc);
				assert(*pRc != SQLITE_OK || pRight->bStart);
			}

			fts3EvalNextRow(pCsr, pLeft, pRc);
			if (pLeft->bEof == 0) {
				while (!*pRc
					&& !pRight->bEof
					&& DOCID_CMP(pLeft->iDocid, pRight->iDocid)>0
					) {
					fts3EvalNextRow(pCsr, pRight, pRc);
				}
			}
			pExpr->iDocid = pLeft->iDocid;
			pExpr->bEof = pLeft->bEof;
			break;
		}

		default: {
			Fts3Phrase *pPhrase = pExpr->pPhrase;
			fts3EvalInvalidatePoslist(pPhrase);
			*pRc = fts3EvalPhraseNext(pCsr, pPhrase, &pExpr->bEof);
			pExpr->iDocid = pPhrase->doclist.iDocid;
			break;
		}
		}
	}
}


static int fts3EvalNearTest(Fts3Expr *pExpr, int *pRc) {
	int res = 1;

	
	if (*pRc == SQLITE_OK
		&& pExpr->eType == FTSQUERY_NEAR
		&& pExpr->bEof == 0
		&& (pExpr->pParent == 0 || pExpr->pParent->eType != FTSQUERY_NEAR)
		) {
		Fts3Expr *p;
		int nTmp = 0;                 
		char *aTmp;                   

									  
		for (p = pExpr; p->pLeft; p = p->pLeft) {
			nTmp += p->pRight->pPhrase->doclist.nList;
		}
		nTmp += p->pPhrase->doclist.nList;
		if (nTmp == 0) {
			res = 0;
		}
		else {
			aTmp = sqlite3_malloc(nTmp * 2);
			if (!aTmp) {
				*pRc = SQLITE_NOMEM;
				res = 0;
			}
			else {
				char *aPoslist = p->pPhrase->doclist.pList;
				int nToken = p->pPhrase->nToken;

				for (p = p->pParent; res && p && p->eType == FTSQUERY_NEAR; p = p->pParent) {
					Fts3Phrase *pPhrase = p->pRight->pPhrase;
					int nNear = p->nNear;
					res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
				}

				aPoslist = pExpr->pRight->pPhrase->doclist.pList;
				nToken = pExpr->pRight->pPhrase->nToken;
				for (p = pExpr->pLeft; p && res; p = p->pLeft) {
					int nNear;
					Fts3Phrase *pPhrase;
					assert(p->pParent && p->pParent->pLeft == p);
					nNear = p->pParent->nNear;
					pPhrase = (
						p->eType == FTSQUERY_NEAR ? p->pRight->pPhrase : p->pPhrase
						);
					res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);
				}
			}

			sqlite3_free(aTmp);
		}
	}

	return res;
}


static int fts3EvalTestExpr(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	int *pRc                        
) {
	int bHit = 1;                   
	if (*pRc == SQLITE_OK) {
		switch (pExpr->eType) {
		case FTSQUERY_NEAR:
		case FTSQUERY_AND:
			bHit = (
				fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)
				&& fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)
				&& fts3EvalNearTest(pExpr, pRc)
				);

			
			if (bHit == 0
				&& pExpr->eType == FTSQUERY_NEAR
				&& (pExpr->pParent == 0 || pExpr->pParent->eType != FTSQUERY_NEAR)
				) {
				Fts3Expr *p;
				for (p = pExpr; p->pPhrase == 0; p = p->pLeft) {
					if (p->pRight->iDocid == pCsr->iPrevId) {
						fts3EvalInvalidatePoslist(p->pRight->pPhrase);
					}
				}
				if (p->iDocid == pCsr->iPrevId) {
					fts3EvalInvalidatePoslist(p->pPhrase);
				}
			}

			break;

		case FTSQUERY_OR: {
			int bHit1 = fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc);
			int bHit2 = fts3EvalTestExpr(pCsr, pExpr->pRight, pRc);
			bHit = bHit1 || bHit2;
			break;
		}

		case FTSQUERY_NOT:
			bHit = (
				fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)
				&& !fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)
				);
			break;

		default: {
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
			if (pCsr->pDeferred
				&& (pExpr->iDocid == pCsr->iPrevId || pExpr->bDeferred)
				) {
				Fts3Phrase *pPhrase = pExpr->pPhrase;
				assert(pExpr->bDeferred || pPhrase->doclist.bFreeList == 0);
				if (pExpr->bDeferred) {
					fts3EvalInvalidatePoslist(pPhrase);
				}
				*pRc = fts3EvalDeferredPhrase(pCsr, pPhrase);
				bHit = (pPhrase->doclist.pList != 0);
				pExpr->iDocid = pCsr->iPrevId;
			}
			else
#endif
			{
				bHit = (pExpr->bEof == 0 && pExpr->iDocid == pCsr->iPrevId);
			}
			break;
		}
		}
	}
	return bHit;
}


SQLITE_PRIVATE int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc) {
	int rc = *pRc;
	int bMiss = 0;
	if (rc == SQLITE_OK) {

		
		if (pCsr->pDeferred) {
			rc = fts3CursorSeek(0, pCsr);
			if (rc == SQLITE_OK) {
				rc = sqlite3Fts3CacheDeferredDoclists(pCsr);
			}
		}
		bMiss = (0 == fts3EvalTestExpr(pCsr, pCsr->pExpr, &rc));

		
		sqlite3Fts3FreeDeferredDoclists(pCsr);
		*pRc = rc;
	}
	return (rc == SQLITE_OK && bMiss);
}


static int fts3EvalNext(Fts3Cursor *pCsr) {
	int rc = SQLITE_OK;             
	Fts3Expr *pExpr = pCsr->pExpr;
	assert(pCsr->isEof == 0);
	if (pExpr == 0) {
		pCsr->isEof = 1;
	}
	else {
		do {
			if (pCsr->isRequireSeek == 0) {
				sqlite3_reset(pCsr->pStmt);
			}
			assert(sqlite3_data_count(pCsr->pStmt) == 0);
			fts3EvalNextRow(pCsr, pExpr, &rc);
			pCsr->isEof = pExpr->bEof;
			pCsr->isRequireSeek = 1;
			pCsr->isMatchinfoNeeded = 1;
			pCsr->iPrevId = pExpr->iDocid;
		} while (pCsr->isEof == 0 && sqlite3Fts3EvalTestDeferred(pCsr, &rc));
	}

	
	if (rc == SQLITE_OK && (
		(pCsr->bDesc == 0 && pCsr->iPrevId>pCsr->iMaxDocid)
		|| (pCsr->bDesc != 0 && pCsr->iPrevId<pCsr->iMinDocid)
		)) {
		pCsr->isEof = 1;
	}

	return rc;
}


static void fts3EvalRestart(
	Fts3Cursor *pCsr,
	Fts3Expr *pExpr,
	int *pRc
) {
	if (pExpr && *pRc == SQLITE_OK) {
		Fts3Phrase *pPhrase = pExpr->pPhrase;

		if (pPhrase) {
			fts3EvalInvalidatePoslist(pPhrase);
			if (pPhrase->bIncr) {
				int i;
				for (i = 0; i<pPhrase->nToken; i++) {
					Fts3PhraseToken *pToken = &pPhrase->aToken[i];
					assert(pToken->pDeferred == 0);
					if (pToken->pSegcsr) {
						sqlite3Fts3MsrIncrRestart(pToken->pSegcsr);
					}
				}
				*pRc = fts3EvalPhraseStart(pCsr, 0, pPhrase);
			}
			pPhrase->doclist.pNextDocid = 0;
			pPhrase->doclist.iDocid = 0;
			pPhrase->pOrPoslist = 0;
		}

		pExpr->iDocid = 0;
		pExpr->bEof = 0;
		pExpr->bStart = 0;

		fts3EvalRestart(pCsr, pExpr->pLeft, pRc);
		fts3EvalRestart(pCsr, pExpr->pRight, pRc);
	}
}


static void fts3EvalUpdateCounts(Fts3Expr *pExpr) {
	if (pExpr) {
		Fts3Phrase *pPhrase = pExpr->pPhrase;
		if (pPhrase && pPhrase->doclist.pList) {
			int iCol = 0;
			char *p = pPhrase->doclist.pList;

			assert(*p);
			while (1) {
				u8 c = 0;
				int iCnt = 0;
				while (0xFE & (*p | c)) {
					if ((c & 0x80) == 0) iCnt++;
					c = *p++ & 0x80;
				}

				
				pExpr->aMI[iCol * 3 + 1] += iCnt;
				pExpr->aMI[iCol * 3 + 2] += (iCnt>0);
				if (*p == 0x00) break;
				p++;
				p += fts3GetVarint32(p, &iCol);
			}
		}

		fts3EvalUpdateCounts(pExpr->pLeft);
		fts3EvalUpdateCounts(pExpr->pRight);
	}
}


static int fts3EvalGatherStats(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr                 
) {
	int rc = SQLITE_OK;             

	assert(pExpr->eType == FTSQUERY_PHRASE);
	if (pExpr->aMI == 0) {
		Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
		Fts3Expr *pRoot;                
		Fts3Expr *p;                    

		sqlite3_int64 iPrevId = pCsr->iPrevId;
		sqlite3_int64 iDocid;
		u8 bEof;

		
		pRoot = pExpr;
		while (pRoot->pParent && pRoot->pParent->eType == FTSQUERY_NEAR) {
			pRoot = pRoot->pParent;
		}
		iDocid = pRoot->iDocid;
		bEof = pRoot->bEof;
		assert(pRoot->bStart);

		
		for (p = pRoot; p; p = p->pLeft) {
			Fts3Expr *pE = (p->eType == FTSQUERY_PHRASE ? p : p->pRight);
			assert(pE->aMI == 0);
			pE->aMI = (u32 *)sqlite3_malloc(pTab->nColumn * 3 * sizeof(u32));
			if (!pE->aMI) return SQLITE_NOMEM;
			memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));
		}

		fts3EvalRestart(pCsr, pRoot, &rc);

		while (pCsr->isEof == 0 && rc == SQLITE_OK) {

			do {
				
				if (pCsr->isRequireSeek == 0) sqlite3_reset(pCsr->pStmt);
				assert(sqlite3_data_count(pCsr->pStmt) == 0);

				
				fts3EvalNextRow(pCsr, pRoot, &rc);
				pCsr->isEof = pRoot->bEof;
				pCsr->isRequireSeek = 1;
				pCsr->isMatchinfoNeeded = 1;
				pCsr->iPrevId = pRoot->iDocid;
			} while (pCsr->isEof == 0
				&& pRoot->eType == FTSQUERY_NEAR
				&& sqlite3Fts3EvalTestDeferred(pCsr, &rc)
				);

			if (rc == SQLITE_OK && pCsr->isEof == 0) {
				fts3EvalUpdateCounts(pRoot);
			}
		}

		pCsr->isEof = 0;
		pCsr->iPrevId = iPrevId;

		if (bEof) {
			pRoot->bEof = bEof;
		}
		else {
			
			fts3EvalRestart(pCsr, pRoot, &rc);
			do {
				fts3EvalNextRow(pCsr, pRoot, &rc);
				assert(pRoot->bEof == 0);
			} while (pRoot->iDocid != iDocid && rc == SQLITE_OK);
		}
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3EvalPhraseStats(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	u32 *aiOut                      
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc = SQLITE_OK;
	int iCol;

	if (pExpr->bDeferred && pExpr->pParent->eType != FTSQUERY_NEAR) {
		assert(pCsr->nDoc>0);
		for (iCol = 0; iCol<pTab->nColumn; iCol++) {
			aiOut[iCol * 3 + 1] = (u32)pCsr->nDoc;
			aiOut[iCol * 3 + 2] = (u32)pCsr->nDoc;
		}
	}
	else {
		rc = fts3EvalGatherStats(pCsr, pExpr);
		if (rc == SQLITE_OK) {
			assert(pExpr->aMI);
			for (iCol = 0; iCol<pTab->nColumn; iCol++) {
				aiOut[iCol * 3 + 1] = pExpr->aMI[iCol * 3 + 1];
				aiOut[iCol * 3 + 2] = pExpr->aMI[iCol * 3 + 2];
			}
		}
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(
	Fts3Cursor *pCsr,               
	Fts3Expr *pExpr,                
	int iCol,                       
	char **ppOut                    
) {
	Fts3Phrase *pPhrase = pExpr->pPhrase;
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	char *pIter;
	int iThis;
	sqlite3_int64 iDocid;

	
	*ppOut = 0;
	assert(iCol >= 0 && iCol<pTab->nColumn);
	if ((pPhrase->iColumn<pTab->nColumn && pPhrase->iColumn != iCol)) {
		return SQLITE_OK;
	}

	iDocid = pExpr->iDocid;
	pIter = pPhrase->doclist.pList;
	if (iDocid != pCsr->iPrevId || pExpr->bEof) {
		int rc = SQLITE_OK;
		int bDescDoclist = pTab->bDescIdx;      
		int bOr = 0;
		u8 bTreeEof = 0;
		Fts3Expr *p;                  
		Fts3Expr *pNear;              
		int bMatch;

		
		pNear = pExpr;
		for (p = pExpr->pParent; p; p = p->pParent) {
			if (p->eType == FTSQUERY_OR) bOr = 1;
			if (p->eType == FTSQUERY_NEAR) pNear = p;
			if (p->bEof) bTreeEof = 1;
		}
		if (bOr == 0) return SQLITE_OK;

		
		if (pPhrase->bIncr) {
			int bEofSave = pNear->bEof;
			fts3EvalRestart(pCsr, pNear, &rc);
			while (rc == SQLITE_OK && !pNear->bEof) {
				fts3EvalNextRow(pCsr, pNear, &rc);
				if (bEofSave == 0 && pNear->iDocid == iDocid) break;
			}
			assert(rc != SQLITE_OK || pPhrase->bIncr == 0);
		}
		if (bTreeEof) {
			while (rc == SQLITE_OK && !pNear->bEof) {
				fts3EvalNextRow(pCsr, pNear, &rc);
			}
		}
		if (rc != SQLITE_OK) return rc;

		bMatch = 1;
		for (p = pNear; p; p = p->pLeft) {
			u8 bEof = 0;
			Fts3Expr *pTest = p;
			Fts3Phrase *pPh;
			assert(pTest->eType == FTSQUERY_NEAR || pTest->eType == FTSQUERY_PHRASE);
			if (pTest->eType == FTSQUERY_NEAR) pTest = pTest->pRight;
			assert(pTest->eType == FTSQUERY_PHRASE);
			pPh = pTest->pPhrase;

			pIter = pPh->pOrPoslist;
			iDocid = pPh->iOrDocid;
			if (pCsr->bDesc == bDescDoclist) {
				bEof = !pPh->doclist.nAll ||
					(pIter >= (pPh->doclist.aAll + pPh->doclist.nAll));
				while ((pIter == 0 || DOCID_CMP(iDocid, pCsr->iPrevId)<0) && bEof == 0) {
					sqlite3Fts3DoclistNext(
						bDescDoclist, pPh->doclist.aAll, pPh->doclist.nAll,
						&pIter, &iDocid, &bEof
					);
				}
			}
			else {
				bEof = !pPh->doclist.nAll || (pIter && pIter <= pPh->doclist.aAll);
				while ((pIter == 0 || DOCID_CMP(iDocid, pCsr->iPrevId)>0) && bEof == 0) {
					int dummy;
					sqlite3Fts3DoclistPrev(
						bDescDoclist, pPh->doclist.aAll, pPh->doclist.nAll,
						&pIter, &iDocid, &dummy, &bEof
					);
				}
			}
			pPh->pOrPoslist = pIter;
			pPh->iOrDocid = iDocid;
			if (bEof || iDocid != pCsr->iPrevId) bMatch = 0;
		}

		if (bMatch) {
			pIter = pPhrase->pOrPoslist;
		}
		else {
			pIter = 0;
		}
	}
	if (pIter == 0) return SQLITE_OK;

	if (*pIter == 0x01) {
		pIter++;
		pIter += fts3GetVarint32(pIter, &iThis);
	}
	else {
		iThis = 0;
	}
	while (iThis<iCol) {
		fts3ColumnlistCopy(0, &pIter);
		if (*pIter == 0x00) return SQLITE_OK;
		pIter++;
		pIter += fts3GetVarint32(pIter, &iThis);
	}
	if (*pIter == 0x00) {
		pIter = 0;
	}

	*ppOut = ((iCol == iThis) ? pIter : 0);
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *pPhrase) {
	if (pPhrase) {
		int i;
		sqlite3_free(pPhrase->doclist.aAll);
		fts3EvalInvalidatePoslist(pPhrase);
		memset(&pPhrase->doclist, 0, sizeof(Fts3Doclist));
		for (i = 0; i<pPhrase->nToken; i++) {
			fts3SegReaderCursorFree(pPhrase->aToken[i].pSegcsr);
			pPhrase->aToken[i].pSegcsr = 0;
		}
	}
}



#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3Fts3Corrupt() {
	return SQLITE_CORRUPT_VTAB;
}
#endif

#if !SQLITE_CORE

#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts3_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi)
		return sqlite3Fts3Init(db);
}
#endif

#endif





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)




typedef struct Fts3auxTable Fts3auxTable;
typedef struct Fts3auxCursor Fts3auxCursor;

struct Fts3auxTable {
	sqlite3_vtab base;              
	Fts3Table *pFts3Tab;
};

struct Fts3auxCursor {
	sqlite3_vtab_cursor base;       
	Fts3MultiSegReader csr;        
	Fts3SegFilter filter;
	char *zStop;
	int nStop;                      
	int iLangid;                    
	int isEof;                      
	sqlite3_int64 iRowid;           

	int iCol;                       
	int nStat;                      
	struct Fts3auxColstats {
		sqlite3_int64 nDoc;           
		sqlite3_int64 nOcc;           
	} *aStat;
};


#define FTS3_AUX_SCHEMA \
  "CREATE TABLE x(term, col, documents, occurrences, languageid HIDDEN)"


static int fts3auxConnectMethod(
	sqlite3 *db,                    
	void *pUnused,                  
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	char const *zDb;                
	char const *zFts3;              
	int nDb;                        
	int nFts3;                      
	int nByte;                      
	int rc;                         
	Fts3auxTable *p;                

	UNUSED_PARAMETER(pUnused);

	
	if (argc != 4 && argc != 5) goto bad_args;

	zDb = argv[1];
	nDb = (int)strlen(zDb);
	if (argc == 5) {
		if (nDb == 4 && 0 == sqlite3_strnicmp("temp", zDb, 4)) {
			zDb = argv[3];
			nDb = (int)strlen(zDb);
			zFts3 = argv[4];
		}
		else {
			goto bad_args;
		}
	}
	else {
		zFts3 = argv[3];
	}
	nFts3 = (int)strlen(zFts3);

	rc = sqlite3_declare_vtab(db, FTS3_AUX_SCHEMA);
	if (rc != SQLITE_OK) return rc;

	nByte = sizeof(Fts3auxTable) + sizeof(Fts3Table) + nDb + nFts3 + 2;
	p = (Fts3auxTable *)sqlite3_malloc(nByte);
	if (!p) return SQLITE_NOMEM;
	memset(p, 0, nByte);

	p->pFts3Tab = (Fts3Table *)&p[1];
	p->pFts3Tab->zDb = (char *)&p->pFts3Tab[1];
	p->pFts3Tab->zName = &p->pFts3Tab->zDb[nDb + 1];
	p->pFts3Tab->db = db;
	p->pFts3Tab->nIndex = 1;

	memcpy((char *)p->pFts3Tab->zDb, zDb, nDb);
	memcpy((char *)p->pFts3Tab->zName, zFts3, nFts3);
	sqlite3Fts3Dequote((char *)p->pFts3Tab->zName);

	*ppVtab = (sqlite3_vtab *)p;
	return SQLITE_OK;

bad_args:
	sqlite3Fts3ErrMsg(pzErr, "invalid arguments to fts4aux constructor");
	return SQLITE_ERROR;
}


static int fts3auxDisconnectMethod(sqlite3_vtab *pVtab) {
	Fts3auxTable *p = (Fts3auxTable *)pVtab;
	Fts3Table *pFts3 = p->pFts3Tab;
	int i;

	
	for (i = 0; i<SizeofArray(pFts3->aStmt); i++) {
		sqlite3_finalize(pFts3->aStmt[i]);
	}
	sqlite3_free(pFts3->zSegmentsTbl);
	sqlite3_free(p);
	return SQLITE_OK;
}

#define FTS4AUX_EQ_CONSTRAINT 1
#define FTS4AUX_GE_CONSTRAINT 2
#define FTS4AUX_LE_CONSTRAINT 4


static int fts3auxBestIndexMethod(
	sqlite3_vtab *pVTab,
	sqlite3_index_info *pInfo
) {
	int i;
	int iEq = -1;
	int iGe = -1;
	int iLe = -1;
	int iLangid = -1;
	int iNext = 1;                  

	UNUSED_PARAMETER(pVTab);

	
	if (pInfo->nOrderBy == 1
		&& pInfo->aOrderBy[0].iColumn == 0
		&& pInfo->aOrderBy[0].desc == 0
		) {
		pInfo->orderByConsumed = 1;
	}

	
	for (i = 0; i<pInfo->nConstraint; i++) {
		if (pInfo->aConstraint[i].usable) {
			int op = pInfo->aConstraint[i].op;
			int iCol = pInfo->aConstraint[i].iColumn;

			if (iCol == 0) {
				if (op == SQLITE_INDEX_CONSTRAINT_EQ) iEq = i;
				if (op == SQLITE_INDEX_CONSTRAINT_LT) iLe = i;
				if (op == SQLITE_INDEX_CONSTRAINT_LE) iLe = i;
				if (op == SQLITE_INDEX_CONSTRAINT_GT) iGe = i;
				if (op == SQLITE_INDEX_CONSTRAINT_GE) iGe = i;
			}
			if (iCol == 4) {
				if (op == SQLITE_INDEX_CONSTRAINT_EQ) iLangid = i;
			}
		}
	}

	if (iEq >= 0) {
		pInfo->idxNum = FTS4AUX_EQ_CONSTRAINT;
		pInfo->aConstraintUsage[iEq].argvIndex = iNext++;
		pInfo->estimatedCost = 5;
	}
	else {
		pInfo->idxNum = 0;
		pInfo->estimatedCost = 20000;
		if (iGe >= 0) {
			pInfo->idxNum += FTS4AUX_GE_CONSTRAINT;
			pInfo->aConstraintUsage[iGe].argvIndex = iNext++;
			pInfo->estimatedCost /= 2;
		}
		if (iLe >= 0) {
			pInfo->idxNum += FTS4AUX_LE_CONSTRAINT;
			pInfo->aConstraintUsage[iLe].argvIndex = iNext++;
			pInfo->estimatedCost /= 2;
		}
	}
	if (iLangid >= 0) {
		pInfo->aConstraintUsage[iLangid].argvIndex = iNext++;
		pInfo->estimatedCost--;
	}

	return SQLITE_OK;
}


static int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr) {
	Fts3auxCursor *pCsr;            

	UNUSED_PARAMETER(pVTab);

	pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));
	if (!pCsr) return SQLITE_NOMEM;
	memset(pCsr, 0, sizeof(Fts3auxCursor));

	*ppCsr = (sqlite3_vtab_cursor *)pCsr;
	return SQLITE_OK;
}


static int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
	Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;

	sqlite3Fts3SegmentsClose(pFts3);
	sqlite3Fts3SegReaderFinish(&pCsr->csr);
	sqlite3_free((void *)pCsr->filter.zTerm);
	sqlite3_free(pCsr->zStop);
	sqlite3_free(pCsr->aStat);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}

static int fts3auxGrowStatArray(Fts3auxCursor *pCsr, int nSize) {
	if (nSize>pCsr->nStat) {
		struct Fts3auxColstats *aNew;
		aNew = (struct Fts3auxColstats *)sqlite3_realloc(pCsr->aStat,
			sizeof(struct Fts3auxColstats) * nSize
		);
		if (aNew == 0) return SQLITE_NOMEM;
		memset(&aNew[pCsr->nStat], 0,
			sizeof(struct Fts3auxColstats) * (nSize - pCsr->nStat)
		);
		pCsr->aStat = aNew;
		pCsr->nStat = nSize;
	}
	return SQLITE_OK;
}


static int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
	Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
	int rc;

	
	pCsr->iRowid++;

	for (pCsr->iCol++; pCsr->iCol<pCsr->nStat; pCsr->iCol++) {
		if (pCsr->aStat[pCsr->iCol].nDoc>0) return SQLITE_OK;
	}

	rc = sqlite3Fts3SegReaderStep(pFts3, &pCsr->csr);
	if (rc == SQLITE_ROW) {
		int i = 0;
		int nDoclist = pCsr->csr.nDoclist;
		char *aDoclist = pCsr->csr.aDoclist;
		int iCol;

		int eState = 0;

		if (pCsr->zStop) {
			int n = (pCsr->nStop<pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm;
			int mc = memcmp(pCsr->zStop, pCsr->csr.zTerm, n);
			if (mc<0 || (mc == 0 && pCsr->csr.nTerm>pCsr->nStop)) {
				pCsr->isEof = 1;
				return SQLITE_OK;
			}
		}

		if (fts3auxGrowStatArray(pCsr, 2)) return SQLITE_NOMEM;
		memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);
		iCol = 0;

		while (i<nDoclist) {
			sqlite3_int64 v = 0;

			i += sqlite3Fts3GetVarint(&aDoclist[i], &v);
			switch (eState) {
				
			case 0:
				pCsr->aStat[0].nDoc++;
				eState = 1;
				iCol = 0;
				break;

				
			case 1:
				assert(iCol == 0);
				if (v>1) {
					pCsr->aStat[1].nDoc++;
				}
				eState = 2;
				

			case 2:
				if (v == 0) {       
					eState = 0;
				}
				else if (v == 1) { 
					eState = 3;
				}
				else {            
					pCsr->aStat[iCol + 1].nOcc++;
					pCsr->aStat[0].nOcc++;
				}
				break;

				
			default: assert(eState == 3);
				iCol = (int)v;
				if (fts3auxGrowStatArray(pCsr, iCol + 2)) return SQLITE_NOMEM;
				pCsr->aStat[iCol + 1].nDoc++;
				eState = 2;
				break;
			}
		}

		pCsr->iCol = 0;
		rc = SQLITE_OK;
	}
	else {
		pCsr->isEof = 1;
	}
	return rc;
}


static int fts3auxFilterMethod(
	sqlite3_vtab_cursor *pCursor,   
	int idxNum,                     
	const char *idxStr,             
	int nVal,                       
	sqlite3_value **apVal           
) {
	Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
	Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
	int rc;
	int isScan = 0;
	int iLangVal = 0;               

	int iEq = -1;                   
	int iGe = -1;                   
	int iLe = -1;                   
	int iLangid = -1;               
	int iNext = 0;

	UNUSED_PARAMETER(nVal);
	UNUSED_PARAMETER(idxStr);

	assert(idxStr == 0);
	assert(idxNum == FTS4AUX_EQ_CONSTRAINT || idxNum == 0
		|| idxNum == FTS4AUX_LE_CONSTRAINT || idxNum == FTS4AUX_GE_CONSTRAINT
		|| idxNum == (FTS4AUX_LE_CONSTRAINT | FTS4AUX_GE_CONSTRAINT)
	);

	if (idxNum == FTS4AUX_EQ_CONSTRAINT) {
		iEq = iNext++;
	}
	else {
		isScan = 1;
		if (idxNum & FTS4AUX_GE_CONSTRAINT) {
			iGe = iNext++;
		}
		if (idxNum & FTS4AUX_LE_CONSTRAINT) {
			iLe = iNext++;
		}
	}
	if (iNext<nVal) {
		iLangid = iNext++;
	}

	
	testcase(pCsr->filter.zTerm);
	sqlite3Fts3SegReaderFinish(&pCsr->csr);
	sqlite3_free((void *)pCsr->filter.zTerm);
	sqlite3_free(pCsr->aStat);
	memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);

	pCsr->filter.flags = FTS3_SEGMENT_REQUIRE_POS | FTS3_SEGMENT_IGNORE_EMPTY;
	if (isScan) pCsr->filter.flags |= FTS3_SEGMENT_SCAN;

	if (iEq >= 0 || iGe >= 0) {
		const unsigned char *zStr = sqlite3_value_text(apVal[0]);
		assert((iEq == 0 && iGe == -1) || (iEq == -1 && iGe == 0));
		if (zStr) {
			pCsr->filter.zTerm = sqlite3_mprintf("%s", zStr);
			pCsr->filter.nTerm = sqlite3_value_bytes(apVal[0]);
			if (pCsr->filter.zTerm == 0) return SQLITE_NOMEM;
		}
	}

	if (iLe >= 0) {
		pCsr->zStop = sqlite3_mprintf("%s", sqlite3_value_text(apVal[iLe]));
		pCsr->nStop = sqlite3_value_bytes(apVal[iLe]);
		if (pCsr->zStop == 0) return SQLITE_NOMEM;
	}

	if (iLangid >= 0) {
		iLangVal = sqlite3_value_int(apVal[iLangid]);

		
		if (iLangVal<0) iLangVal = 0;
	}
	pCsr->iLangid = iLangVal;

	rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
		pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
	);
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts3SegReaderStart(pFts3, &pCsr->csr, &pCsr->filter);
	}

	if (rc == SQLITE_OK) rc = fts3auxNextMethod(pCursor);
	return rc;
}


static int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
	return pCsr->isEof;
}


static int fts3auxColumnMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite3_context *pCtx,          
	int iCol                        
) {
	Fts3auxCursor *p = (Fts3auxCursor *)pCursor;

	assert(p->isEof == 0);
	switch (iCol) {
	case 0: 
		sqlite3_result_text(pCtx, p->csr.zTerm, p->csr.nTerm, SQLITE_TRANSIENT);
		break;

	case 1: 
		if (p->iCol) {
			sqlite3_result_int(pCtx, p->iCol - 1);
		}
		else {
			sqlite3_result_text(pCtx, "*", -1, SQLITE_STATIC);
		}
		break;

	case 2: 
		sqlite3_result_int64(pCtx, p->aStat[p->iCol].nDoc);
		break;

	case 3: 
		sqlite3_result_int64(pCtx, p->aStat[p->iCol].nOcc);
		break;

	default: 
		assert(iCol == 4);
		sqlite3_result_int(pCtx, p->iLangid);
		break;
	}

	return SQLITE_OK;
}


static int fts3auxRowidMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite_int64 *pRowid            
) {
	Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
	*pRowid = pCsr->iRowid;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db) {
	static const sqlite3_module fts3aux_module = {
		0,                           
		fts3auxConnectMethod,        
		fts3auxConnectMethod,        
		fts3auxBestIndexMethod,      
		fts3auxDisconnectMethod,     
		fts3auxDisconnectMethod,     
		fts3auxOpenMethod,           
		fts3auxCloseMethod,          
		fts3auxFilterMethod,         
		fts3auxNextMethod,           
		fts3auxEofMethod,            
		fts3auxColumnMethod,         
		fts3auxRowidMethod,          
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0                            
	};
	int rc;                         

	rc = sqlite3_create_module(db, "fts4aux", &fts3aux_module, 0);
	return rc;
}

#endif 





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)



#ifdef SQLITE_TEST
SQLITE_API int sqlite3_fts3_enable_parentheses = 0;
#else
# ifdef SQLITE_ENABLE_FTS3_PARENTHESIS 
#  define sqlite3_fts3_enable_parentheses 1
# else
#  define sqlite3_fts3_enable_parentheses 0
# endif
#endif


#define SQLITE_FTS3_DEFAULT_NEAR_PARAM 10





typedef struct ParseContext ParseContext;
struct ParseContext {
	sqlite3_tokenizer *pTokenizer;      
	int iLangid;                        
	const char **azCol;                 
	int bFts4;                          
	int nCol;                           
	int iDefaultCol;                    
	int isNot;                          
	sqlite3_context *pCtx;              
	int nNest;                          
};


static int fts3isspace(char c) {
	return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v' || c == '\f';
}


static void *fts3MallocZero(int nByte) {
	void *pRet = sqlite3_malloc(nByte);
	if (pRet) memset(pRet, 0, nByte);
	return pRet;
}

SQLITE_PRIVATE int sqlite3Fts3OpenTokenizer(
	sqlite3_tokenizer *pTokenizer,
	int iLangid,
	const char *z,
	int n,
	sqlite3_tokenizer_cursor **ppCsr
) {
	sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
	sqlite3_tokenizer_cursor *pCsr = 0;
	int rc;

	rc = pModule->xOpen(pTokenizer, z, n, &pCsr);
	assert(rc == SQLITE_OK || pCsr == 0);
	if (rc == SQLITE_OK) {
		pCsr->pTokenizer = pTokenizer;
		if (pModule->iVersion >= 1) {
			rc = pModule->xLanguageid(pCsr, iLangid);
			if (rc != SQLITE_OK) {
				pModule->xClose(pCsr);
				pCsr = 0;
			}
		}
	}
	*ppCsr = pCsr;
	return rc;
}


static int fts3ExprParse(ParseContext *, const char *, int, Fts3Expr **, int *);


static int getNextToken(
	ParseContext *pParse,                   
	int iCol,                               
	const char *z, int n,                   
	Fts3Expr **ppExpr,                      
	int *pnConsumed                         
) {
	sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;
	sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
	int rc;
	sqlite3_tokenizer_cursor *pCursor;
	Fts3Expr *pRet = 0;
	int i = 0;

	
	for (i = 0; i<n; i++) {
		if (sqlite3_fts3_enable_parentheses && (z[i] == '(' || z[i] == ')')) break;
		if (z[i] == '"') break;
	}

	*pnConsumed = i;
	rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, z, i, &pCursor);
	if (rc == SQLITE_OK) {
		const char *zToken;
		int nToken = 0, iStart = 0, iEnd = 0, iPosition = 0;
		int nByte;                               

		rc = pModule->xNext(pCursor, &zToken, &nToken, &iStart, &iEnd, &iPosition);
		if (rc == SQLITE_OK) {
			nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase) + nToken;
			pRet = (Fts3Expr *)fts3MallocZero(nByte);
			if (!pRet) {
				rc = SQLITE_NOMEM;
			}
			else {
				pRet->eType = FTSQUERY_PHRASE;
				pRet->pPhrase = (Fts3Phrase *)&pRet[1];
				pRet->pPhrase->nToken = 1;
				pRet->pPhrase->iColumn = iCol;
				pRet->pPhrase->aToken[0].n = nToken;
				pRet->pPhrase->aToken[0].z = (char *)&pRet->pPhrase[1];
				memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);

				if (iEnd<n && z[iEnd] == '*') {
					pRet->pPhrase->aToken[0].isPrefix = 1;
					iEnd++;
				}

				while (1) {
					if (!sqlite3_fts3_enable_parentheses
						&& iStart>0 && z[iStart - 1] == '-'
						) {
						pParse->isNot = 1;
						iStart--;
					}
					else if (pParse->bFts4 && iStart>0 && z[iStart - 1] == '^') {
						pRet->pPhrase->aToken[0].bFirst = 1;
						iStart--;
					}
					else {
						break;
					}
				}

			}
			*pnConsumed = iEnd;
		}
		else if (i && rc == SQLITE_DONE) {
			rc = SQLITE_OK;
		}

		pModule->xClose(pCursor);
	}

	*ppExpr = pRet;
	return rc;
}



static void *fts3ReallocOrFree(void *pOrig, int nNew) {
	void *pRet = sqlite3_realloc(pOrig, nNew);
	if (!pRet) {
		sqlite3_free(pOrig);
	}
	return pRet;
}


static int getNextString(
	ParseContext *pParse,                   
	const char *zInput, int nInput,         
	Fts3Expr **ppExpr                       
) {
	sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;
	sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
	int rc;
	Fts3Expr *p = 0;
	sqlite3_tokenizer_cursor *pCursor = 0;
	char *zTemp = 0;
	int nTemp = 0;

	const int nSpace = sizeof(Fts3Expr) + sizeof(Fts3Phrase);
	int nToken = 0;

	
	rc = sqlite3Fts3OpenTokenizer(
		pTokenizer, pParse->iLangid, zInput, nInput, &pCursor);
	if (rc == SQLITE_OK) {
		int ii;
		for (ii = 0; rc == SQLITE_OK; ii++) {
			const char *zByte;
			int nByte = 0, iBegin = 0, iEnd = 0, iPos = 0;
			rc = pModule->xNext(pCursor, &zByte, &nByte, &iBegin, &iEnd, &iPos);
			if (rc == SQLITE_OK) {
				Fts3PhraseToken *pToken;

				p = fts3ReallocOrFree(p, nSpace + ii * sizeof(Fts3PhraseToken));
				if (!p) goto no_mem;

				zTemp = fts3ReallocOrFree(zTemp, nTemp + nByte);
				if (!zTemp) goto no_mem;

				assert(nToken == ii);
				pToken = &((Fts3Phrase *)(&p[1]))->aToken[ii];
				memset(pToken, 0, sizeof(Fts3PhraseToken));

				memcpy(&zTemp[nTemp], zByte, nByte);
				nTemp += nByte;

				pToken->n = nByte;
				pToken->isPrefix = (iEnd<nInput && zInput[iEnd] == '*');
				pToken->bFirst = (iBegin>0 && zInput[iBegin - 1] == '^');
				nToken = ii + 1;
			}
		}

		pModule->xClose(pCursor);
		pCursor = 0;
	}

	if (rc == SQLITE_DONE) {
		int jj;
		char *zBuf = 0;

		p = fts3ReallocOrFree(p, nSpace + nToken * sizeof(Fts3PhraseToken) + nTemp);
		if (!p) goto no_mem;
		memset(p, 0, (char *)&(((Fts3Phrase *)&p[1])->aToken[0]) - (char *)p);
		p->eType = FTSQUERY_PHRASE;
		p->pPhrase = (Fts3Phrase *)&p[1];
		p->pPhrase->iColumn = pParse->iDefaultCol;
		p->pPhrase->nToken = nToken;

		zBuf = (char *)&p->pPhrase->aToken[nToken];
		if (zTemp) {
			memcpy(zBuf, zTemp, nTemp);
			sqlite3_free(zTemp);
		}
		else {
			assert(nTemp == 0);
		}

		for (jj = 0; jj<p->pPhrase->nToken; jj++) {
			p->pPhrase->aToken[jj].z = zBuf;
			zBuf += p->pPhrase->aToken[jj].n;
		}
		rc = SQLITE_OK;
	}

	*ppExpr = p;
	return rc;
no_mem:

	if (pCursor) {
		pModule->xClose(pCursor);
	}
	sqlite3_free(zTemp);
	sqlite3_free(p);
	*ppExpr = 0;
	return SQLITE_NOMEM;
}


static int getNextNode(
	ParseContext *pParse,                   
	const char *z, int n,                   
	Fts3Expr **ppExpr,                      
	int *pnConsumed                         
) {
	static const struct Fts3Keyword {
		char *z;                              
		unsigned char n;                      
		unsigned char parenOnly;              
		unsigned char eType;                  
	} aKeyword[] = {
		{ "OR" ,  2, 0, FTSQUERY_OR },
		{ "AND",  3, 1, FTSQUERY_AND },
		{ "NOT",  3, 1, FTSQUERY_NOT },
		{ "NEAR", 4, 0, FTSQUERY_NEAR }
	};
	int ii;
	int iCol;
	int iColLen;
	int rc;
	Fts3Expr *pRet = 0;

	const char *zInput = z;
	int nInput = n;

	pParse->isNot = 0;

	
	while (nInput>0 && fts3isspace(*zInput)) {
		nInput--;
		zInput++;
	}
	if (nInput == 0) {
		return SQLITE_DONE;
	}

	
	for (ii = 0; ii<(int)(sizeof(aKeyword) / sizeof(struct Fts3Keyword)); ii++) {
		const struct Fts3Keyword *pKey = &aKeyword[ii];

		if ((pKey->parenOnly & ~sqlite3_fts3_enable_parentheses) != 0) {
			continue;
		}

		if (nInput >= pKey->n && 0 == memcmp(zInput, pKey->z, pKey->n)) {
			int nNear = SQLITE_FTS3_DEFAULT_NEAR_PARAM;
			int nKey = pKey->n;
			char cNext;

			
			if (pKey->eType == FTSQUERY_NEAR) {
				assert(nKey == 4);
				if (zInput[4] == '/' && zInput[5] >= '0' && zInput[5] <= '9') {
					nNear = 0;
					for (nKey = 5; zInput[nKey] >= '0' && zInput[nKey] <= '9'; nKey++) {
						nNear = nNear * 10 + (zInput[nKey] - '0');
					}
				}
			}

			
			cNext = zInput[nKey];
			if (fts3isspace(cNext)
				|| cNext == '"' || cNext == '(' || cNext == ')' || cNext == 0
				) {
				pRet = (Fts3Expr *)fts3MallocZero(sizeof(Fts3Expr));
				if (!pRet) {
					return SQLITE_NOMEM;
				}
				pRet->eType = pKey->eType;
				pRet->nNear = nNear;
				*ppExpr = pRet;
				*pnConsumed = (int)((zInput - z) + nKey);
				return SQLITE_OK;
			}

			
		}
	}

	
	if (*zInput == '"') {
		for (ii = 1; ii<nInput && zInput[ii] != '"'; ii++);
		*pnConsumed = (int)((zInput - z) + ii + 1);
		if (ii == nInput) {
			return SQLITE_ERROR;
		}
		return getNextString(pParse, &zInput[1], ii - 1, ppExpr);
	}

	if (sqlite3_fts3_enable_parentheses) {
		if (*zInput == '(') {
			int nConsumed = 0;
			pParse->nNest++;
			rc = fts3ExprParse(pParse, zInput + 1, nInput - 1, ppExpr, &nConsumed);
			if (rc == SQLITE_OK && !*ppExpr) { rc = SQLITE_DONE; }
			*pnConsumed = (int)(zInput - z) + 1 + nConsumed;
			return rc;
		}
		else if (*zInput == ')') {
			pParse->nNest--;
			*pnConsumed = (int)((zInput - z) + 1);
			*ppExpr = 0;
			return SQLITE_DONE;
		}
	}

	
	iCol = pParse->iDefaultCol;
	iColLen = 0;
	for (ii = 0; ii<pParse->nCol; ii++) {
		const char *zStr = pParse->azCol[ii];
		int nStr = (int)strlen(zStr);
		if (nInput>nStr && zInput[nStr] == ':'
			&& sqlite3_strnicmp(zStr, zInput, nStr) == 0
			) {
			iCol = ii;
			iColLen = (int)((zInput - z) + nStr + 1);
			break;
		}
	}
	rc = getNextToken(pParse, iCol, &z[iColLen], n - iColLen, ppExpr, pnConsumed);
	*pnConsumed += iColLen;
	return rc;
}


static int opPrecedence(Fts3Expr *p) {
	assert(p->eType != FTSQUERY_PHRASE);
	if (sqlite3_fts3_enable_parentheses) {
		return p->eType;
	}
	else if (p->eType == FTSQUERY_NEAR) {
		return 1;
	}
	else if (p->eType == FTSQUERY_OR) {
		return 2;
	}
	assert(p->eType == FTSQUERY_AND);
	return 3;
}


static void insertBinaryOperator(
	Fts3Expr **ppHead,       
	Fts3Expr *pPrev,         
	Fts3Expr *pNew           
) {
	Fts3Expr *pSplit = pPrev;
	while (pSplit->pParent && opPrecedence(pSplit->pParent) <= opPrecedence(pNew)) {
		pSplit = pSplit->pParent;
	}

	if (pSplit->pParent) {
		assert(pSplit->pParent->pRight == pSplit);
		pSplit->pParent->pRight = pNew;
		pNew->pParent = pSplit->pParent;
	}
	else {
		*ppHead = pNew;
	}
	pNew->pLeft = pSplit;
	pSplit->pParent = pNew;
}


static int fts3ExprParse(
	ParseContext *pParse,                   
	const char *z, int n,                   
	Fts3Expr **ppExpr,                      
	int *pnConsumed                         
) {
	Fts3Expr *pRet = 0;
	Fts3Expr *pPrev = 0;
	Fts3Expr *pNotBranch = 0;               
	int nIn = n;
	const char *zIn = z;
	int rc = SQLITE_OK;
	int isRequirePhrase = 1;

	while (rc == SQLITE_OK) {
		Fts3Expr *p = 0;
		int nByte = 0;

		rc = getNextNode(pParse, zIn, nIn, &p, &nByte);
		assert(nByte>0 || (rc != SQLITE_OK && p == 0));
		if (rc == SQLITE_OK) {
			if (p) {
				int isPhrase;

				if (!sqlite3_fts3_enable_parentheses
					&& p->eType == FTSQUERY_PHRASE && pParse->isNot
					) {
					
					Fts3Expr *pNot = fts3MallocZero(sizeof(Fts3Expr));
					if (!pNot) {
						sqlite3Fts3ExprFree(p);
						rc = SQLITE_NOMEM;
						goto exprparse_out;
					}
					pNot->eType = FTSQUERY_NOT;
					pNot->pRight = p;
					p->pParent = pNot;
					if (pNotBranch) {
						pNot->pLeft = pNotBranch;
						pNotBranch->pParent = pNot;
					}
					pNotBranch = pNot;
					p = pPrev;
				}
				else {
					int eType = p->eType;
					isPhrase = (eType == FTSQUERY_PHRASE || p->pLeft);

					
					if (!isPhrase && isRequirePhrase) {
						sqlite3Fts3ExprFree(p);
						rc = SQLITE_ERROR;
						goto exprparse_out;
					}

					if (isPhrase && !isRequirePhrase) {
						
						Fts3Expr *pAnd;
						assert(pRet && pPrev);
						pAnd = fts3MallocZero(sizeof(Fts3Expr));
						if (!pAnd) {
							sqlite3Fts3ExprFree(p);
							rc = SQLITE_NOMEM;
							goto exprparse_out;
						}
						pAnd->eType = FTSQUERY_AND;
						insertBinaryOperator(&pRet, pPrev, pAnd);
						pPrev = pAnd;
					}

					
					if (pPrev && (
						(eType == FTSQUERY_NEAR && !isPhrase && pPrev->eType != FTSQUERY_PHRASE)
						|| (eType != FTSQUERY_PHRASE && isPhrase && pPrev->eType == FTSQUERY_NEAR)
						)) {
						sqlite3Fts3ExprFree(p);
						rc = SQLITE_ERROR;
						goto exprparse_out;
					}

					if (isPhrase) {
						if (pRet) {
							assert(pPrev && pPrev->pLeft && pPrev->pRight == 0);
							pPrev->pRight = p;
							p->pParent = pPrev;
						}
						else {
							pRet = p;
						}
					}
					else {
						insertBinaryOperator(&pRet, pPrev, p);
					}
					isRequirePhrase = !isPhrase;
				}
				pPrev = p;
			}
			assert(nByte>0);
		}
		assert(rc != SQLITE_OK || (nByte>0 && nByte <= nIn));
		nIn -= nByte;
		zIn += nByte;
	}

	if (rc == SQLITE_DONE && pRet && isRequirePhrase) {
		rc = SQLITE_ERROR;
	}

	if (rc == SQLITE_DONE) {
		rc = SQLITE_OK;
		if (!sqlite3_fts3_enable_parentheses && pNotBranch) {
			if (!pRet) {
				rc = SQLITE_ERROR;
			}
			else {
				Fts3Expr *pIter = pNotBranch;
				while (pIter->pLeft) {
					pIter = pIter->pLeft;
				}
				pIter->pLeft = pRet;
				pRet->pParent = pIter;
				pRet = pNotBranch;
			}
		}
	}
	*pnConsumed = n - nIn;

exprparse_out:
	if (rc != SQLITE_OK) {
		sqlite3Fts3ExprFree(pRet);
		sqlite3Fts3ExprFree(pNotBranch);
		pRet = 0;
	}
	*ppExpr = pRet;
	return rc;
}


static int fts3ExprCheckDepth(Fts3Expr *p, int nMaxDepth) {
	int rc = SQLITE_OK;
	if (p) {
		if (nMaxDepth<0) {
			rc = SQLITE_TOOBIG;
		}
		else {
			rc = fts3ExprCheckDepth(p->pLeft, nMaxDepth - 1);
			if (rc == SQLITE_OK) {
				rc = fts3ExprCheckDepth(p->pRight, nMaxDepth - 1);
			}
		}
	}
	return rc;
}


static int fts3ExprBalance(Fts3Expr **pp, int nMaxDepth) {
	int rc = SQLITE_OK;             
	Fts3Expr *pRoot = *pp;          
	Fts3Expr *pFree = 0;            
	int eType = pRoot->eType;       

	if (nMaxDepth == 0) {
		rc = SQLITE_ERROR;
	}

	if (rc == SQLITE_OK) {
		if ((eType == FTSQUERY_AND || eType == FTSQUERY_OR)) {
			Fts3Expr **apLeaf;
			apLeaf = (Fts3Expr **)sqlite3_malloc(sizeof(Fts3Expr *) * nMaxDepth);
			if (0 == apLeaf) {
				rc = SQLITE_NOMEM;
			}
			else {
				memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);
			}

			if (rc == SQLITE_OK) {
				int i;
				Fts3Expr *p;

				
				for (p = pRoot; p->eType == eType; p = p->pLeft) {
					assert(p->pParent == 0 || p->pParent->pLeft == p);
					assert(p->pLeft && p->pRight);
				}

				
				while (1) {
					int iLvl;
					Fts3Expr *pParent = p->pParent;     

					assert(pParent == 0 || pParent->pLeft == p);
					p->pParent = 0;
					if (pParent) {
						pParent->pLeft = 0;
					}
					else {
						pRoot = 0;
					}
					rc = fts3ExprBalance(&p, nMaxDepth - 1);
					if (rc != SQLITE_OK) break;

					for (iLvl = 0; p && iLvl<nMaxDepth; iLvl++) {
						if (apLeaf[iLvl] == 0) {
							apLeaf[iLvl] = p;
							p = 0;
						}
						else {
							assert(pFree);
							pFree->pLeft = apLeaf[iLvl];
							pFree->pRight = p;
							pFree->pLeft->pParent = pFree;
							pFree->pRight->pParent = pFree;

							p = pFree;
							pFree = pFree->pParent;
							p->pParent = 0;
							apLeaf[iLvl] = 0;
						}
					}
					if (p) {
						sqlite3Fts3ExprFree(p);
						rc = SQLITE_TOOBIG;
						break;
					}

					
					if (pParent == 0) break;

					
					for (p = pParent->pRight; p->eType == eType; p = p->pLeft);

					
					assert(pParent->pParent == 0 || pParent->pParent->pLeft == pParent);
					pParent->pRight->pParent = pParent->pParent;
					if (pParent->pParent) {
						pParent->pParent->pLeft = pParent->pRight;
					}
					else {
						assert(pParent == pRoot);
						pRoot = pParent->pRight;
					}

					
					pParent->pParent = pFree;
					pFree = pParent;
				}

				if (rc == SQLITE_OK) {
					p = 0;
					for (i = 0; i<nMaxDepth; i++) {
						if (apLeaf[i]) {
							if (p == 0) {
								p = apLeaf[i];
								p->pParent = 0;
							}
							else {
								assert(pFree != 0);
								pFree->pRight = p;
								pFree->pLeft = apLeaf[i];
								pFree->pLeft->pParent = pFree;
								pFree->pRight->pParent = pFree;

								p = pFree;
								pFree = pFree->pParent;
								p->pParent = 0;
							}
						}
					}
					pRoot = p;
				}
				else {
					
					Fts3Expr *pDel;
					for (i = 0; i<nMaxDepth; i++) {
						sqlite3Fts3ExprFree(apLeaf[i]);
					}
					while ((pDel = pFree) != 0) {
						pFree = pDel->pParent;
						sqlite3_free(pDel);
					}
				}

				assert(pFree == 0);
				sqlite3_free(apLeaf);
			}
		}
		else if (eType == FTSQUERY_NOT) {
			Fts3Expr *pLeft = pRoot->pLeft;
			Fts3Expr *pRight = pRoot->pRight;

			pRoot->pLeft = 0;
			pRoot->pRight = 0;
			pLeft->pParent = 0;
			pRight->pParent = 0;

			rc = fts3ExprBalance(&pLeft, nMaxDepth - 1);
			if (rc == SQLITE_OK) {
				rc = fts3ExprBalance(&pRight, nMaxDepth - 1);
			}

			if (rc != SQLITE_OK) {
				sqlite3Fts3ExprFree(pRight);
				sqlite3Fts3ExprFree(pLeft);
			}
			else {
				assert(pLeft && pRight);
				pRoot->pLeft = pLeft;
				pLeft->pParent = pRoot;
				pRoot->pRight = pRight;
				pRight->pParent = pRoot;
			}
		}
	}

	if (rc != SQLITE_OK) {
		sqlite3Fts3ExprFree(pRoot);
		pRoot = 0;
	}
	*pp = pRoot;
	return rc;
}


static int fts3ExprParseUnbalanced(
	sqlite3_tokenizer *pTokenizer,      
	int iLangid,                        
	char **azCol,                       
	int bFts4,                          
	int nCol,                           
	int iDefaultCol,                    
	const char *z, int n,               
	Fts3Expr **ppExpr                   
) {
	int nParsed;
	int rc;
	ParseContext sParse;

	memset(&sParse, 0, sizeof(ParseContext));
	sParse.pTokenizer = pTokenizer;
	sParse.iLangid = iLangid;
	sParse.azCol = (const char **)azCol;
	sParse.nCol = nCol;
	sParse.iDefaultCol = iDefaultCol;
	sParse.bFts4 = bFts4;
	if (z == 0) {
		*ppExpr = 0;
		return SQLITE_OK;
	}
	if (n<0) {
		n = (int)strlen(z);
	}
	rc = fts3ExprParse(&sParse, z, n, ppExpr, &nParsed);
	assert(rc == SQLITE_OK || *ppExpr == 0);

	
	if (rc == SQLITE_OK && sParse.nNest) {
		rc = SQLITE_ERROR;
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3ExprParse(
	sqlite3_tokenizer *pTokenizer,      
	int iLangid,                        
	char **azCol,                       
	int bFts4,                          
	int nCol,                           
	int iDefaultCol,                    
	const char *z, int n,               
	Fts3Expr **ppExpr,                  
	char **pzErr                        
) {
	int rc = fts3ExprParseUnbalanced(
		pTokenizer, iLangid, azCol, bFts4, nCol, iDefaultCol, z, n, ppExpr
	);

	
	if (rc == SQLITE_OK && *ppExpr) {
		rc = fts3ExprBalance(ppExpr, SQLITE_FTS3_MAX_EXPR_DEPTH);
		if (rc == SQLITE_OK) {
			rc = fts3ExprCheckDepth(*ppExpr, SQLITE_FTS3_MAX_EXPR_DEPTH);
		}
	}

	if (rc != SQLITE_OK) {
		sqlite3Fts3ExprFree(*ppExpr);
		*ppExpr = 0;
		if (rc == SQLITE_TOOBIG) {
			sqlite3Fts3ErrMsg(pzErr,
				"FTS expression tree is too large (maximum depth %d)",
				SQLITE_FTS3_MAX_EXPR_DEPTH
			);
			rc = SQLITE_ERROR;
		}
		else if (rc == SQLITE_ERROR) {
			sqlite3Fts3ErrMsg(pzErr, "malformed MATCH expression: [%s]", z);
		}
	}

	return rc;
}


static void fts3FreeExprNode(Fts3Expr *p) {
	assert(p->eType == FTSQUERY_PHRASE || p->pPhrase == 0);
	sqlite3Fts3EvalPhraseCleanup(p->pPhrase);
	sqlite3_free(p->aMI);
	sqlite3_free(p);
}


SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *pDel) {
	Fts3Expr *p;
	assert(pDel == 0 || pDel->pParent == 0);
	for (p = pDel; p && (p->pLeft || p->pRight); p = (p->pLeft ? p->pLeft : p->pRight)) {
		assert(p->pParent == 0 || p == p->pParent->pRight || p == p->pParent->pLeft);
	}
	while (p) {
		Fts3Expr *pParent = p->pParent;
		fts3FreeExprNode(p);
		if (pParent && p == pParent->pLeft && pParent->pRight) {
			p = pParent->pRight;
			while (p && (p->pLeft || p->pRight)) {
				assert(p == p->pParent->pRight || p == p->pParent->pLeft);
				p = (p->pLeft ? p->pLeft : p->pRight);
			}
		}
		else {
			p = pParent;
		}
	}
}



#ifdef SQLITE_TEST




static int queryTestTokenizer(
	sqlite3 *db,
	const char *zName,
	const sqlite3_tokenizer_module **pp
) {
	int rc;
	sqlite3_stmt *pStmt;
	const char zSql[] = "SELECT fts3_tokenizer(?)";

	*pp = 0;
	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
	if (rc != SQLITE_OK) {
		return rc;
	}

	sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);
	if (SQLITE_ROW == sqlite3_step(pStmt)) {
		if (sqlite3_column_type(pStmt, 0) == SQLITE_BLOB) {
			memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));
		}
	}

	return sqlite3_finalize(pStmt);
}


static char *exprToString(Fts3Expr *pExpr, char *zBuf) {
	if (pExpr == 0) {
		return sqlite3_mprintf("");
	}
	switch (pExpr->eType) {
	case FTSQUERY_PHRASE: {
		Fts3Phrase *pPhrase = pExpr->pPhrase;
		int i;
		zBuf = sqlite3_mprintf(
			"%zPHRASE %d 0", zBuf, pPhrase->iColumn);
		for (i = 0; zBuf && i<pPhrase->nToken; i++) {
			zBuf = sqlite3_mprintf("%z %.*s%s", zBuf,
				pPhrase->aToken[i].n, pPhrase->aToken[i].z,
				(pPhrase->aToken[i].isPrefix ? "+" : "")
			);
		}
		return zBuf;
	}

	case FTSQUERY_NEAR:
		zBuf = sqlite3_mprintf("%zNEAR/%d ", zBuf, pExpr->nNear);
		break;
	case FTSQUERY_NOT:
		zBuf = sqlite3_mprintf("%zNOT ", zBuf);
		break;
	case FTSQUERY_AND:
		zBuf = sqlite3_mprintf("%zAND ", zBuf);
		break;
	case FTSQUERY_OR:
		zBuf = sqlite3_mprintf("%zOR ", zBuf);
		break;
	}

	if (zBuf) zBuf = sqlite3_mprintf("%z{", zBuf);
	if (zBuf) zBuf = exprToString(pExpr->pLeft, zBuf);
	if (zBuf) zBuf = sqlite3_mprintf("%z} {", zBuf);

	if (zBuf) zBuf = exprToString(pExpr->pRight, zBuf);
	if (zBuf) zBuf = sqlite3_mprintf("%z}", zBuf);

	return zBuf;
}


static void fts3ExprTest(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	sqlite3_tokenizer_module const *pModule = 0;
	sqlite3_tokenizer *pTokenizer = 0;
	int rc;
	char **azCol = 0;
	const char *zExpr;
	int nExpr;
	int nCol;
	int ii;
	Fts3Expr *pExpr;
	char *zBuf = 0;
	sqlite3 *db = sqlite3_context_db_handle(context);

	if (argc<3) {
		sqlite3_result_error(context,
			"Usage: fts3_exprtest(tokenizer, expr, col1, ...", -1
		);
		return;
	}

	rc = queryTestTokenizer(db,
		(const char *)sqlite3_value_text(argv[0]), &pModule);
	if (rc == SQLITE_NOMEM) {
		sqlite3_result_error_nomem(context);
		goto exprtest_out;
	}
	else if (!pModule) {
		sqlite3_result_error(context, "No such tokenizer module", -1);
		goto exprtest_out;
	}

	rc = pModule->xCreate(0, 0, &pTokenizer);
	assert(rc == SQLITE_NOMEM || rc == SQLITE_OK);
	if (rc == SQLITE_NOMEM) {
		sqlite3_result_error_nomem(context);
		goto exprtest_out;
	}
	pTokenizer->pModule = pModule;

	zExpr = (const char *)sqlite3_value_text(argv[1]);
	nExpr = sqlite3_value_bytes(argv[1]);
	nCol = argc - 2;
	azCol = (char **)sqlite3_malloc(nCol * sizeof(char *));
	if (!azCol) {
		sqlite3_result_error_nomem(context);
		goto exprtest_out;
	}
	for (ii = 0; ii<nCol; ii++) {
		azCol[ii] = (char *)sqlite3_value_text(argv[ii + 2]);
	}

	if (sqlite3_user_data(context)) {
		char *zDummy = 0;
		rc = sqlite3Fts3ExprParse(
			pTokenizer, 0, azCol, 0, nCol, nCol, zExpr, nExpr, &pExpr, &zDummy
		);
		assert(rc == SQLITE_OK || pExpr == 0);
		sqlite3_free(zDummy);
	}
	else {
		rc = fts3ExprParseUnbalanced(
			pTokenizer, 0, azCol, 0, nCol, nCol, zExpr, nExpr, &pExpr
		);
	}

	if (rc != SQLITE_OK && rc != SQLITE_NOMEM) {
		sqlite3Fts3ExprFree(pExpr);
		sqlite3_result_error(context, "Error parsing expression", -1);
	}
	else if (rc == SQLITE_NOMEM || !(zBuf = exprToString(pExpr, 0))) {
		sqlite3_result_error_nomem(context);
	}
	else {
		sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
		sqlite3_free(zBuf);
	}

	sqlite3Fts3ExprFree(pExpr);

exprtest_out:
	if (pModule && pTokenizer) {
		rc = pModule->xDestroy(pTokenizer);
	}
	sqlite3_free(azCol);
}


SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3* db) {
	int rc = sqlite3_create_function(
		db, "fts3_exprtest", -1, SQLITE_UTF8, 0, fts3ExprTest, 0, 0
	);
	if (rc == SQLITE_OK) {
		rc = sqlite3_create_function(db, "fts3_exprtest_rebalance",
			-1, SQLITE_UTF8, (void *)1, fts3ExprTest, 0, 0
		);
	}
	return rc;
}

#endif
#endif 







#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)








static void *fts3HashMalloc(int n) {
	void *p = sqlite3_malloc(n);
	if (p) {
		memset(p, 0, n);
	}
	return p;
}
static void fts3HashFree(void *p) {
	sqlite3_free(p);
}


SQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey) {
	assert(pNew != 0);
	assert(keyClass >= FTS3_HASH_STRING && keyClass <= FTS3_HASH_BINARY);
	pNew->keyClass = keyClass;
	pNew->copyKey = copyKey;
	pNew->first = 0;
	pNew->count = 0;
	pNew->htsize = 0;
	pNew->ht = 0;
}


SQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash *pH) {
	Fts3HashElem *elem;         

	assert(pH != 0);
	elem = pH->first;
	pH->first = 0;
	fts3HashFree(pH->ht);
	pH->ht = 0;
	pH->htsize = 0;
	while (elem) {
		Fts3HashElem *next_elem = elem->next;
		if (pH->copyKey && elem->pKey) {
			fts3HashFree(elem->pKey);
		}
		fts3HashFree(elem);
		elem = next_elem;
	}
	pH->count = 0;
}


static int fts3StrHash(const void *pKey, int nKey) {
	const char *z = (const char *)pKey;
	unsigned h = 0;
	if (nKey <= 0) nKey = (int)strlen(z);
	while (nKey > 0) {
		h = (h << 3) ^ h ^ *z++;
		nKey--;
	}
	return (int)(h & 0x7fffffff);
}
static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2) {
	if (n1 != n2) return 1;
	return strncmp((const char*)pKey1, (const char*)pKey2, n1);
}


static int fts3BinHash(const void *pKey, int nKey) {
	int h = 0;
	const char *z = (const char *)pKey;
	while (nKey-- > 0) {
		h = (h << 3) ^ h ^ *(z++);
	}
	return h & 0x7fffffff;
}
static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2) {
	if (n1 != n2) return 1;
	return memcmp(pKey1, pKey2, n1);
}


static int(*ftsHashFunction(int keyClass))(const void*, int) {
	if (keyClass == FTS3_HASH_STRING) {
		return &fts3StrHash;
	}
	else {
		assert(keyClass == FTS3_HASH_BINARY);
		return &fts3BinHash;
	}
}


static int(*ftsCompareFunction(int keyClass))(const void*, int, const void*, int) {
	if (keyClass == FTS3_HASH_STRING) {
		return &fts3StrCompare;
	}
	else {
		assert(keyClass == FTS3_HASH_BINARY);
		return &fts3BinCompare;
	}
}


static void fts3HashInsertElement(
	Fts3Hash *pH,            
	struct _fts3ht *pEntry,  
	Fts3HashElem *pNew       
) {
	Fts3HashElem *pHead;     
	pHead = pEntry->chain;
	if (pHead) {
		pNew->next = pHead;
		pNew->prev = pHead->prev;
		if (pHead->prev) { pHead->prev->next = pNew; }
		else { pH->first = pNew; }
		pHead->prev = pNew;
	}
	else {
		pNew->next = pH->first;
		if (pH->first) { pH->first->prev = pNew; }
		pNew->prev = 0;
		pH->first = pNew;
	}
	pEntry->count++;
	pEntry->chain = pNew;
}



static int fts3Rehash(Fts3Hash *pH, int new_size) {
	struct _fts3ht *new_ht;          
	Fts3HashElem *elem, *next_elem;  
	int(*xHash)(const void*, int);   

	assert((new_size & (new_size - 1)) == 0);
	new_ht = (struct _fts3ht *)fts3HashMalloc(new_size * sizeof(struct _fts3ht));
	if (new_ht == 0) return 1;
	fts3HashFree(pH->ht);
	pH->ht = new_ht;
	pH->htsize = new_size;
	xHash = ftsHashFunction(pH->keyClass);
	for (elem = pH->first, pH->first = 0; elem; elem = next_elem) {
		int h = (*xHash)(elem->pKey, elem->nKey) & (new_size - 1);
		next_elem = elem->next;
		fts3HashInsertElement(pH, &new_ht[h], elem);
	}
	return 0;
}


static Fts3HashElem *fts3FindElementByHash(
	const Fts3Hash *pH, 
	const void *pKey,   
	int nKey,
	int h               
) {
	Fts3HashElem *elem;            
	int count;                     
	int(*xCompare)(const void*, int, const void*, int);  

	if (pH->ht) {
		struct _fts3ht *pEntry = &pH->ht[h];
		elem = pEntry->chain;
		count = pEntry->count;
		xCompare = ftsCompareFunction(pH->keyClass);
		while (count-- && elem) {
			if ((*xCompare)(elem->pKey, elem->nKey, pKey, nKey) == 0) {
				return elem;
			}
			elem = elem->next;
		}
	}
	return 0;
}


static void fts3RemoveElementByHash(
	Fts3Hash *pH,         
	Fts3HashElem* elem,   
	int h                 
) {
	struct _fts3ht *pEntry;
	if (elem->prev) {
		elem->prev->next = elem->next;
	}
	else {
		pH->first = elem->next;
	}
	if (elem->next) {
		elem->next->prev = elem->prev;
	}
	pEntry = &pH->ht[h];
	if (pEntry->chain == elem) {
		pEntry->chain = elem->next;
	}
	pEntry->count--;
	if (pEntry->count <= 0) {
		pEntry->chain = 0;
	}
	if (pH->copyKey && elem->pKey) {
		fts3HashFree(elem->pKey);
	}
	fts3HashFree(elem);
	pH->count--;
	if (pH->count <= 0) {
		assert(pH->first == 0);
		assert(pH->count == 0);
		fts3HashClear(pH);
	}
}

SQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(
	const Fts3Hash *pH,
	const void *pKey,
	int nKey
) {
	int h;                          
	int(*xHash)(const void*, int);  

	if (pH == 0 || pH->ht == 0) return 0;
	xHash = ftsHashFunction(pH->keyClass);
	assert(xHash != 0);
	h = (*xHash)(pKey, nKey);
	assert((pH->htsize & (pH->htsize - 1)) == 0);
	return fts3FindElementByHash(pH, pKey, nKey, h & (pH->htsize - 1));
}


SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey) {
	Fts3HashElem *pElem;            

	pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);
	return pElem ? pElem->data : 0;
}


SQLITE_PRIVATE void *sqlite3Fts3HashInsert(
	Fts3Hash *pH,        
	const void *pKey,    
	int nKey,            
	void *data           
) {
	int hraw;                 
	int h;                    
	Fts3HashElem *elem;       
	Fts3HashElem *new_elem;   
	int(*xHash)(const void*, int);  

	assert(pH != 0);
	xHash = ftsHashFunction(pH->keyClass);
	assert(xHash != 0);
	hraw = (*xHash)(pKey, nKey);
	assert((pH->htsize & (pH->htsize - 1)) == 0);
	h = hraw & (pH->htsize - 1);
	elem = fts3FindElementByHash(pH, pKey, nKey, h);
	if (elem) {
		void *old_data = elem->data;
		if (data == 0) {
			fts3RemoveElementByHash(pH, elem, h);
		}
		else {
			elem->data = data;
		}
		return old_data;
	}
	if (data == 0) return 0;
	if ((pH->htsize == 0 && fts3Rehash(pH, 8))
		|| (pH->count >= pH->htsize && fts3Rehash(pH, pH->htsize * 2))
		) {
		pH->count = 0;
		return data;
	}
	assert(pH->htsize>0);
	new_elem = (Fts3HashElem*)fts3HashMalloc(sizeof(Fts3HashElem));
	if (new_elem == 0) return data;
	if (pH->copyKey && pKey != 0) {
		new_elem->pKey = fts3HashMalloc(nKey);
		if (new_elem->pKey == 0) {
			fts3HashFree(new_elem);
			return data;
		}
		memcpy((void*)new_elem->pKey, pKey, nKey);
	}
	else {
		new_elem->pKey = (void*)pKey;
	}
	new_elem->nKey = nKey;
	pH->count++;
	assert(pH->htsize>0);
	assert((pH->htsize & (pH->htsize - 1)) == 0);
	h = hraw & (pH->htsize - 1);
	fts3HashInsertElement(pH, &pH->ht[h], new_elem);
	new_elem->data = data;
	return 0;
}

#endif 







#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)









typedef struct porter_tokenizer {
	sqlite3_tokenizer base;      
} porter_tokenizer;


typedef struct porter_tokenizer_cursor {
	sqlite3_tokenizer_cursor base;
	const char *zInput;          
	int nInput;                  
	int iOffset;                 
	int iToken;                  
	char *zToken;                
	int nAllocated;              
} porter_tokenizer_cursor;



static int porterCreate(
	int argc, const char * const *argv,
	sqlite3_tokenizer **ppTokenizer
) {
	porter_tokenizer *t;

	UNUSED_PARAMETER(argc);
	UNUSED_PARAMETER(argv);

	t = (porter_tokenizer *)sqlite3_malloc(sizeof(*t));
	if (t == NULL) return SQLITE_NOMEM;
	memset(t, 0, sizeof(*t));
	*ppTokenizer = &t->base;
	return SQLITE_OK;
}


static int porterDestroy(sqlite3_tokenizer *pTokenizer) {
	sqlite3_free(pTokenizer);
	return SQLITE_OK;
}


static int porterOpen(
	sqlite3_tokenizer *pTokenizer,         
	const char *zInput, int nInput,        
	sqlite3_tokenizer_cursor **ppCursor    
) {
	porter_tokenizer_cursor *c;

	UNUSED_PARAMETER(pTokenizer);

	c = (porter_tokenizer_cursor *)sqlite3_malloc(sizeof(*c));
	if (c == NULL) return SQLITE_NOMEM;

	c->zInput = zInput;
	if (zInput == 0) {
		c->nInput = 0;
	}
	else if (nInput<0) {
		c->nInput = (int)strlen(zInput);
	}
	else {
		c->nInput = nInput;
	}
	c->iOffset = 0;                 
	c->iToken = 0;
	c->zToken = NULL;               
	c->nAllocated = 0;

	*ppCursor = &c->base;
	return SQLITE_OK;
}


static int porterClose(sqlite3_tokenizer_cursor *pCursor) {
	porter_tokenizer_cursor *c = (porter_tokenizer_cursor *)pCursor;
	sqlite3_free(c->zToken);
	sqlite3_free(c);
	return SQLITE_OK;
}

static const char cType[] = {
	0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,
	1, 1, 1, 2, 1
};


static int isVowel(const char*);
static int isConsonant(const char *z) {
	int j;
	char x = *z;
	if (x == 0) return 0;
	assert(x >= 'a' && x <= 'z');
	j = cType[x - 'a'];
	if (j<2) return j;
	return z[1] == 0 || isVowel(z + 1);
}
static int isVowel(const char *z) {
	int j;
	char x = *z;
	if (x == 0) return 0;
	assert(x >= 'a' && x <= 'z');
	j = cType[x - 'a'];
	if (j<2) return 1 - j;
	return isConsonant(z + 1);
}


static int m_gt_0(const char *z) {
	while (isVowel(z)) { z++; }
	if (*z == 0) return 0;
	while (isConsonant(z)) { z++; }
	return *z != 0;
}


static int m_eq_1(const char *z) {
	while (isVowel(z)) { z++; }
	if (*z == 0) return 0;
	while (isConsonant(z)) { z++; }
	if (*z == 0) return 0;
	while (isVowel(z)) { z++; }
	if (*z == 0) return 1;
	while (isConsonant(z)) { z++; }
	return *z == 0;
}


static int m_gt_1(const char *z) {
	while (isVowel(z)) { z++; }
	if (*z == 0) return 0;
	while (isConsonant(z)) { z++; }
	if (*z == 0) return 0;
	while (isVowel(z)) { z++; }
	if (*z == 0) return 0;
	while (isConsonant(z)) { z++; }
	return *z != 0;
}


static int hasVowel(const char *z) {
	while (isConsonant(z)) { z++; }
	return *z != 0;
}


static int doubleConsonant(const char *z) {
	return isConsonant(z) && z[0] == z[1];
}


static int star_oh(const char *z) {
	return
		isConsonant(z) &&
		z[0] != 'w' && z[0] != 'x' && z[0] != 'y' &&
		isVowel(z + 1) &&
		isConsonant(z + 2);
}


static int stem(
	char **pz,             
	const char *zFrom,     
	const char *zTo,       
	int(*xCond)(const char*)   
) {
	char *z = *pz;
	while (*zFrom && *zFrom == *z) { z++; zFrom++; }
	if (*zFrom != 0) return 0;
	if (xCond && !xCond(z)) return 1;
	while (*zTo) {
		*(--z) = *(zTo++);
	}
	*pz = z;
	return 1;
}


static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut) {
	int i, mx, j;
	int hasDigit = 0;
	for (i = 0; i<nIn; i++) {
		char c = zIn[i];
		if (c >= 'A' && c <= 'Z') {
			zOut[i] = c - 'A' + 'a';
		}
		else {
			if (c >= '0' && c <= '9') hasDigit = 1;
			zOut[i] = c;
		}
	}
	mx = hasDigit ? 3 : 10;
	if (nIn>mx * 2) {
		for (j = mx, i = nIn - mx; i<nIn; i++, j++) {
			zOut[j] = zOut[i];
		}
		i = j;
	}
	zOut[i] = 0;
	*pnOut = i;
}



static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut) {
	int i, j;
	char zReverse[28];
	char *z, *z2;
	if (nIn<3 || nIn >= (int)sizeof(zReverse) - 7) {
		
		copy_stemmer(zIn, nIn, zOut, pnOut);
		return;
	}
	for (i = 0, j = sizeof(zReverse) - 6; i<nIn; i++, j--) {
		char c = zIn[i];
		if (c >= 'A' && c <= 'Z') {
			zReverse[j] = c + 'a' - 'A';
		}
		else if (c >= 'a' && c <= 'z') {
			zReverse[j] = c;
		}
		else {
			
			copy_stemmer(zIn, nIn, zOut, pnOut);
			return;
		}
	}
	memset(&zReverse[sizeof(zReverse) - 5], 0, 5);
	z = &zReverse[j + 1];


	
	if (z[0] == 's') {
		if (
			!stem(&z, "sess", "ss", 0) &&
			!stem(&z, "sei", "i", 0) &&
			!stem(&z, "ss", "ss", 0)
			) {
			z++;
		}
	}

	
	z2 = z;
	if (stem(&z, "dee", "ee", m_gt_0)) {
		
	}
	else if (
		(stem(&z, "gni", "", hasVowel) || stem(&z, "de", "", hasVowel))
		&& z != z2
		) {
		if (stem(&z, "ta", "ate", 0) ||
			stem(&z, "lb", "ble", 0) ||
			stem(&z, "zi", "ize", 0)) {
			
		}
		else if (doubleConsonant(z) && (*z != 'l' && *z != 's' && *z != 'z')) {
			z++;
		}
		else if (m_eq_1(z) && star_oh(z)) {
			*(--z) = 'e';
		}
	}

	
	if (z[0] == 'y' && hasVowel(z + 1)) {
		z[0] = 'i';
	}

	
	switch (z[1]) {
	case 'a':
		if (!stem(&z, "lanoita", "ate", m_gt_0)) {
			stem(&z, "lanoit", "tion", m_gt_0);
		}
		break;
	case 'c':
		if (!stem(&z, "icne", "ence", m_gt_0)) {
			stem(&z, "icna", "ance", m_gt_0);
		}
		break;
	case 'e':
		stem(&z, "rezi", "ize", m_gt_0);
		break;
	case 'g':
		stem(&z, "igol", "log", m_gt_0);
		break;
	case 'l':
		if (!stem(&z, "ilb", "ble", m_gt_0)
			&& !stem(&z, "illa", "al", m_gt_0)
			&& !stem(&z, "iltne", "ent", m_gt_0)
			&& !stem(&z, "ile", "e", m_gt_0)
			) {
			stem(&z, "ilsuo", "ous", m_gt_0);
		}
		break;
	case 'o':
		if (!stem(&z, "noitazi", "ize", m_gt_0)
			&& !stem(&z, "noita", "ate", m_gt_0)
			) {
			stem(&z, "rota", "ate", m_gt_0);
		}
		break;
	case 's':
		if (!stem(&z, "msila", "al", m_gt_0)
			&& !stem(&z, "ssenevi", "ive", m_gt_0)
			&& !stem(&z, "ssenluf", "ful", m_gt_0)
			) {
			stem(&z, "ssensuo", "ous", m_gt_0);
		}
		break;
	case 't':
		if (!stem(&z, "itila", "al", m_gt_0)
			&& !stem(&z, "itivi", "ive", m_gt_0)
			) {
			stem(&z, "itilib", "ble", m_gt_0);
		}
		break;
	}

	
	switch (z[0]) {
	case 'e':
		if (!stem(&z, "etaci", "ic", m_gt_0)
			&& !stem(&z, "evita", "", m_gt_0)
			) {
			stem(&z, "ezila", "al", m_gt_0);
		}
		break;
	case 'i':
		stem(&z, "itici", "ic", m_gt_0);
		break;
	case 'l':
		if (!stem(&z, "laci", "ic", m_gt_0)) {
			stem(&z, "luf", "", m_gt_0);
		}
		break;
	case 's':
		stem(&z, "ssen", "", m_gt_0);
		break;
	}

	
	switch (z[1]) {
	case 'a':
		if (z[0] == 'l' && m_gt_1(z + 2)) {
			z += 2;
		}
		break;
	case 'c':
		if (z[0] == 'e' && z[2] == 'n' && (z[3] == 'a' || z[3] == 'e') && m_gt_1(z + 4)) {
			z += 4;
		}
		break;
	case 'e':
		if (z[0] == 'r' && m_gt_1(z + 2)) {
			z += 2;
		}
		break;
	case 'i':
		if (z[0] == 'c' && m_gt_1(z + 2)) {
			z += 2;
		}
		break;
	case 'l':
		if (z[0] == 'e' && z[2] == 'b' && (z[3] == 'a' || z[3] == 'i') && m_gt_1(z + 4)) {
			z += 4;
		}
		break;
	case 'n':
		if (z[0] == 't') {
			if (z[2] == 'a') {
				if (m_gt_1(z + 3)) {
					z += 3;
				}
			}
			else if (z[2] == 'e') {
				if (!stem(&z, "tneme", "", m_gt_1)
					&& !stem(&z, "tnem", "", m_gt_1)
					) {
					stem(&z, "tne", "", m_gt_1);
				}
			}
		}
		break;
	case 'o':
		if (z[0] == 'u') {
			if (m_gt_1(z + 2)) {
				z += 2;
			}
		}
		else if (z[3] == 's' || z[3] == 't') {
			stem(&z, "noi", "", m_gt_1);
		}
		break;
	case 's':
		if (z[0] == 'm' && z[2] == 'i' && m_gt_1(z + 3)) {
			z += 3;
		}
		break;
	case 't':
		if (!stem(&z, "eta", "", m_gt_1)) {
			stem(&z, "iti", "", m_gt_1);
		}
		break;
	case 'u':
		if (z[0] == 's' && z[2] == 'o' && m_gt_1(z + 3)) {
			z += 3;
		}
		break;
	case 'v':
	case 'z':
		if (z[0] == 'e' && z[2] == 'i' && m_gt_1(z + 3)) {
			z += 3;
		}
		break;
	}

	
	if (z[0] == 'e') {
		if (m_gt_1(z + 1)) {
			z++;
		}
		else if (m_eq_1(z + 1) && !star_oh(z + 1)) {
			z++;
		}
	}

	
	if (m_gt_1(z) && z[0] == 'l' && z[1] == 'l') {
		z++;
	}

	
	*pnOut = i = (int)strlen(z);
	zOut[i] = 0;
	while (*z) {
		zOut[--i] = *(z++);
	}
}


static const char porterIdChar[] = {
	
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  
};
#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30]))


static int porterNext(
	sqlite3_tokenizer_cursor *pCursor,  
	const char **pzToken,               
	int *pnBytes,                       
	int *piStartOffset,                 
	int *piEndOffset,                   
	int *piPosition                     
) {
	porter_tokenizer_cursor *c = (porter_tokenizer_cursor *)pCursor;
	const char *z = c->zInput;

	while (c->iOffset<c->nInput) {
		int iStartOffset, ch;

		
		while (c->iOffset<c->nInput && isDelim(z[c->iOffset])) {
			c->iOffset++;
		}

		
		iStartOffset = c->iOffset;
		while (c->iOffset<c->nInput && !isDelim(z[c->iOffset])) {
			c->iOffset++;
		}

		if (c->iOffset>iStartOffset) {
			int n = c->iOffset - iStartOffset;
			if (n>c->nAllocated) {
				char *pNew;
				c->nAllocated = n + 20;
				pNew = sqlite3_realloc(c->zToken, c->nAllocated);
				if (!pNew) return SQLITE_NOMEM;
				c->zToken = pNew;
			}
			porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);
			*pzToken = c->zToken;
			*piStartOffset = iStartOffset;
			*piEndOffset = c->iOffset;
			*piPosition = c->iToken++;
			return SQLITE_OK;
		}
	}
	return SQLITE_DONE;
}


static const sqlite3_tokenizer_module porterTokenizerModule = {
	0,
	porterCreate,
	porterDestroy,
	porterOpen,
	porterClose,
	porterNext,
	0
};


SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(
	sqlite3_tokenizer_module const**ppModule
) {
	*ppModule = &porterTokenizerModule;
}

#endif 







#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)





static int fts3TokenizerEnabled(sqlite3_context *context) {
	sqlite3 *db = sqlite3_context_db_handle(context);
	int isEnabled = 0;
	sqlite3_db_config(db, SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, -1, &isEnabled);
	return isEnabled;
}


static void fts3TokenizerFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	Fts3Hash *pHash;
	void *pPtr = 0;
	const unsigned char *zName;
	int nName;

	assert(argc == 1 || argc == 2);

	pHash = (Fts3Hash *)sqlite3_user_data(context);

	zName = sqlite3_value_text(argv[0]);
	nName = sqlite3_value_bytes(argv[0]) + 1;

	if (argc == 2) {
		if (fts3TokenizerEnabled(context)) {
			void *pOld;
			int n = sqlite3_value_bytes(argv[1]);
			if (zName == 0 || n != sizeof(pPtr)) {
				sqlite3_result_error(context, "argument type mismatch", -1);
				return;
			}
			pPtr = *(void **)sqlite3_value_blob(argv[1]);
			pOld = sqlite3Fts3HashInsert(pHash, (void *)zName, nName, pPtr);
			if (pOld == pPtr) {
				sqlite3_result_error(context, "out of memory", -1);
			}
		}
		else {
			sqlite3_result_error(context, "fts3tokenize disabled", -1);
			return;
		}
	}
	else {
		if (zName) {
			pPtr = sqlite3Fts3HashFind(pHash, zName, nName);
		}
		if (!pPtr) {
			char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName);
			sqlite3_result_error(context, zErr, -1);
			sqlite3_free(zErr);
			return;
		}
	}
	sqlite3_result_blob(context, (void *)&pPtr, sizeof(pPtr), SQLITE_TRANSIENT);
}

SQLITE_PRIVATE int sqlite3Fts3IsIdChar(char c) {
	static const char isFtsIdChar[] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
		0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  
		0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  
		0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  
	};
	return (c & 0x80 || isFtsIdChar[(int)(c)]);
}

SQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *zStr, int *pn) {
	const char *z1;
	const char *z2 = 0;

	
	z1 = zStr;
	while (z2 == 0) {
		char c = *z1;
		switch (c) {
		case '\0': return 0;        
		case '\'':
		case '"':
		case '`': {
			z2 = z1;
			while (*++z2 && (*z2 != c || *++z2 == c));
			break;
		}
		case '[':
			z2 = &z1[1];
			while (*z2 && z2[0] != ']') z2++;
			if (*z2) z2++;
			break;

		default:
			if (sqlite3Fts3IsIdChar(*z1)) {
				z2 = &z1[1];
				while (sqlite3Fts3IsIdChar(*z2)) z2++;
			}
			else {
				z1++;
			}
		}
	}

	*pn = (int)(z2 - z1);
	return z1;
}

SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(
	Fts3Hash *pHash,                
	const char *zArg,               
	sqlite3_tokenizer **ppTok,      
	char **pzErr                    
) {
	int rc;
	char *z = (char *)zArg;
	int n = 0;
	char *zCopy;
	char *zEnd;                     
	sqlite3_tokenizer_module *m;

	zCopy = sqlite3_mprintf("%s", zArg);
	if (!zCopy) return SQLITE_NOMEM;
	zEnd = &zCopy[strlen(zCopy)];

	z = (char *)sqlite3Fts3NextToken(zCopy, &n);
	if (z == 0) {
		assert(n == 0);
		z = zCopy;
	}
	z[n] = '\0';
	sqlite3Fts3Dequote(z);

	m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, z, (int)strlen(z) + 1);
	if (!m) {
		sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", z);
		rc = SQLITE_ERROR;
	}
	else {
		char const **aArg = 0;
		int iArg = 0;
		z = &z[n + 1];
		while (z<zEnd && (NULL != (z = (char *)sqlite3Fts3NextToken(z, &n)))) {
			int nNew = sizeof(char *)*(iArg + 1);
			char const **aNew = (const char **)sqlite3_realloc((void *)aArg, nNew);
			if (!aNew) {
				sqlite3_free(zCopy);
				sqlite3_free((void *)aArg);
				return SQLITE_NOMEM;
			}
			aArg = aNew;
			aArg[iArg++] = z;
			z[n] = '\0';
			sqlite3Fts3Dequote(z);
			z = &z[n + 1];
		}
		rc = m->xCreate(iArg, aArg, ppTok);
		assert(rc != SQLITE_OK || *ppTok);
		if (rc != SQLITE_OK) {
			sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer");
		}
		else {
			(*ppTok)->pModule = m;
		}
		sqlite3_free((void *)aArg);
	}

	sqlite3_free(zCopy);
	return rc;
}


#ifdef SQLITE_TEST

#if defined(INCLUDE_SQLITE_TCL_H)
#  include "sqlite_tcl.h"
#else
#  include "tcl.h"
#endif



static void testFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	Fts3Hash *pHash;
	sqlite3_tokenizer_module *p;
	sqlite3_tokenizer *pTokenizer = 0;
	sqlite3_tokenizer_cursor *pCsr = 0;

	const char *zErr = 0;

	const char *zName;
	int nName;
	const char *zInput;
	int nInput;

	const char *azArg[64];

	const char *zToken;
	int nToken = 0;
	int iStart = 0;
	int iEnd = 0;
	int iPos = 0;
	int i;

	Tcl_Obj *pRet;

	if (argc<2) {
		sqlite3_result_error(context, "insufficient arguments", -1);
		return;
	}

	nName = sqlite3_value_bytes(argv[0]);
	zName = (const char *)sqlite3_value_text(argv[0]);
	nInput = sqlite3_value_bytes(argv[argc - 1]);
	zInput = (const char *)sqlite3_value_text(argv[argc - 1]);

	pHash = (Fts3Hash *)sqlite3_user_data(context);
	p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName + 1);

	if (!p) {
		char *zErr2 = sqlite3_mprintf("unknown tokenizer: %s", zName);
		sqlite3_result_error(context, zErr2, -1);
		sqlite3_free(zErr2);
		return;
	}

	pRet = Tcl_NewObj();
	Tcl_IncrRefCount(pRet);

	for (i = 1; i<argc - 1; i++) {
		azArg[i - 1] = (const char *)sqlite3_value_text(argv[i]);
	}

	if (SQLITE_OK != p->xCreate(argc - 2, azArg, &pTokenizer)) {
		zErr = "error in xCreate()";
		goto finish;
	}
	pTokenizer->pModule = p;
	if (sqlite3Fts3OpenTokenizer(pTokenizer, 0, zInput, nInput, &pCsr)) {
		zErr = "error in xOpen()";
		goto finish;
	}

	while (SQLITE_OK == p->xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos)) {
		Tcl_ListObjAppendElement(0, pRet, Tcl_NewIntObj(iPos));
		Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));
		zToken = &zInput[iStart];
		nToken = iEnd - iStart;
		Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));
	}

	if (SQLITE_OK != p->xClose(pCsr)) {
		zErr = "error in xClose()";
		goto finish;
	}
	if (SQLITE_OK != p->xDestroy(pTokenizer)) {
		zErr = "error in xDestroy()";
		goto finish;
	}

finish:
	if (zErr) {
		sqlite3_result_error(context, zErr, -1);
	}
	else {
		sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);
	}
	Tcl_DecrRefCount(pRet);
}

static
int registerTokenizer(
	sqlite3 *db,
	char *zName,
	const sqlite3_tokenizer_module *p
) {
	int rc;
	sqlite3_stmt *pStmt;
	const char zSql[] = "SELECT fts3_tokenizer(?, ?)";

	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
	if (rc != SQLITE_OK) {
		return rc;
	}

	sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);
	sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);
	sqlite3_step(pStmt);

	return sqlite3_finalize(pStmt);
}


static
int queryTokenizer(
	sqlite3 *db,
	char *zName,
	const sqlite3_tokenizer_module **pp
) {
	int rc;
	sqlite3_stmt *pStmt;
	const char zSql[] = "SELECT fts3_tokenizer(?)";

	*pp = 0;
	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
	if (rc != SQLITE_OK) {
		return rc;
	}

	sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);
	if (SQLITE_ROW == sqlite3_step(pStmt)) {
		if (sqlite3_column_type(pStmt, 0) == SQLITE_BLOB) {
			memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));
		}
	}

	return sqlite3_finalize(pStmt);
}

SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);


static void intTestFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	int rc;
	const sqlite3_tokenizer_module *p1;
	const sqlite3_tokenizer_module *p2;
	sqlite3 *db = (sqlite3 *)sqlite3_user_data(context);

	UNUSED_PARAMETER(argc);
	UNUSED_PARAMETER(argv);

	
	sqlite3Fts3SimpleTokenizerModule(&p1);
	rc = queryTokenizer(db, "simple", &p2);
	assert(rc == SQLITE_OK);
	assert(p1 == p2);
	rc = queryTokenizer(db, "nosuchtokenizer", &p2);
	assert(rc == SQLITE_ERROR);
	assert(p2 == 0);
	assert(0 == strcmp(sqlite3_errmsg(db), "unknown tokenizer: nosuchtokenizer"));

	
	if (fts3TokenizerEnabled(context)) {
		rc = registerTokenizer(db, "nosuchtokenizer", p1);
		assert(rc == SQLITE_OK);
		rc = queryTokenizer(db, "nosuchtokenizer", &p2);
		assert(rc == SQLITE_OK);
		assert(p2 == p1);
	}

	sqlite3_result_text(context, "ok", -1, SQLITE_STATIC);
}

#endif


SQLITE_PRIVATE int sqlite3Fts3InitHashTable(
	sqlite3 *db,
	Fts3Hash *pHash,
	const char *zName
) {
	int rc = SQLITE_OK;
	void *p = (void *)pHash;
	const int any = SQLITE_ANY;

#ifdef SQLITE_TEST
	char *zTest = 0;
	char *zTest2 = 0;
	void *pdb = (void *)db;
	zTest = sqlite3_mprintf("%s_test", zName);
	zTest2 = sqlite3_mprintf("%s_internal_test", zName);
	if (!zTest || !zTest2) {
		rc = SQLITE_NOMEM;
	}
#endif

	if (SQLITE_OK == rc) {
		rc = sqlite3_create_function(db, zName, 1, any, p, fts3TokenizerFunc, 0, 0);
	}
	if (SQLITE_OK == rc) {
		rc = sqlite3_create_function(db, zName, 2, any, p, fts3TokenizerFunc, 0, 0);
	}
#ifdef SQLITE_TEST
	if (SQLITE_OK == rc) {
		rc = sqlite3_create_function(db, zTest, -1, any, p, testFunc, 0, 0);
	}
	if (SQLITE_OK == rc) {
		rc = sqlite3_create_function(db, zTest2, 0, any, pdb, intTestFunc, 0, 0);
	}
#endif

#ifdef SQLITE_TEST
	sqlite3_free(zTest);
	sqlite3_free(zTest2);
#endif

	return rc;
}

#endif 







#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)








typedef struct simple_tokenizer {
	sqlite3_tokenizer base;
	char delim[128];             
} simple_tokenizer;

typedef struct simple_tokenizer_cursor {
	sqlite3_tokenizer_cursor base;
	const char *pInput;          
	int nBytes;                  
	int iOffset;                 
	int iToken;                  
	char *pToken;                
	int nTokenAllocated;         
} simple_tokenizer_cursor;


static int simpleDelim(simple_tokenizer *t, unsigned char c) {
	return c<0x80 && t->delim[c];
}
static int fts3_isalnum(int x) {
	return (x >= '0' && x <= '9') || (x >= 'A' && x <= 'Z') || (x >= 'a' && x <= 'z');
}


static int simpleCreate(
	int argc, const char * const *argv,
	sqlite3_tokenizer **ppTokenizer
) {
	simple_tokenizer *t;

	t = (simple_tokenizer *)sqlite3_malloc(sizeof(*t));
	if (t == NULL) return SQLITE_NOMEM;
	memset(t, 0, sizeof(*t));

	
	if (argc>1) {
		int i, n = (int)strlen(argv[1]);
		for (i = 0; i<n; i++) {
			unsigned char ch = argv[1][i];
			
			if (ch >= 0x80) {
				sqlite3_free(t);
				return SQLITE_ERROR;
			}
			t->delim[ch] = 1;
		}
	}
	else {
		
		int i;
		for (i = 1; i<0x80; i++) {
			t->delim[i] = !fts3_isalnum(i) ? -1 : 0;
		}
	}

	*ppTokenizer = &t->base;
	return SQLITE_OK;
}


static int simpleDestroy(sqlite3_tokenizer *pTokenizer) {
	sqlite3_free(pTokenizer);
	return SQLITE_OK;
}


static int simpleOpen(
	sqlite3_tokenizer *pTokenizer,         
	const char *pInput, int nBytes,        
	sqlite3_tokenizer_cursor **ppCursor    
) {
	simple_tokenizer_cursor *c;

	UNUSED_PARAMETER(pTokenizer);

	c = (simple_tokenizer_cursor *)sqlite3_malloc(sizeof(*c));
	if (c == NULL) return SQLITE_NOMEM;

	c->pInput = pInput;
	if (pInput == 0) {
		c->nBytes = 0;
	}
	else if (nBytes<0) {
		c->nBytes = (int)strlen(pInput);
	}
	else {
		c->nBytes = nBytes;
	}
	c->iOffset = 0;                 
	c->iToken = 0;
	c->pToken = NULL;               
	c->nTokenAllocated = 0;

	*ppCursor = &c->base;
	return SQLITE_OK;
}


static int simpleClose(sqlite3_tokenizer_cursor *pCursor) {
	simple_tokenizer_cursor *c = (simple_tokenizer_cursor *)pCursor;
	sqlite3_free(c->pToken);
	sqlite3_free(c);
	return SQLITE_OK;
}


static int simpleNext(
	sqlite3_tokenizer_cursor *pCursor,  
	const char **ppToken,               
	int *pnBytes,                       
	int *piStartOffset,                 
	int *piEndOffset,                   
	int *piPosition                     
) {
	simple_tokenizer_cursor *c = (simple_tokenizer_cursor *)pCursor;
	simple_tokenizer *t = (simple_tokenizer *)pCursor->pTokenizer;
	unsigned char *p = (unsigned char *)c->pInput;

	while (c->iOffset<c->nBytes) {
		int iStartOffset;

		
		while (c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset])) {
			c->iOffset++;
		}

		
		iStartOffset = c->iOffset;
		while (c->iOffset<c->nBytes && !simpleDelim(t, p[c->iOffset])) {
			c->iOffset++;
		}

		if (c->iOffset>iStartOffset) {
			int i, n = c->iOffset - iStartOffset;
			if (n>c->nTokenAllocated) {
				char *pNew;
				c->nTokenAllocated = n + 20;
				pNew = sqlite3_realloc(c->pToken, c->nTokenAllocated);
				if (!pNew) return SQLITE_NOMEM;
				c->pToken = pNew;
			}
			for (i = 0; i<n; i++) {
				
				unsigned char ch = p[iStartOffset + i];
				c->pToken[i] = (char)((ch >= 'A' && ch <= 'Z') ? ch - 'A' + 'a' : ch);
			}
			*ppToken = c->pToken;
			*pnBytes = n;
			*piStartOffset = iStartOffset;
			*piEndOffset = c->iOffset;
			*piPosition = c->iToken++;

			return SQLITE_OK;
		}
	}
	return SQLITE_DONE;
}


static const sqlite3_tokenizer_module simpleTokenizerModule = {
	0,
	simpleCreate,
	simpleDestroy,
	simpleOpen,
	simpleClose,
	simpleNext,
	0,
};


SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(
	sqlite3_tokenizer_module const**ppModule
) {
	*ppModule = &simpleTokenizerModule;
}

#endif 





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)




typedef struct Fts3tokTable Fts3tokTable;
typedef struct Fts3tokCursor Fts3tokCursor;


struct Fts3tokTable {
	sqlite3_vtab base;              
	const sqlite3_tokenizer_module *pMod;
	sqlite3_tokenizer *pTok;
};


struct Fts3tokCursor {
	sqlite3_vtab_cursor base;       
	char *zInput;                   
	sqlite3_tokenizer_cursor *pCsr; 
	int iRowid;                     
	const char *zToken;             
	int nToken;                     
	int iStart;                     
	int iEnd;                       
	int iPos;                       
};


static int fts3tokQueryTokenizer(
	Fts3Hash *pHash,
	const char *zName,
	const sqlite3_tokenizer_module **pp,
	char **pzErr
) {
	sqlite3_tokenizer_module *p;
	int nName = (int)strlen(zName);

	p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName + 1);
	if (!p) {
		sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", zName);
		return SQLITE_ERROR;
	}

	*pp = p;
	return SQLITE_OK;
}


static int fts3tokDequoteArray(
	int argc,                       
	const char * const *argv,       
	char ***pazDequote              
) {
	int rc = SQLITE_OK;             
	if (argc == 0) {
		*pazDequote = 0;
	}
	else {
		int i;
		int nByte = 0;
		char **azDequote;

		for (i = 0; i<argc; i++) {
			nByte += (int)(strlen(argv[i]) + 1);
		}

		*pazDequote = azDequote = sqlite3_malloc(sizeof(char *)*argc + nByte);
		if (azDequote == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			char *pSpace = (char *)&azDequote[argc];
			for (i = 0; i<argc; i++) {
				int n = (int)strlen(argv[i]);
				azDequote[i] = pSpace;
				memcpy(pSpace, argv[i], n + 1);
				sqlite3Fts3Dequote(pSpace);
				pSpace += (n + 1);
			}
		}
	}

	return rc;
}


#define FTS3_TOK_SCHEMA "CREATE TABLE x(input, token, start, end, position)"


static int fts3tokConnectMethod(
	sqlite3 *db,                    
	void *pHash,                    
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	Fts3tokTable *pTab = 0;
	const sqlite3_tokenizer_module *pMod = 0;
	sqlite3_tokenizer *pTok = 0;
	int rc;
	char **azDequote = 0;
	int nDequote;

	rc = sqlite3_declare_vtab(db, FTS3_TOK_SCHEMA);
	if (rc != SQLITE_OK) return rc;

	nDequote = argc - 3;
	rc = fts3tokDequoteArray(nDequote, &argv[3], &azDequote);

	if (rc == SQLITE_OK) {
		const char *zModule;
		if (nDequote<1) {
			zModule = "simple";
		}
		else {
			zModule = azDequote[0];
		}
		rc = fts3tokQueryTokenizer((Fts3Hash*)pHash, zModule, &pMod, pzErr);
	}

	assert((rc == SQLITE_OK) == (pMod != 0));
	if (rc == SQLITE_OK) {
		const char * const *azArg = (const char * const *)&azDequote[1];
		rc = pMod->xCreate((nDequote>1 ? nDequote - 1 : 0), azArg, &pTok);
	}

	if (rc == SQLITE_OK) {
		pTab = (Fts3tokTable *)sqlite3_malloc(sizeof(Fts3tokTable));
		if (pTab == 0) {
			rc = SQLITE_NOMEM;
		}
	}

	if (rc == SQLITE_OK) {
		memset(pTab, 0, sizeof(Fts3tokTable));
		pTab->pMod = pMod;
		pTab->pTok = pTok;
		*ppVtab = &pTab->base;
	}
	else {
		if (pTok) {
			pMod->xDestroy(pTok);
		}
	}

	sqlite3_free(azDequote);
	return rc;
}


static int fts3tokDisconnectMethod(sqlite3_vtab *pVtab) {
	Fts3tokTable *pTab = (Fts3tokTable *)pVtab;

	pTab->pMod->xDestroy(pTab->pTok);
	sqlite3_free(pTab);
	return SQLITE_OK;
}


static int fts3tokBestIndexMethod(
	sqlite3_vtab *pVTab,
	sqlite3_index_info *pInfo
) {
	int i;
	UNUSED_PARAMETER(pVTab);

	for (i = 0; i<pInfo->nConstraint; i++) {
		if (pInfo->aConstraint[i].usable
			&& pInfo->aConstraint[i].iColumn == 0
			&& pInfo->aConstraint[i].op == SQLITE_INDEX_CONSTRAINT_EQ
			) {
			pInfo->idxNum = 1;
			pInfo->aConstraintUsage[i].argvIndex = 1;
			pInfo->aConstraintUsage[i].omit = 1;
			pInfo->estimatedCost = 1;
			return SQLITE_OK;
		}
	}

	pInfo->idxNum = 0;
	assert(pInfo->estimatedCost>1000000.0);

	return SQLITE_OK;
}


static int fts3tokOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr) {
	Fts3tokCursor *pCsr;
	UNUSED_PARAMETER(pVTab);

	pCsr = (Fts3tokCursor *)sqlite3_malloc(sizeof(Fts3tokCursor));
	if (pCsr == 0) {
		return SQLITE_NOMEM;
	}
	memset(pCsr, 0, sizeof(Fts3tokCursor));

	*ppCsr = (sqlite3_vtab_cursor *)pCsr;
	return SQLITE_OK;
}


static void fts3tokResetCursor(Fts3tokCursor *pCsr) {
	if (pCsr->pCsr) {
		Fts3tokTable *pTab = (Fts3tokTable *)(pCsr->base.pVtab);
		pTab->pMod->xClose(pCsr->pCsr);
		pCsr->pCsr = 0;
	}
	sqlite3_free(pCsr->zInput);
	pCsr->zInput = 0;
	pCsr->zToken = 0;
	pCsr->nToken = 0;
	pCsr->iStart = 0;
	pCsr->iEnd = 0;
	pCsr->iPos = 0;
	pCsr->iRowid = 0;
}


static int fts3tokCloseMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;

	fts3tokResetCursor(pCsr);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}


static int fts3tokNextMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;
	Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);
	int rc;                         

	pCsr->iRowid++;
	rc = pTab->pMod->xNext(pCsr->pCsr,
		&pCsr->zToken, &pCsr->nToken,
		&pCsr->iStart, &pCsr->iEnd, &pCsr->iPos
	);

	if (rc != SQLITE_OK) {
		fts3tokResetCursor(pCsr);
		if (rc == SQLITE_DONE) rc = SQLITE_OK;
	}

	return rc;
}


static int fts3tokFilterMethod(
	sqlite3_vtab_cursor *pCursor,   
	int idxNum,                     
	const char *idxStr,             
	int nVal,                       
	sqlite3_value **apVal           
) {
	int rc = SQLITE_ERROR;
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;
	Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);
	UNUSED_PARAMETER(idxStr);
	UNUSED_PARAMETER(nVal);

	fts3tokResetCursor(pCsr);
	if (idxNum == 1) {
		const char *zByte = (const char *)sqlite3_value_text(apVal[0]);
		int nByte = sqlite3_value_bytes(apVal[0]);
		pCsr->zInput = sqlite3_malloc(nByte + 1);
		if (pCsr->zInput == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			memcpy(pCsr->zInput, zByte, nByte);
			pCsr->zInput[nByte] = 0;
			rc = pTab->pMod->xOpen(pTab->pTok, pCsr->zInput, nByte, &pCsr->pCsr);
			if (rc == SQLITE_OK) {
				pCsr->pCsr->pTokenizer = pTab->pTok;
			}
		}
	}

	if (rc != SQLITE_OK) return rc;
	return fts3tokNextMethod(pCursor);
}


static int fts3tokEofMethod(sqlite3_vtab_cursor *pCursor) {
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;
	return (pCsr->zToken == 0);
}


static int fts3tokColumnMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite3_context *pCtx,          
	int iCol                        
) {
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;

	
	switch (iCol) {
	case 0:
		sqlite3_result_text(pCtx, pCsr->zInput, -1, SQLITE_TRANSIENT);
		break;
	case 1:
		sqlite3_result_text(pCtx, pCsr->zToken, pCsr->nToken, SQLITE_TRANSIENT);
		break;
	case 2:
		sqlite3_result_int(pCtx, pCsr->iStart);
		break;
	case 3:
		sqlite3_result_int(pCtx, pCsr->iEnd);
		break;
	default:
		assert(iCol == 4);
		sqlite3_result_int(pCtx, pCsr->iPos);
		break;
	}
	return SQLITE_OK;
}


static int fts3tokRowidMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite_int64 *pRowid            
) {
	Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;
	*pRowid = (sqlite3_int64)pCsr->iRowid;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3InitTok(sqlite3 *db, Fts3Hash *pHash) {
	static const sqlite3_module fts3tok_module = {
		0,                           
		fts3tokConnectMethod,        
		fts3tokConnectMethod,        
		fts3tokBestIndexMethod,      
		fts3tokDisconnectMethod,     
		fts3tokDisconnectMethod,     
		fts3tokOpenMethod,           
		fts3tokCloseMethod,          
		fts3tokFilterMethod,         
		fts3tokNextMethod,           
		fts3tokEofMethod,            
		fts3tokColumnMethod,         
		fts3tokRowidMethod,          
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0,                           
		0                            
	};
	int rc;                         

	rc = sqlite3_create_module(db, "fts3tokenize", &fts3tok_module, (void*)pHash);
	return rc;
}

#endif 






#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)






#define FTS_MAX_APPENDABLE_HEIGHT 16


#define FTS3_NODE_PADDING (FTS3_VARINT_MAX*2)


#ifdef SQLITE_TEST
int test_fts3_node_chunksize = (4 * 1024);
int test_fts3_node_chunk_threshold = (4 * 1024) * 4;
# define FTS3_NODE_CHUNKSIZE       test_fts3_node_chunksize
# define FTS3_NODE_CHUNK_THRESHOLD test_fts3_node_chunk_threshold
#else
# define FTS3_NODE_CHUNKSIZE (4*1024) 
# define FTS3_NODE_CHUNK_THRESHOLD (FTS3_NODE_CHUNKSIZE*4)
#endif


#define FTS_STAT_DOCTOTAL      0
#define FTS_STAT_INCRMERGEHINT 1
#define FTS_STAT_AUTOINCRMERGE 2


#ifdef FTS3_LOG_MERGES
static void fts3LogMerge(int nMerge, sqlite3_int64 iAbsLevel) {
	sqlite3_log(SQLITE_OK, "%d-way merge from level %d", nMerge, (int)iAbsLevel);
}
#else
#define fts3LogMerge(x, y)
#endif


typedef struct PendingList PendingList;
typedef struct SegmentNode SegmentNode;
typedef struct SegmentWriter SegmentWriter;


struct PendingList {
	int nData;
	char *aData;
	int nSpace;
	sqlite3_int64 iLastDocid;
	sqlite3_int64 iLastCol;
	sqlite3_int64 iLastPos;
};



struct Fts3DeferredToken {
	Fts3PhraseToken *pToken;        
	int iCol;                       
	Fts3DeferredToken *pNext;       
	PendingList *pList;             
};


struct Fts3SegReader {
	int iIdx;                       
	u8 bLookup;                     
	u8 rootOnly;                    

	sqlite3_int64 iStartBlock;      
	sqlite3_int64 iLeafEndBlock;    
	sqlite3_int64 iEndBlock;        
	sqlite3_int64 iCurrentBlock;    

	char *aNode;                    
	int nNode;                      
	int nPopulate;                  
	sqlite3_blob *pBlob;            

	Fts3HashElem **ppNextElem;

	
	int nTerm;                      
	char *zTerm;                    
	int nTermAlloc;                 
	char *aDoclist;                 
	int nDoclist;                   

									
	char *pOffsetList;
	int nOffsetList;                
	sqlite3_int64 iDocid;
};

#define fts3SegReaderIsPending(p) ((p)->ppNextElem!=0)
#define fts3SegReaderIsRootOnly(p) ((p)->rootOnly!=0)


struct SegmentWriter {
	SegmentNode *pTree;             
	sqlite3_int64 iFirst;           
	sqlite3_int64 iFree;            
	char *zTerm;                    
	int nTerm;                      
	int nMalloc;                    
	char *zMalloc;                  
	int nSize;                      
	int nData;                      
	char *aData;                    
	i64 nLeafData;                  
};


struct SegmentNode {
	SegmentNode *pParent;           
	SegmentNode *pRight;            
	SegmentNode *pLeftmost;         
	int nEntry;                     
	char *zTerm;                    
	int nTerm;                      
	int nMalloc;                    
	char *zMalloc;                  
	int nData;                      
	char *aData;                    
};


#define SQL_DELETE_CONTENT             0
#define SQL_IS_EMPTY                   1
#define SQL_DELETE_ALL_CONTENT         2 
#define SQL_DELETE_ALL_SEGMENTS        3
#define SQL_DELETE_ALL_SEGDIR          4
#define SQL_DELETE_ALL_DOCSIZE         5
#define SQL_DELETE_ALL_STAT            6
#define SQL_SELECT_CONTENT_BY_ROWID    7
#define SQL_NEXT_SEGMENT_INDEX         8
#define SQL_INSERT_SEGMENTS            9
#define SQL_NEXT_SEGMENTS_ID          10
#define SQL_INSERT_SEGDIR             11
#define SQL_SELECT_LEVEL              12
#define SQL_SELECT_LEVEL_RANGE        13
#define SQL_SELECT_LEVEL_COUNT        14
#define SQL_SELECT_SEGDIR_MAX_LEVEL   15
#define SQL_DELETE_SEGDIR_LEVEL       16
#define SQL_DELETE_SEGMENTS_RANGE     17
#define SQL_CONTENT_INSERT            18
#define SQL_DELETE_DOCSIZE            19
#define SQL_REPLACE_DOCSIZE           20
#define SQL_SELECT_DOCSIZE            21
#define SQL_SELECT_STAT               22
#define SQL_REPLACE_STAT              23

#define SQL_SELECT_ALL_PREFIX_LEVEL   24
#define SQL_DELETE_ALL_TERMS_SEGDIR   25
#define SQL_DELETE_SEGDIR_RANGE       26
#define SQL_SELECT_ALL_LANGID         27
#define SQL_FIND_MERGE_LEVEL          28
#define SQL_MAX_LEAF_NODE_ESTIMATE    29
#define SQL_DELETE_SEGDIR_ENTRY       30
#define SQL_SHIFT_SEGDIR_ENTRY        31
#define SQL_SELECT_SEGDIR             32
#define SQL_CHOMP_SEGDIR              33
#define SQL_SEGMENT_IS_APPENDABLE     34
#define SQL_SELECT_INDEXES            35
#define SQL_SELECT_MXLEVEL            36

#define SQL_SELECT_LEVEL_RANGE2       37
#define SQL_UPDATE_LEVEL_IDX          38
#define SQL_UPDATE_LEVEL              39


static int fts3SqlStmt(
	Fts3Table *p,                   
	int eStmt,                      
	sqlite3_stmt **pp,              
	sqlite3_value **apVal           
) {
	const char *azSql[] = {
		  "DELETE FROM %Q.'%q_content' WHERE rowid = ?",
		  "SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)",
		  "DELETE FROM %Q.'%q_content'",
		  "DELETE FROM %Q.'%q_segments'",
		  "DELETE FROM %Q.'%q_segdir'",
		  "DELETE FROM %Q.'%q_docsize'",
		  "DELETE FROM %Q.'%q_stat'",
		  "SELECT %s WHERE rowid=?",
		  "SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1",
		  "REPLACE INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)",
		  "SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)",
		  "REPLACE INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)",

		
		  "SELECT idx, start_block, leaves_end_block, end_block, root "
		"FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC",
		  "SELECT idx, start_block, leaves_end_block, end_block, root "
		"FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?"
		"ORDER BY level DESC, idx ASC",

		  "SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?",
		  "SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",

		  "DELETE FROM %Q.'%q_segdir' WHERE level = ?",
		  "DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?",
		  "INSERT INTO %Q.'%q_content' VALUES(%s)",
		  "DELETE FROM %Q.'%q_docsize' WHERE docid = ?",
		  "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",
		  "SELECT size FROM %Q.'%q_docsize' WHERE docid=?",
		  "SELECT value FROM %Q.'%q_stat' WHERE id=?",
		  "REPLACE INTO %Q.'%q_stat' VALUES(?,?)",
		  "",
		  "",

		 "DELETE FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",
		 "SELECT ? UNION SELECT level / (1024 * ?) FROM %Q.'%q_segdir'",

		
		 "SELECT level, count(*) AS cnt FROM %Q.'%q_segdir' "
		"  GROUP BY level HAVING cnt>=?"
		"  ORDER BY (level %% 1024) ASC LIMIT 1",

		
		 "SELECT 2 * total(1 + leaves_end_block - start_block) "
		"  FROM %Q.'%q_segdir' WHERE level = ? AND idx < ?",

		
		 "DELETE FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",

		
		 "UPDATE %Q.'%q_segdir' SET idx = ? WHERE level=? AND idx=?",

		
		  "SELECT idx, start_block, leaves_end_block, end_block, root "
		"FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",

		
		  "UPDATE %Q.'%q_segdir' SET start_block = ?, root = ?"
		"WHERE level = ? AND idx = ?",

		
		  "SELECT 1 FROM %Q.'%q_segments' WHERE blockid=? AND block IS NULL",

		
		  "SELECT idx FROM %Q.'%q_segdir' WHERE level=? ORDER BY 1 ASC",

		
		  "SELECT max( level %% 1024 ) FROM %Q.'%q_segdir'",

		
		  "SELECT level, idx, end_block "
		"FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ? "
		"ORDER BY level DESC, idx ASC",

		
		  "UPDATE OR FAIL %Q.'%q_segdir' SET level=-1,idx=? "
		"WHERE level=? AND idx=?",
		  "UPDATE OR FAIL %Q.'%q_segdir' SET level=? WHERE level=-1"

	};
	int rc = SQLITE_OK;
	sqlite3_stmt *pStmt;

	assert(SizeofArray(azSql) == SizeofArray(p->aStmt));
	assert(eStmt<SizeofArray(azSql) && eStmt >= 0);

	pStmt = p->aStmt[eStmt];
	if (!pStmt) {
		char *zSql;
		if (eStmt == SQL_CONTENT_INSERT) {
			zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName, p->zWriteExprlist);
		}
		else if (eStmt == SQL_SELECT_CONTENT_BY_ROWID) {
			zSql = sqlite3_mprintf(azSql[eStmt], p->zReadExprlist);
		}
		else {
			zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName);
		}
		if (!zSql) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, NULL);
			sqlite3_free(zSql);
			assert(rc == SQLITE_OK || pStmt == 0);
			p->aStmt[eStmt] = pStmt;
		}
	}
	if (apVal) {
		int i;
		int nParam = sqlite3_bind_parameter_count(pStmt);
		for (i = 0; rc == SQLITE_OK && i<nParam; i++) {
			rc = sqlite3_bind_value(pStmt, i + 1, apVal[i]);
		}
	}
	*pp = pStmt;
	return rc;
}


static int fts3SelectDocsize(
	Fts3Table *pTab,                
	sqlite3_int64 iDocid,           
	sqlite3_stmt **ppStmt           
) {
	sqlite3_stmt *pStmt = 0;        
	int rc;                         

	rc = fts3SqlStmt(pTab, SQL_SELECT_DOCSIZE, &pStmt, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pStmt, 1, iDocid);
		rc = sqlite3_step(pStmt);
		if (rc != SQLITE_ROW || sqlite3_column_type(pStmt, 0) != SQLITE_BLOB) {
			rc = sqlite3_reset(pStmt);
			if (rc == SQLITE_OK) rc = FTS_CORRUPT_VTAB;
			pStmt = 0;
		}
		else {
			rc = SQLITE_OK;
		}
	}

	*ppStmt = pStmt;
	return rc;
}

SQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(
	Fts3Table *pTab,                
	sqlite3_stmt **ppStmt           
) {
	sqlite3_stmt *pStmt = 0;
	int rc;
	rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
		if (sqlite3_step(pStmt) != SQLITE_ROW
			|| sqlite3_column_type(pStmt, 0) != SQLITE_BLOB
			) {
			rc = sqlite3_reset(pStmt);
			if (rc == SQLITE_OK) rc = FTS_CORRUPT_VTAB;
			pStmt = 0;
		}
	}
	*ppStmt = pStmt;
	return rc;
}

SQLITE_PRIVATE int sqlite3Fts3SelectDocsize(
	Fts3Table *pTab,                
	sqlite3_int64 iDocid,           
	sqlite3_stmt **ppStmt           
) {
	return fts3SelectDocsize(pTab, iDocid, ppStmt);
}


static void fts3SqlExec(
	int *pRC,                
	Fts3Table *p,            
	int eStmt,               
	sqlite3_value **apVal    
) {
	sqlite3_stmt *pStmt;
	int rc;
	if (*pRC) return;
	rc = fts3SqlStmt(p, eStmt, &pStmt, apVal);
	if (rc == SQLITE_OK) {
		sqlite3_step(pStmt);
		rc = sqlite3_reset(pStmt);
	}
	*pRC = rc;
}



static int fts3Writelock(Fts3Table *p) {
	int rc = SQLITE_OK;

	if (p->nPendingData == 0) {
		sqlite3_stmt *pStmt;
		rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_LEVEL, &pStmt, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_null(pStmt, 1);
			sqlite3_step(pStmt);
			rc = sqlite3_reset(pStmt);
		}
	}

	return rc;
}


static sqlite3_int64 getAbsoluteLevel(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int iLevel                      
) {
	sqlite3_int64 iBase;            
	assert(iLangid >= 0);
	assert(p->nIndex>0);
	assert(iIndex >= 0 && iIndex<p->nIndex);

	iBase = ((sqlite3_int64)iLangid * p->nIndex + iIndex) * FTS3_SEGDIR_MAXLEVEL;
	return iBase + iLevel;
}


SQLITE_PRIVATE int sqlite3Fts3AllSegdirs(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int iLevel,                     
	sqlite3_stmt **ppStmt           
) {
	int rc;
	sqlite3_stmt *pStmt = 0;

	assert(iLevel == FTS3_SEGCURSOR_ALL || iLevel >= 0);
	assert(iLevel<FTS3_SEGDIR_MAXLEVEL);
	assert(iIndex >= 0 && iIndex<p->nIndex);

	if (iLevel<0) {
		
		rc = fts3SqlStmt(p, SQL_SELECT_LEVEL_RANGE, &pStmt, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
			sqlite3_bind_int64(pStmt, 2,
				getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL - 1)
			);
		}
	}
	else {
		
		rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel));
		}
	}
	*ppStmt = pStmt;
	return rc;
}



static int fts3PendingListAppendVarint(
	PendingList **pp,               
	sqlite3_int64 i                 
) {
	PendingList *p = *pp;

	
	if (!p) {
		p = sqlite3_malloc(sizeof(*p) + 100);
		if (!p) {
			return SQLITE_NOMEM;
		}
		p->nSpace = 100;
		p->aData = (char *)&p[1];
		p->nData = 0;
	}
	else if (p->nData + FTS3_VARINT_MAX + 1>p->nSpace) {
		int nNew = p->nSpace * 2;
		p = sqlite3_realloc(p, sizeof(*p) + nNew);
		if (!p) {
			sqlite3_free(*pp);
			*pp = 0;
			return SQLITE_NOMEM;
		}
		p->nSpace = nNew;
		p->aData = (char *)&p[1];
	}

	
	p->nData += sqlite3Fts3PutVarint(&p->aData[p->nData], i);
	p->aData[p->nData] = '\0';
	*pp = p;
	return SQLITE_OK;
}


static int fts3PendingListAppend(
	PendingList **pp,               
	sqlite3_int64 iDocid,           
	sqlite3_int64 iCol,             
	sqlite3_int64 iPos,             
	int *pRc                        
) {
	PendingList *p = *pp;
	int rc = SQLITE_OK;

	assert(!p || p->iLastDocid <= iDocid);

	if (!p || p->iLastDocid != iDocid) {
		sqlite3_int64 iDelta = iDocid - (p ? p->iLastDocid : 0);
		if (p) {
			assert(p->nData<p->nSpace);
			assert(p->aData[p->nData] == 0);
			p->nData++;
		}
		if (SQLITE_OK != (rc = fts3PendingListAppendVarint(&p, iDelta))) {
			goto pendinglistappend_out;
		}
		p->iLastCol = -1;
		p->iLastPos = 0;
		p->iLastDocid = iDocid;
	}
	if (iCol>0 && p->iLastCol != iCol) {
		if (SQLITE_OK != (rc = fts3PendingListAppendVarint(&p, 1))
			|| SQLITE_OK != (rc = fts3PendingListAppendVarint(&p, iCol))
			) {
			goto pendinglistappend_out;
		}
		p->iLastCol = iCol;
		p->iLastPos = 0;
	}
	if (iCol >= 0) {
		assert(iPos>p->iLastPos || (iPos == 0 && p->iLastPos == 0));
		rc = fts3PendingListAppendVarint(&p, 2 + iPos - p->iLastPos);
		if (rc == SQLITE_OK) {
			p->iLastPos = iPos;
		}
	}

pendinglistappend_out:
	*pRc = rc;
	if (p != *pp) {
		*pp = p;
		return 1;
	}
	return 0;
}


static void fts3PendingListDelete(PendingList *pList) {
	sqlite3_free(pList);
}


static int fts3PendingTermsAddOne(
	Fts3Table *p,
	int iCol,
	int iPos,
	Fts3Hash *pHash,                
	const char *zToken,
	int nToken
) {
	PendingList *pList;
	int rc = SQLITE_OK;

	pList = (PendingList *)fts3HashFind(pHash, zToken, nToken);
	if (pList) {
		p->nPendingData -= (pList->nData + nToken + sizeof(Fts3HashElem));
	}
	if (fts3PendingListAppend(&pList, p->iPrevDocid, iCol, iPos, &rc)) {
		if (pList == fts3HashInsert(pHash, zToken, nToken, pList)) {
			
			assert(0 == fts3HashFind(pHash, zToken, nToken));
			sqlite3_free(pList);
			rc = SQLITE_NOMEM;
		}
	}
	if (rc == SQLITE_OK) {
		p->nPendingData += (pList->nData + nToken + sizeof(Fts3HashElem));
	}
	return rc;
}


static int fts3PendingTermsAdd(
	Fts3Table *p,                   
	int iLangid,                    
	const char *zText,              
	int iCol,                       
	u32 *pnWord                     
) {
	int rc;
	int iStart = 0;
	int iEnd = 0;
	int iPos = 0;
	int nWord = 0;

	char const *zToken;
	int nToken = 0;

	sqlite3_tokenizer *pTokenizer = p->pTokenizer;
	sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
	sqlite3_tokenizer_cursor *pCsr;
	int(*xNext)(sqlite3_tokenizer_cursor *pCursor,
		const char**, int*, int*, int*, int*);

	assert(pTokenizer && pModule);

	
	if (zText == 0) {
		*pnWord = 0;
		return SQLITE_OK;
	}

	rc = sqlite3Fts3OpenTokenizer(pTokenizer, iLangid, zText, -1, &pCsr);
	if (rc != SQLITE_OK) {
		return rc;
	}

	xNext = pModule->xNext;
	while (SQLITE_OK == rc
		&& SQLITE_OK == (rc = xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos))
		) {
		int i;
		if (iPos >= nWord) nWord = iPos + 1;

		
		if (iPos<0 || !zToken || nToken <= 0) {
			rc = SQLITE_ERROR;
			break;
		}

		
		rc = fts3PendingTermsAddOne(
			p, iCol, iPos, &p->aIndex[0].hPending, zToken, nToken
		);

		
		for (i = 1; rc == SQLITE_OK && i<p->nIndex; i++) {
			struct Fts3Index *pIndex = &p->aIndex[i];
			if (nToken<pIndex->nPrefix) continue;
			rc = fts3PendingTermsAddOne(
				p, iCol, iPos, &pIndex->hPending, zToken, pIndex->nPrefix
			);
		}
	}

	pModule->xClose(pCsr);
	*pnWord += nWord;
	return (rc == SQLITE_DONE ? SQLITE_OK : rc);
}


static int fts3PendingTermsDocid(
	Fts3Table *p,                   
	int bDelete,                    
	int iLangid,                    
	sqlite_int64 iDocid             
) {
	assert(iLangid >= 0);
	assert(bDelete == 1 || bDelete == 0);

	
	if (iDocid<p->iPrevDocid
		|| (iDocid == p->iPrevDocid && p->bPrevDelete == 0)
		|| p->iPrevLangid != iLangid
		|| p->nPendingData>p->nMaxPendingData
		) {
		int rc = sqlite3Fts3PendingTermsFlush(p);
		if (rc != SQLITE_OK) return rc;
	}
	p->iPrevDocid = iDocid;
	p->iPrevLangid = iLangid;
	p->bPrevDelete = bDelete;
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *p) {
	int i;
	for (i = 0; i<p->nIndex; i++) {
		Fts3HashElem *pElem;
		Fts3Hash *pHash = &p->aIndex[i].hPending;
		for (pElem = fts3HashFirst(pHash); pElem; pElem = fts3HashNext(pElem)) {
			PendingList *pList = (PendingList *)fts3HashData(pElem);
			fts3PendingListDelete(pList);
		}
		fts3HashClear(pHash);
	}
	p->nPendingData = 0;
}


static int fts3InsertTerms(
	Fts3Table *p,
	int iLangid,
	sqlite3_value **apVal,
	u32 *aSz
) {
	int i;                          
	for (i = 2; i<p->nColumn + 2; i++) {
		int iCol = i - 2;
		if (p->abNotindexed[iCol] == 0) {
			const char *zText = (const char *)sqlite3_value_text(apVal[i]);
			int rc = fts3PendingTermsAdd(p, iLangid, zText, iCol, &aSz[iCol]);
			if (rc != SQLITE_OK) {
				return rc;
			}
			aSz[p->nColumn] += sqlite3_value_bytes(apVal[i]);
		}
	}
	return SQLITE_OK;
}


static int fts3InsertData(
	Fts3Table *p,                   
	sqlite3_value **apVal,          
	sqlite3_int64 *piDocid          
) {
	int rc;                         
	sqlite3_stmt *pContentInsert;   

	if (p->zContentTbl) {
		sqlite3_value *pRowid = apVal[p->nColumn + 3];
		if (sqlite3_value_type(pRowid) == SQLITE_NULL) {
			pRowid = apVal[1];
		}
		if (sqlite3_value_type(pRowid) != SQLITE_INTEGER) {
			return SQLITE_CONSTRAINT;
		}
		*piDocid = sqlite3_value_int64(pRowid);
		return SQLITE_OK;
	}

	
	rc = fts3SqlStmt(p, SQL_CONTENT_INSERT, &pContentInsert, &apVal[1]);
	if (rc == SQLITE_OK && p->zLanguageid) {
		rc = sqlite3_bind_int(
			pContentInsert, p->nColumn + 2,
			sqlite3_value_int(apVal[p->nColumn + 4])
		);
	}
	if (rc != SQLITE_OK) return rc;

	
	if (SQLITE_NULL != sqlite3_value_type(apVal[3 + p->nColumn])) {
		if (SQLITE_NULL == sqlite3_value_type(apVal[0])
			&& SQLITE_NULL != sqlite3_value_type(apVal[1])
			) {
			
			return SQLITE_ERROR;
		}
		rc = sqlite3_bind_value(pContentInsert, 1, apVal[3 + p->nColumn]);
		if (rc != SQLITE_OK) return rc;
	}

	
	sqlite3_step(pContentInsert);
	rc = sqlite3_reset(pContentInsert);

	*piDocid = sqlite3_last_insert_rowid(p->db);
	return rc;
}




static int fts3DeleteAll(Fts3Table *p, int bContent) {
	int rc = SQLITE_OK;             

									
	sqlite3Fts3PendingTermsClear(p);

	
	assert(p->zContentTbl == 0 || bContent == 0);
	if (bContent) fts3SqlExec(&rc, p, SQL_DELETE_ALL_CONTENT, 0);
	fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGMENTS, 0);
	fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGDIR, 0);
	if (p->bHasDocsize) {
		fts3SqlExec(&rc, p, SQL_DELETE_ALL_DOCSIZE, 0);
	}
	if (p->bHasStat) {
		fts3SqlExec(&rc, p, SQL_DELETE_ALL_STAT, 0);
	}
	return rc;
}


static int langidFromSelect(Fts3Table *p, sqlite3_stmt *pSelect) {
	int iLangid = 0;
	if (p->zLanguageid) iLangid = sqlite3_column_int(pSelect, p->nColumn + 1);
	return iLangid;
}


static void fts3DeleteTerms(
	int *pRC,               
	Fts3Table *p,           
	sqlite3_value *pRowid,  
	u32 *aSz,               
	int *pbFound            
) {
	int rc;
	sqlite3_stmt *pSelect;

	assert(*pbFound == 0);
	if (*pRC) return;
	rc = fts3SqlStmt(p, SQL_SELECT_CONTENT_BY_ROWID, &pSelect, &pRowid);
	if (rc == SQLITE_OK) {
		if (SQLITE_ROW == sqlite3_step(pSelect)) {
			int i;
			int iLangid = langidFromSelect(p, pSelect);
			i64 iDocid = sqlite3_column_int64(pSelect, 0);
			rc = fts3PendingTermsDocid(p, 1, iLangid, iDocid);
			for (i = 1; rc == SQLITE_OK && i <= p->nColumn; i++) {
				int iCol = i - 1;
				if (p->abNotindexed[iCol] == 0) {
					const char *zText = (const char *)sqlite3_column_text(pSelect, i);
					rc = fts3PendingTermsAdd(p, iLangid, zText, -1, &aSz[iCol]);
					aSz[p->nColumn] += sqlite3_column_bytes(pSelect, i);
				}
			}
			if (rc != SQLITE_OK) {
				sqlite3_reset(pSelect);
				*pRC = rc;
				return;
			}
			*pbFound = 1;
		}
		rc = sqlite3_reset(pSelect);
	}
	else {
		sqlite3_reset(pSelect);
	}
	*pRC = rc;
}


static int fts3SegmentMerge(Fts3Table *, int, int, int);


static int fts3AllocateSegdirIdx(
	Fts3Table *p,
	int iLangid,                    
	int iIndex,                     
	int iLevel,
	int *piIdx
) {
	int rc;                         
	sqlite3_stmt *pNextIdx;         
	int iNext = 0;                  

	assert(iLangid >= 0);
	assert(p->nIndex >= 1);

	
	rc = fts3SqlStmt(p, SQL_NEXT_SEGMENT_INDEX, &pNextIdx, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(
			pNextIdx, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel)
		);
		if (SQLITE_ROW == sqlite3_step(pNextIdx)) {
			iNext = sqlite3_column_int(pNextIdx, 0);
		}
		rc = sqlite3_reset(pNextIdx);
	}

	if (rc == SQLITE_OK) {
		
		if (iNext >= FTS3_MERGE_COUNT) {
			fts3LogMerge(16, getAbsoluteLevel(p, iLangid, iIndex, iLevel));
			rc = fts3SegmentMerge(p, iLangid, iIndex, iLevel);
			*piIdx = 0;
		}
		else {
			*piIdx = iNext;
		}
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3ReadBlock(
	Fts3Table *p,                   
	sqlite3_int64 iBlockid,         
	char **paBlob,                  
	int *pnBlob,                    
	int *pnLoad                     
) {
	int rc;                         

									
	assert(pnBlob);

	if (p->pSegments) {
		rc = sqlite3_blob_reopen(p->pSegments, iBlockid);
	}
	else {
		if (0 == p->zSegmentsTbl) {
			p->zSegmentsTbl = sqlite3_mprintf("%s_segments", p->zName);
			if (0 == p->zSegmentsTbl) return SQLITE_NOMEM;
		}
		rc = sqlite3_blob_open(
			p->db, p->zDb, p->zSegmentsTbl, "block", iBlockid, 0, &p->pSegments
		);
	}

	if (rc == SQLITE_OK) {
		int nByte = sqlite3_blob_bytes(p->pSegments);
		*pnBlob = nByte;
		if (paBlob) {
			char *aByte = sqlite3_malloc(nByte + FTS3_NODE_PADDING);
			if (!aByte) {
				rc = SQLITE_NOMEM;
			}
			else {
				if (pnLoad && nByte>(FTS3_NODE_CHUNK_THRESHOLD)) {
					nByte = FTS3_NODE_CHUNKSIZE;
					*pnLoad = nByte;
				}
				rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);
				memset(&aByte[nByte], 0, FTS3_NODE_PADDING);
				if (rc != SQLITE_OK) {
					sqlite3_free(aByte);
					aByte = 0;
				}
			}
			*paBlob = aByte;
		}
	}

	return rc;
}


SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p) {
	sqlite3_blob_close(p->pSegments);
	p->pSegments = 0;
}

static int fts3SegReaderIncrRead(Fts3SegReader *pReader) {
	int nRead;                      
	int rc;                         

	nRead = MIN(pReader->nNode - pReader->nPopulate, FTS3_NODE_CHUNKSIZE);
	rc = sqlite3_blob_read(
		pReader->pBlob,
		&pReader->aNode[pReader->nPopulate],
		nRead,
		pReader->nPopulate
	);

	if (rc == SQLITE_OK) {
		pReader->nPopulate += nRead;
		memset(&pReader->aNode[pReader->nPopulate], 0, FTS3_NODE_PADDING);
		if (pReader->nPopulate == pReader->nNode) {
			sqlite3_blob_close(pReader->pBlob);
			pReader->pBlob = 0;
			pReader->nPopulate = 0;
		}
	}
	return rc;
}

static int fts3SegReaderRequire(Fts3SegReader *pReader, char *pFrom, int nByte) {
	int rc = SQLITE_OK;
	assert(!pReader->pBlob
		|| (pFrom >= pReader->aNode && pFrom<&pReader->aNode[pReader->nNode])
	);
	while (pReader->pBlob && rc == SQLITE_OK
		&& (pFrom - pReader->aNode + nByte)>pReader->nPopulate
		) {
		rc = fts3SegReaderIncrRead(pReader);
	}
	return rc;
}


static void fts3SegReaderSetEof(Fts3SegReader *pSeg) {
	if (!fts3SegReaderIsRootOnly(pSeg)) {
		sqlite3_free(pSeg->aNode);
		sqlite3_blob_close(pSeg->pBlob);
		pSeg->pBlob = 0;
	}
	pSeg->aNode = 0;
}


static int fts3SegReaderNext(
	Fts3Table *p,
	Fts3SegReader *pReader,
	int bIncr
) {
	int rc;                         
	char *pNext;                    
	int nPrefix;                    
	int nSuffix;                    

	if (!pReader->aDoclist) {
		pNext = pReader->aNode;
	}
	else {
		pNext = &pReader->aDoclist[pReader->nDoclist];
	}

	if (!pNext || pNext >= &pReader->aNode[pReader->nNode]) {

		if (fts3SegReaderIsPending(pReader)) {
			Fts3HashElem *pElem = *(pReader->ppNextElem);
			sqlite3_free(pReader->aNode);
			pReader->aNode = 0;
			if (pElem) {
				char *aCopy;
				PendingList *pList = (PendingList *)fts3HashData(pElem);
				int nCopy = pList->nData + 1;
				pReader->zTerm = (char *)fts3HashKey(pElem);
				pReader->nTerm = fts3HashKeysize(pElem);
				aCopy = (char*)sqlite3_malloc(nCopy);
				if (!aCopy) return SQLITE_NOMEM;
				memcpy(aCopy, pList->aData, nCopy);
				pReader->nNode = pReader->nDoclist = nCopy;
				pReader->aNode = pReader->aDoclist = aCopy;
				pReader->ppNextElem++;
				assert(pReader->aNode);
			}
			return SQLITE_OK;
		}

		fts3SegReaderSetEof(pReader);

		
		assert(pReader->iCurrentBlock <= pReader->iLeafEndBlock);
		if (pReader->iCurrentBlock >= pReader->iLeafEndBlock) {
			return SQLITE_OK;
		}

		rc = sqlite3Fts3ReadBlock(
			p, ++pReader->iCurrentBlock, &pReader->aNode, &pReader->nNode,
			(bIncr ? &pReader->nPopulate : 0)
		);
		if (rc != SQLITE_OK) return rc;
		assert(pReader->pBlob == 0);
		if (bIncr && pReader->nPopulate<pReader->nNode) {
			pReader->pBlob = p->pSegments;
			p->pSegments = 0;
		}
		pNext = pReader->aNode;
	}

	assert(!fts3SegReaderIsPending(pReader));

	rc = fts3SegReaderRequire(pReader, pNext, FTS3_VARINT_MAX * 2);
	if (rc != SQLITE_OK) return rc;

	
	pNext += fts3GetVarint32(pNext, &nPrefix);
	pNext += fts3GetVarint32(pNext, &nSuffix);
	if (nPrefix<0 || nSuffix <= 0
		|| &pNext[nSuffix]>&pReader->aNode[pReader->nNode]
		) {
		return FTS_CORRUPT_VTAB;
	}

	if (nPrefix + nSuffix>pReader->nTermAlloc) {
		int nNew = (nPrefix + nSuffix) * 2;
		char *zNew = sqlite3_realloc(pReader->zTerm, nNew);
		if (!zNew) {
			return SQLITE_NOMEM;
		}
		pReader->zTerm = zNew;
		pReader->nTermAlloc = nNew;
	}

	rc = fts3SegReaderRequire(pReader, pNext, nSuffix + FTS3_VARINT_MAX);
	if (rc != SQLITE_OK) return rc;

	memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);
	pReader->nTerm = nPrefix + nSuffix;
	pNext += nSuffix;
	pNext += fts3GetVarint32(pNext, &pReader->nDoclist);
	pReader->aDoclist = pNext;
	pReader->pOffsetList = 0;

	
	if (&pReader->aDoclist[pReader->nDoclist]>&pReader->aNode[pReader->nNode]
		|| (pReader->nPopulate == 0 && pReader->aDoclist[pReader->nDoclist - 1])
		) {
		return FTS_CORRUPT_VTAB;
	}
	return SQLITE_OK;
}


static int fts3SegReaderFirstDocid(Fts3Table *pTab, Fts3SegReader *pReader) {
	int rc = SQLITE_OK;
	assert(pReader->aDoclist);
	assert(!pReader->pOffsetList);
	if (pTab->bDescIdx && fts3SegReaderIsPending(pReader)) {
		u8 bEof = 0;
		pReader->iDocid = 0;
		pReader->nOffsetList = 0;
		sqlite3Fts3DoclistPrev(0,
			pReader->aDoclist, pReader->nDoclist, &pReader->pOffsetList,
			&pReader->iDocid, &pReader->nOffsetList, &bEof
		);
	}
	else {
		rc = fts3SegReaderRequire(pReader, pReader->aDoclist, FTS3_VARINT_MAX);
		if (rc == SQLITE_OK) {
			int n = sqlite3Fts3GetVarint(pReader->aDoclist, &pReader->iDocid);
			pReader->pOffsetList = &pReader->aDoclist[n];
		}
	}
	return rc;
}


static int fts3SegReaderNextDocid(
	Fts3Table *pTab,
	Fts3SegReader *pReader,         
	char **ppOffsetList,            
	int *pnOffsetList               
) {
	int rc = SQLITE_OK;
	char *p = pReader->pOffsetList;
	char c = 0;

	assert(p);

	if (pTab->bDescIdx && fts3SegReaderIsPending(pReader)) {
		
		u8 bEof = 0;
		if (ppOffsetList) {
			*ppOffsetList = pReader->pOffsetList;
			*pnOffsetList = pReader->nOffsetList - 1;
		}
		sqlite3Fts3DoclistPrev(0,
			pReader->aDoclist, pReader->nDoclist, &p, &pReader->iDocid,
			&pReader->nOffsetList, &bEof
		);
		if (bEof) {
			pReader->pOffsetList = 0;
		}
		else {
			pReader->pOffsetList = p;
		}
	}
	else {
		char *pEnd = &pReader->aDoclist[pReader->nDoclist];

		
		while (1) {

			
			while (*p | c) c = *p++ & 0x80;
			assert(*p == 0);

			if (pReader->pBlob == 0 || p<&pReader->aNode[pReader->nPopulate]) break;
			rc = fts3SegReaderIncrRead(pReader);
			if (rc != SQLITE_OK) return rc;
		}
		p++;

		
		if (ppOffsetList) {
			*ppOffsetList = pReader->pOffsetList;
			*pnOffsetList = (int)(p - pReader->pOffsetList - 1);
		}

		
		while (p<pEnd && *p == 0) p++;

		
		if (p >= pEnd) {
			pReader->pOffsetList = 0;
		}
		else {
			rc = fts3SegReaderRequire(pReader, p, FTS3_VARINT_MAX);
			if (rc == SQLITE_OK) {
				sqlite3_int64 iDelta;
				pReader->pOffsetList = p + sqlite3Fts3GetVarint(p, &iDelta);
				if (pTab->bDescIdx) {
					pReader->iDocid -= iDelta;
				}
				else {
					pReader->iDocid += iDelta;
				}
			}
		}
	}

	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3MsrOvfl(
	Fts3Cursor *pCsr,
	Fts3MultiSegReader *pMsr,
	int *pnOvfl
) {
	Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
	int nOvfl = 0;
	int ii;
	int rc = SQLITE_OK;
	int pgsz = p->nPgsz;

	assert(p->bFts4);
	assert(pgsz>0);

	for (ii = 0; rc == SQLITE_OK && ii<pMsr->nSegment; ii++) {
		Fts3SegReader *pReader = pMsr->apSegment[ii];
		if (!fts3SegReaderIsPending(pReader)
			&& !fts3SegReaderIsRootOnly(pReader)
			) {
			sqlite3_int64 jj;
			for (jj = pReader->iStartBlock; jj <= pReader->iLeafEndBlock; jj++) {
				int nBlob;
				rc = sqlite3Fts3ReadBlock(p, jj, 0, &nBlob, 0);
				if (rc != SQLITE_OK) break;
				if ((nBlob + 35)>pgsz) {
					nOvfl += (nBlob + 34) / pgsz;
				}
			}
		}
	}
	*pnOvfl = nOvfl;
	return rc;
}


SQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader) {
	if (pReader) {
		if (!fts3SegReaderIsPending(pReader)) {
			sqlite3_free(pReader->zTerm);
		}
		if (!fts3SegReaderIsRootOnly(pReader)) {
			sqlite3_free(pReader->aNode);
		}
		sqlite3_blob_close(pReader->pBlob);
	}
	sqlite3_free(pReader);
}


SQLITE_PRIVATE int sqlite3Fts3SegReaderNew(
	int iAge,                       
	int bLookup,                    
	sqlite3_int64 iStartLeaf,       
	sqlite3_int64 iEndLeaf,         
	sqlite3_int64 iEndBlock,        
	const char *zRoot,              
	int nRoot,                      
	Fts3SegReader **ppReader        
) {
	Fts3SegReader *pReader;         
	int nExtra = 0;                 

	assert(iStartLeaf <= iEndLeaf);
	if (iStartLeaf == 0) {
		nExtra = nRoot + FTS3_NODE_PADDING;
	}

	pReader = (Fts3SegReader *)sqlite3_malloc(sizeof(Fts3SegReader) + nExtra);
	if (!pReader) {
		return SQLITE_NOMEM;
	}
	memset(pReader, 0, sizeof(Fts3SegReader));
	pReader->iIdx = iAge;
	pReader->bLookup = bLookup != 0;
	pReader->iStartBlock = iStartLeaf;
	pReader->iLeafEndBlock = iEndLeaf;
	pReader->iEndBlock = iEndBlock;

	if (nExtra) {
		
		pReader->aNode = (char *)&pReader[1];
		pReader->rootOnly = 1;
		pReader->nNode = nRoot;
		memcpy(pReader->aNode, zRoot, nRoot);
		memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);
	}
	else {
		pReader->iCurrentBlock = iStartLeaf - 1;
	}
	*ppReader = pReader;
	return SQLITE_OK;
}


static int SQLITE_CDECL fts3CompareElemByTerm(
	const void *lhs,
	const void *rhs
) {
	char *z1 = fts3HashKey(*(Fts3HashElem **)lhs);
	char *z2 = fts3HashKey(*(Fts3HashElem **)rhs);
	int n1 = fts3HashKeysize(*(Fts3HashElem **)lhs);
	int n2 = fts3HashKeysize(*(Fts3HashElem **)rhs);

	int n = (n1<n2 ? n1 : n2);
	int c = memcmp(z1, z2, n);
	if (c == 0) {
		c = n1 - n2;
	}
	return c;
}


SQLITE_PRIVATE int sqlite3Fts3SegReaderPending(
	Fts3Table *p,                   
	int iIndex,                     
	const char *zTerm,              
	int nTerm,                      
	int bPrefix,                    
	Fts3SegReader **ppReader        
) {
	Fts3SegReader *pReader = 0;     
	Fts3HashElem *pE;               
	Fts3HashElem **aElem = 0;       
	int nElem = 0;                  
	int rc = SQLITE_OK;             
	Fts3Hash *pHash;

	pHash = &p->aIndex[iIndex].hPending;
	if (bPrefix) {
		int nAlloc = 0;               

		for (pE = fts3HashFirst(pHash); pE; pE = fts3HashNext(pE)) {
			char *zKey = (char *)fts3HashKey(pE);
			int nKey = fts3HashKeysize(pE);
			if (nTerm == 0 || (nKey >= nTerm && 0 == memcmp(zKey, zTerm, nTerm))) {
				if (nElem == nAlloc) {
					Fts3HashElem **aElem2;
					nAlloc += 16;
					aElem2 = (Fts3HashElem **)sqlite3_realloc(
						aElem, nAlloc * sizeof(Fts3HashElem *)
					);
					if (!aElem2) {
						rc = SQLITE_NOMEM;
						nElem = 0;
						break;
					}
					aElem = aElem2;
				}

				aElem[nElem++] = pE;
			}
		}

		
		if (nElem>1) {
			qsort(aElem, nElem, sizeof(Fts3HashElem *), fts3CompareElemByTerm);
		}

	}
	else {
		
		pE = fts3HashFindElem(pHash, zTerm, nTerm);
		if (pE) {
			aElem = &pE;
			nElem = 1;
		}
	}

	if (nElem>0) {
		int nByte = sizeof(Fts3SegReader) + (nElem + 1) * sizeof(Fts3HashElem *);
		pReader = (Fts3SegReader *)sqlite3_malloc(nByte);
		if (!pReader) {
			rc = SQLITE_NOMEM;
		}
		else {
			memset(pReader, 0, nByte);
			pReader->iIdx = 0x7FFFFFFF;
			pReader->ppNextElem = (Fts3HashElem **)&pReader[1];
			memcpy(pReader->ppNextElem, aElem, nElem * sizeof(Fts3HashElem *));
		}
	}

	if (bPrefix) {
		sqlite3_free(aElem);
	}
	*ppReader = pReader;
	return rc;
}


static int fts3SegReaderCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs) {
	int rc;
	if (pLhs->aNode && pRhs->aNode) {
		int rc2 = pLhs->nTerm - pRhs->nTerm;
		if (rc2<0) {
			rc = memcmp(pLhs->zTerm, pRhs->zTerm, pLhs->nTerm);
		}
		else {
			rc = memcmp(pLhs->zTerm, pRhs->zTerm, pRhs->nTerm);
		}
		if (rc == 0) {
			rc = rc2;
		}
	}
	else {
		rc = (pLhs->aNode == 0) - (pRhs->aNode == 0);
	}
	if (rc == 0) {
		rc = pRhs->iIdx - pLhs->iIdx;
	}
	assert(rc != 0);
	return rc;
}


static int fts3SegReaderDoclistCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs) {
	int rc = (pLhs->pOffsetList == 0) - (pRhs->pOffsetList == 0);
	if (rc == 0) {
		if (pLhs->iDocid == pRhs->iDocid) {
			rc = pRhs->iIdx - pLhs->iIdx;
		}
		else {
			rc = (pLhs->iDocid > pRhs->iDocid) ? 1 : -1;
		}
	}
	assert(pLhs->aNode && pRhs->aNode);
	return rc;
}
static int fts3SegReaderDoclistCmpRev(Fts3SegReader *pLhs, Fts3SegReader *pRhs) {
	int rc = (pLhs->pOffsetList == 0) - (pRhs->pOffsetList == 0);
	if (rc == 0) {
		if (pLhs->iDocid == pRhs->iDocid) {
			rc = pRhs->iIdx - pLhs->iIdx;
		}
		else {
			rc = (pLhs->iDocid < pRhs->iDocid) ? 1 : -1;
		}
	}
	assert(pLhs->aNode && pRhs->aNode);
	return rc;
}


static int fts3SegReaderTermCmp(
	Fts3SegReader *pSeg,            
	const char *zTerm,              
	int nTerm                       
) {
	int res = 0;
	if (pSeg->aNode) {
		if (pSeg->nTerm>nTerm) {
			res = memcmp(pSeg->zTerm, zTerm, nTerm);
		}
		else {
			res = memcmp(pSeg->zTerm, zTerm, pSeg->nTerm);
		}
		if (res == 0) {
			res = pSeg->nTerm - nTerm;
		}
	}
	return res;
}


static void fts3SegReaderSort(
	Fts3SegReader **apSegment,                     
	int nSegment,                                  
	int nSuspect,                                  
	int(*xCmp)(Fts3SegReader *, Fts3SegReader *)  
) {
	int i;                          

	assert(nSuspect <= nSegment);

	if (nSuspect == nSegment) nSuspect--;
	for (i = nSuspect - 1; i >= 0; i--) {
		int j;
		for (j = i; j<(nSegment - 1); j++) {
			Fts3SegReader *pTmp;
			if (xCmp(apSegment[j], apSegment[j + 1])<0) break;
			pTmp = apSegment[j + 1];
			apSegment[j + 1] = apSegment[j];
			apSegment[j] = pTmp;
		}
	}

#ifndef NDEBUG
	
	for (i = 0; i<(nSuspect - 1); i++) {
		assert(xCmp(apSegment[i], apSegment[i + 1])<0);
	}
#endif
}


static int fts3WriteSegment(
	Fts3Table *p,                   
	sqlite3_int64 iBlock,           
	char *z,                        
	int n                           
) {
	sqlite3_stmt *pStmt;
	int rc = fts3SqlStmt(p, SQL_INSERT_SEGMENTS, &pStmt, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pStmt, 1, iBlock);
		sqlite3_bind_blob(pStmt, 2, z, n, SQLITE_STATIC);
		sqlite3_step(pStmt);
		rc = sqlite3_reset(pStmt);
	}
	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3MaxLevel(Fts3Table *p, int *pnMax) {
	int rc;
	int mxLevel = 0;
	sqlite3_stmt *pStmt = 0;

	rc = fts3SqlStmt(p, SQL_SELECT_MXLEVEL, &pStmt, 0);
	if (rc == SQLITE_OK) {
		if (SQLITE_ROW == sqlite3_step(pStmt)) {
			mxLevel = sqlite3_column_int(pStmt, 0);
		}
		rc = sqlite3_reset(pStmt);
	}
	*pnMax = mxLevel;
	return rc;
}


static int fts3WriteSegdir(
	Fts3Table *p,                   
	sqlite3_int64 iLevel,           
	int iIdx,                       
	sqlite3_int64 iStartBlock,      
	sqlite3_int64 iLeafEndBlock,    
	sqlite3_int64 iEndBlock,        
	sqlite3_int64 nLeafData,        
	char *zRoot,                    
	int nRoot                       
) {
	sqlite3_stmt *pStmt;
	int rc = fts3SqlStmt(p, SQL_INSERT_SEGDIR, &pStmt, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pStmt, 1, iLevel);
		sqlite3_bind_int(pStmt, 2, iIdx);
		sqlite3_bind_int64(pStmt, 3, iStartBlock);
		sqlite3_bind_int64(pStmt, 4, iLeafEndBlock);
		if (nLeafData == 0) {
			sqlite3_bind_int64(pStmt, 5, iEndBlock);
		}
		else {
			char *zEnd = sqlite3_mprintf("%lld %lld", iEndBlock, nLeafData);
			if (!zEnd) return SQLITE_NOMEM;
			sqlite3_bind_text(pStmt, 5, zEnd, -1, sqlite3_free);
		}
		sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, SQLITE_STATIC);
		sqlite3_step(pStmt);
		rc = sqlite3_reset(pStmt);
	}
	return rc;
}


static int fts3PrefixCompress(
	const char *zPrev,              
	int nPrev,                      
	const char *zNext,              
	int nNext                       
) {
	int n;
	UNUSED_PARAMETER(nNext);
	for (n = 0; n<nPrev && zPrev[n] == zNext[n]; n++);
	return n;
}


static int fts3NodeAddTerm(
	Fts3Table *p,                   
	SegmentNode **ppTree,           
	int isCopyTerm,                 
	const char *zTerm,              
	int nTerm                       
) {
	SegmentNode *pTree = *ppTree;
	int rc;
	SegmentNode *pNew;

	
	if (pTree) {
		int nData = pTree->nData;     
		int nReq = nData;             
		int nPrefix;                  
		int nSuffix;                  

		nPrefix = fts3PrefixCompress(pTree->zTerm, pTree->nTerm, zTerm, nTerm);
		nSuffix = nTerm - nPrefix;

		nReq += sqlite3Fts3VarintLen(nPrefix) + sqlite3Fts3VarintLen(nSuffix) + nSuffix;
		if (nReq <= p->nNodeSize || !pTree->zTerm) {

			if (nReq>p->nNodeSize) {
				
				assert(pTree->aData == (char *)&pTree[1]);
				pTree->aData = (char *)sqlite3_malloc(nReq);
				if (!pTree->aData) {
					return SQLITE_NOMEM;
				}
			}

			if (pTree->zTerm) {
				
				nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nPrefix);
			}

			nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nSuffix);
			memcpy(&pTree->aData[nData], &zTerm[nPrefix], nSuffix);
			pTree->nData = nData + nSuffix;
			pTree->nEntry++;

			if (isCopyTerm) {
				if (pTree->nMalloc<nTerm) {
					char *zNew = sqlite3_realloc(pTree->zMalloc, nTerm * 2);
					if (!zNew) {
						return SQLITE_NOMEM;
					}
					pTree->nMalloc = nTerm * 2;
					pTree->zMalloc = zNew;
				}
				pTree->zTerm = pTree->zMalloc;
				memcpy(pTree->zTerm, zTerm, nTerm);
				pTree->nTerm = nTerm;
			}
			else {
				pTree->zTerm = (char *)zTerm;
				pTree->nTerm = nTerm;
			}
			return SQLITE_OK;
		}
	}

	
	pNew = (SegmentNode *)sqlite3_malloc(sizeof(SegmentNode) + p->nNodeSize);
	if (!pNew) {
		return SQLITE_NOMEM;
	}
	memset(pNew, 0, sizeof(SegmentNode));
	pNew->nData = 1 + FTS3_VARINT_MAX;
	pNew->aData = (char *)&pNew[1];

	if (pTree) {
		SegmentNode *pParent = pTree->pParent;
		rc = fts3NodeAddTerm(p, &pParent, isCopyTerm, zTerm, nTerm);
		if (pTree->pParent == 0) {
			pTree->pParent = pParent;
		}
		pTree->pRight = pNew;
		pNew->pLeftmost = pTree->pLeftmost;
		pNew->pParent = pParent;
		pNew->zMalloc = pTree->zMalloc;
		pNew->nMalloc = pTree->nMalloc;
		pTree->zMalloc = 0;
	}
	else {
		pNew->pLeftmost = pNew;
		rc = fts3NodeAddTerm(p, &pNew, isCopyTerm, zTerm, nTerm);
	}

	*ppTree = pNew;
	return rc;
}


static int fts3TreeFinishNode(
	SegmentNode *pTree,
	int iHeight,
	sqlite3_int64 iLeftChild
) {
	int nStart;
	assert(iHeight >= 1 && iHeight<128);
	nStart = FTS3_VARINT_MAX - sqlite3Fts3VarintLen(iLeftChild);
	pTree->aData[nStart] = (char)iHeight;
	sqlite3Fts3PutVarint(&pTree->aData[nStart + 1], iLeftChild);
	return nStart;
}


static int fts3NodeWrite(
	Fts3Table *p,                   
	SegmentNode *pTree,             
	int iHeight,                    
	sqlite3_int64 iLeaf,            
	sqlite3_int64 iFree,            
	sqlite3_int64 *piLast,          
	char **paRoot,                  
	int *pnRoot                     
) {
	int rc = SQLITE_OK;

	if (!pTree->pParent) {
		
		int nStart = fts3TreeFinishNode(pTree, iHeight, iLeaf);
		*piLast = iFree - 1;
		*pnRoot = pTree->nData - nStart;
		*paRoot = &pTree->aData[nStart];
	}
	else {
		SegmentNode *pIter;
		sqlite3_int64 iNextFree = iFree;
		sqlite3_int64 iNextLeaf = iLeaf;
		for (pIter = pTree->pLeftmost; pIter && rc == SQLITE_OK; pIter = pIter->pRight) {
			int nStart = fts3TreeFinishNode(pIter, iHeight, iNextLeaf);
			int nWrite = pIter->nData - nStart;

			rc = fts3WriteSegment(p, iNextFree, &pIter->aData[nStart], nWrite);
			iNextFree++;
			iNextLeaf += (pIter->nEntry + 1);
		}
		if (rc == SQLITE_OK) {
			assert(iNextLeaf == iFree);
			rc = fts3NodeWrite(
				p, pTree->pParent, iHeight + 1, iFree, iNextFree, piLast, paRoot, pnRoot
			);
		}
	}

	return rc;
}


static void fts3NodeFree(SegmentNode *pTree) {
	if (pTree) {
		SegmentNode *p = pTree->pLeftmost;
		fts3NodeFree(p->pParent);
		while (p) {
			SegmentNode *pRight = p->pRight;
			if (p->aData != (char *)&p[1]) {
				sqlite3_free(p->aData);
			}
			assert(pRight == 0 || p->zMalloc == 0);
			sqlite3_free(p->zMalloc);
			sqlite3_free(p);
			p = pRight;
		}
	}
}


static int fts3SegWriterAdd(
	Fts3Table *p,                   
	SegmentWriter **ppWriter,       
	int isCopyTerm,                 
	const char *zTerm,              
	int nTerm,                      
	const char *aDoclist,           
	int nDoclist                    
) {
	int nPrefix;                    
	int nSuffix;                    
	int nReq;                       
	int nData;
	SegmentWriter *pWriter = *ppWriter;

	if (!pWriter) {
		int rc;
		sqlite3_stmt *pStmt;

		
		pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));
		if (!pWriter) return SQLITE_NOMEM;
		memset(pWriter, 0, sizeof(SegmentWriter));
		*ppWriter = pWriter;

		
		pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);
		if (!pWriter->aData) return SQLITE_NOMEM;
		pWriter->nSize = p->nNodeSize;

		
		rc = fts3SqlStmt(p, SQL_NEXT_SEGMENTS_ID, &pStmt, 0);
		if (rc != SQLITE_OK) return rc;
		if (SQLITE_ROW == sqlite3_step(pStmt)) {
			pWriter->iFree = sqlite3_column_int64(pStmt, 0);
			pWriter->iFirst = pWriter->iFree;
		}
		rc = sqlite3_reset(pStmt);
		if (rc != SQLITE_OK) return rc;
	}
	nData = pWriter->nData;

	nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm);
	nSuffix = nTerm - nPrefix;

	
	nReq = sqlite3Fts3VarintLen(nPrefix) +    
		sqlite3Fts3VarintLen(nSuffix) +         
		nSuffix +                               
		sqlite3Fts3VarintLen(nDoclist) +        
		nDoclist;                               

	if (nData>0 && nData + nReq>p->nNodeSize) {
		int rc;

		
		rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData);
		if (rc != SQLITE_OK) return rc;
		p->nLeafAdd++;

		
		assert(nPrefix<nTerm);
		rc = fts3NodeAddTerm(p, &pWriter->pTree, isCopyTerm, zTerm, nPrefix + 1);
		if (rc != SQLITE_OK) return rc;

		nData = 0;
		pWriter->nTerm = 0;

		nPrefix = 0;
		nSuffix = nTerm;
		nReq = 1 +                              
			sqlite3Fts3VarintLen(nTerm) +         
			nTerm +                               
			sqlite3Fts3VarintLen(nDoclist) +      
			nDoclist;                             
	}

	
	pWriter->nLeafData += nReq;

	
	if (nReq>pWriter->nSize) {
		char *aNew = sqlite3_realloc(pWriter->aData, nReq);
		if (!aNew) return SQLITE_NOMEM;
		pWriter->aData = aNew;
		pWriter->nSize = nReq;
	}
	assert(nData + nReq <= pWriter->nSize);

	
	nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nPrefix);
	nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nSuffix);
	memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);
	nData += nSuffix;
	nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nDoclist);
	memcpy(&pWriter->aData[nData], aDoclist, nDoclist);
	pWriter->nData = nData + nDoclist;

	
	if (isCopyTerm) {
		if (nTerm>pWriter->nMalloc) {
			char *zNew = sqlite3_realloc(pWriter->zMalloc, nTerm * 2);
			if (!zNew) {
				return SQLITE_NOMEM;
			}
			pWriter->nMalloc = nTerm * 2;
			pWriter->zMalloc = zNew;
			pWriter->zTerm = zNew;
		}
		assert(pWriter->zTerm == pWriter->zMalloc);
		memcpy(pWriter->zTerm, zTerm, nTerm);
	}
	else {
		pWriter->zTerm = (char *)zTerm;
	}
	pWriter->nTerm = nTerm;

	return SQLITE_OK;
}


static int fts3SegWriterFlush(
	Fts3Table *p,                   
	SegmentWriter *pWriter,         
	sqlite3_int64 iLevel,           
	int iIdx                        
) {
	int rc;                         
	if (pWriter->pTree) {
		sqlite3_int64 iLast = 0;      
		sqlite3_int64 iLastLeaf;      
		char *zRoot = NULL;           
		int nRoot = 0;                

		iLastLeaf = pWriter->iFree;
		rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData);
		if (rc == SQLITE_OK) {
			rc = fts3NodeWrite(p, pWriter->pTree, 1,
				pWriter->iFirst, pWriter->iFree, &iLast, &zRoot, &nRoot);
		}
		if (rc == SQLITE_OK) {
			rc = fts3WriteSegdir(p, iLevel, iIdx,
				pWriter->iFirst, iLastLeaf, iLast, pWriter->nLeafData, zRoot, nRoot);
		}
	}
	else {
		
		rc = fts3WriteSegdir(p, iLevel, iIdx,
			0, 0, 0, pWriter->nLeafData, pWriter->aData, pWriter->nData);
	}
	p->nLeafAdd++;
	return rc;
}


static void fts3SegWriterFree(SegmentWriter *pWriter) {
	if (pWriter) {
		sqlite3_free(pWriter->aData);
		sqlite3_free(pWriter->zMalloc);
		fts3NodeFree(pWriter->pTree);
		sqlite3_free(pWriter);
	}
}


static int fts3IsEmpty(Fts3Table *p, sqlite3_value *pRowid, int *pisEmpty) {
	sqlite3_stmt *pStmt;
	int rc;
	if (p->zContentTbl) {
		
		*pisEmpty = 0;
		rc = SQLITE_OK;
	}
	else {
		rc = fts3SqlStmt(p, SQL_IS_EMPTY, &pStmt, &pRowid);
		if (rc == SQLITE_OK) {
			if (SQLITE_ROW == sqlite3_step(pStmt)) {
				*pisEmpty = sqlite3_column_int(pStmt, 0);
			}
			rc = sqlite3_reset(pStmt);
		}
	}
	return rc;
}


static int fts3SegmentMaxLevel(
	Fts3Table *p,
	int iLangid,
	int iIndex,
	sqlite3_int64 *pnMax
) {
	sqlite3_stmt *pStmt;
	int rc;
	assert(iIndex >= 0 && iIndex<p->nIndex);

	
	rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &pStmt, 0);
	if (rc != SQLITE_OK) return rc;
	sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
	sqlite3_bind_int64(pStmt, 2,
		getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL - 1)
	);
	if (SQLITE_ROW == sqlite3_step(pStmt)) {
		*pnMax = sqlite3_column_int64(pStmt, 0);
	}
	return sqlite3_reset(pStmt);
}


static int fts3SegmentIsMaxLevel(Fts3Table *p, i64 iAbsLevel, int *pbMax) {

	
	sqlite3_stmt *pStmt;
	int rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &pStmt, 0);
	if (rc != SQLITE_OK) return rc;
	sqlite3_bind_int64(pStmt, 1, iAbsLevel + 1);
	sqlite3_bind_int64(pStmt, 2,
		((iAbsLevel / FTS3_SEGDIR_MAXLEVEL) + 1) * FTS3_SEGDIR_MAXLEVEL
	);

	*pbMax = 0;
	if (SQLITE_ROW == sqlite3_step(pStmt)) {
		*pbMax = sqlite3_column_type(pStmt, 0) == SQLITE_NULL;
	}
	return sqlite3_reset(pStmt);
}


static int fts3DeleteSegment(
	Fts3Table *p,                   
	Fts3SegReader *pSeg             
) {
	int rc = SQLITE_OK;             
	if (pSeg->iStartBlock) {
		sqlite3_stmt *pDelete;        
		rc = fts3SqlStmt(p, SQL_DELETE_SEGMENTS_RANGE, &pDelete, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pDelete, 1, pSeg->iStartBlock);
			sqlite3_bind_int64(pDelete, 2, pSeg->iEndBlock);
			sqlite3_step(pDelete);
			rc = sqlite3_reset(pDelete);
		}
	}
	return rc;
}


static int fts3DeleteSegdir(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int iLevel,                     
	Fts3SegReader **apSegment,      
	int nReader                     
) {
	int rc = SQLITE_OK;             
	int i;                          
	sqlite3_stmt *pDelete = 0;      

	for (i = 0; rc == SQLITE_OK && i<nReader; i++) {
		rc = fts3DeleteSegment(p, apSegment[i]);
	}
	if (rc != SQLITE_OK) {
		return rc;
	}

	assert(iLevel >= 0 || iLevel == FTS3_SEGCURSOR_ALL);
	if (iLevel == FTS3_SEGCURSOR_ALL) {
		rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_RANGE, &pDelete, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));
			sqlite3_bind_int64(pDelete, 2,
				getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL - 1)
			);
		}
	}
	else {
		rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_LEVEL, &pDelete, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(
				pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel)
			);
		}
	}

	if (rc == SQLITE_OK) {
		sqlite3_step(pDelete);
		rc = sqlite3_reset(pDelete);
	}

	return rc;
}


static void fts3ColumnFilter(
	int iCol,                       
	int bZero,                      
	char **ppList,                  
	int *pnList                     
) {
	char *pList = *ppList;
	int nList = *pnList;
	char *pEnd = &pList[nList];
	int iCurrent = 0;
	char *p = pList;

	assert(iCol >= 0);
	while (1) {
		char c = 0;
		while (p<pEnd && (c | *p) & 0xFE) c = *p++ & 0x80;

		if (iCol == iCurrent) {
			nList = (int)(p - pList);
			break;
		}

		nList -= (int)(p - pList);
		pList = p;
		if (nList == 0) {
			break;
		}
		p = &pList[1];
		p += fts3GetVarint32(p, &iCurrent);
	}

	if (bZero && &pList[nList] != pEnd) {
		memset(&pList[nList], 0, pEnd - &pList[nList]);
	}
	*ppList = pList;
	*pnList = nList;
}


static int fts3MsrBufferData(
	Fts3MultiSegReader *pMsr,       
	char *pList,
	int nList
) {
	if (nList>pMsr->nBuffer) {
		char *pNew;
		pMsr->nBuffer = nList * 2;
		pNew = (char *)sqlite3_realloc(pMsr->aBuffer, pMsr->nBuffer);
		if (!pNew) return SQLITE_NOMEM;
		pMsr->aBuffer = pNew;
	}

	memcpy(pMsr->aBuffer, pList, nList);
	return SQLITE_OK;
}

SQLITE_PRIVATE int sqlite3Fts3MsrIncrNext(
	Fts3Table *p,                   
	Fts3MultiSegReader *pMsr,       
	sqlite3_int64 *piDocid,         
	char **paPoslist,               
	int *pnPoslist                  
) {
	int nMerge = pMsr->nAdvance;
	Fts3SegReader **apSegment = pMsr->apSegment;
	int(*xCmp)(Fts3SegReader *, Fts3SegReader *) = (
		p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp
		);

	if (nMerge == 0) {
		*paPoslist = 0;
		return SQLITE_OK;
	}

	while (1) {
		Fts3SegReader *pSeg;
		pSeg = pMsr->apSegment[0];

		if (pSeg->pOffsetList == 0) {
			*paPoslist = 0;
			break;
		}
		else {
			int rc;
			char *pList;
			int nList;
			int j;
			sqlite3_int64 iDocid = apSegment[0]->iDocid;

			rc = fts3SegReaderNextDocid(p, apSegment[0], &pList, &nList);
			j = 1;
			while (rc == SQLITE_OK
				&& j<nMerge
				&& apSegment[j]->pOffsetList
				&& apSegment[j]->iDocid == iDocid
				) {
				rc = fts3SegReaderNextDocid(p, apSegment[j], 0, 0);
				j++;
			}
			if (rc != SQLITE_OK) return rc;
			fts3SegReaderSort(pMsr->apSegment, nMerge, j, xCmp);

			if (nList>0 && fts3SegReaderIsPending(apSegment[0])) {
				rc = fts3MsrBufferData(pMsr, pList, nList + 1);
				if (rc != SQLITE_OK) return rc;
				assert((pMsr->aBuffer[nList] & 0xFE) == 0x00);
				pList = pMsr->aBuffer;
			}

			if (pMsr->iColFilter >= 0) {
				fts3ColumnFilter(pMsr->iColFilter, 1, &pList, &nList);
			}

			if (nList>0) {
				*paPoslist = pList;
				*piDocid = iDocid;
				*pnPoslist = nList;
				break;
			}
		}
	}

	return SQLITE_OK;
}

static int fts3SegReaderStart(
	Fts3Table *p,                   
	Fts3MultiSegReader *pCsr,       
	const char *zTerm,              
	int nTerm                       
) {
	int i;
	int nSeg = pCsr->nSegment;

	
	for (i = 0; pCsr->bRestart == 0 && i<pCsr->nSegment; i++) {
		int res = 0;
		Fts3SegReader *pSeg = pCsr->apSegment[i];
		do {
			int rc = fts3SegReaderNext(p, pSeg, 0);
			if (rc != SQLITE_OK) return rc;
		} while (zTerm && (res = fts3SegReaderTermCmp(pSeg, zTerm, nTerm))<0);

		if (pSeg->bLookup && res != 0) {
			fts3SegReaderSetEof(pSeg);
		}
	}
	fts3SegReaderSort(pCsr->apSegment, nSeg, nSeg, fts3SegReaderCmp);

	return SQLITE_OK;
}

SQLITE_PRIVATE int sqlite3Fts3SegReaderStart(
	Fts3Table *p,                   
	Fts3MultiSegReader *pCsr,       
	Fts3SegFilter *pFilter          
) {
	pCsr->pFilter = pFilter;
	return fts3SegReaderStart(p, pCsr, pFilter->zTerm, pFilter->nTerm);
}

SQLITE_PRIVATE int sqlite3Fts3MsrIncrStart(
	Fts3Table *p,                   
	Fts3MultiSegReader *pCsr,       
	int iCol,                       
	const char *zTerm,              
	int nTerm                       
) {
	int i;
	int rc;
	int nSegment = pCsr->nSegment;
	int(*xCmp)(Fts3SegReader *, Fts3SegReader *) = (
		p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp
		);

	assert(pCsr->pFilter == 0);
	assert(zTerm && nTerm>0);

	
	rc = fts3SegReaderStart(p, pCsr, zTerm, nTerm);
	if (rc != SQLITE_OK) return rc;

	
	for (i = 0; i<nSegment; i++) {
		Fts3SegReader *pSeg = pCsr->apSegment[i];
		if (!pSeg->aNode || fts3SegReaderTermCmp(pSeg, zTerm, nTerm)) {
			break;
		}
	}
	pCsr->nAdvance = i;

	
	for (i = 0; i<pCsr->nAdvance; i++) {
		rc = fts3SegReaderFirstDocid(p, pCsr->apSegment[i]);
		if (rc != SQLITE_OK) return rc;
	}
	fts3SegReaderSort(pCsr->apSegment, i, i, xCmp);

	assert(iCol<0 || iCol<p->nColumn);
	pCsr->iColFilter = iCol;

	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr) {
	int i;                          

	assert(pCsr->zTerm == 0);
	assert(pCsr->nTerm == 0);
	assert(pCsr->aDoclist == 0);
	assert(pCsr->nDoclist == 0);

	pCsr->nAdvance = 0;
	pCsr->bRestart = 1;
	for (i = 0; i<pCsr->nSegment; i++) {
		pCsr->apSegment[i]->pOffsetList = 0;
		pCsr->apSegment[i]->nOffsetList = 0;
		pCsr->apSegment[i]->iDocid = 0;
	}

	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3SegReaderStep(
	Fts3Table *p,                   
	Fts3MultiSegReader *pCsr        
) {
	int rc = SQLITE_OK;

	int isIgnoreEmpty = (pCsr->pFilter->flags & FTS3_SEGMENT_IGNORE_EMPTY);
	int isRequirePos = (pCsr->pFilter->flags & FTS3_SEGMENT_REQUIRE_POS);
	int isColFilter = (pCsr->pFilter->flags & FTS3_SEGMENT_COLUMN_FILTER);
	int isPrefix = (pCsr->pFilter->flags & FTS3_SEGMENT_PREFIX);
	int isScan = (pCsr->pFilter->flags & FTS3_SEGMENT_SCAN);
	int isFirst = (pCsr->pFilter->flags & FTS3_SEGMENT_FIRST);

	Fts3SegReader **apSegment = pCsr->apSegment;
	int nSegment = pCsr->nSegment;
	Fts3SegFilter *pFilter = pCsr->pFilter;
	int(*xCmp)(Fts3SegReader *, Fts3SegReader *) = (
		p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp
		);

	if (pCsr->nSegment == 0) return SQLITE_OK;

	do {
		int nMerge;
		int i;

		
		for (i = 0; i<pCsr->nAdvance; i++) {
			Fts3SegReader *pSeg = apSegment[i];
			if (pSeg->bLookup) {
				fts3SegReaderSetEof(pSeg);
			}
			else {
				rc = fts3SegReaderNext(p, pSeg, 0);
			}
			if (rc != SQLITE_OK) return rc;
		}
		fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);
		pCsr->nAdvance = 0;

		
		assert(rc == SQLITE_OK);
		if (apSegment[0]->aNode == 0) break;

		pCsr->nTerm = apSegment[0]->nTerm;
		pCsr->zTerm = apSegment[0]->zTerm;

		
		if (pFilter->zTerm && !isScan) {
			if (pCsr->nTerm<pFilter->nTerm
				|| (!isPrefix && pCsr->nTerm>pFilter->nTerm)
				|| memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm)
				) {
				break;
			}
		}

		nMerge = 1;
		while (nMerge<nSegment
			&& apSegment[nMerge]->aNode
			&& apSegment[nMerge]->nTerm == pCsr->nTerm
			&& 0 == memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)
			) {
			nMerge++;
		}

		assert(isIgnoreEmpty || (isRequirePos && !isColFilter));
		if (nMerge == 1
			&& !isIgnoreEmpty
			&& !isFirst
			&& (p->bDescIdx == 0 || fts3SegReaderIsPending(apSegment[0]) == 0)
			) {
			pCsr->nDoclist = apSegment[0]->nDoclist;
			if (fts3SegReaderIsPending(apSegment[0])) {
				rc = fts3MsrBufferData(pCsr, apSegment[0]->aDoclist, pCsr->nDoclist);
				pCsr->aDoclist = pCsr->aBuffer;
			}
			else {
				pCsr->aDoclist = apSegment[0]->aDoclist;
			}
			if (rc == SQLITE_OK) rc = SQLITE_ROW;
		}
		else {
			int nDoclist = 0;           
			sqlite3_int64 iPrev = 0;    

										
			for (i = 0; i<nMerge; i++) {
				fts3SegReaderFirstDocid(p, apSegment[i]);
			}
			fts3SegReaderSort(apSegment, nMerge, nMerge, xCmp);
			while (apSegment[0]->pOffsetList) {
				int j;                    
				char *pList = 0;
				int nList = 0;
				int nByte;
				sqlite3_int64 iDocid = apSegment[0]->iDocid;
				fts3SegReaderNextDocid(p, apSegment[0], &pList, &nList);
				j = 1;
				while (j<nMerge
					&& apSegment[j]->pOffsetList
					&& apSegment[j]->iDocid == iDocid
					) {
					fts3SegReaderNextDocid(p, apSegment[j], 0, 0);
					j++;
				}

				if (isColFilter) {
					fts3ColumnFilter(pFilter->iCol, 0, &pList, &nList);
				}

				if (!isIgnoreEmpty || nList>0) {

					
					sqlite3_int64 iDelta;
					if (p->bDescIdx && nDoclist>0) {
						iDelta = iPrev - iDocid;
					}
					else {
						iDelta = iDocid - iPrev;
					}
					assert(iDelta>0 || (nDoclist == 0 && iDelta == iDocid));
					assert(nDoclist>0 || iDelta == iDocid);

					nByte = sqlite3Fts3VarintLen(iDelta) + (isRequirePos ? nList + 1 : 0);
					if (nDoclist + nByte>pCsr->nBuffer) {
						char *aNew;
						pCsr->nBuffer = (nDoclist + nByte) * 2;
						aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);
						if (!aNew) {
							return SQLITE_NOMEM;
						}
						pCsr->aBuffer = aNew;
					}

					if (isFirst) {
						char *a = &pCsr->aBuffer[nDoclist];
						int nWrite;

						nWrite = sqlite3Fts3FirstFilter(iDelta, pList, nList, a);
						if (nWrite) {
							iPrev = iDocid;
							nDoclist += nWrite;
						}
					}
					else {
						nDoclist += sqlite3Fts3PutVarint(&pCsr->aBuffer[nDoclist], iDelta);
						iPrev = iDocid;
						if (isRequirePos) {
							memcpy(&pCsr->aBuffer[nDoclist], pList, nList);
							nDoclist += nList;
							pCsr->aBuffer[nDoclist++] = '\0';
						}
					}
				}

				fts3SegReaderSort(apSegment, nMerge, j, xCmp);
			}
			if (nDoclist>0) {
				pCsr->aDoclist = pCsr->aBuffer;
				pCsr->nDoclist = nDoclist;
				rc = SQLITE_ROW;
			}
		}
		pCsr->nAdvance = nMerge;
	} while (rc == SQLITE_OK);

	return rc;
}


SQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(
	Fts3MultiSegReader *pCsr       
) {
	if (pCsr) {
		int i;
		for (i = 0; i<pCsr->nSegment; i++) {
			sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);
		}
		sqlite3_free(pCsr->apSegment);
		sqlite3_free(pCsr->aBuffer);

		pCsr->nSegment = 0;
		pCsr->apSegment = 0;
		pCsr->aBuffer = 0;
	}
}


static void fts3ReadEndBlockField(
	sqlite3_stmt *pStmt,
	int iCol,
	i64 *piEndBlock,
	i64 *pnByte
) {
	const unsigned char *zText = sqlite3_column_text(pStmt, iCol);
	if (zText) {
		int i;
		int iMul = 1;
		i64 iVal = 0;
		for (i = 0; zText[i] >= '0' && zText[i] <= '9'; i++) {
			iVal = iVal * 10 + (zText[i] - '0');
		}
		*piEndBlock = iVal;
		while (zText[i] == ' ') i++;
		iVal = 0;
		if (zText[i] == '-') {
			i++;
			iMul = -1;
		}
		for (; zText[i] >= '0' && zText[i] <= '9'; i++) {
			iVal = iVal * 10 + (zText[i] - '0');
		}
		*pnByte = (iVal * (i64)iMul);
	}
}



static int fts3PromoteSegments(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	sqlite3_int64 nByte             
) {
	int rc = SQLITE_OK;
	sqlite3_stmt *pRange;

	rc = fts3SqlStmt(p, SQL_SELECT_LEVEL_RANGE2, &pRange, 0);

	if (rc == SQLITE_OK) {
		int bOk = 0;
		i64 iLast = (iAbsLevel / FTS3_SEGDIR_MAXLEVEL + 1) * FTS3_SEGDIR_MAXLEVEL - 1;
		i64 nLimit = (nByte * 3) / 2;

		
		sqlite3_bind_int64(pRange, 1, iAbsLevel + 1);
		sqlite3_bind_int64(pRange, 2, iLast);
		while (SQLITE_ROW == sqlite3_step(pRange)) {
			i64 nSize = 0, dummy;
			fts3ReadEndBlockField(pRange, 2, &dummy, &nSize);
			if (nSize <= 0 || nSize>nLimit) {
				
				bOk = 0;
				break;
			}
			bOk = 1;
		}
		rc = sqlite3_reset(pRange);

		if (bOk) {
			int iIdx = 0;
			sqlite3_stmt *pUpdate1 = 0;
			sqlite3_stmt *pUpdate2 = 0;

			if (rc == SQLITE_OK) {
				rc = fts3SqlStmt(p, SQL_UPDATE_LEVEL_IDX, &pUpdate1, 0);
			}
			if (rc == SQLITE_OK) {
				rc = fts3SqlStmt(p, SQL_UPDATE_LEVEL, &pUpdate2, 0);
			}

			if (rc == SQLITE_OK) {

				
				sqlite3_bind_int64(pRange, 1, iAbsLevel);
				while (SQLITE_ROW == sqlite3_step(pRange)) {
					sqlite3_bind_int(pUpdate1, 1, iIdx++);
					sqlite3_bind_int(pUpdate1, 2, sqlite3_column_int(pRange, 0));
					sqlite3_bind_int(pUpdate1, 3, sqlite3_column_int(pRange, 1));
					sqlite3_step(pUpdate1);
					rc = sqlite3_reset(pUpdate1);
					if (rc != SQLITE_OK) {
						sqlite3_reset(pRange);
						break;
					}
				}
			}
			if (rc == SQLITE_OK) {
				rc = sqlite3_reset(pRange);
			}

			
			if (rc == SQLITE_OK) {
				sqlite3_bind_int64(pUpdate2, 1, iAbsLevel);
				sqlite3_step(pUpdate2);
				rc = sqlite3_reset(pUpdate2);
			}
		}
	}


	return rc;
}


static int fts3SegmentMerge(
	Fts3Table *p,
	int iLangid,                    
	int iIndex,                     
	int iLevel                      
) {
	int rc;                         
	int iIdx = 0;                   
	sqlite3_int64 iNewLevel = 0;    
	SegmentWriter *pWriter = 0;     
	Fts3SegFilter filter;           
	Fts3MultiSegReader csr;         
	int bIgnoreEmpty = 0;           
	i64 iMaxLevel = 0;              

	assert(iLevel == FTS3_SEGCURSOR_ALL
		|| iLevel == FTS3_SEGCURSOR_PENDING
		|| iLevel >= 0
	);
	assert(iLevel<FTS3_SEGDIR_MAXLEVEL);
	assert(iIndex >= 0 && iIndex<p->nIndex);

	rc = sqlite3Fts3SegReaderCursor(p, iLangid, iIndex, iLevel, 0, 0, 1, 0, &csr);
	if (rc != SQLITE_OK || csr.nSegment == 0) goto finished;

	if (iLevel != FTS3_SEGCURSOR_PENDING) {
		rc = fts3SegmentMaxLevel(p, iLangid, iIndex, &iMaxLevel);
		if (rc != SQLITE_OK) goto finished;
	}

	if (iLevel == FTS3_SEGCURSOR_ALL) {
		
		if (csr.nSegment == 1 && 0 == fts3SegReaderIsPending(csr.apSegment[0])) {
			rc = SQLITE_DONE;
			goto finished;
		}
		iNewLevel = iMaxLevel;
		bIgnoreEmpty = 1;

	}
	else {
		
		assert(FTS3_SEGCURSOR_PENDING == -1);
		iNewLevel = getAbsoluteLevel(p, iLangid, iIndex, iLevel + 1);
		rc = fts3AllocateSegdirIdx(p, iLangid, iIndex, iLevel + 1, &iIdx);
		bIgnoreEmpty = (iLevel != FTS3_SEGCURSOR_PENDING) && (iNewLevel>iMaxLevel);
	}
	if (rc != SQLITE_OK) goto finished;

	assert(csr.nSegment>0);
	assert(iNewLevel >= getAbsoluteLevel(p, iLangid, iIndex, 0));
	assert(iNewLevel<getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL));

	memset(&filter, 0, sizeof(Fts3SegFilter));
	filter.flags = FTS3_SEGMENT_REQUIRE_POS;
	filter.flags |= (bIgnoreEmpty ? FTS3_SEGMENT_IGNORE_EMPTY : 0);

	rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);
	while (SQLITE_OK == rc) {
		rc = sqlite3Fts3SegReaderStep(p, &csr);
		if (rc != SQLITE_ROW) break;
		rc = fts3SegWriterAdd(p, &pWriter, 1,
			csr.zTerm, csr.nTerm, csr.aDoclist, csr.nDoclist);
	}
	if (rc != SQLITE_OK) goto finished;
	assert(pWriter || bIgnoreEmpty);

	if (iLevel != FTS3_SEGCURSOR_PENDING) {
		rc = fts3DeleteSegdir(
			p, iLangid, iIndex, iLevel, csr.apSegment, csr.nSegment
		);
		if (rc != SQLITE_OK) goto finished;
	}
	if (pWriter) {
		rc = fts3SegWriterFlush(p, pWriter, iNewLevel, iIdx);
		if (rc == SQLITE_OK) {
			if (iLevel == FTS3_SEGCURSOR_PENDING || iNewLevel<iMaxLevel) {
				rc = fts3PromoteSegments(p, iNewLevel, pWriter->nLeafData);
			}
		}
	}

finished:
	fts3SegWriterFree(pWriter);
	sqlite3Fts3SegReaderFinish(&csr);
	return rc;
}



SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *p) {
	int rc = SQLITE_OK;
	int i;

	for (i = 0; rc == SQLITE_OK && i<p->nIndex; i++) {
		rc = fts3SegmentMerge(p, p->iPrevLangid, i, FTS3_SEGCURSOR_PENDING);
		if (rc == SQLITE_DONE) rc = SQLITE_OK;
	}
	sqlite3Fts3PendingTermsClear(p);

	
	if (rc == SQLITE_OK && p->bHasStat
		&& p->nAutoincrmerge == 0xff && p->nLeafAdd>0
		) {
		sqlite3_stmt *pStmt = 0;
		rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pStmt, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
			rc = sqlite3_step(pStmt);
			if (rc == SQLITE_ROW) {
				p->nAutoincrmerge = sqlite3_column_int(pStmt, 0);
				if (p->nAutoincrmerge == 1) p->nAutoincrmerge = 8;
			}
			else if (rc == SQLITE_DONE) {
				p->nAutoincrmerge = 0;
			}
			rc = sqlite3_reset(pStmt);
		}
	}
	return rc;
}


static void fts3EncodeIntArray(
	int N,             
	u32 *a,            
	char *zBuf,        
	int *pNBuf         
) {
	int i, j;
	for (i = j = 0; i<N; i++) {
		j += sqlite3Fts3PutVarint(&zBuf[j], (sqlite3_int64)a[i]);
	}
	*pNBuf = j;
}


static void fts3DecodeIntArray(
	int N,             
	u32 *a,            
	const char *zBuf,  
	int nBuf           
) {
	int i, j;
	UNUSED_PARAMETER(nBuf);
	for (i = j = 0; i<N; i++) {
		sqlite3_int64 x;
		j += sqlite3Fts3GetVarint(&zBuf[j], &x);
		assert(j <= nBuf);
		a[i] = (u32)(x & 0xffffffff);
	}
}


static void fts3InsertDocsize(
	int *pRC,                       
	Fts3Table *p,                   
	u32 *aSz                        
) {
	char *pBlob;             
	int nBlob;               
	sqlite3_stmt *pStmt;     
	int rc;                  

	if (*pRC) return;
	pBlob = sqlite3_malloc(10 * p->nColumn);
	if (pBlob == 0) {
		*pRC = SQLITE_NOMEM;
		return;
	}
	fts3EncodeIntArray(p->nColumn, aSz, pBlob, &nBlob);
	rc = fts3SqlStmt(p, SQL_REPLACE_DOCSIZE, &pStmt, 0);
	if (rc) {
		sqlite3_free(pBlob);
		*pRC = rc;
		return;
	}
	sqlite3_bind_int64(pStmt, 1, p->iPrevDocid);
	sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, sqlite3_free);
	sqlite3_step(pStmt);
	*pRC = sqlite3_reset(pStmt);
}


static void fts3UpdateDocTotals(
	int *pRC,                       
	Fts3Table *p,                   
	u32 *aSzIns,                    
	u32 *aSzDel,                    
	int nChng                       
) {
	char *pBlob;             
	int nBlob;               
	u32 *a;                  
	sqlite3_stmt *pStmt;     
	int i;                   
	int rc;                  

	const int nStat = p->nColumn + 2;

	if (*pRC) return;
	a = sqlite3_malloc((sizeof(u32) + 10)*nStat);
	if (a == 0) {
		*pRC = SQLITE_NOMEM;
		return;
	}
	pBlob = (char*)&a[nStat];
	rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pStmt, 0);
	if (rc) {
		sqlite3_free(a);
		*pRC = rc;
		return;
	}
	sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
	if (sqlite3_step(pStmt) == SQLITE_ROW) {
		fts3DecodeIntArray(nStat, a,
			sqlite3_column_blob(pStmt, 0),
			sqlite3_column_bytes(pStmt, 0));
	}
	else {
		memset(a, 0, sizeof(u32)*(nStat));
	}
	rc = sqlite3_reset(pStmt);
	if (rc != SQLITE_OK) {
		sqlite3_free(a);
		*pRC = rc;
		return;
	}
	if (nChng<0 && a[0]<(u32)(-nChng)) {
		a[0] = 0;
	}
	else {
		a[0] += nChng;
	}
	for (i = 0; i<p->nColumn + 1; i++) {
		u32 x = a[i + 1];
		if (x + aSzIns[i] < aSzDel[i]) {
			x = 0;
		}
		else {
			x = x + aSzIns[i] - aSzDel[i];
		}
		a[i + 1] = x;
	}
	fts3EncodeIntArray(nStat, a, pBlob, &nBlob);
	rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
	if (rc) {
		sqlite3_free(a);
		*pRC = rc;
		return;
	}
	sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
	sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, SQLITE_STATIC);
	sqlite3_step(pStmt);
	*pRC = sqlite3_reset(pStmt);
	sqlite3_free(a);
}


static int fts3DoOptimize(Fts3Table *p, int bReturnDone) {
	int bSeenDone = 0;
	int rc;
	sqlite3_stmt *pAllLangid = 0;

	rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);
	if (rc == SQLITE_OK) {
		int rc2;
		sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);
		sqlite3_bind_int(pAllLangid, 2, p->nIndex);
		while (sqlite3_step(pAllLangid) == SQLITE_ROW) {
			int i;
			int iLangid = sqlite3_column_int(pAllLangid, 0);
			for (i = 0; rc == SQLITE_OK && i<p->nIndex; i++) {
				rc = fts3SegmentMerge(p, iLangid, i, FTS3_SEGCURSOR_ALL);
				if (rc == SQLITE_DONE) {
					bSeenDone = 1;
					rc = SQLITE_OK;
				}
			}
		}
		rc2 = sqlite3_reset(pAllLangid);
		if (rc == SQLITE_OK) rc = rc2;
	}

	sqlite3Fts3SegmentsClose(p);
	sqlite3Fts3PendingTermsClear(p);

	return (rc == SQLITE_OK && bReturnDone && bSeenDone) ? SQLITE_DONE : rc;
}


static int fts3DoRebuild(Fts3Table *p) {
	int rc;                         

	rc = fts3DeleteAll(p, 0);
	if (rc == SQLITE_OK) {
		u32 *aSz = 0;
		u32 *aSzIns = 0;
		u32 *aSzDel = 0;
		sqlite3_stmt *pStmt = 0;
		int nEntry = 0;

		
		char *zSql = sqlite3_mprintf("SELECT %s", p->zReadExprlist);
		if (!zSql) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
			sqlite3_free(zSql);
		}

		if (rc == SQLITE_OK) {
			int nByte = sizeof(u32) * (p->nColumn + 1) * 3;
			aSz = (u32 *)sqlite3_malloc(nByte);
			if (aSz == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				memset(aSz, 0, nByte);
				aSzIns = &aSz[p->nColumn + 1];
				aSzDel = &aSzIns[p->nColumn + 1];
			}
		}

		while (rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pStmt)) {
			int iCol;
			int iLangid = langidFromSelect(p, pStmt);
			rc = fts3PendingTermsDocid(p, 0, iLangid, sqlite3_column_int64(pStmt, 0));
			memset(aSz, 0, sizeof(aSz[0]) * (p->nColumn + 1));
			for (iCol = 0; rc == SQLITE_OK && iCol<p->nColumn; iCol++) {
				if (p->abNotindexed[iCol] == 0) {
					const char *z = (const char *)sqlite3_column_text(pStmt, iCol + 1);
					rc = fts3PendingTermsAdd(p, iLangid, z, iCol, &aSz[iCol]);
					aSz[p->nColumn] += sqlite3_column_bytes(pStmt, iCol + 1);
				}
			}
			if (p->bHasDocsize) {
				fts3InsertDocsize(&rc, p, aSz);
			}
			if (rc != SQLITE_OK) {
				sqlite3_finalize(pStmt);
				pStmt = 0;
			}
			else {
				nEntry++;
				for (iCol = 0; iCol <= p->nColumn; iCol++) {
					aSzIns[iCol] += aSz[iCol];
				}
			}
		}
		if (p->bFts4) {
			fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nEntry);
		}
		sqlite3_free(aSz);

		if (pStmt) {
			int rc2 = sqlite3_finalize(pStmt);
			if (rc == SQLITE_OK) {
				rc = rc2;
			}
		}
	}

	return rc;
}



static int fts3IncrmergeCsr(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int nSeg,                       
	Fts3MultiSegReader *pCsr        
) {
	int rc;                         
	sqlite3_stmt *pStmt = 0;        
	int nByte;                      

									
	memset(pCsr, 0, sizeof(*pCsr));
	nByte = sizeof(Fts3SegReader *) * nSeg;
	pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);

	if (pCsr->apSegment == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		memset(pCsr->apSegment, 0, nByte);
		rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);
	}
	if (rc == SQLITE_OK) {
		int i;
		int rc2;
		sqlite3_bind_int64(pStmt, 1, iAbsLevel);
		assert(pCsr->nSegment == 0);
		for (i = 0; rc == SQLITE_OK && sqlite3_step(pStmt) == SQLITE_ROW && i<nSeg; i++) {
			rc = sqlite3Fts3SegReaderNew(i, 0,
				sqlite3_column_int64(pStmt, 1),        
				sqlite3_column_int64(pStmt, 2),        
				sqlite3_column_int64(pStmt, 3),        
				sqlite3_column_blob(pStmt, 4),         
				sqlite3_column_bytes(pStmt, 4),        
				&pCsr->apSegment[i]
			);
			pCsr->nSegment++;
		}
		rc2 = sqlite3_reset(pStmt);
		if (rc == SQLITE_OK) rc = rc2;
	}

	return rc;
}

typedef struct IncrmergeWriter IncrmergeWriter;
typedef struct NodeWriter NodeWriter;
typedef struct Blob Blob;
typedef struct NodeReader NodeReader;


struct Blob {
	char *a;                        
	int n;                          
	int nAlloc;                     
};


struct NodeWriter {
	sqlite3_int64 iBlock;           
	Blob key;                       
	Blob block;                     
};


struct IncrmergeWriter {
	int nLeafEst;                   
	int nWork;                      
	sqlite3_int64 iAbsLevel;        
	int iIdx;                       
	sqlite3_int64 iStart;           
	sqlite3_int64 iEnd;             
	sqlite3_int64 nLeafData;        
	u8 bNoLeafData;                 
	NodeWriter aNodeWriter[FTS_MAX_APPENDABLE_HEIGHT];
};


struct NodeReader {
	const char *aNode;
	int nNode;
	int iOff;                       

									
	sqlite3_int64 iChild;           
	Blob term;                      
	const char *aDoclist;           
	int nDoclist;                   
};


static void blobGrowBuffer(Blob *pBlob, int nMin, int *pRc) {
	if (*pRc == SQLITE_OK && nMin>pBlob->nAlloc) {
		int nAlloc = nMin;
		char *a = (char *)sqlite3_realloc(pBlob->a, nAlloc);
		if (a) {
			pBlob->nAlloc = nAlloc;
			pBlob->a = a;
		}
		else {
			*pRc = SQLITE_NOMEM;
		}
	}
}


static int nodeReaderNext(NodeReader *p) {
	int bFirst = (p->term.n == 0);    
	int nPrefix = 0;                
	int nSuffix = 0;                
	int rc = SQLITE_OK;             

	assert(p->aNode);
	if (p->iChild && bFirst == 0) p->iChild++;
	if (p->iOff >= p->nNode) {
		
		p->aNode = 0;
	}
	else {
		if (bFirst == 0) {
			p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nPrefix);
		}
		p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nSuffix);

		blobGrowBuffer(&p->term, nPrefix + nSuffix, &rc);
		if (rc == SQLITE_OK) {
			memcpy(&p->term.a[nPrefix], &p->aNode[p->iOff], nSuffix);
			p->term.n = nPrefix + nSuffix;
			p->iOff += nSuffix;
			if (p->iChild == 0) {
				p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &p->nDoclist);
				p->aDoclist = &p->aNode[p->iOff];
				p->iOff += p->nDoclist;
			}
		}
	}

	assert(p->iOff <= p->nNode);

	return rc;
}


static void nodeReaderRelease(NodeReader *p) {
	sqlite3_free(p->term.a);
}


static int nodeReaderInit(NodeReader *p, const char *aNode, int nNode) {
	memset(p, 0, sizeof(NodeReader));
	p->aNode = aNode;
	p->nNode = nNode;

	
	if (p->aNode[0]) {
		
		p->iOff = 1 + sqlite3Fts3GetVarint(&p->aNode[1], &p->iChild);
	}
	else {
		p->iOff = 1;
	}

	return nodeReaderNext(p);
}


static int fts3IncrmergePush(
	Fts3Table *p,                   
	IncrmergeWriter *pWriter,       
	const char *zTerm,              
	int nTerm                       
) {
	sqlite3_int64 iPtr = pWriter->aNodeWriter[0].iBlock;
	int iLayer;

	assert(nTerm>0);
	for (iLayer = 1; ALWAYS(iLayer<FTS_MAX_APPENDABLE_HEIGHT); iLayer++) {
		sqlite3_int64 iNextPtr = 0;
		NodeWriter *pNode = &pWriter->aNodeWriter[iLayer];
		int rc = SQLITE_OK;
		int nPrefix;
		int nSuffix;
		int nSpace;

		
		nPrefix = fts3PrefixCompress(pNode->key.a, pNode->key.n, zTerm, nTerm);
		nSuffix = nTerm - nPrefix;
		nSpace = sqlite3Fts3VarintLen(nPrefix);
		nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;

		if (pNode->key.n == 0 || (pNode->block.n + nSpace) <= p->nNodeSize) {
			

			Blob *pBlk = &pNode->block;
			if (pBlk->n == 0) {
				blobGrowBuffer(pBlk, p->nNodeSize, &rc);
				if (rc == SQLITE_OK) {
					pBlk->a[0] = (char)iLayer;
					pBlk->n = 1 + sqlite3Fts3PutVarint(&pBlk->a[1], iPtr);
				}
			}
			blobGrowBuffer(pBlk, pBlk->n + nSpace, &rc);
			blobGrowBuffer(&pNode->key, nTerm, &rc);

			if (rc == SQLITE_OK) {
				if (pNode->key.n) {
					pBlk->n += sqlite3Fts3PutVarint(&pBlk->a[pBlk->n], nPrefix);
				}
				pBlk->n += sqlite3Fts3PutVarint(&pBlk->a[pBlk->n], nSuffix);
				memcpy(&pBlk->a[pBlk->n], &zTerm[nPrefix], nSuffix);
				pBlk->n += nSuffix;

				memcpy(pNode->key.a, zTerm, nTerm);
				pNode->key.n = nTerm;
			}
		}
		else {
			
			rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n);

			assert(pNode->block.nAlloc >= p->nNodeSize);
			pNode->block.a[0] = (char)iLayer;
			pNode->block.n = 1 + sqlite3Fts3PutVarint(&pNode->block.a[1], iPtr + 1);

			iNextPtr = pNode->iBlock;
			pNode->iBlock++;
			pNode->key.n = 0;
		}

		if (rc != SQLITE_OK || iNextPtr == 0) return rc;
		iPtr = iNextPtr;
	}

	assert(0);
	return 0;
}


static int fts3AppendToNode(
	Blob *pNode,                    
	Blob *pPrev,                    
	const char *zTerm,              
	int nTerm,                      
	const char *aDoclist,           
	int nDoclist                    
) {
	int rc = SQLITE_OK;             
	int bFirst = (pPrev->n == 0);     
	int nPrefix;                    
	int nSuffix;                    

									
	assert(pNode->n>0);
	assert((pNode->a[0] == '\0') == (aDoclist != 0));

	blobGrowBuffer(pPrev, nTerm, &rc);
	if (rc != SQLITE_OK) return rc;

	nPrefix = fts3PrefixCompress(pPrev->a, pPrev->n, zTerm, nTerm);
	nSuffix = nTerm - nPrefix;
	memcpy(pPrev->a, zTerm, nTerm);
	pPrev->n = nTerm;

	if (bFirst == 0) {
		pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nPrefix);
	}
	pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nSuffix);
	memcpy(&pNode->a[pNode->n], &zTerm[nPrefix], nSuffix);
	pNode->n += nSuffix;

	if (aDoclist) {
		pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nDoclist);
		memcpy(&pNode->a[pNode->n], aDoclist, nDoclist);
		pNode->n += nDoclist;
	}

	assert(pNode->n <= pNode->nAlloc);

	return SQLITE_OK;
}


static int fts3IncrmergeAppend(
	Fts3Table *p,                   
	IncrmergeWriter *pWriter,       
	Fts3MultiSegReader *pCsr        
) {
	const char *zTerm = pCsr->zTerm;
	int nTerm = pCsr->nTerm;
	const char *aDoclist = pCsr->aDoclist;
	int nDoclist = pCsr->nDoclist;
	int rc = SQLITE_OK;           
	int nSpace;                   
	int nPrefix;                  
	int nSuffix;                  
	NodeWriter *pLeaf;            

	pLeaf = &pWriter->aNodeWriter[0];
	nPrefix = fts3PrefixCompress(pLeaf->key.a, pLeaf->key.n, zTerm, nTerm);
	nSuffix = nTerm - nPrefix;

	nSpace = sqlite3Fts3VarintLen(nPrefix);
	nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;
	nSpace += sqlite3Fts3VarintLen(nDoclist) + nDoclist;

	
	if (pLeaf->block.n>0 && (pLeaf->block.n + nSpace)>p->nNodeSize) {
		rc = fts3WriteSegment(p, pLeaf->iBlock, pLeaf->block.a, pLeaf->block.n);
		pWriter->nWork++;

		
		if (rc == SQLITE_OK) {
			rc = fts3IncrmergePush(p, pWriter, zTerm, nPrefix + 1);
		}

		
		pLeaf->iBlock++;
		pLeaf->key.n = 0;
		pLeaf->block.n = 0;

		nSuffix = nTerm;
		nSpace = 1;
		nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;
		nSpace += sqlite3Fts3VarintLen(nDoclist) + nDoclist;
	}

	pWriter->nLeafData += nSpace;
	blobGrowBuffer(&pLeaf->block, pLeaf->block.n + nSpace, &rc);
	if (rc == SQLITE_OK) {
		if (pLeaf->block.n == 0) {
			pLeaf->block.n = 1;
			pLeaf->block.a[0] = '\0';
		}
		rc = fts3AppendToNode(
			&pLeaf->block, &pLeaf->key, zTerm, nTerm, aDoclist, nDoclist
		);
	}

	return rc;
}


static void fts3IncrmergeRelease(
	Fts3Table *p,                   
	IncrmergeWriter *pWriter,       
	int *pRc                        
) {
	int i;                          
	int iRoot;                      
	NodeWriter *pRoot;              
	int rc = *pRc;                  

									
	for (iRoot = FTS_MAX_APPENDABLE_HEIGHT - 1; iRoot >= 0; iRoot--) {
		NodeWriter *pNode = &pWriter->aNodeWriter[iRoot];
		if (pNode->block.n>0) break;
		assert(*pRc || pNode->block.nAlloc == 0);
		assert(*pRc || pNode->key.nAlloc == 0);
		sqlite3_free(pNode->block.a);
		sqlite3_free(pNode->key.a);
	}

	
	if (iRoot<0) return;

	
	if (iRoot == 0) {
		Blob *pBlock = &pWriter->aNodeWriter[1].block;
		blobGrowBuffer(pBlock, 1 + FTS3_VARINT_MAX, &rc);
		if (rc == SQLITE_OK) {
			pBlock->a[0] = 0x01;
			pBlock->n = 1 + sqlite3Fts3PutVarint(
				&pBlock->a[1], pWriter->aNodeWriter[0].iBlock
			);
		}
		iRoot = 1;
	}
	pRoot = &pWriter->aNodeWriter[iRoot];

	
	for (i = 0; i<iRoot; i++) {
		NodeWriter *pNode = &pWriter->aNodeWriter[i];
		if (pNode->block.n>0 && rc == SQLITE_OK) {
			rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n);
		}
		sqlite3_free(pNode->block.a);
		sqlite3_free(pNode->key.a);
	}

	
	if (rc == SQLITE_OK) {
		rc = fts3WriteSegdir(p,
			pWriter->iAbsLevel + 1,               
			pWriter->iIdx,                      
			pWriter->iStart,                    
			pWriter->aNodeWriter[0].iBlock,     
			pWriter->iEnd,                      
			(pWriter->bNoLeafData == 0 ? pWriter->nLeafData : 0),   
			pRoot->block.a, pRoot->block.n      
		);
	}
	sqlite3_free(pRoot->block.a);
	sqlite3_free(pRoot->key.a);

	*pRc = rc;
}


static int fts3TermCmp(
	const char *zLhs, int nLhs,     
	const char *zRhs, int nRhs      
) {
	int nCmp = MIN(nLhs, nRhs);
	int res;

	res = memcmp(zLhs, zRhs, nCmp);
	if (res == 0) res = nLhs - nRhs;

	return res;
}



static int fts3IsAppendable(Fts3Table *p, sqlite3_int64 iEnd, int *pbRes) {
	int bRes = 0;                   
	sqlite3_stmt *pCheck = 0;       
	int rc;                         

	rc = fts3SqlStmt(p, SQL_SEGMENT_IS_APPENDABLE, &pCheck, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pCheck, 1, iEnd);
		if (SQLITE_ROW == sqlite3_step(pCheck)) bRes = 1;
		rc = sqlite3_reset(pCheck);
	}

	*pbRes = bRes;
	return rc;
}


static int fts3IncrmergeLoad(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int iIdx,                       
	const char *zKey,               
	int nKey,                       
	IncrmergeWriter *pWriter        
) {
	int rc;                         
	sqlite3_stmt *pSelect = 0;      

	rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR, &pSelect, 0);
	if (rc == SQLITE_OK) {
		sqlite3_int64 iStart = 0;     
		sqlite3_int64 iLeafEnd = 0;   
		sqlite3_int64 iEnd = 0;       
		const char *aRoot = 0;        
		int nRoot = 0;                
		int rc2;                      
		int bAppendable = 0;          

									  
		sqlite3_bind_int64(pSelect, 1, iAbsLevel + 1);
		sqlite3_bind_int(pSelect, 2, iIdx);
		if (sqlite3_step(pSelect) == SQLITE_ROW) {
			iStart = sqlite3_column_int64(pSelect, 1);
			iLeafEnd = sqlite3_column_int64(pSelect, 2);
			fts3ReadEndBlockField(pSelect, 3, &iEnd, &pWriter->nLeafData);
			if (pWriter->nLeafData<0) {
				pWriter->nLeafData = pWriter->nLeafData * -1;
			}
			pWriter->bNoLeafData = (pWriter->nLeafData == 0);
			nRoot = sqlite3_column_bytes(pSelect, 4);
			aRoot = sqlite3_column_blob(pSelect, 4);
		}
		else {
			return sqlite3_reset(pSelect);
		}

		
		rc = fts3IsAppendable(p, iEnd, &bAppendable);

		
		if (rc == SQLITE_OK && bAppendable) {
			char *aLeaf = 0;
			int nLeaf = 0;

			rc = sqlite3Fts3ReadBlock(p, iLeafEnd, &aLeaf, &nLeaf, 0);
			if (rc == SQLITE_OK) {
				NodeReader reader;
				for (rc = nodeReaderInit(&reader, aLeaf, nLeaf);
					rc == SQLITE_OK && reader.aNode;
					rc = nodeReaderNext(&reader)
					) {
					assert(reader.aNode);
				}
				if (fts3TermCmp(zKey, nKey, reader.term.a, reader.term.n) <= 0) {
					bAppendable = 0;
				}
				nodeReaderRelease(&reader);
			}
			sqlite3_free(aLeaf);
		}

		if (rc == SQLITE_OK && bAppendable) {
			
			int i;
			int nHeight = (int)aRoot[0];
			NodeWriter *pNode;

			pWriter->nLeafEst = (int)((iEnd - iStart) + 1) / FTS_MAX_APPENDABLE_HEIGHT;
			pWriter->iStart = iStart;
			pWriter->iEnd = iEnd;
			pWriter->iAbsLevel = iAbsLevel;
			pWriter->iIdx = iIdx;

			for (i = nHeight + 1; i<FTS_MAX_APPENDABLE_HEIGHT; i++) {
				pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;
			}

			pNode = &pWriter->aNodeWriter[nHeight];
			pNode->iBlock = pWriter->iStart + pWriter->nLeafEst*nHeight;
			blobGrowBuffer(&pNode->block, MAX(nRoot, p->nNodeSize), &rc);
			if (rc == SQLITE_OK) {
				memcpy(pNode->block.a, aRoot, nRoot);
				pNode->block.n = nRoot;
			}

			for (i = nHeight; i >= 0 && rc == SQLITE_OK; i--) {
				NodeReader reader;
				pNode = &pWriter->aNodeWriter[i];

				rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);
				while (reader.aNode && rc == SQLITE_OK) rc = nodeReaderNext(&reader);
				blobGrowBuffer(&pNode->key, reader.term.n, &rc);
				if (rc == SQLITE_OK) {
					memcpy(pNode->key.a, reader.term.a, reader.term.n);
					pNode->key.n = reader.term.n;
					if (i>0) {
						char *aBlock = 0;
						int nBlock = 0;
						pNode = &pWriter->aNodeWriter[i - 1];
						pNode->iBlock = reader.iChild;
						rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock, 0);
						blobGrowBuffer(&pNode->block, MAX(nBlock, p->nNodeSize), &rc);
						if (rc == SQLITE_OK) {
							memcpy(pNode->block.a, aBlock, nBlock);
							pNode->block.n = nBlock;
						}
						sqlite3_free(aBlock);
					}
				}
				nodeReaderRelease(&reader);
			}
		}

		rc2 = sqlite3_reset(pSelect);
		if (rc == SQLITE_OK) rc = rc2;
	}

	return rc;
}


static int fts3IncrmergeOutputIdx(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int *piIdx                      
) {
	int rc;
	sqlite3_stmt *pOutputIdx = 0;   

	rc = fts3SqlStmt(p, SQL_NEXT_SEGMENT_INDEX, &pOutputIdx, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pOutputIdx, 1, iAbsLevel + 1);
		sqlite3_step(pOutputIdx);
		*piIdx = sqlite3_column_int(pOutputIdx, 0);
		rc = sqlite3_reset(pOutputIdx);
	}

	return rc;
}


static int fts3IncrmergeWriter(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int iIdx,                       
	Fts3MultiSegReader *pCsr,       
	IncrmergeWriter *pWriter        
) {
	int rc;                         
	int i;                          
	int nLeafEst = 0;               
	sqlite3_stmt *pLeafEst = 0;     
	sqlite3_stmt *pFirstBlock = 0;  

									
	rc = fts3SqlStmt(p, SQL_MAX_LEAF_NODE_ESTIMATE, &pLeafEst, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pLeafEst, 1, iAbsLevel);
		sqlite3_bind_int64(pLeafEst, 2, pCsr->nSegment);
		if (SQLITE_ROW == sqlite3_step(pLeafEst)) {
			nLeafEst = sqlite3_column_int(pLeafEst, 0);
		}
		rc = sqlite3_reset(pLeafEst);
	}
	if (rc != SQLITE_OK) return rc;

	
	rc = fts3SqlStmt(p, SQL_NEXT_SEGMENTS_ID, &pFirstBlock, 0);
	if (rc == SQLITE_OK) {
		if (SQLITE_ROW == sqlite3_step(pFirstBlock)) {
			pWriter->iStart = sqlite3_column_int64(pFirstBlock, 0);
			pWriter->iEnd = pWriter->iStart - 1;
			pWriter->iEnd += nLeafEst * FTS_MAX_APPENDABLE_HEIGHT;
		}
		rc = sqlite3_reset(pFirstBlock);
	}
	if (rc != SQLITE_OK) return rc;

	
	rc = fts3WriteSegment(p, pWriter->iEnd, 0, 0);
	if (rc != SQLITE_OK) return rc;

	pWriter->iAbsLevel = iAbsLevel;
	pWriter->nLeafEst = nLeafEst;
	pWriter->iIdx = iIdx;

	
	for (i = 0; i<FTS_MAX_APPENDABLE_HEIGHT; i++) {
		pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;
	}
	return SQLITE_OK;
}


static int fts3RemoveSegdirEntry(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int iIdx                        
) {
	int rc;                         
	sqlite3_stmt *pDelete = 0;      

	rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_ENTRY, &pDelete, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pDelete, 1, iAbsLevel);
		sqlite3_bind_int(pDelete, 2, iIdx);
		sqlite3_step(pDelete);
		rc = sqlite3_reset(pDelete);
	}

	return rc;
}


static int fts3RepackSegdirLevel(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel         
) {
	int rc;                         
	int *aIdx = 0;                  
	int nIdx = 0;                   
	int nAlloc = 0;                 
	int i;                          
	sqlite3_stmt *pSelect = 0;      
	sqlite3_stmt *pUpdate = 0;      

	rc = fts3SqlStmt(p, SQL_SELECT_INDEXES, &pSelect, 0);
	if (rc == SQLITE_OK) {
		int rc2;
		sqlite3_bind_int64(pSelect, 1, iAbsLevel);
		while (SQLITE_ROW == sqlite3_step(pSelect)) {
			if (nIdx >= nAlloc) {
				int *aNew;
				nAlloc += 16;
				aNew = sqlite3_realloc(aIdx, nAlloc * sizeof(int));
				if (!aNew) {
					rc = SQLITE_NOMEM;
					break;
				}
				aIdx = aNew;
			}
			aIdx[nIdx++] = sqlite3_column_int(pSelect, 0);
		}
		rc2 = sqlite3_reset(pSelect);
		if (rc == SQLITE_OK) rc = rc2;
	}

	if (rc == SQLITE_OK) {
		rc = fts3SqlStmt(p, SQL_SHIFT_SEGDIR_ENTRY, &pUpdate, 0);
	}
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pUpdate, 2, iAbsLevel);
	}

	assert(p->bIgnoreSavepoint == 0);
	p->bIgnoreSavepoint = 1;
	for (i = 0; rc == SQLITE_OK && i<nIdx; i++) {
		if (aIdx[i] != i) {
			sqlite3_bind_int(pUpdate, 3, aIdx[i]);
			sqlite3_bind_int(pUpdate, 1, i);
			sqlite3_step(pUpdate);
			rc = sqlite3_reset(pUpdate);
		}
	}
	p->bIgnoreSavepoint = 0;

	sqlite3_free(aIdx);
	return rc;
}

static void fts3StartNode(Blob *pNode, int iHeight, sqlite3_int64 iChild) {
	pNode->a[0] = (char)iHeight;
	if (iChild) {
		assert(pNode->nAlloc >= 1 + sqlite3Fts3VarintLen(iChild));
		pNode->n = 1 + sqlite3Fts3PutVarint(&pNode->a[1], iChild);
	}
	else {
		assert(pNode->nAlloc >= 1);
		pNode->n = 1;
	}
}


static int fts3TruncateNode(
	const char *aNode,              
	int nNode,                      
	Blob *pNew,                     
	const char *zTerm,              
	int nTerm,                      
	sqlite3_int64 *piBlock          
) {
	NodeReader reader;              
	Blob prev = { 0, 0, 0 };          
	int rc = SQLITE_OK;             
	int bLeaf = aNode[0] == '\0';     

									  
	blobGrowBuffer(pNew, nNode, &rc);
	if (rc != SQLITE_OK) return rc;
	pNew->n = 0;

	
	for (rc = nodeReaderInit(&reader, aNode, nNode);
		rc == SQLITE_OK && reader.aNode;
		rc = nodeReaderNext(&reader)
		) {
		if (pNew->n == 0) {
			int res = fts3TermCmp(reader.term.a, reader.term.n, zTerm, nTerm);
			if (res<0 || (bLeaf == 0 && res == 0)) continue;
			fts3StartNode(pNew, (int)aNode[0], reader.iChild);
			*piBlock = reader.iChild;
		}
		rc = fts3AppendToNode(
			pNew, &prev, reader.term.a, reader.term.n,
			reader.aDoclist, reader.nDoclist
		);
		if (rc != SQLITE_OK) break;
	}
	if (pNew->n == 0) {
		fts3StartNode(pNew, (int)aNode[0], reader.iChild);
		*piBlock = reader.iChild;
	}
	assert(pNew->n <= pNew->nAlloc);

	nodeReaderRelease(&reader);
	sqlite3_free(prev.a);
	return rc;
}


static int fts3TruncateSegment(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	int iIdx,                       
	const char *zTerm,              
	int nTerm                      
) {
	int rc = SQLITE_OK;             
	Blob root = { 0,0,0 };            
	Blob block = { 0,0,0 };           
	sqlite3_int64 iBlock = 0;       
	sqlite3_int64 iNewStart = 0;    
	sqlite3_int64 iOldStart = 0;    
	sqlite3_stmt *pFetch = 0;       

	rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR, &pFetch, 0);
	if (rc == SQLITE_OK) {
		int rc2;                      
		sqlite3_bind_int64(pFetch, 1, iAbsLevel);
		sqlite3_bind_int(pFetch, 2, iIdx);
		if (SQLITE_ROW == sqlite3_step(pFetch)) {
			const char *aRoot = sqlite3_column_blob(pFetch, 4);
			int nRoot = sqlite3_column_bytes(pFetch, 4);
			iOldStart = sqlite3_column_int64(pFetch, 1);
			rc = fts3TruncateNode(aRoot, nRoot, &root, zTerm, nTerm, &iBlock);
		}
		rc2 = sqlite3_reset(pFetch);
		if (rc == SQLITE_OK) rc = rc2;
	}

	while (rc == SQLITE_OK && iBlock) {
		char *aBlock = 0;
		int nBlock = 0;
		iNewStart = iBlock;

		rc = sqlite3Fts3ReadBlock(p, iBlock, &aBlock, &nBlock, 0);
		if (rc == SQLITE_OK) {
			rc = fts3TruncateNode(aBlock, nBlock, &block, zTerm, nTerm, &iBlock);
		}
		if (rc == SQLITE_OK) {
			rc = fts3WriteSegment(p, iNewStart, block.a, block.n);
		}
		sqlite3_free(aBlock);
	}

	
	if (rc == SQLITE_OK && iNewStart) {
		sqlite3_stmt *pDel = 0;
		rc = fts3SqlStmt(p, SQL_DELETE_SEGMENTS_RANGE, &pDel, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pDel, 1, iOldStart);
			sqlite3_bind_int64(pDel, 2, iNewStart - 1);
			sqlite3_step(pDel);
			rc = sqlite3_reset(pDel);
		}
	}

	if (rc == SQLITE_OK) {
		sqlite3_stmt *pChomp = 0;
		rc = fts3SqlStmt(p, SQL_CHOMP_SEGDIR, &pChomp, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pChomp, 1, iNewStart);
			sqlite3_bind_blob(pChomp, 2, root.a, root.n, SQLITE_STATIC);
			sqlite3_bind_int64(pChomp, 3, iAbsLevel);
			sqlite3_bind_int(pChomp, 4, iIdx);
			sqlite3_step(pChomp);
			rc = sqlite3_reset(pChomp);
		}
	}

	sqlite3_free(root.a);
	sqlite3_free(block.a);
	return rc;
}


static int fts3IncrmergeChomp(
	Fts3Table *p,                   
	sqlite3_int64 iAbsLevel,        
	Fts3MultiSegReader *pCsr,       
	int *pnRem                      
) {
	int i;
	int nRem = 0;
	int rc = SQLITE_OK;

	for (i = pCsr->nSegment - 1; i >= 0 && rc == SQLITE_OK; i--) {
		Fts3SegReader *pSeg = 0;
		int j;

		
		for (j = 0; ALWAYS(j<pCsr->nSegment); j++) {
			pSeg = pCsr->apSegment[j];
			if (pSeg->iIdx == i) break;
		}
		assert(j<pCsr->nSegment && pSeg->iIdx == i);

		if (pSeg->aNode == 0) {
			
			rc = fts3DeleteSegment(p, pSeg);
			if (rc == SQLITE_OK) {
				rc = fts3RemoveSegdirEntry(p, iAbsLevel, pSeg->iIdx);
			}
			*pnRem = 0;
		}
		else {
			
			const char *zTerm = pSeg->zTerm;
			int nTerm = pSeg->nTerm;
			rc = fts3TruncateSegment(p, iAbsLevel, pSeg->iIdx, zTerm, nTerm);
			nRem++;
		}
	}

	if (rc == SQLITE_OK && nRem != pCsr->nSegment) {
		rc = fts3RepackSegdirLevel(p, iAbsLevel);
	}

	*pnRem = nRem;
	return rc;
}


static int fts3IncrmergeHintStore(Fts3Table *p, Blob *pHint) {
	sqlite3_stmt *pReplace = 0;
	int rc;                         

	rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pReplace, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_int(pReplace, 1, FTS_STAT_INCRMERGEHINT);
		sqlite3_bind_blob(pReplace, 2, pHint->a, pHint->n, SQLITE_STATIC);
		sqlite3_step(pReplace);
		rc = sqlite3_reset(pReplace);
	}

	return rc;
}


static int fts3IncrmergeHintLoad(Fts3Table *p, Blob *pHint) {
	sqlite3_stmt *pSelect = 0;
	int rc;

	pHint->n = 0;
	rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pSelect, 0);
	if (rc == SQLITE_OK) {
		int rc2;
		sqlite3_bind_int(pSelect, 1, FTS_STAT_INCRMERGEHINT);
		if (SQLITE_ROW == sqlite3_step(pSelect)) {
			const char *aHint = sqlite3_column_blob(pSelect, 0);
			int nHint = sqlite3_column_bytes(pSelect, 0);
			if (aHint) {
				blobGrowBuffer(pHint, nHint, &rc);
				if (rc == SQLITE_OK) {
					memcpy(pHint->a, aHint, nHint);
					pHint->n = nHint;
				}
			}
		}
		rc2 = sqlite3_reset(pSelect);
		if (rc == SQLITE_OK) rc = rc2;
	}

	return rc;
}


static void fts3IncrmergeHintPush(
	Blob *pHint,                    
	i64 iAbsLevel,                  
	int nInput,                     
	int *pRc                        
) {
	blobGrowBuffer(pHint, pHint->n + 2 * FTS3_VARINT_MAX, pRc);
	if (*pRc == SQLITE_OK) {
		pHint->n += sqlite3Fts3PutVarint(&pHint->a[pHint->n], iAbsLevel);
		pHint->n += sqlite3Fts3PutVarint(&pHint->a[pHint->n], (i64)nInput);
	}
}


static int fts3IncrmergeHintPop(Blob *pHint, i64 *piAbsLevel, int *pnInput) {
	const int nHint = pHint->n;
	int i;

	i = pHint->n - 2;
	while (i>0 && (pHint->a[i - 1] & 0x80)) i--;
	while (i>0 && (pHint->a[i - 1] & 0x80)) i--;

	pHint->n = i;
	i += sqlite3Fts3GetVarint(&pHint->a[i], piAbsLevel);
	i += fts3GetVarint32(&pHint->a[i], pnInput);
	if (i != nHint) return FTS_CORRUPT_VTAB;

	return SQLITE_OK;
}



SQLITE_PRIVATE int sqlite3Fts3Incrmerge(Fts3Table *p, int nMerge, int nMin) {
	int rc;                         
	int nRem = nMerge;              
	Fts3MultiSegReader *pCsr;       
	Fts3SegFilter *pFilter;         
	IncrmergeWriter *pWriter;       
	int nSeg = 0;                   
	sqlite3_int64 iAbsLevel = 0;    
	Blob hint = { 0, 0, 0 };          
	int bDirtyHint = 0;             

									
	const int nAlloc = sizeof(*pCsr) + sizeof(*pFilter) + sizeof(*pWriter);
	pWriter = (IncrmergeWriter *)sqlite3_malloc(nAlloc);
	if (!pWriter) return SQLITE_NOMEM;
	pFilter = (Fts3SegFilter *)&pWriter[1];
	pCsr = (Fts3MultiSegReader *)&pFilter[1];

	rc = fts3IncrmergeHintLoad(p, &hint);
	while (rc == SQLITE_OK && nRem>0) {
		const i64 nMod = FTS3_SEGDIR_MAXLEVEL * p->nIndex;
		sqlite3_stmt *pFindLevel = 0; 
		int bUseHint = 0;             
		int iIdx = 0;                 

									  
		rc = fts3SqlStmt(p, SQL_FIND_MERGE_LEVEL, &pFindLevel, 0);
		sqlite3_bind_int(pFindLevel, 1, MAX(2, nMin));
		if (sqlite3_step(pFindLevel) == SQLITE_ROW) {
			iAbsLevel = sqlite3_column_int64(pFindLevel, 0);
			nSeg = sqlite3_column_int(pFindLevel, 1);
			assert(nSeg >= 2);
		}
		else {
			nSeg = -1;
		}
		rc = sqlite3_reset(pFindLevel);

		
		if (rc == SQLITE_OK && hint.n) {
			int nHint = hint.n;
			sqlite3_int64 iHintAbsLevel = 0;      
			int nHintSeg = 0;                     

			rc = fts3IncrmergeHintPop(&hint, &iHintAbsLevel, &nHintSeg);
			if (nSeg<0 || (iAbsLevel % nMod) >= (iHintAbsLevel % nMod)) {
				iAbsLevel = iHintAbsLevel;
				nSeg = nHintSeg;
				bUseHint = 1;
				bDirtyHint = 1;
			}
			else {
				
				hint.n = nHint;
			}
		}

		
		if (nSeg<0) break;

		
		memset(pWriter, 0, nAlloc);
		pFilter->flags = FTS3_SEGMENT_REQUIRE_POS;

		if (rc == SQLITE_OK) {
			rc = fts3IncrmergeOutputIdx(p, iAbsLevel, &iIdx);
			assert(bUseHint == 1 || bUseHint == 0);
			if (iIdx == 0 || (bUseHint && iIdx == 1)) {
				int bIgnore = 0;
				rc = fts3SegmentIsMaxLevel(p, iAbsLevel + 1, &bIgnore);
				if (bIgnore) {
					pFilter->flags |= FTS3_SEGMENT_IGNORE_EMPTY;
				}
			}
		}

		if (rc == SQLITE_OK) {
			rc = fts3IncrmergeCsr(p, iAbsLevel, nSeg, pCsr);
		}
		if (SQLITE_OK == rc && pCsr->nSegment == nSeg
			&& SQLITE_OK == (rc = sqlite3Fts3SegReaderStart(p, pCsr, pFilter))
			&& SQLITE_ROW == (rc = sqlite3Fts3SegReaderStep(p, pCsr))
			) {
			if (bUseHint && iIdx>0) {
				const char *zKey = pCsr->zTerm;
				int nKey = pCsr->nTerm;
				rc = fts3IncrmergeLoad(p, iAbsLevel, iIdx - 1, zKey, nKey, pWriter);
			}
			else {
				rc = fts3IncrmergeWriter(p, iAbsLevel, iIdx, pCsr, pWriter);
			}

			if (rc == SQLITE_OK && pWriter->nLeafEst) {
				fts3LogMerge(nSeg, iAbsLevel);
				do {
					rc = fts3IncrmergeAppend(p, pWriter, pCsr);
					if (rc == SQLITE_OK) rc = sqlite3Fts3SegReaderStep(p, pCsr);
					if (pWriter->nWork >= nRem && rc == SQLITE_ROW) rc = SQLITE_OK;
				} while (rc == SQLITE_ROW);

				
				if (rc == SQLITE_OK) {
					nRem -= (1 + pWriter->nWork);
					rc = fts3IncrmergeChomp(p, iAbsLevel, pCsr, &nSeg);
					if (nSeg != 0) {
						bDirtyHint = 1;
						fts3IncrmergeHintPush(&hint, iAbsLevel, nSeg, &rc);
					}
				}
			}

			if (nSeg != 0) {
				pWriter->nLeafData = pWriter->nLeafData * -1;
			}
			fts3IncrmergeRelease(p, pWriter, &rc);
			if (nSeg == 0 && pWriter->bNoLeafData == 0) {
				fts3PromoteSegments(p, iAbsLevel + 1, pWriter->nLeafData);
			}
		}

		sqlite3Fts3SegReaderFinish(pCsr);
	}

	
	if (bDirtyHint && rc == SQLITE_OK) {
		rc = fts3IncrmergeHintStore(p, &hint);
	}

	sqlite3_free(pWriter);
	sqlite3_free(hint.a);
	return rc;
}


static int fts3Getint(const char **pz) {
	const char *z = *pz;
	int i = 0;
	while ((*z) >= '0' && (*z) <= '9') i = 10 * i + *(z++) - '0';
	*pz = z;
	return i;
}


static int fts3DoIncrmerge(
	Fts3Table *p,                   
	const char *zParam              
) {
	int rc;
	int nMin = (FTS3_MERGE_COUNT / 2);
	int nMerge = 0;
	const char *z = zParam;

	
	nMerge = fts3Getint(&z);

	
	if (z[0] == ',' && z[1] != '\0') {
		z++;
		nMin = fts3Getint(&z);
	}

	if (z[0] != '\0' || nMin<2) {
		rc = SQLITE_ERROR;
	}
	else {
		rc = SQLITE_OK;
		if (!p->bHasStat) {
			assert(p->bFts4 == 0);
			sqlite3Fts3CreateStatTable(&rc, p);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts3Incrmerge(p, nMerge, nMin);
		}
		sqlite3Fts3SegmentsClose(p);
	}
	return rc;
}


static int fts3DoAutoincrmerge(
	Fts3Table *p,                   
	const char *zParam              
) {
	int rc = SQLITE_OK;
	sqlite3_stmt *pStmt = 0;
	p->nAutoincrmerge = fts3Getint(&zParam);
	if (p->nAutoincrmerge == 1 || p->nAutoincrmerge>FTS3_MERGE_COUNT) {
		p->nAutoincrmerge = 8;
	}
	if (!p->bHasStat) {
		assert(p->bFts4 == 0);
		sqlite3Fts3CreateStatTable(&rc, p);
		if (rc) return rc;
	}
	rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
	if (rc) return rc;
	sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
	sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
	sqlite3_step(pStmt);
	rc = sqlite3_reset(pStmt);
	return rc;
}


static u64 fts3ChecksumEntry(
	const char *zTerm,              
	int nTerm,                      
	int iLangid,                    
	int iIndex,                     
	i64 iDocid,                     
	int iCol,                       
	int iPos                        
) {
	int i;
	u64 ret = (u64)iDocid;

	ret += (ret << 3) + iLangid;
	ret += (ret << 3) + iIndex;
	ret += (ret << 3) + iCol;
	ret += (ret << 3) + iPos;
	for (i = 0; i<nTerm; i++) ret += (ret << 3) + zTerm[i];

	return ret;
}


static u64 fts3ChecksumIndex(
	Fts3Table *p,                   
	int iLangid,                    
	int iIndex,                     
	int *pRc                        
) {
	Fts3SegFilter filter;
	Fts3MultiSegReader csr;
	int rc;
	u64 cksum = 0;

	assert(*pRc == SQLITE_OK);

	memset(&filter, 0, sizeof(filter));
	memset(&csr, 0, sizeof(csr));
	filter.flags = FTS3_SEGMENT_REQUIRE_POS | FTS3_SEGMENT_IGNORE_EMPTY;
	filter.flags |= FTS3_SEGMENT_SCAN;

	rc = sqlite3Fts3SegReaderCursor(
		p, iLangid, iIndex, FTS3_SEGCURSOR_ALL, 0, 0, 0, 1, &csr
	);
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);
	}

	if (rc == SQLITE_OK) {
		while (SQLITE_ROW == (rc = sqlite3Fts3SegReaderStep(p, &csr))) {
			char *pCsr = csr.aDoclist;
			char *pEnd = &pCsr[csr.nDoclist];

			i64 iDocid = 0;
			i64 iCol = 0;
			i64 iPos = 0;

			pCsr += sqlite3Fts3GetVarint(pCsr, &iDocid);
			while (pCsr<pEnd) {
				i64 iVal = 0;
				pCsr += sqlite3Fts3GetVarint(pCsr, &iVal);
				if (pCsr<pEnd) {
					if (iVal == 0 || iVal == 1) {
						iCol = 0;
						iPos = 0;
						if (iVal) {
							pCsr += sqlite3Fts3GetVarint(pCsr, &iCol);
						}
						else {
							pCsr += sqlite3Fts3GetVarint(pCsr, &iVal);
							iDocid += iVal;
						}
					}
					else {
						iPos += (iVal - 2);
						cksum = cksum ^ fts3ChecksumEntry(
							csr.zTerm, csr.nTerm, iLangid, iIndex, iDocid,
							(int)iCol, (int)iPos
						);
					}
				}
			}
		}
	}
	sqlite3Fts3SegReaderFinish(&csr);

	*pRc = rc;
	return cksum;
}


static int fts3IntegrityCheck(Fts3Table *p, int *pbOk) {
	int rc = SQLITE_OK;             
	u64 cksum1 = 0;                 
	u64 cksum2 = 0;                 
	sqlite3_stmt *pAllLangid = 0;   

									
	rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);
	if (rc == SQLITE_OK) {
		int rc2;
		sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);
		sqlite3_bind_int(pAllLangid, 2, p->nIndex);
		while (rc == SQLITE_OK && sqlite3_step(pAllLangid) == SQLITE_ROW) {
			int iLangid = sqlite3_column_int(pAllLangid, 0);
			int i;
			for (i = 0; i<p->nIndex; i++) {
				cksum1 = cksum1 ^ fts3ChecksumIndex(p, iLangid, i, &rc);
			}
		}
		rc2 = sqlite3_reset(pAllLangid);
		if (rc == SQLITE_OK) rc = rc2;
	}

	
	if (rc == SQLITE_OK) {
		sqlite3_tokenizer_module const *pModule = p->pTokenizer->pModule;
		sqlite3_stmt *pStmt = 0;
		char *zSql;

		zSql = sqlite3_mprintf("SELECT %s", p->zReadExprlist);
		if (!zSql) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
			sqlite3_free(zSql);
		}

		while (rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pStmt)) {
			i64 iDocid = sqlite3_column_int64(pStmt, 0);
			int iLang = langidFromSelect(p, pStmt);
			int iCol;

			for (iCol = 0; rc == SQLITE_OK && iCol<p->nColumn; iCol++) {
				if (p->abNotindexed[iCol] == 0) {
					const char *zText = (const char *)sqlite3_column_text(pStmt, iCol + 1);
					int nText = sqlite3_column_bytes(pStmt, iCol + 1);
					sqlite3_tokenizer_cursor *pT = 0;

					rc = sqlite3Fts3OpenTokenizer(p->pTokenizer, iLang, zText, nText, &pT);
					while (rc == SQLITE_OK) {
						char const *zToken;       
						int nToken = 0;           
						int iDum1 = 0, iDum2 = 0; 
						int iPos = 0;             

						rc = pModule->xNext(pT, &zToken, &nToken, &iDum1, &iDum2, &iPos);
						if (rc == SQLITE_OK) {
							int i;
							cksum2 = cksum2 ^ fts3ChecksumEntry(
								zToken, nToken, iLang, 0, iDocid, iCol, iPos
							);
							for (i = 1; i<p->nIndex; i++) {
								if (p->aIndex[i].nPrefix <= nToken) {
									cksum2 = cksum2 ^ fts3ChecksumEntry(
										zToken, p->aIndex[i].nPrefix, iLang, i, iDocid, iCol, iPos
									);
								}
							}
						}
					}
					if (pT) pModule->xClose(pT);
					if (rc == SQLITE_DONE) rc = SQLITE_OK;
				}
			}
		}

		sqlite3_finalize(pStmt);
	}

	*pbOk = (cksum1 == cksum2);
	return rc;
}


static int fts3DoIntegrityCheck(
	Fts3Table *p                    
) {
	int rc;
	int bOk = 0;
	rc = fts3IntegrityCheck(p, &bOk);
	if (rc == SQLITE_OK && bOk == 0) rc = FTS_CORRUPT_VTAB;
	return rc;
}


static int fts3SpecialInsert(Fts3Table *p, sqlite3_value *pVal) {
	int rc;                         
	const char *zVal = (const char *)sqlite3_value_text(pVal);
	int nVal = sqlite3_value_bytes(pVal);

	if (!zVal) {
		return SQLITE_NOMEM;
	}
	else if (nVal == 8 && 0 == sqlite3_strnicmp(zVal, "optimize", 8)) {
		rc = fts3DoOptimize(p, 0);
	}
	else if (nVal == 7 && 0 == sqlite3_strnicmp(zVal, "rebuild", 7)) {
		rc = fts3DoRebuild(p);
	}
	else if (nVal == 15 && 0 == sqlite3_strnicmp(zVal, "integrity-check", 15)) {
		rc = fts3DoIntegrityCheck(p);
	}
	else if (nVal>6 && 0 == sqlite3_strnicmp(zVal, "merge=", 6)) {
		rc = fts3DoIncrmerge(p, &zVal[6]);
	}
	else if (nVal>10 && 0 == sqlite3_strnicmp(zVal, "automerge=", 10)) {
		rc = fts3DoAutoincrmerge(p, &zVal[10]);
#ifdef SQLITE_TEST
	}
	else if (nVal>9 && 0 == sqlite3_strnicmp(zVal, "nodesize=", 9)) {
		p->nNodeSize = atoi(&zVal[9]);
		rc = SQLITE_OK;
	}
	else if (nVal>11 && 0 == sqlite3_strnicmp(zVal, "maxpending=", 9)) {
		p->nMaxPendingData = atoi(&zVal[11]);
		rc = SQLITE_OK;
	}
	else if (nVal>21 && 0 == sqlite3_strnicmp(zVal, "test-no-incr-doclist=", 21)) {
		p->bNoIncrDoclist = atoi(&zVal[21]);
		rc = SQLITE_OK;
#endif
	}
	else {
		rc = SQLITE_ERROR;
	}

	return rc;
}

#ifndef SQLITE_DISABLE_FTS4_DEFERRED

SQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *pCsr) {
	Fts3DeferredToken *pDef;
	for (pDef = pCsr->pDeferred; pDef; pDef = pDef->pNext) {
		fts3PendingListDelete(pDef->pList);
		pDef->pList = 0;
	}
}


SQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *pCsr) {
	Fts3DeferredToken *pDef;
	Fts3DeferredToken *pNext;
	for (pDef = pCsr->pDeferred; pDef; pDef = pNext) {
		pNext = pDef->pNext;
		fts3PendingListDelete(pDef->pList);
		sqlite3_free(pDef);
	}
	pCsr->pDeferred = 0;
}


SQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *pCsr) {
	int rc = SQLITE_OK;             
	if (pCsr->pDeferred) {
		int i;                        
		sqlite3_int64 iDocid;         
		Fts3DeferredToken *pDef;      

		Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
		sqlite3_tokenizer *pT = p->pTokenizer;
		sqlite3_tokenizer_module const *pModule = pT->pModule;

		assert(pCsr->isRequireSeek == 0);
		iDocid = sqlite3_column_int64(pCsr->pStmt, 0);

		for (i = 0; i<p->nColumn && rc == SQLITE_OK; i++) {
			if (p->abNotindexed[i] == 0) {
				const char *zText = (const char *)sqlite3_column_text(pCsr->pStmt, i + 1);
				sqlite3_tokenizer_cursor *pTC = 0;

				rc = sqlite3Fts3OpenTokenizer(pT, pCsr->iLangid, zText, -1, &pTC);
				while (rc == SQLITE_OK) {
					char const *zToken;       
					int nToken = 0;           
					int iDum1 = 0, iDum2 = 0; 
					int iPos = 0;             

					rc = pModule->xNext(pTC, &zToken, &nToken, &iDum1, &iDum2, &iPos);
					for (pDef = pCsr->pDeferred; pDef && rc == SQLITE_OK; pDef = pDef->pNext) {
						Fts3PhraseToken *pPT = pDef->pToken;
						if ((pDef->iCol >= p->nColumn || pDef->iCol == i)
							&& (pPT->bFirst == 0 || iPos == 0)
							&& (pPT->n == nToken || (pPT->isPrefix && pPT->n<nToken))
							&& (0 == memcmp(zToken, pPT->z, pPT->n))
							) {
							fts3PendingListAppend(&pDef->pList, iDocid, i, iPos, &rc);
						}
					}
				}
				if (pTC) pModule->xClose(pTC);
				if (rc == SQLITE_DONE) rc = SQLITE_OK;
			}
		}

		for (pDef = pCsr->pDeferred; pDef && rc == SQLITE_OK; pDef = pDef->pNext) {
			if (pDef->pList) {
				rc = fts3PendingListAppendVarint(&pDef->pList, 0);
			}
		}
	}

	return rc;
}

SQLITE_PRIVATE int sqlite3Fts3DeferredTokenList(
	Fts3DeferredToken *p,
	char **ppData,
	int *pnData
) {
	char *pRet;
	int nSkip;
	sqlite3_int64 dummy;

	*ppData = 0;
	*pnData = 0;

	if (p->pList == 0) {
		return SQLITE_OK;
	}

	pRet = (char *)sqlite3_malloc(p->pList->nData);
	if (!pRet) return SQLITE_NOMEM;

	nSkip = sqlite3Fts3GetVarint(p->pList->aData, &dummy);
	*pnData = p->pList->nData - nSkip;
	*ppData = pRet;

	memcpy(pRet, &p->pList->aData[nSkip], *pnData);
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3Fts3DeferToken(
	Fts3Cursor *pCsr,               
	Fts3PhraseToken *pToken,        
	int iCol                        
) {
	Fts3DeferredToken *pDeferred;
	pDeferred = sqlite3_malloc(sizeof(*pDeferred));
	if (!pDeferred) {
		return SQLITE_NOMEM;
	}
	memset(pDeferred, 0, sizeof(*pDeferred));
	pDeferred->pToken = pToken;
	pDeferred->pNext = pCsr->pDeferred;
	pDeferred->iCol = iCol;
	pCsr->pDeferred = pDeferred;

	assert(pToken->pDeferred == 0);
	pToken->pDeferred = pDeferred;

	return SQLITE_OK;
}
#endif


static int fts3DeleteByRowid(
	Fts3Table *p,
	sqlite3_value *pRowid,
	int *pnChng,                    
	u32 *aSzDel
) {
	int rc = SQLITE_OK;             
	int bFound = 0;                 

	fts3DeleteTerms(&rc, p, pRowid, aSzDel, &bFound);
	if (bFound && rc == SQLITE_OK) {
		int isEmpty = 0;              
		rc = fts3IsEmpty(p, pRowid, &isEmpty);
		if (rc == SQLITE_OK) {
			if (isEmpty) {
				
				rc = fts3DeleteAll(p, 1);
				*pnChng = 0;
				memset(aSzDel, 0, sizeof(u32) * (p->nColumn + 1) * 2);
			}
			else {
				*pnChng = *pnChng - 1;
				if (p->zContentTbl == 0) {
					fts3SqlExec(&rc, p, SQL_DELETE_CONTENT, &pRowid);
				}
				if (p->bHasDocsize) {
					fts3SqlExec(&rc, p, SQL_DELETE_DOCSIZE, &pRowid);
				}
			}
		}
	}

	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(
	sqlite3_vtab *pVtab,            
	int nArg,                       
	sqlite3_value **apVal,          
	sqlite_int64 *pRowid            
) {
	Fts3Table *p = (Fts3Table *)pVtab;
	int rc = SQLITE_OK;             
	int isRemove = 0;               
	u32 *aSzIns = 0;                
	u32 *aSzDel = 0;                
	int nChng = 0;                  
	int bInsertDone = 0;

	
	assert(p->bHasStat == 0 || p->bHasStat == 1);

	assert(p->pSegments == 0);
	assert(
		nArg == 1                     
		|| nArg == (2 + p->nColumn + 3)  
	);

	
	if (nArg>1
		&& sqlite3_value_type(apVal[0]) == SQLITE_NULL
		&& sqlite3_value_type(apVal[p->nColumn + 2]) != SQLITE_NULL
		) {
		rc = fts3SpecialInsert(p, apVal[p->nColumn + 2]);
		goto update_out;
	}

	if (nArg>1 && sqlite3_value_int(apVal[2 + p->nColumn + 2])<0) {
		rc = SQLITE_CONSTRAINT;
		goto update_out;
	}

	
	aSzDel = sqlite3_malloc(sizeof(aSzDel[0])*(p->nColumn + 1) * 2);
	if (aSzDel == 0) {
		rc = SQLITE_NOMEM;
		goto update_out;
	}
	aSzIns = &aSzDel[p->nColumn + 1];
	memset(aSzDel, 0, sizeof(aSzDel[0])*(p->nColumn + 1) * 2);

	rc = fts3Writelock(p);
	if (rc != SQLITE_OK) goto update_out;

	
	if (nArg>1 && p->zContentTbl == 0) {
		
		sqlite3_value *pNewRowid = apVal[3 + p->nColumn];
		if (sqlite3_value_type(pNewRowid) == SQLITE_NULL) {
			pNewRowid = apVal[1];
		}

		if (sqlite3_value_type(pNewRowid) != SQLITE_NULL && (
			sqlite3_value_type(apVal[0]) == SQLITE_NULL
			|| sqlite3_value_int64(apVal[0]) != sqlite3_value_int64(pNewRowid)
			)) {
			
			if (sqlite3_vtab_on_conflict(p->db) == SQLITE_REPLACE) {
				rc = fts3DeleteByRowid(p, pNewRowid, &nChng, aSzDel);
			}
			else {
				rc = fts3InsertData(p, apVal, pRowid);
				bInsertDone = 1;
			}
		}
	}
	if (rc != SQLITE_OK) {
		goto update_out;
	}

	
	if (sqlite3_value_type(apVal[0]) != SQLITE_NULL) {
		assert(sqlite3_value_type(apVal[0]) == SQLITE_INTEGER);
		rc = fts3DeleteByRowid(p, apVal[0], &nChng, aSzDel);
		isRemove = 1;
	}

	
	if (nArg>1 && rc == SQLITE_OK) {
		int iLangid = sqlite3_value_int(apVal[2 + p->nColumn + 2]);
		if (bInsertDone == 0) {
			rc = fts3InsertData(p, apVal, pRowid);
			if (rc == SQLITE_CONSTRAINT && p->zContentTbl == 0) {
				rc = FTS_CORRUPT_VTAB;
			}
		}
		if (rc == SQLITE_OK && (!isRemove || *pRowid != p->iPrevDocid)) {
			rc = fts3PendingTermsDocid(p, 0, iLangid, *pRowid);
		}
		if (rc == SQLITE_OK) {
			assert(p->iPrevDocid == *pRowid);
			rc = fts3InsertTerms(p, iLangid, apVal, aSzIns);
		}
		if (p->bHasDocsize) {
			fts3InsertDocsize(&rc, p, aSzIns);
		}
		nChng++;
	}

	if (p->bFts4) {
		fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nChng);
	}

update_out:
	sqlite3_free(aSzDel);
	sqlite3Fts3SegmentsClose(p);
	return rc;
}


SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p) {
	int rc;
	rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
	if (rc == SQLITE_OK) {
		rc = fts3DoOptimize(p, 1);
		if (rc == SQLITE_OK || rc == SQLITE_DONE) {
			int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
			if (rc2 != SQLITE_OK) rc = rc2;
		}
		else {
			sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
			sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
		}
	}
	sqlite3Fts3SegmentsClose(p);
	return rc;
}

#endif






#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)





#define FTS3_MATCHINFO_NPHRASE   'p'        
#define FTS3_MATCHINFO_NCOL      'c'        
#define FTS3_MATCHINFO_NDOC      'n'        
#define FTS3_MATCHINFO_AVGLENGTH 'a'        
#define FTS3_MATCHINFO_LENGTH    'l'        
#define FTS3_MATCHINFO_LCS       's'        
#define FTS3_MATCHINFO_HITS      'x'        
#define FTS3_MATCHINFO_LHITS     'y'        
#define FTS3_MATCHINFO_LHITS_BM  'b'        


#define FTS3_MATCHINFO_DEFAULT   "pcx"



typedef struct LoadDoclistCtx LoadDoclistCtx;
struct LoadDoclistCtx {
	Fts3Cursor *pCsr;               
	int nPhrase;                    
	int nToken;                     
};


typedef struct SnippetIter SnippetIter;
typedef struct SnippetPhrase SnippetPhrase;
typedef struct SnippetFragment SnippetFragment;

struct SnippetIter {
	Fts3Cursor *pCsr;               
	int iCol;                       
	int nSnippet;                   
	int nPhrase;                    
	SnippetPhrase *aPhrase;         
	int iCurrent;                   
};

struct SnippetPhrase {
	int nToken;                     
	char *pList;                    
	int iHead;                      
	char *pHead;                    
	int iTail;                      
	char *pTail;                    
};

struct SnippetFragment {
	int iCol;                       
	int iPos;                       
	u64 covered;                    
	u64 hlmask;                     
};


typedef struct MatchInfo MatchInfo;
struct MatchInfo {
	Fts3Cursor *pCursor;            
	int nCol;                       
	int nPhrase;                    
	sqlite3_int64 nDoc;             
	char flag;
	u32 *aMatchinfo;                
};


struct MatchinfoBuffer {
	u8 aRef[3];
	int nElem;
	int bGlobal;                    
	char *zMatchinfo;
	u32 aMatchinfo[1];
};



typedef struct StrBuffer StrBuffer;
struct StrBuffer {
	char *z;                        
	int n;                          
	int nAlloc;                     
};





static MatchinfoBuffer *fts3MIBufferNew(int nElem, const char *zMatchinfo) {
	MatchinfoBuffer *pRet;
	int nByte = sizeof(u32) * (2 * nElem + 1) + sizeof(MatchinfoBuffer);
	int nStr = (int)strlen(zMatchinfo);

	pRet = sqlite3_malloc(nByte + nStr + 1);
	if (pRet) {
		memset(pRet, 0, nByte);
		pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;
		pRet->aMatchinfo[1 + nElem] = pRet->aMatchinfo[0] + sizeof(u32)*(nElem + 1);
		pRet->nElem = nElem;
		pRet->zMatchinfo = ((char*)pRet) + nByte;
		memcpy(pRet->zMatchinfo, zMatchinfo, nStr + 1);
		pRet->aRef[0] = 1;
	}

	return pRet;
}

static void fts3MIBufferFree(void *p) {
	MatchinfoBuffer *pBuf = (MatchinfoBuffer*)((u8*)p - ((u32*)p)[-1]);

	assert((u32*)p == &pBuf->aMatchinfo[1]
		|| (u32*)p == &pBuf->aMatchinfo[pBuf->nElem + 2]
	);
	if ((u32*)p == &pBuf->aMatchinfo[1]) {
		pBuf->aRef[1] = 0;
	}
	else {
		pBuf->aRef[2] = 0;
	}

	if (pBuf->aRef[0] == 0 && pBuf->aRef[1] == 0 && pBuf->aRef[2] == 0) {
		sqlite3_free(pBuf);
	}
}

static void(*fts3MIBufferAlloc(MatchinfoBuffer *p, u32 **paOut))(void*) {
	void(*xRet)(void*) = 0;
	u32 *aOut = 0;

	if (p->aRef[1] == 0) {
		p->aRef[1] = 1;
		aOut = &p->aMatchinfo[1];
		xRet = fts3MIBufferFree;
	}
	else if (p->aRef[2] == 0) {
		p->aRef[2] = 1;
		aOut = &p->aMatchinfo[p->nElem + 2];
		xRet = fts3MIBufferFree;
	}
	else {
		aOut = (u32*)sqlite3_malloc(p->nElem * sizeof(u32));
		if (aOut) {
			xRet = sqlite3_free;
			if (p->bGlobal) memcpy(aOut, &p->aMatchinfo[1], p->nElem * sizeof(u32));
		}
	}

	*paOut = aOut;
	return xRet;
}

static void fts3MIBufferSetGlobal(MatchinfoBuffer *p) {
	p->bGlobal = 1;
	memcpy(&p->aMatchinfo[2 + p->nElem], &p->aMatchinfo[1], p->nElem * sizeof(u32));
}


SQLITE_PRIVATE void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p) {
	if (p) {
		assert(p->aRef[0] == 1);
		p->aRef[0] = 0;
		if (p->aRef[0] == 0 && p->aRef[1] == 0 && p->aRef[2] == 0) {
			sqlite3_free(p);
		}
	}
}





static void fts3GetDeltaPosition(char **pp, int *piPos) {
	int iVal;
	*pp += fts3GetVarint32(*pp, &iVal);
	*piPos += (iVal - 2);
}


static int fts3ExprIterate2(
	Fts3Expr *pExpr,                
	int *piPhrase,                  
	int(*x)(Fts3Expr*, int, void*),  
	void *pCtx                      
) {
	int rc;                         
	int eType = pExpr->eType;     

	if (eType != FTSQUERY_PHRASE) {
		assert(pExpr->pLeft && pExpr->pRight);
		rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);
		if (rc == SQLITE_OK && eType != FTSQUERY_NOT) {
			rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);
		}
	}
	else {
		rc = x(pExpr, *piPhrase, pCtx);
		(*piPhrase)++;
	}
	return rc;
}


static int fts3ExprIterate(
	Fts3Expr *pExpr,                
	int(*x)(Fts3Expr*, int, void*),  
	void *pCtx                      
) {
	int iPhrase = 0;                
	return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx);
}



static int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx) {
	int rc = SQLITE_OK;
	Fts3Phrase *pPhrase = pExpr->pPhrase;
	LoadDoclistCtx *p = (LoadDoclistCtx *)ctx;

	UNUSED_PARAMETER(iPhrase);

	p->nPhrase++;
	p->nToken += pPhrase->nToken;

	return rc;
}


static int fts3ExprLoadDoclists(
	Fts3Cursor *pCsr,               
	int *pnPhrase,                  
	int *pnToken                    
) {
	int rc;                         
	LoadDoclistCtx sCtx = { 0,0,0 };  
	sCtx.pCsr = pCsr;
	rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);
	if (pnPhrase) *pnPhrase = sCtx.nPhrase;
	if (pnToken) *pnToken = sCtx.nToken;
	return rc;
}

static int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx) {
	(*(int *)ctx)++;
	pExpr->iPhrase = iPhrase;
	return SQLITE_OK;
}
static int fts3ExprPhraseCount(Fts3Expr *pExpr) {
	int nPhrase = 0;
	(void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);
	return nPhrase;
}


static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext) {
	char *pIter = *ppIter;
	if (pIter) {
		int iIter = *piIter;

		while (iIter<iNext) {
			if (0 == (*pIter & 0xFE)) {
				iIter = -1;
				pIter = 0;
				break;
			}
			fts3GetDeltaPosition(&pIter, &iIter);
		}

		*piIter = iIter;
		*ppIter = pIter;
	}
}


static int fts3SnippetNextCandidate(SnippetIter *pIter) {
	int i;                          

	if (pIter->iCurrent<0) {
		
		pIter->iCurrent = 0;

		
		for (i = 0; i<pIter->nPhrase; i++) {
			SnippetPhrase *pPhrase = &pIter->aPhrase[i];
			fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);
		}
	}
	else {
		int iStart;
		int iEnd = 0x7FFFFFFF;

		for (i = 0; i<pIter->nPhrase; i++) {
			SnippetPhrase *pPhrase = &pIter->aPhrase[i];
			if (pPhrase->pHead && pPhrase->iHead<iEnd) {
				iEnd = pPhrase->iHead;
			}
		}
		if (iEnd == 0x7FFFFFFF) {
			return 1;
		}

		pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;
		for (i = 0; i<pIter->nPhrase; i++) {
			SnippetPhrase *pPhrase = &pIter->aPhrase[i];
			fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1);
			fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
		}
	}

	return 0;
}


static void fts3SnippetDetails(
	SnippetIter *pIter,             
	u64 mCovered,                   
	int *piToken,                   
	int *piScore,                   
	u64 *pmCover,                   
	u64 *pmHighlight                
) {
	int iStart = pIter->iCurrent;   
	int iScore = 0;                 
	int i;                          
	u64 mCover = 0;                 
	u64 mHighlight = 0;             

	for (i = 0; i<pIter->nPhrase; i++) {
		SnippetPhrase *pPhrase = &pIter->aPhrase[i];
		if (pPhrase->pTail) {
			char *pCsr = pPhrase->pTail;
			int iCsr = pPhrase->iTail;

			while (iCsr<(iStart + pIter->nSnippet)) {
				int j;
				u64 mPhrase = (u64)1 << i;
				u64 mPos = (u64)1 << (iCsr - iStart);
				assert(iCsr >= iStart);
				if ((mCover | mCovered)&mPhrase) {
					iScore++;
				}
				else {
					iScore += 1000;
				}
				mCover |= mPhrase;

				for (j = 0; j<pPhrase->nToken; j++) {
					mHighlight |= (mPos >> j);
				}

				if (0 == (*pCsr & 0x0FE)) break;
				fts3GetDeltaPosition(&pCsr, &iCsr);
			}
		}
	}

	
	*piToken = iStart;
	*piScore = iScore;
	*pmCover = mCover;
	*pmHighlight = mHighlight;
}


static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx) {
	SnippetIter *p = (SnippetIter *)ctx;
	SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];
	char *pCsr;
	int rc;

	pPhrase->nToken = pExpr->pPhrase->nToken;
	rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pCsr);
	assert(rc == SQLITE_OK || pCsr == 0);
	if (pCsr) {
		int iFirst = 0;
		pPhrase->pList = pCsr;
		fts3GetDeltaPosition(&pCsr, &iFirst);
		assert(iFirst >= 0);
		pPhrase->pHead = pCsr;
		pPhrase->pTail = pCsr;
		pPhrase->iHead = iFirst;
		pPhrase->iTail = iFirst;
	}
	else {
		assert(rc != SQLITE_OK || (
			pPhrase->pList == 0 && pPhrase->pHead == 0 && pPhrase->pTail == 0
			));
	}

	return rc;
}


static int fts3BestSnippet(
	int nSnippet,                   
	Fts3Cursor *pCsr,               
	int iCol,                       
	u64 mCovered,                   
	u64 *pmSeen,                    
	SnippetFragment *pFragment,     
	int *piScore                    
) {
	int rc;                         
	int nList;                      
	SnippetIter sIter;              
	int nByte;                      
	int iBestScore = -1;            
	int i;                          

	memset(&sIter, 0, sizeof(sIter));

	
	rc = fts3ExprLoadDoclists(pCsr, &nList, 0);
	if (rc != SQLITE_OK) {
		return rc;
	}

	
	nByte = sizeof(SnippetPhrase) * nList;
	sIter.aPhrase = (SnippetPhrase *)sqlite3_malloc(nByte);
	if (!sIter.aPhrase) {
		return SQLITE_NOMEM;
	}
	memset(sIter.aPhrase, 0, nByte);

	
	sIter.pCsr = pCsr;
	sIter.iCol = iCol;
	sIter.nSnippet = nSnippet;
	sIter.nPhrase = nList;
	sIter.iCurrent = -1;
	rc = fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void*)&sIter);
	if (rc == SQLITE_OK) {

		
		for (i = 0; i<nList; i++) {
			if (sIter.aPhrase[i].pHead) {
				*pmSeen |= (u64)1 << i;
			}
		}

		
		pFragment->iCol = iCol;
		while (!fts3SnippetNextCandidate(&sIter)) {
			int iPos;
			int iScore;
			u64 mCover;
			u64 mHighlite;
			fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover, &mHighlite);
			assert(iScore >= 0);
			if (iScore>iBestScore) {
				pFragment->iPos = iPos;
				pFragment->hlmask = mHighlite;
				pFragment->covered = mCover;
				iBestScore = iScore;
			}
		}

		*piScore = iBestScore;
	}
	sqlite3_free(sIter.aPhrase);
	return rc;
}



static int fts3StringAppend(
	StrBuffer *pStr,                
	const char *zAppend,            
	int nAppend                     
) {
	if (nAppend<0) {
		nAppend = (int)strlen(zAppend);
	}

	
	if (pStr->n + nAppend + 1 >= pStr->nAlloc) {
		int nAlloc = pStr->nAlloc + nAppend + 100;
		char *zNew = sqlite3_realloc(pStr->z, nAlloc);
		if (!zNew) {
			return SQLITE_NOMEM;
		}
		pStr->z = zNew;
		pStr->nAlloc = nAlloc;
	}
	assert(pStr->z != 0 && (pStr->nAlloc >= pStr->n + nAppend + 1));

	
	memcpy(&pStr->z[pStr->n], zAppend, nAppend);
	pStr->n += nAppend;
	pStr->z[pStr->n] = '\0';

	return SQLITE_OK;
}


static int fts3SnippetShift(
	Fts3Table *pTab,                
	int iLangid,                    
	int nSnippet,                   
	const char *zDoc,               
	int nDoc,                       
	int *piPos,                     
	u64 *pHlmask                    
) {
	u64 hlmask = *pHlmask;          

	if (hlmask) {
		int nLeft;                    
		int nRight;                   
		int nDesired;                 

		for (nLeft = 0; !(hlmask & ((u64)1 << nLeft)); nLeft++);
		for (nRight = 0; !(hlmask & ((u64)1 << (nSnippet - 1 - nRight))); nRight++);
		nDesired = (nLeft - nRight) / 2;

		
		if (nDesired>0) {
			int nShift;                 
			int iCurrent = 0;           
			int rc;                     
			sqlite3_tokenizer_module *pMod;
			sqlite3_tokenizer_cursor *pC;
			pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;

			
			rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, iLangid, zDoc, nDoc, &pC);
			if (rc != SQLITE_OK) {
				return rc;
			}
			while (rc == SQLITE_OK && iCurrent<(nSnippet + nDesired)) {
				const char *ZDUMMY; int DUMMY1 = 0, DUMMY2 = 0, DUMMY3 = 0;
				rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &DUMMY2, &DUMMY3, &iCurrent);
			}
			pMod->xClose(pC);
			if (rc != SQLITE_OK && rc != SQLITE_DONE) { return rc; }

			nShift = (rc == SQLITE_DONE) + iCurrent - nSnippet;
			assert(nShift <= nDesired);
			if (nShift>0) {
				*piPos += nShift;
				*pHlmask = hlmask >> nShift;
			}
		}
	}
	return SQLITE_OK;
}


static int fts3SnippetText(
	Fts3Cursor *pCsr,               
	SnippetFragment *pFragment,     
	int iFragment,                  
	int isLast,                     
	int nSnippet,                   
	const char *zOpen,              
	const char *zClose,             
	const char *zEllipsis,          
	StrBuffer *pOut                 
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc;                         
	const char *zDoc;               
	int nDoc;                       
	int iCurrent = 0;               
	int iEnd = 0;                   
	int isShiftDone = 0;            
	int iPos = pFragment->iPos;     
	u64 hlmask = pFragment->hlmask; 
	int iCol = pFragment->iCol + 1;   
	sqlite3_tokenizer_module *pMod; 
	sqlite3_tokenizer_cursor *pC;   

	zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol);
	if (zDoc == 0) {
		if (sqlite3_column_type(pCsr->pStmt, iCol) != SQLITE_NULL) {
			return SQLITE_NOMEM;
		}
		return SQLITE_OK;
	}
	nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol);

	
	pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;
	rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid, zDoc, nDoc, &pC);
	if (rc != SQLITE_OK) {
		return rc;
	}

	while (rc == SQLITE_OK) {
		const char *ZDUMMY;           
		int DUMMY1 = -1;              
		int iBegin = 0;               
		int iFin = 0;                 
		int isHighlight = 0;          

									  
		rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &iBegin, &iFin, &iCurrent);
		if (rc != SQLITE_OK) {
			if (rc == SQLITE_DONE) {
				
				rc = fts3StringAppend(pOut, &zDoc[iEnd], -1);
			}
			break;
		}
		if (iCurrent<iPos) { continue; }

		if (!isShiftDone) {
			int n = nDoc - iBegin;
			rc = fts3SnippetShift(
				pTab, pCsr->iLangid, nSnippet, &zDoc[iBegin], n, &iPos, &hlmask
			);
			isShiftDone = 1;

			
			if (rc == SQLITE_OK) {
				if (iPos>0 || iFragment>0) {
					rc = fts3StringAppend(pOut, zEllipsis, -1);
				}
				else if (iBegin) {
					rc = fts3StringAppend(pOut, zDoc, iBegin);
				}
			}
			if (rc != SQLITE_OK || iCurrent<iPos) continue;
		}

		if (iCurrent >= (iPos + nSnippet)) {
			if (isLast) {
				rc = fts3StringAppend(pOut, zEllipsis, -1);
			}
			break;
		}

		
		isHighlight = (hlmask & ((u64)1 << (iCurrent - iPos))) != 0;

		if (iCurrent>iPos) rc = fts3StringAppend(pOut, &zDoc[iEnd], iBegin - iEnd);
		if (rc == SQLITE_OK && isHighlight) rc = fts3StringAppend(pOut, zOpen, -1);
		if (rc == SQLITE_OK) rc = fts3StringAppend(pOut, &zDoc[iBegin], iFin - iBegin);
		if (rc == SQLITE_OK && isHighlight) rc = fts3StringAppend(pOut, zClose, -1);

		iEnd = iFin;
	}

	pMod->xClose(pC);
	return rc;
}



static int fts3ColumnlistCount(char **ppCollist) {
	char *pEnd = *ppCollist;
	char c = 0;
	int nEntry = 0;

	
	while (0xFE & (*pEnd | c)) {
		c = *pEnd++ & 0x80;
		if (!c) nEntry++;
	}

	*ppCollist = pEnd;
	return nEntry;
}


static void fts3ExprLHits(
	Fts3Expr *pExpr,                
	MatchInfo *p                    
) {
	Fts3Table *pTab = (Fts3Table *)p->pCursor->base.pVtab;
	int iStart;
	Fts3Phrase *pPhrase = pExpr->pPhrase;
	char *pIter = pPhrase->doclist.pList;
	int iCol = 0;

	assert(p->flag == FTS3_MATCHINFO_LHITS_BM || p->flag == FTS3_MATCHINFO_LHITS);
	if (p->flag == FTS3_MATCHINFO_LHITS) {
		iStart = pExpr->iPhrase * p->nCol;
	}
	else {
		iStart = pExpr->iPhrase * ((p->nCol + 31) / 32);
	}

	while (1) {
		int nHit = fts3ColumnlistCount(&pIter);
		if ((pPhrase->iColumn >= pTab->nColumn || pPhrase->iColumn == iCol)) {
			if (p->flag == FTS3_MATCHINFO_LHITS) {
				p->aMatchinfo[iStart + iCol] = (u32)nHit;
			}
			else if (nHit) {
				p->aMatchinfo[iStart + (iCol + 1) / 32] |= (1 << (iCol & 0x1F));
			}
		}
		assert(*pIter == 0x00 || *pIter == 0x01);
		if (*pIter != 0x01) break;
		pIter++;
		pIter += fts3GetVarint32(pIter, &iCol);
	}
}


static void fts3ExprLHitGather(
	Fts3Expr *pExpr,
	MatchInfo *p
) {
	assert((pExpr->pLeft == 0) == (pExpr->pRight == 0));
	if (pExpr->bEof == 0 && pExpr->iDocid == p->pCursor->iPrevId) {
		if (pExpr->pLeft) {
			fts3ExprLHitGather(pExpr->pLeft, p);
			fts3ExprLHitGather(pExpr->pRight, p);
		}
		else {
			fts3ExprLHits(pExpr, p);
		}
	}
}


static int fts3ExprGlobalHitsCb(
	Fts3Expr *pExpr,                
	int iPhrase,                    
	void *pCtx                      
) {
	MatchInfo *p = (MatchInfo *)pCtx;
	return sqlite3Fts3EvalPhraseStats(
		p->pCursor, pExpr, &p->aMatchinfo[3 * iPhrase*p->nCol]
	);
}


static int fts3ExprLocalHitsCb(
	Fts3Expr *pExpr,                
	int iPhrase,                    
	void *pCtx                      
) {
	int rc = SQLITE_OK;
	MatchInfo *p = (MatchInfo *)pCtx;
	int iStart = iPhrase * p->nCol * 3;
	int i;

	for (i = 0; i<p->nCol && rc == SQLITE_OK; i++) {
		char *pCsr;
		rc = sqlite3Fts3EvalPhrasePoslist(p->pCursor, pExpr, i, &pCsr);
		if (pCsr) {
			p->aMatchinfo[iStart + i * 3] = fts3ColumnlistCount(&pCsr);
		}
		else {
			p->aMatchinfo[iStart + i * 3] = 0;
		}
	}

	return rc;
}

static int fts3MatchinfoCheck(
	Fts3Table *pTab,
	char cArg,
	char **pzErr
) {
	if ((cArg == FTS3_MATCHINFO_NPHRASE)
		|| (cArg == FTS3_MATCHINFO_NCOL)
		|| (cArg == FTS3_MATCHINFO_NDOC && pTab->bFts4)
		|| (cArg == FTS3_MATCHINFO_AVGLENGTH && pTab->bFts4)
		|| (cArg == FTS3_MATCHINFO_LENGTH && pTab->bHasDocsize)
		|| (cArg == FTS3_MATCHINFO_LCS)
		|| (cArg == FTS3_MATCHINFO_HITS)
		|| (cArg == FTS3_MATCHINFO_LHITS)
		|| (cArg == FTS3_MATCHINFO_LHITS_BM)
		) {
		return SQLITE_OK;
	}
	sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo request: %c", cArg);
	return SQLITE_ERROR;
}

static int fts3MatchinfoSize(MatchInfo *pInfo, char cArg) {
	int nVal;                       

	switch (cArg) {
	case FTS3_MATCHINFO_NDOC:
	case FTS3_MATCHINFO_NPHRASE:
	case FTS3_MATCHINFO_NCOL:
		nVal = 1;
		break;

	case FTS3_MATCHINFO_AVGLENGTH:
	case FTS3_MATCHINFO_LENGTH:
	case FTS3_MATCHINFO_LCS:
		nVal = pInfo->nCol;
		break;

	case FTS3_MATCHINFO_LHITS:
		nVal = pInfo->nCol * pInfo->nPhrase;
		break;

	case FTS3_MATCHINFO_LHITS_BM:
		nVal = pInfo->nPhrase * ((pInfo->nCol + 31) / 32);
		break;

	default:
		assert(cArg == FTS3_MATCHINFO_HITS);
		nVal = pInfo->nCol * pInfo->nPhrase * 3;
		break;
	}

	return nVal;
}

static int fts3MatchinfoSelectDoctotal(
	Fts3Table *pTab,
	sqlite3_stmt **ppStmt,
	sqlite3_int64 *pnDoc,
	const char **paLen
) {
	sqlite3_stmt *pStmt;
	const char *a;
	sqlite3_int64 nDoc;

	if (!*ppStmt) {
		int rc = sqlite3Fts3SelectDoctotal(pTab, ppStmt);
		if (rc != SQLITE_OK) return rc;
	}
	pStmt = *ppStmt;
	assert(sqlite3_data_count(pStmt) == 1);

	a = sqlite3_column_blob(pStmt, 0);
	a += sqlite3Fts3GetVarint(a, &nDoc);
	if (nDoc == 0) return FTS_CORRUPT_VTAB;
	*pnDoc = (u32)nDoc;

	if (paLen) *paLen = a;
	return SQLITE_OK;
}


typedef struct LcsIterator LcsIterator;
struct LcsIterator {
	Fts3Expr *pExpr;                
	int iPosOffset;                 
	char *pRead;                    
	int iPos;                       
};


#define LCS_ITERATOR_FINISHED 0x7FFFFFFF;

static int fts3MatchinfoLcsCb(
	Fts3Expr *pExpr,                
	int iPhrase,                    
	void *pCtx                      
) {
	LcsIterator *aIter = (LcsIterator *)pCtx;
	aIter[iPhrase].pExpr = pExpr;
	return SQLITE_OK;
}


static int fts3LcsIteratorAdvance(LcsIterator *pIter) {
	char *pRead = pIter->pRead;
	sqlite3_int64 iRead;
	int rc = 0;

	pRead += sqlite3Fts3GetVarint(pRead, &iRead);
	if (iRead == 0 || iRead == 1) {
		pRead = 0;
		rc = 1;
	}
	else {
		pIter->iPos += (int)(iRead - 2);
	}

	pIter->pRead = pRead;
	return rc;
}


static int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo) {
	LcsIterator *aIter;
	int i;
	int iCol;
	int nToken = 0;

	
	aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);
	if (!aIter) return SQLITE_NOMEM;
	memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);
	(void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);

	for (i = 0; i<pInfo->nPhrase; i++) {
		LcsIterator *pIter = &aIter[i];
		nToken -= pIter->pExpr->pPhrase->nToken;
		pIter->iPosOffset = nToken;
	}

	for (iCol = 0; iCol<pInfo->nCol; iCol++) {
		int nLcs = 0;                 
		int nLive = 0;                

		for (i = 0; i<pInfo->nPhrase; i++) {
			int rc;
			LcsIterator *pIt = &aIter[i];
			rc = sqlite3Fts3EvalPhrasePoslist(pCsr, pIt->pExpr, iCol, &pIt->pRead);
			if (rc != SQLITE_OK) return rc;
			if (pIt->pRead) {
				pIt->iPos = pIt->iPosOffset;
				fts3LcsIteratorAdvance(&aIter[i]);
				nLive++;
			}
		}

		while (nLive>0) {
			LcsIterator *pAdv = 0;      
			int nThisLcs = 0;           

			for (i = 0; i<pInfo->nPhrase; i++) {
				LcsIterator *pIter = &aIter[i];
				if (pIter->pRead == 0) {
					
					nThisLcs = 0;
				}
				else {
					if (pAdv == 0 || pIter->iPos<pAdv->iPos) {
						pAdv = pIter;
					}
					if (nThisLcs == 0 || pIter->iPos == pIter[-1].iPos) {
						nThisLcs++;
					}
					else {
						nThisLcs = 1;
					}
					if (nThisLcs>nLcs) nLcs = nThisLcs;
				}
			}
			if (fts3LcsIteratorAdvance(pAdv)) nLive--;
		}

		pInfo->aMatchinfo[iCol] = nLcs;
	}

	sqlite3_free(aIter);
	return SQLITE_OK;
}


static int fts3MatchinfoValues(
	Fts3Cursor *pCsr,               
	int bGlobal,                    
	MatchInfo *pInfo,               
	const char *zArg                
) {
	int rc = SQLITE_OK;
	int i;
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	sqlite3_stmt *pSelect = 0;

	for (i = 0; rc == SQLITE_OK && zArg[i]; i++) {
		pInfo->flag = zArg[i];
		switch (zArg[i]) {
		case FTS3_MATCHINFO_NPHRASE:
			if (bGlobal) pInfo->aMatchinfo[0] = pInfo->nPhrase;
			break;

		case FTS3_MATCHINFO_NCOL:
			if (bGlobal) pInfo->aMatchinfo[0] = pInfo->nCol;
			break;

		case FTS3_MATCHINFO_NDOC:
			if (bGlobal) {
				sqlite3_int64 nDoc = 0;
				rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, 0);
				pInfo->aMatchinfo[0] = (u32)nDoc;
			}
			break;

		case FTS3_MATCHINFO_AVGLENGTH:
			if (bGlobal) {
				sqlite3_int64 nDoc;     
				const char *a;          

				rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, &a);
				if (rc == SQLITE_OK) {
					int iCol;
					for (iCol = 0; iCol<pInfo->nCol; iCol++) {
						u32 iVal;
						sqlite3_int64 nToken;
						a += sqlite3Fts3GetVarint(a, &nToken);
						iVal = (u32)(((u32)(nToken & 0xffffffff) + nDoc / 2) / nDoc);
						pInfo->aMatchinfo[iCol] = iVal;
					}
				}
			}
			break;

		case FTS3_MATCHINFO_LENGTH: {
			sqlite3_stmt *pSelectDocsize = 0;
			rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, &pSelectDocsize);
			if (rc == SQLITE_OK) {
				int iCol;
				const char *a = sqlite3_column_blob(pSelectDocsize, 0);
				for (iCol = 0; iCol<pInfo->nCol; iCol++) {
					sqlite3_int64 nToken;
					a += sqlite3Fts3GetVarint(a, &nToken);
					pInfo->aMatchinfo[iCol] = (u32)nToken;
				}
			}
			sqlite3_reset(pSelectDocsize);
			break;
		}

		case FTS3_MATCHINFO_LCS:
			rc = fts3ExprLoadDoclists(pCsr, 0, 0);
			if (rc == SQLITE_OK) {
				rc = fts3MatchinfoLcs(pCsr, pInfo);
			}
			break;

		case FTS3_MATCHINFO_LHITS_BM:
		case FTS3_MATCHINFO_LHITS: {
			int nZero = fts3MatchinfoSize(pInfo, zArg[i]) * sizeof(u32);
			memset(pInfo->aMatchinfo, 0, nZero);
			fts3ExprLHitGather(pCsr->pExpr, pInfo);
			break;
		}

		default: {
			Fts3Expr *pExpr;
			assert(zArg[i] == FTS3_MATCHINFO_HITS);
			pExpr = pCsr->pExpr;
			rc = fts3ExprLoadDoclists(pCsr, 0, 0);
			if (rc != SQLITE_OK) break;
			if (bGlobal) {
				if (pCsr->pDeferred) {
					rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &pInfo->nDoc, 0);
					if (rc != SQLITE_OK) break;
				}
				rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb, (void*)pInfo);
				sqlite3Fts3EvalTestDeferred(pCsr, &rc);
				if (rc != SQLITE_OK) break;
			}
			(void)fts3ExprIterate(pExpr, fts3ExprLocalHitsCb, (void*)pInfo);
			break;
		}
		}

		pInfo->aMatchinfo += fts3MatchinfoSize(pInfo, zArg[i]);
	}

	sqlite3_reset(pSelect);
	return rc;
}



static void fts3GetMatchinfo(
	sqlite3_context *pCtx,        
	Fts3Cursor *pCsr,               
	const char *zArg                
) {
	MatchInfo sInfo;
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc = SQLITE_OK;
	int bGlobal = 0;                

	u32 *aOut = 0;
	void(*xDestroyOut)(void*) = 0;

	memset(&sInfo, 0, sizeof(MatchInfo));
	sInfo.pCursor = pCsr;
	sInfo.nCol = pTab->nColumn;

	
	if (pCsr->pMIBuffer && strcmp(pCsr->pMIBuffer->zMatchinfo, zArg)) {
		sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
		pCsr->pMIBuffer = 0;
	}

	
	if (pCsr->pMIBuffer == 0) {
		int nMatchinfo = 0;           
		int i;                        

									  
		pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr);
		sInfo.nPhrase = pCsr->nPhrase;

		
		for (i = 0; zArg[i]; i++) {
			char *zErr = 0;
			if (fts3MatchinfoCheck(pTab, zArg[i], &zErr)) {
				sqlite3_result_error(pCtx, zErr, -1);
				sqlite3_free(zErr);
				return;
			}
			nMatchinfo += fts3MatchinfoSize(&sInfo, zArg[i]);
		}

		
		pCsr->pMIBuffer = fts3MIBufferNew(nMatchinfo, zArg);
		if (!pCsr->pMIBuffer) rc = SQLITE_NOMEM;

		pCsr->isMatchinfoNeeded = 1;
		bGlobal = 1;
	}

	if (rc == SQLITE_OK) {
		xDestroyOut = fts3MIBufferAlloc(pCsr->pMIBuffer, &aOut);
		if (xDestroyOut == 0) {
			rc = SQLITE_NOMEM;
		}
	}

	if (rc == SQLITE_OK) {
		sInfo.aMatchinfo = aOut;
		sInfo.nPhrase = pCsr->nPhrase;
		rc = fts3MatchinfoValues(pCsr, bGlobal, &sInfo, zArg);
		if (bGlobal) {
			fts3MIBufferSetGlobal(pCsr->pMIBuffer);
		}
	}

	if (rc != SQLITE_OK) {
		sqlite3_result_error_code(pCtx, rc);
		if (xDestroyOut) xDestroyOut(aOut);
	}
	else {
		int n = pCsr->pMIBuffer->nElem * sizeof(u32);
		sqlite3_result_blob(pCtx, aOut, n, xDestroyOut);
	}
}


SQLITE_PRIVATE void sqlite3Fts3Snippet(
	sqlite3_context *pCtx,          
	Fts3Cursor *pCsr,               
	const char *zStart,             
	const char *zEnd,               
	const char *zEllipsis,          
	int iCol,                       
	int nToken                      
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	int rc = SQLITE_OK;
	int i;
	StrBuffer res = { 0, 0, 0 };

	
	int nSnippet = 0;               
	SnippetFragment aSnippet[4];    
	int nFToken = -1;               

	if (!pCsr->pExpr) {
		sqlite3_result_text(pCtx, "", 0, SQLITE_STATIC);
		return;
	}

	for (nSnippet = 1; 1; nSnippet++) {

		int iSnip;                    
		u64 mCovered = 0;             
		u64 mSeen = 0;                

		if (nToken >= 0) {
			nFToken = (nToken + nSnippet - 1) / nSnippet;
		}
		else {
			nFToken = -1 * nToken;
		}

		for (iSnip = 0; iSnip<nSnippet; iSnip++) {
			int iBestScore = -1;        
			int iRead;                  
			SnippetFragment *pFragment = &aSnippet[iSnip];

			memset(pFragment, 0, sizeof(*pFragment));

			
			for (iRead = 0; iRead<pTab->nColumn; iRead++) {
				SnippetFragment sF = { 0, 0, 0, 0 };
				int iS = 0;
				if (iCol >= 0 && iRead != iCol) continue;

				
				rc = fts3BestSnippet(nFToken, pCsr, iRead, mCovered, &mSeen, &sF, &iS);
				if (rc != SQLITE_OK) {
					goto snippet_out;
				}
				if (iS>iBestScore) {
					*pFragment = sF;
					iBestScore = iS;
				}
			}

			mCovered |= pFragment->covered;
		}

		
		assert((mCovered&mSeen) == mCovered);
		if (mSeen == mCovered || nSnippet == SizeofArray(aSnippet)) break;
	}

	assert(nFToken>0);

	for (i = 0; i<nSnippet && rc == SQLITE_OK; i++) {
		rc = fts3SnippetText(pCsr, &aSnippet[i],
			i, (i == nSnippet - 1), nFToken, zStart, zEnd, zEllipsis, &res
		);
	}

snippet_out:
	sqlite3Fts3SegmentsClose(pTab);
	if (rc != SQLITE_OK) {
		sqlite3_result_error_code(pCtx, rc);
		sqlite3_free(res.z);
	}
	else {
		sqlite3_result_text(pCtx, res.z, -1, sqlite3_free);
	}
}


typedef struct TermOffset TermOffset;
typedef struct TermOffsetCtx TermOffsetCtx;

struct TermOffset {
	char *pList;                    
	int iPos;                       
	int iOff;                       
};

struct TermOffsetCtx {
	Fts3Cursor *pCsr;
	int iCol;                       
	int iTerm;
	sqlite3_int64 iDocid;
	TermOffset *aTerm;
};


static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx) {
	TermOffsetCtx *p = (TermOffsetCtx *)ctx;
	int nTerm;                      
	int iTerm;                      
	char *pList;                    
	int iPos = 0;                   
	int rc;

	UNUSED_PARAMETER(iPhrase);
	rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pList);
	nTerm = pExpr->pPhrase->nToken;
	if (pList) {
		fts3GetDeltaPosition(&pList, &iPos);
		assert(iPos >= 0);
	}

	for (iTerm = 0; iTerm<nTerm; iTerm++) {
		TermOffset *pT = &p->aTerm[p->iTerm++];
		pT->iOff = nTerm - iTerm - 1;
		pT->pList = pList;
		pT->iPos = iPos;
	}

	return rc;
}


SQLITE_PRIVATE void sqlite3Fts3Offsets(
	sqlite3_context *pCtx,          
	Fts3Cursor *pCsr                
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	sqlite3_tokenizer_module const *pMod = pTab->pTokenizer->pModule;
	int rc;                         
	int nToken;                     
	int iCol;                       
	StrBuffer res = { 0, 0, 0 };      
	TermOffsetCtx sCtx;             

	if (!pCsr->pExpr) {
		sqlite3_result_text(pCtx, "", 0, SQLITE_STATIC);
		return;
	}

	memset(&sCtx, 0, sizeof(sCtx));
	assert(pCsr->isRequireSeek == 0);

	
	rc = fts3ExprLoadDoclists(pCsr, 0, &nToken);
	if (rc != SQLITE_OK) goto offsets_out;

	
	sCtx.aTerm = (TermOffset *)sqlite3_malloc(sizeof(TermOffset)*nToken);
	if (0 == sCtx.aTerm) {
		rc = SQLITE_NOMEM;
		goto offsets_out;
	}
	sCtx.iDocid = pCsr->iPrevId;
	sCtx.pCsr = pCsr;

	
	for (iCol = 0; iCol<pTab->nColumn; iCol++) {
		sqlite3_tokenizer_cursor *pC; 
		const char *ZDUMMY;           
		int NDUMMY = 0;               
		int iStart = 0;
		int iEnd = 0;
		int iCurrent = 0;
		const char *zDoc;
		int nDoc;

		
		sCtx.iCol = iCol;
		sCtx.iTerm = 0;
		(void)fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);

		
		zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol + 1);
		nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol + 1);
		if (zDoc == 0) {
			if (sqlite3_column_type(pCsr->pStmt, iCol + 1) == SQLITE_NULL) {
				continue;
			}
			rc = SQLITE_NOMEM;
			goto offsets_out;
		}

		
		rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid,
			zDoc, nDoc, &pC
		);
		if (rc != SQLITE_OK) goto offsets_out;

		rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);
		while (rc == SQLITE_OK) {
			int i;                      
			int iMinPos = 0x7FFFFFFF;   
			TermOffset *pTerm = 0;      

			for (i = 0; i<nToken; i++) {
				TermOffset *pT = &sCtx.aTerm[i];
				if (pT->pList && (pT->iPos - pT->iOff)<iMinPos) {
					iMinPos = pT->iPos - pT->iOff;
					pTerm = pT;
				}
			}

			if (!pTerm) {
				
				rc = SQLITE_DONE;
			}
			else {
				assert(iCurrent <= iMinPos);
				if (0 == (0xFE & *pTerm->pList)) {
					pTerm->pList = 0;
				}
				else {
					fts3GetDeltaPosition(&pTerm->pList, &pTerm->iPos);
				}
				while (rc == SQLITE_OK && iCurrent<iMinPos) {
					rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);
				}
				if (rc == SQLITE_OK) {
					char aBuffer[64];
					sqlite3_snprintf(sizeof(aBuffer), aBuffer,
						"%d %d %d %d ", iCol, pTerm - sCtx.aTerm, iStart, iEnd - iStart
					);
					rc = fts3StringAppend(&res, aBuffer, -1);
				}
				else if (rc == SQLITE_DONE && pTab->zContentTbl == 0) {
					rc = FTS_CORRUPT_VTAB;
				}
			}
		}
		if (rc == SQLITE_DONE) {
			rc = SQLITE_OK;
		}

		pMod->xClose(pC);
		if (rc != SQLITE_OK) goto offsets_out;
	}

offsets_out:
	sqlite3_free(sCtx.aTerm);
	assert(rc != SQLITE_DONE);
	sqlite3Fts3SegmentsClose(pTab);
	if (rc != SQLITE_OK) {
		sqlite3_result_error_code(pCtx, rc);
		sqlite3_free(res.z);
	}
	else {
		sqlite3_result_text(pCtx, res.z, res.n - 1, sqlite3_free);
	}
	return;
}


SQLITE_PRIVATE void sqlite3Fts3Matchinfo(
	sqlite3_context *pContext,      
	Fts3Cursor *pCsr,               
	const char *zArg                
) {
	Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
	const char *zFormat;

	if (zArg) {
		zFormat = zArg;
	}
	else {
		zFormat = FTS3_MATCHINFO_DEFAULT;
	}

	if (!pCsr->pExpr) {
		sqlite3_result_blob(pContext, "", 0, SQLITE_STATIC);
		return;
	}
	else {
		
		fts3GetMatchinfo(pContext, pCsr, zFormat);
		sqlite3Fts3SegmentsClose(pTab);
	}
}

#endif





#ifndef SQLITE_DISABLE_FTS3_UNICODE


#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)









#ifndef SQLITE_AMALGAMATION

static const unsigned char sqlite3Utf8Trans1[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};

#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }

#define WRITE_UTF8(zOut, c) {                          \
  if( c<0x00080 ){                                     \
    *zOut++ = (u8)(c&0xFF);                            \
  }                                                    \
  else if( c<0x00800 ){                                \
    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
  else if( c<0x10000 ){                                \
    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }else{                                               \
    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \
    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
}

#endif 

typedef struct unicode_tokenizer unicode_tokenizer;
typedef struct unicode_cursor unicode_cursor;

struct unicode_tokenizer {
	sqlite3_tokenizer base;
	int bRemoveDiacritic;
	int nException;
	int *aiException;
};

struct unicode_cursor {
	sqlite3_tokenizer_cursor base;
	const unsigned char *aInput;    
	int nInput;                     
	int iOff;                       
	int iToken;                     
	char *zToken;                   
	int nAlloc;                     
};



static int unicodeDestroy(sqlite3_tokenizer *pTokenizer) {
	if (pTokenizer) {
		unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;
		sqlite3_free(p->aiException);
		sqlite3_free(p);
	}
	return SQLITE_OK;
}


static int unicodeAddExceptions(
	unicode_tokenizer *p,           
	int bAlnum,                     
	const char *zIn,                
	int nIn                         
) {
	const unsigned char *z = (const unsigned char *)zIn;
	const unsigned char *zTerm = &z[nIn];
	int iCode;
	int nEntry = 0;

	assert(bAlnum == 0 || bAlnum == 1);

	while (z<zTerm) {
		READ_UTF8(z, zTerm, iCode);
		assert((sqlite3FtsUnicodeIsalnum(iCode) & 0xFFFFFFFE) == 0);
		if (sqlite3FtsUnicodeIsalnum(iCode) != bAlnum
			&& sqlite3FtsUnicodeIsdiacritic(iCode) == 0
			) {
			nEntry++;
		}
	}

	if (nEntry) {
		int *aNew;                    
		int nNew;                     

		aNew = sqlite3_realloc(p->aiException, (p->nException + nEntry) * sizeof(int));
		if (aNew == 0) return SQLITE_NOMEM;
		nNew = p->nException;

		z = (const unsigned char *)zIn;
		while (z<zTerm) {
			READ_UTF8(z, zTerm, iCode);
			if (sqlite3FtsUnicodeIsalnum(iCode) != bAlnum
				&& sqlite3FtsUnicodeIsdiacritic(iCode) == 0
				) {
				int i, j;
				for (i = 0; i<nNew && aNew[i]<iCode; i++);
				for (j = nNew; j>i; j--) aNew[j] = aNew[j - 1];
				aNew[i] = iCode;
				nNew++;
			}
		}
		p->aiException = aNew;
		p->nException = nNew;
	}

	return SQLITE_OK;
}


static int unicodeIsException(unicode_tokenizer *p, int iCode) {
	if (p->nException>0) {
		int *a = p->aiException;
		int iLo = 0;
		int iHi = p->nException - 1;

		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			if (iCode == a[iTest]) {
				return 1;
			}
			else if (iCode>a[iTest]) {
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}
	}

	return 0;
}


static int unicodeIsAlnum(unicode_tokenizer *p, int iCode) {
	assert((sqlite3FtsUnicodeIsalnum(iCode) & 0xFFFFFFFE) == 0);
	return sqlite3FtsUnicodeIsalnum(iCode) ^ unicodeIsException(p, iCode);
}


static int unicodeCreate(
	int nArg,                       
	const char * const *azArg,      
	sqlite3_tokenizer **pp          
) {
	unicode_tokenizer *pNew;        
	int i;
	int rc = SQLITE_OK;

	pNew = (unicode_tokenizer *)sqlite3_malloc(sizeof(unicode_tokenizer));
	if (pNew == NULL) return SQLITE_NOMEM;
	memset(pNew, 0, sizeof(unicode_tokenizer));
	pNew->bRemoveDiacritic = 1;

	for (i = 0; rc == SQLITE_OK && i<nArg; i++) {
		const char *z = azArg[i];
		int n = (int)strlen(z);

		if (n == 19 && memcmp("remove_diacritics=1", z, 19) == 0) {
			pNew->bRemoveDiacritic = 1;
		}
		else if (n == 19 && memcmp("remove_diacritics=0", z, 19) == 0) {
			pNew->bRemoveDiacritic = 0;
		}
		else if (n >= 11 && memcmp("tokenchars=", z, 11) == 0) {
			rc = unicodeAddExceptions(pNew, 1, &z[11], n - 11);
		}
		else if (n >= 11 && memcmp("separators=", z, 11) == 0) {
			rc = unicodeAddExceptions(pNew, 0, &z[11], n - 11);
		}
		else {
			
			rc = SQLITE_ERROR;
		}
	}

	if (rc != SQLITE_OK) {
		unicodeDestroy((sqlite3_tokenizer *)pNew);
		pNew = 0;
	}
	*pp = (sqlite3_tokenizer *)pNew;
	return rc;
}


static int unicodeOpen(
	sqlite3_tokenizer *p,           
	const char *aInput,             
	int nInput,                     
	sqlite3_tokenizer_cursor **pp   
) {
	unicode_cursor *pCsr;

	pCsr = (unicode_cursor *)sqlite3_malloc(sizeof(unicode_cursor));
	if (pCsr == 0) {
		return SQLITE_NOMEM;
	}
	memset(pCsr, 0, sizeof(unicode_cursor));

	pCsr->aInput = (const unsigned char *)aInput;
	if (aInput == 0) {
		pCsr->nInput = 0;
	}
	else if (nInput<0) {
		pCsr->nInput = (int)strlen(aInput);
	}
	else {
		pCsr->nInput = nInput;
	}

	*pp = &pCsr->base;
	UNUSED_PARAMETER(p);
	return SQLITE_OK;
}


static int unicodeClose(sqlite3_tokenizer_cursor *pCursor) {
	unicode_cursor *pCsr = (unicode_cursor *)pCursor;
	sqlite3_free(pCsr->zToken);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}


static int unicodeNext(
	sqlite3_tokenizer_cursor *pC,   
	const char **paToken,           
	int *pnToken,                   
	int *piStart,                   
	int *piEnd,                     
	int *piPos                      
) {
	unicode_cursor *pCsr = (unicode_cursor *)pC;
	unicode_tokenizer *p = ((unicode_tokenizer *)pCsr->base.pTokenizer);
	int iCode = 0;
	char *zOut;
	const unsigned char *z = &pCsr->aInput[pCsr->iOff];
	const unsigned char *zStart = z;
	const unsigned char *zEnd;
	const unsigned char *zTerm = &pCsr->aInput[pCsr->nInput];

	
	while (z<zTerm) {
		READ_UTF8(z, zTerm, iCode);
		if (unicodeIsAlnum(p, iCode)) break;
		zStart = z;
	}
	if (zStart >= zTerm) return SQLITE_DONE;

	zOut = pCsr->zToken;
	do {
		int iOut;

		
		if ((zOut - pCsr->zToken) >= (pCsr->nAlloc - 4)) {
			char *zNew = sqlite3_realloc(pCsr->zToken, pCsr->nAlloc + 64);
			if (!zNew) return SQLITE_NOMEM;
			zOut = &zNew[zOut - pCsr->zToken];
			pCsr->zToken = zNew;
			pCsr->nAlloc += 64;
		}

		
		zEnd = z;
		iOut = sqlite3FtsUnicodeFold(iCode, p->bRemoveDiacritic);
		if (iOut) {
			WRITE_UTF8(zOut, iOut);
		}

		
		if (z >= zTerm) break;
		READ_UTF8(z, zTerm, iCode);
	} while (unicodeIsAlnum(p, iCode)
		|| sqlite3FtsUnicodeIsdiacritic(iCode)
		);

	
	pCsr->iOff = (int)(z - pCsr->aInput);
	*paToken = pCsr->zToken;
	*pnToken = (int)(zOut - pCsr->zToken);
	*piStart = (int)(zStart - pCsr->aInput);
	*piEnd = (int)(zEnd - pCsr->aInput);
	*piPos = pCsr->iToken++;
	return SQLITE_OK;
}


SQLITE_PRIVATE void sqlite3Fts3UnicodeTokenizer(sqlite3_tokenizer_module const **ppModule) {
	static const sqlite3_tokenizer_module module = {
		0,
		unicodeCreate,
		unicodeDestroy,
		unicodeOpen,
		unicodeClose,
		unicodeNext,
		0,
	};
	*ppModule = &module;
}

#endif 
#endif 







#ifndef SQLITE_DISABLE_FTS3_UNICODE
#if defined(SQLITE_ENABLE_FTS3) || defined(SQLITE_ENABLE_FTS4)




SQLITE_PRIVATE int sqlite3FtsUnicodeIsalnum(int c) {
	
	static const unsigned int aEntry[] = {
		0x00000030, 0x0000E807, 0x00016C06, 0x0001EC2F, 0x0002AC07,
		0x0002D001, 0x0002D803, 0x0002EC01, 0x0002FC01, 0x00035C01,
		0x0003DC01, 0x000B0804, 0x000B480E, 0x000B9407, 0x000BB401,
		0x000BBC81, 0x000DD401, 0x000DF801, 0x000E1002, 0x000E1C01,
		0x000FD801, 0x00120808, 0x00156806, 0x00162402, 0x00163C01,
		0x00164437, 0x0017CC02, 0x00180005, 0x00181816, 0x00187802,
		0x00192C15, 0x0019A804, 0x0019C001, 0x001B5001, 0x001B580F,
		0x001B9C07, 0x001BF402, 0x001C000E, 0x001C3C01, 0x001C4401,
		0x001CC01B, 0x001E980B, 0x001FAC09, 0x001FD804, 0x00205804,
		0x00206C09, 0x00209403, 0x0020A405, 0x0020C00F, 0x00216403,
		0x00217801, 0x0023901B, 0x00240004, 0x0024E803, 0x0024F812,
		0x00254407, 0x00258804, 0x0025C001, 0x00260403, 0x0026F001,
		0x0026F807, 0x00271C02, 0x00272C03, 0x00275C01, 0x00278802,
		0x0027C802, 0x0027E802, 0x00280403, 0x0028F001, 0x0028F805,
		0x00291C02, 0x00292C03, 0x00294401, 0x0029C002, 0x0029D401,
		0x002A0403, 0x002AF001, 0x002AF808, 0x002B1C03, 0x002B2C03,
		0x002B8802, 0x002BC002, 0x002C0403, 0x002CF001, 0x002CF807,
		0x002D1C02, 0x002D2C03, 0x002D5802, 0x002D8802, 0x002DC001,
		0x002E0801, 0x002EF805, 0x002F1803, 0x002F2804, 0x002F5C01,
		0x002FCC08, 0x00300403, 0x0030F807, 0x00311803, 0x00312804,
		0x00315402, 0x00318802, 0x0031FC01, 0x00320802, 0x0032F001,
		0x0032F807, 0x00331803, 0x00332804, 0x00335402, 0x00338802,
		0x00340802, 0x0034F807, 0x00351803, 0x00352804, 0x00355C01,
		0x00358802, 0x0035E401, 0x00360802, 0x00372801, 0x00373C06,
		0x00375801, 0x00376008, 0x0037C803, 0x0038C401, 0x0038D007,
		0x0038FC01, 0x00391C09, 0x00396802, 0x003AC401, 0x003AD006,
		0x003AEC02, 0x003B2006, 0x003C041F, 0x003CD00C, 0x003DC417,
		0x003E340B, 0x003E6424, 0x003EF80F, 0x003F380D, 0x0040AC14,
		0x00412806, 0x00415804, 0x00417803, 0x00418803, 0x00419C07,
		0x0041C404, 0x0042080C, 0x00423C01, 0x00426806, 0x0043EC01,
		0x004D740C, 0x004E400A, 0x00500001, 0x0059B402, 0x005A0001,
		0x005A6C02, 0x005BAC03, 0x005C4803, 0x005CC805, 0x005D4802,
		0x005DC802, 0x005ED023, 0x005F6004, 0x005F7401, 0x0060000F,
		0x0062A401, 0x0064800C, 0x0064C00C, 0x00650001, 0x00651002,
		0x0066C011, 0x00672002, 0x00677822, 0x00685C05, 0x00687802,
		0x0069540A, 0x0069801D, 0x0069FC01, 0x006A8007, 0x006AA006,
		0x006C0005, 0x006CD011, 0x006D6823, 0x006E0003, 0x006E840D,
		0x006F980E, 0x006FF004, 0x00709014, 0x0070EC05, 0x0071F802,
		0x00730008, 0x00734019, 0x0073B401, 0x0073C803, 0x00770027,
		0x0077F004, 0x007EF401, 0x007EFC03, 0x007F3403, 0x007F7403,
		0x007FB403, 0x007FF402, 0x00800065, 0x0081A806, 0x0081E805,
		0x00822805, 0x0082801A, 0x00834021, 0x00840002, 0x00840C04,
		0x00842002, 0x00845001, 0x00845803, 0x00847806, 0x00849401,
		0x00849C01, 0x0084A401, 0x0084B801, 0x0084E802, 0x00850005,
		0x00852804, 0x00853C01, 0x00864264, 0x00900027, 0x0091000B,
		0x0092704E, 0x00940200, 0x009C0475, 0x009E53B9, 0x00AD400A,
		0x00B39406, 0x00B3BC03, 0x00B3E404, 0x00B3F802, 0x00B5C001,
		0x00B5FC01, 0x00B7804F, 0x00B8C00C, 0x00BA001A, 0x00BA6C59,
		0x00BC00D6, 0x00BFC00C, 0x00C00005, 0x00C02019, 0x00C0A807,
		0x00C0D802, 0x00C0F403, 0x00C26404, 0x00C28001, 0x00C3EC01,
		0x00C64002, 0x00C6580A, 0x00C70024, 0x00C8001F, 0x00C8A81E,
		0x00C94001, 0x00C98020, 0x00CA2827, 0x00CB003F, 0x00CC0100,
		0x01370040, 0x02924037, 0x0293F802, 0x02983403, 0x0299BC10,
		0x029A7C01, 0x029BC008, 0x029C0017, 0x029C8002, 0x029E2402,
		0x02A00801, 0x02A01801, 0x02A02C01, 0x02A08C09, 0x02A0D804,
		0x02A1D004, 0x02A20002, 0x02A2D011, 0x02A33802, 0x02A38012,
		0x02A3E003, 0x02A4980A, 0x02A51C0D, 0x02A57C01, 0x02A60004,
		0x02A6CC1B, 0x02A77802, 0x02A8A40E, 0x02A90C01, 0x02A93002,
		0x02A97004, 0x02A9DC03, 0x02A9EC01, 0x02AAC001, 0x02AAC803,
		0x02AADC02, 0x02AAF802, 0x02AB0401, 0x02AB7802, 0x02ABAC07,
		0x02ABD402, 0x02AF8C0B, 0x03600001, 0x036DFC02, 0x036FFC02,
		0x037FFC01, 0x03EC7801, 0x03ECA401, 0x03EEC810, 0x03F4F802,
		0x03F7F002, 0x03F8001A, 0x03F88007, 0x03F8C023, 0x03F95013,
		0x03F9A004, 0x03FBFC01, 0x03FC040F, 0x03FC6807, 0x03FCEC06,
		0x03FD6C0B, 0x03FF8007, 0x03FFA007, 0x03FFE405, 0x04040003,
		0x0404DC09, 0x0405E411, 0x0406400C, 0x0407402E, 0x040E7C01,
		0x040F4001, 0x04215C01, 0x04247C01, 0x0424FC01, 0x04280403,
		0x04281402, 0x04283004, 0x0428E003, 0x0428FC01, 0x04294009,
		0x0429FC01, 0x042CE407, 0x04400003, 0x0440E016, 0x04420003,
		0x0442C012, 0x04440003, 0x04449C0E, 0x04450004, 0x04460003,
		0x0446CC0E, 0x04471404, 0x045AAC0D, 0x0491C004, 0x05BD442E,
		0x05BE3C04, 0x074000F6, 0x07440027, 0x0744A4B5, 0x07480046,
		0x074C0057, 0x075B0401, 0x075B6C01, 0x075BEC01, 0x075C5401,
		0x075CD401, 0x075D3C01, 0x075DBC01, 0x075E2401, 0x075EA401,
		0x075F0C01, 0x07BBC002, 0x07C0002C, 0x07C0C064, 0x07C2800F,
		0x07C2C40E, 0x07C3040F, 0x07C3440F, 0x07C4401F, 0x07C4C03C,
		0x07C5C02B, 0x07C7981D, 0x07C8402B, 0x07C90009, 0x07C94002,
		0x07CC0021, 0x07CCC006, 0x07CCDC46, 0x07CE0014, 0x07CE8025,
		0x07CF1805, 0x07CF8011, 0x07D0003F, 0x07D10001, 0x07D108B6,
		0x07D3E404, 0x07D4003E, 0x07D50004, 0x07D54018, 0x07D7EC46,
		0x07D9140B, 0x07DA0046, 0x07DC0074, 0x38000401, 0x38008060,
		0x380400F0,
	};
	static const unsigned int aAscii[4] = {
		0xFFFFFFFF, 0xFC00FFFF, 0xF8000001, 0xF8000001,
	};

	if (c<128) {
		return ((aAscii[c >> 5] & (1 << (c & 0x001F))) == 0);
	}
	else if (c<(1 << 22)) {
		unsigned int key = (((unsigned int)c) << 10) | 0x000003FF;
		int iRes = 0;
		int iHi = sizeof(aEntry) / sizeof(aEntry[0]) - 1;
		int iLo = 0;
		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			if (key >= aEntry[iTest]) {
				iRes = iTest;
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}
		assert(aEntry[0]<key);
		assert(key >= aEntry[iRes]);
		return (((unsigned int)c) >= ((aEntry[iRes] >> 10) + (aEntry[iRes] & 0x3FF)));
	}
	return 1;
}



static int remove_diacritic(int c) {
	unsigned short aDia[] = {
		0,  1797,  1848,  1859,  1891,  1928,  1940,  1995,
		2024,  2040,  2060,  2110,  2168,  2206,  2264,  2286,
		2344,  2383,  2472,  2488,  2516,  2596,  2668,  2732,
		2782,  2842,  2894,  2954,  2984,  3000,  3028,  3336,
		3456,  3696,  3712,  3728,  3744,  3896,  3912,  3928,
		3968,  4008,  4040,  4106,  4138,  4170,  4202,  4234,
		4266,  4296,  4312,  4344,  4408,  4424,  4472,  4504,
		6148,  6198,  6264,  6280,  6360,  6429,  6505,  6529,
		61448, 61468, 61534, 61592, 61642, 61688, 61704, 61726,
		61784, 61800, 61836, 61880, 61914, 61948, 61998, 62122,
		62154, 62200, 62218, 62302, 62364, 62442, 62478, 62536,
		62554, 62584, 62604, 62640, 62648, 62656, 62664, 62730,
		62924, 63050, 63082, 63274, 63390,
	};
	char aChar[] = {
		'\0', 'a',  'c',  'e',  'i',  'n',  'o',  'u',  'y',  'y',  'a',  'c',
		'd',  'e',  'e',  'g',  'h',  'i',  'j',  'k',  'l',  'n',  'o',  'r',
		's',  't',  'u',  'u',  'w',  'y',  'z',  'o',  'u',  'a',  'i',  'o',
		'u',  'g',  'k',  'o',  'j',  'g',  'n',  'a',  'e',  'i',  'o',  'r',
		'u',  's',  't',  'h',  'a',  'e',  'o',  'y',  '\0', '\0', '\0', '\0',
		'\0', '\0', '\0', '\0', 'a',  'b',  'd',  'd',  'e',  'f',  'g',  'h',
		'h',  'i',  'k',  'l',  'l',  'm',  'n',  'p',  'r',  'r',  's',  't',
		'u',  'v',  'w',  'w',  'x',  'y',  'z',  'h',  't',  'w',  'y',  'a',
		'e',  'i',  'o',  'u',  'y',
	};

	unsigned int key = (((unsigned int)c) << 3) | 0x00000007;
	int iRes = 0;
	int iHi = sizeof(aDia) / sizeof(aDia[0]) - 1;
	int iLo = 0;
	while (iHi >= iLo) {
		int iTest = (iHi + iLo) / 2;
		if (key >= aDia[iTest]) {
			iRes = iTest;
			iLo = iTest + 1;
		}
		else {
			iHi = iTest - 1;
		}
	}
	assert(key >= aDia[iRes]);
	return ((c > (aDia[iRes] >> 3) + (aDia[iRes] & 0x07)) ? c : (int)aChar[iRes]);
}



SQLITE_PRIVATE int sqlite3FtsUnicodeIsdiacritic(int c) {
	unsigned int mask0 = 0x08029FDF;
	unsigned int mask1 = 0x000361F8;
	if (c<768 || c>817) return 0;
	return (c < 768 + 32) ?
		(mask0 & (1 << (c - 768))) :
		(mask1 & (1 << (c - 768 - 32)));
}



SQLITE_PRIVATE int sqlite3FtsUnicodeFold(int c, int bRemoveDiacritic) {
	
	static const struct TableEntry {
		unsigned short iCode;
		unsigned char flags;
		unsigned char nRange;
	} aEntry[] = {
		{ 65, 14, 26 },{ 181, 64, 1 },{ 192, 14, 23 },
		{ 216, 14, 7 },{ 256, 1, 48 },{ 306, 1, 6 },
		{ 313, 1, 16 },{ 330, 1, 46 },{ 376, 116, 1 },
		{ 377, 1, 6 },{ 383, 104, 1 },{ 385, 50, 1 },
		{ 386, 1, 4 },{ 390, 44, 1 },{ 391, 0, 1 },
		{ 393, 42, 2 },{ 395, 0, 1 },{ 398, 32, 1 },
		{ 399, 38, 1 },{ 400, 40, 1 },{ 401, 0, 1 },
		{ 403, 42, 1 },{ 404, 46, 1 },{ 406, 52, 1 },
		{ 407, 48, 1 },{ 408, 0, 1 },{ 412, 52, 1 },
		{ 413, 54, 1 },{ 415, 56, 1 },{ 416, 1, 6 },
		{ 422, 60, 1 },{ 423, 0, 1 },{ 425, 60, 1 },
		{ 428, 0, 1 },{ 430, 60, 1 },{ 431, 0, 1 },
		{ 433, 58, 2 },{ 435, 1, 4 },{ 439, 62, 1 },
		{ 440, 0, 1 },{ 444, 0, 1 },{ 452, 2, 1 },
		{ 453, 0, 1 },{ 455, 2, 1 },{ 456, 0, 1 },
		{ 458, 2, 1 },{ 459, 1, 18 },{ 478, 1, 18 },
		{ 497, 2, 1 },{ 498, 1, 4 },{ 502, 122, 1 },
		{ 503, 134, 1 },{ 504, 1, 40 },{ 544, 110, 1 },
		{ 546, 1, 18 },{ 570, 70, 1 },{ 571, 0, 1 },
		{ 573, 108, 1 },{ 574, 68, 1 },{ 577, 0, 1 },
		{ 579, 106, 1 },{ 580, 28, 1 },{ 581, 30, 1 },
		{ 582, 1, 10 },{ 837, 36, 1 },{ 880, 1, 4 },
		{ 886, 0, 1 },{ 902, 18, 1 },{ 904, 16, 3 },
		{ 908, 26, 1 },{ 910, 24, 2 },{ 913, 14, 17 },
		{ 931, 14, 9 },{ 962, 0, 1 },{ 975, 4, 1 },
		{ 976, 140, 1 },{ 977, 142, 1 },{ 981, 146, 1 },
		{ 982, 144, 1 },{ 984, 1, 24 },{ 1008, 136, 1 },
		{ 1009, 138, 1 },{ 1012, 130, 1 },{ 1013, 128, 1 },
		{ 1015, 0, 1 },{ 1017, 152, 1 },{ 1018, 0, 1 },
		{ 1021, 110, 3 },{ 1024, 34, 16 },{ 1040, 14, 32 },
		{ 1120, 1, 34 },{ 1162, 1, 54 },{ 1216, 6, 1 },
		{ 1217, 1, 14 },{ 1232, 1, 88 },{ 1329, 22, 38 },
		{ 4256, 66, 38 },{ 4295, 66, 1 },{ 4301, 66, 1 },
		{ 7680, 1, 150 },{ 7835, 132, 1 },{ 7838, 96, 1 },
		{ 7840, 1, 96 },{ 7944, 150, 8 },{ 7960, 150, 6 },
		{ 7976, 150, 8 },{ 7992, 150, 8 },{ 8008, 150, 6 },
		{ 8025, 151, 8 },{ 8040, 150, 8 },{ 8072, 150, 8 },
		{ 8088, 150, 8 },{ 8104, 150, 8 },{ 8120, 150, 2 },
		{ 8122, 126, 2 },{ 8124, 148, 1 },{ 8126, 100, 1 },
		{ 8136, 124, 4 },{ 8140, 148, 1 },{ 8152, 150, 2 },
		{ 8154, 120, 2 },{ 8168, 150, 2 },{ 8170, 118, 2 },
		{ 8172, 152, 1 },{ 8184, 112, 2 },{ 8186, 114, 2 },
		{ 8188, 148, 1 },{ 8486, 98, 1 },{ 8490, 92, 1 },
		{ 8491, 94, 1 },{ 8498, 12, 1 },{ 8544, 8, 16 },
		{ 8579, 0, 1 },{ 9398, 10, 26 },{ 11264, 22, 47 },
		{ 11360, 0, 1 },{ 11362, 88, 1 },{ 11363, 102, 1 },
		{ 11364, 90, 1 },{ 11367, 1, 6 },{ 11373, 84, 1 },
		{ 11374, 86, 1 },{ 11375, 80, 1 },{ 11376, 82, 1 },
		{ 11378, 0, 1 },{ 11381, 0, 1 },{ 11390, 78, 2 },
		{ 11392, 1, 100 },{ 11499, 1, 4 },{ 11506, 0, 1 },
		{ 42560, 1, 46 },{ 42624, 1, 24 },{ 42786, 1, 14 },
		{ 42802, 1, 62 },{ 42873, 1, 4 },{ 42877, 76, 1 },
		{ 42878, 1, 10 },{ 42891, 0, 1 },{ 42893, 74, 1 },
		{ 42896, 1, 4 },{ 42912, 1, 10 },{ 42922, 72, 1 },
		{ 65313, 14, 26 },
	};
	static const unsigned short aiOff[] = {
		1,     2,     8,     15,    16,    26,    28,    32,
		37,    38,    40,    48,    63,    64,    69,    71,
		79,    80,    116,   202,   203,   205,   206,   207,
		209,   210,   211,   213,   214,   217,   218,   219,
		775,   7264,  10792, 10795, 23228, 23256, 30204, 54721,
		54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274,
		57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406,
		65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462,
		65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511,
		65514, 65521, 65527, 65528, 65529,
	};

	int ret = c;

	assert(c >= 0);
	assert(sizeof(unsigned short) == 2 && sizeof(unsigned char) == 1);

	if (c<128) {
		if (c >= 'A' && c <= 'Z') ret = c + ('a' - 'A');
	}
	else if (c<65536) {
		int iHi = sizeof(aEntry) / sizeof(aEntry[0]) - 1;
		int iLo = 0;
		int iRes = -1;

		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			int cmp = (c - aEntry[iTest].iCode);
			if (cmp >= 0) {
				iRes = iTest;
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}
		assert(iRes<0 || c >= aEntry[iRes].iCode);

		if (iRes >= 0) {
			const struct TableEntry *p = &aEntry[iRes];
			if (c<(p->iCode + p->nRange) && 0 == (0x01 & p->flags & (p->iCode ^ c))) {
				ret = (c + (aiOff[p->flags >> 1])) & 0x0000FFFF;
				assert(ret>0);
			}
		}

		if (bRemoveDiacritic) ret = remove_diacritic(ret);
	}

	else if (c >= 66560 && c<66600) {
		ret = c + 40;
	}

	return ret;
}
#endif 
#endif 







#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RTREE)

#ifndef SQLITE_CORE

SQLITE_EXTENSION_INIT1
#else

#endif





#ifndef SQLITE_AMALGAMATION
#include "sqlite3rtree.h"
typedef sqlite3_int64 i64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
#endif


#ifndef UNUSED_PARAMETER
# define UNUSED_PARAMETER(x) (void)(x)
#endif

typedef struct Rtree Rtree;
typedef struct RtreeCursor RtreeCursor;
typedef struct RtreeNode RtreeNode;
typedef struct RtreeCell RtreeCell;
typedef struct RtreeConstraint RtreeConstraint;
typedef struct RtreeMatchArg RtreeMatchArg;
typedef struct RtreeGeomCallback RtreeGeomCallback;
typedef union RtreeCoord RtreeCoord;
typedef struct RtreeSearchPoint RtreeSearchPoint;


#define RTREE_MAX_DIMENSIONS 5


#define HASHSIZE 97


#define RTREE_DEFAULT_ROWEST 1048576
#define RTREE_MIN_ROWEST         100


struct Rtree {
	sqlite3_vtab base;          
	sqlite3 *db;                
	int iNodeSize;              
	u8 nDim;                    
	u8 eCoordType;              
	u8 nBytesPerCell;           
	int iDepth;                 
	char *zDb;                  
	char *zName;                
	int nBusy;                  
	i64 nRowEst;                

								
	RtreeNode *pDeleted;
	int iReinsertHeight;        

								
	sqlite3_stmt *pReadNode;
	sqlite3_stmt *pWriteNode;
	sqlite3_stmt *pDeleteNode;

	
	sqlite3_stmt *pReadRowid;
	sqlite3_stmt *pWriteRowid;
	sqlite3_stmt *pDeleteRowid;

	
	sqlite3_stmt *pReadParent;
	sqlite3_stmt *pWriteParent;
	sqlite3_stmt *pDeleteParent;

	RtreeNode *aHash[HASHSIZE]; 
};


#define RTREE_COORD_REAL32 0
#define RTREE_COORD_INT32  1


#ifdef SQLITE_RTREE_INT_ONLY
typedef sqlite3_int64 RtreeDValue;       
typedef int RtreeValue;                  
# define RTREE_ZERO 0
#else
typedef double RtreeDValue;              
typedef float RtreeValue;                
# define RTREE_ZERO 0.0
#endif

										 
struct RtreeSearchPoint {
	RtreeDValue rScore;    
	sqlite3_int64 id;      
	u8 iLevel;             
	u8 eWithin;            
	u8 iCell;              
};


#define RTREE_MINCELLS(p) ((((p)->iNodeSize-4)/(p)->nBytesPerCell)/3)
#define RTREE_REINSERT(p) RTREE_MINCELLS(p)
#define RTREE_MAXCELLS 51


#define RTREE_MAX_DEPTH 40



#define RTREE_CACHE_SZ  5


struct RtreeCursor {
	sqlite3_vtab_cursor base;         
	u8 atEOF;                         
	u8 bPoint;                        
	int iStrategy;                    
	int nConstraint;                  
	RtreeConstraint *aConstraint;     
	int nPointAlloc;                  
	int nPoint;                       
	int mxLevel;                      
	RtreeSearchPoint *aPoint;         
	RtreeSearchPoint sPoint;          
	RtreeNode *aNode[RTREE_CACHE_SZ]; 
	u32 anQueue[RTREE_MAX_DEPTH + 1];   
};


#define RTREE_OF_CURSOR(X)   ((Rtree*)((X)->base.pVtab))


union RtreeCoord {
	RtreeValue f;      
	int i;             
	u32 u;             
};


#ifdef SQLITE_RTREE_INT_ONLY
# define DCOORD(coord) ((RtreeDValue)coord.i)
#else
# define DCOORD(coord) (                           \
    (pRtree->eCoordType==RTREE_COORD_REAL32) ?      \
      ((double)coord.f) :                           \
      ((double)coord.i)                             \
  )
#endif


struct RtreeConstraint {
	int iCoord;                     
	int op;                         
	union {
		RtreeDValue rValue;             
		int(*xGeom)(sqlite3_rtree_geometry*, int, RtreeDValue*, int*);
		int(*xQueryFunc)(sqlite3_rtree_query_info*);
	} u;
	sqlite3_rtree_query_info *pInfo;  
};


#define RTREE_EQ    0x41  
#define RTREE_LE    0x42  
#define RTREE_LT    0x43  
#define RTREE_GE    0x44  
#define RTREE_GT    0x45  
#define RTREE_MATCH 0x46  
#define RTREE_QUERY 0x47  



struct RtreeNode {
	RtreeNode *pParent;         
	i64 iNode;                  
	int nRef;                   
	int isDirty;                
	u8 *zData;                  
	RtreeNode *pNext;           
};


#define NCELL(pNode) readInt16(&(pNode)->zData[2])


struct RtreeCell {
	i64 iRowid;                                 
	RtreeCoord aCoord[RTREE_MAX_DIMENSIONS * 2];  
};



struct RtreeGeomCallback {
	int(*xGeom)(sqlite3_rtree_geometry*, int, RtreeDValue*, int*);
	int(*xQueryFunc)(sqlite3_rtree_query_info*);
	void(*xDestructor)(void*);
	void *pContext;
};



#define RTREE_GEOMETRY_MAGIC 0x891245AB


struct RtreeMatchArg {
	u32 magic;                  
	RtreeGeomCallback cb;       
	int nParam;                 
	sqlite3_value **apSqlParam; 
	RtreeDValue aParam[1];      
};

#ifndef MAX
# define MAX(x,y) ((x) < (y) ? (y) : (x))
#endif
#ifndef MIN
# define MIN(x,y) ((x) > (y) ? (y) : (x))
#endif


static int readInt16(u8 *p) {
	return (p[0] << 8) + p[1];
}
static void readCoord(u8 *p, RtreeCoord *pCoord) {
	pCoord->u = (
		(((u32)p[0]) << 24) +
		(((u32)p[1]) << 16) +
		(((u32)p[2]) << 8) +
		(((u32)p[3]) << 0)
		);
}
static i64 readInt64(u8 *p) {
	return (
		(((i64)p[0]) << 56) +
		(((i64)p[1]) << 48) +
		(((i64)p[2]) << 40) +
		(((i64)p[3]) << 32) +
		(((i64)p[4]) << 24) +
		(((i64)p[5]) << 16) +
		(((i64)p[6]) << 8) +
		(((i64)p[7]) << 0)
		);
}


static int writeInt16(u8 *p, int i) {
	p[0] = (i >> 8) & 0xFF;
	p[1] = (i >> 0) & 0xFF;
	return 2;
}
static int writeCoord(u8 *p, RtreeCoord *pCoord) {
	u32 i;
	assert(sizeof(RtreeCoord) == 4);
	assert(sizeof(u32) == 4);
	i = pCoord->u;
	p[0] = (i >> 24) & 0xFF;
	p[1] = (i >> 16) & 0xFF;
	p[2] = (i >> 8) & 0xFF;
	p[3] = (i >> 0) & 0xFF;
	return 4;
}
static int writeInt64(u8 *p, i64 i) {
	p[0] = (i >> 56) & 0xFF;
	p[1] = (i >> 48) & 0xFF;
	p[2] = (i >> 40) & 0xFF;
	p[3] = (i >> 32) & 0xFF;
	p[4] = (i >> 24) & 0xFF;
	p[5] = (i >> 16) & 0xFF;
	p[6] = (i >> 8) & 0xFF;
	p[7] = (i >> 0) & 0xFF;
	return 8;
}


static void nodeReference(RtreeNode *p) {
	if (p) {
		p->nRef++;
	}
}


static void nodeZero(Rtree *pRtree, RtreeNode *p) {
	memset(&p->zData[2], 0, pRtree->iNodeSize - 2);
	p->isDirty = 1;
}


static int nodeHash(i64 iNode) {
	return iNode % HASHSIZE;
}


static RtreeNode *nodeHashLookup(Rtree *pRtree, i64 iNode) {
	RtreeNode *p;
	for (p = pRtree->aHash[nodeHash(iNode)]; p && p->iNode != iNode; p = p->pNext);
	return p;
}


static void nodeHashInsert(Rtree *pRtree, RtreeNode *pNode) {
	int iHash;
	assert(pNode->pNext == 0);
	iHash = nodeHash(pNode->iNode);
	pNode->pNext = pRtree->aHash[iHash];
	pRtree->aHash[iHash] = pNode;
}


static void nodeHashDelete(Rtree *pRtree, RtreeNode *pNode) {
	RtreeNode **pp;
	if (pNode->iNode != 0) {
		pp = &pRtree->aHash[nodeHash(pNode->iNode)];
		for (; (*pp) != pNode; pp = &(*pp)->pNext) { assert(*pp); }
		*pp = pNode->pNext;
		pNode->pNext = 0;
	}
}


static RtreeNode *nodeNew(Rtree *pRtree, RtreeNode *pParent) {
	RtreeNode *pNode;
	pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize);
	if (pNode) {
		memset(pNode, 0, sizeof(RtreeNode) + pRtree->iNodeSize);
		pNode->zData = (u8 *)&pNode[1];
		pNode->nRef = 1;
		pNode->pParent = pParent;
		pNode->isDirty = 1;
		nodeReference(pParent);
	}
	return pNode;
}


static int nodeAcquire(
	Rtree *pRtree,             
	i64 iNode,                 
	RtreeNode *pParent,        
	RtreeNode **ppNode         
) {
	int rc;
	int rc2 = SQLITE_OK;
	RtreeNode *pNode;

	
	if ((pNode = nodeHashLookup(pRtree, iNode))) {
		assert(!pParent || !pNode->pParent || pNode->pParent == pParent);
		if (pParent && !pNode->pParent) {
			nodeReference(pParent);
			pNode->pParent = pParent;
		}
		pNode->nRef++;
		*ppNode = pNode;
		return SQLITE_OK;
	}

	sqlite3_bind_int64(pRtree->pReadNode, 1, iNode);
	rc = sqlite3_step(pRtree->pReadNode);
	if (rc == SQLITE_ROW) {
		const u8 *zBlob = sqlite3_column_blob(pRtree->pReadNode, 0);
		if (pRtree->iNodeSize == sqlite3_column_bytes(pRtree->pReadNode, 0)) {
			pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize);
			if (!pNode) {
				rc2 = SQLITE_NOMEM;
			}
			else {
				pNode->pParent = pParent;
				pNode->zData = (u8 *)&pNode[1];
				pNode->nRef = 1;
				pNode->iNode = iNode;
				pNode->isDirty = 0;
				pNode->pNext = 0;
				memcpy(pNode->zData, zBlob, pRtree->iNodeSize);
				nodeReference(pParent);
			}
		}
	}
	rc = sqlite3_reset(pRtree->pReadNode);
	if (rc == SQLITE_OK) rc = rc2;

	
	if (pNode && iNode == 1) {
		pRtree->iDepth = readInt16(pNode->zData);
		if (pRtree->iDepth>RTREE_MAX_DEPTH) {
			rc = SQLITE_CORRUPT_VTAB;
		}
	}

	
	if (pNode && rc == SQLITE_OK) {
		if (NCELL(pNode)>((pRtree->iNodeSize - 4) / pRtree->nBytesPerCell)) {
			rc = SQLITE_CORRUPT_VTAB;
		}
	}

	if (rc == SQLITE_OK) {
		if (pNode != 0) {
			nodeHashInsert(pRtree, pNode);
		}
		else {
			rc = SQLITE_CORRUPT_VTAB;
		}
		*ppNode = pNode;
	}
	else {
		sqlite3_free(pNode);
		*ppNode = 0;
	}

	return rc;
}


static void nodeOverwriteCell(
	Rtree *pRtree,             
	RtreeNode *pNode,          
	RtreeCell *pCell,          
	int iCell                  
) {
	int ii;
	u8 *p = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];
	p += writeInt64(p, pCell->iRowid);
	for (ii = 0; ii<(pRtree->nDim * 2); ii++) {
		p += writeCoord(p, &pCell->aCoord[ii]);
	}
	pNode->isDirty = 1;
}


static void nodeDeleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell) {
	u8 *pDst = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];
	u8 *pSrc = &pDst[pRtree->nBytesPerCell];
	int nByte = (NCELL(pNode) - iCell - 1) * pRtree->nBytesPerCell;
	memmove(pDst, pSrc, nByte);
	writeInt16(&pNode->zData[2], NCELL(pNode) - 1);
	pNode->isDirty = 1;
}


static int nodeInsertCell(
	Rtree *pRtree,                
	RtreeNode *pNode,             
	RtreeCell *pCell              
) {
	int nCell;                    
	int nMaxCell;                 

	nMaxCell = (pRtree->iNodeSize - 4) / pRtree->nBytesPerCell;
	nCell = NCELL(pNode);

	assert(nCell <= nMaxCell);
	if (nCell<nMaxCell) {
		nodeOverwriteCell(pRtree, pNode, pCell, nCell);
		writeInt16(&pNode->zData[2], nCell + 1);
		pNode->isDirty = 1;
	}

	return (nCell == nMaxCell);
}


static int nodeWrite(Rtree *pRtree, RtreeNode *pNode) {
	int rc = SQLITE_OK;
	if (pNode->isDirty) {
		sqlite3_stmt *p = pRtree->pWriteNode;
		if (pNode->iNode) {
			sqlite3_bind_int64(p, 1, pNode->iNode);
		}
		else {
			sqlite3_bind_null(p, 1);
		}
		sqlite3_bind_blob(p, 2, pNode->zData, pRtree->iNodeSize, SQLITE_STATIC);
		sqlite3_step(p);
		pNode->isDirty = 0;
		rc = sqlite3_reset(p);
		if (pNode->iNode == 0 && rc == SQLITE_OK) {
			pNode->iNode = sqlite3_last_insert_rowid(pRtree->db);
			nodeHashInsert(pRtree, pNode);
		}
	}
	return rc;
}


static int nodeRelease(Rtree *pRtree, RtreeNode *pNode) {
	int rc = SQLITE_OK;
	if (pNode) {
		assert(pNode->nRef>0);
		pNode->nRef--;
		if (pNode->nRef == 0) {
			if (pNode->iNode == 1) {
				pRtree->iDepth = -1;
			}
			if (pNode->pParent) {
				rc = nodeRelease(pRtree, pNode->pParent);
			}
			if (rc == SQLITE_OK) {
				rc = nodeWrite(pRtree, pNode);
			}
			nodeHashDelete(pRtree, pNode);
			sqlite3_free(pNode);
		}
	}
	return rc;
}


static i64 nodeGetRowid(
	Rtree *pRtree,       
	RtreeNode *pNode,    
	int iCell            
) {
	assert(iCell<NCELL(pNode));
	return readInt64(&pNode->zData[4 + pRtree->nBytesPerCell*iCell]);
}


static void nodeGetCoord(
	Rtree *pRtree,               
	RtreeNode *pNode,            
	int iCell,                   
	int iCoord,                  
	RtreeCoord *pCoord           
) {
	readCoord(&pNode->zData[12 + pRtree->nBytesPerCell*iCell + 4 * iCoord], pCoord);
}


static void nodeGetCell(
	Rtree *pRtree,               
	RtreeNode *pNode,            
	int iCell,                   
	RtreeCell *pCell             
) {
	u8 *pData;
	RtreeCoord *pCoord;
	int ii;
	pCell->iRowid = nodeGetRowid(pRtree, pNode, iCell);
	pData = pNode->zData + (12 + pRtree->nBytesPerCell*iCell);
	pCoord = pCell->aCoord;
	for (ii = 0; ii<pRtree->nDim * 2; ii++) {
		readCoord(&pData[ii * 4], &pCoord[ii]);
	}
}



static int rtreeInit(
	sqlite3 *, void *, int, const char *const*, sqlite3_vtab **, char **, int
);


static int rtreeCreate(
	sqlite3 *db,
	void *pAux,
	int argc, const char *const*argv,
	sqlite3_vtab **ppVtab,
	char **pzErr
) {
	return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 1);
}


static int rtreeConnect(
	sqlite3 *db,
	void *pAux,
	int argc, const char *const*argv,
	sqlite3_vtab **ppVtab,
	char **pzErr
) {
	return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 0);
}


static void rtreeReference(Rtree *pRtree) {
	pRtree->nBusy++;
}


static void rtreeRelease(Rtree *pRtree) {
	pRtree->nBusy--;
	if (pRtree->nBusy == 0) {
		sqlite3_finalize(pRtree->pReadNode);
		sqlite3_finalize(pRtree->pWriteNode);
		sqlite3_finalize(pRtree->pDeleteNode);
		sqlite3_finalize(pRtree->pReadRowid);
		sqlite3_finalize(pRtree->pWriteRowid);
		sqlite3_finalize(pRtree->pDeleteRowid);
		sqlite3_finalize(pRtree->pReadParent);
		sqlite3_finalize(pRtree->pWriteParent);
		sqlite3_finalize(pRtree->pDeleteParent);
		sqlite3_free(pRtree);
	}
}


static int rtreeDisconnect(sqlite3_vtab *pVtab) {
	rtreeRelease((Rtree *)pVtab);
	return SQLITE_OK;
}


static int rtreeDestroy(sqlite3_vtab *pVtab) {
	Rtree *pRtree = (Rtree *)pVtab;
	int rc;
	char *zCreate = sqlite3_mprintf(
		"DROP TABLE '%q'.'%q_node';"
		"DROP TABLE '%q'.'%q_rowid';"
		"DROP TABLE '%q'.'%q_parent';",
		pRtree->zDb, pRtree->zName,
		pRtree->zDb, pRtree->zName,
		pRtree->zDb, pRtree->zName
	);
	if (!zCreate) {
		rc = SQLITE_NOMEM;
	}
	else {
		rc = sqlite3_exec(pRtree->db, zCreate, 0, 0, 0);
		sqlite3_free(zCreate);
	}
	if (rc == SQLITE_OK) {
		rtreeRelease(pRtree);
	}

	return rc;
}


static int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor) {
	int rc = SQLITE_NOMEM;
	RtreeCursor *pCsr;

	pCsr = (RtreeCursor *)sqlite3_malloc(sizeof(RtreeCursor));
	if (pCsr) {
		memset(pCsr, 0, sizeof(RtreeCursor));
		pCsr->base.pVtab = pVTab;
		rc = SQLITE_OK;
	}
	*ppCursor = (sqlite3_vtab_cursor *)pCsr;

	return rc;
}



static void freeCursorConstraints(RtreeCursor *pCsr) {
	if (pCsr->aConstraint) {
		int i;                        
		for (i = 0; i<pCsr->nConstraint; i++) {
			sqlite3_rtree_query_info *pInfo = pCsr->aConstraint[i].pInfo;
			if (pInfo) {
				if (pInfo->xDelUser) pInfo->xDelUser(pInfo->pUser);
				sqlite3_free(pInfo);
			}
		}
		sqlite3_free(pCsr->aConstraint);
		pCsr->aConstraint = 0;
	}
}


static int rtreeClose(sqlite3_vtab_cursor *cur) {
	Rtree *pRtree = (Rtree *)(cur->pVtab);
	int ii;
	RtreeCursor *pCsr = (RtreeCursor *)cur;
	freeCursorConstraints(pCsr);
	sqlite3_free(pCsr->aPoint);
	for (ii = 0; ii<RTREE_CACHE_SZ; ii++) nodeRelease(pRtree, pCsr->aNode[ii]);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}


static int rtreeEof(sqlite3_vtab_cursor *cur) {
	RtreeCursor *pCsr = (RtreeCursor *)cur;
	return pCsr->atEOF;
}


#if defined(SQLITE_BYTEORDER) && SQLITE_BYTEORDER==1234
#define RTREE_DECODE_COORD(eInt, a, r) {                        \
    RtreeCoord c;                       \
    memcpy(&c.u,a,4);                                           \
    c.u = ((c.u>>24)&0xff)|((c.u>>8)&0xff00)|                   \
          ((c.u&0xff)<<24)|((c.u&0xff00)<<8);                   \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}
#elif defined(SQLITE_BYTEORDER) && SQLITE_BYTEORDER==4321
#define RTREE_DECODE_COORD(eInt, a, r) {                        \
    RtreeCoord c;                       \
    memcpy(&c.u,a,4);                                           \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}
#else
#define RTREE_DECODE_COORD(eInt, a, r) {                        \
    RtreeCoord c;                       \
    c.u = ((u32)a[0]<<24) + ((u32)a[1]<<16)                     \
           +((u32)a[2]<<8) + a[3];                              \
    r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; \
}
#endif


static int rtreeCallbackConstraint(
	RtreeConstraint *pConstraint,  
	int eInt,                      
	u8 *pCellData,                 
	RtreeSearchPoint *pSearch,     
	sqlite3_rtree_dbl *prScore,    
	int *peWithin                  
) {
	int i;                                                
	sqlite3_rtree_query_info *pInfo = pConstraint->pInfo; 
	int nCoord = pInfo->nCoord;                           
	int rc;                                             
	sqlite3_rtree_dbl aCoord[RTREE_MAX_DIMENSIONS * 2];   

	assert(pConstraint->op == RTREE_MATCH || pConstraint->op == RTREE_QUERY);
	assert(nCoord == 2 || nCoord == 4 || nCoord == 6 || nCoord == 8 || nCoord == 10);

	if (pConstraint->op == RTREE_QUERY && pSearch->iLevel == 1) {
		pInfo->iRowid = readInt64(pCellData);
	}
	pCellData += 8;
	for (i = 0; i<nCoord; i++, pCellData += 4) {
		RTREE_DECODE_COORD(eInt, pCellData, aCoord[i]);
	}
	if (pConstraint->op == RTREE_MATCH) {
		rc = pConstraint->u.xGeom((sqlite3_rtree_geometry*)pInfo,
			nCoord, aCoord, &i);
		if (i == 0) *peWithin = NOT_WITHIN;
		*prScore = RTREE_ZERO;
	}
	else {
		pInfo->aCoord = aCoord;
		pInfo->iLevel = pSearch->iLevel - 1;
		pInfo->rScore = pInfo->rParentScore = pSearch->rScore;
		pInfo->eWithin = pInfo->eParentWithin = pSearch->eWithin;
		rc = pConstraint->u.xQueryFunc(pInfo);
		if (pInfo->eWithin<*peWithin) *peWithin = pInfo->eWithin;
		if (pInfo->rScore<*prScore || *prScore<RTREE_ZERO) {
			*prScore = pInfo->rScore;
		}
	}
	return rc;
}


static void rtreeNonleafConstraint(
	RtreeConstraint *p,        
	int eInt,                  
	u8 *pCellData,             
	int *peWithin              
) {
	sqlite3_rtree_dbl val;     

							   
	pCellData += 8 + 4 * (p->iCoord & 0xfe);

	assert(p->op == RTREE_LE || p->op == RTREE_LT || p->op == RTREE_GE
		|| p->op == RTREE_GT || p->op == RTREE_EQ);
	switch (p->op) {
	case RTREE_LE:
	case RTREE_LT:
	case RTREE_EQ:
		RTREE_DECODE_COORD(eInt, pCellData, val);
		
		if (p->u.rValue >= val) return;
		if (p->op != RTREE_EQ) break;  
									   

	default: 
		pCellData += 4;
		RTREE_DECODE_COORD(eInt, pCellData, val);
		
		if (p->u.rValue <= val) return;
	}
	*peWithin = NOT_WITHIN;
}


static void rtreeLeafConstraint(
	RtreeConstraint *p,        
	int eInt,                  
	u8 *pCellData,             
	int *peWithin              
) {
	RtreeDValue xN;      

	assert(p->op == RTREE_LE || p->op == RTREE_LT || p->op == RTREE_GE
		|| p->op == RTREE_GT || p->op == RTREE_EQ);
	pCellData += 8 + p->iCoord * 4;
	RTREE_DECODE_COORD(eInt, pCellData, xN);
	switch (p->op) {
	case RTREE_LE: if (xN <= p->u.rValue) return;  break;
	case RTREE_LT: if (xN <  p->u.rValue) return;  break;
	case RTREE_GE: if (xN >= p->u.rValue) return;  break;
	case RTREE_GT: if (xN >  p->u.rValue) return;  break;
	default:       if (xN == p->u.rValue) return;  break;
	}
	*peWithin = NOT_WITHIN;
}


static int nodeRowidIndex(
	Rtree *pRtree,
	RtreeNode *pNode,
	i64 iRowid,
	int *piIndex
) {
	int ii;
	int nCell = NCELL(pNode);
	assert(nCell<200);
	for (ii = 0; ii<nCell; ii++) {
		if (nodeGetRowid(pRtree, pNode, ii) == iRowid) {
			*piIndex = ii;
			return SQLITE_OK;
		}
	}
	return SQLITE_CORRUPT_VTAB;
}


static int nodeParentIndex(Rtree *pRtree, RtreeNode *pNode, int *piIndex) {
	RtreeNode *pParent = pNode->pParent;
	if (pParent) {
		return nodeRowidIndex(pRtree, pParent, pNode->iNode, piIndex);
	}
	*piIndex = -1;
	return SQLITE_OK;
}


static int rtreeSearchPointCompare(
	const RtreeSearchPoint *pA,
	const RtreeSearchPoint *pB
) {
	if (pA->rScore<pB->rScore) return -1;
	if (pA->rScore>pB->rScore) return +1;
	if (pA->iLevel<pB->iLevel) return -1;
	if (pA->iLevel>pB->iLevel) return +1;
	return 0;
}


static void rtreeSearchPointSwap(RtreeCursor *p, int i, int j) {
	RtreeSearchPoint t = p->aPoint[i];
	assert(i<j);
	p->aPoint[i] = p->aPoint[j];
	p->aPoint[j] = t;
	i++; j++;
	if (i<RTREE_CACHE_SZ) {
		if (j >= RTREE_CACHE_SZ) {
			nodeRelease(RTREE_OF_CURSOR(p), p->aNode[i]);
			p->aNode[i] = 0;
		}
		else {
			RtreeNode *pTemp = p->aNode[i];
			p->aNode[i] = p->aNode[j];
			p->aNode[j] = pTemp;
		}
	}
}


static RtreeSearchPoint *rtreeSearchPointFirst(RtreeCursor *pCur) {
	return pCur->bPoint ? &pCur->sPoint : pCur->nPoint ? pCur->aPoint : 0;
}


static RtreeNode *rtreeNodeOfFirstSearchPoint(RtreeCursor *pCur, int *pRC) {
	sqlite3_int64 id;
	int ii = 1 - pCur->bPoint;
	assert(ii == 0 || ii == 1);
	assert(pCur->bPoint || pCur->nPoint);
	if (pCur->aNode[ii] == 0) {
		assert(pRC != 0);
		id = ii ? pCur->aPoint[0].id : pCur->sPoint.id;
		*pRC = nodeAcquire(RTREE_OF_CURSOR(pCur), id, 0, &pCur->aNode[ii]);
	}
	return pCur->aNode[ii];
}


static RtreeSearchPoint *rtreeEnqueue(
	RtreeCursor *pCur,    
	RtreeDValue rScore,   
	u8 iLevel             
) {
	int i, j;
	RtreeSearchPoint *pNew;
	if (pCur->nPoint >= pCur->nPointAlloc) {
		int nNew = pCur->nPointAlloc * 2 + 8;
		pNew = sqlite3_realloc(pCur->aPoint, nNew * sizeof(pCur->aPoint[0]));
		if (pNew == 0) return 0;
		pCur->aPoint = pNew;
		pCur->nPointAlloc = nNew;
	}
	i = pCur->nPoint++;
	pNew = pCur->aPoint + i;
	pNew->rScore = rScore;
	pNew->iLevel = iLevel;
	assert(iLevel <= RTREE_MAX_DEPTH);
	while (i>0) {
		RtreeSearchPoint *pParent;
		j = (i - 1) / 2;
		pParent = pCur->aPoint + j;
		if (rtreeSearchPointCompare(pNew, pParent) >= 0) break;
		rtreeSearchPointSwap(pCur, j, i);
		i = j;
		pNew = pParent;
	}
	return pNew;
}


static RtreeSearchPoint *rtreeSearchPointNew(
	RtreeCursor *pCur,    
	RtreeDValue rScore,   
	u8 iLevel             
) {
	RtreeSearchPoint *pNew, *pFirst;
	pFirst = rtreeSearchPointFirst(pCur);
	pCur->anQueue[iLevel]++;
	if (pFirst == 0
		|| pFirst->rScore>rScore
		|| (pFirst->rScore == rScore && pFirst->iLevel>iLevel)
		) {
		if (pCur->bPoint) {
			int ii;
			pNew = rtreeEnqueue(pCur, rScore, iLevel);
			if (pNew == 0) return 0;
			ii = (int)(pNew - pCur->aPoint) + 1;
			if (ii<RTREE_CACHE_SZ) {
				assert(pCur->aNode[ii] == 0);
				pCur->aNode[ii] = pCur->aNode[0];
			}
			else {
				nodeRelease(RTREE_OF_CURSOR(pCur), pCur->aNode[0]);
			}
			pCur->aNode[0] = 0;
			*pNew = pCur->sPoint;
		}
		pCur->sPoint.rScore = rScore;
		pCur->sPoint.iLevel = iLevel;
		pCur->bPoint = 1;
		return &pCur->sPoint;
	}
	else {
		return rtreeEnqueue(pCur, rScore, iLevel);
	}
}

#if 0

static void tracePoint(RtreeSearchPoint *p, int idx, RtreeCursor *pCur) {
	if (idx<0) { printf(" s"); }
	else { printf("%2d", idx); }
	printf(" %d.%05lld.%02d %g %d",
		p->iLevel, p->id, p->iCell, p->rScore, p->eWithin
	);
	idx++;
	if (idx<RTREE_CACHE_SZ) {
		printf(" %p\n", pCur->aNode[idx]);
	}
	else {
		printf("\n");
	}
}
static void traceQueue(RtreeCursor *pCur, const char *zPrefix) {
	int ii;
	printf("=== %9s ", zPrefix);
	if (pCur->bPoint) {
		tracePoint(&pCur->sPoint, -1, pCur);
	}
	for (ii = 0; ii<pCur->nPoint; ii++) {
		if (ii>0 || pCur->bPoint) printf("              ");
		tracePoint(&pCur->aPoint[ii], ii, pCur);
	}
}
# define RTREE_QUEUE_TRACE(A,B) traceQueue(A,B)
#else
# define RTREE_QUEUE_TRACE(A,B)   
#endif


static void rtreeSearchPointPop(RtreeCursor *p) {
	int i, j, k, n;
	i = 1 - p->bPoint;
	assert(i == 0 || i == 1);
	if (p->aNode[i]) {
		nodeRelease(RTREE_OF_CURSOR(p), p->aNode[i]);
		p->aNode[i] = 0;
	}
	if (p->bPoint) {
		p->anQueue[p->sPoint.iLevel]--;
		p->bPoint = 0;
	}
	else if (p->nPoint) {
		p->anQueue[p->aPoint[0].iLevel]--;
		n = --p->nPoint;
		p->aPoint[0] = p->aPoint[n];
		if (n<RTREE_CACHE_SZ - 1) {
			p->aNode[1] = p->aNode[n + 1];
			p->aNode[n + 1] = 0;
		}
		i = 0;
		while ((j = i * 2 + 1)<n) {
			k = j + 1;
			if (k<n && rtreeSearchPointCompare(&p->aPoint[k], &p->aPoint[j])<0) {
				if (rtreeSearchPointCompare(&p->aPoint[k], &p->aPoint[i])<0) {
					rtreeSearchPointSwap(p, i, k);
					i = k;
				}
				else {
					break;
				}
			}
			else {
				if (rtreeSearchPointCompare(&p->aPoint[j], &p->aPoint[i])<0) {
					rtreeSearchPointSwap(p, i, j);
					i = j;
				}
				else {
					break;
				}
			}
		}
	}
}



static int rtreeStepToLeaf(RtreeCursor *pCur) {
	RtreeSearchPoint *p;
	Rtree *pRtree = RTREE_OF_CURSOR(pCur);
	RtreeNode *pNode;
	int eWithin;
	int rc = SQLITE_OK;
	int nCell;
	int nConstraint = pCur->nConstraint;
	int ii;
	int eInt;
	RtreeSearchPoint x;

	eInt = pRtree->eCoordType == RTREE_COORD_INT32;
	while ((p = rtreeSearchPointFirst(pCur)) != 0 && p->iLevel>0) {
		pNode = rtreeNodeOfFirstSearchPoint(pCur, &rc);
		if (rc) return rc;
		nCell = NCELL(pNode);
		assert(nCell<200);
		while (p->iCell<nCell) {
			sqlite3_rtree_dbl rScore = (sqlite3_rtree_dbl)-1;
			u8 *pCellData = pNode->zData + (4 + pRtree->nBytesPerCell*p->iCell);
			eWithin = FULLY_WITHIN;
			for (ii = 0; ii<nConstraint; ii++) {
				RtreeConstraint *pConstraint = pCur->aConstraint + ii;
				if (pConstraint->op >= RTREE_MATCH) {
					rc = rtreeCallbackConstraint(pConstraint, eInt, pCellData, p,
						&rScore, &eWithin);
					if (rc) return rc;
				}
				else if (p->iLevel == 1) {
					rtreeLeafConstraint(pConstraint, eInt, pCellData, &eWithin);
				}
				else {
					rtreeNonleafConstraint(pConstraint, eInt, pCellData, &eWithin);
				}
				if (eWithin == NOT_WITHIN) break;
			}
			p->iCell++;
			if (eWithin == NOT_WITHIN) continue;
			x.iLevel = p->iLevel - 1;
			if (x.iLevel) {
				x.id = readInt64(pCellData);
				x.iCell = 0;
			}
			else {
				x.id = p->id;
				x.iCell = p->iCell - 1;
			}
			if (p->iCell >= nCell) {
				RTREE_QUEUE_TRACE(pCur, "POP-S:");
				rtreeSearchPointPop(pCur);
			}
			if (rScore<RTREE_ZERO) rScore = RTREE_ZERO;
			p = rtreeSearchPointNew(pCur, rScore, x.iLevel);
			if (p == 0) return SQLITE_NOMEM;
			p->eWithin = eWithin;
			p->id = x.id;
			p->iCell = x.iCell;
			RTREE_QUEUE_TRACE(pCur, "PUSH-S:");
			break;
		}
		if (p->iCell >= nCell) {
			RTREE_QUEUE_TRACE(pCur, "POP-Se:");
			rtreeSearchPointPop(pCur);
		}
	}
	pCur->atEOF = p == 0;
	return SQLITE_OK;
}


static int rtreeNext(sqlite3_vtab_cursor *pVtabCursor) {
	RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;
	int rc = SQLITE_OK;

	
	RTREE_QUEUE_TRACE(pCsr, "POP-Nx:");
	rtreeSearchPointPop(pCsr);
	rc = rtreeStepToLeaf(pCsr);
	return rc;
}


static int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid) {
	RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;
	RtreeSearchPoint *p = rtreeSearchPointFirst(pCsr);
	int rc = SQLITE_OK;
	RtreeNode *pNode = rtreeNodeOfFirstSearchPoint(pCsr, &rc);
	if (rc == SQLITE_OK && p) {
		*pRowid = nodeGetRowid(RTREE_OF_CURSOR(pCsr), pNode, p->iCell);
	}
	return rc;
}


static int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i) {
	Rtree *pRtree = (Rtree *)cur->pVtab;
	RtreeCursor *pCsr = (RtreeCursor *)cur;
	RtreeSearchPoint *p = rtreeSearchPointFirst(pCsr);
	RtreeCoord c;
	int rc = SQLITE_OK;
	RtreeNode *pNode = rtreeNodeOfFirstSearchPoint(pCsr, &rc);

	if (rc) return rc;
	if (p == 0) return SQLITE_OK;
	if (i == 0) {
		sqlite3_result_int64(ctx, nodeGetRowid(pRtree, pNode, p->iCell));
	}
	else {
		if (rc) return rc;
		nodeGetCoord(pRtree, pNode, p->iCell, i - 1, &c);
#ifndef SQLITE_RTREE_INT_ONLY
		if (pRtree->eCoordType == RTREE_COORD_REAL32) {
			sqlite3_result_double(ctx, c.f);
		}
		else
#endif
		{
			assert(pRtree->eCoordType == RTREE_COORD_INT32);
			sqlite3_result_int(ctx, c.i);
		}
	}
	return SQLITE_OK;
}


static int findLeafNode(
	Rtree *pRtree,              
	i64 iRowid,                 
	RtreeNode **ppLeaf,         
	sqlite3_int64 *piNode       
) {
	int rc;
	*ppLeaf = 0;
	sqlite3_bind_int64(pRtree->pReadRowid, 1, iRowid);
	if (sqlite3_step(pRtree->pReadRowid) == SQLITE_ROW) {
		i64 iNode = sqlite3_column_int64(pRtree->pReadRowid, 0);
		if (piNode) *piNode = iNode;
		rc = nodeAcquire(pRtree, iNode, 0, ppLeaf);
		sqlite3_reset(pRtree->pReadRowid);
	}
	else {
		rc = sqlite3_reset(pRtree->pReadRowid);
	}
	return rc;
}


static int deserializeGeometry(sqlite3_value *pValue, RtreeConstraint *pCons) {
	RtreeMatchArg *pBlob;              
	sqlite3_rtree_query_info *pInfo;   
	int nBlob;                         
	int nExpected;                     

									   
	if (sqlite3_value_type(pValue) != SQLITE_BLOB) return SQLITE_ERROR;

	
	nBlob = sqlite3_value_bytes(pValue);
	if (nBlob<(int)sizeof(RtreeMatchArg)) {
		return SQLITE_ERROR;
	}

	pInfo = (sqlite3_rtree_query_info*)sqlite3_malloc(sizeof(*pInfo) + nBlob);
	if (!pInfo) return SQLITE_NOMEM;
	memset(pInfo, 0, sizeof(*pInfo));
	pBlob = (RtreeMatchArg*)&pInfo[1];

	memcpy(pBlob, sqlite3_value_blob(pValue), nBlob);
	nExpected = (int)(sizeof(RtreeMatchArg) +
		pBlob->nParam * sizeof(sqlite3_value*) +
		(pBlob->nParam - 1) * sizeof(RtreeDValue));
	if (pBlob->magic != RTREE_GEOMETRY_MAGIC || nBlob != nExpected) {
		sqlite3_free(pInfo);
		return SQLITE_ERROR;
	}
	pInfo->pContext = pBlob->cb.pContext;
	pInfo->nParam = pBlob->nParam;
	pInfo->aParam = pBlob->aParam;
	pInfo->apSqlParam = pBlob->apSqlParam;

	if (pBlob->cb.xGeom) {
		pCons->u.xGeom = pBlob->cb.xGeom;
	}
	else {
		pCons->op = RTREE_QUERY;
		pCons->u.xQueryFunc = pBlob->cb.xQueryFunc;
	}
	pCons->pInfo = pInfo;
	return SQLITE_OK;
}


static int rtreeFilter(
	sqlite3_vtab_cursor *pVtabCursor,
	int idxNum, const char *idxStr,
	int argc, sqlite3_value **argv
) {
	Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;
	RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;
	RtreeNode *pRoot = 0;
	int ii;
	int rc = SQLITE_OK;
	int iCell = 0;

	rtreeReference(pRtree);

	
	freeCursorConstraints(pCsr);
	sqlite3_free(pCsr->aPoint);
	memset(pCsr, 0, sizeof(RtreeCursor));
	pCsr->base.pVtab = (sqlite3_vtab*)pRtree;

	pCsr->iStrategy = idxNum;
	if (idxNum == 1) {
		
		RtreeNode *pLeaf;        
		RtreeSearchPoint *p;     
		i64 iRowid = sqlite3_value_int64(argv[0]);
		i64 iNode = 0;
		rc = findLeafNode(pRtree, iRowid, &pLeaf, &iNode);
		if (rc == SQLITE_OK && pLeaf != 0) {
			p = rtreeSearchPointNew(pCsr, RTREE_ZERO, 0);
			assert(p != 0);  
			pCsr->aNode[0] = pLeaf;
			p->id = iNode;
			p->eWithin = PARTLY_WITHIN;
			rc = nodeRowidIndex(pRtree, pLeaf, iRowid, &iCell);
			p->iCell = iCell;
			RTREE_QUEUE_TRACE(pCsr, "PUSH-F1:");
		}
		else {
			pCsr->atEOF = 1;
		}
	}
	else {
		
		rc = nodeAcquire(pRtree, 1, 0, &pRoot);
		if (rc == SQLITE_OK && argc>0) {
			pCsr->aConstraint = sqlite3_malloc(sizeof(RtreeConstraint)*argc);
			pCsr->nConstraint = argc;
			if (!pCsr->aConstraint) {
				rc = SQLITE_NOMEM;
			}
			else {
				memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);
				memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));
				assert((idxStr == 0 && argc == 0)
					|| (idxStr && (int)strlen(idxStr) == argc * 2));
				for (ii = 0; ii<argc; ii++) {
					RtreeConstraint *p = &pCsr->aConstraint[ii];
					p->op = idxStr[ii * 2];
					p->iCoord = idxStr[ii * 2 + 1] - '0';
					if (p->op >= RTREE_MATCH) {
						
						rc = deserializeGeometry(argv[ii], p);
						if (rc != SQLITE_OK) {
							break;
						}
						p->pInfo->nCoord = pRtree->nDim * 2;
						p->pInfo->anQueue = pCsr->anQueue;
						p->pInfo->mxLevel = pRtree->iDepth + 1;
					}
					else {
#ifdef SQLITE_RTREE_INT_ONLY
						p->u.rValue = sqlite3_value_int64(argv[ii]);
#else
						p->u.rValue = sqlite3_value_double(argv[ii]);
#endif
					}
				}
			}
		}
		if (rc == SQLITE_OK) {
			RtreeSearchPoint *pNew;
			pNew = rtreeSearchPointNew(pCsr, RTREE_ZERO, pRtree->iDepth + 1);
			if (pNew == 0) return SQLITE_NOMEM;
			pNew->id = 1;
			pNew->iCell = 0;
			pNew->eWithin = PARTLY_WITHIN;
			assert(pCsr->bPoint == 1);
			pCsr->aNode[0] = pRoot;
			pRoot = 0;
			RTREE_QUEUE_TRACE(pCsr, "PUSH-Fm:");
			rc = rtreeStepToLeaf(pCsr);
		}
	}

	nodeRelease(pRtree, pRoot);
	rtreeRelease(pRtree);
	return rc;
}


static void setEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow) {
#if SQLITE_VERSION_NUMBER>=3008002
	if (sqlite3_libversion_number() >= 3008002) {
		pIdxInfo->estimatedRows = nRow;
	}
#endif
}


static int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo) {
	Rtree *pRtree = (Rtree*)tab;
	int rc = SQLITE_OK;
	int ii;
	int bMatch = 0;                 
	i64 nRow;                       

	int iIdx = 0;
	char zIdxStr[RTREE_MAX_DIMENSIONS * 8 + 1];
	memset(zIdxStr, 0, sizeof(zIdxStr));

	
	for (ii = 0; ii<pIdxInfo->nConstraint; ii++) {
		if (pIdxInfo->aConstraint[ii].op == SQLITE_INDEX_CONSTRAINT_MATCH) {
			bMatch = 1;
		}
	}

	assert(pIdxInfo->idxStr == 0);
	for (ii = 0; ii<pIdxInfo->nConstraint && iIdx<(int)(sizeof(zIdxStr) - 1); ii++) {
		struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[ii];

		if (bMatch == 0 && p->usable
			&& p->iColumn == 0 && p->op == SQLITE_INDEX_CONSTRAINT_EQ
			) {
			
			int jj;
			for (jj = 0; jj<ii; jj++) {
				pIdxInfo->aConstraintUsage[jj].argvIndex = 0;
				pIdxInfo->aConstraintUsage[jj].omit = 0;
			}
			pIdxInfo->idxNum = 1;
			pIdxInfo->aConstraintUsage[ii].argvIndex = 1;
			pIdxInfo->aConstraintUsage[jj].omit = 1;

			
			pIdxInfo->estimatedCost = 30.0;
			setEstimatedRows(pIdxInfo, 1);
			return SQLITE_OK;
		}

		if (p->usable && (p->iColumn>0 || p->op == SQLITE_INDEX_CONSTRAINT_MATCH)) {
			u8 op;
			switch (p->op) {
			case SQLITE_INDEX_CONSTRAINT_EQ: op = RTREE_EQ; break;
			case SQLITE_INDEX_CONSTRAINT_GT: op = RTREE_GT; break;
			case SQLITE_INDEX_CONSTRAINT_LE: op = RTREE_LE; break;
			case SQLITE_INDEX_CONSTRAINT_LT: op = RTREE_LT; break;
			case SQLITE_INDEX_CONSTRAINT_GE: op = RTREE_GE; break;
			default:
				assert(p->op == SQLITE_INDEX_CONSTRAINT_MATCH);
				op = RTREE_MATCH;
				break;
			}
			zIdxStr[iIdx++] = op;
			zIdxStr[iIdx++] = p->iColumn - 1 + '0';
			pIdxInfo->aConstraintUsage[ii].argvIndex = (iIdx / 2);
			pIdxInfo->aConstraintUsage[ii].omit = 1;
		}
	}

	pIdxInfo->idxNum = 2;
	pIdxInfo->needToFreeIdxStr = 1;
	if (iIdx>0 && 0 == (pIdxInfo->idxStr = sqlite3_mprintf("%s", zIdxStr))) {
		return SQLITE_NOMEM;
	}

	nRow = pRtree->nRowEst >> (iIdx / 2);
	pIdxInfo->estimatedCost = (double)6.0 * (double)nRow;
	setEstimatedRows(pIdxInfo, nRow);

	return rc;
}


static RtreeDValue cellArea(Rtree *pRtree, RtreeCell *p) {
	RtreeDValue area = (RtreeDValue)1;
	int ii;
	for (ii = 0; ii<(pRtree->nDim * 2); ii += 2) {
		area = (area * (DCOORD(p->aCoord[ii + 1]) - DCOORD(p->aCoord[ii])));
	}
	return area;
}


static RtreeDValue cellMargin(Rtree *pRtree, RtreeCell *p) {
	RtreeDValue margin = (RtreeDValue)0;
	int ii;
	for (ii = 0; ii<(pRtree->nDim * 2); ii += 2) {
		margin += (DCOORD(p->aCoord[ii + 1]) - DCOORD(p->aCoord[ii]));
	}
	return margin;
}


static void cellUnion(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2) {
	int ii;
	if (pRtree->eCoordType == RTREE_COORD_REAL32) {
		for (ii = 0; ii<(pRtree->nDim * 2); ii += 2) {
			p1->aCoord[ii].f = MIN(p1->aCoord[ii].f, p2->aCoord[ii].f);
			p1->aCoord[ii + 1].f = MAX(p1->aCoord[ii + 1].f, p2->aCoord[ii + 1].f);
		}
	}
	else {
		for (ii = 0; ii<(pRtree->nDim * 2); ii += 2) {
			p1->aCoord[ii].i = MIN(p1->aCoord[ii].i, p2->aCoord[ii].i);
			p1->aCoord[ii + 1].i = MAX(p1->aCoord[ii + 1].i, p2->aCoord[ii + 1].i);
		}
	}
}


static int cellContains(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2) {
	int ii;
	int isInt = (pRtree->eCoordType == RTREE_COORD_INT32);
	for (ii = 0; ii<(pRtree->nDim * 2); ii += 2) {
		RtreeCoord *a1 = &p1->aCoord[ii];
		RtreeCoord *a2 = &p2->aCoord[ii];
		if ((!isInt && (a2[0].f<a1[0].f || a2[1].f>a1[1].f))
			|| (isInt && (a2[0].i<a1[0].i || a2[1].i>a1[1].i))
			) {
			return 0;
		}
	}
	return 1;
}


static RtreeDValue cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell) {
	RtreeDValue area;
	RtreeCell cell;
	memcpy(&cell, p, sizeof(RtreeCell));
	area = cellArea(pRtree, &cell);
	cellUnion(pRtree, &cell, pCell);
	return (cellArea(pRtree, &cell) - area);
}

static RtreeDValue cellOverlap(
	Rtree *pRtree,
	RtreeCell *p,
	RtreeCell *aCell,
	int nCell
) {
	int ii;
	RtreeDValue overlap = RTREE_ZERO;
	for (ii = 0; ii<nCell; ii++) {
		int jj;
		RtreeDValue o = (RtreeDValue)1;
		for (jj = 0; jj<(pRtree->nDim * 2); jj += 2) {
			RtreeDValue x1, x2;
			x1 = MAX(DCOORD(p->aCoord[jj]), DCOORD(aCell[ii].aCoord[jj]));
			x2 = MIN(DCOORD(p->aCoord[jj + 1]), DCOORD(aCell[ii].aCoord[jj + 1]));
			if (x2<x1) {
				o = (RtreeDValue)0;
				break;
			}
			else {
				o = o * (x2 - x1);
			}
		}
		overlap += o;
	}
	return overlap;
}



static int ChooseLeaf(
	Rtree *pRtree,               
	RtreeCell *pCell,            
	int iHeight,                 
	RtreeNode **ppLeaf           
) {
	int rc;
	int ii;
	RtreeNode *pNode;
	rc = nodeAcquire(pRtree, 1, 0, &pNode);

	for (ii = 0; rc == SQLITE_OK && ii<(pRtree->iDepth - iHeight); ii++) {
		int iCell;
		sqlite3_int64 iBest = 0;

		RtreeDValue fMinGrowth = RTREE_ZERO;
		RtreeDValue fMinArea = RTREE_ZERO;

		int nCell = NCELL(pNode);
		RtreeCell cell;
		RtreeNode *pChild;

		RtreeCell *aCell = 0;

		
		for (iCell = 0; iCell<nCell; iCell++) {
			int bBest = 0;
			RtreeDValue growth;
			RtreeDValue area;
			nodeGetCell(pRtree, pNode, iCell, &cell);
			growth = cellGrowth(pRtree, &cell, pCell);
			area = cellArea(pRtree, &cell);
			if (iCell == 0 || growth<fMinGrowth || (growth == fMinGrowth && area<fMinArea)) {
				bBest = 1;
			}
			if (bBest) {
				fMinGrowth = growth;
				fMinArea = area;
				iBest = cell.iRowid;
			}
		}

		sqlite3_free(aCell);
		rc = nodeAcquire(pRtree, iBest, pNode, &pChild);
		nodeRelease(pRtree, pNode);
		pNode = pChild;
	}

	*ppLeaf = pNode;
	return rc;
}


static int AdjustTree(
	Rtree *pRtree,                    
	RtreeNode *pNode,                 
	RtreeCell *pCell                  
) {
	RtreeNode *p = pNode;
	while (p->pParent) {
		RtreeNode *pParent = p->pParent;
		RtreeCell cell;
		int iCell;

		if (nodeParentIndex(pRtree, p, &iCell)) {
			return SQLITE_CORRUPT_VTAB;
		}

		nodeGetCell(pRtree, pParent, iCell, &cell);
		if (!cellContains(pRtree, &cell, pCell)) {
			cellUnion(pRtree, &cell, pCell);
			nodeOverwriteCell(pRtree, pParent, &cell, iCell);
		}

		p = pParent;
	}
	return SQLITE_OK;
}


static int rowidWrite(Rtree *pRtree, sqlite3_int64 iRowid, sqlite3_int64 iNode) {
	sqlite3_bind_int64(pRtree->pWriteRowid, 1, iRowid);
	sqlite3_bind_int64(pRtree->pWriteRowid, 2, iNode);
	sqlite3_step(pRtree->pWriteRowid);
	return sqlite3_reset(pRtree->pWriteRowid);
}


static int parentWrite(Rtree *pRtree, sqlite3_int64 iNode, sqlite3_int64 iPar) {
	sqlite3_bind_int64(pRtree->pWriteParent, 1, iNode);
	sqlite3_bind_int64(pRtree->pWriteParent, 2, iPar);
	sqlite3_step(pRtree->pWriteParent);
	return sqlite3_reset(pRtree->pWriteParent);
}

static int rtreeInsertCell(Rtree *, RtreeNode *, RtreeCell *, int);



static void SortByDistance(
	int *aIdx,
	int nIdx,
	RtreeDValue *aDistance,
	int *aSpare
) {
	if (nIdx>1) {
		int iLeft = 0;
		int iRight = 0;

		int nLeft = nIdx / 2;
		int nRight = nIdx - nLeft;
		int *aLeft = aIdx;
		int *aRight = &aIdx[nLeft];

		SortByDistance(aLeft, nLeft, aDistance, aSpare);
		SortByDistance(aRight, nRight, aDistance, aSpare);

		memcpy(aSpare, aLeft, sizeof(int)*nLeft);
		aLeft = aSpare;

		while (iLeft<nLeft || iRight<nRight) {
			if (iLeft == nLeft) {
				aIdx[iLeft + iRight] = aRight[iRight];
				iRight++;
			}
			else if (iRight == nRight) {
				aIdx[iLeft + iRight] = aLeft[iLeft];
				iLeft++;
			}
			else {
				RtreeDValue fLeft = aDistance[aLeft[iLeft]];
				RtreeDValue fRight = aDistance[aRight[iRight]];
				if (fLeft<fRight) {
					aIdx[iLeft + iRight] = aLeft[iLeft];
					iLeft++;
				}
				else {
					aIdx[iLeft + iRight] = aRight[iRight];
					iRight++;
				}
			}
		}

#if 0
		
		{
			int jj;
			for (jj = 1; jj<nIdx; jj++) {
				RtreeDValue left = aDistance[aIdx[jj - 1]];
				RtreeDValue right = aDistance[aIdx[jj]];
				assert(left <= right);
			}
		}
#endif
	}
}


static void SortByDimension(
	Rtree *pRtree,
	int *aIdx,
	int nIdx,
	int iDim,
	RtreeCell *aCell,
	int *aSpare
) {
	if (nIdx>1) {

		int iLeft = 0;
		int iRight = 0;

		int nLeft = nIdx / 2;
		int nRight = nIdx - nLeft;
		int *aLeft = aIdx;
		int *aRight = &aIdx[nLeft];

		SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare);
		SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare);

		memcpy(aSpare, aLeft, sizeof(int)*nLeft);
		aLeft = aSpare;
		while (iLeft<nLeft || iRight<nRight) {
			RtreeDValue xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim * 2]);
			RtreeDValue xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim * 2 + 1]);
			RtreeDValue xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim * 2]);
			RtreeDValue xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim * 2 + 1]);
			if ((iLeft != nLeft) && ((iRight == nRight)
				|| (xleft1<xright1)
				|| (xleft1 == xright1 && xleft2<xright2)
				)) {
				aIdx[iLeft + iRight] = aLeft[iLeft];
				iLeft++;
			}
			else {
				aIdx[iLeft + iRight] = aRight[iRight];
				iRight++;
			}
		}

#if 0
		
		{
			int jj;
			for (jj = 1; jj<nIdx; jj++) {
				RtreeDValue xleft1 = aCell[aIdx[jj - 1]].aCoord[iDim * 2];
				RtreeDValue xleft2 = aCell[aIdx[jj - 1]].aCoord[iDim * 2 + 1];
				RtreeDValue xright1 = aCell[aIdx[jj]].aCoord[iDim * 2];
				RtreeDValue xright2 = aCell[aIdx[jj]].aCoord[iDim * 2 + 1];
				assert(xleft1 <= xright1 && (xleft1<xright1 || xleft2 <= xright2));
			}
		}
#endif
	}
}


static int splitNodeStartree(
	Rtree *pRtree,
	RtreeCell *aCell,
	int nCell,
	RtreeNode *pLeft,
	RtreeNode *pRight,
	RtreeCell *pBboxLeft,
	RtreeCell *pBboxRight
) {
	int **aaSorted;
	int *aSpare;
	int ii;

	int iBestDim = 0;
	int iBestSplit = 0;
	RtreeDValue fBestMargin = RTREE_ZERO;

	int nByte = (pRtree->nDim + 1)*(sizeof(int*) + nCell * sizeof(int));

	aaSorted = (int **)sqlite3_malloc(nByte);
	if (!aaSorted) {
		return SQLITE_NOMEM;
	}

	aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];
	memset(aaSorted, 0, nByte);
	for (ii = 0; ii<pRtree->nDim; ii++) {
		int jj;
		aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell];
		for (jj = 0; jj<nCell; jj++) {
			aaSorted[ii][jj] = jj;
		}
		SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare);
	}

	for (ii = 0; ii<pRtree->nDim; ii++) {
		RtreeDValue margin = RTREE_ZERO;
		RtreeDValue fBestOverlap = RTREE_ZERO;
		RtreeDValue fBestArea = RTREE_ZERO;
		int iBestLeft = 0;
		int nLeft;

		for (
			nLeft = RTREE_MINCELLS(pRtree);
			nLeft <= (nCell - RTREE_MINCELLS(pRtree));
			nLeft++
			) {
			RtreeCell left;
			RtreeCell right;
			int kk;
			RtreeDValue overlap;
			RtreeDValue area;

			memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));
			memcpy(&right, &aCell[aaSorted[ii][nCell - 1]], sizeof(RtreeCell));
			for (kk = 1; kk<(nCell - 1); kk++) {
				if (kk<nLeft) {
					cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]);
				}
				else {
					cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]);
				}
			}
			margin += cellMargin(pRtree, &left);
			margin += cellMargin(pRtree, &right);
			overlap = cellOverlap(pRtree, &left, &right, 1);
			area = cellArea(pRtree, &left) + cellArea(pRtree, &right);
			if ((nLeft == RTREE_MINCELLS(pRtree))
				|| (overlap<fBestOverlap)
				|| (overlap == fBestOverlap && area<fBestArea)
				) {
				iBestLeft = nLeft;
				fBestOverlap = overlap;
				fBestArea = area;
			}
		}

		if (ii == 0 || margin<fBestMargin) {
			iBestDim = ii;
			fBestMargin = margin;
			iBestSplit = iBestLeft;
		}
	}

	memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));
	memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));
	for (ii = 0; ii<nCell; ii++) {
		RtreeNode *pTarget = (ii<iBestSplit) ? pLeft : pRight;
		RtreeCell *pBbox = (ii<iBestSplit) ? pBboxLeft : pBboxRight;
		RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]];
		nodeInsertCell(pRtree, pTarget, pCell);
		cellUnion(pRtree, pBbox, pCell);
	}

	sqlite3_free(aaSorted);
	return SQLITE_OK;
}


static int updateMapping(
	Rtree *pRtree,
	i64 iRowid,
	RtreeNode *pNode,
	int iHeight
) {
	int(*xSetMapping)(Rtree *, sqlite3_int64, sqlite3_int64);
	xSetMapping = ((iHeight == 0) ? rowidWrite : parentWrite);
	if (iHeight>0) {
		RtreeNode *pChild = nodeHashLookup(pRtree, iRowid);
		if (pChild) {
			nodeRelease(pRtree, pChild->pParent);
			nodeReference(pNode);
			pChild->pParent = pNode;
		}
	}
	return xSetMapping(pRtree, iRowid, pNode->iNode);
}

static int SplitNode(
	Rtree *pRtree,
	RtreeNode *pNode,
	RtreeCell *pCell,
	int iHeight
) {
	int i;
	int newCellIsRight = 0;

	int rc = SQLITE_OK;
	int nCell = NCELL(pNode);
	RtreeCell *aCell;
	int *aiUsed;

	RtreeNode *pLeft = 0;
	RtreeNode *pRight = 0;

	RtreeCell leftbbox;
	RtreeCell rightbbox;

	
	aCell = sqlite3_malloc((sizeof(RtreeCell) + sizeof(int))*(nCell + 1));
	if (!aCell) {
		rc = SQLITE_NOMEM;
		goto splitnode_out;
	}
	aiUsed = (int *)&aCell[nCell + 1];
	memset(aiUsed, 0, sizeof(int)*(nCell + 1));
	for (i = 0; i<nCell; i++) {
		nodeGetCell(pRtree, pNode, i, &aCell[i]);
	}
	nodeZero(pRtree, pNode);
	memcpy(&aCell[nCell], pCell, sizeof(RtreeCell));
	nCell++;

	if (pNode->iNode == 1) {
		pRight = nodeNew(pRtree, pNode);
		pLeft = nodeNew(pRtree, pNode);
		pRtree->iDepth++;
		pNode->isDirty = 1;
		writeInt16(pNode->zData, pRtree->iDepth);
	}
	else {
		pLeft = pNode;
		pRight = nodeNew(pRtree, pLeft->pParent);
		nodeReference(pLeft);
	}

	if (!pLeft || !pRight) {
		rc = SQLITE_NOMEM;
		goto splitnode_out;
	}

	memset(pLeft->zData, 0, pRtree->iNodeSize);
	memset(pRight->zData, 0, pRtree->iNodeSize);

	rc = splitNodeStartree(pRtree, aCell, nCell, pLeft, pRight,
		&leftbbox, &rightbbox);
	if (rc != SQLITE_OK) {
		goto splitnode_out;
	}

	
	if (SQLITE_OK != (rc = nodeWrite(pRtree, pRight))
		|| (0 == pLeft->iNode && SQLITE_OK != (rc = nodeWrite(pRtree, pLeft)))
		) {
		goto splitnode_out;
	}

	rightbbox.iRowid = pRight->iNode;
	leftbbox.iRowid = pLeft->iNode;

	if (pNode->iNode == 1) {
		rc = rtreeInsertCell(pRtree, pLeft->pParent, &leftbbox, iHeight + 1);
		if (rc != SQLITE_OK) {
			goto splitnode_out;
		}
	}
	else {
		RtreeNode *pParent = pLeft->pParent;
		int iCell;
		rc = nodeParentIndex(pRtree, pLeft, &iCell);
		if (rc == SQLITE_OK) {
			nodeOverwriteCell(pRtree, pParent, &leftbbox, iCell);
			rc = AdjustTree(pRtree, pParent, &leftbbox);
		}
		if (rc != SQLITE_OK) {
			goto splitnode_out;
		}
	}
	if ((rc = rtreeInsertCell(pRtree, pRight->pParent, &rightbbox, iHeight + 1))) {
		goto splitnode_out;
	}

	for (i = 0; i<NCELL(pRight); i++) {
		i64 iRowid = nodeGetRowid(pRtree, pRight, i);
		rc = updateMapping(pRtree, iRowid, pRight, iHeight);
		if (iRowid == pCell->iRowid) {
			newCellIsRight = 1;
		}
		if (rc != SQLITE_OK) {
			goto splitnode_out;
		}
	}
	if (pNode->iNode == 1) {
		for (i = 0; i<NCELL(pLeft); i++) {
			i64 iRowid = nodeGetRowid(pRtree, pLeft, i);
			rc = updateMapping(pRtree, iRowid, pLeft, iHeight);
			if (rc != SQLITE_OK) {
				goto splitnode_out;
			}
		}
	}
	else if (newCellIsRight == 0) {
		rc = updateMapping(pRtree, pCell->iRowid, pLeft, iHeight);
	}

	if (rc == SQLITE_OK) {
		rc = nodeRelease(pRtree, pRight);
		pRight = 0;
	}
	if (rc == SQLITE_OK) {
		rc = nodeRelease(pRtree, pLeft);
		pLeft = 0;
	}

splitnode_out:
	nodeRelease(pRtree, pRight);
	nodeRelease(pRtree, pLeft);
	sqlite3_free(aCell);
	return rc;
}


static int fixLeafParent(Rtree *pRtree, RtreeNode *pLeaf) {
	int rc = SQLITE_OK;
	RtreeNode *pChild = pLeaf;
	while (rc == SQLITE_OK && pChild->iNode != 1 && pChild->pParent == 0) {
		int rc2 = SQLITE_OK;          
		sqlite3_bind_int64(pRtree->pReadParent, 1, pChild->iNode);
		rc = sqlite3_step(pRtree->pReadParent);
		if (rc == SQLITE_ROW) {
			RtreeNode *pTest;           
			i64 iNode;                  

										
			iNode = sqlite3_column_int64(pRtree->pReadParent, 0);
			for (pTest = pLeaf; pTest && pTest->iNode != iNode; pTest = pTest->pParent);
			if (!pTest) {
				rc2 = nodeAcquire(pRtree, iNode, 0, &pChild->pParent);
			}
		}
		rc = sqlite3_reset(pRtree->pReadParent);
		if (rc == SQLITE_OK) rc = rc2;
		if (rc == SQLITE_OK && !pChild->pParent) rc = SQLITE_CORRUPT_VTAB;
		pChild = pChild->pParent;
	}
	return rc;
}

static int deleteCell(Rtree *, RtreeNode *, int, int);

static int removeNode(Rtree *pRtree, RtreeNode *pNode, int iHeight) {
	int rc;
	int rc2;
	RtreeNode *pParent = 0;
	int iCell;

	assert(pNode->nRef == 1);

	
	rc = nodeParentIndex(pRtree, pNode, &iCell);
	if (rc == SQLITE_OK) {
		pParent = pNode->pParent;
		pNode->pParent = 0;
		rc = deleteCell(pRtree, pParent, iCell, iHeight + 1);
	}
	rc2 = nodeRelease(pRtree, pParent);
	if (rc == SQLITE_OK) {
		rc = rc2;
	}
	if (rc != SQLITE_OK) {
		return rc;
	}

	
	sqlite3_bind_int64(pRtree->pDeleteNode, 1, pNode->iNode);
	sqlite3_step(pRtree->pDeleteNode);
	if (SQLITE_OK != (rc = sqlite3_reset(pRtree->pDeleteNode))) {
		return rc;
	}

	
	sqlite3_bind_int64(pRtree->pDeleteParent, 1, pNode->iNode);
	sqlite3_step(pRtree->pDeleteParent);
	if (SQLITE_OK != (rc = sqlite3_reset(pRtree->pDeleteParent))) {
		return rc;
	}

	
	nodeHashDelete(pRtree, pNode);
	pNode->iNode = iHeight;
	pNode->pNext = pRtree->pDeleted;
	pNode->nRef++;
	pRtree->pDeleted = pNode;

	return SQLITE_OK;
}

static int fixBoundingBox(Rtree *pRtree, RtreeNode *pNode) {
	RtreeNode *pParent = pNode->pParent;
	int rc = SQLITE_OK;
	if (pParent) {
		int ii;
		int nCell = NCELL(pNode);
		RtreeCell box;                            
		nodeGetCell(pRtree, pNode, 0, &box);
		for (ii = 1; ii<nCell; ii++) {
			RtreeCell cell;
			nodeGetCell(pRtree, pNode, ii, &cell);
			cellUnion(pRtree, &box, &cell);
		}
		box.iRowid = pNode->iNode;
		rc = nodeParentIndex(pRtree, pNode, &ii);
		if (rc == SQLITE_OK) {
			nodeOverwriteCell(pRtree, pParent, &box, ii);
			rc = fixBoundingBox(pRtree, pParent);
		}
	}
	return rc;
}


static int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight) {
	RtreeNode *pParent;
	int rc;

	if (SQLITE_OK != (rc = fixLeafParent(pRtree, pNode))) {
		return rc;
	}

	
	nodeDeleteCell(pRtree, pNode, iCell);

	
	pParent = pNode->pParent;
	assert(pParent || pNode->iNode == 1);
	if (pParent) {
		if (NCELL(pNode)<RTREE_MINCELLS(pRtree)) {
			rc = removeNode(pRtree, pNode, iHeight);
		}
		else {
			rc = fixBoundingBox(pRtree, pNode);
		}
	}

	return rc;
}

static int Reinsert(
	Rtree *pRtree,
	RtreeNode *pNode,
	RtreeCell *pCell,
	int iHeight
) {
	int *aOrder;
	int *aSpare;
	RtreeCell *aCell;
	RtreeDValue *aDistance;
	int nCell;
	RtreeDValue aCenterCoord[RTREE_MAX_DIMENSIONS];
	int iDim;
	int ii;
	int rc = SQLITE_OK;
	int n;

	memset(aCenterCoord, 0, sizeof(RtreeDValue)*RTREE_MAX_DIMENSIONS);

	nCell = NCELL(pNode) + 1;
	n = (nCell + 1)&(~1);

	
	aCell = (RtreeCell *)sqlite3_malloc(n * (
		sizeof(RtreeCell) +         
		sizeof(int) +         
		sizeof(int) +         
		sizeof(RtreeDValue)             
		));
	if (!aCell) {
		return SQLITE_NOMEM;
	}
	aOrder = (int *)&aCell[n];
	aSpare = (int *)&aOrder[n];
	aDistance = (RtreeDValue *)&aSpare[n];

	for (ii = 0; ii<nCell; ii++) {
		if (ii == (nCell - 1)) {
			memcpy(&aCell[ii], pCell, sizeof(RtreeCell));
		}
		else {
			nodeGetCell(pRtree, pNode, ii, &aCell[ii]);
		}
		aOrder[ii] = ii;
		for (iDim = 0; iDim<pRtree->nDim; iDim++) {
			aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim * 2]);
			aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim * 2 + 1]);
		}
	}
	for (iDim = 0; iDim<pRtree->nDim; iDim++) {
		aCenterCoord[iDim] = (aCenterCoord[iDim] / (nCell*(RtreeDValue)2));
	}

	for (ii = 0; ii<nCell; ii++) {
		aDistance[ii] = RTREE_ZERO;
		for (iDim = 0; iDim<pRtree->nDim; iDim++) {
			RtreeDValue coord = (DCOORD(aCell[ii].aCoord[iDim * 2 + 1]) -
				DCOORD(aCell[ii].aCoord[iDim * 2]));
			aDistance[ii] += (coord - aCenterCoord[iDim])*(coord - aCenterCoord[iDim]);
		}
	}

	SortByDistance(aOrder, nCell, aDistance, aSpare);
	nodeZero(pRtree, pNode);

	for (ii = 0; rc == SQLITE_OK && ii<(nCell - (RTREE_MINCELLS(pRtree) + 1)); ii++) {
		RtreeCell *p = &aCell[aOrder[ii]];
		nodeInsertCell(pRtree, pNode, p);
		if (p->iRowid == pCell->iRowid) {
			if (iHeight == 0) {
				rc = rowidWrite(pRtree, p->iRowid, pNode->iNode);
			}
			else {
				rc = parentWrite(pRtree, p->iRowid, pNode->iNode);
			}
		}
	}
	if (rc == SQLITE_OK) {
		rc = fixBoundingBox(pRtree, pNode);
	}
	for (; rc == SQLITE_OK && ii<nCell; ii++) {
		
		RtreeNode *pInsert;
		RtreeCell *p = &aCell[aOrder[ii]];
		rc = ChooseLeaf(pRtree, p, iHeight, &pInsert);
		if (rc == SQLITE_OK) {
			int rc2;
			rc = rtreeInsertCell(pRtree, pInsert, p, iHeight);
			rc2 = nodeRelease(pRtree, pInsert);
			if (rc == SQLITE_OK) {
				rc = rc2;
			}
		}
	}

	sqlite3_free(aCell);
	return rc;
}


static int rtreeInsertCell(
	Rtree *pRtree,
	RtreeNode *pNode,
	RtreeCell *pCell,
	int iHeight
) {
	int rc = SQLITE_OK;
	if (iHeight>0) {
		RtreeNode *pChild = nodeHashLookup(pRtree, pCell->iRowid);
		if (pChild) {
			nodeRelease(pRtree, pChild->pParent);
			nodeReference(pNode);
			pChild->pParent = pNode;
		}
	}
	if (nodeInsertCell(pRtree, pNode, pCell)) {
		if (iHeight <= pRtree->iReinsertHeight || pNode->iNode == 1) {
			rc = SplitNode(pRtree, pNode, pCell, iHeight);
		}
		else {
			pRtree->iReinsertHeight = iHeight;
			rc = Reinsert(pRtree, pNode, pCell, iHeight);
		}
	}
	else {
		rc = AdjustTree(pRtree, pNode, pCell);
		if (rc == SQLITE_OK) {
			if (iHeight == 0) {
				rc = rowidWrite(pRtree, pCell->iRowid, pNode->iNode);
			}
			else {
				rc = parentWrite(pRtree, pCell->iRowid, pNode->iNode);
			}
		}
	}
	return rc;
}

static int reinsertNodeContent(Rtree *pRtree, RtreeNode *pNode) {
	int ii;
	int rc = SQLITE_OK;
	int nCell = NCELL(pNode);

	for (ii = 0; rc == SQLITE_OK && ii<nCell; ii++) {
		RtreeNode *pInsert;
		RtreeCell cell;
		nodeGetCell(pRtree, pNode, ii, &cell);

		
		rc = ChooseLeaf(pRtree, &cell, (int)pNode->iNode, &pInsert);
		if (rc == SQLITE_OK) {
			int rc2;
			rc = rtreeInsertCell(pRtree, pInsert, &cell, (int)pNode->iNode);
			rc2 = nodeRelease(pRtree, pInsert);
			if (rc == SQLITE_OK) {
				rc = rc2;
			}
		}
	}
	return rc;
}


static int newRowid(Rtree *pRtree, i64 *piRowid) {
	int rc;
	sqlite3_bind_null(pRtree->pWriteRowid, 1);
	sqlite3_bind_null(pRtree->pWriteRowid, 2);
	sqlite3_step(pRtree->pWriteRowid);
	rc = sqlite3_reset(pRtree->pWriteRowid);
	*piRowid = sqlite3_last_insert_rowid(pRtree->db);
	return rc;
}


static int rtreeDeleteRowid(Rtree *pRtree, sqlite3_int64 iDelete) {
	int rc;                         
	RtreeNode *pLeaf = 0;           
	int iCell;                      
	RtreeNode *pRoot;               


									
	rc = nodeAcquire(pRtree, 1, 0, &pRoot);

	
	if (rc == SQLITE_OK) {
		rc = findLeafNode(pRtree, iDelete, &pLeaf, 0);
	}

	
	if (rc == SQLITE_OK) {
		int rc2;
		rc = nodeRowidIndex(pRtree, pLeaf, iDelete, &iCell);
		if (rc == SQLITE_OK) {
			rc = deleteCell(pRtree, pLeaf, iCell, 0);
		}
		rc2 = nodeRelease(pRtree, pLeaf);
		if (rc == SQLITE_OK) {
			rc = rc2;
		}
	}

	
	if (rc == SQLITE_OK) {
		sqlite3_bind_int64(pRtree->pDeleteRowid, 1, iDelete);
		sqlite3_step(pRtree->pDeleteRowid);
		rc = sqlite3_reset(pRtree->pDeleteRowid);
	}

	
	if (rc == SQLITE_OK && pRtree->iDepth>0 && NCELL(pRoot) == 1) {
		int rc2;
		RtreeNode *pChild;
		i64 iChild = nodeGetRowid(pRtree, pRoot, 0);
		rc = nodeAcquire(pRtree, iChild, pRoot, &pChild);
		if (rc == SQLITE_OK) {
			rc = removeNode(pRtree, pChild, pRtree->iDepth - 1);
		}
		rc2 = nodeRelease(pRtree, pChild);
		if (rc == SQLITE_OK) rc = rc2;
		if (rc == SQLITE_OK) {
			pRtree->iDepth--;
			writeInt16(pRoot->zData, pRtree->iDepth);
			pRoot->isDirty = 1;
		}
	}

	
	for (pLeaf = pRtree->pDeleted; pLeaf; pLeaf = pRtree->pDeleted) {
		if (rc == SQLITE_OK) {
			rc = reinsertNodeContent(pRtree, pLeaf);
		}
		pRtree->pDeleted = pLeaf->pNext;
		sqlite3_free(pLeaf);
	}

	
	if (rc == SQLITE_OK) {
		rc = nodeRelease(pRtree, pRoot);
	}
	else {
		nodeRelease(pRtree, pRoot);
	}

	return rc;
}


#define RNDTOWARDS  (1.0 - 1.0/8388608.0)  
#define RNDAWAY     (1.0 + 1.0/8388608.0)  

#if !defined(SQLITE_RTREE_INT_ONLY)

static RtreeValue rtreeValueDown(sqlite3_value *v) {
	double d = sqlite3_value_double(v);
	float f = (float)d;
	if (f>d) {
		f = (float)(d*(d<0 ? RNDAWAY : RNDTOWARDS));
	}
	return f;
}
static RtreeValue rtreeValueUp(sqlite3_value *v) {
	double d = sqlite3_value_double(v);
	float f = (float)d;
	if (f<d) {
		f = (float)(d*(d<0 ? RNDTOWARDS : RNDAWAY));
	}
	return f;
}
#endif 


static int rtreeConstraintError(Rtree *pRtree, int iCol) {
	sqlite3_stmt *pStmt = 0;
	char *zSql;
	int rc;

	assert(iCol == 0 || iCol % 2);
	zSql = sqlite3_mprintf("SELECT * FROM %Q.%Q", pRtree->zDb, pRtree->zName);
	if (zSql) {
		rc = sqlite3_prepare_v2(pRtree->db, zSql, -1, &pStmt, 0);
	}
	else {
		rc = SQLITE_NOMEM;
	}
	sqlite3_free(zSql);

	if (rc == SQLITE_OK) {
		if (iCol == 0) {
			const char *zCol = sqlite3_column_name(pStmt, 0);
			pRtree->base.zErrMsg = sqlite3_mprintf(
				"UNIQUE constraint failed: %s.%s", pRtree->zName, zCol
			);
		}
		else {
			const char *zCol1 = sqlite3_column_name(pStmt, iCol);
			const char *zCol2 = sqlite3_column_name(pStmt, iCol + 1);
			pRtree->base.zErrMsg = sqlite3_mprintf(
				"rtree constraint failed: %s.(%s<=%s)", pRtree->zName, zCol1, zCol2
			);
		}
	}

	sqlite3_finalize(pStmt);
	return (rc == SQLITE_OK ? SQLITE_CONSTRAINT : rc);
}




static int rtreeUpdate(
	sqlite3_vtab *pVtab,
	int nData,
	sqlite3_value **azData,
	sqlite_int64 *pRowid
) {
	Rtree *pRtree = (Rtree *)pVtab;
	int rc = SQLITE_OK;
	RtreeCell cell;                 
	int bHaveRowid = 0;             

	rtreeReference(pRtree);
	assert(nData >= 1);

	cell.iRowid = 0;  

					  
	if (nData>1) {
		int ii;

		
		assert(nData <= (pRtree->nDim * 2 + 3));

#ifndef SQLITE_RTREE_INT_ONLY
		if (pRtree->eCoordType == RTREE_COORD_REAL32) {
			for (ii = 0; ii<nData - 4; ii += 2) {
				cell.aCoord[ii].f = rtreeValueDown(azData[ii + 3]);
				cell.aCoord[ii + 1].f = rtreeValueUp(azData[ii + 4]);
				if (cell.aCoord[ii].f>cell.aCoord[ii + 1].f) {
					rc = rtreeConstraintError(pRtree, ii + 1);
					goto constraint;
				}
			}
		}
		else
#endif
		{
			for (ii = 0; ii<nData - 4; ii += 2) {
				cell.aCoord[ii].i = sqlite3_value_int(azData[ii + 3]);
				cell.aCoord[ii + 1].i = sqlite3_value_int(azData[ii + 4]);
				if (cell.aCoord[ii].i>cell.aCoord[ii + 1].i) {
					rc = rtreeConstraintError(pRtree, ii + 1);
					goto constraint;
				}
			}
		}

		
		if (sqlite3_value_type(azData[2]) != SQLITE_NULL) {
			cell.iRowid = sqlite3_value_int64(azData[2]);
			if (sqlite3_value_type(azData[0]) == SQLITE_NULL
				|| sqlite3_value_int64(azData[0]) != cell.iRowid
				) {
				int steprc;
				sqlite3_bind_int64(pRtree->pReadRowid, 1, cell.iRowid);
				steprc = sqlite3_step(pRtree->pReadRowid);
				rc = sqlite3_reset(pRtree->pReadRowid);
				if (SQLITE_ROW == steprc) {
					if (sqlite3_vtab_on_conflict(pRtree->db) == SQLITE_REPLACE) {
						rc = rtreeDeleteRowid(pRtree, cell.iRowid);
					}
					else {
						rc = rtreeConstraintError(pRtree, 0);
						goto constraint;
					}
				}
			}
			bHaveRowid = 1;
		}
	}

	
	if (sqlite3_value_type(azData[0]) != SQLITE_NULL) {
		rc = rtreeDeleteRowid(pRtree, sqlite3_value_int64(azData[0]));
	}

	
	if (rc == SQLITE_OK && nData>1) {
		
		RtreeNode *pLeaf = 0;

		
		if (bHaveRowid == 0) {
			rc = newRowid(pRtree, &cell.iRowid);
		}
		*pRowid = cell.iRowid;

		if (rc == SQLITE_OK) {
			rc = ChooseLeaf(pRtree, &cell, 0, &pLeaf);
		}
		if (rc == SQLITE_OK) {
			int rc2;
			pRtree->iReinsertHeight = -1;
			rc = rtreeInsertCell(pRtree, pLeaf, &cell, 0);
			rc2 = nodeRelease(pRtree, pLeaf);
			if (rc == SQLITE_OK) {
				rc = rc2;
			}
		}
	}

constraint:
	rtreeRelease(pRtree);
	return rc;
}


static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName) {
	Rtree *pRtree = (Rtree *)pVtab;
	int rc = SQLITE_NOMEM;
	char *zSql = sqlite3_mprintf(
		"ALTER TABLE %Q.'%q_node'   RENAME TO \"%w_node\";"
		"ALTER TABLE %Q.'%q_parent' RENAME TO \"%w_parent\";"
		"ALTER TABLE %Q.'%q_rowid'  RENAME TO \"%w_rowid\";"
		, pRtree->zDb, pRtree->zName, zNewName
		, pRtree->zDb, pRtree->zName, zNewName
		, pRtree->zDb, pRtree->zName, zNewName
	);
	if (zSql) {
		rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0);
		sqlite3_free(zSql);
	}
	return rc;
}


static int rtreeQueryStat1(sqlite3 *db, Rtree *pRtree) {
	const char *zFmt = "SELECT stat FROM %Q.sqlite_stat1 WHERE tbl = '%q_rowid'";
	char *zSql;
	sqlite3_stmt *p;
	int rc;
	i64 nRow = 0;

	rc = sqlite3_table_column_metadata(
		db, pRtree->zDb, "sqlite_stat1", 0, 0, 0, 0, 0, 0
	);
	if (rc != SQLITE_OK) {
		pRtree->nRowEst = RTREE_DEFAULT_ROWEST;
		return rc == SQLITE_ERROR ? SQLITE_OK : rc;
	}
	zSql = sqlite3_mprintf(zFmt, pRtree->zDb, pRtree->zName);
	if (zSql == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		rc = sqlite3_prepare_v2(db, zSql, -1, &p, 0);
		if (rc == SQLITE_OK) {
			if (sqlite3_step(p) == SQLITE_ROW) nRow = sqlite3_column_int64(p, 0);
			rc = sqlite3_finalize(p);
		}
		else if (rc != SQLITE_NOMEM) {
			rc = SQLITE_OK;
		}

		if (rc == SQLITE_OK) {
			if (nRow == 0) {
				pRtree->nRowEst = RTREE_DEFAULT_ROWEST;
			}
			else {
				pRtree->nRowEst = MAX(nRow, RTREE_MIN_ROWEST);
			}
		}
		sqlite3_free(zSql);
	}

	return rc;
}

static sqlite3_module rtreeModule = {
	0,                          
	rtreeCreate,                
	rtreeConnect,               
	rtreeBestIndex,             
	rtreeDisconnect,            
	rtreeDestroy,               
	rtreeOpen,                  
	rtreeClose,                 
	rtreeFilter,                
	rtreeNext,                  
	rtreeEof,                   
	rtreeColumn,                
	rtreeRowid,                 
	rtreeUpdate,                
	0,                          
	0,                          
	0,                          
	0,                          
	0,                          
	rtreeRename,                
	0,                          
	0,                          
	0                           
};

static int rtreeSqlInit(
	Rtree *pRtree,
	sqlite3 *db,
	const char *zDb,
	const char *zPrefix,
	int isCreate
) {
	int rc = SQLITE_OK;

#define N_STATEMENT 9
	static const char *azSql[N_STATEMENT] = {
		
		"SELECT data FROM '%q'.'%q_node' WHERE nodeno = :1",
		"INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(:1, :2)",
		"DELETE FROM '%q'.'%q_node' WHERE nodeno = :1",

		
		"SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = :1",
		"INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(:1, :2)",
		"DELETE FROM '%q'.'%q_rowid' WHERE rowid = :1",

		
		"SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = :1",
		"INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(:1, :2)",
		"DELETE FROM '%q'.'%q_parent' WHERE nodeno = :1"
	};
	sqlite3_stmt **appStmt[N_STATEMENT];
	int i;

	pRtree->db = db;

	if (isCreate) {
		char *zCreate = sqlite3_mprintf(
			"CREATE TABLE \"%w\".\"%w_node\"(nodeno INTEGER PRIMARY KEY, data BLOB);"
			"CREATE TABLE \"%w\".\"%w_rowid\"(rowid INTEGER PRIMARY KEY, nodeno INTEGER);"
			"CREATE TABLE \"%w\".\"%w_parent\"(nodeno INTEGER PRIMARY KEY,"
			" parentnode INTEGER);"
			"INSERT INTO '%q'.'%q_node' VALUES(1, zeroblob(%d))",
			zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, pRtree->iNodeSize
		);
		if (!zCreate) {
			return SQLITE_NOMEM;
		}
		rc = sqlite3_exec(db, zCreate, 0, 0, 0);
		sqlite3_free(zCreate);
		if (rc != SQLITE_OK) {
			return rc;
		}
	}

	appStmt[0] = &pRtree->pReadNode;
	appStmt[1] = &pRtree->pWriteNode;
	appStmt[2] = &pRtree->pDeleteNode;
	appStmt[3] = &pRtree->pReadRowid;
	appStmt[4] = &pRtree->pWriteRowid;
	appStmt[5] = &pRtree->pDeleteRowid;
	appStmt[6] = &pRtree->pReadParent;
	appStmt[7] = &pRtree->pWriteParent;
	appStmt[8] = &pRtree->pDeleteParent;

	rc = rtreeQueryStat1(db, pRtree);
	for (i = 0; i<N_STATEMENT && rc == SQLITE_OK; i++) {
		char *zSql = sqlite3_mprintf(azSql[i], zDb, zPrefix);
		if (zSql) {
			rc = sqlite3_prepare_v2(db, zSql, -1, appStmt[i], 0);
		}
		else {
			rc = SQLITE_NOMEM;
		}
		sqlite3_free(zSql);
	}

	return rc;
}


static int getIntFromStmt(sqlite3 *db, const char *zSql, int *piVal) {
	int rc = SQLITE_NOMEM;
	if (zSql) {
		sqlite3_stmt *pStmt = 0;
		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
		if (rc == SQLITE_OK) {
			if (SQLITE_ROW == sqlite3_step(pStmt)) {
				*piVal = sqlite3_column_int(pStmt, 0);
			}
			rc = sqlite3_finalize(pStmt);
		}
	}
	return rc;
}


static int getNodeSize(
	sqlite3 *db,                    
	Rtree *pRtree,                  
	int isCreate,                   
	char **pzErr                    
) {
	int rc;
	char *zSql;
	if (isCreate) {
		int iPageSize = 0;
		zSql = sqlite3_mprintf("PRAGMA %Q.page_size", pRtree->zDb);
		rc = getIntFromStmt(db, zSql, &iPageSize);
		if (rc == SQLITE_OK) {
			pRtree->iNodeSize = iPageSize - 64;
			if ((4 + pRtree->nBytesPerCell*RTREE_MAXCELLS)<pRtree->iNodeSize) {
				pRtree->iNodeSize = 4 + pRtree->nBytesPerCell*RTREE_MAXCELLS;
			}
		}
		else {
			*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
		}
	}
	else {
		zSql = sqlite3_mprintf(
			"SELECT length(data) FROM '%q'.'%q_node' WHERE nodeno = 1",
			pRtree->zDb, pRtree->zName
		);
		rc = getIntFromStmt(db, zSql, &pRtree->iNodeSize);
		if (rc != SQLITE_OK) {
			*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
		}
	}

	sqlite3_free(zSql);
	return rc;
}


static int rtreeInit(
	sqlite3 *db,                        
	void *pAux,                         
	int argc, const char *const*argv,   
	sqlite3_vtab **ppVtab,              
	char **pzErr,                       
	int isCreate                        
) {
	int rc = SQLITE_OK;
	Rtree *pRtree;
	int nDb;              
	int nName;            
	int eCoordType = (pAux ? RTREE_COORD_INT32 : RTREE_COORD_REAL32);

	const char *aErrMsg[] = {
		0,                                                    
		"Wrong number of columns for an rtree table",         
		"Too few columns for an rtree table",                 
		"Too many columns for an rtree table"                 
	};

	int iErr = (argc<6) ? 2 : argc>(RTREE_MAX_DIMENSIONS * 2 + 4) ? 3 : argc % 2;
	if (aErrMsg[iErr]) {
		*pzErr = sqlite3_mprintf("%s", aErrMsg[iErr]);
		return SQLITE_ERROR;
	}

	sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);

	
	nDb = (int)strlen(argv[1]);
	nName = (int)strlen(argv[2]);
	pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree) + nDb + nName + 2);
	if (!pRtree) {
		return SQLITE_NOMEM;
	}
	memset(pRtree, 0, sizeof(Rtree) + nDb + nName + 2);
	pRtree->nBusy = 1;
	pRtree->base.pModule = &rtreeModule;
	pRtree->zDb = (char *)&pRtree[1];
	pRtree->zName = &pRtree->zDb[nDb + 1];
	pRtree->nDim = (argc - 4) / 2;
	pRtree->nBytesPerCell = 8 + pRtree->nDim * 4 * 2;
	pRtree->eCoordType = eCoordType;
	memcpy(pRtree->zDb, argv[1], nDb);
	memcpy(pRtree->zName, argv[2], nName);

	
	rc = getNodeSize(db, pRtree, isCreate, pzErr);

	
	if (rc == SQLITE_OK) {
		if ((rc = rtreeSqlInit(pRtree, db, argv[1], argv[2], isCreate))) {
			*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
		}
		else {
			char *zSql = sqlite3_mprintf("CREATE TABLE x(%s", argv[3]);
			char *zTmp;
			int ii;
			for (ii = 4; zSql && ii<argc; ii++) {
				zTmp = zSql;
				zSql = sqlite3_mprintf("%s, %s", zTmp, argv[ii]);
				sqlite3_free(zTmp);
			}
			if (zSql) {
				zTmp = zSql;
				zSql = sqlite3_mprintf("%s);", zTmp);
				sqlite3_free(zTmp);
			}
			if (!zSql) {
				rc = SQLITE_NOMEM;
			}
			else if (SQLITE_OK != (rc = sqlite3_declare_vtab(db, zSql))) {
				*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
			}
			sqlite3_free(zSql);
		}
	}

	if (rc == SQLITE_OK) {
		*ppVtab = (sqlite3_vtab *)pRtree;
	}
	else {
		assert(*ppVtab == 0);
		assert(pRtree->nBusy == 1);
		rtreeRelease(pRtree);
	}
	return rc;
}



static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg) {
	char *zText = 0;
	RtreeNode node;
	Rtree tree;
	int ii;

	UNUSED_PARAMETER(nArg);
	memset(&node, 0, sizeof(RtreeNode));
	memset(&tree, 0, sizeof(Rtree));
	tree.nDim = sqlite3_value_int(apArg[0]);
	tree.nBytesPerCell = 8 + 8 * tree.nDim;
	node.zData = (u8 *)sqlite3_value_blob(apArg[1]);

	for (ii = 0; ii<NCELL(&node); ii++) {
		char zCell[512];
		int nCell = 0;
		RtreeCell cell;
		int jj;

		nodeGetCell(&tree, &node, ii, &cell);
		sqlite3_snprintf(512 - nCell, &zCell[nCell], "%lld", cell.iRowid);
		nCell = (int)strlen(zCell);
		for (jj = 0; jj<tree.nDim * 2; jj++) {
#ifndef SQLITE_RTREE_INT_ONLY
			sqlite3_snprintf(512 - nCell, &zCell[nCell], " %g",
				(double)cell.aCoord[jj].f);
#else
			sqlite3_snprintf(512 - nCell, &zCell[nCell], " %d",
				cell.aCoord[jj].i);
#endif
			nCell = (int)strlen(zCell);
		}

		if (zText) {
			char *zTextNew = sqlite3_mprintf("%s {%s}", zText, zCell);
			sqlite3_free(zText);
			zText = zTextNew;
		}
		else {
			zText = sqlite3_mprintf("{%s}", zCell);
		}
	}

	sqlite3_result_text(ctx, zText, -1, sqlite3_free);
}


static void rtreedepth(sqlite3_context *ctx, int nArg, sqlite3_value **apArg) {
	UNUSED_PARAMETER(nArg);
	if (sqlite3_value_type(apArg[0]) != SQLITE_BLOB
		|| sqlite3_value_bytes(apArg[0])<2
		) {
		sqlite3_result_error(ctx, "Invalid argument to rtreedepth()", -1);
	}
	else {
		u8 *zBlob = (u8 *)sqlite3_value_blob(apArg[0]);
		sqlite3_result_int(ctx, readInt16(zBlob));
	}
}


SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db) {
	const int utf8 = SQLITE_UTF8;
	int rc;

	rc = sqlite3_create_function(db, "rtreenode", 2, utf8, 0, rtreenode, 0, 0);
	if (rc == SQLITE_OK) {
		rc = sqlite3_create_function(db, "rtreedepth", 1, utf8, 0, rtreedepth, 0, 0);
	}
	if (rc == SQLITE_OK) {
#ifdef SQLITE_RTREE_INT_ONLY
		void *c = (void *)RTREE_COORD_INT32;
#else
		void *c = (void *)RTREE_COORD_REAL32;
#endif
		rc = sqlite3_create_module_v2(db, "rtree", &rtreeModule, c, 0);
	}
	if (rc == SQLITE_OK) {
		void *c = (void *)RTREE_COORD_INT32;
		rc = sqlite3_create_module_v2(db, "rtree_i32", &rtreeModule, c, 0);
	}

	return rc;
}


static void rtreeFreeCallback(void *p) {
	RtreeGeomCallback *pInfo = (RtreeGeomCallback*)p;
	if (pInfo->xDestructor) pInfo->xDestructor(pInfo->pContext);
	sqlite3_free(p);
}


static void rtreeMatchArgFree(void *pArg) {
	int i;
	RtreeMatchArg *p = (RtreeMatchArg*)pArg;
	for (i = 0; i<p->nParam; i++) {
		sqlite3_value_free(p->apSqlParam[i]);
	}
	sqlite3_free(p);
}


static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg) {
	RtreeGeomCallback *pGeomCtx = (RtreeGeomCallback *)sqlite3_user_data(ctx);
	RtreeMatchArg *pBlob;
	int nBlob;
	int memErr = 0;

	nBlob = sizeof(RtreeMatchArg) + (nArg - 1) * sizeof(RtreeDValue)
		+ nArg * sizeof(sqlite3_value*);
	pBlob = (RtreeMatchArg *)sqlite3_malloc(nBlob);
	if (!pBlob) {
		sqlite3_result_error_nomem(ctx);
	}
	else {
		int i;
		pBlob->magic = RTREE_GEOMETRY_MAGIC;
		pBlob->cb = pGeomCtx[0];
		pBlob->apSqlParam = (sqlite3_value**)&pBlob->aParam[nArg];
		pBlob->nParam = nArg;
		for (i = 0; i<nArg; i++) {
			pBlob->apSqlParam[i] = sqlite3_value_dup(aArg[i]);
			if (pBlob->apSqlParam[i] == 0) memErr = 1;
#ifdef SQLITE_RTREE_INT_ONLY
			pBlob->aParam[i] = sqlite3_value_int64(aArg[i]);
#else
			pBlob->aParam[i] = sqlite3_value_double(aArg[i]);
#endif
		}
		if (memErr) {
			sqlite3_result_error_nomem(ctx);
			rtreeMatchArgFree(pBlob);
		}
		else {
			sqlite3_result_blob(ctx, pBlob, nBlob, rtreeMatchArgFree);
		}
	}
}


SQLITE_API int sqlite3_rtree_geometry_callback(
	sqlite3 *db,                  
	const char *zGeom,            
	int(*xGeom)(sqlite3_rtree_geometry*, int, RtreeDValue*, int*), 
	void *pContext                
) {
	RtreeGeomCallback *pGeomCtx;      

									  
	pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));
	if (!pGeomCtx) return SQLITE_NOMEM;
	pGeomCtx->xGeom = xGeom;
	pGeomCtx->xQueryFunc = 0;
	pGeomCtx->xDestructor = 0;
	pGeomCtx->pContext = pContext;
	return sqlite3_create_function_v2(db, zGeom, -1, SQLITE_ANY,
		(void *)pGeomCtx, geomCallback, 0, 0, rtreeFreeCallback
	);
}


SQLITE_API int sqlite3_rtree_query_callback(
	sqlite3 *db,                 
	const char *zQueryFunc,      
	int(*xQueryFunc)(sqlite3_rtree_query_info*), 
	void *pContext,              
	void(*xDestructor)(void*)   
) {
	RtreeGeomCallback *pGeomCtx;      

									  
	pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));
	if (!pGeomCtx) return SQLITE_NOMEM;
	pGeomCtx->xGeom = 0;
	pGeomCtx->xQueryFunc = xQueryFunc;
	pGeomCtx->xDestructor = xDestructor;
	pGeomCtx->pContext = pContext;
	return sqlite3_create_function_v2(db, zQueryFunc, -1, SQLITE_ANY,
		(void *)pGeomCtx, geomCallback, 0, 0, rtreeFreeCallback
	);
}

#if !SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_rtree_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi)
		return sqlite3RtreeInit(db);
}
#endif

#endif





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ICU)


#include <unicode/utypes.h>
#include <unicode/uregex.h>
#include <unicode/ustring.h>
#include <unicode/ucol.h>



#ifndef SQLITE_CORE

SQLITE_EXTENSION_INIT1
#else

#endif


#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH
# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
#endif


static void xFree(void *p) {
	sqlite3_free(p);
}


static const unsigned char icuUtf8Trans1[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};

#define SQLITE_ICU_READ_UTF8(zIn, c)                       \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = icuUtf8Trans1[c-0xc0];                             \
    while( (*zIn & 0xc0)==0x80 ){                          \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
  }

#define SQLITE_ICU_SKIP_UTF8(zIn)                          \
  assert( *zIn );                                          \
  if( *(zIn++)>=0xc0 ){                                    \
    while( (*zIn & 0xc0)==0x80 ){zIn++;}                   \
  }



static int icuLikeCompare(
	const uint8_t *zPattern,   
	const uint8_t *zString,    
	const UChar32 uEsc         
) {
	static const int MATCH_ONE = (UChar32)'_';
	static const int MATCH_ALL = (UChar32)'%';

	int prevEscape = 0;     

	while (1) {

		
		UChar32 uPattern;
		SQLITE_ICU_READ_UTF8(zPattern, uPattern);
		if (uPattern == 0) break;

		
		if (!prevEscape && uPattern == MATCH_ALL) {
			
			uint8_t c;

			
			while ((c = *zPattern) == MATCH_ALL || c == MATCH_ONE) {
				if (c == MATCH_ONE) {
					if (*zString == 0) return 0;
					SQLITE_ICU_SKIP_UTF8(zString);
				}
				zPattern++;
			}

			if (*zPattern == 0) return 1;

			while (*zString) {
				if (icuLikeCompare(zPattern, zString, uEsc)) {
					return 1;
				}
				SQLITE_ICU_SKIP_UTF8(zString);
			}
			return 0;

		}
		else if (!prevEscape && uPattern == MATCH_ONE) {
			
			if (*zString == 0) return 0;
			SQLITE_ICU_SKIP_UTF8(zString);

		}
		else if (!prevEscape && uPattern == uEsc) {
			
			prevEscape = 1;

		}
		else {
			
			UChar32 uString;
			SQLITE_ICU_READ_UTF8(zString, uString);
			uString = u_foldCase(uString, U_FOLD_CASE_DEFAULT);
			uPattern = u_foldCase(uPattern, U_FOLD_CASE_DEFAULT);
			if (uString != uPattern) {
				return 0;
			}
			prevEscape = 0;
		}
	}

	return *zString == 0;
}


static void icuLikeFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const unsigned char *zA = sqlite3_value_text(argv[0]);
	const unsigned char *zB = sqlite3_value_text(argv[1]);
	UChar32 uEsc = 0;

	
	if (sqlite3_value_bytes(argv[0])>SQLITE_MAX_LIKE_PATTERN_LENGTH) {
		sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
		return;
	}


	if (argc == 3) {
		
		int nE = sqlite3_value_bytes(argv[2]);
		const unsigned char *zE = sqlite3_value_text(argv[2]);
		int i = 0;
		if (zE == 0) return;
		U8_NEXT(zE, i, nE, uEsc);
		if (i != nE) {
			sqlite3_result_error(context,
				"ESCAPE expression must be a single character", -1);
			return;
		}
	}

	if (zA && zB) {
		sqlite3_result_int(context, icuLikeCompare(zA, zB, uEsc));
	}
}


static void icuFunctionError(
	sqlite3_context *pCtx,       
	const char *zName,           
	UErrorCode e                 
) {
	char zBuf[128];
	sqlite3_snprintf(128, zBuf, "ICU error: %s(): %s", zName, u_errorName(e));
	zBuf[127] = '\0';
	sqlite3_result_error(pCtx, zBuf, -1);
}


static void icuRegexpDelete(void *p) {
	URegularExpression *pExpr = (URegularExpression *)p;
	uregex_close(pExpr);
}


static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg) {
	UErrorCode status = U_ZERO_ERROR;
	URegularExpression *pExpr;
	UBool res;
	const UChar *zString = sqlite3_value_text16(apArg[1]);

	(void)nArg;  

				 
	if (!zString) {
		return;
	}

	pExpr = sqlite3_get_auxdata(p, 0);
	if (!pExpr) {
		const UChar *zPattern = sqlite3_value_text16(apArg[0]);
		if (!zPattern) {
			return;
		}
		pExpr = uregex_open(zPattern, -1, 0, 0, &status);

		if (U_SUCCESS(status)) {
			sqlite3_set_auxdata(p, 0, pExpr, icuRegexpDelete);
		}
		else {
			assert(!pExpr);
			icuFunctionError(p, "uregex_open", status);
			return;
		}
	}

	
	uregex_setText(pExpr, zString, -1, &status);
	if (!U_SUCCESS(status)) {
		icuFunctionError(p, "uregex_setText", status);
		return;
	}

	
	res = uregex_matches(pExpr, 0, &status);
	if (!U_SUCCESS(status)) {
		icuFunctionError(p, "uregex_matches", status);
		return;
	}

	
	uregex_setText(pExpr, 0, 0, &status);

	
	sqlite3_result_int(p, res ? 1 : 0);
}


static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg) {
	const UChar *zInput;            
	UChar *zOutput = 0;             
	int nInput;                     
	int nOut;                       
	int cnt;
	int bToUpper;                   
	UErrorCode status;
	const char *zLocale = 0;

	assert(nArg == 1 || nArg == 2);
	bToUpper = (sqlite3_user_data(p) != 0);
	if (nArg == 2) {
		zLocale = (const char *)sqlite3_value_text(apArg[1]);
	}

	zInput = sqlite3_value_text16(apArg[0]);
	if (!zInput) {
		return;
	}
	nOut = nInput = sqlite3_value_bytes16(apArg[0]);
	if (nOut == 0) {
		sqlite3_result_text16(p, "", 0, SQLITE_STATIC);
		return;
	}

	for (cnt = 0; cnt<2; cnt++) {
		UChar *zNew = sqlite3_realloc(zOutput, nOut);
		if (zNew == 0) {
			sqlite3_free(zOutput);
			sqlite3_result_error_nomem(p);
			return;
		}
		zOutput = zNew;
		status = U_ZERO_ERROR;
		if (bToUpper) {
			nOut = 2 * u_strToUpper(zOutput, nOut / 2, zInput, nInput / 2, zLocale, &status);
		}
		else {
			nOut = 2 * u_strToLower(zOutput, nOut / 2, zInput, nInput / 2, zLocale, &status);
		}

		if (U_SUCCESS(status)) {
			sqlite3_result_text16(p, zOutput, nOut, xFree);
		}
		else if (status == U_BUFFER_OVERFLOW_ERROR) {
			assert(cnt == 0);
			continue;
		}
		else {
			icuFunctionError(p, bToUpper ? "u_strToUpper" : "u_strToLower", status);
		}
		return;
	}
	assert(0);     
}


static void icuCollationDel(void *pCtx) {
	UCollator *p = (UCollator *)pCtx;
	ucol_close(p);
}


static int icuCollationColl(
	void *pCtx,
	int nLeft,
	const void *zLeft,
	int nRight,
	const void *zRight
) {
	UCollationResult res;
	UCollator *p = (UCollator *)pCtx;
	res = ucol_strcoll(p, (UChar *)zLeft, nLeft / 2, (UChar *)zRight, nRight / 2);
	switch (res) {
	case UCOL_LESS:    return -1;
	case UCOL_GREATER: return +1;
	case UCOL_EQUAL:   return 0;
	}
	assert(!"Unexpected return value from ucol_strcoll()");
	return 0;
}


static void icuLoadCollation(
	sqlite3_context *p,
	int nArg,
	sqlite3_value **apArg
) {
	sqlite3 *db = (sqlite3 *)sqlite3_user_data(p);
	UErrorCode status = U_ZERO_ERROR;
	const char *zLocale;      
	const char *zName;        
	UCollator *pUCollator;    
	int rc;                   

	assert(nArg == 2);
	(void)nArg; 
	zLocale = (const char *)sqlite3_value_text(apArg[0]);
	zName = (const char *)sqlite3_value_text(apArg[1]);

	if (!zLocale || !zName) {
		return;
	}

	pUCollator = ucol_open(zLocale, &status);
	if (!U_SUCCESS(status)) {
		icuFunctionError(p, "ucol_open", status);
		return;
	}
	assert(p);

	rc = sqlite3_create_collation_v2(db, zName, SQLITE_UTF16, (void *)pUCollator,
		icuCollationColl, icuCollationDel
	);
	if (rc != SQLITE_OK) {
		ucol_close(pUCollator);
		sqlite3_result_error(p, "Error registering collation function", -1);
	}
}


SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db) {
	struct IcuScalar {
		const char *zName;                        
		int nArg;                                 
		int enc;                                  
		void *pContext;                           
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**);
	} scalars[] = {
		{ "regexp", 2, SQLITE_ANY | SQLITE_DETERMINISTIC,          0, icuRegexpFunc },

		{ "lower",  1, SQLITE_UTF16 | SQLITE_DETERMINISTIC,        0, icuCaseFunc16 },
		{ "lower",  2, SQLITE_UTF16 | SQLITE_DETERMINISTIC,        0, icuCaseFunc16 },
		{ "upper",  1, SQLITE_UTF16 | SQLITE_DETERMINISTIC, (void*)1, icuCaseFunc16 },
		{ "upper",  2, SQLITE_UTF16 | SQLITE_DETERMINISTIC, (void*)1, icuCaseFunc16 },

		{ "lower",  1, SQLITE_UTF8 | SQLITE_DETERMINISTIC,         0, icuCaseFunc16 },
		{ "lower",  2, SQLITE_UTF8 | SQLITE_DETERMINISTIC,         0, icuCaseFunc16 },
		{ "upper",  1, SQLITE_UTF8 | SQLITE_DETERMINISTIC,  (void*)1, icuCaseFunc16 },
		{ "upper",  2, SQLITE_UTF8 | SQLITE_DETERMINISTIC,  (void*)1, icuCaseFunc16 },

		{ "like",   2, SQLITE_UTF8 | SQLITE_DETERMINISTIC,         0, icuLikeFunc },
		{ "like",   3, SQLITE_UTF8 | SQLITE_DETERMINISTIC,         0, icuLikeFunc },

		{ "icu_load_collation",  2, SQLITE_UTF8, (void*)db, icuLoadCollation },
	};

	int rc = SQLITE_OK;
	int i;

	for (i = 0; rc == SQLITE_OK && i<(int)(sizeof(scalars) / sizeof(scalars[0])); i++) {
		struct IcuScalar *p = &scalars[i];
		rc = sqlite3_create_function(
			db, p->zName, p->nArg, p->enc, p->pContext, p->xFunc, 0, 0
		);
	}

	return rc;
}

#if !SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_icu_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi)
		return sqlite3IcuInit(db);
}
#endif

#endif





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifdef SQLITE_ENABLE_ICU





#include <unicode/ubrk.h>


#include <unicode/utf16.h>

typedef struct IcuTokenizer IcuTokenizer;
typedef struct IcuCursor IcuCursor;

struct IcuTokenizer {
	sqlite3_tokenizer base;
	char *zLocale;
};

struct IcuCursor {
	sqlite3_tokenizer_cursor base;

	UBreakIterator *pIter;      
	int nChar;                  
	UChar *aChar;               
	int *aOffset;               

	int nBuffer;
	char *zBuffer;

	int iToken;
};


static int icuCreate(
	int argc,                            
	const char * const *argv,            
	sqlite3_tokenizer **ppTokenizer      
) {
	IcuTokenizer *p;
	int n = 0;

	if (argc>0) {
		n = strlen(argv[0]) + 1;
	}
	p = (IcuTokenizer *)sqlite3_malloc(sizeof(IcuTokenizer) + n);
	if (!p) {
		return SQLITE_NOMEM;
	}
	memset(p, 0, sizeof(IcuTokenizer));

	if (n) {
		p->zLocale = (char *)&p[1];
		memcpy(p->zLocale, argv[0], n);
	}

	*ppTokenizer = (sqlite3_tokenizer *)p;

	return SQLITE_OK;
}


static int icuDestroy(sqlite3_tokenizer *pTokenizer) {
	IcuTokenizer *p = (IcuTokenizer *)pTokenizer;
	sqlite3_free(p);
	return SQLITE_OK;
}


static int icuOpen(
	sqlite3_tokenizer *pTokenizer,         
	const char *zInput,                    
	int nInput,                            
	sqlite3_tokenizer_cursor **ppCursor    
) {
	IcuTokenizer *p = (IcuTokenizer *)pTokenizer;
	IcuCursor *pCsr;

	const int32_t opt = U_FOLD_CASE_DEFAULT;
	UErrorCode status = U_ZERO_ERROR;
	int nChar;

	UChar32 c;
	int iInput = 0;
	int iOut = 0;

	*ppCursor = 0;

	if (zInput == 0) {
		nInput = 0;
		zInput = "";
	}
	else if (nInput<0) {
		nInput = strlen(zInput);
	}
	nChar = nInput + 1;
	pCsr = (IcuCursor *)sqlite3_malloc(
		sizeof(IcuCursor) +                
		((nChar + 3)&~3) * sizeof(UChar) +   
		(nChar + 1) * sizeof(int)            
	);
	if (!pCsr) {
		return SQLITE_NOMEM;
	}
	memset(pCsr, 0, sizeof(IcuCursor));
	pCsr->aChar = (UChar *)&pCsr[1];
	pCsr->aOffset = (int *)&pCsr->aChar[(nChar + 3)&~3];

	pCsr->aOffset[iOut] = iInput;
	U8_NEXT(zInput, iInput, nInput, c);
	while (c>0) {
		int isError = 0;
		c = u_foldCase(c, opt);
		U16_APPEND(pCsr->aChar, iOut, nChar, c, isError);
		if (isError) {
			sqlite3_free(pCsr);
			return SQLITE_ERROR;
		}
		pCsr->aOffset[iOut] = iInput;

		if (iInput<nInput) {
			U8_NEXT(zInput, iInput, nInput, c);
		}
		else {
			c = 0;
		}
	}

	pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);
	if (!U_SUCCESS(status)) {
		sqlite3_free(pCsr);
		return SQLITE_ERROR;
	}
	pCsr->nChar = iOut;

	ubrk_first(pCsr->pIter);
	*ppCursor = (sqlite3_tokenizer_cursor *)pCsr;
	return SQLITE_OK;
}


static int icuClose(sqlite3_tokenizer_cursor *pCursor) {
	IcuCursor *pCsr = (IcuCursor *)pCursor;
	ubrk_close(pCsr->pIter);
	sqlite3_free(pCsr->zBuffer);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}


static int icuNext(
	sqlite3_tokenizer_cursor *pCursor,  
	const char **ppToken,               
	int *pnBytes,                       
	int *piStartOffset,                 
	int *piEndOffset,                   
	int *piPosition                     
) {
	IcuCursor *pCsr = (IcuCursor *)pCursor;

	int iStart = 0;
	int iEnd = 0;
	int nByte = 0;

	while (iStart == iEnd) {
		UChar32 c;

		iStart = ubrk_current(pCsr->pIter);
		iEnd = ubrk_next(pCsr->pIter);
		if (iEnd == UBRK_DONE) {
			return SQLITE_DONE;
		}

		while (iStart<iEnd) {
			int iWhite = iStart;
			U16_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c);
			if (u_isspace(c)) {
				iStart = iWhite;
			}
			else {
				break;
			}
		}
		assert(iStart <= iEnd);
	}

	do {
		UErrorCode status = U_ZERO_ERROR;
		if (nByte) {
			char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte);
			if (!zNew) {
				return SQLITE_NOMEM;
			}
			pCsr->zBuffer = zNew;
			pCsr->nBuffer = nByte;
		}

		u_strToUTF8(
			pCsr->zBuffer, pCsr->nBuffer, &nByte,    
			&pCsr->aChar[iStart], iEnd - iStart,       
			&status                                  
		);
	} while (nByte>pCsr->nBuffer);

	*ppToken = pCsr->zBuffer;
	*pnBytes = nByte;
	*piStartOffset = pCsr->aOffset[iStart];
	*piEndOffset = pCsr->aOffset[iEnd];
	*piPosition = pCsr->iToken++;

	return SQLITE_OK;
}


static const sqlite3_tokenizer_module icuTokenizerModule = {
	0,                           
	icuCreate,                   
	icuDestroy,                  
	icuOpen,                     
	icuClose,                    
	icuNext,                     
	0,                           
};


SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
	sqlite3_tokenizer_module const**ppModule
) {
	*ppModule = &icuTokenizerModule;
}

#endif 
#endif 











#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RBU)






#ifndef _SQLITE3RBU_H
#define _SQLITE3RBU_H



#if 0
extern "C" {
#endif

	typedef struct sqlite3rbu sqlite3rbu;

	
	SQLITE_API sqlite3rbu *sqlite3rbu_open(
		const char *zTarget,
		const char *zRbu,
		const char *zState
	);

	
	SQLITE_API sqlite3rbu *sqlite3rbu_vacuum(
		const char *zTarget,
		const char *zState
	);

	
	SQLITE_API sqlite3 *sqlite3rbu_db(sqlite3rbu*, int bRbu);

	
	SQLITE_API int sqlite3rbu_step(sqlite3rbu *pRbu);

	
	SQLITE_API int sqlite3rbu_savestate(sqlite3rbu *pRbu);

	
	SQLITE_API int sqlite3rbu_close(sqlite3rbu *pRbu, char **pzErrmsg);

	
	SQLITE_API sqlite3_int64 sqlite3rbu_progress(sqlite3rbu *pRbu);

	
	SQLITE_API void sqlite3rbu_bp_progress(sqlite3rbu *pRbu, int *pnOne, int *pnTwo);

	
#define SQLITE_RBU_STATE_OAL        1
#define SQLITE_RBU_STATE_MOVE       2
#define SQLITE_RBU_STATE_CHECKPOINT 3
#define SQLITE_RBU_STATE_DONE       4
#define SQLITE_RBU_STATE_ERROR      5

	SQLITE_API int sqlite3rbu_state(sqlite3rbu *pRbu);

	
	SQLITE_API int sqlite3rbu_create_vfs(const char *zName, const char *zParent);

	
	SQLITE_API void sqlite3rbu_destroy_vfs(const char *zName);

#if 0
}  
#endif

#endif 

   
   

#if defined(_WIN32_WCE)
   
#endif

   
#define SQLITE_RBU_UPDATE_CACHESIZE 16

   
#if !defined(SQLITE_AMALGAMATION)
# define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}
#endif

   
#define RBU_STATE_STAGE        1
#define RBU_STATE_TBL          2
#define RBU_STATE_IDX          3
#define RBU_STATE_ROW          4
#define RBU_STATE_PROGRESS     5
#define RBU_STATE_CKPT         6
#define RBU_STATE_COOKIE       7
#define RBU_STATE_OALSZ        8
#define RBU_STATE_PHASEONESTEP 9

#define RBU_STAGE_OAL         1
#define RBU_STAGE_MOVE        2
#define RBU_STAGE_CAPTURE     3
#define RBU_STAGE_CKPT        4
#define RBU_STAGE_DONE        5


#define RBU_CREATE_STATE \
  "CREATE TABLE IF NOT EXISTS %s.rbu_state(k INTEGER PRIMARY KEY, v)"

typedef struct RbuFrame RbuFrame;
typedef struct RbuObjIter RbuObjIter;
typedef struct RbuState RbuState;
typedef struct rbu_vfs rbu_vfs;
typedef struct rbu_file rbu_file;
typedef struct RbuUpdateStmt RbuUpdateStmt;

#if !defined(SQLITE_AMALGAMATION)
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef sqlite3_int64 i64;
#endif


#define WAL_LOCK_WRITE  0
#define WAL_LOCK_CKPT   1
#define WAL_LOCK_READ0  3

#define SQLITE_FCNTL_RBUCNT    5149216


struct RbuState {
	int eStage;
	char *zTbl;
	char *zIdx;
	i64 iWalCksum;
	int nRow;
	i64 nProgress;
	u32 iCookie;
	i64 iOalSz;
	i64 nPhaseOneStep;
};

struct RbuUpdateStmt {
	char *zMask;                    
	sqlite3_stmt *pUpdate;          
	RbuUpdateStmt *pNext;
};


struct RbuObjIter {
	sqlite3_stmt *pTblIter;         
	sqlite3_stmt *pIdxIter;         
	int nTblCol;                    
	char **azTblCol;                
	char **azTblType;               
	int *aiSrcOrder;                
	u8 *abTblPk;                    
	u8 *abNotNull;                  
	u8 *abIndexed;                  
	int eType;                      

									
	int bCleanup;                   
	const char *zTbl;               
	const char *zDataTbl;           
	const char *zIdx;               
	int iTnum;                      
	int iPkTnum;                    
	int bUnique;                    
	int nIndex;                     

									
	int nCol;                       
	sqlite3_stmt *pSelect;          
	sqlite3_stmt *pInsert;          
	sqlite3_stmt *pDelete;          
	sqlite3_stmt *pTmpInsert;       

									
	RbuUpdateStmt *pRbuUpdate;
};


#define RBU_PK_NOTABLE        0
#define RBU_PK_NONE           1
#define RBU_PK_IPK            2
#define RBU_PK_EXTERNAL       3
#define RBU_PK_WITHOUT_ROWID  4
#define RBU_PK_VTAB           5



#define RBU_INSERT     1          
#define RBU_DELETE     2          
#define RBU_REPLACE    3          
#define RBU_IDX_DELETE 4          
#define RBU_IDX_INSERT 5          

#define RBU_UPDATE     6          


struct RbuFrame {
	u32 iDbPage;
	u32 iWalFrame;
};


struct sqlite3rbu {
	int eStage;                     
	sqlite3 *dbMain;                
	sqlite3 *dbRbu;                 
	char *zTarget;                  
	char *zRbu;                     
	char *zState;                   
	char zStateDb[5];               
	int rc;                         
	char *zErrmsg;                  
	int nStep;                      
	int nProgress;                  
	RbuObjIter objiter;             
	const char *zVfsName;           
	rbu_file *pTargetFd;            
	i64 iOalSz;
	i64 nPhaseOneStep;

	
	u32 iMaxFrame;                  
	u32 mLock;
	int nFrame;                     
	int nFrameAlloc;                
	RbuFrame *aFrame;
	int pgsz;
	u8 *aBuf;
	i64 iWalCksum;

	
	int nRbu;                       
	rbu_file *pRbuFd;               
};


struct rbu_vfs {
	sqlite3_vfs base;               
	sqlite3_vfs *pRealVfs;          
	sqlite3_mutex *mutex;           
	rbu_file *pMain;                
};


struct rbu_file {
	sqlite3_file base;              
	sqlite3_file *pReal;            
	rbu_vfs *pRbuVfs;               
	sqlite3rbu *pRbu;               

	int openFlags;                  
	u32 iCookie;                    
	u8 iWriteVer;                   
	u8 bNolock;                     

	int nShm;                       
	char **apShm;                   
	char *zDel;                     

	const char *zWal;               
	rbu_file *pWalFd;               
	rbu_file *pMainNext;            
};


#define rbuIsVacuum(p) ((p)->zTarget==0)





static unsigned int rbuDeltaGetInt(const char **pz, int *pLen) {
	static const signed char zValue[] = {
		-1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
		0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,
		-1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,
		25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,
		-1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,
		52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1,
	};
	unsigned int v = 0;
	int c;
	unsigned char *z = (unsigned char*)*pz;
	unsigned char *zStart = z;
	while ((c = zValue[0x7f & *(z++)]) >= 0) {
		v = (v << 6) + c;
	}
	z--;
	*pLen -= z - zStart;
	*pz = (char*)z;
	return v;
}


static unsigned int rbuDeltaChecksum(const char *zIn, size_t N) {
	const unsigned char *z = (const unsigned char *)zIn;
	unsigned sum0 = 0;
	unsigned sum1 = 0;
	unsigned sum2 = 0;
	unsigned sum3 = 0;
	while (N >= 16) {
		sum0 += ((unsigned)z[0] + z[4] + z[8] + z[12]);
		sum1 += ((unsigned)z[1] + z[5] + z[9] + z[13]);
		sum2 += ((unsigned)z[2] + z[6] + z[10] + z[14]);
		sum3 += ((unsigned)z[3] + z[7] + z[11] + z[15]);
		z += 16;
		N -= 16;
	}
	while (N >= 4) {
		sum0 += z[0];
		sum1 += z[1];
		sum2 += z[2];
		sum3 += z[3];
		z += 4;
		N -= 4;
	}
	sum3 += (sum2 << 8) + (sum1 << 16) + (sum0 << 24);
	switch (N) {
	case 3:   sum3 += (z[2] << 8);
	case 2:   sum3 += (z[1] << 16);
	case 1:   sum3 += (z[0] << 24);
	default:;
	}
	return sum3;
}


static int rbuDeltaApply(
	const char *zSrc,      
	int lenSrc,            
	const char *zDelta,    
	int lenDelta,          
	char *zOut             
) {
	unsigned int limit;
	unsigned int total = 0;
#ifndef FOSSIL_OMIT_DELTA_CKSUM_TEST
	char *zOrigOut = zOut;
#endif

	limit = rbuDeltaGetInt(&zDelta, &lenDelta);
	if (*zDelta != '\n') {
		
		return -1;
	}
	zDelta++; lenDelta--;
	while (*zDelta && lenDelta>0) {
		unsigned int cnt, ofst;
		cnt = rbuDeltaGetInt(&zDelta, &lenDelta);
		switch (zDelta[0]) {
		case '@': {
			zDelta++; lenDelta--;
			ofst = rbuDeltaGetInt(&zDelta, &lenDelta);
			if (lenDelta>0 && zDelta[0] != ',') {
				
				return -1;
			}
			zDelta++; lenDelta--;
			total += cnt;
			if (total>limit) {
				
				return -1;
			}
			if ((int)(ofst + cnt) > lenSrc) {
				
				return -1;
			}
			memcpy(zOut, &zSrc[ofst], cnt);
			zOut += cnt;
			break;
		}
		case ':': {
			zDelta++; lenDelta--;
			total += cnt;
			if (total>limit) {
				
				return -1;
			}
			if ((int)cnt>lenDelta) {
				
				return -1;
			}
			memcpy(zOut, zDelta, cnt);
			zOut += cnt;
			zDelta += cnt;
			lenDelta -= cnt;
			break;
		}
		case ';': {
			zDelta++; lenDelta--;
			zOut[0] = 0;
#ifndef FOSSIL_OMIT_DELTA_CKSUM_TEST
			if (cnt != rbuDeltaChecksum(zOrigOut, total)) {
				
				return -1;
			}
#endif
			if (total != limit) {
				
				return -1;
			}
			return total;
		}
		default: {
			
			return -1;
		}
		}
	}
	
	return -1;
}

static int rbuDeltaOutputSize(const char *zDelta, int lenDelta) {
	int size;
	size = rbuDeltaGetInt(&zDelta, &lenDelta);
	if (*zDelta != '\n') {
		
		return -1;
	}
	return size;
}




static void rbuFossilDeltaFunc(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	const char *aDelta;
	int nDelta;
	const char *aOrig;
	int nOrig;

	int nOut;
	int nOut2;
	char *aOut;

	assert(argc == 2);

	nOrig = sqlite3_value_bytes(argv[0]);
	aOrig = (const char*)sqlite3_value_blob(argv[0]);
	nDelta = sqlite3_value_bytes(argv[1]);
	aDelta = (const char*)sqlite3_value_blob(argv[1]);

	
	nOut = rbuDeltaOutputSize(aDelta, nDelta);
	if (nOut<0) {
		sqlite3_result_error(context, "corrupt fossil delta", -1);
		return;
	}

	aOut = sqlite3_malloc(nOut + 1);
	if (aOut == 0) {
		sqlite3_result_error_nomem(context);
	}
	else {
		nOut2 = rbuDeltaApply(aOrig, nOrig, aDelta, nDelta, aOut);
		if (nOut2 != nOut) {
			sqlite3_result_error(context, "corrupt fossil delta", -1);
		}
		else {
			sqlite3_result_blob(context, aOut, nOut, sqlite3_free);
		}
	}
}



static int prepareAndCollectError(
	sqlite3 *db,
	sqlite3_stmt **ppStmt,
	char **pzErrmsg,
	const char *zSql
) {
	int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
	if (rc != SQLITE_OK) {
		*pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));
		*ppStmt = 0;
	}
	return rc;
}


static int resetAndCollectError(sqlite3_stmt *pStmt, char **pzErrmsg) {
	int rc = sqlite3_reset(pStmt);
	if (rc != SQLITE_OK) {
		*pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(sqlite3_db_handle(pStmt)));
	}
	return rc;
}


static int prepareFreeAndCollectError(
	sqlite3 *db,
	sqlite3_stmt **ppStmt,
	char **pzErrmsg,
	char *zSql
) {
	int rc;
	assert(*pzErrmsg == 0);
	if (zSql == 0) {
		rc = SQLITE_NOMEM;
		*ppStmt = 0;
	}
	else {
		rc = prepareAndCollectError(db, ppStmt, pzErrmsg, zSql);
		sqlite3_free(zSql);
	}
	return rc;
}


static void rbuObjIterFreeCols(RbuObjIter *pIter) {
	int i;
	for (i = 0; i<pIter->nTblCol; i++) {
		sqlite3_free(pIter->azTblCol[i]);
		sqlite3_free(pIter->azTblType[i]);
	}
	sqlite3_free(pIter->azTblCol);
	pIter->azTblCol = 0;
	pIter->azTblType = 0;
	pIter->aiSrcOrder = 0;
	pIter->abTblPk = 0;
	pIter->abNotNull = 0;
	pIter->nTblCol = 0;
	pIter->eType = 0;               
}


static void rbuObjIterClearStatements(RbuObjIter *pIter) {
	RbuUpdateStmt *pUp;

	sqlite3_finalize(pIter->pSelect);
	sqlite3_finalize(pIter->pInsert);
	sqlite3_finalize(pIter->pDelete);
	sqlite3_finalize(pIter->pTmpInsert);
	pUp = pIter->pRbuUpdate;
	while (pUp) {
		RbuUpdateStmt *pTmp = pUp->pNext;
		sqlite3_finalize(pUp->pUpdate);
		sqlite3_free(pUp);
		pUp = pTmp;
	}

	pIter->pSelect = 0;
	pIter->pInsert = 0;
	pIter->pDelete = 0;
	pIter->pRbuUpdate = 0;
	pIter->pTmpInsert = 0;
	pIter->nCol = 0;
}


static void rbuObjIterFinalize(RbuObjIter *pIter) {
	rbuObjIterClearStatements(pIter);
	sqlite3_finalize(pIter->pTblIter);
	sqlite3_finalize(pIter->pIdxIter);
	rbuObjIterFreeCols(pIter);
	memset(pIter, 0, sizeof(RbuObjIter));
}


static int rbuObjIterNext(sqlite3rbu *p, RbuObjIter *pIter) {
	int rc = p->rc;
	if (rc == SQLITE_OK) {

		
		rbuObjIterClearStatements(pIter);
		if (pIter->zIdx == 0) {
			rc = sqlite3_exec(p->dbMain,
				"DROP TRIGGER IF EXISTS temp.rbu_insert_tr;"
				"DROP TRIGGER IF EXISTS temp.rbu_update1_tr;"
				"DROP TRIGGER IF EXISTS temp.rbu_update2_tr;"
				"DROP TRIGGER IF EXISTS temp.rbu_delete_tr;"
				, 0, 0, &p->zErrmsg
			);
		}

		if (rc == SQLITE_OK) {
			if (pIter->bCleanup) {
				rbuObjIterFreeCols(pIter);
				pIter->bCleanup = 0;
				rc = sqlite3_step(pIter->pTblIter);
				if (rc != SQLITE_ROW) {
					rc = resetAndCollectError(pIter->pTblIter, &p->zErrmsg);
					pIter->zTbl = 0;
				}
				else {
					pIter->zTbl = (const char*)sqlite3_column_text(pIter->pTblIter, 0);
					pIter->zDataTbl = (const char*)sqlite3_column_text(pIter->pTblIter, 1);
					rc = (pIter->zDataTbl && pIter->zTbl) ? SQLITE_OK : SQLITE_NOMEM;
				}
			}
			else {
				if (pIter->zIdx == 0) {
					sqlite3_stmt *pIdx = pIter->pIdxIter;
					rc = sqlite3_bind_text(pIdx, 1, pIter->zTbl, -1, SQLITE_STATIC);
				}
				if (rc == SQLITE_OK) {
					rc = sqlite3_step(pIter->pIdxIter);
					if (rc != SQLITE_ROW) {
						rc = resetAndCollectError(pIter->pIdxIter, &p->zErrmsg);
						pIter->bCleanup = 1;
						pIter->zIdx = 0;
					}
					else {
						pIter->zIdx = (const char*)sqlite3_column_text(pIter->pIdxIter, 0);
						pIter->iTnum = sqlite3_column_int(pIter->pIdxIter, 1);
						pIter->bUnique = sqlite3_column_int(pIter->pIdxIter, 2);
						rc = pIter->zIdx ? SQLITE_OK : SQLITE_NOMEM;
					}
				}
			}
		}
	}

	if (rc != SQLITE_OK) {
		rbuObjIterFinalize(pIter);
		p->rc = rc;
	}
	return rc;
}



static void rbuTargetNameFunc(
	sqlite3_context *pCtx,
	int argc,
	sqlite3_value **argv
) {
	sqlite3rbu *p = sqlite3_user_data(pCtx);
	const char *zIn;
	assert(argc == 1 || argc == 2);

	zIn = (const char*)sqlite3_value_text(argv[0]);
	if (zIn) {
		if (rbuIsVacuum(p)) {
			if (argc == 1 || 0 == sqlite3_value_int(argv[1])) {
				sqlite3_result_text(pCtx, zIn, -1, SQLITE_STATIC);
			}
		}
		else {
			if (strlen(zIn)>4 && memcmp("data", zIn, 4) == 0) {
				int i;
				for (i = 4; zIn[i] >= '0' && zIn[i] <= '9'; i++);
				if (zIn[i] == '_' && zIn[i + 1]) {
					sqlite3_result_text(pCtx, &zIn[i + 1], -1, SQLITE_STATIC);
				}
			}
		}
	}
}


static int rbuObjIterFirst(sqlite3rbu *p, RbuObjIter *pIter) {
	int rc;
	memset(pIter, 0, sizeof(RbuObjIter));

	rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pTblIter, &p->zErrmsg,
		sqlite3_mprintf(
			"SELECT rbu_target_name(name, type='view') AS target, name "
			"FROM sqlite_master "
			"WHERE type IN ('table', 'view') AND target IS NOT NULL "
			" %s "
			"ORDER BY name"
			, rbuIsVacuum(p) ? "AND rootpage!=0 AND rootpage IS NOT NULL" : ""));

	if (rc == SQLITE_OK) {
		rc = prepareAndCollectError(p->dbMain, &pIter->pIdxIter, &p->zErrmsg,
			"SELECT name, rootpage, sql IS NULL OR substr(8, 6)=='UNIQUE' "
			"  FROM main.sqlite_master "
			"  WHERE type='index' AND tbl_name = ?"
		);
	}

	pIter->bCleanup = 1;
	p->rc = rc;
	return rbuObjIterNext(p, pIter);
}


static char *rbuMPrintf(sqlite3rbu *p, const char *zFmt, ...) {
	char *zSql = 0;
	va_list ap;
	va_start(ap, zFmt);
	zSql = sqlite3_vmprintf(zFmt, ap);
	if (p->rc == SQLITE_OK) {
		if (zSql == 0) p->rc = SQLITE_NOMEM;
	}
	else {
		sqlite3_free(zSql);
		zSql = 0;
	}
	va_end(ap);
	return zSql;
}


static int rbuMPrintfExec(sqlite3rbu *p, sqlite3 *db, const char *zFmt, ...) {
	va_list ap;
	char *zSql;
	va_start(ap, zFmt);
	zSql = sqlite3_vmprintf(zFmt, ap);
	if (p->rc == SQLITE_OK) {
		if (zSql == 0) {
			p->rc = SQLITE_NOMEM;
		}
		else {
			p->rc = sqlite3_exec(db, zSql, 0, 0, &p->zErrmsg);
		}
	}
	sqlite3_free(zSql);
	va_end(ap);
	return p->rc;
}


static void *rbuMalloc(sqlite3rbu *p, int nByte) {
	void *pRet = 0;
	if (p->rc == SQLITE_OK) {
		assert(nByte>0);
		pRet = sqlite3_malloc64(nByte);
		if (pRet == 0) {
			p->rc = SQLITE_NOMEM;
		}
		else {
			memset(pRet, 0, nByte);
		}
	}
	return pRet;
}



static void rbuAllocateIterArrays(sqlite3rbu *p, RbuObjIter *pIter, int nCol) {
	int nByte = (2 * sizeof(char*) + sizeof(int) + 3 * sizeof(u8)) * nCol;
	char **azNew;

	azNew = (char**)rbuMalloc(p, nByte);
	if (azNew) {
		pIter->azTblCol = azNew;
		pIter->azTblType = &azNew[nCol];
		pIter->aiSrcOrder = (int*)&pIter->azTblType[nCol];
		pIter->abTblPk = (u8*)&pIter->aiSrcOrder[nCol];
		pIter->abNotNull = (u8*)&pIter->abTblPk[nCol];
		pIter->abIndexed = (u8*)&pIter->abNotNull[nCol];
	}
}


static char *rbuStrndup(const char *zStr, int *pRc) {
	char *zRet = 0;

	assert(*pRc == SQLITE_OK);
	if (zStr) {
		size_t nCopy = strlen(zStr) + 1;
		zRet = (char*)sqlite3_malloc64(nCopy);
		if (zRet) {
			memcpy(zRet, zStr, nCopy);
		}
		else {
			*pRc = SQLITE_NOMEM;
		}
	}

	return zRet;
}


static void rbuFinalize(sqlite3rbu *p, sqlite3_stmt *pStmt) {
	sqlite3 *db = sqlite3_db_handle(pStmt);
	int rc = sqlite3_finalize(pStmt);
	if (p->rc == SQLITE_OK && rc != SQLITE_OK) {
		p->rc = rc;
		p->zErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));
	}
}


static void rbuTableType(
	sqlite3rbu *p,
	const char *zTab,
	int *peType,
	int *piTnum,
	int *piPk
) {
	
	sqlite3_stmt *aStmt[4] = { 0, 0, 0, 0 };

	*peType = RBU_PK_NOTABLE;
	*piPk = 0;

	assert(p->rc == SQLITE_OK);
	p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[0], &p->zErrmsg,
		sqlite3_mprintf(
			"SELECT (sql LIKE 'create virtual%%'), rootpage"
			"  FROM sqlite_master"
			" WHERE name=%Q", zTab
		));
	if (p->rc != SQLITE_OK || sqlite3_step(aStmt[0]) != SQLITE_ROW) {
		
		goto rbuTableType_end;
	}
	if (sqlite3_column_int(aStmt[0], 0)) {
		*peType = RBU_PK_VTAB;                     
		goto rbuTableType_end;
	}
	*piTnum = sqlite3_column_int(aStmt[0], 1);

	p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[1], &p->zErrmsg,
		sqlite3_mprintf("PRAGMA index_list=%Q", zTab)
	);
	if (p->rc) goto rbuTableType_end;
	while (sqlite3_step(aStmt[1]) == SQLITE_ROW) {
		const u8 *zOrig = sqlite3_column_text(aStmt[1], 3);
		const u8 *zIdx = sqlite3_column_text(aStmt[1], 1);
		if (zOrig && zIdx && zOrig[0] == 'p') {
			p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[2], &p->zErrmsg,
				sqlite3_mprintf(
					"SELECT rootpage FROM sqlite_master WHERE name = %Q", zIdx
				));
			if (p->rc == SQLITE_OK) {
				if (sqlite3_step(aStmt[2]) == SQLITE_ROW) {
					*piPk = sqlite3_column_int(aStmt[2], 0);
					*peType = RBU_PK_EXTERNAL;
				}
				else {
					*peType = RBU_PK_WITHOUT_ROWID;
				}
			}
			goto rbuTableType_end;
		}
	}

	p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[3], &p->zErrmsg,
		sqlite3_mprintf("PRAGMA table_info=%Q", zTab)
	);
	if (p->rc == SQLITE_OK) {
		while (sqlite3_step(aStmt[3]) == SQLITE_ROW) {
			if (sqlite3_column_int(aStmt[3], 5)>0) {
				*peType = RBU_PK_IPK;                
				goto rbuTableType_end;
			}
		}
		*peType = RBU_PK_NONE;
	}

rbuTableType_end: {
	unsigned int i;
	for (i = 0; i<sizeof(aStmt) / sizeof(aStmt[0]); i++) {
		rbuFinalize(p, aStmt[i]);
	}
	}
}


static void rbuObjIterCacheIndexedCols(sqlite3rbu *p, RbuObjIter *pIter) {
	sqlite3_stmt *pList = 0;
	int bIndex = 0;

	if (p->rc == SQLITE_OK) {
		memcpy(pIter->abIndexed, pIter->abTblPk, sizeof(u8)*pIter->nTblCol);
		p->rc = prepareFreeAndCollectError(p->dbMain, &pList, &p->zErrmsg,
			sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)
		);
	}

	pIter->nIndex = 0;
	while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pList)) {
		const char *zIdx = (const char*)sqlite3_column_text(pList, 1);
		sqlite3_stmt *pXInfo = 0;
		if (zIdx == 0) break;
		p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
			sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)
		);
		while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pXInfo)) {
			int iCid = sqlite3_column_int(pXInfo, 1);
			if (iCid >= 0) pIter->abIndexed[iCid] = 1;
		}
		rbuFinalize(p, pXInfo);
		bIndex = 1;
		pIter->nIndex++;
	}

	if (pIter->eType == RBU_PK_WITHOUT_ROWID) {
		
		pIter->nIndex--;
	}

	rbuFinalize(p, pList);
	if (bIndex == 0) pIter->abIndexed = 0;
}



static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter) {
	if (pIter->azTblCol == 0) {
		sqlite3_stmt *pStmt = 0;
		int nCol = 0;
		int i;                        
		int bRbuRowid = 0;            
		int iOrder = 0;
		int iTnum = 0;

		
		assert(pIter->eType == 0);
		rbuTableType(p, pIter->zTbl, &pIter->eType, &iTnum, &pIter->iPkTnum);
		if (p->rc == SQLITE_OK && pIter->eType == RBU_PK_NOTABLE) {
			p->rc = SQLITE_ERROR;
			p->zErrmsg = sqlite3_mprintf("no such table: %s", pIter->zTbl);
		}
		if (p->rc) return p->rc;
		if (pIter->zIdx == 0) pIter->iTnum = iTnum;

		assert(pIter->eType == RBU_PK_NONE || pIter->eType == RBU_PK_IPK
			|| pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_WITHOUT_ROWID
			|| pIter->eType == RBU_PK_VTAB
		);

		
		p->rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,
			sqlite3_mprintf("SELECT * FROM '%q'", pIter->zDataTbl)
		);
		if (p->rc == SQLITE_OK) {
			nCol = sqlite3_column_count(pStmt);
			rbuAllocateIterArrays(p, pIter, nCol);
		}
		for (i = 0; p->rc == SQLITE_OK && i<nCol; i++) {
			const char *zName = (const char*)sqlite3_column_name(pStmt, i);
			if (sqlite3_strnicmp("rbu_", zName, 4)) {
				char *zCopy = rbuStrndup(zName, &p->rc);
				pIter->aiSrcOrder[pIter->nTblCol] = pIter->nTblCol;
				pIter->azTblCol[pIter->nTblCol++] = zCopy;
			}
			else if (0 == sqlite3_stricmp("rbu_rowid", zName)) {
				bRbuRowid = 1;
			}
		}
		sqlite3_finalize(pStmt);
		pStmt = 0;

		if (p->rc == SQLITE_OK
			&& rbuIsVacuum(p) == 0
			&& bRbuRowid != (pIter->eType == RBU_PK_VTAB || pIter->eType == RBU_PK_NONE)
			) {
			p->rc = SQLITE_ERROR;
			p->zErrmsg = sqlite3_mprintf(
				"table %q %s rbu_rowid column", pIter->zDataTbl,
				(bRbuRowid ? "may not have" : "requires")
			);
		}

		
		if (p->rc == SQLITE_OK) {
			p->rc = prepareFreeAndCollectError(p->dbMain, &pStmt, &p->zErrmsg,
				sqlite3_mprintf("PRAGMA table_info(%Q)", pIter->zTbl)
			);
		}
		while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pStmt)) {
			const char *zName = (const char*)sqlite3_column_text(pStmt, 1);
			if (zName == 0) break;  
			for (i = iOrder; i<pIter->nTblCol; i++) {
				if (0 == strcmp(zName, pIter->azTblCol[i])) break;
			}
			if (i == pIter->nTblCol) {
				p->rc = SQLITE_ERROR;
				p->zErrmsg = sqlite3_mprintf("column missing from %q: %s",
					pIter->zDataTbl, zName
				);
			}
			else {
				int iPk = sqlite3_column_int(pStmt, 5);
				int bNotNull = sqlite3_column_int(pStmt, 3);
				const char *zType = (const char*)sqlite3_column_text(pStmt, 2);

				if (i != iOrder) {
					SWAP(int, pIter->aiSrcOrder[i], pIter->aiSrcOrder[iOrder]);
					SWAP(char*, pIter->azTblCol[i], pIter->azTblCol[iOrder]);
				}

				pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);
				pIter->abTblPk[iOrder] = (iPk != 0);
				pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk != 0);
				iOrder++;
			}
		}

		rbuFinalize(p, pStmt);
		rbuObjIterCacheIndexedCols(p, pIter);
		assert(pIter->eType != RBU_PK_VTAB || pIter->abIndexed == 0);
		assert(pIter->eType != RBU_PK_VTAB || pIter->nIndex == 0);
	}

	return p->rc;
}


static char *rbuObjIterGetCollist(
	sqlite3rbu *p,                  
	RbuObjIter *pIter               
) {
	char *zList = 0;
	const char *zSep = "";
	int i;
	for (i = 0; i<pIter->nTblCol; i++) {
		const char *z = pIter->azTblCol[i];
		zList = rbuMPrintf(p, "%z%s\"%w\"", zList, zSep, z);
		zSep = ", ";
	}
	return zList;
}


static char *rbuObjIterGetIndexCols(
	sqlite3rbu *p,                  
	RbuObjIter *pIter,              
	char **pzImposterCols,          
	char **pzImposterPk,            
	char **pzWhere,                 
	int *pnBind                     
) {
	int rc = p->rc;                 
	int rc2;                        
	char *zRet = 0;                 
	char *zImpCols = 0;             
	char *zImpPK = 0;               
	char *zWhere = 0;               
	int nBind = 0;                  
	const char *zCom = "";          
	const char *zAnd = "";          
	sqlite3_stmt *pXInfo = 0;       

	if (rc == SQLITE_OK) {
		assert(p->zErrmsg == 0);
		rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
			sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", pIter->zIdx)
		);
	}

	while (rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pXInfo)) {
		int iCid = sqlite3_column_int(pXInfo, 1);
		int bDesc = sqlite3_column_int(pXInfo, 3);
		const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);
		const char *zCol;
		const char *zType;

		if (iCid<0) {
			
			if (pIter->eType == RBU_PK_IPK) {
				int i;
				for (i = 0; pIter->abTblPk[i] == 0; i++);
				assert(i<pIter->nTblCol);
				zCol = pIter->azTblCol[i];
			}
			else if (rbuIsVacuum(p)) {
				zCol = "_rowid_";
			}
			else {
				zCol = "rbu_rowid";
			}
			zType = "INTEGER";
		}
		else {
			zCol = pIter->azTblCol[iCid];
			zType = pIter->azTblType[iCid];
		}

		zRet = sqlite3_mprintf("%z%s\"%w\" COLLATE %Q", zRet, zCom, zCol, zCollate);
		if (pIter->bUnique == 0 || sqlite3_column_int(pXInfo, 5)) {
			const char *zOrder = (bDesc ? " DESC" : "");
			zImpPK = sqlite3_mprintf("%z%s\"rbu_imp_%d%w\"%s",
				zImpPK, zCom, nBind, zCol, zOrder
			);
		}
		zImpCols = sqlite3_mprintf("%z%s\"rbu_imp_%d%w\" %s COLLATE %Q",
			zImpCols, zCom, nBind, zCol, zType, zCollate
		);
		zWhere = sqlite3_mprintf(
			"%z%s\"rbu_imp_%d%w\" IS ?", zWhere, zAnd, nBind, zCol
		);
		if (zRet == 0 || zImpPK == 0 || zImpCols == 0 || zWhere == 0) rc = SQLITE_NOMEM;
		zCom = ", ";
		zAnd = " AND ";
		nBind++;
	}

	rc2 = sqlite3_finalize(pXInfo);
	if (rc == SQLITE_OK) rc = rc2;

	if (rc != SQLITE_OK) {
		sqlite3_free(zRet);
		sqlite3_free(zImpCols);
		sqlite3_free(zImpPK);
		sqlite3_free(zWhere);
		zRet = 0;
		zImpCols = 0;
		zImpPK = 0;
		zWhere = 0;
		p->rc = rc;
	}

	*pzImposterCols = zImpCols;
	*pzImposterPk = zImpPK;
	*pzWhere = zWhere;
	*pnBind = nBind;
	return zRet;
}


static char *rbuObjIterGetOldlist(
	sqlite3rbu *p,
	RbuObjIter *pIter,
	const char *zObj
) {
	char *zList = 0;
	if (p->rc == SQLITE_OK && pIter->abIndexed) {
		const char *zS = "";
		int i;
		for (i = 0; i<pIter->nTblCol; i++) {
			if (pIter->abIndexed[i]) {
				const char *zCol = pIter->azTblCol[i];
				zList = sqlite3_mprintf("%z%s%s.\"%w\"", zList, zS, zObj, zCol);
			}
			else {
				zList = sqlite3_mprintf("%z%sNULL", zList, zS);
			}
			zS = ", ";
			if (zList == 0) {
				p->rc = SQLITE_NOMEM;
				break;
			}
		}

		
		if (pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_NONE) {
			zList = rbuMPrintf(p, "%z, %s._rowid_", zList, zObj);
		}
	}
	return zList;
}


static char *rbuObjIterGetWhere(
	sqlite3rbu *p,
	RbuObjIter *pIter
) {
	char *zList = 0;
	if (pIter->eType == RBU_PK_VTAB || pIter->eType == RBU_PK_NONE) {
		zList = rbuMPrintf(p, "_rowid_ = ?%d", pIter->nTblCol + 1);
	}
	else if (pIter->eType == RBU_PK_EXTERNAL) {
		const char *zSep = "";
		int i;
		for (i = 0; i<pIter->nTblCol; i++) {
			if (pIter->abTblPk[i]) {
				zList = rbuMPrintf(p, "%z%sc%d=?%d", zList, zSep, i, i + 1);
				zSep = " AND ";
			}
		}
		zList = rbuMPrintf(p,
			"_rowid_ = (SELECT id FROM rbu_imposter2 WHERE %z)", zList
		);

	}
	else {
		const char *zSep = "";
		int i;
		for (i = 0; i<pIter->nTblCol; i++) {
			if (pIter->abTblPk[i]) {
				const char *zCol = pIter->azTblCol[i];
				zList = rbuMPrintf(p, "%z%s\"%w\"=?%d", zList, zSep, zCol, i + 1);
				zSep = " AND ";
			}
		}
	}
	return zList;
}


static void rbuBadControlError(sqlite3rbu *p) {
	p->rc = SQLITE_ERROR;
	p->zErrmsg = sqlite3_mprintf("invalid rbu_control value");
}



static char *rbuObjIterGetSetlist(
	sqlite3rbu *p,
	RbuObjIter *pIter,
	const char *zMask
) {
	char *zList = 0;
	if (p->rc == SQLITE_OK) {
		int i;

		if ((int)strlen(zMask) != pIter->nTblCol) {
			rbuBadControlError(p);
		}
		else {
			const char *zSep = "";
			for (i = 0; i<pIter->nTblCol; i++) {
				char c = zMask[pIter->aiSrcOrder[i]];
				if (c == 'x') {
					zList = rbuMPrintf(p, "%z%s\"%w\"=?%d",
						zList, zSep, pIter->azTblCol[i], i + 1
					);
					zSep = ", ";
				}
				else if (c == 'd') {
					zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_delta(\"%w\", ?%d)",
						zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i + 1
					);
					zSep = ", ";
				}
				else if (c == 'f') {
					zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_fossil_delta(\"%w\", ?%d)",
						zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i + 1
					);
					zSep = ", ";
				}
			}
		}
	}
	return zList;
}


static char *rbuObjIterGetBindlist(sqlite3rbu *p, int nBind) {
	char *zRet = 0;
	int nByte = nBind * 2 + 1;

	zRet = (char*)rbuMalloc(p, nByte);
	if (zRet) {
		int i;
		for (i = 0; i<nBind; i++) {
			zRet[i * 2] = '?';
			zRet[i * 2 + 1] = (i + 1 == nBind) ? '\0' : ',';
		}
	}
	return zRet;
}


static char *rbuWithoutRowidPK(sqlite3rbu *p, RbuObjIter *pIter) {
	char *z = 0;
	assert(pIter->zIdx == 0);
	if (p->rc == SQLITE_OK) {
		const char *zSep = "PRIMARY KEY(";
		sqlite3_stmt *pXList = 0;     
		sqlite3_stmt *pXInfo = 0;     

		p->rc = prepareFreeAndCollectError(p->dbMain, &pXList, &p->zErrmsg,
			sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)
		);
		while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pXList)) {
			const char *zOrig = (const char*)sqlite3_column_text(pXList, 3);
			if (zOrig && strcmp(zOrig, "pk") == 0) {
				const char *zIdx = (const char*)sqlite3_column_text(pXList, 1);
				if (zIdx) {
					p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
						sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)
					);
				}
				break;
			}
		}
		rbuFinalize(p, pXList);

		while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pXInfo)) {
			if (sqlite3_column_int(pXInfo, 5)) {
				
				const char *zCol = (const char*)sqlite3_column_text(pXInfo, 2);
				const char *zDesc = sqlite3_column_int(pXInfo, 3) ? " DESC" : "";
				z = rbuMPrintf(p, "%z%s\"%w\"%s", z, zSep, zCol, zDesc);
				zSep = ", ";
			}
		}
		z = rbuMPrintf(p, "%z)", z);
		rbuFinalize(p, pXInfo);
	}
	return z;
}


static void rbuCreateImposterTable2(sqlite3rbu *p, RbuObjIter *pIter) {
	if (p->rc == SQLITE_OK && pIter->eType == RBU_PK_EXTERNAL) {
		int tnum = pIter->iPkTnum;    
		sqlite3_stmt *pQuery = 0;     
		const char *zIdx = 0;         
		sqlite3_stmt *pXInfo = 0;     
		const char *zComma = "";
		char *zCols = 0;              
		char *zPk = 0;                

									  
		p->rc = prepareAndCollectError(p->dbMain, &pQuery, &p->zErrmsg,
			"SELECT name FROM sqlite_master WHERE rootpage = ?"
		);
		if (p->rc == SQLITE_OK) {
			sqlite3_bind_int(pQuery, 1, tnum);
			if (SQLITE_ROW == sqlite3_step(pQuery)) {
				zIdx = (const char*)sqlite3_column_text(pQuery, 0);
			}
		}
		if (zIdx) {
			p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
				sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)
			);
		}
		rbuFinalize(p, pQuery);

		while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pXInfo)) {
			int bKey = sqlite3_column_int(pXInfo, 5);
			if (bKey) {
				int iCid = sqlite3_column_int(pXInfo, 1);
				int bDesc = sqlite3_column_int(pXInfo, 3);
				const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);
				zCols = rbuMPrintf(p, "%z%sc%d %s COLLATE %s", zCols, zComma,
					iCid, pIter->azTblType[iCid], zCollate
				);
				zPk = rbuMPrintf(p, "%z%sc%d%s", zPk, zComma, iCid, bDesc ? " DESC" : "");
				zComma = ", ";
			}
		}
		zCols = rbuMPrintf(p, "%z, id INTEGER", zCols);
		rbuFinalize(p, pXInfo);

		sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1, tnum);
		rbuMPrintfExec(p, p->dbMain,
			"CREATE TABLE rbu_imposter2(%z, PRIMARY KEY(%z)) WITHOUT ROWID",
			zCols, zPk
		);
		sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);
	}
}


static void rbuCreateImposterTable(sqlite3rbu *p, RbuObjIter *pIter) {
	if (p->rc == SQLITE_OK && pIter->eType != RBU_PK_VTAB) {
		int tnum = pIter->iTnum;
		const char *zComma = "";
		char *zSql = 0;
		int iCol;
		sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 1);

		for (iCol = 0; p->rc == SQLITE_OK && iCol<pIter->nTblCol; iCol++) {
			const char *zPk = "";
			const char *zCol = pIter->azTblCol[iCol];
			const char *zColl = 0;

			p->rc = sqlite3_table_column_metadata(
				p->dbMain, "main", pIter->zTbl, zCol, 0, &zColl, 0, 0, 0
			);

			if (pIter->eType == RBU_PK_IPK && pIter->abTblPk[iCol]) {
				
				zPk = "PRIMARY KEY ";
			}
			zSql = rbuMPrintf(p, "%z%s\"%w\" %s %sCOLLATE %s%s",
				zSql, zComma, zCol, pIter->azTblType[iCol], zPk, zColl,
				(pIter->abNotNull[iCol] ? " NOT NULL" : "")
			);
			zComma = ", ";
		}

		if (pIter->eType == RBU_PK_WITHOUT_ROWID) {
			char *zPk = rbuWithoutRowidPK(p, pIter);
			if (zPk) {
				zSql = rbuMPrintf(p, "%z, %z", zSql, zPk);
			}
		}

		sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1, tnum);
		rbuMPrintfExec(p, p->dbMain, "CREATE TABLE \"rbu_imp_%w\"(%z)%s",
			pIter->zTbl, zSql,
			(pIter->eType == RBU_PK_WITHOUT_ROWID ? " WITHOUT ROWID" : "")
		);
		sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);
	}
}


static void rbuObjIterPrepareTmpInsert(
	sqlite3rbu *p,
	RbuObjIter *pIter,
	const char *zCollist,
	const char *zRbuRowid
) {
	int bRbuRowid = (pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_NONE);
	char *zBind = rbuObjIterGetBindlist(p, pIter->nTblCol + 1 + bRbuRowid);
	if (zBind) {
		assert(pIter->pTmpInsert == 0);
		p->rc = prepareFreeAndCollectError(
			p->dbRbu, &pIter->pTmpInsert, &p->zErrmsg, sqlite3_mprintf(
				"INSERT INTO %s.'rbu_tmp_%q'(rbu_control,%s%s) VALUES(%z)",
				p->zStateDb, pIter->zDataTbl, zCollist, zRbuRowid, zBind
			));
	}
}

static void rbuTmpInsertFunc(
	sqlite3_context *pCtx,
	int nVal,
	sqlite3_value **apVal
) {
	sqlite3rbu *p = sqlite3_user_data(pCtx);
	int rc = SQLITE_OK;
	int i;

	assert(sqlite3_value_int(apVal[0]) != 0
		|| p->objiter.eType == RBU_PK_EXTERNAL
		|| p->objiter.eType == RBU_PK_NONE
	);
	if (sqlite3_value_int(apVal[0]) != 0) {
		p->nPhaseOneStep += p->objiter.nIndex;
	}

	for (i = 0; rc == SQLITE_OK && i<nVal; i++) {
		rc = sqlite3_bind_value(p->objiter.pTmpInsert, i + 1, apVal[i]);
	}
	if (rc == SQLITE_OK) {
		sqlite3_step(p->objiter.pTmpInsert);
		rc = sqlite3_reset(p->objiter.pTmpInsert);
	}

	if (rc != SQLITE_OK) {
		sqlite3_result_error_code(pCtx, rc);
	}
}


static int rbuObjIterPrepareAll(
	sqlite3rbu *p,
	RbuObjIter *pIter,
	int nOffset                     
) {
	assert(pIter->bCleanup == 0);
	if (pIter->pSelect == 0 && rbuObjIterCacheTableInfo(p, pIter) == SQLITE_OK) {
		const int tnum = pIter->iTnum;
		char *zCollist = 0;           
		char **pz = &p->zErrmsg;
		const char *zIdx = pIter->zIdx;
		char *zLimit = 0;

		if (nOffset) {
			zLimit = sqlite3_mprintf(" LIMIT -1 OFFSET %d", nOffset);
			if (!zLimit) p->rc = SQLITE_NOMEM;
		}

		if (zIdx) {
			const char *zTbl = pIter->zTbl;
			char *zImposterCols = 0;    
			char *zImposterPK = 0;      
			char *zWhere = 0;           
			char *zBind = 0;
			int nBind = 0;

			assert(pIter->eType != RBU_PK_VTAB);
			zCollist = rbuObjIterGetIndexCols(
				p, pIter, &zImposterCols, &zImposterPK, &zWhere, &nBind
			);
			zBind = rbuObjIterGetBindlist(p, nBind);

			
			sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 1);
			sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1, tnum);
			rbuMPrintfExec(p, p->dbMain,
				"CREATE TABLE \"rbu_imp_%w\"( %s, PRIMARY KEY( %s ) ) WITHOUT ROWID",
				zTbl, zImposterCols, zImposterPK
			);
			sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);

			
			pIter->nCol = nBind;
			if (p->rc == SQLITE_OK) {
				p->rc = prepareFreeAndCollectError(
					p->dbMain, &pIter->pInsert, &p->zErrmsg,
					sqlite3_mprintf("INSERT INTO \"rbu_imp_%w\" VALUES(%s)", zTbl, zBind)
				);
			}

			
			if (rbuIsVacuum(p) == 0 && p->rc == SQLITE_OK) {
				p->rc = prepareFreeAndCollectError(
					p->dbMain, &pIter->pDelete, &p->zErrmsg,
					sqlite3_mprintf("DELETE FROM \"rbu_imp_%w\" WHERE %s", zTbl, zWhere)
				);
			}

			
			if (p->rc == SQLITE_OK) {
				char *zSql;
				if (rbuIsVacuum(p)) {
					zSql = sqlite3_mprintf(
						"SELECT %s, 0 AS rbu_control FROM '%q' ORDER BY %s%s",
						zCollist,
						pIter->zDataTbl,
						zCollist, zLimit
					);
				}
				else

					if (pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_NONE) {
						zSql = sqlite3_mprintf(
							"SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' ORDER BY %s%s",
							zCollist, p->zStateDb, pIter->zDataTbl,
							zCollist, zLimit
						);
					}
					else {
						zSql = sqlite3_mprintf(
							"SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' "
							"UNION ALL "
							"SELECT %s, rbu_control FROM '%q' "
							"WHERE typeof(rbu_control)='integer' AND rbu_control!=1 "
							"ORDER BY %s%s",
							zCollist, p->zStateDb, pIter->zDataTbl,
							zCollist, pIter->zDataTbl,
							zCollist, zLimit
						);
					}
					p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz, zSql);
			}

			sqlite3_free(zImposterCols);
			sqlite3_free(zImposterPK);
			sqlite3_free(zWhere);
			sqlite3_free(zBind);
		}
		else {
			int bRbuRowid = (pIter->eType == RBU_PK_VTAB)
				|| (pIter->eType == RBU_PK_NONE)
				|| (pIter->eType == RBU_PK_EXTERNAL && rbuIsVacuum(p));
			const char *zTbl = pIter->zTbl;       
			const char *zWrite;                   

			char *zBindings = rbuObjIterGetBindlist(p, pIter->nTblCol + bRbuRowid);
			char *zWhere = rbuObjIterGetWhere(p, pIter);
			char *zOldlist = rbuObjIterGetOldlist(p, pIter, "old");
			char *zNewlist = rbuObjIterGetOldlist(p, pIter, "new");

			zCollist = rbuObjIterGetCollist(p, pIter);
			pIter->nCol = pIter->nTblCol;

			
			rbuCreateImposterTable(p, pIter);
			rbuCreateImposterTable2(p, pIter);
			zWrite = (pIter->eType == RBU_PK_VTAB ? "" : "rbu_imp_");

			
			if (p->rc == SQLITE_OK) {
				p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pInsert, pz,
					sqlite3_mprintf(
						"INSERT INTO \"%s%w\"(%s%s) VALUES(%s)",
						zWrite, zTbl, zCollist, (bRbuRowid ? ", _rowid_" : ""), zBindings
					)
				);
			}

			
			if (rbuIsVacuum(p) == 0 && p->rc == SQLITE_OK) {
				p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pDelete, pz,
					sqlite3_mprintf(
						"DELETE FROM \"%s%w\" WHERE %s", zWrite, zTbl, zWhere
					)
				);
			}

			if (rbuIsVacuum(p) == 0 && pIter->abIndexed) {
				const char *zRbuRowid = "";
				if (pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_NONE) {
					zRbuRowid = ", rbu_rowid";
				}

				
				rbuMPrintfExec(p, p->dbRbu,
					"CREATE TABLE IF NOT EXISTS %s.'rbu_tmp_%q' AS "
					"SELECT *%s FROM '%q' WHERE 0;"
					, p->zStateDb, pIter->zDataTbl
					, (pIter->eType == RBU_PK_EXTERNAL ? ", 0 AS rbu_rowid" : "")
					, pIter->zDataTbl
				);

				rbuMPrintfExec(p, p->dbMain,
					"CREATE TEMP TRIGGER rbu_delete_tr BEFORE DELETE ON \"%s%w\" "
					"BEGIN "
					"  SELECT rbu_tmp_insert(3, %s);"
					"END;"

					"CREATE TEMP TRIGGER rbu_update1_tr BEFORE UPDATE ON \"%s%w\" "
					"BEGIN "
					"  SELECT rbu_tmp_insert(3, %s);"
					"END;"

					"CREATE TEMP TRIGGER rbu_update2_tr AFTER UPDATE ON \"%s%w\" "
					"BEGIN "
					"  SELECT rbu_tmp_insert(4, %s);"
					"END;",
					zWrite, zTbl, zOldlist,
					zWrite, zTbl, zOldlist,
					zWrite, zTbl, zNewlist
				);

				if (pIter->eType == RBU_PK_EXTERNAL || pIter->eType == RBU_PK_NONE) {
					rbuMPrintfExec(p, p->dbMain,
						"CREATE TEMP TRIGGER rbu_insert_tr AFTER INSERT ON \"%s%w\" "
						"BEGIN "
						"  SELECT rbu_tmp_insert(0, %s);"
						"END;",
						zWrite, zTbl, zNewlist
					);
				}

				rbuObjIterPrepareTmpInsert(p, pIter, zCollist, zRbuRowid);
			}

			
			if (p->rc == SQLITE_OK) {
				const char *zRbuRowid = "";
				if (bRbuRowid) {
					zRbuRowid = rbuIsVacuum(p) ? ",_rowid_ " : ",rbu_rowid";
				}
				p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
					sqlite3_mprintf(
						"SELECT %s,%s rbu_control%s FROM '%q'%s",
						zCollist,
						(rbuIsVacuum(p) ? "0 AS " : ""),
						zRbuRowid,
						pIter->zDataTbl, zLimit
					)
				);
			}

			sqlite3_free(zWhere);
			sqlite3_free(zOldlist);
			sqlite3_free(zNewlist);
			sqlite3_free(zBindings);
		}
		sqlite3_free(zCollist);
		sqlite3_free(zLimit);
	}

	return p->rc;
}


static int rbuGetUpdateStmt(
	sqlite3rbu *p,                  
	RbuObjIter *pIter,              
	const char *zMask,              
	sqlite3_stmt **ppStmt           
) {
	RbuUpdateStmt **pp;
	RbuUpdateStmt *pUp = 0;
	int nUp = 0;

	
	*ppStmt = 0;

	
	for (pp = &pIter->pRbuUpdate; *pp; pp = &((*pp)->pNext)) {
		pUp = *pp;
		if (strcmp(pUp->zMask, zMask) == 0) {
			*pp = pUp->pNext;
			pUp->pNext = pIter->pRbuUpdate;
			pIter->pRbuUpdate = pUp;
			*ppStmt = pUp->pUpdate;
			return SQLITE_OK;
		}
		nUp++;
	}
	assert(pUp == 0 || pUp->pNext == 0);

	if (nUp >= SQLITE_RBU_UPDATE_CACHESIZE) {
		for (pp = &pIter->pRbuUpdate; *pp != pUp; pp = &((*pp)->pNext));
		*pp = 0;
		sqlite3_finalize(pUp->pUpdate);
		pUp->pUpdate = 0;
	}
	else {
		pUp = (RbuUpdateStmt*)rbuMalloc(p, sizeof(RbuUpdateStmt) + pIter->nTblCol + 1);
	}

	if (pUp) {
		char *zWhere = rbuObjIterGetWhere(p, pIter);
		char *zSet = rbuObjIterGetSetlist(p, pIter, zMask);
		char *zUpdate = 0;

		pUp->zMask = (char*)&pUp[1];
		memcpy(pUp->zMask, zMask, pIter->nTblCol);
		pUp->pNext = pIter->pRbuUpdate;
		pIter->pRbuUpdate = pUp;

		if (zSet) {
			const char *zPrefix = "";

			if (pIter->eType != RBU_PK_VTAB) zPrefix = "rbu_imp_";
			zUpdate = sqlite3_mprintf("UPDATE \"%s%w\" SET %s WHERE %s",
				zPrefix, pIter->zTbl, zSet, zWhere
			);
			p->rc = prepareFreeAndCollectError(
				p->dbMain, &pUp->pUpdate, &p->zErrmsg, zUpdate
			);
			*ppStmt = pUp->pUpdate;
		}
		sqlite3_free(zWhere);
		sqlite3_free(zSet);
	}

	return p->rc;
}

static sqlite3 *rbuOpenDbhandle(
	sqlite3rbu *p,
	const char *zName,
	int bUseVfs
) {
	sqlite3 *db = 0;
	if (p->rc == SQLITE_OK) {
		const int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_URI;
		p->rc = sqlite3_open_v2(zName, &db, flags, bUseVfs ? p->zVfsName : 0);
		if (p->rc) {
			p->zErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));
			sqlite3_close(db);
			db = 0;
		}
	}
	return db;
}


static void rbuFreeState(RbuState *p) {
	if (p) {
		sqlite3_free(p->zTbl);
		sqlite3_free(p->zIdx);
		sqlite3_free(p);
	}
}


static RbuState *rbuLoadState(sqlite3rbu *p) {
	RbuState *pRet = 0;
	sqlite3_stmt *pStmt = 0;
	int rc;
	int rc2;

	pRet = (RbuState*)rbuMalloc(p, sizeof(RbuState));
	if (pRet == 0) return 0;

	rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,
		sqlite3_mprintf("SELECT k, v FROM %s.rbu_state", p->zStateDb)
	);
	while (rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pStmt)) {
		switch (sqlite3_column_int(pStmt, 0)) {
		case RBU_STATE_STAGE:
			pRet->eStage = sqlite3_column_int(pStmt, 1);
			if (pRet->eStage != RBU_STAGE_OAL
				&& pRet->eStage != RBU_STAGE_MOVE
				&& pRet->eStage != RBU_STAGE_CKPT
				) {
				p->rc = SQLITE_CORRUPT;
			}
			break;

		case RBU_STATE_TBL:
			pRet->zTbl = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);
			break;

		case RBU_STATE_IDX:
			pRet->zIdx = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);
			break;

		case RBU_STATE_ROW:
			pRet->nRow = sqlite3_column_int(pStmt, 1);
			break;

		case RBU_STATE_PROGRESS:
			pRet->nProgress = sqlite3_column_int64(pStmt, 1);
			break;

		case RBU_STATE_CKPT:
			pRet->iWalCksum = sqlite3_column_int64(pStmt, 1);
			break;

		case RBU_STATE_COOKIE:
			pRet->iCookie = (u32)sqlite3_column_int64(pStmt, 1);
			break;

		case RBU_STATE_OALSZ:
			pRet->iOalSz = (u32)sqlite3_column_int64(pStmt, 1);
			break;

		case RBU_STATE_PHASEONESTEP:
			pRet->nPhaseOneStep = sqlite3_column_int64(pStmt, 1);
			break;

		default:
			rc = SQLITE_CORRUPT;
			break;
		}
	}
	rc2 = sqlite3_finalize(pStmt);
	if (rc == SQLITE_OK) rc = rc2;

	p->rc = rc;
	return pRet;
}



static void rbuOpenDatabase(sqlite3rbu *p) {
	assert(p->rc || (p->dbMain == 0 && p->dbRbu == 0));
	assert(p->rc || rbuIsVacuum(p) || p->zTarget != 0);

	
	p->dbRbu = rbuOpenDbhandle(p, p->zRbu, 1);

	if (p->rc == SQLITE_OK && rbuIsVacuum(p)) {
		sqlite3_file_control(p->dbRbu, "main", SQLITE_FCNTL_RBUCNT, (void*)p);
		if (p->zState == 0) {
			const char *zFile = sqlite3_db_filename(p->dbRbu, "main");
			p->zState = rbuMPrintf(p, "file://%s-vacuum?modeof=%s", zFile, zFile);
		}
	}

	
	if (p->zState) {
		rbuMPrintfExec(p, p->dbRbu, "ATTACH %Q AS stat", p->zState);
		memcpy(p->zStateDb, "stat", 4);
	}
	else {
		memcpy(p->zStateDb, "main", 4);
	}

#if 0
	if (p->rc == SQLITE_OK && rbuIsVacuum(p)) {
		p->rc = sqlite3_exec(p->dbRbu, "BEGIN", 0, 0, 0);
	}
#endif

	
	rbuMPrintfExec(p, p->dbRbu, RBU_CREATE_STATE, p->zStateDb);

#if 0
	if (rbuIsVacuum(p)) {
		if (p->rc == SQLITE_OK) {
			int rc2;
			int bOk = 0;
			sqlite3_stmt *pCnt = 0;
			p->rc = prepareAndCollectError(p->dbRbu, &pCnt, &p->zErrmsg,
				"SELECT count(*) FROM stat.sqlite_master"
			);
			if (p->rc == SQLITE_OK
				&& sqlite3_step(pCnt) == SQLITE_ROW
				&& 1 == sqlite3_column_int(pCnt, 0)
				) {
				bOk = 1;
			}
			rc2 = sqlite3_finalize(pCnt);
			if (p->rc == SQLITE_OK) p->rc = rc2;

			if (p->rc == SQLITE_OK && bOk == 0) {
				p->rc = SQLITE_ERROR;
				p->zErrmsg = sqlite3_mprintf("invalid state database");
			}

			if (p->rc == SQLITE_OK) {
				p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, 0);
			}
		}
	}
#endif

	if (p->rc == SQLITE_OK && rbuIsVacuum(p)) {
		int bOpen = 0;
		int rc;
		p->nRbu = 0;
		p->pRbuFd = 0;
		rc = sqlite3_file_control(p->dbRbu, "main", SQLITE_FCNTL_RBUCNT, (void*)p);
		if (rc != SQLITE_NOTFOUND) p->rc = rc;
		if (p->eStage >= RBU_STAGE_MOVE) {
			bOpen = 1;
		}
		else {
			RbuState *pState = rbuLoadState(p);
			if (pState) {
				bOpen = (pState->eStage>RBU_STAGE_MOVE);
				rbuFreeState(pState);
			}
		}
		if (bOpen) p->dbMain = rbuOpenDbhandle(p, p->zRbu, p->nRbu <= 1);
	}

	p->eStage = 0;
	if (p->rc == SQLITE_OK && p->dbMain == 0) {
		if (!rbuIsVacuum(p)) {
			p->dbMain = rbuOpenDbhandle(p, p->zTarget, 1);
		}
		else if (p->pRbuFd->pWalFd) {
			p->rc = SQLITE_ERROR;
			p->zErrmsg = sqlite3_mprintf("cannot vacuum wal mode database");
		}
		else {
			char *zTarget;
			char *zExtra = 0;
			if (strlen(p->zRbu) >= 5 && 0 == memcmp("file:", p->zRbu, 5)) {
				zExtra = &p->zRbu[5];
				while (*zExtra) {
					if (*zExtra++ == '?') break;
				}
				if (*zExtra == '\0') zExtra = 0;
			}

			zTarget = sqlite3_mprintf("file:%s-vacuum?rbu_memory=1%s%s",
				sqlite3_db_filename(p->dbRbu, "main"),
				(zExtra == 0 ? "" : "&"), (zExtra == 0 ? "" : zExtra)
			);

			if (zTarget == 0) {
				p->rc = SQLITE_NOMEM;
				return;
			}
			p->dbMain = rbuOpenDbhandle(p, zTarget, p->nRbu <= 1);
			sqlite3_free(zTarget);
		}
	}

	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_create_function(p->dbMain,
			"rbu_tmp_insert", -1, SQLITE_UTF8, (void*)p, rbuTmpInsertFunc, 0, 0
		);
	}

	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_create_function(p->dbMain,
			"rbu_fossil_delta", 2, SQLITE_UTF8, 0, rbuFossilDeltaFunc, 0, 0
		);
	}

	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_create_function(p->dbRbu,
			"rbu_target_name", -1, SQLITE_UTF8, (void*)p, rbuTargetNameFunc, 0, 0
		);
	}

	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_file_control(p->dbMain, "main", SQLITE_FCNTL_RBU, (void*)p);
	}
	rbuMPrintfExec(p, p->dbMain, "SELECT * FROM sqlite_master");

	
	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_file_control(p->dbMain, "main", SQLITE_FCNTL_RBU, (void*)p);
	}

	if (p->rc == SQLITE_NOTFOUND) {
		p->rc = SQLITE_ERROR;
		p->zErrmsg = sqlite3_mprintf("rbu vfs not found");
	}
}


static void rbuFileSuffix3(const char *zBase, char *z) {
#ifdef SQLITE_ENABLE_8_3_NAMES
#if SQLITE_ENABLE_8_3_NAMES<2
	if (sqlite3_uri_boolean(zBase, "8_3_names", 0))
#endif
	{
		int i, sz;
		sz = (int)strlen(z) & 0xffffff;
		for (i = sz - 1; i>0 && z[i] != '/' && z[i] != '.'; i--) {}
		if (z[i] == '.' && sz>i + 4) memmove(&z[i + 1], &z[sz - 3], 4);
	}
#endif
}


static i64 rbuShmChecksum(sqlite3rbu *p) {
	i64 iRet = 0;
	if (p->rc == SQLITE_OK) {
		sqlite3_file *pDb = p->pTargetFd->pReal;
		u32 volatile *ptr;
		p->rc = pDb->pMethods->xShmMap(pDb, 0, 32 * 1024, 0, (void volatile**)&ptr);
		if (p->rc == SQLITE_OK) {
			iRet = ((i64)ptr[10] << 32) + ptr[11];
		}
	}
	return iRet;
}


static void rbuSetupCheckpoint(sqlite3rbu *p, RbuState *pState) {

	
	if (pState == 0) {
		p->eStage = 0;
		if (p->rc == SQLITE_OK) {
			p->rc = sqlite3_exec(p->dbMain, "SELECT * FROM sqlite_master", 0, 0, 0);
		}
	}

	
	if (p->rc == SQLITE_OK) {
		int rc2;
		p->eStage = RBU_STAGE_CAPTURE;
		rc2 = sqlite3_exec(p->dbMain, "PRAGMA main.wal_checkpoint=restart", 0, 0, 0);
		if (rc2 != SQLITE_INTERNAL) p->rc = rc2;
	}

	if (p->rc == SQLITE_OK) {
		p->eStage = RBU_STAGE_CKPT;
		p->nStep = (pState ? pState->nRow : 0);
		p->aBuf = rbuMalloc(p, p->pgsz);
		p->iWalCksum = rbuShmChecksum(p);
	}

	if (p->rc == SQLITE_OK && pState && pState->iWalCksum != p->iWalCksum) {
		p->rc = SQLITE_DONE;
		p->eStage = RBU_STAGE_DONE;
	}
}


static int rbuCaptureWalRead(sqlite3rbu *pRbu, i64 iOff, int iAmt) {
	const u32 mReq = (1 << WAL_LOCK_WRITE) | (1 << WAL_LOCK_CKPT) | (1 << WAL_LOCK_READ0);
	u32 iFrame;

	if (pRbu->mLock != mReq) {
		pRbu->rc = SQLITE_BUSY;
		return SQLITE_INTERNAL;
	}

	pRbu->pgsz = iAmt;
	if (pRbu->nFrame == pRbu->nFrameAlloc) {
		int nNew = (pRbu->nFrameAlloc ? pRbu->nFrameAlloc : 64) * 2;
		RbuFrame *aNew;
		aNew = (RbuFrame*)sqlite3_realloc64(pRbu->aFrame, nNew * sizeof(RbuFrame));
		if (aNew == 0) return SQLITE_NOMEM;
		pRbu->aFrame = aNew;
		pRbu->nFrameAlloc = nNew;
	}

	iFrame = (u32)((iOff - 32) / (i64)(iAmt + 24)) + 1;
	if (pRbu->iMaxFrame<iFrame) pRbu->iMaxFrame = iFrame;
	pRbu->aFrame[pRbu->nFrame].iWalFrame = iFrame;
	pRbu->aFrame[pRbu->nFrame].iDbPage = 0;
	pRbu->nFrame++;
	return SQLITE_OK;
}


static int rbuCaptureDbWrite(sqlite3rbu *pRbu, i64 iOff) {
	pRbu->aFrame[pRbu->nFrame - 1].iDbPage = (u32)(iOff / pRbu->pgsz) + 1;
	return SQLITE_OK;
}


static void rbuCheckpointFrame(sqlite3rbu *p, RbuFrame *pFrame) {
	sqlite3_file *pWal = p->pTargetFd->pWalFd->pReal;
	sqlite3_file *pDb = p->pTargetFd->pReal;
	i64 iOff;

	assert(p->rc == SQLITE_OK);
	iOff = (i64)(pFrame->iWalFrame - 1) * (p->pgsz + 24) + 32 + 24;
	p->rc = pWal->pMethods->xRead(pWal, p->aBuf, p->pgsz, iOff);
	if (p->rc) return;

	iOff = (i64)(pFrame->iDbPage - 1) * p->pgsz;
	p->rc = pDb->pMethods->xWrite(pDb, p->aBuf, p->pgsz, iOff);
}



static void rbuLockDatabase(sqlite3rbu *p) {
	sqlite3_file *pReal = p->pTargetFd->pReal;
	assert(p->rc == SQLITE_OK);
	p->rc = pReal->pMethods->xLock(pReal, SQLITE_LOCK_SHARED);
	if (p->rc == SQLITE_OK) {
		p->rc = pReal->pMethods->xLock(pReal, SQLITE_LOCK_EXCLUSIVE);
	}
}

#if defined(_WIN32_WCE)
static LPWSTR rbuWinUtf8ToUnicode(const char *zFilename) {
	int nChar;
	LPWSTR zWideFilename;

	nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);
	if (nChar == 0) {
		return 0;
	}
	zWideFilename = sqlite3_malloc64(nChar * sizeof(zWideFilename[0]));
	if (zWideFilename == 0) {
		return 0;
	}
	memset(zWideFilename, 0, nChar * sizeof(zWideFilename[0]));
	nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,
		nChar);
	if (nChar == 0) {
		sqlite3_free(zWideFilename);
		zWideFilename = 0;
	}
	return zWideFilename;
}
#endif


static void rbuMoveOalFile(sqlite3rbu *p) {
	const char *zBase = sqlite3_db_filename(p->dbMain, "main");
	const char *zMove = zBase;
	char *zOal;
	char *zWal;

	if (rbuIsVacuum(p)) {
		zMove = sqlite3_db_filename(p->dbRbu, "main");
	}
	zOal = sqlite3_mprintf("%s-oal", zMove);
	zWal = sqlite3_mprintf("%s-wal", zMove);

	assert(p->eStage == RBU_STAGE_MOVE);
	assert(p->rc == SQLITE_OK && p->zErrmsg == 0);
	if (zWal == 0 || zOal == 0) {
		p->rc = SQLITE_NOMEM;
	}
	else {
		
		rbuLockDatabase(p);
		if (p->rc == SQLITE_OK) {
			rbuFileSuffix3(zBase, zWal);
			rbuFileSuffix3(zBase, zOal);

			
			rbuObjIterFinalize(&p->objiter);
			sqlite3_close(p->dbRbu);
			sqlite3_close(p->dbMain);
			p->dbMain = 0;
			p->dbRbu = 0;

#if defined(_WIN32_WCE)
			{
				LPWSTR zWideOal;
				LPWSTR zWideWal;

				zWideOal = rbuWinUtf8ToUnicode(zOal);
				if (zWideOal) {
					zWideWal = rbuWinUtf8ToUnicode(zWal);
					if (zWideWal) {
						if (MoveFileW(zWideOal, zWideWal)) {
							p->rc = SQLITE_OK;
						}
						else {
							p->rc = SQLITE_IOERR;
						}
						sqlite3_free(zWideWal);
					}
					else {
						p->rc = SQLITE_IOERR_NOMEM;
					}
					sqlite3_free(zWideOal);
				}
				else {
					p->rc = SQLITE_IOERR_NOMEM;
				}
			}
#else
			p->rc = rename(zOal, zWal) ? SQLITE_IOERR : SQLITE_OK;
#endif

			if (p->rc == SQLITE_OK) {
				rbuOpenDatabase(p);
				rbuSetupCheckpoint(p, 0);
			}
		}
	}

	sqlite3_free(zWal);
	sqlite3_free(zOal);
}


static int rbuStepType(sqlite3rbu *p, const char **pzMask) {
	int iCol = p->objiter.nCol;     
	int res = 0;                    

	switch (sqlite3_column_type(p->objiter.pSelect, iCol)) {
	case SQLITE_INTEGER: {
		int iVal = sqlite3_column_int(p->objiter.pSelect, iCol);
		switch (iVal) {
		case 0: res = RBU_INSERT;     break;
		case 1: res = RBU_DELETE;     break;
		case 2: res = RBU_REPLACE;    break;
		case 3: res = RBU_IDX_DELETE; break;
		case 4: res = RBU_IDX_INSERT; break;
		}
		break;
	}

	case SQLITE_TEXT: {
		const unsigned char *z = sqlite3_column_text(p->objiter.pSelect, iCol);
		if (z == 0) {
			p->rc = SQLITE_NOMEM;
		}
		else {
			*pzMask = (const char*)z;
		}
		res = RBU_UPDATE;

		break;
	}

	default:
		break;
	}

	if (res == 0) {
		rbuBadControlError(p);
	}
	return res;
}

#ifdef SQLITE_DEBUG

static void assertColumnName(sqlite3_stmt *pStmt, int iCol, const char *zName) {
	const char *zCol = sqlite3_column_name(pStmt, iCol);
	assert(0 == sqlite3_stricmp(zName, zCol));
}
#else
# define assertColumnName(x,y,z)
#endif


static void rbuStepOneOp(sqlite3rbu *p, int eType) {
	RbuObjIter *pIter = &p->objiter;
	sqlite3_value *pVal;
	sqlite3_stmt *pWriter;
	int i;

	assert(p->rc == SQLITE_OK);
	assert(eType != RBU_DELETE || pIter->zIdx == 0);
	assert(eType == RBU_DELETE || eType == RBU_IDX_DELETE
		|| eType == RBU_INSERT || eType == RBU_IDX_INSERT
	);

	
	if (eType == RBU_DELETE) {
		p->nPhaseOneStep -= p->objiter.nIndex;
	}

	if (eType == RBU_IDX_DELETE || eType == RBU_DELETE) {
		pWriter = pIter->pDelete;
	}
	else {
		pWriter = pIter->pInsert;
	}

	for (i = 0; i<pIter->nCol; i++) {
		
		if (eType == RBU_INSERT
			&& pIter->zIdx == 0 && pIter->eType == RBU_PK_IPK && pIter->abTblPk[i]
			&& sqlite3_column_type(pIter->pSelect, i) == SQLITE_NULL
			) {
			p->rc = SQLITE_MISMATCH;
			p->zErrmsg = sqlite3_mprintf("datatype mismatch");
			return;
		}

		if (eType == RBU_DELETE && pIter->abTblPk[i] == 0) {
			continue;
		}

		pVal = sqlite3_column_value(pIter->pSelect, i);
		p->rc = sqlite3_bind_value(pWriter, i + 1, pVal);
		if (p->rc) return;
	}
	if (pIter->zIdx == 0) {
		if (pIter->eType == RBU_PK_VTAB
			|| pIter->eType == RBU_PK_NONE
			|| (pIter->eType == RBU_PK_EXTERNAL && rbuIsVacuum(p))
			) {
			
			assertColumnName(pIter->pSelect, pIter->nCol + 1,
				rbuIsVacuum(p) ? "rowid" : "rbu_rowid"
			);
			pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol + 1);
			p->rc = sqlite3_bind_value(pWriter, pIter->nCol + 1, pVal);
		}
	}
	if (p->rc == SQLITE_OK) {
		sqlite3_step(pWriter);
		p->rc = resetAndCollectError(pWriter, &p->zErrmsg);
	}
}


static int rbuStep(sqlite3rbu *p) {
	RbuObjIter *pIter = &p->objiter;
	const char *zMask = 0;
	int eType = rbuStepType(p, &zMask);

	if (eType) {
		assert(eType == RBU_INSERT || eType == RBU_DELETE
			|| eType == RBU_REPLACE || eType == RBU_IDX_DELETE
			|| eType == RBU_IDX_INSERT || eType == RBU_UPDATE
		);
		assert(eType != RBU_UPDATE || pIter->zIdx == 0);

		if (pIter->zIdx == 0 && (eType == RBU_IDX_DELETE || eType == RBU_IDX_INSERT)) {
			rbuBadControlError(p);
		}
		else if (eType == RBU_REPLACE) {
			if (pIter->zIdx == 0) {
				p->nPhaseOneStep += p->objiter.nIndex;
				rbuStepOneOp(p, RBU_DELETE);
			}
			if (p->rc == SQLITE_OK) rbuStepOneOp(p, RBU_INSERT);
		}
		else if (eType != RBU_UPDATE) {
			rbuStepOneOp(p, eType);
		}
		else {
			sqlite3_value *pVal;
			sqlite3_stmt *pUpdate = 0;
			assert(eType == RBU_UPDATE);
			p->nPhaseOneStep -= p->objiter.nIndex;
			rbuGetUpdateStmt(p, pIter, zMask, &pUpdate);
			if (pUpdate) {
				int i;
				for (i = 0; p->rc == SQLITE_OK && i<pIter->nCol; i++) {
					char c = zMask[pIter->aiSrcOrder[i]];
					pVal = sqlite3_column_value(pIter->pSelect, i);
					if (pIter->abTblPk[i] || c != '.') {
						p->rc = sqlite3_bind_value(pUpdate, i + 1, pVal);
					}
				}
				if (p->rc == SQLITE_OK
					&& (pIter->eType == RBU_PK_VTAB || pIter->eType == RBU_PK_NONE)
					) {
					
					assertColumnName(pIter->pSelect, pIter->nCol + 1, "rbu_rowid");
					pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol + 1);
					p->rc = sqlite3_bind_value(pUpdate, pIter->nCol + 1, pVal);
				}
				if (p->rc == SQLITE_OK) {
					sqlite3_step(pUpdate);
					p->rc = resetAndCollectError(pUpdate, &p->zErrmsg);
				}
			}
		}
	}
	return p->rc;
}


static void rbuIncrSchemaCookie(sqlite3rbu *p) {
	if (p->rc == SQLITE_OK) {
		sqlite3 *dbread = (rbuIsVacuum(p) ? p->dbRbu : p->dbMain);
		int iCookie = 1000000;
		sqlite3_stmt *pStmt;

		p->rc = prepareAndCollectError(dbread, &pStmt, &p->zErrmsg,
			"PRAGMA schema_version"
		);
		if (p->rc == SQLITE_OK) {
			
			if (SQLITE_ROW == sqlite3_step(pStmt)) {
				iCookie = sqlite3_column_int(pStmt, 0);
			}
			rbuFinalize(p, pStmt);
		}
		if (p->rc == SQLITE_OK) {
			rbuMPrintfExec(p, p->dbMain, "PRAGMA schema_version = %d", iCookie + 1);
		}
	}
}


static void rbuSaveState(sqlite3rbu *p, int eStage) {
	if (p->rc == SQLITE_OK || p->rc == SQLITE_DONE) {
		sqlite3_stmt *pInsert = 0;
		rbu_file *pFd = (rbuIsVacuum(p) ? p->pRbuFd : p->pTargetFd);
		int rc;

		assert(p->zErrmsg == 0);
		rc = prepareFreeAndCollectError(p->dbRbu, &pInsert, &p->zErrmsg,
			sqlite3_mprintf(
				"INSERT OR REPLACE INTO %s.rbu_state(k, v) VALUES "
				"(%d, %d), "
				"(%d, %Q), "
				"(%d, %Q), "
				"(%d, %d), "
				"(%d, %d), "
				"(%d, %lld), "
				"(%d, %lld), "
				"(%d, %lld), "
				"(%d, %lld) ",
				p->zStateDb,
				RBU_STATE_STAGE, eStage,
				RBU_STATE_TBL, p->objiter.zTbl,
				RBU_STATE_IDX, p->objiter.zIdx,
				RBU_STATE_ROW, p->nStep,
				RBU_STATE_PROGRESS, p->nProgress,
				RBU_STATE_CKPT, p->iWalCksum,
				RBU_STATE_COOKIE, (i64)pFd->iCookie,
				RBU_STATE_OALSZ, p->iOalSz,
				RBU_STATE_PHASEONESTEP, p->nPhaseOneStep
			)
		);
		assert(pInsert == 0 || rc == SQLITE_OK);

		if (rc == SQLITE_OK) {
			sqlite3_step(pInsert);
			rc = sqlite3_finalize(pInsert);
		}
		if (rc != SQLITE_OK) p->rc = rc;
	}
}



static void rbuCopyPragma(sqlite3rbu *p, const char *zPragma) {
	if (p->rc == SQLITE_OK) {
		sqlite3_stmt *pPragma = 0;
		p->rc = prepareFreeAndCollectError(p->dbRbu, &pPragma, &p->zErrmsg,
			sqlite3_mprintf("PRAGMA main.%s", zPragma)
		);
		if (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pPragma)) {
			p->rc = rbuMPrintfExec(p, p->dbMain, "PRAGMA main.%s = %d",
				zPragma, sqlite3_column_int(pPragma, 0)
			);
		}
		rbuFinalize(p, pPragma);
	}
}


static void rbuCreateTargetSchema(sqlite3rbu *p) {
	sqlite3_stmt *pSql = 0;
	sqlite3_stmt *pInsert = 0;

	assert(rbuIsVacuum(p));
	p->rc = sqlite3_exec(p->dbMain, "PRAGMA writable_schema=1", 0, 0, &p->zErrmsg);
	if (p->rc == SQLITE_OK) {
		p->rc = prepareAndCollectError(p->dbRbu, &pSql, &p->zErrmsg,
			"SELECT sql FROM sqlite_master WHERE sql!='' AND rootpage!=0"
			" AND name!='sqlite_sequence' "
			" ORDER BY type DESC"
		);
	}

	while (p->rc == SQLITE_OK && sqlite3_step(pSql) == SQLITE_ROW) {
		const char *zSql = (const char*)sqlite3_column_text(pSql, 0);
		p->rc = sqlite3_exec(p->dbMain, zSql, 0, 0, &p->zErrmsg);
	}
	rbuFinalize(p, pSql);
	if (p->rc != SQLITE_OK) return;

	if (p->rc == SQLITE_OK) {
		p->rc = prepareAndCollectError(p->dbRbu, &pSql, &p->zErrmsg,
			"SELECT * FROM sqlite_master WHERE rootpage=0 OR rootpage IS NULL"
		);
	}

	if (p->rc == SQLITE_OK) {
		p->rc = prepareAndCollectError(p->dbMain, &pInsert, &p->zErrmsg,
			"INSERT INTO sqlite_master VALUES(?,?,?,?,?)"
		);
	}

	while (p->rc == SQLITE_OK && sqlite3_step(pSql) == SQLITE_ROW) {
		int i;
		for (i = 0; i<5; i++) {
			sqlite3_bind_value(pInsert, i + 1, sqlite3_column_value(pSql, i));
		}
		sqlite3_step(pInsert);
		p->rc = sqlite3_reset(pInsert);
	}
	if (p->rc == SQLITE_OK) {
		p->rc = sqlite3_exec(p->dbMain, "PRAGMA writable_schema=0", 0, 0, &p->zErrmsg);
	}

	rbuFinalize(p, pSql);
	rbuFinalize(p, pInsert);
}


SQLITE_API int sqlite3rbu_step(sqlite3rbu *p) {
	if (p) {
		switch (p->eStage) {
		case RBU_STAGE_OAL: {
			RbuObjIter *pIter = &p->objiter;

			
			if (rbuIsVacuum(p) && p->nProgress == 0 && p->rc == SQLITE_OK) {
				rbuCreateTargetSchema(p);
				rbuCopyPragma(p, "user_version");
				rbuCopyPragma(p, "application_id");
			}

			while (p->rc == SQLITE_OK && pIter->zTbl) {

				if (pIter->bCleanup) {
					
					if (rbuIsVacuum(p) == 0 && pIter->abIndexed) {
						rbuMPrintfExec(p, p->dbRbu,
							"DELETE FROM %s.'rbu_tmp_%q'", p->zStateDb, pIter->zDataTbl
						);
					}
				}
				else {
					rbuObjIterPrepareAll(p, pIter, 0);

					
					if (p->rc == SQLITE_OK) {
						int rc = sqlite3_step(pIter->pSelect);
						if (rc == SQLITE_ROW) {
							p->nProgress++;
							p->nStep++;
							return rbuStep(p);
						}
						p->rc = sqlite3_reset(pIter->pSelect);
						p->nStep = 0;
					}
				}

				rbuObjIterNext(p, pIter);
			}

			if (p->rc == SQLITE_OK) {
				assert(pIter->zTbl == 0);
				rbuSaveState(p, RBU_STAGE_MOVE);
				rbuIncrSchemaCookie(p);
				if (p->rc == SQLITE_OK) {
					p->rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, &p->zErrmsg);
				}
				if (p->rc == SQLITE_OK) {
					p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, &p->zErrmsg);
				}
				p->eStage = RBU_STAGE_MOVE;
			}
			break;
		}

		case RBU_STAGE_MOVE: {
			if (p->rc == SQLITE_OK) {
				rbuMoveOalFile(p);
				p->nProgress++;
			}
			break;
		}

		case RBU_STAGE_CKPT: {
			if (p->rc == SQLITE_OK) {
				if (p->nStep >= p->nFrame) {
					sqlite3_file *pDb = p->pTargetFd->pReal;

					
					p->rc = pDb->pMethods->xSync(pDb, SQLITE_SYNC_NORMAL);

					
					if (p->rc == SQLITE_OK) {
						void volatile *ptr;
						p->rc = pDb->pMethods->xShmMap(pDb, 0, 32 * 1024, 0, &ptr);
						if (p->rc == SQLITE_OK) {
							((u32 volatile*)ptr)[24] = p->iMaxFrame;
						}
					}

					if (p->rc == SQLITE_OK) {
						p->eStage = RBU_STAGE_DONE;
						p->rc = SQLITE_DONE;
					}
				}
				else {
					RbuFrame *pFrame = &p->aFrame[p->nStep];
					rbuCheckpointFrame(p, pFrame);
					p->nStep++;
				}
				p->nProgress++;
			}
			break;
		}

		default:
			break;
		}
		return p->rc;
	}
	else {
		return SQLITE_NOMEM;
	}
}


static int rbuStrCompare(const char *z1, const char *z2) {
	if (z1 == 0 && z2 == 0) return 0;
	if (z1 == 0 || z2 == 0) return 1;
	return (sqlite3_stricmp(z1, z2) != 0);
}


static void rbuSetupOal(sqlite3rbu *p, RbuState *pState) {
	assert(p->rc == SQLITE_OK);
	if (pState->zTbl) {
		RbuObjIter *pIter = &p->objiter;
		int rc = SQLITE_OK;

		while (rc == SQLITE_OK && pIter->zTbl && (pIter->bCleanup
			|| rbuStrCompare(pIter->zIdx, pState->zIdx)
			|| rbuStrCompare(pIter->zTbl, pState->zTbl)
			)) {
			rc = rbuObjIterNext(p, pIter);
		}

		if (rc == SQLITE_OK && !pIter->zTbl) {
			rc = SQLITE_ERROR;
			p->zErrmsg = sqlite3_mprintf("rbu_state mismatch error");
		}

		if (rc == SQLITE_OK) {
			p->nStep = pState->nRow;
			rc = rbuObjIterPrepareAll(p, &p->objiter, p->nStep);
		}

		p->rc = rc;
	}
}


static void rbuDeleteOalFile(sqlite3rbu *p) {
	char *zOal = rbuMPrintf(p, "%s-oal", p->zTarget);
	if (zOal) {
		sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
		assert(pVfs && p->rc == SQLITE_OK && p->zErrmsg == 0);
		pVfs->xDelete(pVfs, zOal, 0);
		sqlite3_free(zOal);
	}
}


static void rbuCreateVfs(sqlite3rbu *p) {
	int rnd;
	char zRnd[64];

	assert(p->rc == SQLITE_OK);
	sqlite3_randomness(sizeof(int), (void*)&rnd);
	sqlite3_snprintf(sizeof(zRnd), zRnd, "rbu_vfs_%d", rnd);
	p->rc = sqlite3rbu_create_vfs(zRnd, 0);
	if (p->rc == SQLITE_OK) {
		sqlite3_vfs *pVfs = sqlite3_vfs_find(zRnd);
		assert(pVfs);
		p->zVfsName = pVfs->zName;
	}
}


static void rbuDeleteVfs(sqlite3rbu *p) {
	if (p->zVfsName) {
		sqlite3rbu_destroy_vfs(p->zVfsName);
		p->zVfsName = 0;
	}
}


static void rbuIndexCntFunc(
	sqlite3_context *pCtx,
	int nVal,
	sqlite3_value **apVal
) {
	sqlite3rbu *p = (sqlite3rbu*)sqlite3_user_data(pCtx);
	sqlite3_stmt *pStmt = 0;
	char *zErrmsg = 0;
	int rc;

	assert(nVal == 1);

	rc = prepareFreeAndCollectError(p->dbMain, &pStmt, &zErrmsg,
		sqlite3_mprintf("SELECT count(*) FROM sqlite_master "
			"WHERE type='index' AND tbl_name = %Q", sqlite3_value_text(apVal[0]))
	);
	if (rc != SQLITE_OK) {
		sqlite3_result_error(pCtx, zErrmsg, -1);
	}
	else {
		int nIndex = 0;
		if (SQLITE_ROW == sqlite3_step(pStmt)) {
			nIndex = sqlite3_column_int(pStmt, 0);
		}
		rc = sqlite3_finalize(pStmt);
		if (rc == SQLITE_OK) {
			sqlite3_result_int(pCtx, nIndex);
		}
		else {
			sqlite3_result_error(pCtx, sqlite3_errmsg(p->dbMain), -1);
		}
	}

	sqlite3_free(zErrmsg);
}


static void rbuInitPhaseOneSteps(sqlite3rbu *p) {
	if (p->rc == SQLITE_OK) {
		sqlite3_stmt *pStmt = 0;
		int bExists = 0;                

		p->nPhaseOneStep = -1;

		p->rc = sqlite3_create_function(p->dbRbu,
			"rbu_index_cnt", 1, SQLITE_UTF8, (void*)p, rbuIndexCntFunc, 0, 0
		);

		
		if (p->rc == SQLITE_OK) {
			p->rc = prepareAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,
				"SELECT 1 FROM sqlite_master WHERE tbl_name = 'rbu_count'"
			);
		}
		if (p->rc == SQLITE_OK) {
			if (SQLITE_ROW == sqlite3_step(pStmt)) {
				bExists = 1;
			}
			p->rc = sqlite3_finalize(pStmt);
		}

		if (p->rc == SQLITE_OK && bExists) {
			p->rc = prepareAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,
				"SELECT sum(cnt * (1 + rbu_index_cnt(rbu_target_name(tbl))))"
				"FROM rbu_count"
			);
			if (p->rc == SQLITE_OK) {
				if (SQLITE_ROW == sqlite3_step(pStmt)) {
					p->nPhaseOneStep = sqlite3_column_int64(pStmt, 0);
				}
				p->rc = sqlite3_finalize(pStmt);
			}
		}
	}
}


static sqlite3rbu *openRbuHandle(
	const char *zTarget,
	const char *zRbu,
	const char *zState
) {
	sqlite3rbu *p;
	size_t nTarget = zTarget ? strlen(zTarget) : 0;
	size_t nRbu = strlen(zRbu);
	size_t nByte = sizeof(sqlite3rbu) + nTarget + 1 + nRbu + 1;

	p = (sqlite3rbu*)sqlite3_malloc64(nByte);
	if (p) {
		RbuState *pState = 0;

		
		memset(p, 0, sizeof(sqlite3rbu));
		rbuCreateVfs(p);

		
		if (p->rc == SQLITE_OK) {
			char *pCsr = (char*)&p[1];
			if (zTarget) {
				p->zTarget = pCsr;
				memcpy(p->zTarget, zTarget, nTarget + 1);
				pCsr += nTarget + 1;
			}
			p->zRbu = pCsr;
			memcpy(p->zRbu, zRbu, nRbu + 1);
			pCsr += nRbu + 1;
			if (zState) {
				p->zState = rbuMPrintf(p, "%s", zState);
			}
			rbuOpenDatabase(p);
		}

		if (p->rc == SQLITE_OK) {
			pState = rbuLoadState(p);
			assert(pState || p->rc != SQLITE_OK);
			if (p->rc == SQLITE_OK) {

				if (pState->eStage == 0) {
					rbuDeleteOalFile(p);
					rbuInitPhaseOneSteps(p);
					p->eStage = RBU_STAGE_OAL;
				}
				else {
					p->eStage = pState->eStage;
					p->nPhaseOneStep = pState->nPhaseOneStep;
				}
				p->nProgress = pState->nProgress;
				p->iOalSz = pState->iOalSz;
			}
		}
		assert(p->rc != SQLITE_OK || p->eStage != 0);

		if (p->rc == SQLITE_OK && p->pTargetFd->pWalFd) {
			if (p->eStage == RBU_STAGE_OAL) {
				p->rc = SQLITE_ERROR;
				p->zErrmsg = sqlite3_mprintf("cannot update wal mode database");
			}
			else if (p->eStage == RBU_STAGE_MOVE) {
				p->eStage = RBU_STAGE_CKPT;
				p->nStep = 0;
			}
		}

		if (p->rc == SQLITE_OK
			&& (p->eStage == RBU_STAGE_OAL || p->eStage == RBU_STAGE_MOVE)
			&& pState->eStage != 0
			) {
			rbu_file *pFd = (rbuIsVacuum(p) ? p->pRbuFd : p->pTargetFd);
			if (pFd->iCookie != pState->iCookie) {
				
				p->rc = SQLITE_BUSY;
				p->zErrmsg = sqlite3_mprintf("database modified during rbu %s",
					(rbuIsVacuum(p) ? "vacuum" : "update")
				);
			}
		}

		if (p->rc == SQLITE_OK) {
			if (p->eStage == RBU_STAGE_OAL) {
				sqlite3 *db = p->dbMain;
				p->rc = sqlite3_exec(p->dbRbu, "BEGIN", 0, 0, &p->zErrmsg);

				
				if (p->rc == SQLITE_OK) {
					p->rc = rbuObjIterFirst(p, &p->objiter);
				}

				
				if (p->rc == SQLITE_OK && p->objiter.zTbl == 0) {
					p->rc = SQLITE_DONE;
					p->eStage = RBU_STAGE_DONE;
				}
				else {
					if (p->rc == SQLITE_OK && pState->eStage == 0 && rbuIsVacuum(p)) {
						rbuCopyPragma(p, "page_size");
						rbuCopyPragma(p, "auto_vacuum");
					}

					
					if (p->rc == SQLITE_OK) {
						p->rc = sqlite3_exec(db, "BEGIN IMMEDIATE", 0, 0, &p->zErrmsg);
					}

					
					if (p->rc == SQLITE_OK) {
						int frc = sqlite3_file_control(db, "main", SQLITE_FCNTL_ZIPVFS, 0);
						if (frc == SQLITE_OK) {
							p->rc = sqlite3_exec(
								db, "PRAGMA journal_mode=off", 0, 0, &p->zErrmsg);
						}
					}

					if (p->rc == SQLITE_OK) {
						rbuSetupOal(p, pState);
					}
				}
			}
			else if (p->eStage == RBU_STAGE_MOVE) {
				
			}
			else if (p->eStage == RBU_STAGE_CKPT) {
				rbuSetupCheckpoint(p, pState);
			}
			else if (p->eStage == RBU_STAGE_DONE) {
				p->rc = SQLITE_DONE;
			}
			else {
				p->rc = SQLITE_CORRUPT;
			}
		}

		rbuFreeState(pState);
	}

	return p;
}


static sqlite3rbu *rbuMisuseError(void) {
	sqlite3rbu *pRet;
	pRet = sqlite3_malloc64(sizeof(sqlite3rbu));
	if (pRet) {
		memset(pRet, 0, sizeof(sqlite3rbu));
		pRet->rc = SQLITE_MISUSE;
	}
	return pRet;
}


SQLITE_API sqlite3rbu *sqlite3rbu_open(
	const char *zTarget,
	const char *zRbu,
	const char *zState
) {
	if (zTarget == 0 || zRbu == 0) { return rbuMisuseError(); }
	
	return openRbuHandle(zTarget, zRbu, zState);
}


SQLITE_API sqlite3rbu *sqlite3rbu_vacuum(
	const char *zTarget,
	const char *zState
) {
	if (zTarget == 0) { return rbuMisuseError(); }
	
	return openRbuHandle(0, zTarget, zState);
}


SQLITE_API sqlite3 *sqlite3rbu_db(sqlite3rbu *pRbu, int bRbu) {
	sqlite3 *db = 0;
	if (pRbu) {
		db = (bRbu ? pRbu->dbRbu : pRbu->dbMain);
	}
	return db;
}



static void rbuEditErrmsg(sqlite3rbu *p) {
	if (p->rc == SQLITE_CONSTRAINT && p->zErrmsg) {
		unsigned int i;
		size_t nErrmsg = strlen(p->zErrmsg);
		for (i = 0; i<(nErrmsg - 8); i++) {
			if (memcmp(&p->zErrmsg[i], "rbu_imp_", 8) == 0) {
				int nDel = 8;
				while (p->zErrmsg[i + nDel] >= '0' && p->zErrmsg[i + nDel] <= '9') nDel++;
				memmove(&p->zErrmsg[i], &p->zErrmsg[i + nDel], nErrmsg + 1 - i - nDel);
				nErrmsg -= nDel;
			}
		}
	}
}


SQLITE_API int sqlite3rbu_close(sqlite3rbu *p, char **pzErrmsg) {
	int rc;
	if (p) {

		
		if (p->rc == SQLITE_OK && p->eStage == RBU_STAGE_OAL) {
			p->rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, &p->zErrmsg);
		}

		rbuSaveState(p, p->eStage);

		if (p->rc == SQLITE_OK && p->eStage == RBU_STAGE_OAL) {
			p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, &p->zErrmsg);
		}

		
		rbuObjIterFinalize(&p->objiter);

		
		if (rbuIsVacuum(p) && p->rc != SQLITE_OK && p->dbRbu) {
			int rc2 = sqlite3_exec(p->dbRbu, "DELETE FROM stat.rbu_state", 0, 0, 0);
			if (p->rc == SQLITE_DONE && rc2 != SQLITE_OK) p->rc = rc2;
		}

		
		sqlite3_close(p->dbRbu);
		sqlite3_close(p->dbMain);
		rbuDeleteVfs(p);
		sqlite3_free(p->aBuf);
		sqlite3_free(p->aFrame);

		rbuEditErrmsg(p);
		rc = p->rc;
		*pzErrmsg = p->zErrmsg;
		sqlite3_free(p->zState);
		sqlite3_free(p);
	}
	else {
		rc = SQLITE_NOMEM;
		*pzErrmsg = 0;
	}
	return rc;
}


SQLITE_API sqlite3_int64 sqlite3rbu_progress(sqlite3rbu *pRbu) {
	return pRbu->nProgress;
}


SQLITE_API void sqlite3rbu_bp_progress(sqlite3rbu *p, int *pnOne, int *pnTwo) {
	const int MAX_PROGRESS = 10000;
	switch (p->eStage) {
	case RBU_STAGE_OAL:
		if (p->nPhaseOneStep>0) {
			*pnOne = (int)(MAX_PROGRESS * (i64)p->nProgress / (i64)p->nPhaseOneStep);
		}
		else {
			*pnOne = -1;
		}
		*pnTwo = 0;
		break;

	case RBU_STAGE_MOVE:
		*pnOne = MAX_PROGRESS;
		*pnTwo = 0;
		break;

	case RBU_STAGE_CKPT:
		*pnOne = MAX_PROGRESS;
		*pnTwo = (int)(MAX_PROGRESS * (i64)p->nStep / (i64)p->nFrame);
		break;

	case RBU_STAGE_DONE:
		*pnOne = MAX_PROGRESS;
		*pnTwo = MAX_PROGRESS;
		break;

	default:
		assert(0);
	}
}


SQLITE_API int sqlite3rbu_state(sqlite3rbu *p) {
	int aRes[] = {
		0, SQLITE_RBU_STATE_OAL, SQLITE_RBU_STATE_MOVE,
		0, SQLITE_RBU_STATE_CHECKPOINT, SQLITE_RBU_STATE_DONE
	};

	assert(RBU_STAGE_OAL == 1);
	assert(RBU_STAGE_MOVE == 2);
	assert(RBU_STAGE_CKPT == 4);
	assert(RBU_STAGE_DONE == 5);
	assert(aRes[RBU_STAGE_OAL] == SQLITE_RBU_STATE_OAL);
	assert(aRes[RBU_STAGE_MOVE] == SQLITE_RBU_STATE_MOVE);
	assert(aRes[RBU_STAGE_CKPT] == SQLITE_RBU_STATE_CHECKPOINT);
	assert(aRes[RBU_STAGE_DONE] == SQLITE_RBU_STATE_DONE);

	if (p->rc != SQLITE_OK && p->rc != SQLITE_DONE) {
		return SQLITE_RBU_STATE_ERROR;
	}
	else {
		assert(p->rc != SQLITE_DONE || p->eStage == RBU_STAGE_DONE);
		assert(p->eStage == RBU_STAGE_OAL
			|| p->eStage == RBU_STAGE_MOVE
			|| p->eStage == RBU_STAGE_CKPT
			|| p->eStage == RBU_STAGE_DONE
		);
		return aRes[p->eStage];
	}
}

SQLITE_API int sqlite3rbu_savestate(sqlite3rbu *p) {
	int rc = p->rc;
	if (rc == SQLITE_DONE) return SQLITE_OK;

	assert(p->eStage >= RBU_STAGE_OAL && p->eStage <= RBU_STAGE_DONE);
	if (p->eStage == RBU_STAGE_OAL) {
		assert(rc != SQLITE_DONE);
		if (rc == SQLITE_OK) rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, 0);
	}

	p->rc = rc;
	rbuSaveState(p, p->eStage);
	rc = p->rc;

	if (p->eStage == RBU_STAGE_OAL) {
		assert(rc != SQLITE_DONE);
		if (rc == SQLITE_OK) rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, 0);
		if (rc == SQLITE_OK) rc = sqlite3_exec(p->dbRbu, "BEGIN IMMEDIATE", 0, 0, 0);
		if (rc == SQLITE_OK) rc = sqlite3_exec(p->dbMain, "BEGIN IMMEDIATE", 0, 0, 0);
	}

	p->rc = rc;
	return rc;
}



static void rbuUnlockShm(rbu_file *p) {
	if (p->pRbu) {
		int(*xShmLock)(sqlite3_file*, int, int, int) = p->pReal->pMethods->xShmLock;
		int i;
		for (i = 0; i<SQLITE_SHM_NLOCK; i++) {
			if ((1 << i) & p->pRbu->mLock) {
				xShmLock(p->pReal, i, 1, SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);
			}
		}
		p->pRbu->mLock = 0;
	}
}


static int rbuVfsClose(sqlite3_file *pFile) {
	rbu_file *p = (rbu_file*)pFile;
	int rc;
	int i;

	
	for (i = 0; i<p->nShm; i++) {
		sqlite3_free(p->apShm[i]);
	}
	sqlite3_free(p->apShm);
	p->apShm = 0;
	sqlite3_free(p->zDel);

	if (p->openFlags & SQLITE_OPEN_MAIN_DB) {
		rbu_file **pp;
		sqlite3_mutex_enter(p->pRbuVfs->mutex);
		for (pp = &p->pRbuVfs->pMain; *pp != p; pp = &((*pp)->pMainNext));
		*pp = p->pMainNext;
		sqlite3_mutex_leave(p->pRbuVfs->mutex);
		rbuUnlockShm(p);
		p->pReal->pMethods->xShmUnmap(p->pReal, 0);
	}

	
	rc = p->pReal->pMethods->xClose(p->pReal);
	return rc;
}



static u32 rbuGetU32(u8 *aBuf) {
	return ((u32)aBuf[0] << 24)
		+ ((u32)aBuf[1] << 16)
		+ ((u32)aBuf[2] << 8)
		+ ((u32)aBuf[3]);
}


static void rbuPutU32(u8 *aBuf, u32 iVal) {
	aBuf[0] = (iVal >> 24) & 0xFF;
	aBuf[1] = (iVal >> 16) & 0xFF;
	aBuf[2] = (iVal >> 8) & 0xFF;
	aBuf[3] = (iVal >> 0) & 0xFF;
}

static void rbuPutU16(u8 *aBuf, u16 iVal) {
	aBuf[0] = (iVal >> 8) & 0xFF;
	aBuf[1] = (iVal >> 0) & 0xFF;
}


static int rbuVfsRead(
	sqlite3_file *pFile,
	void *zBuf,
	int iAmt,
	sqlite_int64 iOfst
) {
	rbu_file *p = (rbu_file*)pFile;
	sqlite3rbu *pRbu = p->pRbu;
	int rc;

	if (pRbu && pRbu->eStage == RBU_STAGE_CAPTURE) {
		assert(p->openFlags & SQLITE_OPEN_WAL);
		rc = rbuCaptureWalRead(p->pRbu, iOfst, iAmt);
	}
	else {
		if (pRbu && pRbu->eStage == RBU_STAGE_OAL
			&& (p->openFlags & SQLITE_OPEN_WAL)
			&& iOfst >= pRbu->iOalSz
			) {
			rc = SQLITE_OK;
			memset(zBuf, 0, iAmt);
		}
		else {
			rc = p->pReal->pMethods->xRead(p->pReal, zBuf, iAmt, iOfst);
#if 1
			
			if (pRbu && rbuIsVacuum(pRbu)
				&& rc == SQLITE_IOERR_SHORT_READ && iOfst == 0
				&& (p->openFlags & SQLITE_OPEN_MAIN_DB)
				&& pRbu->rc == SQLITE_OK
				) {
				sqlite3_file *pFd = (sqlite3_file*)pRbu->pRbuFd;
				rc = pFd->pMethods->xRead(pFd, zBuf, iAmt, iOfst);
				if (rc == SQLITE_OK) {
					u8 *aBuf = (u8*)zBuf;
					u32 iRoot = rbuGetU32(&aBuf[52]) ? 1 : 0;
					rbuPutU32(&aBuf[52], iRoot);      
					rbuPutU32(&aBuf[36], 0);          
					rbuPutU32(&aBuf[32], 0);          
					rbuPutU32(&aBuf[28], 1);          
					rbuPutU32(&aBuf[24], pRbu->pRbuFd->iCookie + 1);  

					if (iAmt>100) {
						memset(&aBuf[100], 0, iAmt - 100);
						rbuPutU16(&aBuf[105], iAmt & 0xFFFF);
						aBuf[100] = 0x0D;
					}
				}
			}
#endif
		}
		if (rc == SQLITE_OK && iOfst == 0 && (p->openFlags & SQLITE_OPEN_MAIN_DB)) {
			
			u8 *pBuf = (u8*)zBuf;
			p->iCookie = rbuGetU32(&pBuf[24]);
			p->iWriteVer = pBuf[19];
		}
	}
	return rc;
}


static int rbuVfsWrite(
	sqlite3_file *pFile,
	const void *zBuf,
	int iAmt,
	sqlite_int64 iOfst
) {
	rbu_file *p = (rbu_file*)pFile;
	sqlite3rbu *pRbu = p->pRbu;
	int rc;

	if (pRbu && pRbu->eStage == RBU_STAGE_CAPTURE) {
		assert(p->openFlags & SQLITE_OPEN_MAIN_DB);
		rc = rbuCaptureDbWrite(p->pRbu, iOfst);
	}
	else {
		if (pRbu && pRbu->eStage == RBU_STAGE_OAL
			&& (p->openFlags & SQLITE_OPEN_WAL)
			&& iOfst >= pRbu->iOalSz
			) {
			pRbu->iOalSz = iAmt + iOfst;
		}
		rc = p->pReal->pMethods->xWrite(p->pReal, zBuf, iAmt, iOfst);
		if (rc == SQLITE_OK && iOfst == 0 && (p->openFlags & SQLITE_OPEN_MAIN_DB)) {
			
			u8 *pBuf = (u8*)zBuf;
			p->iCookie = rbuGetU32(&pBuf[24]);
			p->iWriteVer = pBuf[19];
		}
	}
	return rc;
}


static int rbuVfsTruncate(sqlite3_file *pFile, sqlite_int64 size) {
	rbu_file *p = (rbu_file*)pFile;
	return p->pReal->pMethods->xTruncate(p->pReal, size);
}


static int rbuVfsSync(sqlite3_file *pFile, int flags) {
	rbu_file *p = (rbu_file *)pFile;
	if (p->pRbu && p->pRbu->eStage == RBU_STAGE_CAPTURE) {
		if (p->openFlags & SQLITE_OPEN_MAIN_DB) {
			return SQLITE_INTERNAL;
		}
		return SQLITE_OK;
	}
	return p->pReal->pMethods->xSync(p->pReal, flags);
}


static int rbuVfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize) {
	rbu_file *p = (rbu_file *)pFile;
	int rc;
	rc = p->pReal->pMethods->xFileSize(p->pReal, pSize);

	
	if (rc == SQLITE_OK && *pSize == 0
		&& p->pRbu && rbuIsVacuum(p->pRbu)
		&& (p->openFlags & SQLITE_OPEN_MAIN_DB)
		) {
		*pSize = 1024;
	}
	return rc;
}


static int rbuVfsLock(sqlite3_file *pFile, int eLock) {
	rbu_file *p = (rbu_file*)pFile;
	sqlite3rbu *pRbu = p->pRbu;
	int rc = SQLITE_OK;

	assert(p->openFlags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB));
	if (eLock == SQLITE_LOCK_EXCLUSIVE
		&& (p->bNolock || (pRbu && pRbu->eStage != RBU_STAGE_DONE))
		) {
		
		rc = SQLITE_BUSY;
	}
	else {
		rc = p->pReal->pMethods->xLock(p->pReal, eLock);
	}

	return rc;
}


static int rbuVfsUnlock(sqlite3_file *pFile, int eLock) {
	rbu_file *p = (rbu_file *)pFile;
	return p->pReal->pMethods->xUnlock(p->pReal, eLock);
}


static int rbuVfsCheckReservedLock(sqlite3_file *pFile, int *pResOut) {
	rbu_file *p = (rbu_file *)pFile;
	return p->pReal->pMethods->xCheckReservedLock(p->pReal, pResOut);
}


static int rbuVfsFileControl(sqlite3_file *pFile, int op, void *pArg) {
	rbu_file *p = (rbu_file *)pFile;
	int(*xControl)(sqlite3_file*, int, void*) = p->pReal->pMethods->xFileControl;
	int rc;

	assert(p->openFlags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB)
		|| p->openFlags & (SQLITE_OPEN_TRANSIENT_DB | SQLITE_OPEN_TEMP_JOURNAL)
	);
	if (op == SQLITE_FCNTL_RBU) {
		sqlite3rbu *pRbu = (sqlite3rbu*)pArg;

		
		rc = xControl(p->pReal, op, pArg);

		if (rc == SQLITE_NOTFOUND) {
			
			void *dummy = 0;
			rc = xControl(p->pReal, SQLITE_FCNTL_ZIPVFS, &dummy);
			if (rc == SQLITE_OK) {
				rc = SQLITE_ERROR;
				pRbu->zErrmsg = sqlite3_mprintf("rbu/zipvfs setup error");
			}
			else if (rc == SQLITE_NOTFOUND) {
				pRbu->pTargetFd = p;
				p->pRbu = pRbu;
				if (p->pWalFd) p->pWalFd->pRbu = pRbu;
				rc = SQLITE_OK;
			}
		}
		return rc;
	}
	else if (op == SQLITE_FCNTL_RBUCNT) {
		sqlite3rbu *pRbu = (sqlite3rbu*)pArg;
		pRbu->nRbu++;
		pRbu->pRbuFd = p;
		p->bNolock = 1;
	}

	rc = xControl(p->pReal, op, pArg);
	if (rc == SQLITE_OK && op == SQLITE_FCNTL_VFSNAME) {
		rbu_vfs *pRbuVfs = p->pRbuVfs;
		char *zIn = *(char**)pArg;
		char *zOut = sqlite3_mprintf("rbu(%s)/%z", pRbuVfs->base.zName, zIn);
		*(char**)pArg = zOut;
		if (zOut == 0) rc = SQLITE_NOMEM;
	}

	return rc;
}


static int rbuVfsSectorSize(sqlite3_file *pFile) {
	rbu_file *p = (rbu_file *)pFile;
	return p->pReal->pMethods->xSectorSize(p->pReal);
}


static int rbuVfsDeviceCharacteristics(sqlite3_file *pFile) {
	rbu_file *p = (rbu_file *)pFile;
	return p->pReal->pMethods->xDeviceCharacteristics(p->pReal);
}


static int rbuVfsShmLock(sqlite3_file *pFile, int ofst, int n, int flags) {
	rbu_file *p = (rbu_file*)pFile;
	sqlite3rbu *pRbu = p->pRbu;
	int rc = SQLITE_OK;

#ifdef SQLITE_AMALGAMATION
	assert(WAL_CKPT_LOCK == 1);
#endif

	assert(p->openFlags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB));
	if (pRbu && (pRbu->eStage == RBU_STAGE_OAL || pRbu->eStage == RBU_STAGE_MOVE)) {
		
		if (ofst == WAL_LOCK_CKPT && n == 1) rc = SQLITE_BUSY;
	}
	else {
		int bCapture = 0;
		if (n == 1 && (flags & SQLITE_SHM_EXCLUSIVE)
			&& pRbu && pRbu->eStage == RBU_STAGE_CAPTURE
			&& (ofst == WAL_LOCK_WRITE || ofst == WAL_LOCK_CKPT || ofst == WAL_LOCK_READ0)
			) {
			bCapture = 1;
		}

		if (bCapture == 0 || 0 == (flags & SQLITE_SHM_UNLOCK)) {
			rc = p->pReal->pMethods->xShmLock(p->pReal, ofst, n, flags);
			if (bCapture && rc == SQLITE_OK) {
				pRbu->mLock |= (1 << ofst);
			}
		}
	}

	return rc;
}


static int rbuVfsShmMap(
	sqlite3_file *pFile,
	int iRegion,
	int szRegion,
	int isWrite,
	void volatile **pp
) {
	rbu_file *p = (rbu_file*)pFile;
	int rc = SQLITE_OK;
	int eStage = (p->pRbu ? p->pRbu->eStage : 0);

	
	assert(p->openFlags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB));
	if (eStage == RBU_STAGE_OAL || eStage == RBU_STAGE_MOVE) {
		if (iRegion <= p->nShm) {
			int nByte = (iRegion + 1) * sizeof(char*);
			char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);
			if (apNew == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));
				p->apShm = apNew;
				p->nShm = iRegion + 1;
			}
		}

		if (rc == SQLITE_OK && p->apShm[iRegion] == 0) {
			char *pNew = (char*)sqlite3_malloc64(szRegion);
			if (pNew == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				memset(pNew, 0, szRegion);
				p->apShm[iRegion] = pNew;
			}
		}

		if (rc == SQLITE_OK) {
			*pp = p->apShm[iRegion];
		}
		else {
			*pp = 0;
		}
	}
	else {
		assert(p->apShm == 0);
		rc = p->pReal->pMethods->xShmMap(p->pReal, iRegion, szRegion, isWrite, pp);
	}

	return rc;
}


static void rbuVfsShmBarrier(sqlite3_file *pFile) {
	rbu_file *p = (rbu_file *)pFile;
	p->pReal->pMethods->xShmBarrier(p->pReal);
}


static int rbuVfsShmUnmap(sqlite3_file *pFile, int delFlag) {
	rbu_file *p = (rbu_file*)pFile;
	int rc = SQLITE_OK;
	int eStage = (p->pRbu ? p->pRbu->eStage : 0);

	assert(p->openFlags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB));
	if (eStage == RBU_STAGE_OAL || eStage == RBU_STAGE_MOVE) {
		
	}
	else {
		
		rbuUnlockShm(p);
		rc = p->pReal->pMethods->xShmUnmap(p->pReal, delFlag);
	}
	return rc;
}


static rbu_file *rbuFindMaindb(rbu_vfs *pRbuVfs, const char *zWal) {
	rbu_file *pDb;
	sqlite3_mutex_enter(pRbuVfs->mutex);
	for (pDb = pRbuVfs->pMain; pDb && pDb->zWal != zWal; pDb = pDb->pMainNext) {}
	sqlite3_mutex_leave(pRbuVfs->mutex);
	return pDb;
}


static const char *rbuMainToWal(const char *zName, int flags) {
	int n = (int)strlen(zName);
	const char *z = &zName[n];
	if (flags & SQLITE_OPEN_URI) {
		int odd = 0;
		while (1) {
			if (z[0] == 0) {
				odd = 1 - odd;
				if (odd && z[1] == 0) break;
			}
			z++;
		}
		z += 2;
	}
	else {
		while (*z == 0) z++;
	}
	z += (n + 8 + 1);
	return z;
}


static int rbuVfsOpen(
	sqlite3_vfs *pVfs,
	const char *zName,
	sqlite3_file *pFile,
	int flags,
	int *pOutFlags
) {
	static sqlite3_io_methods rbuvfs_io_methods = {
		2,                            
		rbuVfsClose,                  
		rbuVfsRead,                   
		rbuVfsWrite,                  
		rbuVfsTruncate,               
		rbuVfsSync,                   
		rbuVfsFileSize,               
		rbuVfsLock,                   
		rbuVfsUnlock,                 
		rbuVfsCheckReservedLock,      
		rbuVfsFileControl,            
		rbuVfsSectorSize,             
		rbuVfsDeviceCharacteristics,  
		rbuVfsShmMap,                 
		rbuVfsShmLock,                
		rbuVfsShmBarrier,             
		rbuVfsShmUnmap,               
		0, 0                          
	};
	rbu_vfs *pRbuVfs = (rbu_vfs*)pVfs;
	sqlite3_vfs *pRealVfs = pRbuVfs->pRealVfs;
	rbu_file *pFd = (rbu_file *)pFile;
	int rc = SQLITE_OK;
	const char *zOpen = zName;
	int oflags = flags;

	memset(pFd, 0, sizeof(rbu_file));
	pFd->pReal = (sqlite3_file*)&pFd[1];
	pFd->pRbuVfs = pRbuVfs;
	pFd->openFlags = flags;
	if (zName) {
		if (flags & SQLITE_OPEN_MAIN_DB) {
			
			pFd->zWal = rbuMainToWal(zName, flags);
		}
		else if (flags & SQLITE_OPEN_WAL) {
			rbu_file *pDb = rbuFindMaindb(pRbuVfs, zName);
			if (pDb) {
				if (pDb->pRbu && pDb->pRbu->eStage == RBU_STAGE_OAL) {
					
					const char *zBase = zName;
					size_t nCopy;
					char *zCopy;
					if (rbuIsVacuum(pDb->pRbu)) {
						zBase = sqlite3_db_filename(pDb->pRbu->dbRbu, "main");
						zBase = rbuMainToWal(zBase, SQLITE_OPEN_URI);
					}
					nCopy = strlen(zBase);
					zCopy = sqlite3_malloc64(nCopy + 2);
					if (zCopy) {
						memcpy(zCopy, zBase, nCopy);
						zCopy[nCopy - 3] = 'o';
						zCopy[nCopy] = '\0';
						zCopy[nCopy + 1] = '\0';
						zOpen = (const char*)(pFd->zDel = zCopy);
					}
					else {
						rc = SQLITE_NOMEM;
					}
					pFd->pRbu = pDb->pRbu;
				}
				pDb->pWalFd = pFd;
			}
		}
	}

	if (oflags & SQLITE_OPEN_MAIN_DB
		&& sqlite3_uri_boolean(zName, "rbu_memory", 0)
		) {
		assert(oflags & SQLITE_OPEN_MAIN_DB);
		oflags = SQLITE_OPEN_TEMP_DB | SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |
			SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;
		zOpen = 0;
	}

	if (rc == SQLITE_OK) {
		rc = pRealVfs->xOpen(pRealVfs, zOpen, pFd->pReal, oflags, pOutFlags);
	}
	if (pFd->pReal->pMethods) {
		
		pFile->pMethods = &rbuvfs_io_methods;
		if (flags & SQLITE_OPEN_MAIN_DB) {
			sqlite3_mutex_enter(pRbuVfs->mutex);
			pFd->pMainNext = pRbuVfs->pMain;
			pRbuVfs->pMain = pFd;
			sqlite3_mutex_leave(pRbuVfs->mutex);
		}
	}
	else {
		sqlite3_free(pFd->zDel);
	}

	return rc;
}


static int rbuVfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xDelete(pRealVfs, zPath, dirSync);
}


static int rbuVfsAccess(
	sqlite3_vfs *pVfs,
	const char *zPath,
	int flags,
	int *pResOut
) {
	rbu_vfs *pRbuVfs = (rbu_vfs*)pVfs;
	sqlite3_vfs *pRealVfs = pRbuVfs->pRealVfs;
	int rc;

	rc = pRealVfs->xAccess(pRealVfs, zPath, flags, pResOut);

	
	if (rc == SQLITE_OK && flags == SQLITE_ACCESS_EXISTS) {
		rbu_file *pDb = rbuFindMaindb(pRbuVfs, zPath);
		if (pDb && pDb->pRbu && pDb->pRbu->eStage == RBU_STAGE_OAL) {
			if (*pResOut) {
				rc = SQLITE_CANTOPEN;
			}
			else {
				*pResOut = 1;
			}
		}
	}

	return rc;
}


static int rbuVfsFullPathname(
	sqlite3_vfs *pVfs,
	const char *zPath,
	int nOut,
	char *zOut
) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xFullPathname(pRealVfs, zPath, nOut, zOut);
}

#ifndef SQLITE_OMIT_LOAD_EXTENSION

static void *rbuVfsDlOpen(sqlite3_vfs *pVfs, const char *zPath) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xDlOpen(pRealVfs, zPath);
}


static void rbuVfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	pRealVfs->xDlError(pRealVfs, nByte, zErrMsg);
}


static void(*rbuVfsDlSym(
	sqlite3_vfs *pVfs,
	void *pArg,
	const char *zSym
))(void) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xDlSym(pRealVfs, pArg, zSym);
}


static void rbuVfsDlClose(sqlite3_vfs *pVfs, void *pHandle) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	pRealVfs->xDlClose(pRealVfs, pHandle);
}
#endif 


static int rbuVfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xRandomness(pRealVfs, nByte, zBufOut);
}


static int rbuVfsSleep(sqlite3_vfs *pVfs, int nMicro) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xSleep(pRealVfs, nMicro);
}


static int rbuVfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut) {
	sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;
	return pRealVfs->xCurrentTime(pRealVfs, pTimeOut);
}


static int rbuVfsGetLastError(sqlite3_vfs *pVfs, int a, char *b) {
	return 0;
}


SQLITE_API void sqlite3rbu_destroy_vfs(const char *zName) {
	sqlite3_vfs *pVfs = sqlite3_vfs_find(zName);
	if (pVfs && pVfs->xOpen == rbuVfsOpen) {
		sqlite3_mutex_free(((rbu_vfs*)pVfs)->mutex);
		sqlite3_vfs_unregister(pVfs);
		sqlite3_free(pVfs);
	}
}


SQLITE_API int sqlite3rbu_create_vfs(const char *zName, const char *zParent) {

	
	static sqlite3_vfs vfs_template = {
		1,                            
		0,                            
		0,                            
		0,                            
		0,                            
		0,                            
		rbuVfsOpen,                   
		rbuVfsDelete,                 
		rbuVfsAccess,                 
		rbuVfsFullPathname,           

#ifndef SQLITE_OMIT_LOAD_EXTENSION
		rbuVfsDlOpen,                 
		rbuVfsDlError,                
		rbuVfsDlSym,                  
		rbuVfsDlClose,                
#else
		0, 0, 0, 0,
#endif

		rbuVfsRandomness,             
		rbuVfsSleep,                  
		rbuVfsCurrentTime,            
		rbuVfsGetLastError,           
		0,                            
		0, 0, 0                       
	};

	rbu_vfs *pNew = 0;              
	int rc = SQLITE_OK;
	size_t nName;
	size_t nByte;

	nName = strlen(zName);
	nByte = sizeof(rbu_vfs) + nName + 1;
	pNew = (rbu_vfs*)sqlite3_malloc64(nByte);
	if (pNew == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		sqlite3_vfs *pParent;           
		memset(pNew, 0, nByte);
		pParent = sqlite3_vfs_find(zParent);
		if (pParent == 0) {
			rc = SQLITE_NOTFOUND;
		}
		else {
			char *zSpace;
			memcpy(&pNew->base, &vfs_template, sizeof(sqlite3_vfs));
			pNew->base.mxPathname = pParent->mxPathname;
			pNew->base.szOsFile = sizeof(rbu_file) + pParent->szOsFile;
			pNew->pRealVfs = pParent;
			pNew->base.zName = (const char*)(zSpace = (char*)&pNew[1]);
			memcpy(zSpace, zName, nName);

			
			pNew->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_RECURSIVE);
			if (pNew->mutex == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				rc = sqlite3_vfs_register(&pNew->base, 0);
			}
		}

		if (rc != SQLITE_OK) {
			sqlite3_mutex_free(pNew->mutex);
			sqlite3_free(pNew);
		}
	}

	return rc;
}




#endif 






#if (defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)) \
    && !defined(SQLITE_OMIT_VIRTUALTABLE)


#define VTAB_SCHEMA                                                         \
  "CREATE TABLE xx( "                                                       \
  "  name       TEXT,             /* Name of table or index */"             \
  "  path       TEXT,             /* Path to page from root */"             \
  "  pageno     INTEGER,          /* Page number */"                        \
  "  pagetype   TEXT,             /* 'internal', 'leaf' or 'overflow' */"   \
  "  ncell      INTEGER,          /* Cells on page (0 for overflow) */"     \
  "  payload    INTEGER,          /* Bytes of payload on this page */"      \
  "  unused     INTEGER,          /* Bytes of unused space on this page */" \
  "  mx_payload INTEGER,          /* Largest payload size of all cells */"  \
  "  pgoffset   INTEGER,          /* Offset of page in file */"             \
  "  pgsize     INTEGER,          /* Size of the page */"                   \
  "  schema     TEXT HIDDEN       /* Database schema being analyzed */"     \
  ");"


typedef struct StatTable StatTable;
typedef struct StatCursor StatCursor;
typedef struct StatPage StatPage;
typedef struct StatCell StatCell;

struct StatCell {
	int nLocal;                     
	u32 iChildPg;                   
	int nOvfl;                      
	u32 *aOvfl;                     
	int nLastOvfl;                  
	int iOvfl;                      
};

struct StatPage {
	u32 iPgno;
	DbPage *pPg;
	int iCell;

	char *zPath;                    

									
	u8 flags;                       
	int nCell;                      
	int nUnused;                    
	StatCell *aCell;                
	u32 iRightChildPg;              
	int nMxPayload;                 
};

struct StatCursor {
	sqlite3_vtab_cursor base;
	sqlite3_stmt *pStmt;            
	int isEof;                      
	int iDb;                        

	StatPage aPage[32];
	int iPage;                      

									
	char *zName;                    
	char *zPath;                    
	u32 iPageno;                    
	char *zPagetype;                
	int nCell;                      
	int nPayload;                   
	int nUnused;                    
	int nMxPayload;                 
	i64 iOffset;                    
	int szPage;                     
};

struct StatTable {
	sqlite3_vtab base;
	sqlite3 *db;
	int iDb;                        
};

#ifndef get2byte
# define get2byte(x)   ((x)[0]<<8 | (x)[1])
#endif


static int statConnect(
	sqlite3 *db,
	void *pAux,
	int argc, const char *const*argv,
	sqlite3_vtab **ppVtab,
	char **pzErr
) {
	StatTable *pTab = 0;
	int rc = SQLITE_OK;
	int iDb;

	if (argc >= 4) {
		Token nm;
		sqlite3TokenInit(&nm, (char*)argv[3]);
		iDb = sqlite3FindDb(db, &nm);
		if (iDb<0) {
			*pzErr = sqlite3_mprintf("no such database: %s", argv[3]);
			return SQLITE_ERROR;
		}
	}
	else {
		iDb = 0;
	}
	rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);
	if (rc == SQLITE_OK) {
		pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));
		if (pTab == 0) rc = SQLITE_NOMEM_BKPT;
	}

	assert(rc == SQLITE_OK || pTab == 0);
	if (rc == SQLITE_OK) {
		memset(pTab, 0, sizeof(StatTable));
		pTab->db = db;
		pTab->iDb = iDb;
	}

	*ppVtab = (sqlite3_vtab*)pTab;
	return rc;
}


static int statDisconnect(sqlite3_vtab *pVtab) {
	sqlite3_free(pVtab);
	return SQLITE_OK;
}


static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo) {
	int i;

	pIdxInfo->estimatedCost = 1.0e6;  

									  
	for (i = 0; i<pIdxInfo->nConstraint; i++) {
		if (pIdxInfo->aConstraint[i].usable == 0) continue;
		if (pIdxInfo->aConstraint[i].op != SQLITE_INDEX_CONSTRAINT_EQ) continue;
		if (pIdxInfo->aConstraint[i].iColumn != 10) continue;
		pIdxInfo->idxNum = 1;
		pIdxInfo->estimatedCost = 1.0;
		pIdxInfo->aConstraintUsage[i].argvIndex = 1;
		pIdxInfo->aConstraintUsage[i].omit = 1;
		break;
	}


	
	if ((pIdxInfo->nOrderBy == 1
		&& pIdxInfo->aOrderBy[0].iColumn == 0
		&& pIdxInfo->aOrderBy[0].desc == 0
		) ||
		(pIdxInfo->nOrderBy == 2
			&& pIdxInfo->aOrderBy[0].iColumn == 0
			&& pIdxInfo->aOrderBy[0].desc == 0
			&& pIdxInfo->aOrderBy[1].iColumn == 1
			&& pIdxInfo->aOrderBy[1].desc == 0
			)
		) {
		pIdxInfo->orderByConsumed = 1;
	}

	return SQLITE_OK;
}


static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor) {
	StatTable *pTab = (StatTable *)pVTab;
	StatCursor *pCsr;

	pCsr = (StatCursor *)sqlite3_malloc64(sizeof(StatCursor));
	if (pCsr == 0) {
		return SQLITE_NOMEM_BKPT;
	}
	else {
		memset(pCsr, 0, sizeof(StatCursor));
		pCsr->base.pVtab = pVTab;
		pCsr->iDb = pTab->iDb;
	}

	*ppCursor = (sqlite3_vtab_cursor *)pCsr;
	return SQLITE_OK;
}

static void statClearPage(StatPage *p) {
	int i;
	if (p->aCell) {
		for (i = 0; i<p->nCell; i++) {
			sqlite3_free(p->aCell[i].aOvfl);
		}
		sqlite3_free(p->aCell);
	}
	sqlite3PagerUnref(p->pPg);
	sqlite3_free(p->zPath);
	memset(p, 0, sizeof(StatPage));
}

static void statResetCsr(StatCursor *pCsr) {
	int i;
	sqlite3_reset(pCsr->pStmt);
	for (i = 0; i<ArraySize(pCsr->aPage); i++) {
		statClearPage(&pCsr->aPage[i]);
	}
	pCsr->iPage = 0;
	sqlite3_free(pCsr->zPath);
	pCsr->zPath = 0;
	pCsr->isEof = 0;
}


static int statClose(sqlite3_vtab_cursor *pCursor) {
	StatCursor *pCsr = (StatCursor *)pCursor;
	statResetCsr(pCsr);
	sqlite3_finalize(pCsr->pStmt);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}

static void getLocalPayload(
	int nUsable,                    
	u8 flags,                       
	int nTotal,                     
	int *pnLocal                    
) {
	int nLocal;
	int nMinLocal;
	int nMaxLocal;

	if (flags == 0x0D) {              
		nMinLocal = (nUsable - 12) * 32 / 255 - 23;
		nMaxLocal = nUsable - 35;
	}
	else {                          
		nMinLocal = (nUsable - 12) * 32 / 255 - 23;
		nMaxLocal = (nUsable - 12) * 64 / 255 - 23;
	}

	nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);
	if (nLocal>nMaxLocal) nLocal = nMinLocal;
	*pnLocal = nLocal;
}

static int statDecodePage(Btree *pBt, StatPage *p) {
	int nUnused;
	int iOff;
	int nHdr;
	int isLeaf;
	int szPage;

	u8 *aData = sqlite3PagerGetData(p->pPg);
	u8 *aHdr = &aData[p->iPgno == 1 ? 100 : 0];

	p->flags = aHdr[0];
	p->nCell = get2byte(&aHdr[3]);
	p->nMxPayload = 0;

	isLeaf = (p->flags == 0x0A || p->flags == 0x0D);
	nHdr = 12 - isLeaf * 4 + (p->iPgno == 1) * 100;

	nUnused = get2byte(&aHdr[5]) - nHdr - 2 * p->nCell;
	nUnused += (int)aHdr[7];
	iOff = get2byte(&aHdr[1]);
	while (iOff) {
		nUnused += get2byte(&aData[iOff + 2]);
		iOff = get2byte(&aData[iOff]);
	}
	p->nUnused = nUnused;
	p->iRightChildPg = isLeaf ? 0 : sqlite3Get4byte(&aHdr[8]);
	szPage = sqlite3BtreeGetPageSize(pBt);

	if (p->nCell) {
		int i;                        
		int nUsable;                  

		sqlite3BtreeEnter(pBt);
		nUsable = szPage - sqlite3BtreeGetReserveNoMutex(pBt);
		sqlite3BtreeLeave(pBt);
		p->aCell = sqlite3_malloc64((p->nCell + 1) * sizeof(StatCell));
		if (p->aCell == 0) return SQLITE_NOMEM_BKPT;
		memset(p->aCell, 0, (p->nCell + 1) * sizeof(StatCell));

		for (i = 0; i<p->nCell; i++) {
			StatCell *pCell = &p->aCell[i];

			iOff = get2byte(&aData[nHdr + i * 2]);
			if (!isLeaf) {
				pCell->iChildPg = sqlite3Get4byte(&aData[iOff]);
				iOff += 4;
			}
			if (p->flags == 0x05) {
				
			}
			else {
				u32 nPayload;             
				int nLocal;               
				iOff += getVarint32(&aData[iOff], nPayload);
				if (p->flags == 0x0D) {
					u64 dummy;
					iOff += sqlite3GetVarint(&aData[iOff], &dummy);
				}
				if (nPayload>(u32)p->nMxPayload) p->nMxPayload = nPayload;
				getLocalPayload(nUsable, p->flags, nPayload, &nLocal);
				pCell->nLocal = nLocal;
				assert(nLocal >= 0);
				assert(nPayload >= (u32)nLocal);
				assert(nLocal <= (nUsable - 35));
				if (nPayload>(u32)nLocal) {
					int j;
					int nOvfl = ((nPayload - nLocal) + nUsable - 4 - 1) / (nUsable - 4);
					pCell->nLastOvfl = (nPayload - nLocal) - (nOvfl - 1) * (nUsable - 4);
					pCell->nOvfl = nOvfl;
					pCell->aOvfl = sqlite3_malloc64(sizeof(u32)*nOvfl);
					if (pCell->aOvfl == 0) return SQLITE_NOMEM_BKPT;
					pCell->aOvfl[0] = sqlite3Get4byte(&aData[iOff + nLocal]);
					for (j = 1; j<nOvfl; j++) {
						int rc;
						u32 iPrev = pCell->aOvfl[j - 1];
						DbPage *pPg = 0;
						rc = sqlite3PagerGet(sqlite3BtreePager(pBt), iPrev, &pPg, 0);
						if (rc != SQLITE_OK) {
							assert(pPg == 0);
							return rc;
						}
						pCell->aOvfl[j] = sqlite3Get4byte(sqlite3PagerGetData(pPg));
						sqlite3PagerUnref(pPg);
					}
				}
			}
		}
	}

	return SQLITE_OK;
}


static void statSizeAndOffset(StatCursor *pCsr) {
	StatTable *pTab = (StatTable *)((sqlite3_vtab_cursor *)pCsr)->pVtab;
	Btree *pBt = pTab->db->aDb[pTab->iDb].pBt;
	Pager *pPager = sqlite3BtreePager(pBt);
	sqlite3_file *fd;
	sqlite3_int64 x[2];

	
	pCsr->szPage = sqlite3BtreeGetPageSize(pBt);
	pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);

	
	fd = sqlite3PagerFile(pPager);
	x[0] = pCsr->iPageno;
	if (fd->pMethods != 0 && sqlite3OsFileControl(fd, 230440, &x) == SQLITE_OK) {
		pCsr->iOffset = x[0];
		pCsr->szPage = (int)x[1];
	}
}


static int statNext(sqlite3_vtab_cursor *pCursor) {
	int rc;
	int nPayload;
	char *z;
	StatCursor *pCsr = (StatCursor *)pCursor;
	StatTable *pTab = (StatTable *)pCursor->pVtab;
	Btree *pBt = pTab->db->aDb[pCsr->iDb].pBt;
	Pager *pPager = sqlite3BtreePager(pBt);

	sqlite3_free(pCsr->zPath);
	pCsr->zPath = 0;

statNextRestart:
	if (pCsr->aPage[0].pPg == 0) {
		rc = sqlite3_step(pCsr->pStmt);
		if (rc == SQLITE_ROW) {
			int nPage;
			u32 iRoot = (u32)sqlite3_column_int64(pCsr->pStmt, 1);
			sqlite3PagerPagecount(pPager, &nPage);
			if (nPage == 0) {
				pCsr->isEof = 1;
				return sqlite3_reset(pCsr->pStmt);
			}
			rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);
			pCsr->aPage[0].iPgno = iRoot;
			pCsr->aPage[0].iCell = 0;
			pCsr->aPage[0].zPath = z = sqlite3_mprintf("/");
			pCsr->iPage = 0;
			if (z == 0) rc = SQLITE_NOMEM_BKPT;
		}
		else {
			pCsr->isEof = 1;
			return sqlite3_reset(pCsr->pStmt);
		}
	}
	else {

		
		StatPage *p = &pCsr->aPage[pCsr->iPage];

		while (p->iCell<p->nCell) {
			StatCell *pCell = &p->aCell[p->iCell];
			if (pCell->iOvfl<pCell->nOvfl) {
				int nUsable;
				sqlite3BtreeEnter(pBt);
				nUsable = sqlite3BtreeGetPageSize(pBt) -
					sqlite3BtreeGetReserveNoMutex(pBt);
				sqlite3BtreeLeave(pBt);
				pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
				pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];
				pCsr->zPagetype = "overflow";
				pCsr->nCell = 0;
				pCsr->nMxPayload = 0;
				pCsr->zPath = z = sqlite3_mprintf(
					"%s%.3x+%.6x", p->zPath, p->iCell, pCell->iOvfl
				);
				if (pCell->iOvfl<pCell->nOvfl - 1) {
					pCsr->nUnused = 0;
					pCsr->nPayload = nUsable - 4;
				}
				else {
					pCsr->nPayload = pCell->nLastOvfl;
					pCsr->nUnused = nUsable - 4 - pCsr->nPayload;
				}
				pCell->iOvfl++;
				statSizeAndOffset(pCsr);
				return z == 0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;
			}
			if (p->iRightChildPg) break;
			p->iCell++;
		}

		if (!p->iRightChildPg || p->iCell>p->nCell) {
			statClearPage(p);
			if (pCsr->iPage == 0) return statNext(pCursor);
			pCsr->iPage--;
			goto statNextRestart; 
		}
		pCsr->iPage++;
		assert(p == &pCsr->aPage[pCsr->iPage - 1]);

		if (p->iCell == p->nCell) {
			p[1].iPgno = p->iRightChildPg;
		}
		else {
			p[1].iPgno = p->aCell[p->iCell].iChildPg;
		}
		rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);
		p[1].iCell = 0;
		p[1].zPath = z = sqlite3_mprintf("%s%.3x/", p->zPath, p->iCell);
		p->iCell++;
		if (z == 0) rc = SQLITE_NOMEM_BKPT;
	}


	
	if (rc == SQLITE_OK) {
		int i;
		StatPage *p = &pCsr->aPage[pCsr->iPage];
		pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
		pCsr->iPageno = p->iPgno;

		rc = statDecodePage(pBt, p);
		if (rc == SQLITE_OK) {
			statSizeAndOffset(pCsr);

			switch (p->flags) {
			case 0x05:             
			case 0x02:             
				pCsr->zPagetype = "internal";
				break;
			case 0x0D:             
			case 0x0A:             
				pCsr->zPagetype = "leaf";
				break;
			default:
				pCsr->zPagetype = "corrupted";
				break;
			}
			pCsr->nCell = p->nCell;
			pCsr->nUnused = p->nUnused;
			pCsr->nMxPayload = p->nMxPayload;
			pCsr->zPath = z = sqlite3_mprintf("%s", p->zPath);
			if (z == 0) rc = SQLITE_NOMEM_BKPT;
			nPayload = 0;
			for (i = 0; i<p->nCell; i++) {
				nPayload += p->aCell[i].nLocal;
			}
			pCsr->nPayload = nPayload;
		}
	}

	return rc;
}

static int statEof(sqlite3_vtab_cursor *pCursor) {
	StatCursor *pCsr = (StatCursor *)pCursor;
	return pCsr->isEof;
}

static int statFilter(
	sqlite3_vtab_cursor *pCursor,
	int idxNum, const char *idxStr,
	int argc, sqlite3_value **argv
) {
	StatCursor *pCsr = (StatCursor *)pCursor;
	StatTable *pTab = (StatTable*)(pCursor->pVtab);
	char *zSql;
	int rc = SQLITE_OK;
	char *zMaster;

	if (idxNum == 1) {
		const char *zDbase = (const char*)sqlite3_value_text(argv[0]);
		pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);
		if (pCsr->iDb<0) {
			sqlite3_free(pCursor->pVtab->zErrMsg);
			pCursor->pVtab->zErrMsg = sqlite3_mprintf("no such schema: %s", zDbase);
			return pCursor->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM_BKPT;
		}
	}
	else {
		pCsr->iDb = pTab->iDb;
	}
	statResetCsr(pCsr);
	sqlite3_finalize(pCsr->pStmt);
	pCsr->pStmt = 0;
	zMaster = pCsr->iDb == 1 ? "sqlite_temp_master" : "sqlite_master";
	zSql = sqlite3_mprintf(
		"SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type"
		"  UNION ALL  "
		"SELECT name, rootpage, type"
		"  FROM \"%w\".%s WHERE rootpage!=0"
		"  ORDER BY name", pTab->db->aDb[pCsr->iDb].zDbSName, zMaster);
	if (zSql == 0) {
		return SQLITE_NOMEM_BKPT;
	}
	else {
		rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);
		sqlite3_free(zSql);
	}

	if (rc == SQLITE_OK) {
		rc = statNext(pCursor);
	}
	return rc;
}

static int statColumn(
	sqlite3_vtab_cursor *pCursor,
	sqlite3_context *ctx,
	int i
) {
	StatCursor *pCsr = (StatCursor *)pCursor;
	switch (i) {
	case 0:            
		sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);
		break;
	case 1:            
		sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);
		break;
	case 2:            
		sqlite3_result_int64(ctx, pCsr->iPageno);
		break;
	case 3:            
		sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);
		break;
	case 4:            
		sqlite3_result_int(ctx, pCsr->nCell);
		break;
	case 5:            
		sqlite3_result_int(ctx, pCsr->nPayload);
		break;
	case 6:            
		sqlite3_result_int(ctx, pCsr->nUnused);
		break;
	case 7:            
		sqlite3_result_int(ctx, pCsr->nMxPayload);
		break;
	case 8:            
		sqlite3_result_int64(ctx, pCsr->iOffset);
		break;
	case 9:            
		sqlite3_result_int(ctx, pCsr->szPage);
		break;
	default: {          
		sqlite3 *db = sqlite3_context_db_handle(ctx);
		int iDb = pCsr->iDb;
		sqlite3_result_text(ctx, db->aDb[iDb].zDbSName, -1, SQLITE_STATIC);
		break;
	}
	}
	return SQLITE_OK;
}

static int statRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid) {
	StatCursor *pCsr = (StatCursor *)pCursor;
	*pRowid = pCsr->iPageno;
	return SQLITE_OK;
}


SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db) {
	static sqlite3_module dbstat_module = {
		0,                            
		statConnect,                  
		statConnect,                  
		statBestIndex,                
		statDisconnect,               
		statDisconnect,               
		statOpen,                     
		statClose,                    
		statFilter,                   
		statNext,                     
		statEof,                      
		statColumn,                   
		statRowid,                    
		0,                            
		0,                            
		0,                            
		0,                            
		0,                            
		0,                            
		0,                            
	};
	return sqlite3_create_module(db, "dbstat", &dbstat_module, 0);
}
#elif defined(SQLITE_ENABLE_DBSTAT_VTAB)
SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db) { return SQLITE_OK; }
#endif 




#if defined(SQLITE_ENABLE_SESSION) && defined(SQLITE_ENABLE_PREUPDATE_HOOK)




#ifndef SQLITE_AMALGAMATION


#endif

typedef struct SessionTable SessionTable;
typedef struct SessionChange SessionChange;
typedef struct SessionBuffer SessionBuffer;
typedef struct SessionInput SessionInput;


#ifndef SESSIONS_STRM_CHUNK_SIZE
# ifdef SQLITE_TEST
#   define SESSIONS_STRM_CHUNK_SIZE 64
# else
#   define SESSIONS_STRM_CHUNK_SIZE 1024
# endif
#endif

typedef struct SessionHook SessionHook;
struct SessionHook {
	void *pCtx;
	int(*xOld)(void*, int, sqlite3_value**);
	int(*xNew)(void*, int, sqlite3_value**);
	int(*xCount)(void*);
	int(*xDepth)(void*);
};


struct sqlite3_session {
	sqlite3 *db;                    
	char *zDb;                      
	int bEnable;                    
	int bIndirect;                  
	int bAutoAttach;                
	int rc;                         
	void *pFilterCtx;               
	int(*xTableFilter)(void *pCtx, const char *zTab);
	sqlite3_session *pNext;         
	SessionTable *pTable;           
	SessionHook hook;               
};


struct SessionBuffer {
	u8 *aBuf;                       
	int nBuf;                       
	int nAlloc;                     
};


struct SessionInput {
	int bNoDiscard;                 
	int iCurrent;                   
	int iNext;                      
	u8 *aData;                      
	int nData;                      

	SessionBuffer buf;              
	int(*xInput)(void*, void*, int*);        
	void *pIn;                                
	int bEof;                       
};


struct sqlite3_changeset_iter {
	SessionInput in;                
	SessionBuffer tblhdr;           
	int bPatchset;                  
	int rc;                         
	sqlite3_stmt *pConflict;        
	char *zTab;                     
	int nCol;                       
	int op;                         
	int bIndirect;                  
	u8 *abPK;                       
	sqlite3_value **apValue;        
};


struct SessionTable {
	SessionTable *pNext;
	char *zName;                    
	int nCol;                       
	const char **azCol;             
	u8 *abPK;                       
	int nEntry;                     
	int nChange;                    
	SessionChange **apChange;       
};




struct SessionChange {
	int op;                         
	int bIndirect;                  
	int nRecord;                    
	u8 *aRecord;                    
	SessionChange *pNext;           
};


static int sessionVarintPut(u8 *aBuf, int iVal) {
	return putVarint32(aBuf, iVal);
}


static int sessionVarintLen(int iVal) {
	return sqlite3VarintLen(iVal);
}


static int sessionVarintGet(u8 *aBuf, int *piVal) {
	return getVarint32(aBuf, *piVal);
}


#define SESSION_UINT32(x) (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])


static sqlite3_int64 sessionGetI64(u8 *aRec) {
	u64 x = SESSION_UINT32(aRec);
	u32 y = SESSION_UINT32(aRec + 4);
	x = (x << 32) + y;
	return (sqlite3_int64)x;
}


static void sessionPutI64(u8 *aBuf, sqlite3_int64 i) {
	aBuf[0] = (i >> 56) & 0xFF;
	aBuf[1] = (i >> 48) & 0xFF;
	aBuf[2] = (i >> 40) & 0xFF;
	aBuf[3] = (i >> 32) & 0xFF;
	aBuf[4] = (i >> 24) & 0xFF;
	aBuf[5] = (i >> 16) & 0xFF;
	aBuf[6] = (i >> 8) & 0xFF;
	aBuf[7] = (i >> 0) & 0xFF;
}


static int sessionSerializeValue(
	u8 *aBuf,                       
	sqlite3_value *pValue,          
	int *pnWrite                    
) {
	int nByte;                      

	if (pValue) {
		int eType;                    

		eType = sqlite3_value_type(pValue);
		if (aBuf) aBuf[0] = eType;

		switch (eType) {
		case SQLITE_NULL:
			nByte = 1;
			break;

		case SQLITE_INTEGER:
		case SQLITE_FLOAT:
			if (aBuf) {
				
				u64 i;
				if (eType == SQLITE_INTEGER) {
					i = (u64)sqlite3_value_int64(pValue);
				}
				else {
					double r;
					assert(sizeof(double) == 8 && sizeof(u64) == 8);
					r = sqlite3_value_double(pValue);
					memcpy(&i, &r, 8);
				}
				sessionPutI64(&aBuf[1], i);
			}
			nByte = 9;
			break;

		default: {
			u8 *z;
			int n;
			int nVarint;

			assert(eType == SQLITE_TEXT || eType == SQLITE_BLOB);
			if (eType == SQLITE_TEXT) {
				z = (u8 *)sqlite3_value_text(pValue);
			}
			else {
				z = (u8 *)sqlite3_value_blob(pValue);
			}
			n = sqlite3_value_bytes(pValue);
			if (z == 0 && (eType != SQLITE_BLOB || n>0)) return SQLITE_NOMEM;
			nVarint = sessionVarintLen(n);

			if (aBuf) {
				sessionVarintPut(&aBuf[1], n);
				memcpy(&aBuf[nVarint + 1], eType == SQLITE_TEXT ?
					sqlite3_value_text(pValue) : sqlite3_value_blob(pValue), n
				);
			}

			nByte = 1 + nVarint + n;
			break;
		}
		}
	}
	else {
		nByte = 1;
		if (aBuf) aBuf[0] = '\0';
	}

	if (pnWrite) *pnWrite += nByte;
	return SQLITE_OK;
}



#define HASH_APPEND(hash, add) ((hash) << 3) ^ (hash) ^ (unsigned int)(add)


static unsigned int sessionHashAppendI64(unsigned int h, i64 i) {
	h = HASH_APPEND(h, i & 0xFFFFFFFF);
	return HASH_APPEND(h, (i >> 32) & 0xFFFFFFFF);
}


static unsigned int sessionHashAppendBlob(unsigned int h, int n, const u8 *z) {
	int i;
	for (i = 0; i<n; i++) h = HASH_APPEND(h, z[i]);
	return h;
}


static unsigned int sessionHashAppendType(unsigned int h, int eType) {
	return HASH_APPEND(h, eType);
}


static int sessionPreupdateHash(
	sqlite3_session *pSession,      
	SessionTable *pTab,             
	int bNew,                       
	int *piHash,                    
	int *pbNullPK                   
) {
	unsigned int h = 0;             
	int i;                          

	assert(*pbNullPK == 0);
	assert(pTab->nCol == pSession->hook.xCount(pSession->hook.pCtx));
	for (i = 0; i<pTab->nCol; i++) {
		if (pTab->abPK[i]) {
			int rc;
			int eType;
			sqlite3_value *pVal;

			if (bNew) {
				rc = pSession->hook.xNew(pSession->hook.pCtx, i, &pVal);
			}
			else {
				rc = pSession->hook.xOld(pSession->hook.pCtx, i, &pVal);
			}
			if (rc != SQLITE_OK) return rc;

			eType = sqlite3_value_type(pVal);
			h = sessionHashAppendType(h, eType);
			if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
				i64 iVal;
				if (eType == SQLITE_INTEGER) {
					iVal = sqlite3_value_int64(pVal);
				}
				else {
					double rVal = sqlite3_value_double(pVal);
					assert(sizeof(iVal) == 8 && sizeof(rVal) == 8);
					memcpy(&iVal, &rVal, 8);
				}
				h = sessionHashAppendI64(h, iVal);
			}
			else if (eType == SQLITE_TEXT || eType == SQLITE_BLOB) {
				const u8 *z;
				int n;
				if (eType == SQLITE_TEXT) {
					z = (const u8 *)sqlite3_value_text(pVal);
				}
				else {
					z = (const u8 *)sqlite3_value_blob(pVal);
				}
				n = sqlite3_value_bytes(pVal);
				if (!z && (eType != SQLITE_BLOB || n>0)) return SQLITE_NOMEM;
				h = sessionHashAppendBlob(h, n, z);
			}
			else {
				assert(eType == SQLITE_NULL);
				*pbNullPK = 1;
			}
		}
	}

	*piHash = (h % pTab->nChange);
	return SQLITE_OK;
}


static int sessionSerialLen(u8 *a) {
	int e = *a;
	int n;
	if (e == 0) return 1;
	if (e == SQLITE_NULL) return 1;
	if (e == SQLITE_INTEGER || e == SQLITE_FLOAT) return 9;
	return sessionVarintGet(&a[1], &n) + 1 + n;
}


static unsigned int sessionChangeHash(
	SessionTable *pTab,             
	int bPkOnly,                    
	u8 *aRecord,                    
	int nBucket                     
) {
	unsigned int h = 0;             
	int i;                          
	u8 *a = aRecord;                

	for (i = 0; i<pTab->nCol; i++) {
		int eType = *a;
		int isPK = pTab->abPK[i];
		if (bPkOnly && isPK == 0) continue;

		
		assert(eType == SQLITE_INTEGER || eType == SQLITE_FLOAT
			|| eType == SQLITE_TEXT || eType == SQLITE_BLOB
			|| eType == SQLITE_NULL || eType == 0
		);
		assert(!isPK || (eType != 0 && eType != SQLITE_NULL));

		if (isPK) {
			a++;
			h = sessionHashAppendType(h, eType);
			if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
				h = sessionHashAppendI64(h, sessionGetI64(a));
				a += 8;
			}
			else {
				int n;
				a += sessionVarintGet(a, &n);
				h = sessionHashAppendBlob(h, n, a);
				a += n;
			}
		}
		else {
			a += sessionSerialLen(a);
		}
	}
	return (h % nBucket);
}


static int sessionChangeEqual(
	SessionTable *pTab,             
	int bLeftPkOnly,                
	u8 *aLeft,                      
	int bRightPkOnly,               
	u8 *aRight                      
) {
	u8 *a1 = aLeft;                 
	u8 *a2 = aRight;                
	int iCol;                       

	for (iCol = 0; iCol<pTab->nCol; iCol++) {
		if (pTab->abPK[iCol]) {
			int n1 = sessionSerialLen(a1);
			int n2 = sessionSerialLen(a2);

			if (pTab->abPK[iCol] && (n1 != n2 || memcmp(a1, a2, n1))) {
				return 0;
			}
			a1 += n1;
			a2 += n2;
		}
		else {
			if (bLeftPkOnly == 0) a1 += sessionSerialLen(a1);
			if (bRightPkOnly == 0) a2 += sessionSerialLen(a2);
		}
	}

	return 1;
}


static void sessionMergeRecord(
	u8 **paOut,
	int nCol,
	u8 *aLeft,
	u8 *aRight
) {
	u8 *a1 = aLeft;                 
	u8 *a2 = aRight;                
	u8 *aOut = *paOut;              
	int iCol;                       

	for (iCol = 0; iCol<nCol; iCol++) {
		int n1 = sessionSerialLen(a1);
		int n2 = sessionSerialLen(a2);
		if (*a2) {
			memcpy(aOut, a2, n2);
			aOut += n2;
		}
		else {
			memcpy(aOut, a1, n1);
			aOut += n1;
		}
		a1 += n1;
		a2 += n2;
	}

	*paOut = aOut;
}


static u8 *sessionMergeValue(
	u8 **paOne,                     
	u8 **paTwo,                     
	int *pnVal                      
) {
	u8 *a1 = *paOne;
	u8 *a2 = *paTwo;
	u8 *pRet = 0;
	int n1;

	assert(a1);
	if (a2) {
		int n2 = sessionSerialLen(a2);
		if (*a2) {
			*pnVal = n2;
			pRet = a2;
		}
		*paTwo = &a2[n2];
	}

	n1 = sessionSerialLen(a1);
	if (pRet == 0) {
		*pnVal = n1;
		pRet = a1;
	}
	*paOne = &a1[n1];

	return pRet;
}


static int sessionMergeUpdate(
	u8 **paOut,                     
	SessionTable *pTab,             
	int bPatchset,                  
	u8 *aOldRecord1,                
	u8 *aOldRecord2,                
	u8 *aNewRecord1,                
	u8 *aNewRecord2                 
) {
	u8 *aOld1 = aOldRecord1;
	u8 *aOld2 = aOldRecord2;
	u8 *aNew1 = aNewRecord1;
	u8 *aNew2 = aNewRecord2;

	u8 *aOut = *paOut;
	int i;

	if (bPatchset == 0) {
		int bRequired = 0;

		assert(aOldRecord1 && aNewRecord1);

		
		for (i = 0; i<pTab->nCol; i++) {
			int nOld;
			u8 *aOld;
			int nNew;
			u8 *aNew;

			aOld = sessionMergeValue(&aOld1, &aOld2, &nOld);
			aNew = sessionMergeValue(&aNew1, &aNew2, &nNew);
			if (pTab->abPK[i] || nOld != nNew || memcmp(aOld, aNew, nNew)) {
				if (pTab->abPK[i] == 0) bRequired = 1;
				memcpy(aOut, aOld, nOld);
				aOut += nOld;
			}
			else {
				*(aOut++) = '\0';
			}
		}

		if (!bRequired) return 0;
	}

	
	aOld1 = aOldRecord1;
	aOld2 = aOldRecord2;
	aNew1 = aNewRecord1;
	aNew2 = aNewRecord2;
	for (i = 0; i<pTab->nCol; i++) {
		int nOld;
		u8 *aOld;
		int nNew;
		u8 *aNew;

		aOld = sessionMergeValue(&aOld1, &aOld2, &nOld);
		aNew = sessionMergeValue(&aNew1, &aNew2, &nNew);
		if (bPatchset == 0
			&& (pTab->abPK[i] || (nOld == nNew && 0 == memcmp(aOld, aNew, nNew)))
			) {
			*(aOut++) = '\0';
		}
		else {
			memcpy(aOut, aNew, nNew);
			aOut += nNew;
		}
	}

	*paOut = aOut;
	return 1;
}


static int sessionPreupdateEqual(
	sqlite3_session *pSession,      
	SessionTable *pTab,             
	SessionChange *pChange,         
	int op                          
) {
	int iCol;                       
	u8 *a = pChange->aRecord;       

	assert(op == SQLITE_INSERT || op == SQLITE_UPDATE || op == SQLITE_DELETE);
	for (iCol = 0; iCol<pTab->nCol; iCol++) {
		if (!pTab->abPK[iCol]) {
			a += sessionSerialLen(a);
		}
		else {
			sqlite3_value *pVal;        
			int rc;                     
			int eType = *a++;           

										
			if (op == SQLITE_INSERT) {
				
				rc = pSession->hook.xNew(pSession->hook.pCtx, iCol, &pVal);
			}
			else {
				
				rc = pSession->hook.xOld(pSession->hook.pCtx, iCol, &pVal);
			}
			assert(rc == SQLITE_OK);
			if (sqlite3_value_type(pVal) != eType) return 0;

			
			assert(eType == SQLITE_INTEGER || eType == SQLITE_FLOAT
				|| eType == SQLITE_BLOB || eType == SQLITE_TEXT
			);

			if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
				i64 iVal = sessionGetI64(a);
				a += 8;
				if (eType == SQLITE_INTEGER) {
					if (sqlite3_value_int64(pVal) != iVal) return 0;
				}
				else {
					double rVal;
					assert(sizeof(iVal) == 8 && sizeof(rVal) == 8);
					memcpy(&rVal, &iVal, 8);
					if (sqlite3_value_double(pVal) != rVal) return 0;
				}
			}
			else {
				int n;
				const u8 *z;
				a += sessionVarintGet(a, &n);
				if (sqlite3_value_bytes(pVal) != n) return 0;
				if (eType == SQLITE_TEXT) {
					z = sqlite3_value_text(pVal);
				}
				else {
					z = sqlite3_value_blob(pVal);
				}
				if (memcmp(a, z, n)) return 0;
				a += n;
				break;
			}
		}
	}

	return 1;
}


static int sessionGrowHash(int bPatchset, SessionTable *pTab) {
	if (pTab->nChange == 0 || pTab->nEntry >= (pTab->nChange / 2)) {
		int i;
		SessionChange **apNew;
		int nNew = (pTab->nChange ? pTab->nChange : 128) * 2;

		apNew = (SessionChange **)sqlite3_malloc(sizeof(SessionChange *) * nNew);
		if (apNew == 0) {
			if (pTab->nChange == 0) {
				return SQLITE_ERROR;
			}
			return SQLITE_OK;
		}
		memset(apNew, 0, sizeof(SessionChange *) * nNew);

		for (i = 0; i<pTab->nChange; i++) {
			SessionChange *p;
			SessionChange *pNext;
			for (p = pTab->apChange[i]; p; p = pNext) {
				int bPkOnly = (p->op == SQLITE_DELETE && bPatchset);
				int iHash = sessionChangeHash(pTab, bPkOnly, p->aRecord, nNew);
				pNext = p->pNext;
				p->pNext = apNew[iHash];
				apNew[iHash] = p;
			}
		}

		sqlite3_free(pTab->apChange);
		pTab->nChange = nNew;
		pTab->apChange = apNew;
	}

	return SQLITE_OK;
}


static int sessionTableInfo(
	sqlite3 *db,                    
	const char *zDb,                
	const char *zThis,              
	int *pnCol,                     
	const char **pzTab,             
	const char ***pazCol,           
	u8 **pabPK                      
) {
	char *zPragma;
	sqlite3_stmt *pStmt;
	int rc;
	int nByte;
	int nDbCol = 0;
	int nThis;
	int i;
	u8 *pAlloc = 0;
	char **azCol = 0;
	u8 *abPK = 0;

	assert(pazCol && pabPK);

	nThis = sqlite3Strlen30(zThis);
	zPragma = sqlite3_mprintf("PRAGMA '%q'.table_info('%q')", zDb, zThis);
	if (!zPragma) return SQLITE_NOMEM;

	rc = sqlite3_prepare_v2(db, zPragma, -1, &pStmt, 0);
	sqlite3_free(zPragma);
	if (rc != SQLITE_OK) return rc;

	nByte = nThis + 1;
	while (SQLITE_ROW == sqlite3_step(pStmt)) {
		nByte += sqlite3_column_bytes(pStmt, 1);
		nDbCol++;
	}
	rc = sqlite3_reset(pStmt);

	if (rc == SQLITE_OK) {
		nByte += nDbCol * (sizeof(const char *) + sizeof(u8) + 1);
		pAlloc = sqlite3_malloc(nByte);
		if (pAlloc == 0) {
			rc = SQLITE_NOMEM;
		}
	}
	if (rc == SQLITE_OK) {
		azCol = (char **)pAlloc;
		pAlloc = (u8 *)&azCol[nDbCol];
		abPK = (u8 *)pAlloc;
		pAlloc = &abPK[nDbCol];
		if (pzTab) {
			memcpy(pAlloc, zThis, nThis + 1);
			*pzTab = (char *)pAlloc;
			pAlloc += nThis + 1;
		}

		i = 0;
		while (SQLITE_ROW == sqlite3_step(pStmt)) {
			int nName = sqlite3_column_bytes(pStmt, 1);
			const unsigned char *zName = sqlite3_column_text(pStmt, 1);
			if (zName == 0) break;
			memcpy(pAlloc, zName, nName + 1);
			azCol[i] = (char *)pAlloc;
			pAlloc += nName + 1;
			abPK[i] = sqlite3_column_int(pStmt, 5);
			i++;
		}
		rc = sqlite3_reset(pStmt);

	}

	
	if (rc == SQLITE_OK) {
		*pazCol = (const char **)azCol;
		*pabPK = abPK;
		*pnCol = nDbCol;
	}
	else {
		*pazCol = 0;
		*pabPK = 0;
		*pnCol = 0;
		if (pzTab) *pzTab = 0;
		sqlite3_free(azCol);
	}
	sqlite3_finalize(pStmt);
	return rc;
}


static int sessionInitTable(sqlite3_session *pSession, SessionTable *pTab) {
	if (pTab->nCol == 0) {
		u8 *abPK;
		assert(pTab->azCol == 0 || pTab->abPK == 0);
		pSession->rc = sessionTableInfo(pSession->db, pSession->zDb,
			pTab->zName, &pTab->nCol, 0, &pTab->azCol, &abPK
		);
		if (pSession->rc == SQLITE_OK) {
			int i;
			for (i = 0; i<pTab->nCol; i++) {
				if (abPK[i]) {
					pTab->abPK = abPK;
					break;
				}
			}
		}
	}
	return (pSession->rc || pTab->abPK == 0);
}


static void sessionPreupdateOneChange(
	int op,                         
	sqlite3_session *pSession,      
	SessionTable *pTab              
) {
	int iHash;
	int bNull = 0;
	int rc = SQLITE_OK;

	if (pSession->rc) return;

	
	if (sessionInitTable(pSession, pTab)) return;

	
	if (pTab->nCol != pSession->hook.xCount(pSession->hook.pCtx)) {
		pSession->rc = SQLITE_SCHEMA;
		return;
	}

	
	if (sessionGrowHash(0, pTab)) {
		pSession->rc = SQLITE_NOMEM;
		return;
	}

	
	rc = sessionPreupdateHash(pSession, pTab, op == SQLITE_INSERT, &iHash, &bNull);
	if (rc != SQLITE_OK) goto error_out;

	if (bNull == 0) {
		
		SessionChange *pC;
		for (pC = pTab->apChange[iHash]; pC; pC = pC->pNext) {
			if (sessionPreupdateEqual(pSession, pTab, pC, op)) break;
		}

		if (pC == 0) {
			
			SessionChange *pChange; 
			int nByte;              
			int i;                  

			assert(rc == SQLITE_OK);
			pTab->nEntry++;

			
			nByte = sizeof(SessionChange);
			for (i = 0; i<pTab->nCol; i++) {
				sqlite3_value *p = 0;
				if (op != SQLITE_INSERT) {
					TESTONLY(int trc = ) pSession->hook.xOld(pSession->hook.pCtx, i, &p);
					assert(trc == SQLITE_OK);
				}
				else if (pTab->abPK[i]) {
					TESTONLY(int trc = ) pSession->hook.xNew(pSession->hook.pCtx, i, &p);
					assert(trc == SQLITE_OK);
				}

				
				rc = sessionSerializeValue(0, p, &nByte);
				if (rc != SQLITE_OK) goto error_out;
			}

			
			pChange = (SessionChange *)sqlite3_malloc(nByte);
			if (!pChange) {
				rc = SQLITE_NOMEM;
				goto error_out;
			}
			else {
				memset(pChange, 0, sizeof(SessionChange));
				pChange->aRecord = (u8 *)&pChange[1];
			}

			
			nByte = 0;
			for (i = 0; i<pTab->nCol; i++) {
				sqlite3_value *p = 0;
				if (op != SQLITE_INSERT) {
					pSession->hook.xOld(pSession->hook.pCtx, i, &p);
				}
				else if (pTab->abPK[i]) {
					pSession->hook.xNew(pSession->hook.pCtx, i, &p);
				}
				sessionSerializeValue(&pChange->aRecord[nByte], p, &nByte);
			}

			
			if (pSession->bIndirect || pSession->hook.xDepth(pSession->hook.pCtx)) {
				pChange->bIndirect = 1;
			}
			pChange->nRecord = nByte;
			pChange->op = op;
			pChange->pNext = pTab->apChange[iHash];
			pTab->apChange[iHash] = pChange;

		}
		else if (pC->bIndirect) {
			
			if (pSession->hook.xDepth(pSession->hook.pCtx) == 0
				&& pSession->bIndirect == 0
				) {
				pC->bIndirect = 0;
			}
		}
	}

	
error_out:
	if (rc != SQLITE_OK) {
		pSession->rc = rc;
	}
}

static int sessionFindTable(
	sqlite3_session *pSession,
	const char *zName,
	SessionTable **ppTab
) {
	int rc = SQLITE_OK;
	int nName = sqlite3Strlen30(zName);
	SessionTable *pRet;

	
	for (pRet = pSession->pTable; pRet; pRet = pRet->pNext) {
		if (0 == sqlite3_strnicmp(pRet->zName, zName, nName + 1)) break;
	}

	if (pRet == 0 && pSession->bAutoAttach) {
		
		if (pSession->xTableFilter == 0
			|| pSession->xTableFilter(pSession->pFilterCtx, zName)
			) {
			rc = sqlite3session_attach(pSession, zName);
			if (rc == SQLITE_OK) {
				for (pRet = pSession->pTable; pRet->pNext; pRet = pRet->pNext);
				assert(0 == sqlite3_strnicmp(pRet->zName, zName, nName + 1));
			}
		}
	}

	assert(rc == SQLITE_OK || pRet == 0);
	*ppTab = pRet;
	return rc;
}


static void xPreUpdate(
	void *pCtx,                     
	sqlite3 *db,                    
	int op,                         
	char const *zDb,                
	char const *zName,              
	sqlite3_int64 iKey1,            
	sqlite3_int64 iKey2             
) {
	sqlite3_session *pSession;
	int nDb = sqlite3Strlen30(zDb);

	assert(sqlite3_mutex_held(db->mutex));

	for (pSession = (sqlite3_session *)pCtx; pSession; pSession = pSession->pNext) {
		SessionTable *pTab;

		
		if (pSession->bEnable == 0) continue;
		if (pSession->rc) continue;
		if (sqlite3_strnicmp(zDb, pSession->zDb, nDb + 1)) continue;

		pSession->rc = sessionFindTable(pSession, zName, &pTab);
		if (pTab) {
			assert(pSession->rc == SQLITE_OK);
			sessionPreupdateOneChange(op, pSession, pTab);
			if (op == SQLITE_UPDATE) {
				sessionPreupdateOneChange(SQLITE_INSERT, pSession, pTab);
			}
		}
	}
}


static int sessionPreupdateOld(void *pCtx, int iVal, sqlite3_value **ppVal) {
	return sqlite3_preupdate_old((sqlite3*)pCtx, iVal, ppVal);
}
static int sessionPreupdateNew(void *pCtx, int iVal, sqlite3_value **ppVal) {
	return sqlite3_preupdate_new((sqlite3*)pCtx, iVal, ppVal);
}
static int sessionPreupdateCount(void *pCtx) {
	return sqlite3_preupdate_count((sqlite3*)pCtx);
}
static int sessionPreupdateDepth(void *pCtx) {
	return sqlite3_preupdate_depth((sqlite3*)pCtx);
}


static void sessionPreupdateHooks(
	sqlite3_session *pSession
) {
	pSession->hook.pCtx = (void*)pSession->db;
	pSession->hook.xOld = sessionPreupdateOld;
	pSession->hook.xNew = sessionPreupdateNew;
	pSession->hook.xCount = sessionPreupdateCount;
	pSession->hook.xDepth = sessionPreupdateDepth;
}

typedef struct SessionDiffCtx SessionDiffCtx;
struct SessionDiffCtx {
	sqlite3_stmt *pStmt;
	int nOldOff;
};


static int sessionDiffOld(void *pCtx, int iVal, sqlite3_value **ppVal) {
	SessionDiffCtx *p = (SessionDiffCtx*)pCtx;
	*ppVal = sqlite3_column_value(p->pStmt, iVal + p->nOldOff);
	return SQLITE_OK;
}
static int sessionDiffNew(void *pCtx, int iVal, sqlite3_value **ppVal) {
	SessionDiffCtx *p = (SessionDiffCtx*)pCtx;
	*ppVal = sqlite3_column_value(p->pStmt, iVal);
	return SQLITE_OK;
}
static int sessionDiffCount(void *pCtx) {
	SessionDiffCtx *p = (SessionDiffCtx*)pCtx;
	return p->nOldOff ? p->nOldOff : sqlite3_column_count(p->pStmt);
}
static int sessionDiffDepth(void *pCtx) {
	return 0;
}


static void sessionDiffHooks(
	sqlite3_session *pSession,
	SessionDiffCtx *pDiffCtx
) {
	pSession->hook.pCtx = (void*)pDiffCtx;
	pSession->hook.xOld = sessionDiffOld;
	pSession->hook.xNew = sessionDiffNew;
	pSession->hook.xCount = sessionDiffCount;
	pSession->hook.xDepth = sessionDiffDepth;
}

static char *sessionExprComparePK(
	int nCol,
	const char *zDb1, const char *zDb2,
	const char *zTab,
	const char **azCol, u8 *abPK
) {
	int i;
	const char *zSep = "";
	char *zRet = 0;

	for (i = 0; i<nCol; i++) {
		if (abPK[i]) {
			zRet = sqlite3_mprintf("%z%s\"%w\".\"%w\".\"%w\"=\"%w\".\"%w\".\"%w\"",
				zRet, zSep, zDb1, zTab, azCol[i], zDb2, zTab, azCol[i]
			);
			zSep = " AND ";
			if (zRet == 0) break;
		}
	}

	return zRet;
}

static char *sessionExprCompareOther(
	int nCol,
	const char *zDb1, const char *zDb2,
	const char *zTab,
	const char **azCol, u8 *abPK
) {
	int i;
	const char *zSep = "";
	char *zRet = 0;
	int bHave = 0;

	for (i = 0; i<nCol; i++) {
		if (abPK[i] == 0) {
			bHave = 1;
			zRet = sqlite3_mprintf(
				"%z%s\"%w\".\"%w\".\"%w\" IS NOT \"%w\".\"%w\".\"%w\"",
				zRet, zSep, zDb1, zTab, azCol[i], zDb2, zTab, azCol[i]
			);
			zSep = " OR ";
			if (zRet == 0) break;
		}
	}

	if (bHave == 0) {
		assert(zRet == 0);
		zRet = sqlite3_mprintf("0");
	}

	return zRet;
}

static char *sessionSelectFindNew(
	int nCol,
	const char *zDb1,      
	const char *zDb2,      
	const char *zTbl,      
	const char *zExpr
) {
	char *zRet = sqlite3_mprintf(
		"SELECT * FROM \"%w\".\"%w\" WHERE NOT EXISTS ("
		"  SELECT 1 FROM \"%w\".\"%w\" WHERE %s"
		")",
		zDb1, zTbl, zDb2, zTbl, zExpr
	);
	return zRet;
}

static int sessionDiffFindNew(
	int op,
	sqlite3_session *pSession,
	SessionTable *pTab,
	const char *zDb1,
	const char *zDb2,
	char *zExpr
) {
	int rc = SQLITE_OK;
	char *zStmt = sessionSelectFindNew(pTab->nCol, zDb1, zDb2, pTab->zName, zExpr);

	if (zStmt == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		sqlite3_stmt *pStmt;
		rc = sqlite3_prepare(pSession->db, zStmt, -1, &pStmt, 0);
		if (rc == SQLITE_OK) {
			SessionDiffCtx *pDiffCtx = (SessionDiffCtx*)pSession->hook.pCtx;
			pDiffCtx->pStmt = pStmt;
			pDiffCtx->nOldOff = 0;
			while (SQLITE_ROW == sqlite3_step(pStmt)) {
				sessionPreupdateOneChange(op, pSession, pTab);
			}
			rc = sqlite3_finalize(pStmt);
		}
		sqlite3_free(zStmt);
	}

	return rc;
}

static int sessionDiffFindModified(
	sqlite3_session *pSession,
	SessionTable *pTab,
	const char *zFrom,
	const char *zExpr
) {
	int rc = SQLITE_OK;

	char *zExpr2 = sessionExprCompareOther(pTab->nCol,
		pSession->zDb, zFrom, pTab->zName, pTab->azCol, pTab->abPK
	);
	if (zExpr2 == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		char *zStmt = sqlite3_mprintf(
			"SELECT * FROM \"%w\".\"%w\", \"%w\".\"%w\" WHERE %s AND (%z)",
			pSession->zDb, pTab->zName, zFrom, pTab->zName, zExpr, zExpr2
		);
		if (zStmt == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			sqlite3_stmt *pStmt;
			rc = sqlite3_prepare(pSession->db, zStmt, -1, &pStmt, 0);

			if (rc == SQLITE_OK) {
				SessionDiffCtx *pDiffCtx = (SessionDiffCtx*)pSession->hook.pCtx;
				pDiffCtx->pStmt = pStmt;
				pDiffCtx->nOldOff = pTab->nCol;
				while (SQLITE_ROW == sqlite3_step(pStmt)) {
					sessionPreupdateOneChange(SQLITE_UPDATE, pSession, pTab);
				}
				rc = sqlite3_finalize(pStmt);
			}
			sqlite3_free(zStmt);
		}
	}

	return rc;
}

SQLITE_API int sqlite3session_diff(
	sqlite3_session *pSession,
	const char *zFrom,
	const char *zTbl,
	char **pzErrMsg
) {
	const char *zDb = pSession->zDb;
	int rc = pSession->rc;
	SessionDiffCtx d;

	memset(&d, 0, sizeof(d));
	sessionDiffHooks(pSession, &d);

	sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));
	if (pzErrMsg) *pzErrMsg = 0;
	if (rc == SQLITE_OK) {
		char *zExpr = 0;
		sqlite3 *db = pSession->db;
		SessionTable *pTo;            

									  
		rc = sessionFindTable(pSession, zTbl, &pTo);
		if (pTo == 0) goto diff_out;
		if (sessionInitTable(pSession, pTo)) {
			rc = pSession->rc;
			goto diff_out;
		}

		
		if (rc == SQLITE_OK) {
			int bHasPk = 0;
			int bMismatch = 0;
			int nCol;                   
			u8 *abPK;
			const char **azCol = 0;
			rc = sessionTableInfo(db, zFrom, zTbl, &nCol, 0, &azCol, &abPK);
			if (rc == SQLITE_OK) {
				if (pTo->nCol != nCol) {
					bMismatch = 1;
				}
				else {
					int i;
					for (i = 0; i<nCol; i++) {
						if (pTo->abPK[i] != abPK[i]) bMismatch = 1;
						if (sqlite3_stricmp(azCol[i], pTo->azCol[i])) bMismatch = 1;
						if (abPK[i]) bHasPk = 1;
					}
				}

			}
			sqlite3_free((char*)azCol);
			if (bMismatch) {
				*pzErrMsg = sqlite3_mprintf("table schemas do not match");
				rc = SQLITE_SCHEMA;
			}
			if (bHasPk == 0) {
				
				goto diff_out;
			}
		}

		if (rc == SQLITE_OK) {
			zExpr = sessionExprComparePK(pTo->nCol,
				zDb, zFrom, pTo->zName, pTo->azCol, pTo->abPK
			);
		}

		
		if (rc == SQLITE_OK) {
			rc = sessionDiffFindNew(SQLITE_INSERT, pSession, pTo, zDb, zFrom, zExpr);
		}

		
		if (rc == SQLITE_OK) {
			rc = sessionDiffFindNew(SQLITE_DELETE, pSession, pTo, zFrom, zDb, zExpr);
		}

		
		if (rc == SQLITE_OK) {
			rc = sessionDiffFindModified(pSession, pTo, zFrom, zExpr);
		}

		sqlite3_free(zExpr);
	}

diff_out:
	sessionPreupdateHooks(pSession);
	sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));
	return rc;
}


SQLITE_API int sqlite3session_create(
	sqlite3 *db,                    
	const char *zDb,                
	sqlite3_session **ppSession     
) {
	sqlite3_session *pNew;          
	sqlite3_session *pOld;          
	int nDb = sqlite3Strlen30(zDb); 

									
	*ppSession = 0;

	
	pNew = (sqlite3_session *)sqlite3_malloc(sizeof(sqlite3_session) + nDb + 1);
	if (!pNew) return SQLITE_NOMEM;
	memset(pNew, 0, sizeof(sqlite3_session));
	pNew->db = db;
	pNew->zDb = (char *)&pNew[1];
	pNew->bEnable = 1;
	memcpy(pNew->zDb, zDb, nDb + 1);
	sessionPreupdateHooks(pNew);

	
	sqlite3_mutex_enter(sqlite3_db_mutex(db));
	pOld = (sqlite3_session*)sqlite3_preupdate_hook(db, xPreUpdate, (void*)pNew);
	pNew->pNext = pOld;
	sqlite3_mutex_leave(sqlite3_db_mutex(db));

	*ppSession = pNew;
	return SQLITE_OK;
}


static void sessionDeleteTable(SessionTable *pList) {
	SessionTable *pNext;
	SessionTable *pTab;

	for (pTab = pList; pTab; pTab = pNext) {
		int i;
		pNext = pTab->pNext;
		for (i = 0; i<pTab->nChange; i++) {
			SessionChange *p;
			SessionChange *pNextChange;
			for (p = pTab->apChange[i]; p; p = pNextChange) {
				pNextChange = p->pNext;
				sqlite3_free(p);
			}
		}
		sqlite3_free((char*)pTab->azCol);  
		sqlite3_free(pTab->apChange);
		sqlite3_free(pTab);
	}
}


SQLITE_API void sqlite3session_delete(sqlite3_session *pSession) {
	sqlite3 *db = pSession->db;
	sqlite3_session *pHead;
	sqlite3_session **pp;

	
	sqlite3_mutex_enter(sqlite3_db_mutex(db));
	pHead = (sqlite3_session*)sqlite3_preupdate_hook(db, 0, 0);
	for (pp = &pHead; ALWAYS((*pp) != 0); pp = &((*pp)->pNext)) {
		if ((*pp) == pSession) {
			*pp = (*pp)->pNext;
			if (pHead) sqlite3_preupdate_hook(db, xPreUpdate, (void*)pHead);
			break;
		}
	}
	sqlite3_mutex_leave(sqlite3_db_mutex(db));

	
	sessionDeleteTable(pSession->pTable);

	
	sqlite3_free(pSession);
}


SQLITE_API void sqlite3session_table_filter(
	sqlite3_session *pSession,
	int(*xFilter)(void*, const char*),
	void *pCtx                      
) {
	pSession->bAutoAttach = 1;
	pSession->pFilterCtx = pCtx;
	pSession->xTableFilter = xFilter;
}


SQLITE_API int sqlite3session_attach(
	sqlite3_session *pSession,      
	const char *zName               
) {
	int rc = SQLITE_OK;
	sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));

	if (!zName) {
		pSession->bAutoAttach = 1;
	}
	else {
		SessionTable *pTab;           
		int nName;                    

									  
		nName = sqlite3Strlen30(zName);
		for (pTab = pSession->pTable; pTab; pTab = pTab->pNext) {
			if (0 == sqlite3_strnicmp(pTab->zName, zName, nName + 1)) break;
		}

		if (!pTab) {
			
			pTab = (SessionTable *)sqlite3_malloc(sizeof(SessionTable) + nName + 1);
			if (!pTab) {
				rc = SQLITE_NOMEM;
			}
			else {
				
				SessionTable **ppTab;
				memset(pTab, 0, sizeof(SessionTable));
				pTab->zName = (char *)&pTab[1];
				memcpy(pTab->zName, zName, nName + 1);
				for (ppTab = &pSession->pTable; *ppTab; ppTab = &(*ppTab)->pNext);
				*ppTab = pTab;
			}
		}
	}

	sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));
	return rc;
}


static int sessionBufferGrow(SessionBuffer *p, int nByte, int *pRc) {
	if (*pRc == SQLITE_OK && p->nAlloc - p->nBuf<nByte) {
		u8 *aNew;
		int nNew = p->nAlloc ? p->nAlloc : 128;
		do {
			nNew = nNew * 2;
		} while (nNew<(p->nBuf + nByte));

		aNew = (u8 *)sqlite3_realloc(p->aBuf, nNew);
		if (0 == aNew) {
			*pRc = SQLITE_NOMEM;
		}
		else {
			p->aBuf = aNew;
			p->nAlloc = nNew;
		}
	}
	return (*pRc != SQLITE_OK);
}


static void sessionAppendValue(SessionBuffer *p, sqlite3_value *pVal, int *pRc) {
	int rc = *pRc;
	if (rc == SQLITE_OK) {
		int nByte = 0;
		rc = sessionSerializeValue(0, pVal, &nByte);
		sessionBufferGrow(p, nByte, &rc);
		if (rc == SQLITE_OK) {
			rc = sessionSerializeValue(&p->aBuf[p->nBuf], pVal, 0);
			p->nBuf += nByte;
		}
		else {
			*pRc = rc;
		}
	}
}


static void sessionAppendByte(SessionBuffer *p, u8 v, int *pRc) {
	if (0 == sessionBufferGrow(p, 1, pRc)) {
		p->aBuf[p->nBuf++] = v;
	}
}


static void sessionAppendVarint(SessionBuffer *p, int v, int *pRc) {
	if (0 == sessionBufferGrow(p, 9, pRc)) {
		p->nBuf += sessionVarintPut(&p->aBuf[p->nBuf], v);
	}
}


static void sessionAppendBlob(
	SessionBuffer *p,
	const u8 *aBlob,
	int nBlob,
	int *pRc
) {
	if (0 == sessionBufferGrow(p, nBlob, pRc)) {
		memcpy(&p->aBuf[p->nBuf], aBlob, nBlob);
		p->nBuf += nBlob;
	}
}


static void sessionAppendStr(
	SessionBuffer *p,
	const char *zStr,
	int *pRc
) {
	int nStr = sqlite3Strlen30(zStr);
	if (0 == sessionBufferGrow(p, nStr, pRc)) {
		memcpy(&p->aBuf[p->nBuf], zStr, nStr);
		p->nBuf += nStr;
	}
}


static void sessionAppendInteger(
	SessionBuffer *p,               
	int iVal,                       
	int *pRc                        
) {
	char aBuf[24];
	sqlite3_snprintf(sizeof(aBuf) - 1, aBuf, "%d", iVal);
	sessionAppendStr(p, aBuf, pRc);
}


static void sessionAppendIdent(
	SessionBuffer *p,               
	const char *zStr,               
	int *pRc                        
) {
	int nStr = sqlite3Strlen30(zStr) * 2 + 2 + 1;
	if (0 == sessionBufferGrow(p, nStr, pRc)) {
		char *zOut = (char *)&p->aBuf[p->nBuf];
		const char *zIn = zStr;
		*zOut++ = '"';
		while (*zIn) {
			if (*zIn == '"') *zOut++ = '"';
			*zOut++ = *(zIn++);
		}
		*zOut++ = '"';
		p->nBuf = (int)((u8 *)zOut - p->aBuf);
	}
}


static void sessionAppendCol(
	SessionBuffer *p,               
	sqlite3_stmt *pStmt,            
	int iCol,                       
	int *pRc                        
) {
	if (*pRc == SQLITE_OK) {
		int eType = sqlite3_column_type(pStmt, iCol);
		sessionAppendByte(p, (u8)eType, pRc);
		if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
			sqlite3_int64 i;
			u8 aBuf[8];
			if (eType == SQLITE_INTEGER) {
				i = sqlite3_column_int64(pStmt, iCol);
			}
			else {
				double r = sqlite3_column_double(pStmt, iCol);
				memcpy(&i, &r, 8);
			}
			sessionPutI64(aBuf, i);
			sessionAppendBlob(p, aBuf, 8, pRc);
		}
		if (eType == SQLITE_BLOB || eType == SQLITE_TEXT) {
			u8 *z;
			int nByte;
			if (eType == SQLITE_BLOB) {
				z = (u8 *)sqlite3_column_blob(pStmt, iCol);
			}
			else {
				z = (u8 *)sqlite3_column_text(pStmt, iCol);
			}
			nByte = sqlite3_column_bytes(pStmt, iCol);
			if (z || (eType == SQLITE_BLOB && nByte == 0)) {
				sessionAppendVarint(p, nByte, pRc);
				sessionAppendBlob(p, z, nByte, pRc);
			}
			else {
				*pRc = SQLITE_NOMEM;
			}
		}
	}
}


static int sessionAppendUpdate(
	SessionBuffer *pBuf,            
	int bPatchset,                  
	sqlite3_stmt *pStmt,            
	SessionChange *p,               
	u8 *abPK                        
) {
	int rc = SQLITE_OK;
	SessionBuffer buf2 = { 0,0,0 }; 
	int bNoop = 1;                
	int nRewind = pBuf->nBuf;     
	int i;                        
	u8 *pCsr = p->aRecord;        

	sessionAppendByte(pBuf, SQLITE_UPDATE, &rc);
	sessionAppendByte(pBuf, p->bIndirect, &rc);
	for (i = 0; i<sqlite3_column_count(pStmt); i++) {
		int bChanged = 0;
		int nAdvance;
		int eType = *pCsr;
		switch (eType) {
		case SQLITE_NULL:
			nAdvance = 1;
			if (sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
				bChanged = 1;
			}
			break;

		case SQLITE_FLOAT:
		case SQLITE_INTEGER: {
			nAdvance = 9;
			if (eType == sqlite3_column_type(pStmt, i)) {
				sqlite3_int64 iVal = sessionGetI64(&pCsr[1]);
				if (eType == SQLITE_INTEGER) {
					if (iVal == sqlite3_column_int64(pStmt, i)) break;
				}
				else {
					double dVal;
					memcpy(&dVal, &iVal, 8);
					if (dVal == sqlite3_column_double(pStmt, i)) break;
				}
			}
			bChanged = 1;
			break;
		}

		default: {
			int nByte;
			int nHdr = 1 + sessionVarintGet(&pCsr[1], &nByte);
			assert(eType == SQLITE_TEXT || eType == SQLITE_BLOB);
			nAdvance = nHdr + nByte;
			if (eType == sqlite3_column_type(pStmt, i)
				&& nByte == sqlite3_column_bytes(pStmt, i)
				&& 0 == memcmp(&pCsr[nHdr], sqlite3_column_blob(pStmt, i), nByte)
				) {
				break;
			}
			bChanged = 1;
		}
		}

		
		if (bChanged) bNoop = 0;

		
		if (bPatchset == 0) {
			if (bChanged || abPK[i]) {
				sessionAppendBlob(pBuf, pCsr, nAdvance, &rc);
			}
			else {
				sessionAppendByte(pBuf, 0, &rc);
			}
		}

		
		if (bChanged || (bPatchset && abPK[i])) {
			sessionAppendCol(&buf2, pStmt, i, &rc);
		}
		else {
			sessionAppendByte(&buf2, 0, &rc);
		}

		pCsr += nAdvance;
	}

	if (bNoop) {
		pBuf->nBuf = nRewind;
	}
	else {
		sessionAppendBlob(pBuf, buf2.aBuf, buf2.nBuf, &rc);
	}
	sqlite3_free(buf2.aBuf);

	return rc;
}


static int sessionAppendDelete(
	SessionBuffer *pBuf,            
	int bPatchset,                  
	SessionChange *p,               
	int nCol,                       
	u8 *abPK                        
) {
	int rc = SQLITE_OK;

	sessionAppendByte(pBuf, SQLITE_DELETE, &rc);
	sessionAppendByte(pBuf, p->bIndirect, &rc);

	if (bPatchset == 0) {
		sessionAppendBlob(pBuf, p->aRecord, p->nRecord, &rc);
	}
	else {
		int i;
		u8 *a = p->aRecord;
		for (i = 0; i<nCol; i++) {
			u8 *pStart = a;
			int eType = *a++;

			switch (eType) {
			case 0:
			case SQLITE_NULL:
				assert(abPK[i] == 0);
				break;

			case SQLITE_FLOAT:
			case SQLITE_INTEGER:
				a += 8;
				break;

			default: {
				int n;
				a += sessionVarintGet(a, &n);
				a += n;
				break;
			}
			}
			if (abPK[i]) {
				sessionAppendBlob(pBuf, pStart, (int)(a - pStart), &rc);
			}
		}
		assert((a - p->aRecord) == p->nRecord);
	}

	return rc;
}


static int sessionSelectStmt(
	sqlite3 *db,                    
	const char *zDb,                
	const char *zTab,               
	int nCol,                       
	const char **azCol,             
	u8 *abPK,                       
	sqlite3_stmt **ppStmt           
) {
	int rc = SQLITE_OK;
	int i;
	const char *zSep = "";
	SessionBuffer buf = { 0, 0, 0 };

	sessionAppendStr(&buf, "SELECT * FROM ", &rc);
	sessionAppendIdent(&buf, zDb, &rc);
	sessionAppendStr(&buf, ".", &rc);
	sessionAppendIdent(&buf, zTab, &rc);
	sessionAppendStr(&buf, " WHERE ", &rc);
	for (i = 0; i<nCol; i++) {
		if (abPK[i]) {
			sessionAppendStr(&buf, zSep, &rc);
			sessionAppendIdent(&buf, azCol[i], &rc);
			sessionAppendStr(&buf, " = ?", &rc);
			sessionAppendInteger(&buf, i + 1, &rc);
			zSep = " AND ";
		}
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, ppStmt, 0);
	}
	sqlite3_free(buf.aBuf);
	return rc;
}


static int sessionSelectBind(
	sqlite3_stmt *pSelect,          
	int nCol,                       
	u8 *abPK,                       
	SessionChange *pChange          
) {
	int i;
	int rc = SQLITE_OK;
	u8 *a = pChange->aRecord;

	for (i = 0; i<nCol && rc == SQLITE_OK; i++) {
		int eType = *a++;

		switch (eType) {
		case 0:
		case SQLITE_NULL:
			assert(abPK[i] == 0);
			break;

		case SQLITE_INTEGER: {
			if (abPK[i]) {
				i64 iVal = sessionGetI64(a);
				rc = sqlite3_bind_int64(pSelect, i + 1, iVal);
			}
			a += 8;
			break;
		}

		case SQLITE_FLOAT: {
			if (abPK[i]) {
				double rVal;
				i64 iVal = sessionGetI64(a);
				memcpy(&rVal, &iVal, 8);
				rc = sqlite3_bind_double(pSelect, i + 1, rVal);
			}
			a += 8;
			break;
		}

		case SQLITE_TEXT: {
			int n;
			a += sessionVarintGet(a, &n);
			if (abPK[i]) {
				rc = sqlite3_bind_text(pSelect, i + 1, (char *)a, n, SQLITE_TRANSIENT);
			}
			a += n;
			break;
		}

		default: {
			int n;
			assert(eType == SQLITE_BLOB);
			a += sessionVarintGet(a, &n);
			if (abPK[i]) {
				rc = sqlite3_bind_blob(pSelect, i + 1, a, n, SQLITE_TRANSIENT);
			}
			a += n;
			break;
		}
		}
	}

	return rc;
}


static void sessionAppendTableHdr(
	SessionBuffer *pBuf,            
	int bPatchset,                  
	SessionTable *pTab,             
	int *pRc                        
) {
	
	sessionAppendByte(pBuf, (bPatchset ? 'P' : 'T'), pRc);
	sessionAppendVarint(pBuf, pTab->nCol, pRc);
	sessionAppendBlob(pBuf, pTab->abPK, pTab->nCol, pRc);
	sessionAppendBlob(pBuf, (u8 *)pTab->zName, (int)strlen(pTab->zName) + 1, pRc);
}


static int sessionGenerateChangeset(
	sqlite3_session *pSession,      
	int bPatchset,                  
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut,                     
	int *pnChangeset,               
	void **ppChangeset              
) {
	sqlite3 *db = pSession->db;     
	SessionTable *pTab;             
	SessionBuffer buf = { 0,0,0 };    
	int rc;                         

	assert(xOutput == 0 || (pnChangeset == 0 && ppChangeset == 0));

	
	if (xOutput == 0) {
		*pnChangeset = 0;
		*ppChangeset = 0;
	}

	if (pSession->rc) return pSession->rc;
	rc = sqlite3_exec(pSession->db, "SAVEPOINT changeset", 0, 0, 0);
	if (rc != SQLITE_OK) return rc;

	sqlite3_mutex_enter(sqlite3_db_mutex(db));

	for (pTab = pSession->pTable; rc == SQLITE_OK && pTab; pTab = pTab->pNext) {
		if (pTab->nEntry) {
			const char *zName = pTab->zName;
			int nCol;                   
			u8 *abPK;                   
			const char **azCol = 0;     
			int i;                      
			sqlite3_stmt *pSel = 0;     
			int nRewind = buf.nBuf;     
			int nNoop;                  

										
			rc = sessionTableInfo(db, pSession->zDb, zName, &nCol, 0, &azCol, &abPK);
			if (!rc && (pTab->nCol != nCol || memcmp(abPK, pTab->abPK, nCol))) {
				rc = SQLITE_SCHEMA;
			}

			
			sessionAppendTableHdr(&buf, bPatchset, pTab, &rc);

			
			if (rc == SQLITE_OK) {
				rc = sessionSelectStmt(
					db, pSession->zDb, zName, nCol, azCol, abPK, &pSel);
			}

			nNoop = buf.nBuf;
			for (i = 0; i<pTab->nChange && rc == SQLITE_OK; i++) {
				SessionChange *p;         

				for (p = pTab->apChange[i]; rc == SQLITE_OK && p; p = p->pNext) {
					rc = sessionSelectBind(pSel, nCol, abPK, p);
					if (rc != SQLITE_OK) continue;
					if (sqlite3_step(pSel) == SQLITE_ROW) {
						if (p->op == SQLITE_INSERT) {
							int iCol;
							sessionAppendByte(&buf, SQLITE_INSERT, &rc);
							sessionAppendByte(&buf, p->bIndirect, &rc);
							for (iCol = 0; iCol<nCol; iCol++) {
								sessionAppendCol(&buf, pSel, iCol, &rc);
							}
						}
						else {
							rc = sessionAppendUpdate(&buf, bPatchset, pSel, p, abPK);
						}
					}
					else if (p->op != SQLITE_INSERT) {
						rc = sessionAppendDelete(&buf, bPatchset, p, nCol, abPK);
					}
					if (rc == SQLITE_OK) {
						rc = sqlite3_reset(pSel);
					}

					
					if (xOutput
						&& rc == SQLITE_OK
						&& buf.nBuf>nNoop
						&& buf.nBuf>SESSIONS_STRM_CHUNK_SIZE
						) {
						rc = xOutput(pOut, (void*)buf.aBuf, buf.nBuf);
						nNoop = -1;
						buf.nBuf = 0;
					}

				}
			}

			sqlite3_finalize(pSel);
			if (buf.nBuf == nNoop) {
				buf.nBuf = nRewind;
			}
			sqlite3_free((char*)azCol);  
		}
	}

	if (rc == SQLITE_OK) {
		if (xOutput == 0) {
			*pnChangeset = buf.nBuf;
			*ppChangeset = buf.aBuf;
			buf.aBuf = 0;
		}
		else if (buf.nBuf>0) {
			rc = xOutput(pOut, (void*)buf.aBuf, buf.nBuf);
		}
	}

	sqlite3_free(buf.aBuf);
	sqlite3_exec(db, "RELEASE changeset", 0, 0, 0);
	sqlite3_mutex_leave(sqlite3_db_mutex(db));
	return rc;
}


SQLITE_API int sqlite3session_changeset(
	sqlite3_session *pSession,      
	int *pnChangeset,               
	void **ppChangeset              
) {
	return sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset, ppChangeset);
}


SQLITE_API int sqlite3session_changeset_strm(
	sqlite3_session *pSession,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut
) {
	return sessionGenerateChangeset(pSession, 0, xOutput, pOut, 0, 0);
}


SQLITE_API int sqlite3session_patchset_strm(
	sqlite3_session *pSession,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut
) {
	return sessionGenerateChangeset(pSession, 1, xOutput, pOut, 0, 0);
}


SQLITE_API int sqlite3session_patchset(
	sqlite3_session *pSession,      
	int *pnPatchset,                
	void **ppPatchset               
) {
	return sessionGenerateChangeset(pSession, 1, 0, 0, pnPatchset, ppPatchset);
}


SQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable) {
	int ret;
	sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));
	if (bEnable >= 0) {
		pSession->bEnable = bEnable;
	}
	ret = pSession->bEnable;
	sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));
	return ret;
}


SQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect) {
	int ret;
	sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));
	if (bIndirect >= 0) {
		pSession->bIndirect = bIndirect;
	}
	ret = pSession->bIndirect;
	sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));
	return ret;
}


SQLITE_API int sqlite3session_isempty(sqlite3_session *pSession) {
	int ret = 0;
	SessionTable *pTab;

	sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));
	for (pTab = pSession->pTable; pTab && ret == 0; pTab = pTab->pNext) {
		ret = (pTab->nEntry>0);
	}
	sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));

	return (ret == 0);
}


static int sessionChangesetStart(
	sqlite3_changeset_iter **pp,    
	int(*xInput)(void *pIn, void *pData, int *pnData),
	void *pIn,
	int nChangeset,                 
	void *pChangeset                
) {
	sqlite3_changeset_iter *pRet;   
	int nByte;                      

	assert(xInput == 0 || (pChangeset == 0 && nChangeset == 0));

	
	*pp = 0;

	
	nByte = sizeof(sqlite3_changeset_iter);
	pRet = (sqlite3_changeset_iter *)sqlite3_malloc(nByte);
	if (!pRet) return SQLITE_NOMEM;
	memset(pRet, 0, sizeof(sqlite3_changeset_iter));
	pRet->in.aData = (u8 *)pChangeset;
	pRet->in.nData = nChangeset;
	pRet->in.xInput = xInput;
	pRet->in.pIn = pIn;
	pRet->in.bEof = (xInput ? 0 : 1);

	
	*pp = pRet;
	return SQLITE_OK;
}


SQLITE_API int sqlite3changeset_start(
	sqlite3_changeset_iter **pp,    
	int nChangeset,                 
	void *pChangeset                
) {
	return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset);
}


SQLITE_API int sqlite3changeset_start_strm(
	sqlite3_changeset_iter **pp,    
	int(*xInput)(void *pIn, void *pData, int *pnData),
	void *pIn
) {
	return sessionChangesetStart(pp, xInput, pIn, 0, 0);
}


static void sessionDiscardData(SessionInput *pIn) {
	if (pIn->bEof && pIn->xInput && pIn->iNext >= SESSIONS_STRM_CHUNK_SIZE) {
		int nMove = pIn->buf.nBuf - pIn->iNext;
		assert(nMove >= 0);
		if (nMove>0) {
			memmove(pIn->buf.aBuf, &pIn->buf.aBuf[pIn->iNext], nMove);
		}
		pIn->buf.nBuf -= pIn->iNext;
		pIn->iNext = 0;
		pIn->nData = pIn->buf.nBuf;
	}
}


static int sessionInputBuffer(SessionInput *pIn, int nByte) {
	int rc = SQLITE_OK;
	if (pIn->xInput) {
		while (!pIn->bEof && (pIn->iNext + nByte) >= pIn->nData && rc == SQLITE_OK) {
			int nNew = SESSIONS_STRM_CHUNK_SIZE;

			if (pIn->bNoDiscard == 0) sessionDiscardData(pIn);
			if (SQLITE_OK == sessionBufferGrow(&pIn->buf, nNew, &rc)) {
				rc = pIn->xInput(pIn->pIn, &pIn->buf.aBuf[pIn->buf.nBuf], &nNew);
				if (nNew == 0) {
					pIn->bEof = 1;
				}
				else {
					pIn->buf.nBuf += nNew;
				}
			}

			pIn->aData = pIn->buf.aBuf;
			pIn->nData = pIn->buf.nBuf;
		}
	}
	return rc;
}


static void sessionSkipRecord(
	u8 **ppRec,                     
	int nCol                        
) {
	u8 *aRec = *ppRec;
	int i;
	for (i = 0; i<nCol; i++) {
		int eType = *aRec++;
		if (eType == SQLITE_TEXT || eType == SQLITE_BLOB) {
			int nByte;
			aRec += sessionVarintGet((u8*)aRec, &nByte);
			aRec += nByte;
		}
		else if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
			aRec += 8;
		}
	}

	*ppRec = aRec;
}


static int sessionValueSetStr(
	sqlite3_value *pVal,            
	u8 *aData,                      
	int nData,                      
	u8 enc                          
) {
	
	u8 *aCopy = sqlite3_malloc(nData + 1);
	if (aCopy == 0) return SQLITE_NOMEM;
	memcpy(aCopy, aData, nData);
	sqlite3ValueSetStr(pVal, nData, (char*)aCopy, enc, sqlite3_free);
	return SQLITE_OK;
}


static int sessionReadRecord(
	SessionInput *pIn,              
	int nCol,                       
	u8 *abPK,                       
	sqlite3_value **apOut           
) {
	int i;                          
	int rc = SQLITE_OK;

	for (i = 0; i<nCol && rc == SQLITE_OK; i++) {
		int eType = 0;                
		if (abPK && abPK[i] == 0) continue;
		rc = sessionInputBuffer(pIn, 9);
		if (rc == SQLITE_OK) {
			eType = pIn->aData[pIn->iNext++];
		}

		assert(apOut[i] == 0);
		if (eType) {
			apOut[i] = sqlite3ValueNew(0);
			if (!apOut[i]) rc = SQLITE_NOMEM;
		}

		if (rc == SQLITE_OK) {
			u8 *aVal = &pIn->aData[pIn->iNext];
			if (eType == SQLITE_TEXT || eType == SQLITE_BLOB) {
				int nByte;
				pIn->iNext += sessionVarintGet(aVal, &nByte);
				rc = sessionInputBuffer(pIn, nByte);
				if (rc == SQLITE_OK) {
					u8 enc = (eType == SQLITE_TEXT ? SQLITE_UTF8 : 0);
					rc = sessionValueSetStr(apOut[i], &pIn->aData[pIn->iNext], nByte, enc);
				}
				pIn->iNext += nByte;
			}
			if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
				sqlite3_int64 v = sessionGetI64(aVal);
				if (eType == SQLITE_INTEGER) {
					sqlite3VdbeMemSetInt64(apOut[i], v);
				}
				else {
					double d;
					memcpy(&d, &v, 8);
					sqlite3VdbeMemSetDouble(apOut[i], d);
				}
				pIn->iNext += 8;
			}
		}
	}

	return rc;
}


static int sessionChangesetBufferTblhdr(SessionInput *pIn, int *pnByte) {
	int rc = SQLITE_OK;
	int nCol = 0;
	int nRead = 0;

	rc = sessionInputBuffer(pIn, 9);
	if (rc == SQLITE_OK) {
		nRead += sessionVarintGet(&pIn->aData[pIn->iNext + nRead], &nCol);
		rc = sessionInputBuffer(pIn, nRead + nCol + 100);
		nRead += nCol;
	}

	while (rc == SQLITE_OK) {
		while ((pIn->iNext + nRead)<pIn->nData && pIn->aData[pIn->iNext + nRead]) {
			nRead++;
		}
		if ((pIn->iNext + nRead)<pIn->nData) break;
		rc = sessionInputBuffer(pIn, nRead + 100);
	}
	*pnByte = nRead + 1;
	return rc;
}


static int sessionChangesetBufferRecord(
	SessionInput *pIn,              
	int nCol,                       
	int *pnByte                     
) {
	int rc = SQLITE_OK;
	int nByte = 0;
	int i;
	for (i = 0; rc == SQLITE_OK && i<nCol; i++) {
		int eType;
		rc = sessionInputBuffer(pIn, nByte + 10);
		if (rc == SQLITE_OK) {
			eType = pIn->aData[pIn->iNext + nByte++];
			if (eType == SQLITE_TEXT || eType == SQLITE_BLOB) {
				int n;
				nByte += sessionVarintGet(&pIn->aData[pIn->iNext + nByte], &n);
				nByte += n;
				rc = sessionInputBuffer(pIn, nByte);
			}
			else if (eType == SQLITE_INTEGER || eType == SQLITE_FLOAT) {
				nByte += 8;
			}
		}
	}
	*pnByte = nByte;
	return rc;
}


static int sessionChangesetReadTblhdr(sqlite3_changeset_iter *p) {
	int rc;
	int nCopy;
	assert(p->rc == SQLITE_OK);

	rc = sessionChangesetBufferTblhdr(&p->in, &nCopy);
	if (rc == SQLITE_OK) {
		int nByte;
		int nVarint;
		nVarint = sessionVarintGet(&p->in.aData[p->in.iNext], &p->nCol);
		nCopy -= nVarint;
		p->in.iNext += nVarint;
		nByte = p->nCol * sizeof(sqlite3_value*) * 2 + nCopy;
		p->tblhdr.nBuf = 0;
		sessionBufferGrow(&p->tblhdr, nByte, &rc);
	}

	if (rc == SQLITE_OK) {
		int iPK = sizeof(sqlite3_value*)*p->nCol * 2;
		memset(p->tblhdr.aBuf, 0, iPK);
		memcpy(&p->tblhdr.aBuf[iPK], &p->in.aData[p->in.iNext], nCopy);
		p->in.iNext += nCopy;
	}

	p->apValue = (sqlite3_value**)p->tblhdr.aBuf;
	p->abPK = (u8*)&p->apValue[p->nCol * 2];
	p->zTab = (char*)&p->abPK[p->nCol];
	return (p->rc = rc);
}


static int sessionChangesetNext(
	sqlite3_changeset_iter *p,      
	u8 **paRec,                     
	int *pnRec                      
) {
	int i;
	u8 op;

	assert((paRec == 0 && pnRec == 0) || (paRec && pnRec));

	
	if (p->rc != SQLITE_OK) return p->rc;

	
	if (p->apValue) {
		for (i = 0; i<p->nCol * 2; i++) {
			sqlite3ValueFree(p->apValue[i]);
		}
		memset(p->apValue, 0, sizeof(sqlite3_value*)*p->nCol * 2);
	}

	
	p->rc = sessionInputBuffer(&p->in, 2);
	if (p->rc != SQLITE_OK) return p->rc;

	
	if (p->in.iNext >= p->in.nData) {
		return SQLITE_DONE;
	}

	sessionDiscardData(&p->in);
	p->in.iCurrent = p->in.iNext;

	op = p->in.aData[p->in.iNext++];
	if (op == 'T' || op == 'P') {
		p->bPatchset = (op == 'P');
		if (sessionChangesetReadTblhdr(p)) return p->rc;
		if ((p->rc = sessionInputBuffer(&p->in, 2))) return p->rc;
		p->in.iCurrent = p->in.iNext;
		op = p->in.aData[p->in.iNext++];
	}

	p->op = op;
	p->bIndirect = p->in.aData[p->in.iNext++];
	if (p->op != SQLITE_UPDATE && p->op != SQLITE_DELETE && p->op != SQLITE_INSERT) {
		return (p->rc = SQLITE_CORRUPT_BKPT);
	}

	if (paRec) {
		int nVal;                     
		if (p->bPatchset == 0 && op == SQLITE_UPDATE) {
			nVal = p->nCol * 2;
		}
		else if (p->bPatchset && op == SQLITE_DELETE) {
			nVal = 0;
			for (i = 0; i<p->nCol; i++) if (p->abPK[i]) nVal++;
		}
		else {
			nVal = p->nCol;
		}
		p->rc = sessionChangesetBufferRecord(&p->in, nVal, pnRec);
		if (p->rc != SQLITE_OK) return p->rc;
		*paRec = &p->in.aData[p->in.iNext];
		p->in.iNext += *pnRec;
	}
	else {

		
		if (p->op != SQLITE_INSERT && (p->bPatchset == 0 || p->op == SQLITE_DELETE)) {
			u8 *abPK = p->bPatchset ? p->abPK : 0;
			p->rc = sessionReadRecord(&p->in, p->nCol, abPK, p->apValue);
			if (p->rc != SQLITE_OK) return p->rc;
		}

		
		if (p->op != SQLITE_DELETE) {
			p->rc = sessionReadRecord(&p->in, p->nCol, 0, &p->apValue[p->nCol]);
			if (p->rc != SQLITE_OK) return p->rc;
		}

		if (p->bPatchset && p->op == SQLITE_UPDATE) {
			
			for (i = 0; i<p->nCol; i++) {
				assert(p->apValue[i] == 0);
				assert(p->abPK[i] == 0 || p->apValue[i + p->nCol]);
				if (p->abPK[i]) {
					p->apValue[i] = p->apValue[i + p->nCol];
					p->apValue[i + p->nCol] = 0;
				}
			}
		}
	}

	return SQLITE_ROW;
}


SQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *p) {
	return sessionChangesetNext(p, 0, 0);
}


SQLITE_API int sqlite3changeset_op(
	sqlite3_changeset_iter *pIter,  
	const char **pzTab,             
	int *pnCol,                     
	int *pOp,                       
	int *pbIndirect                 
) {
	*pOp = pIter->op;
	*pnCol = pIter->nCol;
	*pzTab = pIter->zTab;
	if (pbIndirect) *pbIndirect = pIter->bIndirect;
	return SQLITE_OK;
}


SQLITE_API int sqlite3changeset_pk(
	sqlite3_changeset_iter *pIter,  
	unsigned char **pabPK,          
	int *pnCol                      
) {
	*pabPK = pIter->abPK;
	if (pnCol) *pnCol = pIter->nCol;
	return SQLITE_OK;
}


SQLITE_API int sqlite3changeset_old(
	sqlite3_changeset_iter *pIter,  
	int iVal,                       
	sqlite3_value **ppValue         
) {
	if (pIter->op != SQLITE_UPDATE && pIter->op != SQLITE_DELETE) {
		return SQLITE_MISUSE;
	}
	if (iVal<0 || iVal >= pIter->nCol) {
		return SQLITE_RANGE;
	}
	*ppValue = pIter->apValue[iVal];
	return SQLITE_OK;
}


SQLITE_API int sqlite3changeset_new(
	sqlite3_changeset_iter *pIter,  
	int iVal,                       
	sqlite3_value **ppValue         
) {
	if (pIter->op != SQLITE_UPDATE && pIter->op != SQLITE_INSERT) {
		return SQLITE_MISUSE;
	}
	if (iVal<0 || iVal >= pIter->nCol) {
		return SQLITE_RANGE;
	}
	*ppValue = pIter->apValue[pIter->nCol + iVal];
	return SQLITE_OK;
}


#define sessionChangesetNew(pIter, iVal) (pIter)->apValue[(pIter)->nCol+(iVal)]
#define sessionChangesetOld(pIter, iVal) (pIter)->apValue[(iVal)]


SQLITE_API int sqlite3changeset_conflict(
	sqlite3_changeset_iter *pIter,  
	int iVal,                       
	sqlite3_value **ppValue         
) {
	if (!pIter->pConflict) {
		return SQLITE_MISUSE;
	}
	if (iVal<0 || iVal >= sqlite3_column_count(pIter->pConflict)) {
		return SQLITE_RANGE;
	}
	*ppValue = sqlite3_column_value(pIter->pConflict, iVal);
	return SQLITE_OK;
}


SQLITE_API int sqlite3changeset_fk_conflicts(
	sqlite3_changeset_iter *pIter,  
	int *pnOut                      
) {
	if (pIter->pConflict || pIter->apValue) {
		return SQLITE_MISUSE;
	}
	*pnOut = pIter->nCol;
	return SQLITE_OK;
}



SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *p) {
	int rc = SQLITE_OK;
	if (p) {
		int i;                        
		rc = p->rc;
		if (p->apValue) {
			for (i = 0; i<p->nCol * 2; i++) sqlite3ValueFree(p->apValue[i]);
		}
		sqlite3_free(p->tblhdr.aBuf);
		sqlite3_free(p->in.buf.aBuf);
		sqlite3_free(p);
	}
	return rc;
}

static int sessionChangesetInvert(
	SessionInput *pInput,           
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut,
	int *pnInverted,                
	void **ppInverted               
) {
	int rc = SQLITE_OK;             
	SessionBuffer sOut;             
	int nCol = 0;                   
	u8 *abPK = 0;                   
	sqlite3_value **apVal = 0;      
	SessionBuffer sPK = { 0, 0, 0 };  

									  
	memset(&sOut, 0, sizeof(SessionBuffer));

	
	if (ppInverted) {
		*ppInverted = 0;
		*pnInverted = 0;
	}

	while (1) {
		u8 eType;

		
		if ((rc = sessionInputBuffer(pInput, 2))) goto finished_invert;
		if (pInput->iNext >= pInput->nData) break;
		eType = pInput->aData[pInput->iNext];

		switch (eType) {
		case 'T': {
			
			int nByte;
			int nVar;
			pInput->iNext++;
			if ((rc = sessionChangesetBufferTblhdr(pInput, &nByte))) {
				goto finished_invert;
			}
			nVar = sessionVarintGet(&pInput->aData[pInput->iNext], &nCol);
			sPK.nBuf = 0;
			sessionAppendBlob(&sPK, &pInput->aData[pInput->iNext + nVar], nCol, &rc);
			sessionAppendByte(&sOut, eType, &rc);
			sessionAppendBlob(&sOut, &pInput->aData[pInput->iNext], nByte, &rc);
			if (rc) goto finished_invert;

			pInput->iNext += nByte;
			sqlite3_free(apVal);
			apVal = 0;
			abPK = sPK.aBuf;
			break;
		}

		case SQLITE_INSERT:
		case SQLITE_DELETE: {
			int nByte;
			int bIndirect = pInput->aData[pInput->iNext + 1];
			int eType2 = (eType == SQLITE_DELETE ? SQLITE_INSERT : SQLITE_DELETE);
			pInput->iNext += 2;
			assert(rc == SQLITE_OK);
			rc = sessionChangesetBufferRecord(pInput, nCol, &nByte);
			sessionAppendByte(&sOut, eType2, &rc);
			sessionAppendByte(&sOut, bIndirect, &rc);
			sessionAppendBlob(&sOut, &pInput->aData[pInput->iNext], nByte, &rc);
			pInput->iNext += nByte;
			if (rc) goto finished_invert;
			break;
		}

		case SQLITE_UPDATE: {
			int iCol;

			if (0 == apVal) {
				apVal = (sqlite3_value **)sqlite3_malloc(sizeof(apVal[0])*nCol * 2);
				if (0 == apVal) {
					rc = SQLITE_NOMEM;
					goto finished_invert;
				}
				memset(apVal, 0, sizeof(apVal[0])*nCol * 2);
			}

			
			sessionAppendByte(&sOut, eType, &rc);
			sessionAppendByte(&sOut, pInput->aData[pInput->iNext + 1], &rc);

			
			pInput->iNext += 2;
			rc = sessionReadRecord(pInput, nCol, 0, &apVal[0]);
			if (rc == SQLITE_OK) {
				rc = sessionReadRecord(pInput, nCol, 0, &apVal[nCol]);
			}

			
			for (iCol = 0; iCol<nCol; iCol++) {
				sqlite3_value *pVal = apVal[iCol + (abPK[iCol] ? 0 : nCol)];
				sessionAppendValue(&sOut, pVal, &rc);
			}

			
			for (iCol = 0; iCol<nCol; iCol++) {
				sqlite3_value *pVal = (abPK[iCol] ? 0 : apVal[iCol]);
				sessionAppendValue(&sOut, pVal, &rc);
			}

			for (iCol = 0; iCol<nCol * 2; iCol++) {
				sqlite3ValueFree(apVal[iCol]);
			}
			memset(apVal, 0, sizeof(apVal[0])*nCol * 2);
			if (rc != SQLITE_OK) {
				goto finished_invert;
			}

			break;
		}

		default:
			rc = SQLITE_CORRUPT_BKPT;
			goto finished_invert;
		}

		assert(rc == SQLITE_OK);
		if (xOutput && sOut.nBuf >= SESSIONS_STRM_CHUNK_SIZE) {
			rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);
			sOut.nBuf = 0;
			if (rc != SQLITE_OK) goto finished_invert;
		}
	}

	assert(rc == SQLITE_OK);
	if (pnInverted) {
		*pnInverted = sOut.nBuf;
		*ppInverted = sOut.aBuf;
		sOut.aBuf = 0;
	}
	else if (sOut.nBuf>0) {
		rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);
	}

finished_invert:
	sqlite3_free(sOut.aBuf);
	sqlite3_free(apVal);
	sqlite3_free(sPK.aBuf);
	return rc;
}



SQLITE_API int sqlite3changeset_invert(
	int nChangeset,                 
	const void *pChangeset,         
	int *pnInverted,                
	void **ppInverted               
) {
	SessionInput sInput;

	
	memset(&sInput, 0, sizeof(SessionInput));
	sInput.nData = nChangeset;
	sInput.aData = (u8*)pChangeset;

	return sessionChangesetInvert(&sInput, 0, 0, pnInverted, ppInverted);
}


SQLITE_API int sqlite3changeset_invert_strm(
	int(*xInput)(void *pIn, void *pData, int *pnData),
	void *pIn,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut
) {
	SessionInput sInput;
	int rc;

	
	memset(&sInput, 0, sizeof(SessionInput));
	sInput.xInput = xInput;
	sInput.pIn = pIn;

	rc = sessionChangesetInvert(&sInput, xOutput, pOut, 0, 0);
	sqlite3_free(sInput.buf.aBuf);
	return rc;
}

typedef struct SessionApplyCtx SessionApplyCtx;
struct SessionApplyCtx {
	sqlite3 *db;
	sqlite3_stmt *pDelete;          
	sqlite3_stmt *pUpdate;          
	sqlite3_stmt *pInsert;          
	sqlite3_stmt *pSelect;          
	int nCol;                       
	const char **azCol;             
	u8 *abPK;                       

	int bDeferConstraints;          
	SessionBuffer constraints;      
};


static int sessionDeleteRow(
	sqlite3 *db,                    
	const char *zTab,               
	SessionApplyCtx *p              
) {
	int i;
	const char *zSep = "";
	int rc = SQLITE_OK;
	SessionBuffer buf = { 0, 0, 0 };
	int nPk = 0;

	sessionAppendStr(&buf, "DELETE FROM ", &rc);
	sessionAppendIdent(&buf, zTab, &rc);
	sessionAppendStr(&buf, " WHERE ", &rc);

	for (i = 0; i<p->nCol; i++) {
		if (p->abPK[i]) {
			nPk++;
			sessionAppendStr(&buf, zSep, &rc);
			sessionAppendIdent(&buf, p->azCol[i], &rc);
			sessionAppendStr(&buf, " = ?", &rc);
			sessionAppendInteger(&buf, i + 1, &rc);
			zSep = " AND ";
		}
	}

	if (nPk<p->nCol) {
		sessionAppendStr(&buf, " AND (?", &rc);
		sessionAppendInteger(&buf, p->nCol + 1, &rc);
		sessionAppendStr(&buf, " OR ", &rc);

		zSep = "";
		for (i = 0; i<p->nCol; i++) {
			if (!p->abPK[i]) {
				sessionAppendStr(&buf, zSep, &rc);
				sessionAppendIdent(&buf, p->azCol[i], &rc);
				sessionAppendStr(&buf, " IS ?", &rc);
				sessionAppendInteger(&buf, i + 1, &rc);
				zSep = "AND ";
			}
		}
		sessionAppendStr(&buf, ")", &rc);
	}

	if (rc == SQLITE_OK) {
		rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pDelete, 0);
	}
	sqlite3_free(buf.aBuf);

	return rc;
}


static int sessionUpdateRow(
	sqlite3 *db,                    
	const char *zTab,               
	SessionApplyCtx *p              
) {
	int rc = SQLITE_OK;
	int i;
	const char *zSep = "";
	SessionBuffer buf = { 0, 0, 0 };

	
	sessionAppendStr(&buf, "UPDATE ", &rc);
	sessionAppendIdent(&buf, zTab, &rc);
	sessionAppendStr(&buf, " SET ", &rc);

	
	for (i = 0; i<p->nCol; i++) {
		sessionAppendStr(&buf, zSep, &rc);
		sessionAppendIdent(&buf, p->azCol[i], &rc);
		sessionAppendStr(&buf, " = CASE WHEN ?", &rc);
		sessionAppendInteger(&buf, i * 3 + 2, &rc);
		sessionAppendStr(&buf, " THEN ?", &rc);
		sessionAppendInteger(&buf, i * 3 + 3, &rc);
		sessionAppendStr(&buf, " ELSE ", &rc);
		sessionAppendIdent(&buf, p->azCol[i], &rc);
		sessionAppendStr(&buf, " END", &rc);
		zSep = ", ";
	}

	
	sessionAppendStr(&buf, " WHERE ", &rc);
	for (i = 0; i<p->nCol; i++) {
		if (p->abPK[i]) {
			sessionAppendIdent(&buf, p->azCol[i], &rc);
			sessionAppendStr(&buf, " = ?", &rc);
			sessionAppendInteger(&buf, i * 3 + 1, &rc);
			sessionAppendStr(&buf, " AND ", &rc);
		}
	}

	
	sessionAppendStr(&buf, " (?", &rc);
	sessionAppendInteger(&buf, p->nCol * 3 + 1, &rc);
	sessionAppendStr(&buf, " OR 1", &rc);
	for (i = 0; i<p->nCol; i++) {
		if (!p->abPK[i]) {
			sessionAppendStr(&buf, " AND (?", &rc);
			sessionAppendInteger(&buf, i * 3 + 2, &rc);
			sessionAppendStr(&buf, "=0 OR ", &rc);
			sessionAppendIdent(&buf, p->azCol[i], &rc);
			sessionAppendStr(&buf, " IS ?", &rc);
			sessionAppendInteger(&buf, i * 3 + 1, &rc);
			sessionAppendStr(&buf, ")", &rc);
		}
	}
	sessionAppendStr(&buf, ")", &rc);

	if (rc == SQLITE_OK) {
		rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pUpdate, 0);
	}
	sqlite3_free(buf.aBuf);

	return rc;
}


static int sessionSelectRow(
	sqlite3 *db,                    
	const char *zTab,               
	SessionApplyCtx *p              
) {
	return sessionSelectStmt(
		db, "main", zTab, p->nCol, p->azCol, p->abPK, &p->pSelect);
}


static int sessionInsertRow(
	sqlite3 *db,                    
	const char *zTab,               
	SessionApplyCtx *p              
) {
	int rc = SQLITE_OK;
	int i;
	SessionBuffer buf = { 0, 0, 0 };

	sessionAppendStr(&buf, "INSERT INTO main.", &rc);
	sessionAppendIdent(&buf, zTab, &rc);
	sessionAppendStr(&buf, " VALUES(?", &rc);
	for (i = 1; i<p->nCol; i++) {
		sessionAppendStr(&buf, ", ?", &rc);
	}
	sessionAppendStr(&buf, ")", &rc);

	if (rc == SQLITE_OK) {
		rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pInsert, 0);
	}
	sqlite3_free(buf.aBuf);
	return rc;
}


static int sessionBindValue(
	sqlite3_stmt *pStmt,            
	int i,                          
	sqlite3_value *pVal             
) {
	int eType = sqlite3_value_type(pVal);
	
	if ((eType == SQLITE_TEXT || eType == SQLITE_BLOB) && pVal->z == 0) {
		
		return SQLITE_NOMEM;
	}
	return sqlite3_bind_value(pStmt, i, pVal);
}


static int sessionBindRow(
	sqlite3_changeset_iter *pIter,  
	int(*xValue)(sqlite3_changeset_iter *, int, sqlite3_value **),
	int nCol,                       
	u8 *abPK,                       
	sqlite3_stmt *pStmt             
) {
	int i;
	int rc = SQLITE_OK;

	
	assert(xValue == sqlite3changeset_old || xValue == sqlite3changeset_new);

	for (i = 0; rc == SQLITE_OK && i<nCol; i++) {
		if (!abPK || abPK[i]) {
			sqlite3_value *pVal;
			(void)xValue(pIter, i, &pVal);
			rc = sessionBindValue(pStmt, i + 1, pVal);
		}
	}
	return rc;
}


static int sessionSeekToRow(
	sqlite3 *db,                    
	sqlite3_changeset_iter *pIter,  
	u8 *abPK,                       
	sqlite3_stmt *pSelect           
) {
	int rc;                         
	int nCol;                       
	int op;                         
	const char *zDummy;             

	sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);
	rc = sessionBindRow(pIter,
		op == SQLITE_INSERT ? sqlite3changeset_new : sqlite3changeset_old,
		nCol, abPK, pSelect
	);

	if (rc == SQLITE_OK) {
		rc = sqlite3_step(pSelect);
		if (rc != SQLITE_ROW) rc = sqlite3_reset(pSelect);
	}

	return rc;
}


static int sessionConflictHandler(
	int eType,                      
	SessionApplyCtx *p,             
	sqlite3_changeset_iter *pIter,  
	int(*xConflict)(void *, int, sqlite3_changeset_iter*),
	void *pCtx,                     
	int *pbReplace                  
) {
	int res = 0;                    
	int rc;
	int nCol;
	int op;
	const char *zDummy;

	sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);

	assert(eType == SQLITE_CHANGESET_CONFLICT || eType == SQLITE_CHANGESET_DATA);
	assert(SQLITE_CHANGESET_CONFLICT + 1 == SQLITE_CHANGESET_CONSTRAINT);
	assert(SQLITE_CHANGESET_DATA + 1 == SQLITE_CHANGESET_NOTFOUND);

	
	if (pbReplace) {
		rc = sessionSeekToRow(p->db, pIter, p->abPK, p->pSelect);
	}
	else {
		rc = SQLITE_OK;
	}

	if (rc == SQLITE_ROW) {
		
		pIter->pConflict = p->pSelect;
		res = xConflict(pCtx, eType, pIter);
		pIter->pConflict = 0;
		rc = sqlite3_reset(p->pSelect);
	}
	else if (rc == SQLITE_OK) {
		if (p->bDeferConstraints && eType == SQLITE_CHANGESET_CONFLICT) {
			
			u8 *aBlob = &pIter->in.aData[pIter->in.iCurrent];
			int nBlob = pIter->in.iNext - pIter->in.iCurrent;
			sessionAppendBlob(&p->constraints, aBlob, nBlob, &rc);
			res = SQLITE_CHANGESET_OMIT;
		}
		else {
			
			res = xConflict(pCtx, eType + 1, pIter);
			if (res == SQLITE_CHANGESET_REPLACE) rc = SQLITE_MISUSE;
		}
	}

	if (rc == SQLITE_OK) {
		switch (res) {
		case SQLITE_CHANGESET_REPLACE:
			assert(pbReplace);
			*pbReplace = 1;
			break;

		case SQLITE_CHANGESET_OMIT:
			break;

		case SQLITE_CHANGESET_ABORT:
			rc = SQLITE_ABORT;
			break;

		default:
			rc = SQLITE_MISUSE;
			break;
		}
	}

	return rc;
}


static int sessionApplyOneOp(
	sqlite3_changeset_iter *pIter,  
	SessionApplyCtx *p,             
	int(*xConflict)(void *, int, sqlite3_changeset_iter *),
	void *pCtx,                     
	int *pbReplace,                 
	int *pbRetry                    
) {
	const char *zDummy;
	int op;
	int nCol;
	int rc = SQLITE_OK;

	assert(p->pDelete && p->pUpdate && p->pInsert && p->pSelect);
	assert(p->azCol && p->abPK);
	assert(!pbReplace || *pbReplace == 0);

	sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);

	if (op == SQLITE_DELETE) {

		
		u8 *abPK = (pIter->bPatchset ? p->abPK : 0);
		rc = sessionBindRow(pIter, sqlite3changeset_old, nCol, abPK, p->pDelete);
		if (rc == SQLITE_OK && sqlite3_bind_parameter_count(p->pDelete)>nCol) {
			rc = sqlite3_bind_int(p->pDelete, nCol + 1, (pbRetry == 0 || abPK));
		}
		if (rc != SQLITE_OK) return rc;

		sqlite3_step(p->pDelete);
		rc = sqlite3_reset(p->pDelete);
		if (rc == SQLITE_OK && sqlite3_changes(p->db) == 0) {
			rc = sessionConflictHandler(
				SQLITE_CHANGESET_DATA, p, pIter, xConflict, pCtx, pbRetry
			);
		}
		else if ((rc & 0xff) == SQLITE_CONSTRAINT) {
			rc = sessionConflictHandler(
				SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, 0
			);
		}

	}
	else if (op == SQLITE_UPDATE) {
		int i;

		
		for (i = 0; rc == SQLITE_OK && i<nCol; i++) {
			sqlite3_value *pOld = sessionChangesetOld(pIter, i);
			sqlite3_value *pNew = sessionChangesetNew(pIter, i);

			sqlite3_bind_int(p->pUpdate, i * 3 + 2, !!pNew);
			if (pOld) {
				rc = sessionBindValue(p->pUpdate, i * 3 + 1, pOld);
			}
			if (rc == SQLITE_OK && pNew) {
				rc = sessionBindValue(p->pUpdate, i * 3 + 3, pNew);
			}
		}
		if (rc == SQLITE_OK) {
			sqlite3_bind_int(p->pUpdate, nCol * 3 + 1, pbRetry == 0 || pIter->bPatchset);
		}
		if (rc != SQLITE_OK) return rc;

		
		sqlite3_step(p->pUpdate);
		rc = sqlite3_reset(p->pUpdate);

		if (rc == SQLITE_OK && sqlite3_changes(p->db) == 0) {
			

			rc = sessionConflictHandler(
				SQLITE_CHANGESET_DATA, p, pIter, xConflict, pCtx, pbRetry
			);

		}
		else if ((rc & 0xff) == SQLITE_CONSTRAINT) {
			
			rc = sessionConflictHandler(
				SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, 0
			);
		}

	}
	else {
		assert(op == SQLITE_INSERT);
		rc = sessionBindRow(pIter, sqlite3changeset_new, nCol, 0, p->pInsert);
		if (rc != SQLITE_OK) return rc;

		sqlite3_step(p->pInsert);
		rc = sqlite3_reset(p->pInsert);
		if ((rc & 0xff) == SQLITE_CONSTRAINT) {
			rc = sessionConflictHandler(
				SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, pbReplace
			);
		}
	}

	return rc;
}


static int sessionApplyOneWithRetry(
	sqlite3 *db,                    
	sqlite3_changeset_iter *pIter,  
	SessionApplyCtx *pApply,        
	int(*xConflict)(void*, int, sqlite3_changeset_iter*),
	void *pCtx                      
) {
	int bReplace = 0;
	int bRetry = 0;
	int rc;

	rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, &bReplace, &bRetry);
	assert(rc == SQLITE_OK || (bRetry == 0 && bReplace == 0));

	
	if (bRetry) {
		assert(pIter->op == SQLITE_UPDATE || pIter->op == SQLITE_DELETE);
		rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);
	}

	
	else if (bReplace) {
		assert(pIter->op == SQLITE_INSERT);
		rc = sqlite3_exec(db, "SAVEPOINT replace_op", 0, 0, 0);
		if (rc == SQLITE_OK) {
			rc = sessionBindRow(pIter,
				sqlite3changeset_new, pApply->nCol, pApply->abPK, pApply->pDelete);
			sqlite3_bind_int(pApply->pDelete, pApply->nCol + 1, 1);
		}
		if (rc == SQLITE_OK) {
			sqlite3_step(pApply->pDelete);
			rc = sqlite3_reset(pApply->pDelete);
		}
		if (rc == SQLITE_OK) {
			rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3_exec(db, "RELEASE replace_op", 0, 0, 0);
		}
	}

	return rc;
}


static int sessionRetryConstraints(
	sqlite3 *db,
	int bPatchset,
	const char *zTab,
	SessionApplyCtx *pApply,
	int(*xConflict)(void*, int, sqlite3_changeset_iter*),
	void *pCtx                      
) {
	int rc = SQLITE_OK;

	while (pApply->constraints.nBuf) {
		sqlite3_changeset_iter *pIter2 = 0;
		SessionBuffer cons = pApply->constraints;
		memset(&pApply->constraints, 0, sizeof(SessionBuffer));

		rc = sessionChangesetStart(&pIter2, 0, 0, cons.nBuf, cons.aBuf);
		if (rc == SQLITE_OK) {
			int nByte = 2 * pApply->nCol * sizeof(sqlite3_value*);
			int rc2;
			pIter2->bPatchset = bPatchset;
			pIter2->zTab = (char*)zTab;
			pIter2->nCol = pApply->nCol;
			pIter2->abPK = pApply->abPK;
			sessionBufferGrow(&pIter2->tblhdr, nByte, &rc);
			pIter2->apValue = (sqlite3_value**)pIter2->tblhdr.aBuf;
			if (rc == SQLITE_OK) memset(pIter2->apValue, 0, nByte);

			while (rc == SQLITE_OK && SQLITE_ROW == sqlite3changeset_next(pIter2)) {
				rc = sessionApplyOneWithRetry(db, pIter2, pApply, xConflict, pCtx);
			}

			rc2 = sqlite3changeset_finalize(pIter2);
			if (rc == SQLITE_OK) rc = rc2;
		}
		assert(pApply->bDeferConstraints || pApply->constraints.nBuf == 0);

		sqlite3_free(cons.aBuf);
		if (rc != SQLITE_OK) break;
		if (pApply->constraints.nBuf >= cons.nBuf) {
			
			pApply->bDeferConstraints = 0;
		}
	}

	return rc;
}


static int sessionChangesetApply(
	sqlite3 *db,                    
	sqlite3_changeset_iter *pIter,  
	int(*xFilter)(
		void *pCtx,                   
		const char *zTab              
		),
	int(*xConflict)(
		void *pCtx,                   
		int eConflict,                
		sqlite3_changeset_iter *p     
		),
	void *pCtx                      
) {
	int schemaMismatch = 0;
	int rc;                         
	const char *zTab = 0;           
	int nTab = 0;                   
	SessionApplyCtx sApply;         
	int bPatchset;

	assert(xConflict != 0);

	pIter->in.bNoDiscard = 1;
	memset(&sApply, 0, sizeof(sApply));
	sqlite3_mutex_enter(sqlite3_db_mutex(db));
	rc = sqlite3_exec(db, "SAVEPOINT changeset_apply", 0, 0, 0);
	if (rc == SQLITE_OK) {
		rc = sqlite3_exec(db, "PRAGMA defer_foreign_keys = 1", 0, 0, 0);
	}
	while (rc == SQLITE_OK && SQLITE_ROW == sqlite3changeset_next(pIter)) {
		int nCol;
		int op;
		const char *zNew;

		sqlite3changeset_op(pIter, &zNew, &nCol, &op, 0);

		if (zTab == 0 || sqlite3_strnicmp(zNew, zTab, nTab + 1)) {
			u8 *abPK;

			rc = sessionRetryConstraints(
				db, pIter->bPatchset, zTab, &sApply, xConflict, pCtx
			);
			if (rc != SQLITE_OK) break;

			sqlite3_free((char*)sApply.azCol);  
			sqlite3_finalize(sApply.pDelete);
			sqlite3_finalize(sApply.pUpdate);
			sqlite3_finalize(sApply.pInsert);
			sqlite3_finalize(sApply.pSelect);
			memset(&sApply, 0, sizeof(sApply));
			sApply.db = db;
			sApply.bDeferConstraints = 1;

			
			schemaMismatch = (xFilter && (0 == xFilter(pCtx, zNew)));
			if (schemaMismatch) {
				zTab = sqlite3_mprintf("%s", zNew);
				if (zTab == 0) {
					rc = SQLITE_NOMEM;
					break;
				}
				nTab = (int)strlen(zTab);
				sApply.azCol = (const char **)zTab;
			}
			else {
				sqlite3changeset_pk(pIter, &abPK, 0);
				rc = sessionTableInfo(
					db, "main", zNew, &sApply.nCol, &zTab, &sApply.azCol, &sApply.abPK
				);
				if (rc != SQLITE_OK) break;

				if (sApply.nCol == 0) {
					schemaMismatch = 1;
					sqlite3_log(SQLITE_SCHEMA,
						"sqlite3changeset_apply(): no such table: %s", zTab
					);
				}
				else if (sApply.nCol != nCol) {
					schemaMismatch = 1;
					sqlite3_log(SQLITE_SCHEMA,
						"sqlite3changeset_apply(): table %s has %d columns, expected %d",
						zTab, sApply.nCol, nCol
					);
				}
				else if (memcmp(sApply.abPK, abPK, nCol) != 0) {
					schemaMismatch = 1;
					sqlite3_log(SQLITE_SCHEMA, "sqlite3changeset_apply(): "
						"primary key mismatch for table %s", zTab
					);
				}
				else if (
					(rc = sessionSelectRow(db, zTab, &sApply))
					|| (rc = sessionUpdateRow(db, zTab, &sApply))
					|| (rc = sessionDeleteRow(db, zTab, &sApply))
					|| (rc = sessionInsertRow(db, zTab, &sApply))
					) {
					break;
				}
				nTab = sqlite3Strlen30(zTab);
			}
		}

		
		if (schemaMismatch) continue;

		rc = sessionApplyOneWithRetry(db, pIter, &sApply, xConflict, pCtx);
	}

	bPatchset = pIter->bPatchset;
	if (rc == SQLITE_OK) {
		rc = sqlite3changeset_finalize(pIter);
	}
	else {
		sqlite3changeset_finalize(pIter);
	}

	if (rc == SQLITE_OK) {
		rc = sessionRetryConstraints(db, bPatchset, zTab, &sApply, xConflict, pCtx);
	}

	if (rc == SQLITE_OK) {
		int nFk, notUsed;
		sqlite3_db_status(db, SQLITE_DBSTATUS_DEFERRED_FKS, &nFk, &notUsed, 0);
		if (nFk != 0) {
			int res = SQLITE_CHANGESET_ABORT;
			sqlite3_changeset_iter sIter;
			memset(&sIter, 0, sizeof(sIter));
			sIter.nCol = nFk;
			res = xConflict(pCtx, SQLITE_CHANGESET_FOREIGN_KEY, &sIter);
			if (res != SQLITE_CHANGESET_OMIT) {
				rc = SQLITE_CONSTRAINT;
			}
		}
	}
	sqlite3_exec(db, "PRAGMA defer_foreign_keys = 0", 0, 0, 0);

	if (rc == SQLITE_OK) {
		rc = sqlite3_exec(db, "RELEASE changeset_apply", 0, 0, 0);
	}
	else {
		sqlite3_exec(db, "ROLLBACK TO changeset_apply", 0, 0, 0);
		sqlite3_exec(db, "RELEASE changeset_apply", 0, 0, 0);
	}

	sqlite3_finalize(sApply.pInsert);
	sqlite3_finalize(sApply.pDelete);
	sqlite3_finalize(sApply.pUpdate);
	sqlite3_finalize(sApply.pSelect);
	sqlite3_free((char*)sApply.azCol);  
	sqlite3_free((char*)sApply.constraints.aBuf);
	sqlite3_mutex_leave(sqlite3_db_mutex(db));
	return rc;
}


SQLITE_API int sqlite3changeset_apply(
	sqlite3 *db,                    
	int nChangeset,                 
	void *pChangeset,               
	int(*xFilter)(
		void *pCtx,                   
		const char *zTab              
		),
	int(*xConflict)(
		void *pCtx,                   
		int eConflict,                
		sqlite3_changeset_iter *p     
		),
	void *pCtx                      
) {
	sqlite3_changeset_iter *pIter;  
	int rc = sqlite3changeset_start(&pIter, nChangeset, pChangeset);
	if (rc == SQLITE_OK) {
		rc = sessionChangesetApply(db, pIter, xFilter, xConflict, pCtx);
	}
	return rc;
}


SQLITE_API int sqlite3changeset_apply_strm(
	sqlite3 *db,                    
	int(*xInput)(void *pIn, void *pData, int *pnData), 
	void *pIn,                                          
	int(*xFilter)(
		void *pCtx,                   
		const char *zTab              
		),
	int(*xConflict)(
		void *pCtx,                   
		int eConflict,                
		sqlite3_changeset_iter *p     
		),
	void *pCtx                      
) {
	sqlite3_changeset_iter *pIter;  
	int rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);
	if (rc == SQLITE_OK) {
		rc = sessionChangesetApply(db, pIter, xFilter, xConflict, pCtx);
	}
	return rc;
}


struct sqlite3_changegroup {
	int rc;                         
	int bPatch;                     
	SessionTable *pList;            
};


static int sessionChangeMerge(
	SessionTable *pTab,             
	int bPatchset,                  
	SessionChange *pExist,          
	int op2,                        
	int bIndirect,                  
	u8 *aRec,                       
	int nRec,                       
	SessionChange **ppNew           
) {
	SessionChange *pNew = 0;

	if (!pExist) {
		pNew = (SessionChange *)sqlite3_malloc(sizeof(SessionChange) + nRec);
		if (!pNew) {
			return SQLITE_NOMEM;
		}
		memset(pNew, 0, sizeof(SessionChange));
		pNew->op = op2;
		pNew->bIndirect = bIndirect;
		pNew->nRecord = nRec;
		pNew->aRecord = (u8*)&pNew[1];
		memcpy(pNew->aRecord, aRec, nRec);
	}
	else {
		int op1 = pExist->op;

		
		if ((op1 == SQLITE_INSERT && op2 == SQLITE_INSERT)
			|| (op1 == SQLITE_UPDATE && op2 == SQLITE_INSERT)
			|| (op1 == SQLITE_DELETE && op2 == SQLITE_UPDATE)
			|| (op1 == SQLITE_DELETE && op2 == SQLITE_DELETE)
			) {
			pNew = pExist;
		}
		else if (op1 == SQLITE_INSERT && op2 == SQLITE_DELETE) {
			sqlite3_free(pExist);
			assert(pNew == 0);
		}
		else {
			u8 *aExist = pExist->aRecord;
			int nByte;
			u8 *aCsr;

			
			nByte = sizeof(SessionChange) + pExist->nRecord + nRec;
			pNew = (SessionChange *)sqlite3_malloc(nByte);
			if (!pNew) {
				sqlite3_free(pExist);
				return SQLITE_NOMEM;
			}
			memset(pNew, 0, sizeof(SessionChange));
			pNew->bIndirect = (bIndirect && pExist->bIndirect);
			aCsr = pNew->aRecord = (u8 *)&pNew[1];

			if (op1 == SQLITE_INSERT) {             
				u8 *a1 = aRec;
				assert(op2 == SQLITE_UPDATE);
				pNew->op = SQLITE_INSERT;
				if (bPatchset == 0) sessionSkipRecord(&a1, pTab->nCol);
				sessionMergeRecord(&aCsr, pTab->nCol, aExist, a1);
			}
			else if (op1 == SQLITE_DELETE) {       
				assert(op2 == SQLITE_INSERT);
				pNew->op = SQLITE_UPDATE;
				if (bPatchset) {
					memcpy(aCsr, aRec, nRec);
					aCsr += nRec;
				}
				else {
					if (0 == sessionMergeUpdate(&aCsr, pTab, bPatchset, aExist, 0, aRec, 0)) {
						sqlite3_free(pNew);
						pNew = 0;
					}
				}
			}
			else if (op2 == SQLITE_UPDATE) {       
				u8 *a1 = aExist;
				u8 *a2 = aRec;
				assert(op1 == SQLITE_UPDATE);
				if (bPatchset == 0) {
					sessionSkipRecord(&a1, pTab->nCol);
					sessionSkipRecord(&a2, pTab->nCol);
				}
				pNew->op = SQLITE_UPDATE;
				if (0 == sessionMergeUpdate(&aCsr, pTab, bPatchset, aRec, aExist, a1, a2)) {
					sqlite3_free(pNew);
					pNew = 0;
				}
			}
			else {                                
				assert(op1 == SQLITE_UPDATE && op2 == SQLITE_DELETE);
				pNew->op = SQLITE_DELETE;
				if (bPatchset) {
					memcpy(aCsr, aRec, nRec);
					aCsr += nRec;
				}
				else {
					sessionMergeRecord(&aCsr, pTab->nCol, aRec, aExist);
				}
			}

			if (pNew) {
				pNew->nRecord = (int)(aCsr - pNew->aRecord);
			}
			sqlite3_free(pExist);
		}
	}

	*ppNew = pNew;
	return SQLITE_OK;
}


static int sessionChangesetToHash(
	sqlite3_changeset_iter *pIter,   
	sqlite3_changegroup *pGrp        
) {
	u8 *aRec;
	int nRec;
	int rc = SQLITE_OK;
	SessionTable *pTab = 0;


	while (SQLITE_ROW == sessionChangesetNext(pIter, &aRec, &nRec)) {
		const char *zNew;
		int nCol;
		int op;
		int iHash;
		int bIndirect;
		SessionChange *pChange;
		SessionChange *pExist = 0;
		SessionChange **pp;

		if (pGrp->pList == 0) {
			pGrp->bPatch = pIter->bPatchset;
		}
		else if (pIter->bPatchset != pGrp->bPatch) {
			rc = SQLITE_ERROR;
			break;
		}

		sqlite3changeset_op(pIter, &zNew, &nCol, &op, &bIndirect);
		if (!pTab || sqlite3_stricmp(zNew, pTab->zName)) {
			
			int nNew = (int)strlen(zNew);
			u8 *abPK;

			sqlite3changeset_pk(pIter, &abPK, 0);
			for (pTab = pGrp->pList; pTab; pTab = pTab->pNext) {
				if (0 == sqlite3_strnicmp(pTab->zName, zNew, nNew + 1)) break;
			}
			if (!pTab) {
				SessionTable **ppTab;

				pTab = sqlite3_malloc(sizeof(SessionTable) + nCol + nNew + 1);
				if (!pTab) {
					rc = SQLITE_NOMEM;
					break;
				}
				memset(pTab, 0, sizeof(SessionTable));
				pTab->nCol = nCol;
				pTab->abPK = (u8*)&pTab[1];
				memcpy(pTab->abPK, abPK, nCol);
				pTab->zName = (char*)&pTab->abPK[nCol];
				memcpy(pTab->zName, zNew, nNew + 1);

				
				for (ppTab = &pGrp->pList; *ppTab; ppTab = &(*ppTab)->pNext);
				*ppTab = pTab;
			}
			else if (pTab->nCol != nCol || memcmp(pTab->abPK, abPK, nCol)) {
				rc = SQLITE_SCHEMA;
				break;
			}
		}

		if (sessionGrowHash(pIter->bPatchset, pTab)) {
			rc = SQLITE_NOMEM;
			break;
		}
		iHash = sessionChangeHash(
			pTab, (pIter->bPatchset && op == SQLITE_DELETE), aRec, pTab->nChange
		);

		
		for (pp = &pTab->apChange[iHash]; *pp; pp = &(*pp)->pNext) {
			int bPkOnly1 = 0;
			int bPkOnly2 = 0;
			if (pIter->bPatchset) {
				bPkOnly1 = (*pp)->op == SQLITE_DELETE;
				bPkOnly2 = op == SQLITE_DELETE;
			}
			if (sessionChangeEqual(pTab, bPkOnly1, (*pp)->aRecord, bPkOnly2, aRec)) {
				pExist = *pp;
				*pp = (*pp)->pNext;
				pTab->nEntry--;
				break;
			}
		}

		rc = sessionChangeMerge(pTab,
			pIter->bPatchset, pExist, op, bIndirect, aRec, nRec, &pChange
		);
		if (rc) break;
		if (pChange) {
			pChange->pNext = pTab->apChange[iHash];
			pTab->apChange[iHash] = pChange;
			pTab->nEntry++;
		}
	}

	if (rc == SQLITE_OK) rc = pIter->rc;
	return rc;
}


static int sessionChangegroupOutput(
	sqlite3_changegroup *pGrp,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut,
	int *pnOut,
	void **ppOut
) {
	int rc = SQLITE_OK;
	SessionBuffer buf = { 0, 0, 0 };
	SessionTable *pTab;
	assert(xOutput == 0 || (ppOut == 0 && pnOut == 0));

	
	for (pTab = pGrp->pList; rc == SQLITE_OK && pTab; pTab = pTab->pNext) {
		int i;
		if (pTab->nEntry == 0) continue;

		sessionAppendTableHdr(&buf, pGrp->bPatch, pTab, &rc);
		for (i = 0; i<pTab->nChange; i++) {
			SessionChange *p;
			for (p = pTab->apChange[i]; p; p = p->pNext) {
				sessionAppendByte(&buf, p->op, &rc);
				sessionAppendByte(&buf, p->bIndirect, &rc);
				sessionAppendBlob(&buf, p->aRecord, p->nRecord, &rc);
			}
		}

		if (rc == SQLITE_OK && xOutput && buf.nBuf >= SESSIONS_STRM_CHUNK_SIZE) {
			rc = xOutput(pOut, buf.aBuf, buf.nBuf);
			buf.nBuf = 0;
		}
	}

	if (rc == SQLITE_OK) {
		if (xOutput) {
			if (buf.nBuf>0) rc = xOutput(pOut, buf.aBuf, buf.nBuf);
		}
		else {
			*ppOut = buf.aBuf;
			*pnOut = buf.nBuf;
			buf.aBuf = 0;
		}
	}
	sqlite3_free(buf.aBuf);

	return rc;
}


SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp) {
	int rc = SQLITE_OK;             
	sqlite3_changegroup *p;         
	p = (sqlite3_changegroup*)sqlite3_malloc(sizeof(sqlite3_changegroup));
	if (p == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		memset(p, 0, sizeof(sqlite3_changegroup));
	}
	*pp = p;
	return rc;
}


SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup *pGrp, int nData, void *pData) {
	sqlite3_changeset_iter *pIter;  
	int rc;                         

	rc = sqlite3changeset_start(&pIter, nData, pData);
	if (rc == SQLITE_OK) {
		rc = sessionChangesetToHash(pIter, pGrp);
	}
	sqlite3changeset_finalize(pIter);
	return rc;
}


SQLITE_API int sqlite3changegroup_output(
	sqlite3_changegroup *pGrp,
	int *pnData,
	void **ppData
) {
	return sessionChangegroupOutput(pGrp, 0, 0, pnData, ppData);
}


SQLITE_API int sqlite3changegroup_add_strm(
	sqlite3_changegroup *pGrp,
	int(*xInput)(void *pIn, void *pData, int *pnData),
	void *pIn
) {
	sqlite3_changeset_iter *pIter;  
	int rc;                         

	rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);
	if (rc == SQLITE_OK) {
		rc = sessionChangesetToHash(pIter, pGrp);
	}
	sqlite3changeset_finalize(pIter);
	return rc;
}


SQLITE_API int sqlite3changegroup_output_strm(
	sqlite3_changegroup *pGrp,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut
) {
	return sessionChangegroupOutput(pGrp, xOutput, pOut, 0, 0);
}


SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup *pGrp) {
	if (pGrp) {
		sessionDeleteTable(pGrp->pList);
		sqlite3_free(pGrp);
	}
}


SQLITE_API int sqlite3changeset_concat(
	int nLeft,                      
	void *pLeft,                    
	int nRight                      ,
	void *pRight,                   
	int *pnOut,                     
	void **ppOut                    
) {
	sqlite3_changegroup *pGrp;
	int rc;

	rc = sqlite3changegroup_new(&pGrp);
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_add(pGrp, nLeft, pLeft);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_add(pGrp, nRight, pRight);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_output(pGrp, pnOut, ppOut);
	}
	sqlite3changegroup_delete(pGrp);

	return rc;
}


SQLITE_API int sqlite3changeset_concat_strm(
	int(*xInputA)(void *pIn, void *pData, int *pnData),
	void *pInA,
	int(*xInputB)(void *pIn, void *pData, int *pnData),
	void *pInB,
	int(*xOutput)(void *pOut, const void *pData, int nData),
	void *pOut
) {
	sqlite3_changegroup *pGrp;
	int rc;

	rc = sqlite3changegroup_new(&pGrp);
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_add_strm(pGrp, xInputA, pInA);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_add_strm(pGrp, xInputB, pInB);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3changegroup_output_strm(pGrp, xOutput, pOut);
	}
	sqlite3changegroup_delete(pGrp);

	return rc;
}

#endif 




#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_JSON1)
#if !defined(_SQLITEINT_H_)

#endif
SQLITE_EXTENSION_INIT1






#ifndef UNUSED_PARAM
# define UNUSED_PARAM(X)  (void)(X)
#endif

#ifndef LARGEST_INT64
# define LARGEST_INT64  (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
#endif


#ifdef sqlite3Isdigit

#  define safe_isdigit(x)  sqlite3Isdigit(x)
#  define safe_isalnum(x)  sqlite3Isalnum(x)
#  define safe_isxdigit(x) sqlite3Isxdigit(x)
#else

#include <ctype.h>  
#  define safe_isdigit(x)  isdigit((unsigned char)(x))
#  define safe_isalnum(x)  isalnum((unsigned char)(x))
#  define safe_isxdigit(x) isxdigit((unsigned char)(x))
#endif


static const char jsonIsSpace[] = {
	0, 0, 0, 0, 0, 0, 0, 0,     0, 1, 1, 0, 0, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
};
#define safe_isspace(x) (jsonIsSpace[(unsigned char)x])

#ifndef SQLITE_AMALGAMATION

typedef sqlite3_uint64 u64;
typedef unsigned int u32;
typedef unsigned char u8;
#endif


typedef struct JsonString JsonString;
typedef struct JsonNode JsonNode;
typedef struct JsonParse JsonParse;


struct JsonString {
	sqlite3_context *pCtx;   
	char *zBuf;              
	u64 nAlloc;              
	u64 nUsed;               
	u8 bStatic;              
	u8 bErr;                 
	char zSpace[100];        
};


#define JSON_NULL     0
#define JSON_TRUE     1
#define JSON_FALSE    2
#define JSON_INT      3
#define JSON_REAL     4
#define JSON_STRING   5
#define JSON_ARRAY    6
#define JSON_OBJECT   7


#define JSON_SUBTYPE  74    


static const char * const jsonType[] = {
	"null", "true", "false", "integer", "real", "text", "array", "object"
};


#define JNODE_RAW     0x01         
#define JNODE_ESCAPE  0x02         
#define JNODE_REMOVE  0x04         
#define JNODE_REPLACE 0x08         
#define JNODE_APPEND  0x10         
#define JNODE_LABEL   0x20         



struct JsonNode {
	u8 eType;              
	u8 jnFlags;            
	u8 iVal;               
	u32 n;                 
	union {
		const char *zJContent; 
		u32 iAppend;           
		u32 iKey;              
	} u;
};


struct JsonParse {
	u32 nNode;         
	u32 nAlloc;        
	JsonNode *aNode;   
	const char *zJson; 
	u32 *aUp;          
	u8 oom;            
	u8 nErr;           
};




static void jsonZero(JsonString *p) {
	p->zBuf = p->zSpace;
	p->nAlloc = sizeof(p->zSpace);
	p->nUsed = 0;
	p->bStatic = 1;
}


static void jsonInit(JsonString *p, sqlite3_context *pCtx) {
	p->pCtx = pCtx;
	p->bErr = 0;
	jsonZero(p);
}



static void jsonReset(JsonString *p) {
	if (!p->bStatic) sqlite3_free(p->zBuf);
	jsonZero(p);
}



static void jsonOom(JsonString *p) {
	p->bErr = 1;
	sqlite3_result_error_nomem(p->pCtx);
	jsonReset(p);
}


static int jsonGrow(JsonString *p, u32 N) {
	u64 nTotal = N<p->nAlloc ? p->nAlloc * 2 : p->nAlloc + N + 10;
	char *zNew;
	if (p->bStatic) {
		if (p->bErr) return 1;
		zNew = sqlite3_malloc64(nTotal);
		if (zNew == 0) {
			jsonOom(p);
			return SQLITE_NOMEM;
		}
		memcpy(zNew, p->zBuf, (size_t)p->nUsed);
		p->zBuf = zNew;
		p->bStatic = 0;
	}
	else {
		zNew = sqlite3_realloc64(p->zBuf, nTotal);
		if (zNew == 0) {
			jsonOom(p);
			return SQLITE_NOMEM;
		}
		p->zBuf = zNew;
	}
	p->nAlloc = nTotal;
	return SQLITE_OK;
}


static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N) {
	if ((N + p->nUsed >= p->nAlloc) && jsonGrow(p, N) != 0) return;
	memcpy(p->zBuf + p->nUsed, zIn, N);
	p->nUsed += N;
}


static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...) {
	va_list ap;
	if ((p->nUsed + N >= p->nAlloc) && jsonGrow(p, N)) return;
	va_start(ap, zFormat);
	sqlite3_vsnprintf(N, p->zBuf + p->nUsed, zFormat, ap);
	va_end(ap);
	p->nUsed += (int)strlen(p->zBuf + p->nUsed);
}


static void jsonAppendChar(JsonString *p, char c) {
	if (p->nUsed >= p->nAlloc && jsonGrow(p, 1) != 0) return;
	p->zBuf[p->nUsed++] = c;
}


static void jsonAppendSeparator(JsonString *p) {
	char c;
	if (p->nUsed == 0) return;
	c = p->zBuf[p->nUsed - 1];
	if (c != '[' && c != '{') jsonAppendChar(p, ',');
}


static void jsonAppendString(JsonString *p, const char *zIn, u32 N) {
	u32 i;
	if ((N + p->nUsed + 2 >= p->nAlloc) && jsonGrow(p, N + 2) != 0) return;
	p->zBuf[p->nUsed++] = '"';
	for (i = 0; i<N; i++) {
		unsigned char c = ((unsigned const char*)zIn)[i];
		if (c == '"' || c == '\\') {
		json_simple_escape:
			if ((p->nUsed + N + 3 - i > p->nAlloc) && jsonGrow(p, N + 3 - i) != 0) return;
			p->zBuf[p->nUsed++] = '\\';
		}
		else if (c <= 0x1f) {
			static const char aSpecial[] = {
				0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,   0,   0,   0, 0,   0,   0, 0, 0
			};
			assert(sizeof(aSpecial) == 32);
			assert(aSpecial['\b'] == 'b');
			assert(aSpecial['\f'] == 'f');
			assert(aSpecial['\n'] == 'n');
			assert(aSpecial['\r'] == 'r');
			assert(aSpecial['\t'] == 't');
			if (aSpecial[c]) {
				c = aSpecial[c];
				goto json_simple_escape;
			}
			if ((p->nUsed + N + 7 + i > p->nAlloc) && jsonGrow(p, N + 7 - i) != 0) return;
			p->zBuf[p->nUsed++] = '\\';
			p->zBuf[p->nUsed++] = 'u';
			p->zBuf[p->nUsed++] = '0';
			p->zBuf[p->nUsed++] = '0';
			p->zBuf[p->nUsed++] = '0' + (c >> 4);
			c = "0123456789abcdef"[c & 0xf];
		}
		p->zBuf[p->nUsed++] = c;
	}
	p->zBuf[p->nUsed++] = '"';
	assert(p->nUsed<p->nAlloc);
}


static void jsonAppendValue(
	JsonString *p,                 
	sqlite3_value *pValue          
) {
	switch (sqlite3_value_type(pValue)) {
	case SQLITE_NULL: {
		jsonAppendRaw(p, "null", 4);
		break;
	}
	case SQLITE_INTEGER:
	case SQLITE_FLOAT: {
		const char *z = (const char*)sqlite3_value_text(pValue);
		u32 n = (u32)sqlite3_value_bytes(pValue);
		jsonAppendRaw(p, z, n);
		break;
	}
	case SQLITE_TEXT: {
		const char *z = (const char*)sqlite3_value_text(pValue);
		u32 n = (u32)sqlite3_value_bytes(pValue);
		if (sqlite3_value_subtype(pValue) == JSON_SUBTYPE) {
			jsonAppendRaw(p, z, n);
		}
		else {
			jsonAppendString(p, z, n);
		}
		break;
	}
	default: {
		if (p->bErr == 0) {
			sqlite3_result_error(p->pCtx, "JSON cannot hold BLOB values", -1);
			p->bErr = 2;
			jsonReset(p);
		}
		break;
	}
	}
}



static void jsonResult(JsonString *p) {
	if (p->bErr == 0) {
		sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,
			p->bStatic ? SQLITE_TRANSIENT : sqlite3_free,
			SQLITE_UTF8);
		jsonZero(p);
	}
	assert(p->bStatic);
}




static u32 jsonNodeSize(JsonNode *pNode) {
	return pNode->eType >= JSON_ARRAY ? pNode->n + 1 : 1;
}


static void jsonParseReset(JsonParse *pParse) {
	sqlite3_free(pParse->aNode);
	pParse->aNode = 0;
	pParse->nNode = 0;
	pParse->nAlloc = 0;
	sqlite3_free(pParse->aUp);
	pParse->aUp = 0;
}


static void jsonRenderNode(
	JsonNode *pNode,               
	JsonString *pOut,              
	sqlite3_value **aReplace       
) {
	switch (pNode->eType) {
	default: {
		assert(pNode->eType == JSON_NULL);
		jsonAppendRaw(pOut, "null", 4);
		break;
	}
	case JSON_TRUE: {
		jsonAppendRaw(pOut, "true", 4);
		break;
	}
	case JSON_FALSE: {
		jsonAppendRaw(pOut, "false", 5);
		break;
	}
	case JSON_STRING: {
		if (pNode->jnFlags & JNODE_RAW) {
			jsonAppendString(pOut, pNode->u.zJContent, pNode->n);
			break;
		}
		
	}
	case JSON_REAL:
	case JSON_INT: {
		jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);
		break;
	}
	case JSON_ARRAY: {
		u32 j = 1;
		jsonAppendChar(pOut, '[');
		for (;;) {
			while (j <= pNode->n) {
				if (pNode[j].jnFlags & (JNODE_REMOVE | JNODE_REPLACE)) {
					if (pNode[j].jnFlags & JNODE_REPLACE) {
						jsonAppendSeparator(pOut);
						jsonAppendValue(pOut, aReplace[pNode[j].iVal]);
					}
				}
				else {
					jsonAppendSeparator(pOut);
					jsonRenderNode(&pNode[j], pOut, aReplace);
				}
				j += jsonNodeSize(&pNode[j]);
			}
			if ((pNode->jnFlags & JNODE_APPEND) == 0) break;
			pNode = &pNode[pNode->u.iAppend];
			j = 1;
		}
		jsonAppendChar(pOut, ']');
		break;
	}
	case JSON_OBJECT: {
		u32 j = 1;
		jsonAppendChar(pOut, '{');
		for (;;) {
			while (j <= pNode->n) {
				if ((pNode[j + 1].jnFlags & JNODE_REMOVE) == 0) {
					jsonAppendSeparator(pOut);
					jsonRenderNode(&pNode[j], pOut, aReplace);
					jsonAppendChar(pOut, ':');
					if (pNode[j + 1].jnFlags & JNODE_REPLACE) {
						jsonAppendValue(pOut, aReplace[pNode[j + 1].iVal]);
					}
					else {
						jsonRenderNode(&pNode[j + 1], pOut, aReplace);
					}
				}
				j += 1 + jsonNodeSize(&pNode[j + 1]);
			}
			if ((pNode->jnFlags & JNODE_APPEND) == 0) break;
			pNode = &pNode[pNode->u.iAppend];
			j = 1;
		}
		jsonAppendChar(pOut, '}');
		break;
	}
	}
}


static void jsonReturnJson(
	JsonNode *pNode,            
	sqlite3_context *pCtx,      
	sqlite3_value **aReplace    
) {
	JsonString s;
	jsonInit(&s, pCtx);
	jsonRenderNode(pNode, &s, aReplace);
	jsonResult(&s);
	sqlite3_result_subtype(pCtx, JSON_SUBTYPE);
}


static void jsonReturn(
	JsonNode *pNode,            
	sqlite3_context *pCtx,      
	sqlite3_value **aReplace    
) {
	switch (pNode->eType) {
	default: {
		assert(pNode->eType == JSON_NULL);
		sqlite3_result_null(pCtx);
		break;
	}
	case JSON_TRUE: {
		sqlite3_result_int(pCtx, 1);
		break;
	}
	case JSON_FALSE: {
		sqlite3_result_int(pCtx, 0);
		break;
	}
	case JSON_INT: {
		sqlite3_int64 i = 0;
		const char *z = pNode->u.zJContent;
		if (z[0] == '-') { z++; }
		while (z[0] >= '0' && z[0] <= '9') {
			unsigned v = *(z++) - '0';
			if (i >= LARGEST_INT64 / 10) {
				if (i>LARGEST_INT64 / 10) goto int_as_real;
				if (z[0] >= '0' && z[0] <= '9') goto int_as_real;
				if (v == 9) goto int_as_real;
				if (v == 8) {
					if (pNode->u.zJContent[0] == '-') {
						sqlite3_result_int64(pCtx, SMALLEST_INT64);
						goto int_done;
					}
					else {
						goto int_as_real;
					}
				}
			}
			i = i * 10 + v;
		}
		if (pNode->u.zJContent[0] == '-') { i = -i; }
		sqlite3_result_int64(pCtx, i);
	int_done:
		break;
	int_as_real: ;
	}
	case JSON_REAL: {
		double r;
#ifdef SQLITE_AMALGAMATION
		const char *z = pNode->u.zJContent;
		sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);
#else
		r = strtod(pNode->u.zJContent, 0);
#endif
		sqlite3_result_double(pCtx, r);
		break;
	}
	case JSON_STRING: {
#if 0 
		if (pNode->jnFlags & JNODE_RAW) {
			sqlite3_result_text(pCtx, pNode->u.zJContent, pNode->n,
				SQLITE_TRANSIENT);
		}
		else
#endif
			assert((pNode->jnFlags & JNODE_RAW) == 0);
		if ((pNode->jnFlags & JNODE_ESCAPE) == 0) {
			
			sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2,
				SQLITE_TRANSIENT);
		}
		else {
			
			u32 i;
			u32 n = pNode->n;
			const char *z = pNode->u.zJContent;
			char *zOut;
			u32 j;
			zOut = sqlite3_malloc(n + 1);
			if (zOut == 0) {
				sqlite3_result_error_nomem(pCtx);
				break;
			}
			for (i = 1, j = 0; i<n - 1; i++) {
				char c = z[i];
				if (c != '\\') {
					zOut[j++] = c;
				}
				else {
					c = z[++i];
					if (c == 'u') {
						u32 v = 0, k;
						for (k = 0; k<4 && i<n - 2; i++, k++) {
							c = z[i + 1];
							if (c >= '0' && c <= '9') v = v * 16 + c - '0';
							else if (c >= 'A' && c <= 'F') v = v * 16 + c - 'A' + 10;
							else if (c >= 'a' && c <= 'f') v = v * 16 + c - 'a' + 10;
							else break;
						}
						if (v == 0) break;
						if (v <= 0x7f) {
							zOut[j++] = (char)v;
						}
						else if (v <= 0x7ff) {
							zOut[j++] = (char)(0xc0 | (v >> 6));
							zOut[j++] = 0x80 | (v & 0x3f);
						}
						else {
							zOut[j++] = (char)(0xe0 | (v >> 12));
							zOut[j++] = 0x80 | ((v >> 6) & 0x3f);
							zOut[j++] = 0x80 | (v & 0x3f);
						}
					}
					else {
						if (c == 'b') {
							c = '\b';
						}
						else if (c == 'f') {
							c = '\f';
						}
						else if (c == 'n') {
							c = '\n';
						}
						else if (c == 'r') {
							c = '\r';
						}
						else if (c == 't') {
							c = '\t';
						}
						zOut[j++] = c;
					}
				}
			}
			zOut[j] = 0;
			sqlite3_result_text(pCtx, zOut, j, sqlite3_free);
		}
		break;
	}
	case JSON_ARRAY:
	case JSON_OBJECT: {
		jsonReturnJson(pNode, pCtx, aReplace);
		break;
	}
	}
}


static int jsonParseAddNode(JsonParse*, u32, u32, const char*);


#if defined(__GNUC__)
#  define JSON_NOINLINE  __attribute__((noinline))
#elif defined(_MSC_VER) && _MSC_VER>=1310
#  define JSON_NOINLINE  __declspec(noinline)
#else
#  define JSON_NOINLINE
#endif


static JSON_NOINLINE int jsonParseAddNodeExpand(
	JsonParse *pParse,        
	u32 eType,                
	u32 n,                    
	const char *zContent      
) {
	u32 nNew;
	JsonNode *pNew;
	assert(pParse->nNode >= pParse->nAlloc);
	if (pParse->oom) return -1;
	nNew = pParse->nAlloc * 2 + 10;
	pNew = sqlite3_realloc(pParse->aNode, sizeof(JsonNode)*nNew);
	if (pNew == 0) {
		pParse->oom = 1;
		return -1;
	}
	pParse->nAlloc = nNew;
	pParse->aNode = pNew;
	assert(pParse->nNode<pParse->nAlloc);
	return jsonParseAddNode(pParse, eType, n, zContent);
}


static int jsonParseAddNode(
	JsonParse *pParse,        
	u32 eType,                
	u32 n,                    
	const char *zContent      
) {
	JsonNode *p;
	if (pParse->nNode >= pParse->nAlloc) {
		return jsonParseAddNodeExpand(pParse, eType, n, zContent);
	}
	p = &pParse->aNode[pParse->nNode];
	p->eType = (u8)eType;
	p->jnFlags = 0;
	p->iVal = 0;
	p->n = n;
	p->u.zJContent = zContent;
	return pParse->nNode++;
}


static int jsonIs4Hex(const char *z) {
	int i;
	for (i = 0; i<4; i++) if (!safe_isxdigit(z[i])) return 0;
	return 1;
}


static int jsonParseValue(JsonParse *pParse, u32 i) {
	char c;
	u32 j;
	int iThis;
	int x;
	JsonNode *pNode;
	while (safe_isspace(pParse->zJson[i])) { i++; }
	if ((c = pParse->zJson[i]) == '{') {
		
		iThis = jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);
		if (iThis<0) return -1;
		for (j = i + 1;; j++) {
			while (safe_isspace(pParse->zJson[j])) { j++; }
			x = jsonParseValue(pParse, j);
			if (x<0) {
				if (x == (-2) && pParse->nNode == (u32)iThis + 1) return j + 1;
				return -1;
			}
			if (pParse->oom) return -1;
			pNode = &pParse->aNode[pParse->nNode - 1];
			if (pNode->eType != JSON_STRING) return -1;
			pNode->jnFlags |= JNODE_LABEL;
			j = x;
			while (safe_isspace(pParse->zJson[j])) { j++; }
			if (pParse->zJson[j] != ':') return -1;
			j++;
			x = jsonParseValue(pParse, j);
			if (x<0) return -1;
			j = x;
			while (safe_isspace(pParse->zJson[j])) { j++; }
			c = pParse->zJson[j];
			if (c == ',') continue;
			if (c != '}') return -1;
			break;
		}
		pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;
		return j + 1;
	}
	else if (c == '[') {
		
		iThis = jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);
		if (iThis<0) return -1;
		for (j = i + 1;; j++) {
			while (safe_isspace(pParse->zJson[j])) { j++; }
			x = jsonParseValue(pParse, j);
			if (x<0) {
				if (x == (-3) && pParse->nNode == (u32)iThis + 1) return j + 1;
				return -1;
			}
			j = x;
			while (safe_isspace(pParse->zJson[j])) { j++; }
			c = pParse->zJson[j];
			if (c == ',') continue;
			if (c != ']') return -1;
			break;
		}
		pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;
		return j + 1;
	}
	else if (c == '"') {
		
		u8 jnFlags = 0;
		j = i + 1;
		for (;;) {
			c = pParse->zJson[j];
			if (c == 0) return -1;
			if (c == '\\') {
				c = pParse->zJson[++j];
				if (c == '"' || c == '\\' || c == '/' || c == 'b' || c == 'f'
					|| c == 'n' || c == 'r' || c == 't'
					|| (c == 'u' && jsonIs4Hex(pParse->zJson + j + 1))) {
					jnFlags = JNODE_ESCAPE;
				}
				else {
					return -1;
				}
			}
			else if (c == '"') {
				break;
			}
			j++;
		}
		jsonParseAddNode(pParse, JSON_STRING, j + 1 - i, &pParse->zJson[i]);
		if (!pParse->oom) pParse->aNode[pParse->nNode - 1].jnFlags = jnFlags;
		return j + 1;
	}
	else if (c == 'n'
		&& strncmp(pParse->zJson + i, "null", 4) == 0
		&& !safe_isalnum(pParse->zJson[i + 4])) {
		jsonParseAddNode(pParse, JSON_NULL, 0, 0);
		return i + 4;
	}
	else if (c == 't'
		&& strncmp(pParse->zJson + i, "true", 4) == 0
		&& !safe_isalnum(pParse->zJson[i + 4])) {
		jsonParseAddNode(pParse, JSON_TRUE, 0, 0);
		return i + 4;
	}
	else if (c == 'f'
		&& strncmp(pParse->zJson + i, "false", 5) == 0
		&& !safe_isalnum(pParse->zJson[i + 5])) {
		jsonParseAddNode(pParse, JSON_FALSE, 0, 0);
		return i + 5;
	}
	else if (c == '-' || (c >= '0' && c <= '9')) {
		
		u8 seenDP = 0;
		u8 seenE = 0;
		j = i + 1;
		for (;; j++) {
			c = pParse->zJson[j];
			if (c >= '0' && c <= '9') continue;
			if (c == '.') {
				if (pParse->zJson[j - 1] == '-') return -1;
				if (seenDP) return -1;
				seenDP = 1;
				continue;
			}
			if (c == 'e' || c == 'E') {
				if (pParse->zJson[j - 1]<'0') return -1;
				if (seenE) return -1;
				seenDP = seenE = 1;
				c = pParse->zJson[j + 1];
				if (c == '+' || c == '-') {
					j++;
					c = pParse->zJson[j + 1];
				}
				if (c<'0' || c>'9') return -1;
				continue;
			}
			break;
		}
		if (pParse->zJson[j - 1]<'0') return -1;
		jsonParseAddNode(pParse, seenDP ? JSON_REAL : JSON_INT,
			j - i, &pParse->zJson[i]);
		return j;
	}
	else if (c == '}') {
		return -2;  
	}
	else if (c == ']') {
		return -3;  
	}
	else if (c == 0) {
		return 0;   
	}
	else {
		return -1;  
	}
}


static int jsonParse(
	JsonParse *pParse,           
	sqlite3_context *pCtx,       
	const char *zJson            
) {
	int i;
	memset(pParse, 0, sizeof(*pParse));
	if (zJson == 0) return 1;
	pParse->zJson = zJson;
	i = jsonParseValue(pParse, 0);
	if (pParse->oom) i = -1;
	if (i>0) {
		while (safe_isspace(zJson[i])) i++;
		if (zJson[i]) i = -1;
	}
	if (i <= 0) {
		if (pCtx != 0) {
			if (pParse->oom) {
				sqlite3_result_error_nomem(pCtx);
			}
			else {
				sqlite3_result_error(pCtx, "malformed JSON", -1);
			}
		}
		jsonParseReset(pParse);
		return 1;
	}
	return 0;
}


static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent) {
	JsonNode *pNode = &pParse->aNode[i];
	u32 j;
	pParse->aUp[i] = iParent;
	switch (pNode->eType) {
	case JSON_ARRAY: {
		for (j = 1; j <= pNode->n; j += jsonNodeSize(pNode + j)) {
			jsonParseFillInParentage(pParse, i + j, i);
		}
		break;
	}
	case JSON_OBJECT: {
		for (j = 1; j <= pNode->n; j += jsonNodeSize(pNode + j + 1) + 1) {
			pParse->aUp[i + j] = i;
			jsonParseFillInParentage(pParse, i + j + 1, i);
		}
		break;
	}
	default: {
		break;
	}
	}
}


static int jsonParseFindParents(JsonParse *pParse) {
	u32 *aUp;
	assert(pParse->aUp == 0);
	aUp = pParse->aUp = sqlite3_malloc(sizeof(u32)*pParse->nNode);
	if (aUp == 0) {
		pParse->oom = 1;
		return SQLITE_NOMEM;
	}
	jsonParseFillInParentage(pParse, 0, 0);
	return SQLITE_OK;
}


static int jsonLabelCompare(JsonNode *pNode, const char *zKey, u32 nKey) {
	if (pNode->jnFlags & JNODE_RAW) {
		if (pNode->n != nKey) return 0;
		return strncmp(pNode->u.zJContent, zKey, nKey) == 0;
	}
	else {
		if (pNode->n != nKey + 2) return 0;
		return strncmp(pNode->u.zJContent + 1, zKey, nKey) == 0;
	}
}


static JsonNode *jsonLookupAppend(JsonParse*, const char*, int*, const char**);


static JsonNode *jsonLookupStep(
	JsonParse *pParse,      
	u32 iRoot,              
	const char *zPath,      
	int *pApnd,             
	const char **pzErr      
) {
	u32 i, j, nKey;
	const char *zKey;
	JsonNode *pRoot = &pParse->aNode[iRoot];
	if (zPath[0] == 0) return pRoot;
	if (zPath[0] == '.') {
		if (pRoot->eType != JSON_OBJECT) return 0;
		zPath++;
		if (zPath[0] == '"') {
			zKey = zPath + 1;
			for (i = 1; zPath[i] && zPath[i] != '"'; i++) {}
			nKey = i - 1;
			if (zPath[i]) {
				i++;
			}
			else {
				*pzErr = zPath;
				return 0;
			}
		}
		else {
			zKey = zPath;
			for (i = 0; zPath[i] && zPath[i] != '.' && zPath[i] != '['; i++) {}
			nKey = i;
		}
		if (nKey == 0) {
			*pzErr = zPath;
			return 0;
		}
		j = 1;
		for (;;) {
			while (j <= pRoot->n) {
				if (jsonLabelCompare(pRoot + j, zKey, nKey)) {
					return jsonLookupStep(pParse, iRoot + j + 1, &zPath[i], pApnd, pzErr);
				}
				j++;
				j += jsonNodeSize(&pRoot[j]);
			}
			if ((pRoot->jnFlags & JNODE_APPEND) == 0) break;
			iRoot += pRoot->u.iAppend;
			pRoot = &pParse->aNode[iRoot];
			j = 1;
		}
		if (pApnd) {
			u32 iStart, iLabel;
			JsonNode *pNode;
			iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);
			iLabel = jsonParseAddNode(pParse, JSON_STRING, i, zPath);
			zPath += i;
			pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
			if (pParse->oom) return 0;
			if (pNode) {
				pRoot = &pParse->aNode[iRoot];
				pRoot->u.iAppend = iStart - iRoot;
				pRoot->jnFlags |= JNODE_APPEND;
				pParse->aNode[iLabel].jnFlags |= JNODE_RAW;
			}
			return pNode;
		}
	}
	else if (zPath[0] == '[' && safe_isdigit(zPath[1])) {
		if (pRoot->eType != JSON_ARRAY) return 0;
		i = 0;
		j = 1;
		while (safe_isdigit(zPath[j])) {
			i = i * 10 + zPath[j] - '0';
			j++;
		}
		if (zPath[j] != ']') {
			*pzErr = zPath;
			return 0;
		}
		zPath += j + 1;
		j = 1;
		for (;;) {
			while (j <= pRoot->n && (i>0 || (pRoot[j].jnFlags & JNODE_REMOVE) != 0)) {
				if ((pRoot[j].jnFlags & JNODE_REMOVE) == 0) i--;
				j += jsonNodeSize(&pRoot[j]);
			}
			if ((pRoot->jnFlags & JNODE_APPEND) == 0) break;
			iRoot += pRoot->u.iAppend;
			pRoot = &pParse->aNode[iRoot];
			j = 1;
		}
		if (j <= pRoot->n) {
			return jsonLookupStep(pParse, iRoot + j, zPath, pApnd, pzErr);
		}
		if (i == 0 && pApnd) {
			u32 iStart;
			JsonNode *pNode;
			iStart = jsonParseAddNode(pParse, JSON_ARRAY, 1, 0);
			pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
			if (pParse->oom) return 0;
			if (pNode) {
				pRoot = &pParse->aNode[iRoot];
				pRoot->u.iAppend = iStart - iRoot;
				pRoot->jnFlags |= JNODE_APPEND;
			}
			return pNode;
		}
	}
	else {
		*pzErr = zPath;
	}
	return 0;
}


static JsonNode *jsonLookupAppend(
	JsonParse *pParse,     
	const char *zPath,     
	int *pApnd,            
	const char **pzErr     
) {
	*pApnd = 1;
	if (zPath[0] == 0) {
		jsonParseAddNode(pParse, JSON_NULL, 0, 0);
		return pParse->oom ? 0 : &pParse->aNode[pParse->nNode - 1];
	}
	if (zPath[0] == '.') {
		jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);
	}
	else if (strncmp(zPath, "[0]", 3) == 0) {
		jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);
	}
	else {
		return 0;
	}
	if (pParse->oom) return 0;
	return jsonLookupStep(pParse, pParse->nNode - 1, zPath, pApnd, pzErr);
}


static char *jsonPathSyntaxError(const char *zErr) {
	return sqlite3_mprintf("JSON path error near '%q'", zErr);
}


static JsonNode *jsonLookup(
	JsonParse *pParse,      
	const char *zPath,      
	int *pApnd,             
	sqlite3_context *pCtx   
) {
	const char *zErr = 0;
	JsonNode *pNode = 0;
	char *zMsg;

	if (zPath == 0) return 0;
	if (zPath[0] != '$') {
		zErr = zPath;
		goto lookup_err;
	}
	zPath++;
	pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);
	if (zErr == 0) return pNode;

lookup_err:
	pParse->nErr++;
	assert(zErr != 0 && pCtx != 0);
	zMsg = jsonPathSyntaxError(zErr);
	if (zMsg) {
		sqlite3_result_error(pCtx, zMsg, -1);
		sqlite3_free(zMsg);
	}
	else {
		sqlite3_result_error_nomem(pCtx);
	}
	return 0;
}



static void jsonWrongNumArgs(
	sqlite3_context *pCtx,
	const char *zFuncName
) {
	char *zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments",
		zFuncName);
	sqlite3_result_error(pCtx, zMsg, -1);
	sqlite3_free(zMsg);
}




#ifdef SQLITE_DEBUG

static void jsonParseFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonString s;       
	JsonParse x;        
	u32 i;

	assert(argc == 1);
	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	jsonParseFindParents(&x);
	jsonInit(&s, ctx);
	for (i = 0; i<x.nNode; i++) {
		const char *zType;
		if (x.aNode[i].jnFlags & JNODE_LABEL) {
			assert(x.aNode[i].eType == JSON_STRING);
			zType = "label";
		}
		else {
			zType = jsonType[x.aNode[i].eType];
		}
		jsonPrintf(100, &s, "node %3u: %7s n=%-4d up=%-4d",
			i, zType, x.aNode[i].n, x.aUp[i]);
		if (x.aNode[i].u.zJContent != 0) {
			jsonAppendRaw(&s, " ", 1);
			jsonAppendRaw(&s, x.aNode[i].u.zJContent, x.aNode[i].n);
		}
		jsonAppendRaw(&s, "\n", 1);
	}
	jsonParseReset(&x);
	jsonResult(&s);
}


static void jsonTest1Func(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	UNUSED_PARAM(argc);
	sqlite3_result_int(ctx, sqlite3_value_subtype(argv[0]) == JSON_SUBTYPE);
}
#endif 




static void jsonQuoteFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonString jx;
	UNUSED_PARAM(argc);

	jsonInit(&jx, ctx);
	jsonAppendValue(&jx, argv[0]);
	jsonResult(&jx);
	sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}


static void jsonArrayFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	int i;
	JsonString jx;

	jsonInit(&jx, ctx);
	jsonAppendChar(&jx, '[');
	for (i = 0; i<argc; i++) {
		jsonAppendSeparator(&jx);
		jsonAppendValue(&jx, argv[i]);
	}
	jsonAppendChar(&jx, ']');
	jsonResult(&jx);
	sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}



static void jsonArrayLengthFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	sqlite3_int64 n = 0;
	u32 i;
	JsonNode *pNode;

	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	assert(x.nNode);
	if (argc == 2) {
		const char *zPath = (const char*)sqlite3_value_text(argv[1]);
		pNode = jsonLookup(&x, zPath, 0, ctx);
	}
	else {
		pNode = x.aNode;
	}
	if (pNode == 0) {
		x.nErr = 1;
	}
	else if (pNode->eType == JSON_ARRAY) {
		assert((pNode->jnFlags & JNODE_APPEND) == 0);
		for (i = 1; i <= pNode->n; n++) {
			i += jsonNodeSize(&pNode[i]);
		}
	}
	if (x.nErr == 0) sqlite3_result_int64(ctx, n);
	jsonParseReset(&x);
}


static void jsonExtractFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	JsonNode *pNode;
	const char *zPath;
	JsonString jx;
	int i;

	if (argc<2) return;
	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	jsonInit(&jx, ctx);
	jsonAppendChar(&jx, '[');
	for (i = 1; i<argc; i++) {
		zPath = (const char*)sqlite3_value_text(argv[i]);
		pNode = jsonLookup(&x, zPath, 0, ctx);
		if (x.nErr) break;
		if (argc>2) {
			jsonAppendSeparator(&jx);
			if (pNode) {
				jsonRenderNode(pNode, &jx, 0);
			}
			else {
				jsonAppendRaw(&jx, "null", 4);
			}
		}
		else if (pNode) {
			jsonReturn(pNode, ctx, 0);
		}
	}
	if (argc>2 && i == argc) {
		jsonAppendChar(&jx, ']');
		jsonResult(&jx);
		sqlite3_result_subtype(ctx, JSON_SUBTYPE);
	}
	jsonReset(&jx);
	jsonParseReset(&x);
}


static void jsonObjectFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	int i;
	JsonString jx;
	const char *z;
	u32 n;

	if (argc & 1) {
		sqlite3_result_error(ctx, "json_object() requires an even number "
			"of arguments", -1);
		return;
	}
	jsonInit(&jx, ctx);
	jsonAppendChar(&jx, '{');
	for (i = 0; i<argc; i += 2) {
		if (sqlite3_value_type(argv[i]) != SQLITE_TEXT) {
			sqlite3_result_error(ctx, "json_object() labels must be TEXT", -1);
			jsonReset(&jx);
			return;
		}
		jsonAppendSeparator(&jx);
		z = (const char*)sqlite3_value_text(argv[i]);
		n = (u32)sqlite3_value_bytes(argv[i]);
		jsonAppendString(&jx, z, n);
		jsonAppendChar(&jx, ':');
		jsonAppendValue(&jx, argv[i + 1]);
	}
	jsonAppendChar(&jx, '}');
	jsonResult(&jx);
	sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}



static void jsonRemoveFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	JsonNode *pNode;
	const char *zPath;
	u32 i;

	if (argc<1) return;
	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	assert(x.nNode);
	for (i = 1; i<(u32)argc; i++) {
		zPath = (const char*)sqlite3_value_text(argv[i]);
		if (zPath == 0) goto remove_done;
		pNode = jsonLookup(&x, zPath, 0, ctx);
		if (x.nErr) goto remove_done;
		if (pNode) pNode->jnFlags |= JNODE_REMOVE;
	}
	if ((x.aNode[0].jnFlags & JNODE_REMOVE) == 0) {
		jsonReturnJson(x.aNode, ctx, 0);
	}
remove_done:
	jsonParseReset(&x);
}


static void jsonReplaceFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	JsonNode *pNode;
	const char *zPath;
	u32 i;

	if (argc<1) return;
	if ((argc & 1) == 0) {
		jsonWrongNumArgs(ctx, "replace");
		return;
	}
	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	assert(x.nNode);
	for (i = 1; i<(u32)argc; i += 2) {
		zPath = (const char*)sqlite3_value_text(argv[i]);
		pNode = jsonLookup(&x, zPath, 0, ctx);
		if (x.nErr) goto replace_err;
		if (pNode) {
			pNode->jnFlags |= (u8)JNODE_REPLACE;
			pNode->iVal = (u8)(i + 1);
		}
	}
	if (x.aNode[0].jnFlags & JNODE_REPLACE) {
		sqlite3_result_value(ctx, argv[x.aNode[0].iVal]);
	}
	else {
		jsonReturnJson(x.aNode, ctx, argv);
	}
replace_err:
	jsonParseReset(&x);
}


static void jsonSetFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	JsonNode *pNode;
	const char *zPath;
	u32 i;
	int bApnd;
	int bIsSet = *(int*)sqlite3_user_data(ctx);

	if (argc<1) return;
	if ((argc & 1) == 0) {
		jsonWrongNumArgs(ctx, bIsSet ? "set" : "insert");
		return;
	}
	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	assert(x.nNode);
	for (i = 1; i<(u32)argc; i += 2) {
		zPath = (const char*)sqlite3_value_text(argv[i]);
		bApnd = 0;
		pNode = jsonLookup(&x, zPath, &bApnd, ctx);
		if (x.oom) {
			sqlite3_result_error_nomem(ctx);
			goto jsonSetDone;
		}
		else if (x.nErr) {
			goto jsonSetDone;
		}
		else if (pNode && (bApnd || bIsSet)) {
			pNode->jnFlags |= (u8)JNODE_REPLACE;
			pNode->iVal = (u8)(i + 1);
		}
	}
	if (x.aNode[0].jnFlags & JNODE_REPLACE) {
		sqlite3_result_value(ctx, argv[x.aNode[0].iVal]);
	}
	else {
		jsonReturnJson(x.aNode, ctx, argv);
	}
jsonSetDone:
	jsonParseReset(&x);
}


static void jsonTypeFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	const char *zPath;
	JsonNode *pNode;

	if (jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0]))) return;
	assert(x.nNode);
	if (argc == 2) {
		zPath = (const char*)sqlite3_value_text(argv[1]);
		pNode = jsonLookup(&x, zPath, 0, ctx);
	}
	else {
		pNode = x.aNode;
	}
	if (pNode) {
		sqlite3_result_text(ctx, jsonType[pNode->eType], -1, SQLITE_STATIC);
	}
	jsonParseReset(&x);
}


static void jsonValidFunc(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonParse x;          
	int rc = 0;

	UNUSED_PARAM(argc);
	if (jsonParse(&x, 0, (const char*)sqlite3_value_text(argv[0])) == 0) {
		rc = 1;
	}
	jsonParseReset(&x);
	sqlite3_result_int(ctx, rc);
}




static void jsonArrayStep(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonString *pStr;
	UNUSED_PARAM(argc);
	pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
	if (pStr) {
		if (pStr->zBuf == 0) {
			jsonInit(pStr, ctx);
			jsonAppendChar(pStr, '[');
		}
		else {
			jsonAppendChar(pStr, ',');
			pStr->pCtx = ctx;
		}
		jsonAppendValue(pStr, argv[0]);
	}
}
static void jsonArrayFinal(sqlite3_context *ctx) {
	JsonString *pStr;
	pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
	if (pStr) {
		pStr->pCtx = ctx;
		jsonAppendChar(pStr, ']');
		if (pStr->bErr) {
			if (pStr->bErr == 1) sqlite3_result_error_nomem(ctx);
			assert(pStr->bStatic);
		}
		else {
			sqlite3_result_text(ctx, pStr->zBuf, pStr->nUsed,
				pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);
			pStr->bStatic = 1;
		}
	}
	else {
		sqlite3_result_text(ctx, "[]", 2, SQLITE_STATIC);
	}
	sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}


static void jsonObjectStep(
	sqlite3_context *ctx,
	int argc,
	sqlite3_value **argv
) {
	JsonString *pStr;
	const char *z;
	u32 n;
	UNUSED_PARAM(argc);
	pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
	if (pStr) {
		if (pStr->zBuf == 0) {
			jsonInit(pStr, ctx);
			jsonAppendChar(pStr, '{');
		}
		else {
			jsonAppendChar(pStr, ',');
			pStr->pCtx = ctx;
		}
		z = (const char*)sqlite3_value_text(argv[0]);
		n = (u32)sqlite3_value_bytes(argv[0]);
		jsonAppendString(pStr, z, n);
		jsonAppendChar(pStr, ':');
		jsonAppendValue(pStr, argv[1]);
	}
}
static void jsonObjectFinal(sqlite3_context *ctx) {
	JsonString *pStr;
	pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
	if (pStr) {
		jsonAppendChar(pStr, '}');
		if (pStr->bErr) {
			if (pStr->bErr == 1) sqlite3_result_error_nomem(ctx);
			assert(pStr->bStatic);
		}
		else {
			sqlite3_result_text(ctx, pStr->zBuf, pStr->nUsed,
				pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);
			pStr->bStatic = 1;
		}
	}
	else {
		sqlite3_result_text(ctx, "{}", 2, SQLITE_STATIC);
	}
	sqlite3_result_subtype(ctx, JSON_SUBTYPE);
}


#ifndef SQLITE_OMIT_VIRTUALTABLE

typedef struct JsonEachCursor JsonEachCursor;
struct JsonEachCursor {
	sqlite3_vtab_cursor base;  
	u32 iRowid;                
	u32 iBegin;                
	u32 i;                     
	u32 iEnd;                  
	u8 eType;                  
	u8 bRecursive;             
	char *zJson;               
	char *zRoot;               
	JsonParse sParse;          
};


static int jsonEachConnect(
	sqlite3 *db,
	void *pAux,
	int argc, const char *const*argv,
	sqlite3_vtab **ppVtab,
	char **pzErr
) {
	sqlite3_vtab *pNew;
	int rc;

	
#define JEACH_KEY     0
#define JEACH_VALUE   1
#define JEACH_TYPE    2
#define JEACH_ATOM    3
#define JEACH_ID      4
#define JEACH_PARENT  5
#define JEACH_FULLKEY 6
#define JEACH_PATH    7
#define JEACH_JSON    8
#define JEACH_ROOT    9

	UNUSED_PARAM(pzErr);
	UNUSED_PARAM(argv);
	UNUSED_PARAM(argc);
	UNUSED_PARAM(pAux);
	rc = sqlite3_declare_vtab(db,
		"CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"
		"json HIDDEN,root HIDDEN)");
	if (rc == SQLITE_OK) {
		pNew = *ppVtab = sqlite3_malloc(sizeof(*pNew));
		if (pNew == 0) return SQLITE_NOMEM;
		memset(pNew, 0, sizeof(*pNew));
	}
	return rc;
}


static int jsonEachDisconnect(sqlite3_vtab *pVtab) {
	sqlite3_free(pVtab);
	return SQLITE_OK;
}


static int jsonEachOpenEach(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor) {
	JsonEachCursor *pCur;

	UNUSED_PARAM(p);
	pCur = sqlite3_malloc(sizeof(*pCur));
	if (pCur == 0) return SQLITE_NOMEM;
	memset(pCur, 0, sizeof(*pCur));
	*ppCursor = &pCur->base;
	return SQLITE_OK;
}


static int jsonEachOpenTree(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor) {
	int rc = jsonEachOpenEach(p, ppCursor);
	if (rc == SQLITE_OK) {
		JsonEachCursor *pCur = (JsonEachCursor*)*ppCursor;
		pCur->bRecursive = 1;
	}
	return rc;
}


static void jsonEachCursorReset(JsonEachCursor *p) {
	sqlite3_free(p->zJson);
	sqlite3_free(p->zRoot);
	jsonParseReset(&p->sParse);
	p->iRowid = 0;
	p->i = 0;
	p->iEnd = 0;
	p->eType = 0;
	p->zJson = 0;
	p->zRoot = 0;
}


static int jsonEachClose(sqlite3_vtab_cursor *cur) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	jsonEachCursorReset(p);
	sqlite3_free(cur);
	return SQLITE_OK;
}


static int jsonEachEof(sqlite3_vtab_cursor *cur) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	return p->i >= p->iEnd;
}


static int jsonEachNext(sqlite3_vtab_cursor *cur) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	if (p->bRecursive) {
		if (p->sParse.aNode[p->i].jnFlags & JNODE_LABEL) p->i++;
		p->i++;
		p->iRowid++;
		if (p->i<p->iEnd) {
			u32 iUp = p->sParse.aUp[p->i];
			JsonNode *pUp = &p->sParse.aNode[iUp];
			p->eType = pUp->eType;
			if (pUp->eType == JSON_ARRAY) {
				if (iUp == p->i - 1) {
					pUp->u.iKey = 0;
				}
				else {
					pUp->u.iKey++;
				}
			}
		}
	}
	else {
		switch (p->eType) {
		case JSON_ARRAY: {
			p->i += jsonNodeSize(&p->sParse.aNode[p->i]);
			p->iRowid++;
			break;
		}
		case JSON_OBJECT: {
			p->i += 1 + jsonNodeSize(&p->sParse.aNode[p->i + 1]);
			p->iRowid++;
			break;
		}
		default: {
			p->i = p->iEnd;
			break;
		}
		}
	}
	return SQLITE_OK;
}


static void jsonEachComputePath(
	JsonEachCursor *p,       
	JsonString *pStr,        
	u32 i                    
) {
	JsonNode *pNode, *pUp;
	u32 iUp;
	if (i == 0) {
		jsonAppendChar(pStr, '$');
		return;
	}
	iUp = p->sParse.aUp[i];
	jsonEachComputePath(p, pStr, iUp);
	pNode = &p->sParse.aNode[i];
	pUp = &p->sParse.aNode[iUp];
	if (pUp->eType == JSON_ARRAY) {
		jsonPrintf(30, pStr, "[%d]", pUp->u.iKey);
	}
	else {
		assert(pUp->eType == JSON_OBJECT);
		if ((pNode->jnFlags & JNODE_LABEL) == 0) pNode--;
		assert(pNode->eType == JSON_STRING);
		assert(pNode->jnFlags & JNODE_LABEL);
		jsonPrintf(pNode->n + 1, pStr, ".%.*s", pNode->n - 2, pNode->u.zJContent + 1);
	}
}


static int jsonEachColumn(
	sqlite3_vtab_cursor *cur,   
	sqlite3_context *ctx,       
	int i                       
) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	JsonNode *pThis = &p->sParse.aNode[p->i];
	switch (i) {
	case JEACH_KEY: {
		if (p->i == 0) break;
		if (p->eType == JSON_OBJECT) {
			jsonReturn(pThis, ctx, 0);
		}
		else if (p->eType == JSON_ARRAY) {
			u32 iKey;
			if (p->bRecursive) {
				if (p->iRowid == 0) break;
				iKey = p->sParse.aNode[p->sParse.aUp[p->i]].u.iKey;
			}
			else {
				iKey = p->iRowid;
			}
			sqlite3_result_int64(ctx, (sqlite3_int64)iKey);
		}
		break;
	}
	case JEACH_VALUE: {
		if (pThis->jnFlags & JNODE_LABEL) pThis++;
		jsonReturn(pThis, ctx, 0);
		break;
	}
	case JEACH_TYPE: {
		if (pThis->jnFlags & JNODE_LABEL) pThis++;
		sqlite3_result_text(ctx, jsonType[pThis->eType], -1, SQLITE_STATIC);
		break;
	}
	case JEACH_ATOM: {
		if (pThis->jnFlags & JNODE_LABEL) pThis++;
		if (pThis->eType >= JSON_ARRAY) break;
		jsonReturn(pThis, ctx, 0);
		break;
	}
	case JEACH_ID: {
		sqlite3_result_int64(ctx,
			(sqlite3_int64)p->i + ((pThis->jnFlags & JNODE_LABEL) != 0));
		break;
	}
	case JEACH_PARENT: {
		if (p->i>p->iBegin && p->bRecursive) {
			sqlite3_result_int64(ctx, (sqlite3_int64)p->sParse.aUp[p->i]);
		}
		break;
	}
	case JEACH_FULLKEY: {
		JsonString x;
		jsonInit(&x, ctx);
		if (p->bRecursive) {
			jsonEachComputePath(p, &x, p->i);
		}
		else {
			if (p->zRoot) {
				jsonAppendRaw(&x, p->zRoot, (int)strlen(p->zRoot));
			}
			else {
				jsonAppendChar(&x, '$');
			}
			if (p->eType == JSON_ARRAY) {
				jsonPrintf(30, &x, "[%d]", p->iRowid);
			}
			else {
				jsonPrintf(pThis->n, &x, ".%.*s", pThis->n - 2, pThis->u.zJContent + 1);
			}
		}
		jsonResult(&x);
		break;
	}
	case JEACH_PATH: {
		if (p->bRecursive) {
			JsonString x;
			jsonInit(&x, ctx);
			jsonEachComputePath(p, &x, p->sParse.aUp[p->i]);
			jsonResult(&x);
			break;
		}
		
	}
	default: {
		const char *zRoot = p->zRoot;
		if (zRoot == 0) zRoot = "$";
		sqlite3_result_text(ctx, zRoot, -1, SQLITE_STATIC);
		break;
	}
	case JEACH_JSON: {
		assert(i == JEACH_JSON);
		sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_STATIC);
		break;
	}
	}
	return SQLITE_OK;
}


static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	*pRowid = p->iRowid;
	return SQLITE_OK;
}


static int jsonEachBestIndex(
	sqlite3_vtab *tab,
	sqlite3_index_info *pIdxInfo
) {
	int i;
	int jsonIdx = -1;
	int rootIdx = -1;
	const struct sqlite3_index_constraint *pConstraint;

	UNUSED_PARAM(tab);
	pConstraint = pIdxInfo->aConstraint;
	for (i = 0; i<pIdxInfo->nConstraint; i++, pConstraint++) {
		if (pConstraint->usable == 0) continue;
		if (pConstraint->op != SQLITE_INDEX_CONSTRAINT_EQ) continue;
		switch (pConstraint->iColumn) {
		case JEACH_JSON:   jsonIdx = i;    break;
		case JEACH_ROOT:   rootIdx = i;    break;
		default:                break;
		}
	}
	if (jsonIdx<0) {
		pIdxInfo->idxNum = 0;
		pIdxInfo->estimatedCost = 1e99;
	}
	else {
		pIdxInfo->estimatedCost = 1.0;
		pIdxInfo->aConstraintUsage[jsonIdx].argvIndex = 1;
		pIdxInfo->aConstraintUsage[jsonIdx].omit = 1;
		if (rootIdx<0) {
			pIdxInfo->idxNum = 1;
		}
		else {
			pIdxInfo->aConstraintUsage[rootIdx].argvIndex = 2;
			pIdxInfo->aConstraintUsage[rootIdx].omit = 1;
			pIdxInfo->idxNum = 3;
		}
	}
	return SQLITE_OK;
}


static int jsonEachFilter(
	sqlite3_vtab_cursor *cur,
	int idxNum, const char *idxStr,
	int argc, sqlite3_value **argv
) {
	JsonEachCursor *p = (JsonEachCursor*)cur;
	const char *z;
	const char *zRoot = 0;
	sqlite3_int64 n;

	UNUSED_PARAM(idxStr);
	UNUSED_PARAM(argc);
	jsonEachCursorReset(p);
	if (idxNum == 0) return SQLITE_OK;
	z = (const char*)sqlite3_value_text(argv[0]);
	if (z == 0) return SQLITE_OK;
	n = sqlite3_value_bytes(argv[0]);
	p->zJson = sqlite3_malloc64(n + 1);
	if (p->zJson == 0) return SQLITE_NOMEM;
	memcpy(p->zJson, z, (size_t)n + 1);
	if (jsonParse(&p->sParse, 0, p->zJson)) {
		int rc = SQLITE_NOMEM;
		if (p->sParse.oom == 0) {
			sqlite3_free(cur->pVtab->zErrMsg);
			cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");
			if (cur->pVtab->zErrMsg) rc = SQLITE_ERROR;
		}
		jsonEachCursorReset(p);
		return rc;
	}
	else if (p->bRecursive && jsonParseFindParents(&p->sParse)) {
		jsonEachCursorReset(p);
		return SQLITE_NOMEM;
	}
	else {
		JsonNode *pNode = 0;
		if (idxNum == 3) {
			const char *zErr = 0;
			zRoot = (const char*)sqlite3_value_text(argv[1]);
			if (zRoot == 0) return SQLITE_OK;
			n = sqlite3_value_bytes(argv[1]);
			p->zRoot = sqlite3_malloc64(n + 1);
			if (p->zRoot == 0) return SQLITE_NOMEM;
			memcpy(p->zRoot, zRoot, (size_t)n + 1);
			if (zRoot[0] != '$') {
				zErr = zRoot;
			}
			else {
				pNode = jsonLookupStep(&p->sParse, 0, p->zRoot + 1, 0, &zErr);
			}
			if (zErr) {
				sqlite3_free(cur->pVtab->zErrMsg);
				cur->pVtab->zErrMsg = jsonPathSyntaxError(zErr);
				jsonEachCursorReset(p);
				return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;
			}
			else if (pNode == 0) {
				return SQLITE_OK;
			}
		}
		else {
			pNode = p->sParse.aNode;
		}
		p->iBegin = p->i = (int)(pNode - p->sParse.aNode);
		p->eType = pNode->eType;
		if (p->eType >= JSON_ARRAY) {
			pNode->u.iKey = 0;
			p->iEnd = p->i + pNode->n + 1;
			if (p->bRecursive) {
				p->eType = p->sParse.aNode[p->sParse.aUp[p->i]].eType;
				if (p->i>0 && (p->sParse.aNode[p->i - 1].jnFlags & JNODE_LABEL) != 0) {
					p->i--;
				}
			}
			else {
				p->i++;
			}
		}
		else {
			p->iEnd = p->i + 1;
		}
	}
	return SQLITE_OK;
}


static sqlite3_module jsonEachModule = {
	0,                         
	0,                         
	jsonEachConnect,           
	jsonEachBestIndex,         
	jsonEachDisconnect,        
	0,                         
	jsonEachOpenEach,          
	jsonEachClose,             
	jsonEachFilter,            
	jsonEachNext,              
	jsonEachEof,               
	jsonEachColumn,            
	jsonEachRowid,             
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0                          
};


static sqlite3_module jsonTreeModule = {
	0,                         
	0,                         
	jsonEachConnect,           
	jsonEachBestIndex,         
	jsonEachDisconnect,        
	0,                         
	jsonEachOpenTree,          
	jsonEachClose,             
	jsonEachFilter,            
	jsonEachNext,              
	jsonEachEof,               
	jsonEachColumn,            
	jsonEachRowid,             
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0,                         
	0                          
};
#endif 



SQLITE_PRIVATE int sqlite3Json1Init(sqlite3 *db) {
	int rc = SQLITE_OK;
	unsigned int i;
	static const struct {
		const char *zName;
		int nArg;
		int flag;
		void(*xFunc)(sqlite3_context*, int, sqlite3_value**);
	} aFunc[] = {
		{ "json",                 1, 0,   jsonRemoveFunc },
		{ "json_array",          -1, 0,   jsonArrayFunc },
		{ "json_array_length",    1, 0,   jsonArrayLengthFunc },
		{ "json_array_length",    2, 0,   jsonArrayLengthFunc },
		{ "json_extract",        -1, 0,   jsonExtractFunc },
		{ "json_insert",         -1, 0,   jsonSetFunc },
		{ "json_object",         -1, 0,   jsonObjectFunc },
		{ "json_quote",           1, 0,   jsonQuoteFunc },
		{ "json_remove",         -1, 0,   jsonRemoveFunc },
		{ "json_replace",        -1, 0,   jsonReplaceFunc },
		{ "json_set",            -1, 1,   jsonSetFunc },
		{ "json_type",            1, 0,   jsonTypeFunc },
		{ "json_type",            2, 0,   jsonTypeFunc },
		{ "json_valid",           1, 0,   jsonValidFunc },

#if SQLITE_DEBUG
		
		{ "json_parse",           1, 0,   jsonParseFunc },
		{ "json_test1",           1, 0,   jsonTest1Func },
#endif
	};
	static const struct {
		const char *zName;
		int nArg;
		void(*xStep)(sqlite3_context*, int, sqlite3_value**);
		void(*xFinal)(sqlite3_context*);
	} aAgg[] = {
		{ "json_group_array",     1,   jsonArrayStep,   jsonArrayFinal },
		{ "json_group_object",    2,   jsonObjectStep,  jsonObjectFinal },
	};
#ifndef SQLITE_OMIT_VIRTUALTABLE
	static const struct {
		const char *zName;
		sqlite3_module *pModule;
	} aMod[] = {
		{ "json_each",            &jsonEachModule },
		{ "json_tree",            &jsonTreeModule },
	};
#endif
	for (i = 0; i<sizeof(aFunc) / sizeof(aFunc[0]) && rc == SQLITE_OK; i++) {
		rc = sqlite3_create_function(db, aFunc[i].zName, aFunc[i].nArg,
			SQLITE_UTF8 | SQLITE_DETERMINISTIC,
			(void*)&aFunc[i].flag,
			aFunc[i].xFunc, 0, 0);
	}
	for (i = 0; i<sizeof(aAgg) / sizeof(aAgg[0]) && rc == SQLITE_OK; i++) {
		rc = sqlite3_create_function(db, aAgg[i].zName, aAgg[i].nArg,
			SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,
			0, aAgg[i].xStep, aAgg[i].xFinal);
	}
#ifndef SQLITE_OMIT_VIRTUALTABLE
	for (i = 0; i<sizeof(aMod) / sizeof(aMod[0]) && rc == SQLITE_OK; i++) {
		rc = sqlite3_create_module(db, aMod[i].zName, aMod[i].pModule, 0);
	}
#endif
	return rc;
}


#ifndef SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_json_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi);
	(void)pzErrMsg;  
	return sqlite3Json1Init(db);
}
#endif
#endif 





#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS5) 

#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) 
# define NDEBUG 1
#endif
#if defined(NDEBUG) && defined(SQLITE_DEBUG)
# undef NDEBUG
#endif




#ifndef _FTS5_H
#define _FTS5_H



#if 0
extern "C" {
#endif

	

	typedef struct Fts5ExtensionApi Fts5ExtensionApi;
	typedef struct Fts5Context Fts5Context;
	typedef struct Fts5PhraseIter Fts5PhraseIter;

	typedef void(*fts5_extension_function)(
		const Fts5ExtensionApi *pApi,   
		Fts5Context *pFts,              
		sqlite3_context *pCtx,          
		int nVal,                       
		sqlite3_value **apVal           
		);

	struct Fts5PhraseIter {
		const unsigned char *a;
		const unsigned char *b;
	};

	
	struct Fts5ExtensionApi {
		int iVersion;                   

		void *(*xUserData)(Fts5Context*);

		int(*xColumnCount)(Fts5Context*);
		int(*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
		int(*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

		int(*xTokenize)(Fts5Context*,
			const char *pText, int nText, 
			void *pCtx,                   
			int(*xToken)(void*, int, const char*, int, int, int)       
			);

		int(*xPhraseCount)(Fts5Context*);
		int(*xPhraseSize)(Fts5Context*, int iPhrase);

		int(*xInstCount)(Fts5Context*, int *pnInst);
		int(*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

		sqlite3_int64(*xRowid)(Fts5Context*);
		int(*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
		int(*xColumnSize)(Fts5Context*, int iCol, int *pnToken);

		int(*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
			int(*)(const Fts5ExtensionApi*, Fts5Context*, void*)
			);
		int(*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
		void *(*xGetAuxdata)(Fts5Context*, int bClear);

		int(*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
		void(*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

		int(*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
		void(*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);
	};

	

	
	typedef struct Fts5Tokenizer Fts5Tokenizer;
	typedef struct fts5_tokenizer fts5_tokenizer;
	struct fts5_tokenizer {
		int(*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
		void(*xDelete)(Fts5Tokenizer*);
		int(*xTokenize)(Fts5Tokenizer*,
			void *pCtx,
			int flags,            
			const char *pText, int nText,
			int(*xToken)(
				void *pCtx,         
				int tflags,         
				const char *pToken, 
				int nToken,         
				int iStart,         
				int iEnd            
				)
			);
	};

	
#define FTS5_TOKENIZE_QUERY     0x0001
#define FTS5_TOKENIZE_PREFIX    0x0002
#define FTS5_TOKENIZE_DOCUMENT  0x0004
#define FTS5_TOKENIZE_AUX       0x0008

	
#define FTS5_TOKEN_COLOCATED    0x0001      

	

	
	typedef struct fts5_api fts5_api;
	struct fts5_api {
		int iVersion;                   

										
		int(*xCreateTokenizer)(
			fts5_api *pApi,
			const char *zName,
			void *pContext,
			fts5_tokenizer *pTokenizer,
			void(*xDestroy)(void*)
			);

		
		int(*xFindTokenizer)(
			fts5_api *pApi,
			const char *zName,
			void **ppContext,
			fts5_tokenizer *pTokenizer
			);

		
		int(*xCreateFunction)(
			fts5_api *pApi,
			const char *zName,
			void *pContext,
			fts5_extension_function xFunction,
			void(*xDestroy)(void*)
			);
	};

	

#if 0
}  
#endif

#endif 

   
#ifndef _FTS5INT_H
#define _FTS5INT_H

   
   
SQLITE_EXTENSION_INIT1




#ifndef SQLITE_AMALGAMATION

typedef unsigned char  u8;
typedef unsigned int   u32;
typedef unsigned short u16;
typedef short i16;
typedef sqlite3_int64 i64;
typedef sqlite3_uint64 u64;

#define ArraySize(x) ((int)(sizeof(x) / sizeof(x[0])))

#define testcase(x)
#define ALWAYS(x) 1
#define NEVER(x) 0

#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#define MAX(x,y) (((x) > (y)) ? (x) : (y))


# define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))
# define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)

#endif


#define FTS5_MAX_TOKEN_SIZE 32768


#define FTS5_MAX_PREFIX_INDEXES 31

#define FTS5_DEFAULT_NEARDIST 10
#define FTS5_DEFAULT_RANK     "bm25"


#define FTS5_RANK_NAME "rank"
#define FTS5_ROWID_NAME "rowid"

#ifdef SQLITE_DEBUG
# define FTS5_CORRUPT sqlite3Fts5Corrupt()
static int sqlite3Fts5Corrupt(void);
#else
# define FTS5_CORRUPT SQLITE_CORRUPT_VTAB
#endif


#ifdef SQLITE_DEBUG
SQLITE_API extern int sqlite3_fts5_may_be_corrupt;
# define assert_nc(x) assert(sqlite3_fts5_may_be_corrupt || (x))
#else
# define assert_nc(x) assert(x)
#endif


#ifndef UNUSED_PARAM
# define UNUSED_PARAM(X)  (void)(X)
#endif

#ifndef UNUSED_PARAM2
# define UNUSED_PARAM2(X, Y)  (void)(X), (void)(Y)
#endif

typedef struct Fts5Global Fts5Global;
typedef struct Fts5Colset Fts5Colset;


struct Fts5Colset {
	int nCol;
	int aiCol[1];
};





typedef struct Fts5Config Fts5Config;


struct Fts5Config {
	sqlite3 *db;                    
	char *zDb;                      
	char *zName;                    
	int nCol;                       
	char **azCol;                   
	u8 *abUnindexed;                
	int nPrefix;                    
	int *aPrefix;                   
	int eContent;                   
	char *zContent;                 
	char *zContentRowid;            
	int bColumnsize;                
	int eDetail;                    
	char *zContentExprlist;
	Fts5Tokenizer *pTok;
	fts5_tokenizer *pTokApi;

	
	int iCookie;                    
	int pgsz;                       
	int nAutomerge;                 
	int nCrisisMerge;               
	int nUsermerge;                 
	int nHashSize;                  
	char *zRank;                    
	char *zRankArgs;                

									
	char **pzErrmsg;

#ifdef SQLITE_DEBUG
	int bPrefixIndex;               
#endif
};


#define FTS5_CURRENT_VERSION 4

#define FTS5_CONTENT_NORMAL   0
#define FTS5_CONTENT_NONE     1
#define FTS5_CONTENT_EXTERNAL 2

#define FTS5_DETAIL_FULL    0
#define FTS5_DETAIL_NONE    1
#define FTS5_DETAIL_COLUMNS 2



static int sqlite3Fts5ConfigParse(
	Fts5Global*, sqlite3*, int, const char **, Fts5Config**, char**
);
static void sqlite3Fts5ConfigFree(Fts5Config*);

static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig);

static int sqlite3Fts5Tokenize(
	Fts5Config *pConfig,            
	int flags,                      
	const char *pText, int nText,   
	void *pCtx,                     
	int(*xToken)(void*, int, const char*, int, int, int)    
);

static void sqlite3Fts5Dequote(char *z);


static int sqlite3Fts5ConfigLoad(Fts5Config*, int);


static int sqlite3Fts5ConfigSetValue(Fts5Config*, const char*, sqlite3_value*, int*);

static int sqlite3Fts5ConfigParseRank(const char*, char**, char**);






typedef struct Fts5Buffer Fts5Buffer;
struct Fts5Buffer {
	u8 *p;
	int n;
	int nSpace;
};

static int sqlite3Fts5BufferSize(int*, Fts5Buffer*, u32);
static void sqlite3Fts5BufferAppendVarint(int*, Fts5Buffer*, i64);
static void sqlite3Fts5BufferAppendBlob(int*, Fts5Buffer*, u32, const u8*);
static void sqlite3Fts5BufferAppendString(int *, Fts5Buffer*, const char*);
static void sqlite3Fts5BufferFree(Fts5Buffer*);
static void sqlite3Fts5BufferZero(Fts5Buffer*);
static void sqlite3Fts5BufferSet(int*, Fts5Buffer*, int, const u8*);
static void sqlite3Fts5BufferAppendPrintf(int *, Fts5Buffer*, char *zFmt, ...);

static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...);

#define fts5BufferZero(x)             sqlite3Fts5BufferZero(x)
#define fts5BufferAppendVarint(a,b,c) sqlite3Fts5BufferAppendVarint(a,b,c)
#define fts5BufferFree(a)             sqlite3Fts5BufferFree(a)
#define fts5BufferAppendBlob(a,b,c,d) sqlite3Fts5BufferAppendBlob(a,b,c,d)
#define fts5BufferSet(a,b,c,d)        sqlite3Fts5BufferSet(a,b,c,d)

#define fts5BufferGrow(pRc,pBuf,nn) ( \
  (u32)((pBuf)->n) + (u32)(nn) <= (u32)((pBuf)->nSpace) ? 0 : \
    sqlite3Fts5BufferSize((pRc),(pBuf),(nn)+(pBuf)->n) \
)


static void sqlite3Fts5Put32(u8*, int);
static int sqlite3Fts5Get32(const u8*);

#define FTS5_POS2COLUMN(iPos) (int)(iPos >> 32)
#define FTS5_POS2OFFSET(iPos) (int)(iPos & 0xFFFFFFFF)

typedef struct Fts5PoslistReader Fts5PoslistReader;
struct Fts5PoslistReader {
	
	const u8 *a;                    
	int n;                          
	int i;                          

	u8 bFlag;                       

									
	u8 bEof;                        
	i64 iPos;                       
};
static int sqlite3Fts5PoslistReaderInit(
	const u8 *a, int n,             
	Fts5PoslistReader *pIter        
);
static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader*);

typedef struct Fts5PoslistWriter Fts5PoslistWriter;
struct Fts5PoslistWriter {
	i64 iPrev;
};
static int sqlite3Fts5PoslistWriterAppend(Fts5Buffer*, Fts5PoslistWriter*, i64);
static void sqlite3Fts5PoslistSafeAppend(Fts5Buffer*, i64*, i64);

static int sqlite3Fts5PoslistNext64(
	const u8 *a, int n,             
	int *pi,                        
	i64 *piOff                      
);


static void *sqlite3Fts5MallocZero(int *pRc, int nByte);
static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn);


static int sqlite3Fts5IsBareword(char t);



typedef struct Fts5Termset Fts5Termset;
static int sqlite3Fts5TermsetNew(Fts5Termset**);
static int sqlite3Fts5TermsetAdd(Fts5Termset*, int, const char*, int, int *pbPresent);
static void sqlite3Fts5TermsetFree(Fts5Termset*);





typedef struct Fts5Index Fts5Index;
typedef struct Fts5IndexIter Fts5IndexIter;

struct Fts5IndexIter {
	i64 iRowid;
	const u8 *pData;
	int nData;
	u8 bEof;
};

#define sqlite3Fts5IterEof(x) ((x)->bEof)


#define FTS5INDEX_QUERY_PREFIX     0x0001   
#define FTS5INDEX_QUERY_DESC       0x0002   
#define FTS5INDEX_QUERY_TEST_NOIDX 0x0004   
#define FTS5INDEX_QUERY_SCAN       0x0008   


#define FTS5INDEX_QUERY_SKIPEMPTY  0x0010
#define FTS5INDEX_QUERY_NOOUTPUT   0x0020


static int sqlite3Fts5IndexOpen(Fts5Config *pConfig, int bCreate, Fts5Index**, char**);
static int sqlite3Fts5IndexClose(Fts5Index *p);


static u64 sqlite3Fts5IndexEntryCksum(
	i64 iRowid,
	int iCol,
	int iPos,
	int iIdx,
	const char *pTerm,
	int nTerm
);


static int sqlite3Fts5IndexCharlenToBytelen(
	const char *p,
	int nByte,
	int nChar
);


static int sqlite3Fts5IndexQuery(
	Fts5Index *p,                   
	const char *pToken, int nToken, 
	int flags,                      
	Fts5Colset *pColset,            
	Fts5IndexIter **ppIter          
);


static int sqlite3Fts5IterNext(Fts5IndexIter*);
static int sqlite3Fts5IterNextFrom(Fts5IndexIter*, i64 iMatch);


static void sqlite3Fts5IterClose(Fts5IndexIter*);


static const char *sqlite3Fts5IterTerm(Fts5IndexIter*, int*);
static int sqlite3Fts5IterNextScan(Fts5IndexIter*);



static int sqlite3Fts5IndexWrite(
	Fts5Index *p,                   
	int iCol,                       
	int iPos,                       
	const char *pToken, int nToken  
);


static int sqlite3Fts5IndexBeginWrite(
	Fts5Index *p,                   
	int bDelete,                    
	i64 iDocid                      
);


static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit);


static int sqlite3Fts5IndexRollback(Fts5Index *p);


static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize);
static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8*, int);


static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum);


static int sqlite3Fts5IndexInit(sqlite3*);

static int sqlite3Fts5IndexSetCookie(Fts5Index*, int);


static int sqlite3Fts5IndexReads(Fts5Index *p);

static int sqlite3Fts5IndexReinit(Fts5Index *p);
static int sqlite3Fts5IndexOptimize(Fts5Index *p);
static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge);
static int sqlite3Fts5IndexReset(Fts5Index *p);

static int sqlite3Fts5IndexLoadConfig(Fts5Index *p);




static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v);
static int sqlite3Fts5GetVarintLen(u32 iVal);
static u8 sqlite3Fts5GetVarint(const unsigned char*, u64*);
static int sqlite3Fts5PutVarint(unsigned char *p, u64 v);

#define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&b)
#define fts5GetVarint    sqlite3Fts5GetVarint

#define fts5FastGetVarint32(a, iOff, nVal) {      \
  nVal = (a)[iOff++];                             \
  if( nVal & 0x80 ){                              \
    iOff--;                                       \
    iOff += fts5GetVarint32(&(a)[iOff], nVal);    \
  }                                               \
}







static int sqlite3Fts5GetTokenizer(
	Fts5Global*,
	const char **azArg,
	int nArg,
	Fts5Tokenizer**,
	fts5_tokenizer**,
	char **pzErr
);

static Fts5Index *sqlite3Fts5IndexFromCsrid(Fts5Global*, i64, Fts5Config **);




typedef struct Fts5Hash Fts5Hash;


static int sqlite3Fts5HashNew(Fts5Config*, Fts5Hash**, int *pnSize);
static void sqlite3Fts5HashFree(Fts5Hash*);

static int sqlite3Fts5HashWrite(
	Fts5Hash*,
	i64 iRowid,                     
	int iCol,                       
	int iPos,                       
	char bByte,
	const char *pToken, int nToken  
);


static void sqlite3Fts5HashClear(Fts5Hash*);

static int sqlite3Fts5HashQuery(
	Fts5Hash*,                      
	const char *pTerm, int nTerm,   
	const u8 **ppDoclist,           
	int *pnDoclist                  
);

static int sqlite3Fts5HashScanInit(
	Fts5Hash*,                      
	const char *pTerm, int nTerm    
);
static void sqlite3Fts5HashScanNext(Fts5Hash*);
static int sqlite3Fts5HashScanEof(Fts5Hash*);
static void sqlite3Fts5HashScanEntry(Fts5Hash *,
	const char **pzTerm,            
	const u8 **ppDoclist,           
	int *pnDoclist                  
);






#define FTS5_STMT_SCAN_ASC  0     
#define FTS5_STMT_SCAN_DESC 1     
#define FTS5_STMT_LOOKUP    2     

typedef struct Fts5Storage Fts5Storage;

static int sqlite3Fts5StorageOpen(Fts5Config*, Fts5Index*, int, Fts5Storage**, char**);
static int sqlite3Fts5StorageClose(Fts5Storage *p);
static int sqlite3Fts5StorageRename(Fts5Storage*, const char *zName);

static int sqlite3Fts5DropAll(Fts5Config*);
static int sqlite3Fts5CreateTable(Fts5Config*, const char*, const char*, int, char **);

static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64, sqlite3_value**);
static int sqlite3Fts5StorageContentInsert(Fts5Storage *p, sqlite3_value**, i64*);
static int sqlite3Fts5StorageIndexInsert(Fts5Storage *p, sqlite3_value**, i64);

static int sqlite3Fts5StorageIntegrity(Fts5Storage *p);

static int sqlite3Fts5StorageStmt(Fts5Storage *p, int eStmt, sqlite3_stmt**, char**);
static void sqlite3Fts5StorageStmtRelease(Fts5Storage *p, int eStmt, sqlite3_stmt*);

static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol);
static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnAvg);
static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow);

static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit);
static int sqlite3Fts5StorageRollback(Fts5Storage *p);

static int sqlite3Fts5StorageConfigValue(
	Fts5Storage *p, const char*, sqlite3_value*, int
);

static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p);
static int sqlite3Fts5StorageRebuild(Fts5Storage *p);
static int sqlite3Fts5StorageOptimize(Fts5Storage *p);
static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge);
static int sqlite3Fts5StorageReset(Fts5Storage *p);





typedef struct Fts5Expr Fts5Expr;
typedef struct Fts5ExprNode Fts5ExprNode;
typedef struct Fts5Parse Fts5Parse;
typedef struct Fts5Token Fts5Token;
typedef struct Fts5ExprPhrase Fts5ExprPhrase;
typedef struct Fts5ExprNearset Fts5ExprNearset;

struct Fts5Token {
	const char *p;                  
	int n;                          
};


static int sqlite3Fts5ExprNew(
	Fts5Config *pConfig,
	const char *zExpr,
	Fts5Expr **ppNew,
	char **pzErr
);


static int sqlite3Fts5ExprFirst(Fts5Expr*, Fts5Index *pIdx, i64 iMin, int bDesc);
static int sqlite3Fts5ExprNext(Fts5Expr*, i64 iMax);
static int sqlite3Fts5ExprEof(Fts5Expr*);
static i64 sqlite3Fts5ExprRowid(Fts5Expr*);

static void sqlite3Fts5ExprFree(Fts5Expr*);


static int sqlite3Fts5ExprInit(Fts5Global*, sqlite3*);

static int sqlite3Fts5ExprPhraseCount(Fts5Expr*);
static int sqlite3Fts5ExprPhraseSize(Fts5Expr*, int iPhrase);
static int sqlite3Fts5ExprPoslist(Fts5Expr*, int, const u8 **);

typedef struct Fts5PoslistPopulator Fts5PoslistPopulator;
static Fts5PoslistPopulator *sqlite3Fts5ExprClearPoslists(Fts5Expr*, int);
static int sqlite3Fts5ExprPopulatePoslists(
	Fts5Config*, Fts5Expr*, Fts5PoslistPopulator*, int, const char*, int
);
static void sqlite3Fts5ExprCheckPoslists(Fts5Expr*, i64);

static int sqlite3Fts5ExprClonePhrase(Fts5Expr*, int, Fts5Expr**);

static int sqlite3Fts5ExprPhraseCollist(Fts5Expr *, int, const u8 **, int *);



static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...);

static Fts5ExprNode *sqlite3Fts5ParseNode(
	Fts5Parse *pParse,
	int eType,
	Fts5ExprNode *pLeft,
	Fts5ExprNode *pRight,
	Fts5ExprNearset *pNear
);

static Fts5ExprNode *sqlite3Fts5ParseImplicitAnd(
	Fts5Parse *pParse,
	Fts5ExprNode *pLeft,
	Fts5ExprNode *pRight
);

static Fts5ExprPhrase *sqlite3Fts5ParseTerm(
	Fts5Parse *pParse,
	Fts5ExprPhrase *pPhrase,
	Fts5Token *pToken,
	int bPrefix
);

static Fts5ExprNearset *sqlite3Fts5ParseNearset(
	Fts5Parse*,
	Fts5ExprNearset*,
	Fts5ExprPhrase*
);

static Fts5Colset *sqlite3Fts5ParseColset(
	Fts5Parse*,
	Fts5Colset*,
	Fts5Token *
);

static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase*);
static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset*);
static void sqlite3Fts5ParseNodeFree(Fts5ExprNode*);

static void sqlite3Fts5ParseSetDistance(Fts5Parse*, Fts5ExprNearset*, Fts5Token*);
static void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNearset*, Fts5Colset*);
static Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse*, Fts5Colset*);
static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p);
static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token*);







static int sqlite3Fts5AuxInit(fts5_api*);




static int sqlite3Fts5TokenizerInit(fts5_api*);




static int sqlite3Fts5VocabInit(Fts5Global*, sqlite3*);





static int sqlite3Fts5UnicodeIsalnum(int c);
static int sqlite3Fts5UnicodeIsdiacritic(int c);
static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic);


#endif

#define FTS5_OR                               1
#define FTS5_AND                              2
#define FTS5_NOT                              3
#define FTS5_TERM                             4
#define FTS5_COLON                            5
#define FTS5_LP                               6
#define FTS5_RP                               7
#define FTS5_MINUS                            8
#define FTS5_LCP                              9
#define FTS5_RCP                             10
#define FTS5_STRING                          11
#define FTS5_COMMA                           12
#define FTS5_PLUS                            13
#define FTS5_STAR                            14









#define fts5YYNOERRORRECOVERY 1


#define fts5yytestcase(X) testcase(X)


#define fts5YYPARSEFREENOTNULL 1


#define fts5YYMALLOCARGTYPE  u64






#ifndef INTERFACE
# define INTERFACE 1
#endif

#define fts5YYCODETYPE unsigned char
#define fts5YYNOCODE 28
#define fts5YYACTIONTYPE unsigned char
#define sqlite3Fts5ParserFTS5TOKENTYPE Fts5Token
typedef union {
	int fts5yyinit;
	sqlite3Fts5ParserFTS5TOKENTYPE fts5yy0;
	int fts5yy4;
	Fts5Colset* fts5yy11;
	Fts5ExprNode* fts5yy24;
	Fts5ExprNearset* fts5yy46;
	Fts5ExprPhrase* fts5yy53;
} fts5YYMINORTYPE;
#ifndef fts5YYSTACKDEPTH
#define fts5YYSTACKDEPTH 100
#endif
#define sqlite3Fts5ParserARG_SDECL Fts5Parse *pParse;
#define sqlite3Fts5ParserARG_PDECL ,Fts5Parse *pParse
#define sqlite3Fts5ParserARG_FETCH Fts5Parse *pParse = fts5yypParser->pParse
#define sqlite3Fts5ParserARG_STORE fts5yypParser->pParse = pParse
#define fts5YYNSTATE             29
#define fts5YYNRULE              26
#define fts5YY_MAX_SHIFT         28
#define fts5YY_MIN_SHIFTREDUCE   45
#define fts5YY_MAX_SHIFTREDUCE   70
#define fts5YY_MIN_REDUCE        71
#define fts5YY_MAX_REDUCE        96
#define fts5YY_ERROR_ACTION      97
#define fts5YY_ACCEPT_ACTION     98
#define fts5YY_NO_ACTION         99



#ifndef fts5yytestcase
# define fts5yytestcase(X)
#endif



#define fts5YY_ACTTAB_COUNT (85)
static const fts5YYACTIONTYPE fts5yy_action[] = {
	    98,   16,   51,    5,   53,   27,   83,    7,   26,   15,
	    51,    5,   53,   27,   13,   69,   26,   48,   51,    5,
	    53,   27,   19,   11,   26,    9,   20,   51,    5,   53,
	    27,   13,   22,   26,   28,   51,    5,   53,   27,   68,
	     1,   26,   19,   11,   17,    9,   52,   10,   53,   27,
	    23,   24,   26,   54,    3,    4,    2,   26,    6,   21,
	    49,   71,    3,    4,    2,    7,   56,   59,   55,   59,
	     4,    2,   12,   69,   58,   60,   18,   67,   62,   69,
	    25,   66,    8,   14,    2,
};
static const fts5YYCODETYPE fts5yy_lookahead[] = {
	    16,   17,   18,   19,   20,   21,    5,    6,   24,   17,
	    18,   19,   20,   21,   11,   14,   24,   17,   18,   19,
	    20,   21,    8,    9,   24,   11,   17,   18,   19,   20,
	    21,   11,   12,   24,   17,   18,   19,   20,   21,   26,
	     6,   24,    8,    9,   22,   11,   18,   11,   20,   21,
	    24,   25,   24,   20,    1,    2,    3,   24,   23,   24,
	     7,    0,    1,    2,    3,    6,   10,   11,   10,   11,
	     2,    3,    9,   14,   11,   11,   22,   26,    7,   14,
	    13,   11,    5,   11,    3,
};
#define fts5YY_SHIFT_USE_DFLT (85)
#define fts5YY_SHIFT_COUNT    (28)
#define fts5YY_SHIFT_MIN      (0)
#define fts5YY_SHIFT_MAX      (81)
static const unsigned char fts5yy_shift_ofst[] = {
	    34,   34,   34,   34,   34,   14,   20,    3,   36,    1,
	    59,   64,   64,   65,   65,   53,   61,   56,   58,   63,
	    68,   67,   70,   67,   71,   72,   67,   77,   81,
};
#define fts5YY_REDUCE_USE_DFLT (-17)
#define fts5YY_REDUCE_COUNT (14)
#define fts5YY_REDUCE_MIN   (-16)
#define fts5YY_REDUCE_MAX   (54)
static const signed char fts5yy_reduce_ofst[] = {
	   -16,   -8,    0,    9,   17,   28,   26,   35,   33,   13,
	    13,   22,   54,   13,   51,
};
static const fts5YYACTIONTYPE fts5yy_default[] = {
	    97,   97,   97,   97,   97,   76,   91,   97,   97,   96,
	    96,   97,   97,   96,   96,   97,   97,   97,   97,   97,
	    73,   89,   97,   90,   97,   97,   87,   97,   72,
};



#ifdef fts5YYFALLBACK
static const fts5YYCODETYPE fts5yyFallback[] = {
};
#endif 


struct fts5yyStackEntry {
	fts5YYACTIONTYPE stateno;  
	fts5YYCODETYPE major;      
	fts5YYMINORTYPE minor;     
};
typedef struct fts5yyStackEntry fts5yyStackEntry;


struct fts5yyParser {
	fts5yyStackEntry *fts5yytos;          
#ifdef fts5YYTRACKMAXSTACKDEPTH
	int fts5yyhwm;                    
#endif
#ifndef fts5YYNOERRORRECOVERY
	int fts5yyerrcnt;                 
#endif
	sqlite3Fts5ParserARG_SDECL                
#if fts5YYSTACKDEPTH<=0
		int fts5yystksz;                  
	fts5yyStackEntry *fts5yystack;        
	fts5yyStackEntry fts5yystk0;          
#else
		fts5yyStackEntry fts5yystack[fts5YYSTACKDEPTH];  
#endif
};
typedef struct fts5yyParser fts5yyParser;

#ifndef NDEBUG

static FILE *fts5yyTraceFILE = 0;
static char *fts5yyTracePrompt = 0;
#endif 

#ifndef NDEBUG

static void sqlite3Fts5ParserTrace(FILE *TraceFILE, char *zTracePrompt) {
	fts5yyTraceFILE = TraceFILE;
	fts5yyTracePrompt = zTracePrompt;
	if (fts5yyTraceFILE == 0) fts5yyTracePrompt = 0;
	else if (fts5yyTracePrompt == 0) fts5yyTraceFILE = 0;
}
#endif 

#ifndef NDEBUG

static const char *const fts5yyTokenName[] = {
	"$",             "OR",            "AND",           "NOT",
	"TERM",          "COLON",         "LP",            "RP",
	"MINUS",         "LCP",           "RCP",           "STRING",
	"COMMA",         "PLUS",          "STAR",          "error",
	"input",         "expr",          "cnearset",      "exprlist",
	"nearset",       "colset",        "colsetlist",    "nearphrases",
	"phrase",        "neardist_opt",  "star_opt",
};
#endif 

#ifndef NDEBUG

static const char *const fts5yyRuleName[] = {
	 "input ::= expr",
	 "expr ::= expr AND expr",
	 "expr ::= expr OR expr",
	 "expr ::= expr NOT expr",
	 "expr ::= LP expr RP",
	 "expr ::= exprlist",
	 "exprlist ::= cnearset",
	 "exprlist ::= exprlist cnearset",
	 "cnearset ::= nearset",
	 "cnearset ::= colset COLON nearset",
	 "colset ::= MINUS LCP colsetlist RCP",
	 "colset ::= LCP colsetlist RCP",
	 "colset ::= STRING",
	 "colset ::= MINUS STRING",
	 "colsetlist ::= colsetlist STRING",
	 "colsetlist ::= STRING",
	 "nearset ::= phrase",
	 "nearset ::= STRING LP nearphrases neardist_opt RP",
	 "nearphrases ::= phrase",
	 "nearphrases ::= nearphrases phrase",
	 "neardist_opt ::=",
	 "neardist_opt ::= COMMA STRING",
	 "phrase ::= phrase PLUS STRING star_opt",
	 "phrase ::= STRING star_opt",
	 "star_opt ::= STAR",
	 "star_opt ::=",
};
#endif 


#if fts5YYSTACKDEPTH<=0

static int fts5yyGrowStack(fts5yyParser *p) {
	int newSize;
	int idx;
	fts5yyStackEntry *pNew;

	newSize = p->fts5yystksz * 2 + 100;
	idx = p->fts5yytos ? (int)(p->fts5yytos - p->fts5yystack) : 0;
	if (p->fts5yystack == &p->fts5yystk0) {
		pNew = malloc(newSize * sizeof(pNew[0]));
		if (pNew) pNew[0] = p->fts5yystk0;
	}
	else {
		pNew = realloc(p->fts5yystack, newSize * sizeof(pNew[0]));
	}
	if (pNew) {
		p->fts5yystack = pNew;
		p->fts5yytos = &p->fts5yystack[idx];
#ifndef NDEBUG
		if (fts5yyTraceFILE) {
			fprintf(fts5yyTraceFILE, "%sStack grows from %d to %d entries.\n",
				fts5yyTracePrompt, p->fts5yystksz, newSize);
		}
#endif
		p->fts5yystksz = newSize;
	}
	return pNew == 0;
}
#endif


#ifndef fts5YYMALLOCARGTYPE
# define fts5YYMALLOCARGTYPE size_t
#endif


static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(fts5YYMALLOCARGTYPE)) {
	fts5yyParser *pParser;
	pParser = (fts5yyParser*)(*mallocProc)((fts5YYMALLOCARGTYPE)sizeof(fts5yyParser));
	if (pParser) {
#ifdef fts5YYTRACKMAXSTACKDEPTH
		pParser->fts5yyhwm = 0;
#endif
#if fts5YYSTACKDEPTH<=0
		pParser->fts5yytos = NULL;
		pParser->fts5yystack = NULL;
		pParser->fts5yystksz = 0;
		if (fts5yyGrowStack(pParser)) {
			pParser->fts5yystack = &pParser->fts5yystk0;
			pParser->fts5yystksz = 1;
		}
#endif
#ifndef fts5YYNOERRORRECOVERY
		pParser->fts5yyerrcnt = -1;
#endif
		pParser->fts5yytos = pParser->fts5yystack;
		pParser->fts5yystack[0].stateno = 0;
		pParser->fts5yystack[0].major = 0;
	}
	return pParser;
}


static void fts5yy_destructor(
	fts5yyParser *fts5yypParser,    
	fts5YYCODETYPE fts5yymajor,     
	fts5YYMINORTYPE *fts5yypminor   
) {
	sqlite3Fts5ParserARG_FETCH;
	switch (fts5yymajor) {
		
		
	case 16: 
	{
		(void)pParse;
	}
	break;
	case 17: 
	case 18: 
	case 19: 
	{
		sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24));
	}
	break;
	case 20: 
	case 23: 
	{
		sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46));
	}
	break;
	case 21: 
	case 22: 
	{
		sqlite3_free((fts5yypminor->fts5yy11));
	}
	break;
	case 24: 
	{
		sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy53));
	}
	break;
	
	default:  break;   
	}
}


static void fts5yy_pop_parser_stack(fts5yyParser *pParser) {
	fts5yyStackEntry *fts5yytos;
	assert(pParser->fts5yytos != 0);
	assert(pParser->fts5yytos > pParser->fts5yystack);
	fts5yytos = pParser->fts5yytos--;
#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fprintf(fts5yyTraceFILE, "%sPopping %s\n",
			fts5yyTracePrompt,
			fts5yyTokenName[fts5yytos->major]);
	}
#endif
	fts5yy_destructor(pParser, fts5yytos->major, &fts5yytos->minor);
}


static void sqlite3Fts5ParserFree(
	void *p,                    
	void(*freeProc)(void*)     
) {
	fts5yyParser *pParser = (fts5yyParser*)p;
#ifndef fts5YYPARSEFREENEVERNULL
	if (pParser == 0) return;
#endif
	while (pParser->fts5yytos>pParser->fts5yystack) fts5yy_pop_parser_stack(pParser);
#if fts5YYSTACKDEPTH<=0
	if (pParser->fts5yystack != &pParser->fts5yystk0) free(pParser->fts5yystack);
#endif
	(*freeProc)((void*)pParser);
}


#ifdef fts5YYTRACKMAXSTACKDEPTH
static int sqlite3Fts5ParserStackPeak(void *p) {
	fts5yyParser *pParser = (fts5yyParser*)p;
	return pParser->fts5yyhwm;
}
#endif


static unsigned int fts5yy_find_shift_action(
	fts5yyParser *pParser,        
	fts5YYCODETYPE iLookAhead     
) {
	int i;
	int stateno = pParser->fts5yytos->stateno;

	if (stateno >= fts5YY_MIN_REDUCE) return stateno;
	assert(stateno <= fts5YY_SHIFT_COUNT);
	do {
		i = fts5yy_shift_ofst[stateno];
		assert(iLookAhead != fts5YYNOCODE);
		i += iLookAhead;
		if (i<0 || i >= fts5YY_ACTTAB_COUNT || fts5yy_lookahead[i] != iLookAhead) {
#ifdef fts5YYFALLBACK
			fts5YYCODETYPE iFallback;            
			if (iLookAhead<sizeof(fts5yyFallback) / sizeof(fts5yyFallback[0])
				&& (iFallback = fts5yyFallback[iLookAhead]) != 0) {
#ifndef NDEBUG
				if (fts5yyTraceFILE) {
					fprintf(fts5yyTraceFILE, "%sFALLBACK %s => %s\n",
						fts5yyTracePrompt, fts5yyTokenName[iLookAhead], fts5yyTokenName[iFallback]);
				}
#endif
				assert(fts5yyFallback[iFallback] == 0); 
				iLookAhead = iFallback;
				continue;
			}
#endif
#ifdef fts5YYWILDCARD
			{
				int j = i - iLookAhead + fts5YYWILDCARD;
				if (
#if fts5YY_SHIFT_MIN+fts5YYWILDCARD<0
					j >= 0 &&
#endif
#if fts5YY_SHIFT_MAX+fts5YYWILDCARD>=fts5YY_ACTTAB_COUNT
					j<fts5YY_ACTTAB_COUNT &&
#endif
					fts5yy_lookahead[j] == fts5YYWILDCARD && iLookAhead>0
					) {
#ifndef NDEBUG
					if (fts5yyTraceFILE) {
						fprintf(fts5yyTraceFILE, "%sWILDCARD %s => %s\n",
							fts5yyTracePrompt, fts5yyTokenName[iLookAhead],
							fts5yyTokenName[fts5YYWILDCARD]);
					}
#endif 
					return fts5yy_action[j];
				}
			}
#endif 
			return fts5yy_default[stateno];
		}
		else {
			return fts5yy_action[i];
		}
	} while (1);
}


static int fts5yy_find_reduce_action(
	int stateno,              
	fts5YYCODETYPE iLookAhead     
) {
	int i;
#ifdef fts5YYERRORSYMBOL
	if (stateno>fts5YY_REDUCE_COUNT) {
		return fts5yy_default[stateno];
	}
#else
	assert(stateno <= fts5YY_REDUCE_COUNT);
#endif
	i = fts5yy_reduce_ofst[stateno];
	assert(i != fts5YY_REDUCE_USE_DFLT);
	assert(iLookAhead != fts5YYNOCODE);
	i += iLookAhead;
#ifdef fts5YYERRORSYMBOL
	if (i<0 || i >= fts5YY_ACTTAB_COUNT || fts5yy_lookahead[i] != iLookAhead) {
		return fts5yy_default[stateno];
	}
#else
	assert(i >= 0 && i<fts5YY_ACTTAB_COUNT);
	assert(fts5yy_lookahead[i] == iLookAhead);
#endif
	return fts5yy_action[i];
}


static void fts5yyStackOverflow(fts5yyParser *fts5yypParser) {
	sqlite3Fts5ParserARG_FETCH;
	fts5yypParser->fts5yytos--;
#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fprintf(fts5yyTraceFILE, "%sStack Overflow!\n", fts5yyTracePrompt);
	}
#endif
	while (fts5yypParser->fts5yytos>fts5yypParser->fts5yystack) fts5yy_pop_parser_stack(fts5yypParser);
	
	

	sqlite3Fts5ParseError(pParse, "fts5: parser stack overflow");
	
	sqlite3Fts5ParserARG_STORE; 
}


#ifndef NDEBUG
static void fts5yyTraceShift(fts5yyParser *fts5yypParser, int fts5yyNewState) {
	if (fts5yyTraceFILE) {
		if (fts5yyNewState<fts5YYNSTATE) {
			fprintf(fts5yyTraceFILE, "%sShift '%s', go to state %d\n",
				fts5yyTracePrompt, fts5yyTokenName[fts5yypParser->fts5yytos->major],
				fts5yyNewState);
		}
		else {
			fprintf(fts5yyTraceFILE, "%sShift '%s'\n",
				fts5yyTracePrompt, fts5yyTokenName[fts5yypParser->fts5yytos->major]);
		}
	}
}
#else
# define fts5yyTraceShift(X,Y)
#endif


static void fts5yy_shift(
	fts5yyParser *fts5yypParser,          
	int fts5yyNewState,               
	int fts5yyMajor,                  
	sqlite3Fts5ParserFTS5TOKENTYPE fts5yyMinor        
) {
	fts5yyStackEntry *fts5yytos;
	fts5yypParser->fts5yytos++;
#ifdef fts5YYTRACKMAXSTACKDEPTH
	if ((int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm) {
		fts5yypParser->fts5yyhwm++;
		assert(fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));
	}
#endif
#if fts5YYSTACKDEPTH>0 
	if (fts5yypParser->fts5yytos >= &fts5yypParser->fts5yystack[fts5YYSTACKDEPTH]) {
		fts5yyStackOverflow(fts5yypParser);
		return;
	}
#else
	if (fts5yypParser->fts5yytos >= &fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz]) {
		if (fts5yyGrowStack(fts5yypParser)) {
			fts5yyStackOverflow(fts5yypParser);
			return;
		}
	}
#endif
	if (fts5yyNewState > fts5YY_MAX_SHIFT) {
		fts5yyNewState += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;
	}
	fts5yytos = fts5yypParser->fts5yytos;
	fts5yytos->stateno = (fts5YYACTIONTYPE)fts5yyNewState;
	fts5yytos->major = (fts5YYCODETYPE)fts5yyMajor;
	fts5yytos->minor.fts5yy0 = fts5yyMinor;
	fts5yyTraceShift(fts5yypParser, fts5yyNewState);
}


static const struct {
	fts5YYCODETYPE lhs;         
	unsigned char nrhs;     
} fts5yyRuleInfo[] = {
	{ 16, 1 },
	{ 17, 3 },
	{ 17, 3 },
	{ 17, 3 },
	{ 17, 3 },
	{ 17, 1 },
	{ 19, 1 },
	{ 19, 2 },
	{ 18, 1 },
	{ 18, 3 },
	{ 21, 4 },
	{ 21, 3 },
	{ 21, 1 },
	{ 21, 2 },
	{ 22, 2 },
	{ 22, 1 },
	{ 20, 1 },
	{ 20, 5 },
	{ 23, 1 },
	{ 23, 2 },
	{ 25, 0 },
	{ 25, 2 },
	{ 24, 4 },
	{ 24, 2 },
	{ 26, 1 },
	{ 26, 0 },
};

static void fts5yy_accept(fts5yyParser*);  

										   
static void fts5yy_reduce(
	fts5yyParser *fts5yypParser,         
	unsigned int fts5yyruleno        
) {
	int fts5yygoto;                     
	int fts5yyact;                      
	fts5yyStackEntry *fts5yymsp;            
	int fts5yysize;                     
	sqlite3Fts5ParserARG_FETCH;
	fts5yymsp = fts5yypParser->fts5yytos;
#ifndef NDEBUG
	if (fts5yyTraceFILE && fts5yyruleno<(int)(sizeof(fts5yyRuleName) / sizeof(fts5yyRuleName[0]))) {
		fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
		fprintf(fts5yyTraceFILE, "%sReduce [%s], go to state %d.\n", fts5yyTracePrompt,
			fts5yyRuleName[fts5yyruleno], fts5yymsp[-fts5yysize].stateno);
	}
#endif 

	
	if (fts5yyRuleInfo[fts5yyruleno].nrhs == 0) {
#ifdef fts5YYTRACKMAXSTACKDEPTH
		if ((int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm) {
			fts5yypParser->fts5yyhwm++;
			assert(fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));
		}
#endif
#if fts5YYSTACKDEPTH>0 
		if (fts5yypParser->fts5yytos >= &fts5yypParser->fts5yystack[fts5YYSTACKDEPTH - 1]) {
			fts5yyStackOverflow(fts5yypParser);
			return;
		}
#else
		if (fts5yypParser->fts5yytos >= &fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz - 1]) {
			if (fts5yyGrowStack(fts5yypParser)) {
				fts5yyStackOverflow(fts5yypParser);
				return;
			}
			fts5yymsp = fts5yypParser->fts5yytos;
		}
#endif
	}

	switch (fts5yyruleno) {
		
		
		fts5YYMINORTYPE fts5yylhsminor;
	case 0: 
	{ sqlite3Fts5ParseFinished(pParse, fts5yymsp[0].minor.fts5yy24); }
	break;
	case 1: 
	{
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_AND, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
	}
	fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 2: 
	{
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_OR, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
	}
	fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 3: 
	{
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_NOT, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0);
	}
	fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 4: 
	{fts5yymsp[-2].minor.fts5yy24 = fts5yymsp[-1].minor.fts5yy24; }
	break;
	case 5: 
	case 6:  fts5yytestcase(fts5yyruleno == 6);
	{fts5yylhsminor.fts5yy24 = fts5yymsp[0].minor.fts5yy24; }
	fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 7: 
	{
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseImplicitAnd(pParse, fts5yymsp[-1].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24);
	}
	fts5yymsp[-1].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 8: 
	{
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46);
	}
	fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 9: 
	{
		sqlite3Fts5ParseSetColset(pParse, fts5yymsp[0].minor.fts5yy46, fts5yymsp[-2].minor.fts5yy11);
		fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46);
	}
	fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;
	break;
	case 10: 
	{
		fts5yymsp[-3].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
	}
	break;
	case 11: 
	{ fts5yymsp[-2].minor.fts5yy11 = fts5yymsp[-1].minor.fts5yy11; }
	break;
	case 12: 
	{
		fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
	}
	fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
	break;
	case 13: 
	{
		fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
		fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11);
	}
	break;
	case 14: 
	{
		fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, fts5yymsp[-1].minor.fts5yy11, &fts5yymsp[0].minor.fts5yy0); }
	fts5yymsp[-1].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
	break;
	case 15: 
	{
		fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
	}
	fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;
	break;
	case 16: 
	{ fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); }
	fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
	break;
	case 17: 
	{
		sqlite3Fts5ParseNear(pParse, &fts5yymsp[-4].minor.fts5yy0);
		sqlite3Fts5ParseSetDistance(pParse, fts5yymsp[-2].minor.fts5yy46, &fts5yymsp[-1].minor.fts5yy0);
		fts5yylhsminor.fts5yy46 = fts5yymsp[-2].minor.fts5yy46;
	}
	fts5yymsp[-4].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
	break;
	case 18: 
	{
		fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53);
	}
	fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
	break;
	case 19: 
	{
		fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, fts5yymsp[-1].minor.fts5yy46, fts5yymsp[0].minor.fts5yy53);
	}
	fts5yymsp[-1].minor.fts5yy46 = fts5yylhsminor.fts5yy46;
	break;
	case 20: 
	{ fts5yymsp[1].minor.fts5yy0.p = 0; fts5yymsp[1].minor.fts5yy0.n = 0; }
	break;
	case 21: 
	{ fts5yymsp[-1].minor.fts5yy0 = fts5yymsp[0].minor.fts5yy0; }
	break;
	case 22: 
	{
		fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, fts5yymsp[-3].minor.fts5yy53, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4);
	}
	fts5yymsp[-3].minor.fts5yy53 = fts5yylhsminor.fts5yy53;
	break;
	case 23: 
	{
		fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, 0, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4);
	}
	fts5yymsp[-1].minor.fts5yy53 = fts5yylhsminor.fts5yy53;
	break;
	case 24: 
	{ fts5yymsp[0].minor.fts5yy4 = 1; }
	break;
	case 25: 
	{ fts5yymsp[1].minor.fts5yy4 = 0; }
	break;
	default:
		break;
		
	};
	assert(fts5yyruleno<sizeof(fts5yyRuleInfo) / sizeof(fts5yyRuleInfo[0]));
	fts5yygoto = fts5yyRuleInfo[fts5yyruleno].lhs;
	fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
	fts5yyact = fts5yy_find_reduce_action(fts5yymsp[-fts5yysize].stateno, (fts5YYCODETYPE)fts5yygoto);
	if (fts5yyact <= fts5YY_MAX_SHIFTREDUCE) {
		if (fts5yyact>fts5YY_MAX_SHIFT) {
			fts5yyact += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;
		}
		fts5yymsp -= fts5yysize - 1;
		fts5yypParser->fts5yytos = fts5yymsp;
		fts5yymsp->stateno = (fts5YYACTIONTYPE)fts5yyact;
		fts5yymsp->major = (fts5YYCODETYPE)fts5yygoto;
		fts5yyTraceShift(fts5yypParser, fts5yyact);
	}
	else {
		assert(fts5yyact == fts5YY_ACCEPT_ACTION);
		fts5yypParser->fts5yytos -= fts5yysize;
		fts5yy_accept(fts5yypParser);
	}
}


#ifndef fts5YYNOERRORRECOVERY
static void fts5yy_parse_failed(
	fts5yyParser *fts5yypParser           
) {
	sqlite3Fts5ParserARG_FETCH;
#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fprintf(fts5yyTraceFILE, "%sFail!\n", fts5yyTracePrompt);
	}
#endif
	while (fts5yypParser->fts5yytos>fts5yypParser->fts5yystack) fts5yy_pop_parser_stack(fts5yypParser);
	
	
	
	sqlite3Fts5ParserARG_STORE; 
}
#endif 


static void fts5yy_syntax_error(
	fts5yyParser *fts5yypParser,           
	int fts5yymajor,                   
	sqlite3Fts5ParserFTS5TOKENTYPE fts5yyminor         
) {
	sqlite3Fts5ParserARG_FETCH;
#define FTS5TOKEN fts5yyminor
	

	UNUSED_PARAM(fts5yymajor); 
	sqlite3Fts5ParseError(
		pParse, "fts5: syntax error near \"%.*s\"", FTS5TOKEN.n, FTS5TOKEN.p
	);
	
	sqlite3Fts5ParserARG_STORE; 
}


static void fts5yy_accept(
	fts5yyParser *fts5yypParser           
) {
	sqlite3Fts5ParserARG_FETCH;
#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fprintf(fts5yyTraceFILE, "%sAccept!\n", fts5yyTracePrompt);
	}
#endif
#ifndef fts5YYNOERRORRECOVERY
	fts5yypParser->fts5yyerrcnt = -1;
#endif
	assert(fts5yypParser->fts5yytos == fts5yypParser->fts5yystack);
	
	
	
	sqlite3Fts5ParserARG_STORE; 
}


static void sqlite3Fts5Parser(
	void *fts5yyp,                   
	int fts5yymajor,                 
	sqlite3Fts5ParserFTS5TOKENTYPE fts5yyminor       
	sqlite3Fts5ParserARG_PDECL               
) {
	fts5YYMINORTYPE fts5yyminorunion;
	unsigned int fts5yyact;   
#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
	int fts5yyendofinput;     
#endif
#ifdef fts5YYERRORSYMBOL
	int fts5yyerrorhit = 0;   
#endif
	fts5yyParser *fts5yypParser;  

	fts5yypParser = (fts5yyParser*)fts5yyp;
	assert(fts5yypParser->fts5yytos != 0);
#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
	fts5yyendofinput = (fts5yymajor == 0);
#endif
	sqlite3Fts5ParserARG_STORE;

#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fprintf(fts5yyTraceFILE, "%sInput '%s'\n", fts5yyTracePrompt, fts5yyTokenName[fts5yymajor]);
	}
#endif

	do {
		fts5yyact = fts5yy_find_shift_action(fts5yypParser, (fts5YYCODETYPE)fts5yymajor);
		if (fts5yyact <= fts5YY_MAX_SHIFTREDUCE) {
			fts5yy_shift(fts5yypParser, fts5yyact, fts5yymajor, fts5yyminor);
#ifndef fts5YYNOERRORRECOVERY
			fts5yypParser->fts5yyerrcnt--;
#endif
			fts5yymajor = fts5YYNOCODE;
		}
		else if (fts5yyact <= fts5YY_MAX_REDUCE) {
			fts5yy_reduce(fts5yypParser, fts5yyact - fts5YY_MIN_REDUCE);
		}
		else {
			assert(fts5yyact == fts5YY_ERROR_ACTION);
			fts5yyminorunion.fts5yy0 = fts5yyminor;
#ifdef fts5YYERRORSYMBOL
			int fts5yymx;
#endif
#ifndef NDEBUG
			if (fts5yyTraceFILE) {
				fprintf(fts5yyTraceFILE, "%sSyntax Error!\n", fts5yyTracePrompt);
			}
#endif
#ifdef fts5YYERRORSYMBOL
			
			if (fts5yypParser->fts5yyerrcnt<0) {
				fts5yy_syntax_error(fts5yypParser, fts5yymajor, fts5yyminor);
			}
			fts5yymx = fts5yypParser->fts5yytos->major;
			if (fts5yymx == fts5YYERRORSYMBOL || fts5yyerrorhit) {
#ifndef NDEBUG
				if (fts5yyTraceFILE) {
					fprintf(fts5yyTraceFILE, "%sDiscard input token %s\n",
						fts5yyTracePrompt, fts5yyTokenName[fts5yymajor]);
				}
#endif
				fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor, &fts5yyminorunion);
				fts5yymajor = fts5YYNOCODE;
			}
			else {
				while (fts5yypParser->fts5yytos >= fts5yypParser->fts5yystack
					&& fts5yymx != fts5YYERRORSYMBOL
					&& (fts5yyact = fts5yy_find_reduce_action(
						fts5yypParser->fts5yytos->stateno,
						fts5YYERRORSYMBOL)) >= fts5YY_MIN_REDUCE
					) {
					fts5yy_pop_parser_stack(fts5yypParser);
				}
				if (fts5yypParser->fts5yytos < fts5yypParser->fts5yystack || fts5yymajor == 0) {
					fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor, &fts5yyminorunion);
					fts5yy_parse_failed(fts5yypParser);
#ifndef fts5YYNOERRORRECOVERY
					fts5yypParser->fts5yyerrcnt = -1;
#endif
					fts5yymajor = fts5YYNOCODE;
				}
				else if (fts5yymx != fts5YYERRORSYMBOL) {
					fts5yy_shift(fts5yypParser, fts5yyact, fts5YYERRORSYMBOL, fts5yyminor);
				}
			}
			fts5yypParser->fts5yyerrcnt = 3;
			fts5yyerrorhit = 1;
#elif defined(fts5YYNOERRORRECOVERY)
			
			fts5yy_syntax_error(fts5yypParser, fts5yymajor, fts5yyminor);
			fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor, &fts5yyminorunion);
			fts5yymajor = fts5YYNOCODE;

#else  
			
			if (fts5yypParser->fts5yyerrcnt <= 0) {
				fts5yy_syntax_error(fts5yypParser, fts5yymajor, fts5yyminor);
			}
			fts5yypParser->fts5yyerrcnt = 3;
			fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor, &fts5yyminorunion);
			if (fts5yyendofinput) {
				fts5yy_parse_failed(fts5yypParser);
#ifndef fts5YYNOERRORRECOVERY
				fts5yypParser->fts5yyerrcnt = -1;
#endif
			}
			fts5yymajor = fts5YYNOCODE;
#endif
		}
	} while (fts5yymajor != fts5YYNOCODE && fts5yypParser->fts5yytos>fts5yypParser->fts5yystack);
#ifndef NDEBUG
	if (fts5yyTraceFILE) {
		fts5yyStackEntry *i;
		char cDiv = '[';
		fprintf(fts5yyTraceFILE, "%sReturn. Stack=", fts5yyTracePrompt);
		for (i = &fts5yypParser->fts5yystack[1]; i <= fts5yypParser->fts5yytos; i++) {
			fprintf(fts5yyTraceFILE, "%c%s", cDiv, fts5yyTokenName[i->major]);
			cDiv = ' ';
		}
		fprintf(fts5yyTraceFILE, "]\n");
	}
#endif
	return;
}





#include <math.h>                 


typedef struct CInstIter CInstIter;
struct CInstIter {
	const Fts5ExtensionApi *pApi;   
	Fts5Context *pFts;              
	int iCol;                       
	int iInst;                      
	int nInst;                      

									
	int iStart;                     
	int iEnd;                       
};


static int fts5CInstIterNext(CInstIter *pIter) {
	int rc = SQLITE_OK;
	pIter->iStart = -1;
	pIter->iEnd = -1;

	while (rc == SQLITE_OK && pIter->iInst<pIter->nInst) {
		int ip; int ic; int io;
		rc = pIter->pApi->xInst(pIter->pFts, pIter->iInst, &ip, &ic, &io);
		if (rc == SQLITE_OK) {
			if (ic == pIter->iCol) {
				int iEnd = io - 1 + pIter->pApi->xPhraseSize(pIter->pFts, ip);
				if (pIter->iStart<0) {
					pIter->iStart = io;
					pIter->iEnd = iEnd;
				}
				else if (io <= pIter->iEnd) {
					if (iEnd>pIter->iEnd) pIter->iEnd = iEnd;
				}
				else {
					break;
				}
			}
			pIter->iInst++;
		}
	}

	return rc;
}


static int fts5CInstIterInit(
	const Fts5ExtensionApi *pApi,
	Fts5Context *pFts,
	int iCol,
	CInstIter *pIter
) {
	int rc;

	memset(pIter, 0, sizeof(CInstIter));
	pIter->pApi = pApi;
	pIter->pFts = pFts;
	pIter->iCol = iCol;
	rc = pApi->xInstCount(pFts, &pIter->nInst);

	if (rc == SQLITE_OK) {
		rc = fts5CInstIterNext(pIter);
	}

	return rc;
}




typedef struct HighlightContext HighlightContext;
struct HighlightContext {
	CInstIter iter;                 
	int iPos;                       
	int iRangeStart;                
	int iRangeEnd;                  
	const char *zOpen;              
	const char *zClose;             
	const char *zIn;                
	int nIn;                        
	int iOff;                       
	char *zOut;                     
};


static void fts5HighlightAppend(
	int *pRc,
	HighlightContext *p,
	const char *z, int n
) {
	if (*pRc == SQLITE_OK) {
		if (n<0) n = (int)strlen(z);
		p->zOut = sqlite3_mprintf("%z%.*s", p->zOut, n, z);
		if (p->zOut == 0) *pRc = SQLITE_NOMEM;
	}
}


static int fts5HighlightCb(
	void *pContext,                 
	int tflags,                     
	const char *pToken,             
	int nToken,                     
	int iStartOff,                  
	int iEndOff                     
) {
	HighlightContext *p = (HighlightContext*)pContext;
	int rc = SQLITE_OK;
	int iPos;

	UNUSED_PARAM2(pToken, nToken);

	if (tflags & FTS5_TOKEN_COLOCATED) return SQLITE_OK;
	iPos = p->iPos++;

	if (p->iRangeEnd>0) {
		if (iPos<p->iRangeStart || iPos>p->iRangeEnd) return SQLITE_OK;
		if (p->iRangeStart && iPos == p->iRangeStart) p->iOff = iStartOff;
	}

	if (iPos == p->iter.iStart) {
		fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iStartOff - p->iOff);
		fts5HighlightAppend(&rc, p, p->zOpen, -1);
		p->iOff = iStartOff;
	}

	if (iPos == p->iter.iEnd) {
		if (p->iRangeEnd && p->iter.iStart<p->iRangeStart) {
			fts5HighlightAppend(&rc, p, p->zOpen, -1);
		}
		fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);
		fts5HighlightAppend(&rc, p, p->zClose, -1);
		p->iOff = iEndOff;
		if (rc == SQLITE_OK) {
			rc = fts5CInstIterNext(&p->iter);
		}
	}

	if (p->iRangeEnd>0 && iPos == p->iRangeEnd) {
		fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);
		p->iOff = iEndOff;
		if (iPos >= p->iter.iStart && iPos<p->iter.iEnd) {
			fts5HighlightAppend(&rc, p, p->zClose, -1);
		}
	}

	return rc;
}


static void fts5HighlightFunction(
	const Fts5ExtensionApi *pApi,   
	Fts5Context *pFts,              
	sqlite3_context *pCtx,          
	int nVal,                       
	sqlite3_value **apVal           
) {
	HighlightContext ctx;
	int rc;
	int iCol;

	if (nVal != 3) {
		const char *zErr = "wrong number of arguments to function highlight()";
		sqlite3_result_error(pCtx, zErr, -1);
		return;
	}

	iCol = sqlite3_value_int(apVal[0]);
	memset(&ctx, 0, sizeof(HighlightContext));
	ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);
	ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);
	rc = pApi->xColumnText(pFts, iCol, &ctx.zIn, &ctx.nIn);

	if (ctx.zIn) {
		if (rc == SQLITE_OK) {
			rc = fts5CInstIterInit(pApi, pFts, iCol, &ctx.iter);
		}

		if (rc == SQLITE_OK) {
			rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx, fts5HighlightCb);
		}
		fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);

		if (rc == SQLITE_OK) {
			sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
		}
		sqlite3_free(ctx.zOut);
	}
	if (rc != SQLITE_OK) {
		sqlite3_result_error_code(pCtx, rc);
	}
}



typedef struct Fts5SFinder Fts5SFinder;
struct Fts5SFinder {
	int iPos;                       
	int nFirstAlloc;                
	int nFirst;                     
	int *aFirst;                    
	const char *zDoc;               
};


static int fts5SentenceFinderAdd(Fts5SFinder *p, int iAdd) {
	if (p->nFirstAlloc == p->nFirst) {
		int nNew = p->nFirstAlloc ? p->nFirstAlloc * 2 : 64;
		int *aNew;

		aNew = (int*)sqlite3_realloc(p->aFirst, nNew * sizeof(int));
		if (aNew == 0) return SQLITE_NOMEM;
		p->aFirst = aNew;
		p->nFirstAlloc = nNew;
	}
	p->aFirst[p->nFirst++] = iAdd;
	return SQLITE_OK;
}


static int fts5SentenceFinderCb(
	void *pContext,                 
	int tflags,                     
	const char *pToken,             
	int nToken,                     
	int iStartOff,                  
	int iEndOff                     
) {
	int rc = SQLITE_OK;

	UNUSED_PARAM2(pToken, nToken);
	UNUSED_PARAM(iEndOff);

	if ((tflags & FTS5_TOKEN_COLOCATED) == 0) {
		Fts5SFinder *p = (Fts5SFinder*)pContext;
		if (p->iPos>0) {
			int i;
			char c = 0;
			for (i = iStartOff - 1; i >= 0; i--) {
				c = p->zDoc[i];
				if (c != ' ' && c != '\t' && c != '\n' && c != '\r') break;
			}
			if (i != iStartOff - 1 && (c == '.' || c == ':')) {
				rc = fts5SentenceFinderAdd(p, p->iPos);
			}
		}
		else {
			rc = fts5SentenceFinderAdd(p, 0);
		}
		p->iPos++;
	}
	return rc;
}

static int fts5SnippetScore(
	const Fts5ExtensionApi *pApi,   
	Fts5Context *pFts,              
	int nDocsize,                   
	unsigned char *aSeen,           
	int iCol,                       
	int iPos,                       
	int nToken,                     
	int *pnScore,                   
	int *piPos                      
) {
	int rc;
	int i;
	int ip = 0;
	int ic = 0;
	int iOff = 0;
	int iFirst = -1;
	int nInst;
	int nScore = 0;
	int iLast = 0;

	rc = pApi->xInstCount(pFts, &nInst);
	for (i = 0; i<nInst && rc == SQLITE_OK; i++) {
		rc = pApi->xInst(pFts, i, &ip, &ic, &iOff);
		if (rc == SQLITE_OK && ic == iCol && iOff >= iPos && iOff<(iPos + nToken)) {
			nScore += (aSeen[ip] ? 1 : 1000);
			aSeen[ip] = 1;
			if (iFirst<0) iFirst = iOff;
			iLast = iOff + pApi->xPhraseSize(pFts, ip);
		}
	}

	*pnScore = nScore;
	if (piPos) {
		int iAdj = iFirst - (nToken - (iLast - iFirst)) / 2;
		if ((iAdj + nToken)>nDocsize) iAdj = nDocsize - nToken;
		if (iAdj<0) iAdj = 0;
		*piPos = iAdj;
	}

	return rc;
}


static void fts5SnippetFunction(
	const Fts5ExtensionApi *pApi,   
	Fts5Context *pFts,              
	sqlite3_context *pCtx,          
	int nVal,                       
	sqlite3_value **apVal           
) {
	HighlightContext ctx;
	int rc = SQLITE_OK;             
	int iCol;                       
	const char *zEllips;            
	int nToken;                     
	int nInst = 0;                  
	int i;                          
	int nPhrase;                    
	unsigned char *aSeen;           
	int iBestCol;                   
	int iBestStart = 0;             
	int nBestScore = 0;             
	int nColSize = 0;               
	Fts5SFinder sFinder;            
	int nCol;

	if (nVal != 5) {
		const char *zErr = "wrong number of arguments to function snippet()";
		sqlite3_result_error(pCtx, zErr, -1);
		return;
	}

	nCol = pApi->xColumnCount(pFts);
	memset(&ctx, 0, sizeof(HighlightContext));
	iCol = sqlite3_value_int(apVal[0]);
	ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);
	ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);
	zEllips = (const char*)sqlite3_value_text(apVal[3]);
	nToken = sqlite3_value_int(apVal[4]);

	iBestCol = (iCol >= 0 ? iCol : 0);
	nPhrase = pApi->xPhraseCount(pFts);
	aSeen = sqlite3_malloc(nPhrase);
	if (aSeen == 0) {
		rc = SQLITE_NOMEM;
	}
	if (rc == SQLITE_OK) {
		rc = pApi->xInstCount(pFts, &nInst);
	}

	memset(&sFinder, 0, sizeof(Fts5SFinder));
	for (i = 0; i<nCol; i++) {
		if (iCol<0 || iCol == i) {
			int nDoc;
			int nDocsize;
			int ii;
			sFinder.iPos = 0;
			sFinder.nFirst = 0;
			rc = pApi->xColumnText(pFts, i, &sFinder.zDoc, &nDoc);
			if (rc != SQLITE_OK) break;
			rc = pApi->xTokenize(pFts,
				sFinder.zDoc, nDoc, (void*)&sFinder, fts5SentenceFinderCb
			);
			if (rc != SQLITE_OK) break;
			rc = pApi->xColumnSize(pFts, i, &nDocsize);
			if (rc != SQLITE_OK) break;

			for (ii = 0; rc == SQLITE_OK && ii<nInst; ii++) {
				int ip, ic, io;
				int iAdj;
				int nScore;
				int jj;

				rc = pApi->xInst(pFts, ii, &ip, &ic, &io);
				if (ic != i || rc != SQLITE_OK) continue;
				memset(aSeen, 0, nPhrase);
				rc = fts5SnippetScore(pApi, pFts, nDocsize, aSeen, i,
					io, nToken, &nScore, &iAdj
				);
				if (rc == SQLITE_OK && nScore>nBestScore) {
					nBestScore = nScore;
					iBestCol = i;
					iBestStart = iAdj;
					nColSize = nDocsize;
				}

				if (rc == SQLITE_OK && sFinder.nFirst && nDocsize>nToken) {
					for (jj = 0; jj<(sFinder.nFirst - 1); jj++) {
						if (sFinder.aFirst[jj + 1]>io) break;
					}

					if (sFinder.aFirst[jj]<io) {
						memset(aSeen, 0, nPhrase);
						rc = fts5SnippetScore(pApi, pFts, nDocsize, aSeen, i,
							sFinder.aFirst[jj], nToken, &nScore, 0
						);

						nScore += (sFinder.aFirst[jj] == 0 ? 120 : 100);
						if (rc == SQLITE_OK && nScore>nBestScore) {
							nBestScore = nScore;
							iBestCol = i;
							iBestStart = sFinder.aFirst[jj];
							nColSize = nDocsize;
						}
					}
				}
			}
		}
	}

	if (rc == SQLITE_OK) {
		rc = pApi->xColumnText(pFts, iBestCol, &ctx.zIn, &ctx.nIn);
	}
	if (rc == SQLITE_OK && nColSize == 0) {
		rc = pApi->xColumnSize(pFts, iBestCol, &nColSize);
	}
	if (ctx.zIn) {
		if (rc == SQLITE_OK) {
			rc = fts5CInstIterInit(pApi, pFts, iBestCol, &ctx.iter);
		}

		ctx.iRangeStart = iBestStart;
		ctx.iRangeEnd = iBestStart + nToken - 1;

		if (iBestStart>0) {
			fts5HighlightAppend(&rc, &ctx, zEllips, -1);
		}

		
		while (ctx.iter.iStart >= 0 && ctx.iter.iStart<iBestStart && rc == SQLITE_OK) {
			rc = fts5CInstIterNext(&ctx.iter);
		}

		if (rc == SQLITE_OK) {
			rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx, fts5HighlightCb);
		}
		if (ctx.iRangeEnd >= (nColSize - 1)) {
			fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);
		}
		else {
			fts5HighlightAppend(&rc, &ctx, zEllips, -1);
		}
	}
	if (rc == SQLITE_OK) {
		sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
	}
	else {
		sqlite3_result_error_code(pCtx, rc);
	}
	sqlite3_free(ctx.zOut);
	sqlite3_free(aSeen);
	sqlite3_free(sFinder.aFirst);
}




typedef struct Fts5Bm25Data Fts5Bm25Data;
struct Fts5Bm25Data {
	int nPhrase;                    
	double avgdl;                   
	double *aIDF;                   
	double *aFreq;                  
};


static int fts5CountCb(
	const Fts5ExtensionApi *pApi,
	Fts5Context *pFts,
	void *pUserData                 
) {
	sqlite3_int64 *pn = (sqlite3_int64*)pUserData;
	UNUSED_PARAM2(pApi, pFts);
	(*pn)++;
	return SQLITE_OK;
}


static int fts5Bm25GetData(
	const Fts5ExtensionApi *pApi,
	Fts5Context *pFts,
	Fts5Bm25Data **ppData           
) {
	int rc = SQLITE_OK;             
	Fts5Bm25Data *p;                

	p = pApi->xGetAuxdata(pFts, 0);
	if (p == 0) {
		int nPhrase;                  
		sqlite3_int64 nRow = 0;       
		sqlite3_int64 nToken = 0;     
		int nByte;                    
		int i;

		
		nPhrase = pApi->xPhraseCount(pFts);
		nByte = sizeof(Fts5Bm25Data) + nPhrase * 2 * sizeof(double);
		p = (Fts5Bm25Data*)sqlite3_malloc(nByte);
		if (p == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			memset(p, 0, nByte);
			p->nPhrase = nPhrase;
			p->aIDF = (double*)&p[1];
			p->aFreq = &p->aIDF[nPhrase];
		}

		
		if (rc == SQLITE_OK) rc = pApi->xRowCount(pFts, &nRow);
		if (rc == SQLITE_OK) rc = pApi->xColumnTotalSize(pFts, -1, &nToken);
		if (rc == SQLITE_OK) p->avgdl = (double)nToken / (double)nRow;

		
		for (i = 0; rc == SQLITE_OK && i<nPhrase; i++) {
			sqlite3_int64 nHit = 0;
			rc = pApi->xQueryPhrase(pFts, i, (void*)&nHit, fts5CountCb);
			if (rc == SQLITE_OK) {
				
				double idf = log((nRow - nHit + 0.5) / (nHit + 0.5));
				if (idf <= 0.0) idf = 1e-6;
				p->aIDF[i] = idf;
			}
		}

		if (rc != SQLITE_OK) {
			sqlite3_free(p);
		}
		else {
			rc = pApi->xSetAuxdata(pFts, p, sqlite3_free);
		}
		if (rc != SQLITE_OK) p = 0;
	}
	*ppData = p;
	return rc;
}


static void fts5Bm25Function(
	const Fts5ExtensionApi *pApi,   
	Fts5Context *pFts,              
	sqlite3_context *pCtx,          
	int nVal,                       
	sqlite3_value **apVal           
) {
	const double k1 = 1.2;          
	const double b = 0.75;          
	int rc = SQLITE_OK;             
	double score = 0.0;             
	Fts5Bm25Data *pData;            
	int i;                          
	int nInst = 0;                  
	double D = 0.0;                 
	double *aFreq = 0;              

									
	rc = fts5Bm25GetData(pApi, pFts, &pData);
	if (rc == SQLITE_OK) {
		aFreq = pData->aFreq;
		memset(aFreq, 0, sizeof(double) * pData->nPhrase);
		rc = pApi->xInstCount(pFts, &nInst);
	}
	for (i = 0; rc == SQLITE_OK && i<nInst; i++) {
		int ip; int ic; int io;
		rc = pApi->xInst(pFts, i, &ip, &ic, &io);
		if (rc == SQLITE_OK) {
			double w = (nVal > ic) ? sqlite3_value_double(apVal[ic]) : 1.0;
			aFreq[ip] += w;
		}
	}

	
	if (rc == SQLITE_OK) {
		int nTok;
		rc = pApi->xColumnSize(pFts, -1, &nTok);
		D = (double)nTok;
	}

	
	for (i = 0; rc == SQLITE_OK && i<pData->nPhrase; i++) {
		score += pData->aIDF[i] * (
			(aFreq[i] * (k1 + 1.0)) /
			(aFreq[i] + k1 * (1 - b + b * D / pData->avgdl))
			);
	}

	
	if (rc == SQLITE_OK) {
		sqlite3_result_double(pCtx, -1.0 * score);
	}
	else {
		sqlite3_result_error_code(pCtx, rc);
	}
}

static int sqlite3Fts5AuxInit(fts5_api *pApi) {
	struct Builtin {
		const char *zFunc;            
		void *pUserData;              
		fts5_extension_function xFunc;
		void(*xDestroy)(void*);      
	} aBuiltin[] = {
		{ "snippet",   0, fts5SnippetFunction, 0 },
		{ "highlight", 0, fts5HighlightFunction, 0 },
		{ "bm25",      0, fts5Bm25Function,    0 },
	};
	int rc = SQLITE_OK;             
	int i;                          

	for (i = 0; rc == SQLITE_OK && i<ArraySize(aBuiltin); i++) {
		rc = pApi->xCreateFunction(pApi,
			aBuiltin[i].zFunc,
			aBuiltin[i].pUserData,
			aBuiltin[i].xFunc,
			aBuiltin[i].xDestroy
		);
	}

	return rc;
}









static int sqlite3Fts5BufferSize(int *pRc, Fts5Buffer *pBuf, u32 nByte) {
	if ((u32)pBuf->nSpace<nByte) {
		u32 nNew = pBuf->nSpace ? pBuf->nSpace : 64;
		u8 *pNew;
		while (nNew<nByte) {
			nNew = nNew * 2;
		}
		pNew = sqlite3_realloc(pBuf->p, nNew);
		if (pNew == 0) {
			*pRc = SQLITE_NOMEM;
			return 1;
		}
		else {
			pBuf->nSpace = nNew;
			pBuf->p = pNew;
		}
	}
	return 0;
}



static void sqlite3Fts5BufferAppendVarint(int *pRc, Fts5Buffer *pBuf, i64 iVal) {
	if (fts5BufferGrow(pRc, pBuf, 9)) return;
	pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iVal);
}

static void sqlite3Fts5Put32(u8 *aBuf, int iVal) {
	aBuf[0] = (iVal >> 24) & 0x00FF;
	aBuf[1] = (iVal >> 16) & 0x00FF;
	aBuf[2] = (iVal >> 8) & 0x00FF;
	aBuf[3] = (iVal >> 0) & 0x00FF;
}

static int sqlite3Fts5Get32(const u8 *aBuf) {
	return (aBuf[0] << 24) + (aBuf[1] << 16) + (aBuf[2] << 8) + aBuf[3];
}


static void sqlite3Fts5BufferAppendBlob(
	int *pRc,
	Fts5Buffer *pBuf,
	u32 nData,
	const u8 *pData
) {
	assert_nc(*pRc || nData >= 0);
	if (fts5BufferGrow(pRc, pBuf, nData)) return;
	memcpy(&pBuf->p[pBuf->n], pData, nData);
	pBuf->n += nData;
}


static void sqlite3Fts5BufferAppendString(
	int *pRc,
	Fts5Buffer *pBuf,
	const char *zStr
) {
	int nStr = (int)strlen(zStr);
	sqlite3Fts5BufferAppendBlob(pRc, pBuf, nStr + 1, (const u8*)zStr);
	pBuf->n--;
}


static void sqlite3Fts5BufferAppendPrintf(
	int *pRc,
	Fts5Buffer *pBuf,
	char *zFmt, ...
) {
	if (*pRc == SQLITE_OK) {
		char *zTmp;
		va_list ap;
		va_start(ap, zFmt);
		zTmp = sqlite3_vmprintf(zFmt, ap);
		va_end(ap);

		if (zTmp == 0) {
			*pRc = SQLITE_NOMEM;
		}
		else {
			sqlite3Fts5BufferAppendString(pRc, pBuf, zTmp);
			sqlite3_free(zTmp);
		}
	}
}

static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...) {
	char *zRet = 0;
	if (*pRc == SQLITE_OK) {
		va_list ap;
		va_start(ap, zFmt);
		zRet = sqlite3_vmprintf(zFmt, ap);
		va_end(ap);
		if (zRet == 0) {
			*pRc = SQLITE_NOMEM;
		}
	}
	return zRet;
}



static void sqlite3Fts5BufferFree(Fts5Buffer *pBuf) {
	sqlite3_free(pBuf->p);
	memset(pBuf, 0, sizeof(Fts5Buffer));
}


static void sqlite3Fts5BufferZero(Fts5Buffer *pBuf) {
	pBuf->n = 0;
}


static void sqlite3Fts5BufferSet(
	int *pRc,
	Fts5Buffer *pBuf,
	int nData,
	const u8 *pData
) {
	pBuf->n = 0;
	sqlite3Fts5BufferAppendBlob(pRc, pBuf, nData, pData);
}

static int sqlite3Fts5PoslistNext64(
	const u8 *a, int n,             
	int *pi,                        
	i64 *piOff                      
) {
	int i = *pi;
	if (i >= n) {
		
		*piOff = -1;
		return 1;
	}
	else {
		i64 iOff = *piOff;
		int iVal;
		fts5FastGetVarint32(a, i, iVal);
		if (iVal == 1) {
			fts5FastGetVarint32(a, i, iVal);
			iOff = ((i64)iVal) << 32;
			fts5FastGetVarint32(a, i, iVal);
		}
		*piOff = iOff + (iVal - 2);
		*pi = i;
		return 0;
	}
}



static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader *pIter) {
	if (sqlite3Fts5PoslistNext64(pIter->a, pIter->n, &pIter->i, &pIter->iPos)) {
		pIter->bEof = 1;
	}
	return pIter->bEof;
}

static int sqlite3Fts5PoslistReaderInit(
	const u8 *a, int n,             
	Fts5PoslistReader *pIter        
) {
	memset(pIter, 0, sizeof(*pIter));
	pIter->a = a;
	pIter->n = n;
	sqlite3Fts5PoslistReaderNext(pIter);
	return pIter->bEof;
}


static void sqlite3Fts5PoslistSafeAppend(
	Fts5Buffer *pBuf,
	i64 *piPrev,
	i64 iPos
) {
	static const i64 colmask = ((i64)(0x7FFFFFFF)) << 32;
	if ((iPos & colmask) != (*piPrev & colmask)) {
		pBuf->p[pBuf->n++] = 1;
		pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos >> 32));
		*piPrev = (iPos & colmask);
	}
	pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos - *piPrev) + 2);
	*piPrev = iPos;
}

static int sqlite3Fts5PoslistWriterAppend(
	Fts5Buffer *pBuf,
	Fts5PoslistWriter *pWriter,
	i64 iPos
) {
	int rc = 0;   
	if (fts5BufferGrow(&rc, pBuf, 5 + 5 + 5)) return rc;
	sqlite3Fts5PoslistSafeAppend(pBuf, &pWriter->iPrev, iPos);
	return SQLITE_OK;
}

static void *sqlite3Fts5MallocZero(int *pRc, int nByte) {
	void *pRet = 0;
	if (*pRc == SQLITE_OK) {
		pRet = sqlite3_malloc(nByte);
		if (pRet == 0 && nByte>0) {
			*pRc = SQLITE_NOMEM;
		}
		else {
			memset(pRet, 0, nByte);
		}
	}
	return pRet;
}


static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn) {
	char *zRet = 0;
	if (*pRc == SQLITE_OK) {
		if (nIn<0) {
			nIn = (int)strlen(pIn);
		}
		zRet = (char*)sqlite3_malloc(nIn + 1);
		if (zRet) {
			memcpy(zRet, pIn, nIn);
			zRet[nIn] = '\0';
		}
		else {
			*pRc = SQLITE_NOMEM;
		}
	}
	return zRet;
}



static int sqlite3Fts5IsBareword(char t) {
	u8 aBareword[128] = {
		0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0,   
		0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 1, 0, 0, 0, 0, 0,   
		0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0,   
		1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 0, 0, 0, 0, 0, 0,   
		0, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1,   
		1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 0, 0, 0, 0, 1,   
		0, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1,   
		1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 0, 0, 0, 0, 0    
	};

	return (t & 0x80) || aBareword[(int)t];
}



typedef struct Fts5TermsetEntry Fts5TermsetEntry;
struct Fts5TermsetEntry {
	char *pTerm;
	int nTerm;
	int iIdx;                       
	Fts5TermsetEntry *pNext;
};

struct Fts5Termset {
	Fts5TermsetEntry *apHash[512];
};

static int sqlite3Fts5TermsetNew(Fts5Termset **pp) {
	int rc = SQLITE_OK;
	*pp = sqlite3Fts5MallocZero(&rc, sizeof(Fts5Termset));
	return rc;
}

static int sqlite3Fts5TermsetAdd(
	Fts5Termset *p,
	int iIdx,
	const char *pTerm, int nTerm,
	int *pbPresent
) {
	int rc = SQLITE_OK;
	*pbPresent = 0;
	if (p) {
		int i;
		u32 hash = 13;
		Fts5TermsetEntry *pEntry;

		
		for (i = nTerm - 1; i >= 0; i--) {
			hash = (hash << 3) ^ hash ^ pTerm[i];
		}
		hash = (hash << 3) ^ hash ^ iIdx;
		hash = hash % ArraySize(p->apHash);

		for (pEntry = p->apHash[hash]; pEntry; pEntry = pEntry->pNext) {
			if (pEntry->iIdx == iIdx
				&& pEntry->nTerm == nTerm
				&& memcmp(pEntry->pTerm, pTerm, nTerm) == 0
				) {
				*pbPresent = 1;
				break;
			}
		}

		if (pEntry == 0) {
			pEntry = sqlite3Fts5MallocZero(&rc, sizeof(Fts5TermsetEntry) + nTerm);
			if (pEntry) {
				pEntry->pTerm = (char*)&pEntry[1];
				pEntry->nTerm = nTerm;
				pEntry->iIdx = iIdx;
				memcpy(pEntry->pTerm, pTerm, nTerm);
				pEntry->pNext = p->apHash[hash];
				p->apHash[hash] = pEntry;
			}
		}
	}

	return rc;
}

static void sqlite3Fts5TermsetFree(Fts5Termset *p) {
	if (p) {
		u32 i;
		for (i = 0; i<ArraySize(p->apHash); i++) {
			Fts5TermsetEntry *pEntry = p->apHash[i];
			while (pEntry) {
				Fts5TermsetEntry *pDel = pEntry;
				pEntry = pEntry->pNext;
				sqlite3_free(pDel);
			}
		}
		sqlite3_free(p);
	}
}






#define FTS5_DEFAULT_PAGE_SIZE   4050
#define FTS5_DEFAULT_AUTOMERGE      4
#define FTS5_DEFAULT_USERMERGE      4
#define FTS5_DEFAULT_CRISISMERGE   16
#define FTS5_DEFAULT_HASHSIZE    (1024*1024)


#define FTS5_MAX_PAGE_SIZE (128*1024)

static int fts5_iswhitespace(char x) {
	return (x == ' ');
}

static int fts5_isopenquote(char x) {
	return (x == '"' || x == '\'' || x == '[' || x == '`');
}


static const char *fts5ConfigSkipWhitespace(const char *pIn) {
	const char *p = pIn;
	if (p) {
		while (fts5_iswhitespace(*p)) { p++; }
	}
	return p;
}


static const char *fts5ConfigSkipBareword(const char *pIn) {
	const char *p = pIn;
	while (sqlite3Fts5IsBareword(*p)) p++;
	if (p == pIn) p = 0;
	return p;
}

static int fts5_isdigit(char a) {
	return (a >= '0' && a <= '9');
}



static const char *fts5ConfigSkipLiteral(const char *pIn) {
	const char *p = pIn;
	switch (*p) {
	case 'n': case 'N':
		if (sqlite3_strnicmp("null", p, 4) == 0) {
			p = &p[4];
		}
		else {
			p = 0;
		}
		break;

	case 'x': case 'X':
		p++;
		if (*p == '\'') {
			p++;
			while ((*p >= 'a' && *p <= 'f')
				|| (*p >= 'A' && *p <= 'F')
				|| (*p >= '0' && *p <= '9')
				) {
				p++;
			}
			if (*p == '\'' && 0 == ((p - pIn) % 2)) {
				p++;
			}
			else {
				p = 0;
			}
		}
		else {
			p = 0;
		}
		break;

	case '\'':
		p++;
		while (p) {
			if (*p == '\'') {
				p++;
				if (*p != '\'') break;
			}
			p++;
			if (*p == 0) p = 0;
		}
		break;

	default:
		
		if (*p == '+' || *p == '-') p++;
		while (fts5_isdigit(*p)) p++;

		
		if (*p == '.' && fts5_isdigit(p[1])) {
			p += 2;
			while (fts5_isdigit(*p)) p++;
		}
		if (p == pIn) p = 0;

		break;
	}

	return p;
}


static int fts5Dequote(char *z) {
	char q;
	int iIn = 1;
	int iOut = 0;
	q = z[0];

	
	assert(q == '[' || q == '\'' || q == '"' || q == '`');
	if (q == '[') q = ']';

	while (ALWAYS(z[iIn])) {
		if (z[iIn] == q) {
			if (z[iIn + 1] != q) {
				
				iIn++;
				break;
			}
			else {
				
				iIn += 2;
				z[iOut++] = q;
			}
		}
		else {
			z[iOut++] = z[iIn++];
		}
	}

	z[iOut] = '\0';
	return iIn;
}


static void sqlite3Fts5Dequote(char *z) {
	char quote;                     

	assert(0 == fts5_iswhitespace(z[0]));
	quote = z[0];
	if (quote == '[' || quote == '\'' || quote == '"' || quote == '`') {
		fts5Dequote(z);
	}
}


struct Fts5Enum {
	const char *zName;
	int eVal;
};
typedef struct Fts5Enum Fts5Enum;

static int fts5ConfigSetEnum(
	const Fts5Enum *aEnum,
	const char *zEnum,
	int *peVal
) {
	int nEnum = (int)strlen(zEnum);
	int i;
	int iVal = -1;

	for (i = 0; aEnum[i].zName; i++) {
		if (sqlite3_strnicmp(aEnum[i].zName, zEnum, nEnum) == 0) {
			if (iVal >= 0) return SQLITE_ERROR;
			iVal = aEnum[i].eVal;
		}
	}

	*peVal = iVal;
	return iVal<0 ? SQLITE_ERROR : SQLITE_OK;
}


static int fts5ConfigParseSpecial(
	Fts5Global *pGlobal,
	Fts5Config *pConfig,            
	const char *zCmd,               
	const char *zArg,               
	char **pzErr                    
) {
	int rc = SQLITE_OK;
	int nCmd = (int)strlen(zCmd);
	if (sqlite3_strnicmp("prefix", zCmd, nCmd) == 0) {
		const int nByte = sizeof(int) * FTS5_MAX_PREFIX_INDEXES;
		const char *p;
		int bFirst = 1;
		if (pConfig->aPrefix == 0) {
			pConfig->aPrefix = sqlite3Fts5MallocZero(&rc, nByte);
			if (rc) return rc;
		}

		p = zArg;
		while (1) {
			int nPre = 0;

			while (p[0] == ' ') p++;
			if (bFirst == 0 && p[0] == ',') {
				p++;
				while (p[0] == ' ') p++;
			}
			else if (p[0] == '\0') {
				break;
			}
			if (p[0]<'0' || p[0]>'9') {
				*pzErr = sqlite3_mprintf("malformed prefix=... directive");
				rc = SQLITE_ERROR;
				break;
			}

			if (pConfig->nPrefix == FTS5_MAX_PREFIX_INDEXES) {
				*pzErr = sqlite3_mprintf(
					"too many prefix indexes (max %d)", FTS5_MAX_PREFIX_INDEXES
				);
				rc = SQLITE_ERROR;
				break;
			}

			while (p[0] >= '0' && p[0] <= '9' && nPre<1000) {
				nPre = nPre * 10 + (p[0] - '0');
				p++;
			}

			if (nPre <= 0 || nPre >= 1000) {
				*pzErr = sqlite3_mprintf("prefix length out of range (max 999)");
				rc = SQLITE_ERROR;
				break;
			}

			pConfig->aPrefix[pConfig->nPrefix] = nPre;
			pConfig->nPrefix++;
			bFirst = 0;
		}
		assert(pConfig->nPrefix <= FTS5_MAX_PREFIX_INDEXES);
		return rc;
	}

	if (sqlite3_strnicmp("tokenize", zCmd, nCmd) == 0) {
		const char *p = (const char*)zArg;
		int nArg = (int)strlen(zArg) + 1;
		char **azArg = sqlite3Fts5MallocZero(&rc, sizeof(char*) * nArg);
		char *pDel = sqlite3Fts5MallocZero(&rc, nArg * 2);
		char *pSpace = pDel;

		if (azArg && pSpace) {
			if (pConfig->pTok) {
				*pzErr = sqlite3_mprintf("multiple tokenize=... directives");
				rc = SQLITE_ERROR;
			}
			else {
				for (nArg = 0; p && *p; nArg++) {
					const char *p2 = fts5ConfigSkipWhitespace(p);
					if (*p2 == '\'') {
						p = fts5ConfigSkipLiteral(p2);
					}
					else {
						p = fts5ConfigSkipBareword(p2);
					}
					if (p) {
						memcpy(pSpace, p2, p - p2);
						azArg[nArg] = pSpace;
						sqlite3Fts5Dequote(pSpace);
						pSpace += (p - p2) + 1;
						p = fts5ConfigSkipWhitespace(p);
					}
				}
				if (p == 0) {
					*pzErr = sqlite3_mprintf("parse error in tokenize directive");
					rc = SQLITE_ERROR;
				}
				else {
					rc = sqlite3Fts5GetTokenizer(pGlobal,
						(const char**)azArg, nArg, &pConfig->pTok, &pConfig->pTokApi,
						pzErr
					);
				}
			}
		}

		sqlite3_free(azArg);
		sqlite3_free(pDel);
		return rc;
	}

	if (sqlite3_strnicmp("content", zCmd, nCmd) == 0) {
		if (pConfig->eContent != FTS5_CONTENT_NORMAL) {
			*pzErr = sqlite3_mprintf("multiple content=... directives");
			rc = SQLITE_ERROR;
		}
		else {
			if (zArg[0]) {
				pConfig->eContent = FTS5_CONTENT_EXTERNAL;
				pConfig->zContent = sqlite3Fts5Mprintf(&rc, "%Q.%Q", pConfig->zDb, zArg);
			}
			else {
				pConfig->eContent = FTS5_CONTENT_NONE;
			}
		}
		return rc;
	}

	if (sqlite3_strnicmp("content_rowid", zCmd, nCmd) == 0) {
		if (pConfig->zContentRowid) {
			*pzErr = sqlite3_mprintf("multiple content_rowid=... directives");
			rc = SQLITE_ERROR;
		}
		else {
			pConfig->zContentRowid = sqlite3Fts5Strndup(&rc, zArg, -1);
		}
		return rc;
	}

	if (sqlite3_strnicmp("columnsize", zCmd, nCmd) == 0) {
		if ((zArg[0] != '0' && zArg[0] != '1') || zArg[1] != '\0') {
			*pzErr = sqlite3_mprintf("malformed columnsize=... directive");
			rc = SQLITE_ERROR;
		}
		else {
			pConfig->bColumnsize = (zArg[0] == '1');
		}
		return rc;
	}

	if (sqlite3_strnicmp("detail", zCmd, nCmd) == 0) {
		const Fts5Enum aDetail[] = {
			{ "none", FTS5_DETAIL_NONE },
			{ "full", FTS5_DETAIL_FULL },
			{ "columns", FTS5_DETAIL_COLUMNS },
			{ 0, 0 }
		};

		if ((rc = fts5ConfigSetEnum(aDetail, zArg, &pConfig->eDetail))) {
			*pzErr = sqlite3_mprintf("malformed detail=... directive");
		}
		return rc;
	}

	*pzErr = sqlite3_mprintf("unrecognized option: \"%.*s\"", nCmd, zCmd);
	return SQLITE_ERROR;
}


static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig) {
	assert(pConfig->pTok == 0 && pConfig->pTokApi == 0);
	return sqlite3Fts5GetTokenizer(
		pGlobal, 0, 0, &pConfig->pTok, &pConfig->pTokApi, 0
	);
}


static const char *fts5ConfigGobbleWord(
	int *pRc,                       
	const char *zIn,                
	char **pzOut,                   
	int *pbQuoted                   
) {
	const char *zRet = 0;

	int nIn = (int)strlen(zIn);
	char *zOut = sqlite3_malloc(nIn + 1);

	assert(*pRc == SQLITE_OK);
	*pbQuoted = 0;
	*pzOut = 0;

	if (zOut == 0) {
		*pRc = SQLITE_NOMEM;
	}
	else {
		memcpy(zOut, zIn, nIn + 1);
		if (fts5_isopenquote(zOut[0])) {
			int ii = fts5Dequote(zOut);
			zRet = &zIn[ii];
			*pbQuoted = 1;
		}
		else {
			zRet = fts5ConfigSkipBareword(zIn);
			if (zRet) {
				zOut[zRet - zIn] = '\0';
			}
		}
	}

	if (zRet == 0) {
		sqlite3_free(zOut);
	}
	else {
		*pzOut = zOut;
	}

	return zRet;
}

static int fts5ConfigParseColumn(
	Fts5Config *p,
	char *zCol,
	char *zArg,
	char **pzErr
) {
	int rc = SQLITE_OK;
	if (0 == sqlite3_stricmp(zCol, FTS5_RANK_NAME)
		|| 0 == sqlite3_stricmp(zCol, FTS5_ROWID_NAME)
		) {
		*pzErr = sqlite3_mprintf("reserved fts5 column name: %s", zCol);
		rc = SQLITE_ERROR;
	}
	else if (zArg) {
		if (0 == sqlite3_stricmp(zArg, "unindexed")) {
			p->abUnindexed[p->nCol] = 1;
		}
		else {
			*pzErr = sqlite3_mprintf("unrecognized column option: %s", zArg);
			rc = SQLITE_ERROR;
		}
	}

	p->azCol[p->nCol++] = zCol;
	return rc;
}


static int fts5ConfigMakeExprlist(Fts5Config *p) {
	int i;
	int rc = SQLITE_OK;
	Fts5Buffer buf = { 0, 0, 0 };

	sqlite3Fts5BufferAppendPrintf(&rc, &buf, "T.%Q", p->zContentRowid);
	if (p->eContent != FTS5_CONTENT_NONE) {
		for (i = 0; i<p->nCol; i++) {
			if (p->eContent == FTS5_CONTENT_EXTERNAL) {
				sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.%Q", p->azCol[i]);
			}
			else {
				sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.c%d", i);
			}
		}
	}

	assert(p->zContentExprlist == 0);
	p->zContentExprlist = (char*)buf.p;
	return rc;
}


static int sqlite3Fts5ConfigParse(
	Fts5Global *pGlobal,
	sqlite3 *db,
	int nArg,                       
	const char **azArg,             
	Fts5Config **ppOut,             
	char **pzErr                    
) {
	int rc = SQLITE_OK;             
	Fts5Config *pRet;               
	int i;
	int nByte;

	*ppOut = pRet = (Fts5Config*)sqlite3_malloc(sizeof(Fts5Config));
	if (pRet == 0) return SQLITE_NOMEM;
	memset(pRet, 0, sizeof(Fts5Config));
	pRet->db = db;
	pRet->iCookie = -1;

	nByte = nArg * (sizeof(char*) + sizeof(u8));
	pRet->azCol = (char**)sqlite3Fts5MallocZero(&rc, nByte);
	pRet->abUnindexed = (u8*)&pRet->azCol[nArg];
	pRet->zDb = sqlite3Fts5Strndup(&rc, azArg[1], -1);
	pRet->zName = sqlite3Fts5Strndup(&rc, azArg[2], -1);
	pRet->bColumnsize = 1;
	pRet->eDetail = FTS5_DETAIL_FULL;
#ifdef SQLITE_DEBUG
	pRet->bPrefixIndex = 1;
#endif
	if (rc == SQLITE_OK && sqlite3_stricmp(pRet->zName, FTS5_RANK_NAME) == 0) {
		*pzErr = sqlite3_mprintf("reserved fts5 table name: %s", pRet->zName);
		rc = SQLITE_ERROR;
	}

	for (i = 3; rc == SQLITE_OK && i<nArg; i++) {
		const char *zOrig = azArg[i];
		const char *z;
		char *zOne = 0;
		char *zTwo = 0;
		int bOption = 0;
		int bMustBeCol = 0;

		z = fts5ConfigGobbleWord(&rc, zOrig, &zOne, &bMustBeCol);
		z = fts5ConfigSkipWhitespace(z);
		if (z && *z == '=') {
			bOption = 1;
			z++;
			if (bMustBeCol) z = 0;
		}
		z = fts5ConfigSkipWhitespace(z);
		if (z && z[0]) {
			int bDummy;
			z = fts5ConfigGobbleWord(&rc, z, &zTwo, &bDummy);
			if (z && z[0]) z = 0;
		}

		if (rc == SQLITE_OK) {
			if (z == 0) {
				*pzErr = sqlite3_mprintf("parse error in \"%s\"", zOrig);
				rc = SQLITE_ERROR;
			}
			else {
				if (bOption) {
					rc = fts5ConfigParseSpecial(pGlobal, pRet, zOne, zTwo ? zTwo : "", pzErr);
				}
				else {
					rc = fts5ConfigParseColumn(pRet, zOne, zTwo, pzErr);
					zOne = 0;
				}
			}
		}

		sqlite3_free(zOne);
		sqlite3_free(zTwo);
	}

	
	if (rc == SQLITE_OK && pRet->pTok == 0) {
		rc = fts5ConfigDefaultTokenizer(pGlobal, pRet);
	}

	
	if (rc == SQLITE_OK && pRet->zContent == 0) {
		const char *zTail = 0;
		assert(pRet->eContent == FTS5_CONTENT_NORMAL
			|| pRet->eContent == FTS5_CONTENT_NONE
		);
		if (pRet->eContent == FTS5_CONTENT_NORMAL) {
			zTail = "content";
		}
		else if (pRet->bColumnsize) {
			zTail = "docsize";
		}

		if (zTail) {
			pRet->zContent = sqlite3Fts5Mprintf(
				&rc, "%Q.'%q_%s'", pRet->zDb, pRet->zName, zTail
			);
		}
	}

	if (rc == SQLITE_OK && pRet->zContentRowid == 0) {
		pRet->zContentRowid = sqlite3Fts5Strndup(&rc, "rowid", -1);
	}

	
	if (rc == SQLITE_OK) {
		rc = fts5ConfigMakeExprlist(pRet);
	}

	if (rc != SQLITE_OK) {
		sqlite3Fts5ConfigFree(pRet);
		*ppOut = 0;
	}
	return rc;
}


static void sqlite3Fts5ConfigFree(Fts5Config *pConfig) {
	if (pConfig) {
		int i;
		if (pConfig->pTok) {
			pConfig->pTokApi->xDelete(pConfig->pTok);
		}
		sqlite3_free(pConfig->zDb);
		sqlite3_free(pConfig->zName);
		for (i = 0; i<pConfig->nCol; i++) {
			sqlite3_free(pConfig->azCol[i]);
		}
		sqlite3_free(pConfig->azCol);
		sqlite3_free(pConfig->aPrefix);
		sqlite3_free(pConfig->zRank);
		sqlite3_free(pConfig->zRankArgs);
		sqlite3_free(pConfig->zContent);
		sqlite3_free(pConfig->zContentRowid);
		sqlite3_free(pConfig->zContentExprlist);
		sqlite3_free(pConfig);
	}
}


static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig) {
	int i;
	int rc = SQLITE_OK;
	char *zSql;

	zSql = sqlite3Fts5Mprintf(&rc, "CREATE TABLE x(");
	for (i = 0; zSql && i<pConfig->nCol; i++) {
		const char *zSep = (i == 0 ? "" : ", ");
		zSql = sqlite3Fts5Mprintf(&rc, "%z%s%Q", zSql, zSep, pConfig->azCol[i]);
	}
	zSql = sqlite3Fts5Mprintf(&rc, "%z, %Q HIDDEN, %s HIDDEN)",
		zSql, pConfig->zName, FTS5_RANK_NAME
	);

	assert(zSql || rc == SQLITE_NOMEM);
	if (zSql) {
		rc = sqlite3_declare_vtab(pConfig->db, zSql);
		sqlite3_free(zSql);
	}

	return rc;
}


static int sqlite3Fts5Tokenize(
	Fts5Config *pConfig,            
	int flags,                      
	const char *pText, int nText,   
	void *pCtx,                     
	int(*xToken)(void*, int, const char*, int, int, int)    
) {
	if (pText == 0) return SQLITE_OK;
	return pConfig->pTokApi->xTokenize(
		pConfig->pTok, pCtx, flags, pText, nText, xToken
	);
}


static const char *fts5ConfigSkipArgs(const char *pIn) {
	const char *p = pIn;

	while (1) {
		p = fts5ConfigSkipWhitespace(p);
		p = fts5ConfigSkipLiteral(p);
		p = fts5ConfigSkipWhitespace(p);
		if (p == 0 || *p == ')') break;
		if (*p != ',') {
			p = 0;
			break;
		}
		p++;
	}

	return p;
}


static int sqlite3Fts5ConfigParseRank(
	const char *zIn,                
	char **pzRank,                  
	char **pzRankArgs               
) {
	const char *p = zIn;
	const char *pRank;
	char *zRank = 0;
	char *zRankArgs = 0;
	int rc = SQLITE_OK;

	*pzRank = 0;
	*pzRankArgs = 0;

	if (p == 0) {
		rc = SQLITE_ERROR;
	}
	else {
		p = fts5ConfigSkipWhitespace(p);
		pRank = p;
		p = fts5ConfigSkipBareword(p);

		if (p) {
			zRank = sqlite3Fts5MallocZero(&rc, 1 + p - pRank);
			if (zRank) memcpy(zRank, pRank, p - pRank);
		}
		else {
			rc = SQLITE_ERROR;
		}

		if (rc == SQLITE_OK) {
			p = fts5ConfigSkipWhitespace(p);
			if (*p != '(') rc = SQLITE_ERROR;
			p++;
		}
		if (rc == SQLITE_OK) {
			const char *pArgs;
			p = fts5ConfigSkipWhitespace(p);
			pArgs = p;
			if (*p != ')') {
				p = fts5ConfigSkipArgs(p);
				if (p == 0) {
					rc = SQLITE_ERROR;
				}
				else {
					zRankArgs = sqlite3Fts5MallocZero(&rc, 1 + p - pArgs);
					if (zRankArgs) memcpy(zRankArgs, pArgs, p - pArgs);
				}
			}
		}
	}

	if (rc != SQLITE_OK) {
		sqlite3_free(zRank);
		assert(zRankArgs == 0);
	}
	else {
		*pzRank = zRank;
		*pzRankArgs = zRankArgs;
	}
	return rc;
}

static int sqlite3Fts5ConfigSetValue(
	Fts5Config *pConfig,
	const char *zKey,
	sqlite3_value *pVal,
	int *pbBadkey
) {
	int rc = SQLITE_OK;

	if (0 == sqlite3_stricmp(zKey, "pgsz")) {
		int pgsz = 0;
		if (SQLITE_INTEGER == sqlite3_value_numeric_type(pVal)) {
			pgsz = sqlite3_value_int(pVal);
		}
		if (pgsz <= 0 || pgsz>FTS5_MAX_PAGE_SIZE) {
			*pbBadkey = 1;
		}
		else {
			pConfig->pgsz = pgsz;
		}
	}

	else if (0 == sqlite3_stricmp(zKey, "hashsize")) {
		int nHashSize = -1;
		if (SQLITE_INTEGER == sqlite3_value_numeric_type(pVal)) {
			nHashSize = sqlite3_value_int(pVal);
		}
		if (nHashSize <= 0) {
			*pbBadkey = 1;
		}
		else {
			pConfig->nHashSize = nHashSize;
		}
	}

	else if (0 == sqlite3_stricmp(zKey, "automerge")) {
		int nAutomerge = -1;
		if (SQLITE_INTEGER == sqlite3_value_numeric_type(pVal)) {
			nAutomerge = sqlite3_value_int(pVal);
		}
		if (nAutomerge<0 || nAutomerge>64) {
			*pbBadkey = 1;
		}
		else {
			if (nAutomerge == 1) nAutomerge = FTS5_DEFAULT_AUTOMERGE;
			pConfig->nAutomerge = nAutomerge;
		}
	}

	else if (0 == sqlite3_stricmp(zKey, "usermerge")) {
		int nUsermerge = -1;
		if (SQLITE_INTEGER == sqlite3_value_numeric_type(pVal)) {
			nUsermerge = sqlite3_value_int(pVal);
		}
		if (nUsermerge<2 || nUsermerge>16) {
			*pbBadkey = 1;
		}
		else {
			pConfig->nUsermerge = nUsermerge;
		}
	}

	else if (0 == sqlite3_stricmp(zKey, "crisismerge")) {
		int nCrisisMerge = -1;
		if (SQLITE_INTEGER == sqlite3_value_numeric_type(pVal)) {
			nCrisisMerge = sqlite3_value_int(pVal);
		}
		if (nCrisisMerge<0) {
			*pbBadkey = 1;
		}
		else {
			if (nCrisisMerge <= 1) nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;
			pConfig->nCrisisMerge = nCrisisMerge;
		}
	}

	else if (0 == sqlite3_stricmp(zKey, "rank")) {
		const char *zIn = (const char*)sqlite3_value_text(pVal);
		char *zRank;
		char *zRankArgs;
		rc = sqlite3Fts5ConfigParseRank(zIn, &zRank, &zRankArgs);
		if (rc == SQLITE_OK) {
			sqlite3_free(pConfig->zRank);
			sqlite3_free(pConfig->zRankArgs);
			pConfig->zRank = zRank;
			pConfig->zRankArgs = zRankArgs;
		}
		else if (rc == SQLITE_ERROR) {
			rc = SQLITE_OK;
			*pbBadkey = 1;
		}
	}
	else {
		*pbBadkey = 1;
	}
	return rc;
}


static int sqlite3Fts5ConfigLoad(Fts5Config *pConfig, int iCookie) {
	const char *zSelect = "SELECT k, v FROM %Q.'%q_config'";
	char *zSql;
	sqlite3_stmt *p = 0;
	int rc = SQLITE_OK;
	int iVersion = 0;

	
	pConfig->pgsz = FTS5_DEFAULT_PAGE_SIZE;
	pConfig->nAutomerge = FTS5_DEFAULT_AUTOMERGE;
	pConfig->nUsermerge = FTS5_DEFAULT_USERMERGE;
	pConfig->nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;
	pConfig->nHashSize = FTS5_DEFAULT_HASHSIZE;

	zSql = sqlite3Fts5Mprintf(&rc, zSelect, pConfig->zDb, pConfig->zName);
	if (zSql) {
		rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p, 0);
		sqlite3_free(zSql);
	}

	assert(rc == SQLITE_OK || p == 0);
	if (rc == SQLITE_OK) {
		while (SQLITE_ROW == sqlite3_step(p)) {
			const char *zK = (const char*)sqlite3_column_text(p, 0);
			sqlite3_value *pVal = sqlite3_column_value(p, 1);
			if (0 == sqlite3_stricmp(zK, "version")) {
				iVersion = sqlite3_value_int(pVal);
			}
			else {
				int bDummy = 0;
				sqlite3Fts5ConfigSetValue(pConfig, zK, pVal, &bDummy);
			}
		}
		rc = sqlite3_finalize(p);
	}

	if (rc == SQLITE_OK && iVersion != FTS5_CURRENT_VERSION) {
		rc = SQLITE_ERROR;
		if (pConfig->pzErrmsg) {
			assert(0 == *pConfig->pzErrmsg);
			*pConfig->pzErrmsg = sqlite3_mprintf(
				"invalid fts5 file format (found %d, expected %d) - run 'rebuild'",
				iVersion, FTS5_CURRENT_VERSION
			);
		}
	}

	if (rc == SQLITE_OK) {
		pConfig->iCookie = iCookie;
	}
	return rc;
}









#define FTS5_EOF 0

#define FTS5_LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))

typedef struct Fts5ExprTerm Fts5ExprTerm;


static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(u64));
static void sqlite3Fts5ParserFree(void*, void(*freeProc)(void*));
static void sqlite3Fts5Parser(void*, int, Fts5Token, Fts5Parse*);
#ifndef NDEBUG

static void sqlite3Fts5ParserTrace(FILE*, char*);
#endif


struct Fts5Expr {
	Fts5Index *pIndex;
	Fts5Config *pConfig;
	Fts5ExprNode *pRoot;
	int bDesc;                      
	int nPhrase;                    
	Fts5ExprPhrase **apExprPhrase;  
};


struct Fts5ExprNode {
	int eType;                      
	int bEof;                       
	int bNomatch;                   

									
	int(*xNext)(Fts5Expr*, Fts5ExprNode*, int, i64);

	i64 iRowid;                     
	Fts5ExprNearset *pNear;         

									
	int nChild;                     
	Fts5ExprNode *apChild[1];       
};

#define Fts5NodeIsString(p) ((p)->eType==FTS5_TERM || (p)->eType==FTS5_STRING)


#define fts5ExprNodeNext(a,b,c,d) (b)->xNext((a), (b), (c), (d))


struct Fts5ExprTerm {
	int bPrefix;                    
	char *zTerm;                    
	Fts5IndexIter *pIter;           
	Fts5ExprTerm *pSynonym;         
};


struct Fts5ExprPhrase {
	Fts5ExprNode *pNode;            
	Fts5Buffer poslist;             
	int nTerm;                      
	Fts5ExprTerm aTerm[1];          
};


struct Fts5ExprNearset {
	int nNear;                      
	Fts5Colset *pColset;            
	int nPhrase;                    
	Fts5ExprPhrase *apPhrase[1];    
};



struct Fts5Parse {
	Fts5Config *pConfig;
	char *zErr;
	int rc;
	int nPhrase;                    
	Fts5ExprPhrase **apPhrase;      
	Fts5ExprNode *pExpr;            
};

static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...) {
	va_list ap;
	va_start(ap, zFmt);
	if (pParse->rc == SQLITE_OK) {
		pParse->zErr = sqlite3_vmprintf(zFmt, ap);
		pParse->rc = SQLITE_ERROR;
	}
	va_end(ap);
}

static int fts5ExprIsspace(char t) {
	return t == ' ' || t == '\t' || t == '\n' || t == '\r';
}


static int fts5ExprGetToken(
	Fts5Parse *pParse,
	const char **pz,                
	Fts5Token *pToken
) {
	const char *z = *pz;
	int tok;

	
	while (fts5ExprIsspace(*z)) z++;

	pToken->p = z;
	pToken->n = 1;
	switch (*z) {
	case '(':  tok = FTS5_LP;    break;
	case ')':  tok = FTS5_RP;    break;
	case '{':  tok = FTS5_LCP;   break;
	case '}':  tok = FTS5_RCP;   break;
	case ':':  tok = FTS5_COLON; break;
	case ',':  tok = FTS5_COMMA; break;
	case '+':  tok = FTS5_PLUS;  break;
	case '*':  tok = FTS5_STAR;  break;
	case '-':  tok = FTS5_MINUS; break;
	case '\0': tok = FTS5_EOF;   break;

	case '"': {
		const char *z2;
		tok = FTS5_STRING;

		for (z2 = &z[1]; 1; z2++) {
			if (z2[0] == '"') {
				z2++;
				if (z2[0] != '"') break;
			}
			if (z2[0] == '\0') {
				sqlite3Fts5ParseError(pParse, "unterminated string");
				return FTS5_EOF;
			}
		}
		pToken->n = (z2 - z);
		break;
	}

	default: {
		const char *z2;
		if (sqlite3Fts5IsBareword(z[0]) == 0) {
			sqlite3Fts5ParseError(pParse, "fts5: syntax error near \"%.1s\"", z);
			return FTS5_EOF;
		}
		tok = FTS5_STRING;
		for (z2 = &z[1]; sqlite3Fts5IsBareword(*z2); z2++);
		pToken->n = (z2 - z);
		if (pToken->n == 2 && memcmp(pToken->p, "OR", 2) == 0)  tok = FTS5_OR;
		if (pToken->n == 3 && memcmp(pToken->p, "NOT", 3) == 0) tok = FTS5_NOT;
		if (pToken->n == 3 && memcmp(pToken->p, "AND", 3) == 0) tok = FTS5_AND;
		break;
	}
	}

	*pz = &pToken->p[pToken->n];
	return tok;
}

static void *fts5ParseAlloc(u64 t) { return sqlite3_malloc((int)t); }
static void fts5ParseFree(void *p) { sqlite3_free(p); }

static int sqlite3Fts5ExprNew(
	Fts5Config *pConfig,            
	const char *zExpr,              
	Fts5Expr **ppNew,
	char **pzErr
) {
	Fts5Parse sParse;
	Fts5Token token;
	const char *z = zExpr;
	int t;                          
	void *pEngine;
	Fts5Expr *pNew;

	*ppNew = 0;
	*pzErr = 0;
	memset(&sParse, 0, sizeof(sParse));
	pEngine = sqlite3Fts5ParserAlloc(fts5ParseAlloc);
	if (pEngine == 0) { return SQLITE_NOMEM; }
	sParse.pConfig = pConfig;

	do {
		t = fts5ExprGetToken(&sParse, &z, &token);
		sqlite3Fts5Parser(pEngine, t, token, &sParse);
	} while (sParse.rc == SQLITE_OK && t != FTS5_EOF);
	sqlite3Fts5ParserFree(pEngine, fts5ParseFree);

	assert(sParse.rc != SQLITE_OK || sParse.zErr == 0);
	if (sParse.rc == SQLITE_OK) {
		*ppNew = pNew = sqlite3_malloc(sizeof(Fts5Expr));
		if (pNew == 0) {
			sParse.rc = SQLITE_NOMEM;
			sqlite3Fts5ParseNodeFree(sParse.pExpr);
		}
		else {
			if (!sParse.pExpr) {
				const int nByte = sizeof(Fts5ExprNode);
				pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&sParse.rc, nByte);
				if (pNew->pRoot) {
					pNew->pRoot->bEof = 1;
				}
			}
			else {
				pNew->pRoot = sParse.pExpr;
			}
			pNew->pIndex = 0;
			pNew->pConfig = pConfig;
			pNew->apExprPhrase = sParse.apPhrase;
			pNew->nPhrase = sParse.nPhrase;
			sParse.apPhrase = 0;
		}
	}
	else {
		sqlite3Fts5ParseNodeFree(sParse.pExpr);
	}

	sqlite3_free(sParse.apPhrase);
	*pzErr = sParse.zErr;
	return sParse.rc;
}


static void sqlite3Fts5ParseNodeFree(Fts5ExprNode *p) {
	if (p) {
		int i;
		for (i = 0; i<p->nChild; i++) {
			sqlite3Fts5ParseNodeFree(p->apChild[i]);
		}
		sqlite3Fts5ParseNearsetFree(p->pNear);
		sqlite3_free(p);
	}
}


static void sqlite3Fts5ExprFree(Fts5Expr *p) {
	if (p) {
		sqlite3Fts5ParseNodeFree(p->pRoot);
		sqlite3_free(p->apExprPhrase);
		sqlite3_free(p);
	}
}


static i64 fts5ExprSynonymRowid(Fts5ExprTerm *pTerm, int bDesc, int *pbEof) {
	i64 iRet = 0;
	int bRetValid = 0;
	Fts5ExprTerm *p;

	assert(pTerm->pSynonym);
	assert(bDesc == 0 || bDesc == 1);
	for (p = pTerm; p; p = p->pSynonym) {
		if (0 == sqlite3Fts5IterEof(p->pIter)) {
			i64 iRowid = p->pIter->iRowid;
			if (bRetValid == 0 || (bDesc != (iRowid<iRet))) {
				iRet = iRowid;
				bRetValid = 1;
			}
		}
	}

	if (pbEof && bRetValid == 0) *pbEof = 1;
	return iRet;
}


static int fts5ExprSynonymList(
	Fts5ExprTerm *pTerm,
	i64 iRowid,
	Fts5Buffer *pBuf,               
	u8 **pa, int *pn
) {
	Fts5PoslistReader aStatic[4];
	Fts5PoslistReader *aIter = aStatic;
	int nIter = 0;
	int nAlloc = 4;
	int rc = SQLITE_OK;
	Fts5ExprTerm *p;

	assert(pTerm->pSynonym);
	for (p = pTerm; p; p = p->pSynonym) {
		Fts5IndexIter *pIter = p->pIter;
		if (sqlite3Fts5IterEof(pIter) == 0 && pIter->iRowid == iRowid) {
			if (pIter->nData == 0) continue;
			if (nIter == nAlloc) {
				int nByte = sizeof(Fts5PoslistReader) * nAlloc * 2;
				Fts5PoslistReader *aNew = (Fts5PoslistReader*)sqlite3_malloc(nByte);
				if (aNew == 0) {
					rc = SQLITE_NOMEM;
					goto synonym_poslist_out;
				}
				memcpy(aNew, aIter, sizeof(Fts5PoslistReader) * nIter);
				nAlloc = nAlloc * 2;
				if (aIter != aStatic) sqlite3_free(aIter);
				aIter = aNew;
			}
			sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &aIter[nIter]);
			assert(aIter[nIter].bEof == 0);
			nIter++;
		}
	}

	if (nIter == 1) {
		*pa = (u8*)aIter[0].a;
		*pn = aIter[0].n;
	}
	else {
		Fts5PoslistWriter writer = { 0 };
		i64 iPrev = -1;
		fts5BufferZero(pBuf);
		while (1) {
			int i;
			i64 iMin = FTS5_LARGEST_INT64;
			for (i = 0; i<nIter; i++) {
				if (aIter[i].bEof == 0) {
					if (aIter[i].iPos == iPrev) {
						if (sqlite3Fts5PoslistReaderNext(&aIter[i])) continue;
					}
					if (aIter[i].iPos<iMin) {
						iMin = aIter[i].iPos;
					}
				}
			}
			if (iMin == FTS5_LARGEST_INT64 || rc != SQLITE_OK) break;
			rc = sqlite3Fts5PoslistWriterAppend(pBuf, &writer, iMin);
			iPrev = iMin;
		}
		if (rc == SQLITE_OK) {
			*pa = pBuf->p;
			*pn = pBuf->n;
		}
	}

synonym_poslist_out:
	if (aIter != aStatic) sqlite3_free(aIter);
	return rc;
}



static int fts5ExprPhraseIsMatch(
	Fts5ExprNode *pNode,            
	Fts5ExprPhrase *pPhrase,        
	int *pbMatch                    
) {
	Fts5PoslistWriter writer = { 0 };
	Fts5PoslistReader aStatic[4];
	Fts5PoslistReader *aIter = aStatic;
	int i;
	int rc = SQLITE_OK;

	fts5BufferZero(&pPhrase->poslist);

	
	if (pPhrase->nTerm>ArraySize(aStatic)) {
		int nByte = sizeof(Fts5PoslistReader) * pPhrase->nTerm;
		aIter = (Fts5PoslistReader*)sqlite3_malloc(nByte);
		if (!aIter) return SQLITE_NOMEM;
	}
	memset(aIter, 0, sizeof(Fts5PoslistReader) * pPhrase->nTerm);

	
	for (i = 0; i<pPhrase->nTerm; i++) {
		Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];
		int n = 0;
		int bFlag = 0;
		u8 *a = 0;
		if (pTerm->pSynonym) {
			Fts5Buffer buf = { 0, 0, 0 };
			rc = fts5ExprSynonymList(pTerm, pNode->iRowid, &buf, &a, &n);
			if (rc) {
				sqlite3_free(a);
				goto ismatch_out;
			}
			if (a == buf.p) bFlag = 1;
		}
		else {
			a = (u8*)pTerm->pIter->pData;
			n = pTerm->pIter->nData;
		}
		sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);
		aIter[i].bFlag = (u8)bFlag;
		if (aIter[i].bEof) goto ismatch_out;
	}

	while (1) {
		int bMatch;
		i64 iPos = aIter[0].iPos;
		do {
			bMatch = 1;
			for (i = 0; i<pPhrase->nTerm; i++) {
				Fts5PoslistReader *pPos = &aIter[i];
				i64 iAdj = iPos + i;
				if (pPos->iPos != iAdj) {
					bMatch = 0;
					while (pPos->iPos<iAdj) {
						if (sqlite3Fts5PoslistReaderNext(pPos)) goto ismatch_out;
					}
					if (pPos->iPos>iAdj) iPos = pPos->iPos - i;
				}
			}
		} while (bMatch == 0);

		
		rc = sqlite3Fts5PoslistWriterAppend(&pPhrase->poslist, &writer, iPos);
		if (rc != SQLITE_OK) goto ismatch_out;

		for (i = 0; i<pPhrase->nTerm; i++) {
			if (sqlite3Fts5PoslistReaderNext(&aIter[i])) goto ismatch_out;
		}
	}

ismatch_out:
	*pbMatch = (pPhrase->poslist.n>0);
	for (i = 0; i<pPhrase->nTerm; i++) {
		if (aIter[i].bFlag) sqlite3_free((u8*)aIter[i].a);
	}
	if (aIter != aStatic) sqlite3_free(aIter);
	return rc;
}

typedef struct Fts5LookaheadReader Fts5LookaheadReader;
struct Fts5LookaheadReader {
	const u8 *a;                    
	int n;                          
	int i;                          
	i64 iPos;                       
	i64 iLookahead;                 
};

#define FTS5_LOOKAHEAD_EOF (((i64)1) << 62)

static int fts5LookaheadReaderNext(Fts5LookaheadReader *p) {
	p->iPos = p->iLookahead;
	if (sqlite3Fts5PoslistNext64(p->a, p->n, &p->i, &p->iLookahead)) {
		p->iLookahead = FTS5_LOOKAHEAD_EOF;
	}
	return (p->iPos == FTS5_LOOKAHEAD_EOF);
}

static int fts5LookaheadReaderInit(
	const u8 *a, int n,             
	Fts5LookaheadReader *p          
) {
	memset(p, 0, sizeof(Fts5LookaheadReader));
	p->a = a;
	p->n = n;
	fts5LookaheadReaderNext(p);
	return fts5LookaheadReaderNext(p);
}

typedef struct Fts5NearTrimmer Fts5NearTrimmer;
struct Fts5NearTrimmer {
	Fts5LookaheadReader reader;     
	Fts5PoslistWriter writer;       
	Fts5Buffer *pOut;               
};


static int fts5ExprNearIsMatch(int *pRc, Fts5ExprNearset *pNear) {
	Fts5NearTrimmer aStatic[4];
	Fts5NearTrimmer *a = aStatic;
	Fts5ExprPhrase **apPhrase = pNear->apPhrase;

	int i;
	int rc = *pRc;
	int bMatch;

	assert(pNear->nPhrase>1);

	
	if (pNear->nPhrase>ArraySize(aStatic)) {
		int nByte = sizeof(Fts5NearTrimmer) * pNear->nPhrase;
		a = (Fts5NearTrimmer*)sqlite3Fts5MallocZero(&rc, nByte);
	}
	else {
		memset(aStatic, 0, sizeof(aStatic));
	}
	if (rc != SQLITE_OK) {
		*pRc = rc;
		return 0;
	}

	
	for (i = 0; i<pNear->nPhrase; i++) {
		Fts5Buffer *pPoslist = &apPhrase[i]->poslist;
		fts5LookaheadReaderInit(pPoslist->p, pPoslist->n, &a[i].reader);
		pPoslist->n = 0;
		a[i].pOut = pPoslist;
	}

	while (1) {
		int iAdv;
		i64 iMin;
		i64 iMax;

		
		iMax = a[0].reader.iPos;
		do {
			bMatch = 1;
			for (i = 0; i<pNear->nPhrase; i++) {
				Fts5LookaheadReader *pPos = &a[i].reader;
				iMin = iMax - pNear->apPhrase[i]->nTerm - pNear->nNear;
				if (pPos->iPos<iMin || pPos->iPos>iMax) {
					bMatch = 0;
					while (pPos->iPos<iMin) {
						if (fts5LookaheadReaderNext(pPos)) goto ismatch_out;
					}
					if (pPos->iPos>iMax) iMax = pPos->iPos;
				}
			}
		} while (bMatch == 0);

		
		for (i = 0; i<pNear->nPhrase; i++) {
			i64 iPos = a[i].reader.iPos;
			Fts5PoslistWriter *pWriter = &a[i].writer;
			if (a[i].pOut->n == 0 || iPos != pWriter->iPrev) {
				sqlite3Fts5PoslistWriterAppend(a[i].pOut, pWriter, iPos);
			}
		}

		iAdv = 0;
		iMin = a[0].reader.iLookahead;
		for (i = 0; i<pNear->nPhrase; i++) {
			if (a[i].reader.iLookahead < iMin) {
				iMin = a[i].reader.iLookahead;
				iAdv = i;
			}
		}
		if (fts5LookaheadReaderNext(&a[iAdv].reader)) goto ismatch_out;
	}

ismatch_out: {
	int bRet = a[0].pOut->n>0;
	*pRc = rc;
	if (a != aStatic) sqlite3_free(a);
	return bRet;
	}
}


static int fts5ExprAdvanceto(
	Fts5IndexIter *pIter,           
	int bDesc,                      
	i64 *piLast,                    
	int *pRc,                       
	int *pbEof                      
) {
	i64 iLast = *piLast;
	i64 iRowid;

	iRowid = pIter->iRowid;
	if ((bDesc == 0 && iLast>iRowid) || (bDesc && iLast<iRowid)) {
		int rc = sqlite3Fts5IterNextFrom(pIter, iLast);
		if (rc || sqlite3Fts5IterEof(pIter)) {
			*pRc = rc;
			*pbEof = 1;
			return 1;
		}
		iRowid = pIter->iRowid;
		assert((bDesc == 0 && iRowid >= iLast) || (bDesc == 1 && iRowid <= iLast));
	}
	*piLast = iRowid;

	return 0;
}

static int fts5ExprSynonymAdvanceto(
	Fts5ExprTerm *pTerm,            
	int bDesc,                      
	i64 *piLast,                    
	int *pRc                        
) {
	int rc = SQLITE_OK;
	i64 iLast = *piLast;
	Fts5ExprTerm *p;
	int bEof = 0;

	for (p = pTerm; rc == SQLITE_OK && p; p = p->pSynonym) {
		if (sqlite3Fts5IterEof(p->pIter) == 0) {
			i64 iRowid = p->pIter->iRowid;
			if ((bDesc == 0 && iLast>iRowid) || (bDesc && iLast<iRowid)) {
				rc = sqlite3Fts5IterNextFrom(p->pIter, iLast);
			}
		}
	}

	if (rc != SQLITE_OK) {
		*pRc = rc;
		bEof = 1;
	}
	else {
		*piLast = fts5ExprSynonymRowid(pTerm, bDesc, &bEof);
	}
	return bEof;
}


static int fts5ExprNearTest(
	int *pRc,
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode             
) {
	Fts5ExprNearset *pNear = pNode->pNear;
	int rc = *pRc;

	if (pExpr->pConfig->eDetail != FTS5_DETAIL_FULL) {
		Fts5ExprTerm *pTerm;
		Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];
		pPhrase->poslist.n = 0;
		for (pTerm = &pPhrase->aTerm[0]; pTerm; pTerm = pTerm->pSynonym) {
			Fts5IndexIter *pIter = pTerm->pIter;
			if (sqlite3Fts5IterEof(pIter) == 0) {
				if (pIter->iRowid == pNode->iRowid && pIter->nData>0) {
					pPhrase->poslist.n = 1;
				}
			}
		}
		return pPhrase->poslist.n;
	}
	else {
		int i;

		
		for (i = 0; rc == SQLITE_OK && i<pNear->nPhrase; i++) {
			Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
			if (pPhrase->nTerm>1 || pPhrase->aTerm[0].pSynonym || pNear->pColset) {
				int bMatch = 0;
				rc = fts5ExprPhraseIsMatch(pNode, pPhrase, &bMatch);
				if (bMatch == 0) break;
			}
			else {
				Fts5IndexIter *pIter = pPhrase->aTerm[0].pIter;
				fts5BufferSet(&rc, &pPhrase->poslist, pIter->nData, pIter->pData);
			}
		}

		*pRc = rc;
		if (i == pNear->nPhrase && (i == 1 || fts5ExprNearIsMatch(pRc, pNear))) {
			return 1;
		}
		return 0;
	}
}



static int fts5ExprNearInitAll(
	Fts5Expr *pExpr,
	Fts5ExprNode *pNode
) {
	Fts5ExprNearset *pNear = pNode->pNear;
	int i, j;
	int rc = SQLITE_OK;
	int bEof = 1;

	assert(pNode->bNomatch == 0);
	for (i = 0; rc == SQLITE_OK && i<pNear->nPhrase; i++) {
		Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
		for (j = 0; j<pPhrase->nTerm; j++) {
			Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];
			Fts5ExprTerm *p;

			for (p = pTerm; p && rc == SQLITE_OK; p = p->pSynonym) {
				if (p->pIter) {
					sqlite3Fts5IterClose(p->pIter);
					p->pIter = 0;
				}
				rc = sqlite3Fts5IndexQuery(
					pExpr->pIndex, p->zTerm, (int)strlen(p->zTerm),
					(pTerm->bPrefix ? FTS5INDEX_QUERY_PREFIX : 0) |
					(pExpr->bDesc ? FTS5INDEX_QUERY_DESC : 0),
					pNear->pColset,
					&p->pIter
				);
				assert(rc == SQLITE_OK || p->pIter == 0);
				if (p->pIter && 0 == sqlite3Fts5IterEof(p->pIter)) {
					bEof = 0;
				}
			}

			if (bEof) break;
		}
		if (bEof) break;
	}

	pNode->bEof = bEof;
	return rc;
}


static int fts5RowidCmp(
	Fts5Expr *pExpr,
	i64 iLhs,
	i64 iRhs
) {
	assert(pExpr->bDesc == 0 || pExpr->bDesc == 1);
	if (pExpr->bDesc == 0) {
		if (iLhs<iRhs) return -1;
		return (iLhs > iRhs);
	}
	else {
		if (iLhs>iRhs) return -1;
		return (iLhs < iRhs);
	}
}

static void fts5ExprSetEof(Fts5ExprNode *pNode) {
	int i;
	pNode->bEof = 1;
	pNode->bNomatch = 0;
	for (i = 0; i<pNode->nChild; i++) {
		fts5ExprSetEof(pNode->apChild[i]);
	}
}

static void fts5ExprNodeZeroPoslist(Fts5ExprNode *pNode) {
	if (pNode->eType == FTS5_STRING || pNode->eType == FTS5_TERM) {
		Fts5ExprNearset *pNear = pNode->pNear;
		int i;
		for (i = 0; i<pNear->nPhrase; i++) {
			Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
			pPhrase->poslist.n = 0;
		}
	}
	else {
		int i;
		for (i = 0; i<pNode->nChild; i++) {
			fts5ExprNodeZeroPoslist(pNode->apChild[i]);
		}
	}
}




static int fts5NodeCompare(
	Fts5Expr *pExpr,
	Fts5ExprNode *p1,
	Fts5ExprNode *p2
) {
	if (p2->bEof) return -1;
	if (p1->bEof) return +1;
	return fts5RowidCmp(pExpr, p1->iRowid, p2->iRowid);
}


static int fts5ExprNodeTest_STRING(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode
) {
	Fts5ExprNearset *pNear = pNode->pNear;
	Fts5ExprPhrase *pLeft = pNear->apPhrase[0];
	int rc = SQLITE_OK;
	i64 iLast;                      
	int i, j;                       
	int bMatch;                     
	const int bDesc = pExpr->bDesc;

	
	assert(pNear->nPhrase>1
		|| pNear->apPhrase[0]->nTerm>1
		|| pNear->apPhrase[0]->aTerm[0].pSynonym
	);

	
	if (pLeft->aTerm[0].pSynonym) {
		iLast = fts5ExprSynonymRowid(&pLeft->aTerm[0], bDesc, 0);
	}
	else {
		iLast = pLeft->aTerm[0].pIter->iRowid;
	}

	do {
		bMatch = 1;
		for (i = 0; i<pNear->nPhrase; i++) {
			Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
			for (j = 0; j<pPhrase->nTerm; j++) {
				Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];
				if (pTerm->pSynonym) {
					i64 iRowid = fts5ExprSynonymRowid(pTerm, bDesc, 0);
					if (iRowid == iLast) continue;
					bMatch = 0;
					if (fts5ExprSynonymAdvanceto(pTerm, bDesc, &iLast, &rc)) {
						pNode->bNomatch = 0;
						pNode->bEof = 1;
						return rc;
					}
				}
				else {
					Fts5IndexIter *pIter = pPhrase->aTerm[j].pIter;
					if (pIter->iRowid == iLast || pIter->bEof) continue;
					bMatch = 0;
					if (fts5ExprAdvanceto(pIter, bDesc, &iLast, &rc, &pNode->bEof)) {
						return rc;
					}
				}
			}
		}
	} while (bMatch == 0);

	pNode->iRowid = iLast;
	pNode->bNomatch = ((0 == fts5ExprNearTest(&rc, pExpr, pNode)) && rc == SQLITE_OK);
	assert(pNode->bEof == 0 || pNode->bNomatch == 0);

	return rc;
}


static int fts5ExprNodeNext_STRING(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode,            
	int bFromValid,
	i64 iFrom
) {
	Fts5ExprTerm *pTerm = &pNode->pNear->apPhrase[0]->aTerm[0];
	int rc = SQLITE_OK;

	pNode->bNomatch = 0;
	if (pTerm->pSynonym) {
		int bEof = 1;
		Fts5ExprTerm *p;

		
		i64 iRowid = fts5ExprSynonymRowid(pTerm, pExpr->bDesc, 0);

		
		for (p = pTerm; p; p = p->pSynonym) {
			if (sqlite3Fts5IterEof(p->pIter) == 0) {
				i64 ii = p->pIter->iRowid;
				if (ii == iRowid
					|| (bFromValid && ii != iFrom && (ii>iFrom) == pExpr->bDesc)
					) {
					if (bFromValid) {
						rc = sqlite3Fts5IterNextFrom(p->pIter, iFrom);
					}
					else {
						rc = sqlite3Fts5IterNext(p->pIter);
					}
					if (rc != SQLITE_OK) break;
					if (sqlite3Fts5IterEof(p->pIter) == 0) {
						bEof = 0;
					}
				}
				else {
					bEof = 0;
				}
			}
		}

		
		pNode->bEof = (rc || bEof);
	}
	else {
		Fts5IndexIter *pIter = pTerm->pIter;

		assert(Fts5NodeIsString(pNode));
		if (bFromValid) {
			rc = sqlite3Fts5IterNextFrom(pIter, iFrom);
		}
		else {
			rc = sqlite3Fts5IterNext(pIter);
		}

		pNode->bEof = (rc || sqlite3Fts5IterEof(pIter));
	}

	if (pNode->bEof == 0) {
		assert(rc == SQLITE_OK);
		rc = fts5ExprNodeTest_STRING(pExpr, pNode);
	}

	return rc;
}


static int fts5ExprNodeTest_TERM(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode             
) {
	
	Fts5ExprPhrase *pPhrase = pNode->pNear->apPhrase[0];
	Fts5IndexIter *pIter = pPhrase->aTerm[0].pIter;

	assert(pNode->eType == FTS5_TERM);
	assert(pNode->pNear->nPhrase == 1 && pPhrase->nTerm == 1);
	assert(pPhrase->aTerm[0].pSynonym == 0);

	pPhrase->poslist.n = pIter->nData;
	if (pExpr->pConfig->eDetail == FTS5_DETAIL_FULL) {
		pPhrase->poslist.p = (u8*)pIter->pData;
	}
	pNode->iRowid = pIter->iRowid;
	pNode->bNomatch = (pPhrase->poslist.n == 0);
	return SQLITE_OK;
}


static int fts5ExprNodeNext_TERM(
	Fts5Expr *pExpr,
	Fts5ExprNode *pNode,
	int bFromValid,
	i64 iFrom
) {
	int rc;
	Fts5IndexIter *pIter = pNode->pNear->apPhrase[0]->aTerm[0].pIter;

	assert(pNode->bEof == 0);
	if (bFromValid) {
		rc = sqlite3Fts5IterNextFrom(pIter, iFrom);
	}
	else {
		rc = sqlite3Fts5IterNext(pIter);
	}
	if (rc == SQLITE_OK && sqlite3Fts5IterEof(pIter) == 0) {
		rc = fts5ExprNodeTest_TERM(pExpr, pNode);
	}
	else {
		pNode->bEof = 1;
		pNode->bNomatch = 0;
	}
	return rc;
}

static void fts5ExprNodeTest_OR(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode             
) {
	Fts5ExprNode *pNext = pNode->apChild[0];
	int i;

	for (i = 1; i<pNode->nChild; i++) {
		Fts5ExprNode *pChild = pNode->apChild[i];
		int cmp = fts5NodeCompare(pExpr, pNext, pChild);
		if (cmp>0 || (cmp == 0 && pChild->bNomatch == 0)) {
			pNext = pChild;
		}
	}
	pNode->iRowid = pNext->iRowid;
	pNode->bEof = pNext->bEof;
	pNode->bNomatch = pNext->bNomatch;
}

static int fts5ExprNodeNext_OR(
	Fts5Expr *pExpr,
	Fts5ExprNode *pNode,
	int bFromValid,
	i64 iFrom
) {
	int i;
	i64 iLast = pNode->iRowid;

	for (i = 0; i<pNode->nChild; i++) {
		Fts5ExprNode *p1 = pNode->apChild[i];
		assert(p1->bEof || fts5RowidCmp(pExpr, p1->iRowid, iLast) >= 0);
		if (p1->bEof == 0) {
			if ((p1->iRowid == iLast)
				|| (bFromValid && fts5RowidCmp(pExpr, p1->iRowid, iFrom)<0)
				) {
				int rc = fts5ExprNodeNext(pExpr, p1, bFromValid, iFrom);
				if (rc != SQLITE_OK) return rc;
			}
		}
	}

	fts5ExprNodeTest_OR(pExpr, pNode);
	return SQLITE_OK;
}


static int fts5ExprNodeTest_AND(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pAnd              
) {
	int iChild;
	i64 iLast = pAnd->iRowid;
	int rc = SQLITE_OK;
	int bMatch;

	assert(pAnd->bEof == 0);
	do {
		pAnd->bNomatch = 0;
		bMatch = 1;
		for (iChild = 0; iChild<pAnd->nChild; iChild++) {
			Fts5ExprNode *pChild = pAnd->apChild[iChild];
			int cmp = fts5RowidCmp(pExpr, iLast, pChild->iRowid);
			if (cmp>0) {
				
				rc = fts5ExprNodeNext(pExpr, pChild, 1, iLast);
				if (rc != SQLITE_OK) return rc;
			}

			
			assert(pChild->bEof || fts5RowidCmp(pExpr, iLast, pChild->iRowid) <= 0);
			if (pChild->bEof) {
				fts5ExprSetEof(pAnd);
				bMatch = 1;
				break;
			}
			else if (iLast != pChild->iRowid) {
				bMatch = 0;
				iLast = pChild->iRowid;
			}

			if (pChild->bNomatch) {
				pAnd->bNomatch = 1;
			}
		}
	} while (bMatch == 0);

	if (pAnd->bNomatch && pAnd != pExpr->pRoot) {
		fts5ExprNodeZeroPoslist(pAnd);
	}
	pAnd->iRowid = iLast;
	return SQLITE_OK;
}

static int fts5ExprNodeNext_AND(
	Fts5Expr *pExpr,
	Fts5ExprNode *pNode,
	int bFromValid,
	i64 iFrom
) {
	int rc = fts5ExprNodeNext(pExpr, pNode->apChild[0], bFromValid, iFrom);
	if (rc == SQLITE_OK) {
		rc = fts5ExprNodeTest_AND(pExpr, pNode);
	}
	return rc;
}

static int fts5ExprNodeTest_NOT(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode             
) {
	int rc = SQLITE_OK;
	Fts5ExprNode *p1 = pNode->apChild[0];
	Fts5ExprNode *p2 = pNode->apChild[1];
	assert(pNode->nChild == 2);

	while (rc == SQLITE_OK && p1->bEof == 0) {
		int cmp = fts5NodeCompare(pExpr, p1, p2);
		if (cmp>0) {
			rc = fts5ExprNodeNext(pExpr, p2, 1, p1->iRowid);
			cmp = fts5NodeCompare(pExpr, p1, p2);
		}
		assert(rc != SQLITE_OK || cmp <= 0);
		if (cmp || p2->bNomatch) break;
		rc = fts5ExprNodeNext(pExpr, p1, 0, 0);
	}
	pNode->bEof = p1->bEof;
	pNode->bNomatch = p1->bNomatch;
	pNode->iRowid = p1->iRowid;
	if (p1->bEof) {
		fts5ExprNodeZeroPoslist(p2);
	}
	return rc;
}

static int fts5ExprNodeNext_NOT(
	Fts5Expr *pExpr,
	Fts5ExprNode *pNode,
	int bFromValid,
	i64 iFrom
) {
	int rc = fts5ExprNodeNext(pExpr, pNode->apChild[0], bFromValid, iFrom);
	if (rc == SQLITE_OK) {
		rc = fts5ExprNodeTest_NOT(pExpr, pNode);
	}
	return rc;
}


static int fts5ExprNodeTest(
	Fts5Expr *pExpr,                
	Fts5ExprNode *pNode             
) {
	int rc = SQLITE_OK;
	if (pNode->bEof == 0) {
		switch (pNode->eType) {

		case FTS5_STRING: {
			rc = fts5ExprNodeTest_STRING(pExpr, pNode);
			break;
		}

		case FTS5_TERM: {
			rc = fts5ExprNodeTest_TERM(pExpr, pNode);
			break;
		}

		case FTS5_AND: {
			rc = fts5ExprNodeTest_AND(pExpr, pNode);
			break;
		}

		case FTS5_OR: {
			fts5ExprNodeTest_OR(pExpr, pNode);
			break;
		}

		default: assert(pNode->eType == FTS5_NOT); {
			rc = fts5ExprNodeTest_NOT(pExpr, pNode);
			break;
		}
		}
	}
	return rc;
}



static int fts5ExprNodeFirst(Fts5Expr *pExpr, Fts5ExprNode *pNode) {
	int rc = SQLITE_OK;
	pNode->bEof = 0;
	pNode->bNomatch = 0;

	if (Fts5NodeIsString(pNode)) {
		
		rc = fts5ExprNearInitAll(pExpr, pNode);
	}
	else if (pNode->xNext == 0) {
		pNode->bEof = 1;
	}
	else {
		int i;
		int nEof = 0;
		for (i = 0; i<pNode->nChild && rc == SQLITE_OK; i++) {
			Fts5ExprNode *pChild = pNode->apChild[i];
			rc = fts5ExprNodeFirst(pExpr, pNode->apChild[i]);
			assert(pChild->bEof == 0 || pChild->bEof == 1);
			nEof += pChild->bEof;
		}
		pNode->iRowid = pNode->apChild[0]->iRowid;

		switch (pNode->eType) {
		case FTS5_AND:
			if (nEof>0) fts5ExprSetEof(pNode);
			break;

		case FTS5_OR:
			if (pNode->nChild == nEof) fts5ExprSetEof(pNode);
			break;

		default:
			assert(pNode->eType == FTS5_NOT);
			pNode->bEof = pNode->apChild[0]->bEof;
			break;
		}
	}

	if (rc == SQLITE_OK) {
		rc = fts5ExprNodeTest(pExpr, pNode);
	}
	return rc;
}



static int sqlite3Fts5ExprFirst(Fts5Expr *p, Fts5Index *pIdx, i64 iFirst, int bDesc) {
	Fts5ExprNode *pRoot = p->pRoot;
	int rc;                         

	p->pIndex = pIdx;
	p->bDesc = bDesc;
	rc = fts5ExprNodeFirst(p, pRoot);

	
	if (pRoot->bEof == 0 && fts5RowidCmp(p, pRoot->iRowid, iFirst)<0) {
		rc = fts5ExprNodeNext(p, pRoot, 1, iFirst);
	}

	
	while (pRoot->bNomatch) {
		assert(pRoot->bEof == 0 && rc == SQLITE_OK);
		rc = fts5ExprNodeNext(p, pRoot, 0, 0);
	}
	return rc;
}


static int sqlite3Fts5ExprNext(Fts5Expr *p, i64 iLast) {
	int rc;
	Fts5ExprNode *pRoot = p->pRoot;
	assert(pRoot->bEof == 0 && pRoot->bNomatch == 0);
	do {
		rc = fts5ExprNodeNext(p, pRoot, 0, 0);
		assert(pRoot->bNomatch == 0 || (rc == SQLITE_OK && pRoot->bEof == 0));
	} while (pRoot->bNomatch);
	if (fts5RowidCmp(p, pRoot->iRowid, iLast)>0) {
		pRoot->bEof = 1;
	}
	return rc;
}

static int sqlite3Fts5ExprEof(Fts5Expr *p) {
	return p->pRoot->bEof;
}

static i64 sqlite3Fts5ExprRowid(Fts5Expr *p) {
	return p->pRoot->iRowid;
}

static int fts5ParseStringFromToken(Fts5Token *pToken, char **pz) {
	int rc = SQLITE_OK;
	*pz = sqlite3Fts5Strndup(&rc, pToken->p, pToken->n);
	return rc;
}


static void fts5ExprPhraseFree(Fts5ExprPhrase *pPhrase) {
	if (pPhrase) {
		int i;
		for (i = 0; i<pPhrase->nTerm; i++) {
			Fts5ExprTerm *pSyn;
			Fts5ExprTerm *pNext;
			Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];
			sqlite3_free(pTerm->zTerm);
			sqlite3Fts5IterClose(pTerm->pIter);
			for (pSyn = pTerm->pSynonym; pSyn; pSyn = pNext) {
				pNext = pSyn->pSynonym;
				sqlite3Fts5IterClose(pSyn->pIter);
				fts5BufferFree((Fts5Buffer*)&pSyn[1]);
				sqlite3_free(pSyn);
			}
		}
		if (pPhrase->poslist.nSpace>0) fts5BufferFree(&pPhrase->poslist);
		sqlite3_free(pPhrase);
	}
}


static Fts5ExprNearset *sqlite3Fts5ParseNearset(
	Fts5Parse *pParse,              
	Fts5ExprNearset *pNear,         
	Fts5ExprPhrase *pPhrase         
) {
	const int SZALLOC = 8;
	Fts5ExprNearset *pRet = 0;

	if (pParse->rc == SQLITE_OK) {
		if (pPhrase == 0) {
			return pNear;
		}
		if (pNear == 0) {
			int nByte = sizeof(Fts5ExprNearset) + SZALLOC * sizeof(Fts5ExprPhrase*);
			pRet = sqlite3_malloc(nByte);
			if (pRet == 0) {
				pParse->rc = SQLITE_NOMEM;
			}
			else {
				memset(pRet, 0, nByte);
			}
		}
		else if ((pNear->nPhrase % SZALLOC) == 0) {
			int nNew = pNear->nPhrase + SZALLOC;
			int nByte = sizeof(Fts5ExprNearset) + nNew * sizeof(Fts5ExprPhrase*);

			pRet = (Fts5ExprNearset*)sqlite3_realloc(pNear, nByte);
			if (pRet == 0) {
				pParse->rc = SQLITE_NOMEM;
			}
		}
		else {
			pRet = pNear;
		}
	}

	if (pRet == 0) {
		assert(pParse->rc != SQLITE_OK);
		sqlite3Fts5ParseNearsetFree(pNear);
		sqlite3Fts5ParsePhraseFree(pPhrase);
	}
	else {
		if (pRet->nPhrase>0) {
			Fts5ExprPhrase *pLast = pRet->apPhrase[pRet->nPhrase - 1];
			assert(pLast == pParse->apPhrase[pParse->nPhrase - 2]);
			if (pPhrase->nTerm == 0) {
				fts5ExprPhraseFree(pPhrase);
				pRet->nPhrase--;
				pParse->nPhrase--;
				pPhrase = pLast;
			}
			else if (pLast->nTerm == 0) {
				fts5ExprPhraseFree(pLast);
				pParse->apPhrase[pParse->nPhrase - 2] = pPhrase;
				pParse->nPhrase--;
				pRet->nPhrase--;
			}
		}
		pRet->apPhrase[pRet->nPhrase++] = pPhrase;
	}
	return pRet;
}

typedef struct TokenCtx TokenCtx;
struct TokenCtx {
	Fts5ExprPhrase *pPhrase;
	int rc;
};


static int fts5ParseTokenize(
	void *pContext,                 
	int tflags,                     
	const char *pToken,             
	int nToken,                     
	int iUnused1,                   
	int iUnused2                    
) {
	int rc = SQLITE_OK;
	const int SZALLOC = 8;
	TokenCtx *pCtx = (TokenCtx*)pContext;
	Fts5ExprPhrase *pPhrase = pCtx->pPhrase;

	UNUSED_PARAM2(iUnused1, iUnused2);

	
	if (pCtx->rc != SQLITE_OK) return pCtx->rc;
	if (nToken>FTS5_MAX_TOKEN_SIZE) nToken = FTS5_MAX_TOKEN_SIZE;

	if (pPhrase && pPhrase->nTerm>0 && (tflags & FTS5_TOKEN_COLOCATED)) {
		Fts5ExprTerm *pSyn;
		int nByte = sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer) + nToken + 1;
		pSyn = (Fts5ExprTerm*)sqlite3_malloc(nByte);
		if (pSyn == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			memset(pSyn, 0, nByte);
			pSyn->zTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);
			memcpy(pSyn->zTerm, pToken, nToken);
			pSyn->pSynonym = pPhrase->aTerm[pPhrase->nTerm - 1].pSynonym;
			pPhrase->aTerm[pPhrase->nTerm - 1].pSynonym = pSyn;
		}
	}
	else {
		Fts5ExprTerm *pTerm;
		if (pPhrase == 0 || (pPhrase->nTerm % SZALLOC) == 0) {
			Fts5ExprPhrase *pNew;
			int nNew = SZALLOC + (pPhrase ? pPhrase->nTerm : 0);

			pNew = (Fts5ExprPhrase*)sqlite3_realloc(pPhrase,
				sizeof(Fts5ExprPhrase) + sizeof(Fts5ExprTerm) * nNew
			);
			if (pNew == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				if (pPhrase == 0) memset(pNew, 0, sizeof(Fts5ExprPhrase));
				pCtx->pPhrase = pPhrase = pNew;
				pNew->nTerm = nNew - SZALLOC;
			}
		}

		if (rc == SQLITE_OK) {
			pTerm = &pPhrase->aTerm[pPhrase->nTerm++];
			memset(pTerm, 0, sizeof(Fts5ExprTerm));
			pTerm->zTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);
		}
	}

	pCtx->rc = rc;
	return rc;
}



static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase *pPhrase) {
	fts5ExprPhraseFree(pPhrase);
}


static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset *pNear) {
	if (pNear) {
		int i;
		for (i = 0; i<pNear->nPhrase; i++) {
			fts5ExprPhraseFree(pNear->apPhrase[i]);
		}
		sqlite3_free(pNear->pColset);
		sqlite3_free(pNear);
	}
}

static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p) {
	assert(pParse->pExpr == 0);
	pParse->pExpr = p;
}


static Fts5ExprPhrase *sqlite3Fts5ParseTerm(
	Fts5Parse *pParse,              
	Fts5ExprPhrase *pAppend,        
	Fts5Token *pToken,              
	int bPrefix                     
) {
	Fts5Config *pConfig = pParse->pConfig;
	TokenCtx sCtx;                  
	int rc;                         
	char *z = 0;

	memset(&sCtx, 0, sizeof(TokenCtx));
	sCtx.pPhrase = pAppend;

	rc = fts5ParseStringFromToken(pToken, &z);
	if (rc == SQLITE_OK) {
		int flags = FTS5_TOKENIZE_QUERY | (bPrefix ? FTS5_TOKENIZE_QUERY : 0);
		int n;
		sqlite3Fts5Dequote(z);
		n = (int)strlen(z);
		rc = sqlite3Fts5Tokenize(pConfig, flags, z, n, &sCtx, fts5ParseTokenize);
	}
	sqlite3_free(z);
	if (rc || (rc = sCtx.rc)) {
		pParse->rc = rc;
		fts5ExprPhraseFree(sCtx.pPhrase);
		sCtx.pPhrase = 0;
	}
	else {

		if (pAppend == 0) {
			if ((pParse->nPhrase % 8) == 0) {
				int nByte = sizeof(Fts5ExprPhrase*) * (pParse->nPhrase + 8);
				Fts5ExprPhrase **apNew;
				apNew = (Fts5ExprPhrase**)sqlite3_realloc(pParse->apPhrase, nByte);
				if (apNew == 0) {
					pParse->rc = SQLITE_NOMEM;
					fts5ExprPhraseFree(sCtx.pPhrase);
					return 0;
				}
				pParse->apPhrase = apNew;
			}
			pParse->nPhrase++;
		}

		if (sCtx.pPhrase == 0) {
			
			sCtx.pPhrase = sqlite3Fts5MallocZero(&pParse->rc, sizeof(Fts5ExprPhrase));
		}
		else if (sCtx.pPhrase->nTerm) {
			sCtx.pPhrase->aTerm[sCtx.pPhrase->nTerm - 1].bPrefix = bPrefix;
		}
		pParse->apPhrase[pParse->nPhrase - 1] = sCtx.pPhrase;
	}

	return sCtx.pPhrase;
}


static int sqlite3Fts5ExprClonePhrase(
	Fts5Expr *pExpr,
	int iPhrase,
	Fts5Expr **ppNew
) {
	int rc = SQLITE_OK;             
	Fts5ExprPhrase *pOrig;          
	Fts5Expr *pNew = 0;             
	TokenCtx sCtx = { 0,0 };          

	pOrig = pExpr->apExprPhrase[iPhrase];
	pNew = (Fts5Expr*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Expr));
	if (rc == SQLITE_OK) {
		pNew->apExprPhrase = (Fts5ExprPhrase**)sqlite3Fts5MallocZero(&rc,
			sizeof(Fts5ExprPhrase*));
	}
	if (rc == SQLITE_OK) {
		pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&rc,
			sizeof(Fts5ExprNode));
	}
	if (rc == SQLITE_OK) {
		pNew->pRoot->pNear = (Fts5ExprNearset*)sqlite3Fts5MallocZero(&rc,
			sizeof(Fts5ExprNearset) + sizeof(Fts5ExprPhrase*));
	}
	if (rc == SQLITE_OK) {
		Fts5Colset *pColsetOrig = pOrig->pNode->pNear->pColset;
		if (pColsetOrig) {
			int nByte = sizeof(Fts5Colset) + (pColsetOrig->nCol - 1) * sizeof(int);
			Fts5Colset *pColset = (Fts5Colset*)sqlite3Fts5MallocZero(&rc, nByte);
			if (pColset) {
				memcpy(pColset, pColsetOrig, nByte);
			}
			pNew->pRoot->pNear->pColset = pColset;
		}
	}

	if (pOrig->nTerm) {
		int i;                          
		for (i = 0; rc == SQLITE_OK && i<pOrig->nTerm; i++) {
			int tflags = 0;
			Fts5ExprTerm *p;
			for (p = &pOrig->aTerm[i]; p && rc == SQLITE_OK; p = p->pSynonym) {
				const char *zTerm = p->zTerm;
				rc = fts5ParseTokenize((void*)&sCtx, tflags, zTerm, (int)strlen(zTerm),
					0, 0);
				tflags = FTS5_TOKEN_COLOCATED;
			}
			if (rc == SQLITE_OK) {
				sCtx.pPhrase->aTerm[i].bPrefix = pOrig->aTerm[i].bPrefix;
			}
		}
	}
	else {
		
		sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, sizeof(Fts5ExprPhrase));
	}

	if (rc == SQLITE_OK) {
		
		pNew->pIndex = pExpr->pIndex;
		pNew->pConfig = pExpr->pConfig;
		pNew->nPhrase = 1;
		pNew->apExprPhrase[0] = sCtx.pPhrase;
		pNew->pRoot->pNear->apPhrase[0] = sCtx.pPhrase;
		pNew->pRoot->pNear->nPhrase = 1;
		sCtx.pPhrase->pNode = pNew->pRoot;

		if (pOrig->nTerm == 1 && pOrig->aTerm[0].pSynonym == 0) {
			pNew->pRoot->eType = FTS5_TERM;
			pNew->pRoot->xNext = fts5ExprNodeNext_TERM;
		}
		else {
			pNew->pRoot->eType = FTS5_STRING;
			pNew->pRoot->xNext = fts5ExprNodeNext_STRING;
		}
	}
	else {
		sqlite3Fts5ExprFree(pNew);
		fts5ExprPhraseFree(sCtx.pPhrase);
		pNew = 0;
	}

	*ppNew = pNew;
	return rc;
}



static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token *pTok) {
	if (pTok->n != 4 || memcmp("NEAR", pTok->p, 4)) {
		sqlite3Fts5ParseError(
			pParse, "fts5: syntax error near \"%.*s\"", pTok->n, pTok->p
		);
	}
}

static void sqlite3Fts5ParseSetDistance(
	Fts5Parse *pParse,
	Fts5ExprNearset *pNear,
	Fts5Token *p
) {
	if (pNear) {
		int nNear = 0;
		int i;
		if (p->n) {
			for (i = 0; i<p->n; i++) {
				char c = (char)p->p[i];
				if (c<'0' || c>'9') {
					sqlite3Fts5ParseError(
						pParse, "expected integer, got \"%.*s\"", p->n, p->p
					);
					return;
				}
				nNear = nNear * 10 + (p->p[i] - '0');
			}
		}
		else {
			nNear = FTS5_DEFAULT_NEARDIST;
		}
		pNear->nNear = nNear;
	}
}


static Fts5Colset *fts5ParseColset(
	Fts5Parse *pParse,              
	Fts5Colset *p,                  
	int iCol                        
) {
	int nCol = p ? p->nCol : 0;     
	Fts5Colset *pNew;               

	assert(pParse->rc == SQLITE_OK);
	assert(iCol >= 0 && iCol<pParse->pConfig->nCol);

	pNew = sqlite3_realloc(p, sizeof(Fts5Colset) + sizeof(int)*nCol);
	if (pNew == 0) {
		pParse->rc = SQLITE_NOMEM;
	}
	else {
		int *aiCol = pNew->aiCol;
		int i, j;
		for (i = 0; i<nCol; i++) {
			if (aiCol[i] == iCol) return pNew;
			if (aiCol[i]>iCol) break;
		}
		for (j = nCol; j>i; j--) {
			aiCol[j] = aiCol[j - 1];
		}
		aiCol[i] = iCol;
		pNew->nCol = nCol + 1;

#ifndef NDEBUG
		
		for (i = 1; i<pNew->nCol; i++) assert(pNew->aiCol[i]>pNew->aiCol[i - 1]);
#endif
	}

	return pNew;
}


static Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse *pParse, Fts5Colset *p) {
	Fts5Colset *pRet;
	int nCol = pParse->pConfig->nCol;

	pRet = (Fts5Colset*)sqlite3Fts5MallocZero(&pParse->rc,
		sizeof(Fts5Colset) + sizeof(int)*nCol
	);
	if (pRet) {
		int i;
		int iOld = 0;
		for (i = 0; i<nCol; i++) {
			if (iOld >= p->nCol || p->aiCol[iOld] != i) {
				pRet->aiCol[pRet->nCol++] = i;
			}
			else {
				iOld++;
			}
		}
	}

	sqlite3_free(p);
	return pRet;
}

static Fts5Colset *sqlite3Fts5ParseColset(
	Fts5Parse *pParse,              
	Fts5Colset *pColset,            
	Fts5Token *p
) {
	Fts5Colset *pRet = 0;
	int iCol;
	char *z;                        

	z = sqlite3Fts5Strndup(&pParse->rc, p->p, p->n);
	if (pParse->rc == SQLITE_OK) {
		Fts5Config *pConfig = pParse->pConfig;
		sqlite3Fts5Dequote(z);
		for (iCol = 0; iCol<pConfig->nCol; iCol++) {
			if (0 == sqlite3_stricmp(pConfig->azCol[iCol], z)) break;
		}
		if (iCol == pConfig->nCol) {
			sqlite3Fts5ParseError(pParse, "no such column: %s", z);
		}
		else {
			pRet = fts5ParseColset(pParse, pColset, iCol);
		}
		sqlite3_free(z);
	}

	if (pRet == 0) {
		assert(pParse->rc != SQLITE_OK);
		sqlite3_free(pColset);
	}

	return pRet;
}

static void sqlite3Fts5ParseSetColset(
	Fts5Parse *pParse,
	Fts5ExprNearset *pNear,
	Fts5Colset *pColset
) {
	if (pParse->pConfig->eDetail == FTS5_DETAIL_NONE) {
		pParse->rc = SQLITE_ERROR;
		pParse->zErr = sqlite3_mprintf(
			"fts5: column queries are not supported (detail=none)"
		);
		sqlite3_free(pColset);
		return;
	}

	if (pNear) {
		pNear->pColset = pColset;
	}
	else {
		sqlite3_free(pColset);
	}
}

static void fts5ExprAssignXNext(Fts5ExprNode *pNode) {
	switch (pNode->eType) {
	case FTS5_STRING: {
		Fts5ExprNearset *pNear = pNode->pNear;
		if (pNear->nPhrase == 1 && pNear->apPhrase[0]->nTerm == 1
			&& pNear->apPhrase[0]->aTerm[0].pSynonym == 0
			) {
			pNode->eType = FTS5_TERM;
			pNode->xNext = fts5ExprNodeNext_TERM;
		}
		else {
			pNode->xNext = fts5ExprNodeNext_STRING;
		}
		break;
	};

	case FTS5_OR: {
		pNode->xNext = fts5ExprNodeNext_OR;
		break;
	};

	case FTS5_AND: {
		pNode->xNext = fts5ExprNodeNext_AND;
		break;
	};

	default: assert(pNode->eType == FTS5_NOT); {
		pNode->xNext = fts5ExprNodeNext_NOT;
		break;
	};
	}
}

static void fts5ExprAddChildren(Fts5ExprNode *p, Fts5ExprNode *pSub) {
	if (p->eType != FTS5_NOT && pSub->eType == p->eType) {
		int nByte = sizeof(Fts5ExprNode*) * pSub->nChild;
		memcpy(&p->apChild[p->nChild], pSub->apChild, nByte);
		p->nChild += pSub->nChild;
		sqlite3_free(pSub);
	}
	else {
		p->apChild[p->nChild++] = pSub;
	}
}


static Fts5ExprNode *sqlite3Fts5ParseNode(
	Fts5Parse *pParse,              
	int eType,                      
	Fts5ExprNode *pLeft,            
	Fts5ExprNode *pRight,           
	Fts5ExprNearset *pNear          
) {
	Fts5ExprNode *pRet = 0;

	if (pParse->rc == SQLITE_OK) {
		int nChild = 0;               
		int nByte;                    

		assert((eType != FTS5_STRING && !pNear)
			|| (eType == FTS5_STRING && !pLeft && !pRight)
		);
		if (eType == FTS5_STRING && pNear == 0) return 0;
		if (eType != FTS5_STRING && pLeft == 0) return pRight;
		if (eType != FTS5_STRING && pRight == 0) return pLeft;

		if (eType == FTS5_NOT) {
			nChild = 2;
		}
		else if (eType == FTS5_AND || eType == FTS5_OR) {
			nChild = 2;
			if (pLeft->eType == eType) nChild += pLeft->nChild - 1;
			if (pRight->eType == eType) nChild += pRight->nChild - 1;
		}

		nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild - 1);
		pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);

		if (pRet) {
			pRet->eType = eType;
			pRet->pNear = pNear;
			fts5ExprAssignXNext(pRet);
			if (eType == FTS5_STRING) {
				int iPhrase;
				for (iPhrase = 0; iPhrase<pNear->nPhrase; iPhrase++) {
					pNear->apPhrase[iPhrase]->pNode = pRet;
					if (pNear->apPhrase[iPhrase]->nTerm == 0) {
						pRet->xNext = 0;
						pRet->eType = FTS5_EOF;
					}
				}

				if (pParse->pConfig->eDetail != FTS5_DETAIL_FULL
					&& (pNear->nPhrase != 1 || pNear->apPhrase[0]->nTerm>1)
					) {
					assert(pParse->rc == SQLITE_OK);
					pParse->rc = SQLITE_ERROR;
					assert(pParse->zErr == 0);
					pParse->zErr = sqlite3_mprintf(
						"fts5: %s queries are not supported (detail!=full)",
						pNear->nPhrase == 1 ? "phrase" : "NEAR"
					);
					sqlite3_free(pRet);
					pRet = 0;
				}

			}
			else {
				fts5ExprAddChildren(pRet, pLeft);
				fts5ExprAddChildren(pRet, pRight);
			}
		}
	}

	if (pRet == 0) {
		assert(pParse->rc != SQLITE_OK);
		sqlite3Fts5ParseNodeFree(pLeft);
		sqlite3Fts5ParseNodeFree(pRight);
		sqlite3Fts5ParseNearsetFree(pNear);
	}
	return pRet;
}

static Fts5ExprNode *sqlite3Fts5ParseImplicitAnd(
	Fts5Parse *pParse,              
	Fts5ExprNode *pLeft,            
	Fts5ExprNode *pRight            
) {
	Fts5ExprNode *pRet = 0;
	Fts5ExprNode *pPrev;

	if (pParse->rc) {
		sqlite3Fts5ParseNodeFree(pLeft);
		sqlite3Fts5ParseNodeFree(pRight);
	}
	else {

		assert(pLeft->eType == FTS5_STRING
			|| pLeft->eType == FTS5_TERM
			|| pLeft->eType == FTS5_EOF
			|| pLeft->eType == FTS5_AND
		);
		assert(pRight->eType == FTS5_STRING
			|| pRight->eType == FTS5_TERM
			|| pRight->eType == FTS5_EOF
		);

		if (pLeft->eType == FTS5_AND) {
			pPrev = pLeft->apChild[pLeft->nChild - 1];
		}
		else {
			pPrev = pLeft;
		}
		assert(pPrev->eType == FTS5_STRING
			|| pPrev->eType == FTS5_TERM
			|| pPrev->eType == FTS5_EOF
		);

		if (pRight->eType == FTS5_EOF) {
			assert(pParse->apPhrase[pParse->nPhrase - 1] == pRight->pNear->apPhrase[0]);
			sqlite3Fts5ParseNodeFree(pRight);
			pRet = pLeft;
			pParse->nPhrase--;
		}
		else if (pPrev->eType == FTS5_EOF) {
			Fts5ExprPhrase **ap;

			if (pPrev == pLeft) {
				pRet = pRight;
			}
			else {
				pLeft->apChild[pLeft->nChild - 1] = pRight;
				pRet = pLeft;
			}

			ap = &pParse->apPhrase[pParse->nPhrase - 1 - pRight->pNear->nPhrase];
			assert(ap[0] == pPrev->pNear->apPhrase[0]);
			memmove(ap, &ap[1], sizeof(Fts5ExprPhrase*)*pRight->pNear->nPhrase);
			pParse->nPhrase--;

			sqlite3Fts5ParseNodeFree(pPrev);
		}
		else {
			pRet = sqlite3Fts5ParseNode(pParse, FTS5_AND, pLeft, pRight, 0);
		}
	}

	return pRet;
}

static char *fts5ExprTermPrint(Fts5ExprTerm *pTerm) {
	int nByte = 0;
	Fts5ExprTerm *p;
	char *zQuoted;

	
	for (p = pTerm; p; p = p->pSynonym) {
		nByte += (int)strlen(pTerm->zTerm) * 2 + 3 + 2;
	}
	zQuoted = sqlite3_malloc(nByte);

	if (zQuoted) {
		int i = 0;
		for (p = pTerm; p; p = p->pSynonym) {
			char *zIn = p->zTerm;
			zQuoted[i++] = '"';
			while (*zIn) {
				if (*zIn == '"') zQuoted[i++] = '"';
				zQuoted[i++] = *zIn++;
			}
			zQuoted[i++] = '"';
			if (p->pSynonym) zQuoted[i++] = '|';
		}
		if (pTerm->bPrefix) {
			zQuoted[i++] = ' ';
			zQuoted[i++] = '*';
		}
		zQuoted[i++] = '\0';
	}
	return zQuoted;
}

static char *fts5PrintfAppend(char *zApp, const char *zFmt, ...) {
	char *zNew;
	va_list ap;
	va_start(ap, zFmt);
	zNew = sqlite3_vmprintf(zFmt, ap);
	va_end(ap);
	if (zApp && zNew) {
		char *zNew2 = sqlite3_mprintf("%s%s", zApp, zNew);
		sqlite3_free(zNew);
		zNew = zNew2;
	}
	sqlite3_free(zApp);
	return zNew;
}


static char *fts5ExprPrintTcl(
	Fts5Config *pConfig,
	const char *zNearsetCmd,
	Fts5ExprNode *pExpr
) {
	char *zRet = 0;
	if (pExpr->eType == FTS5_STRING || pExpr->eType == FTS5_TERM) {
		Fts5ExprNearset *pNear = pExpr->pNear;
		int i;
		int iTerm;

		zRet = fts5PrintfAppend(zRet, "%s ", zNearsetCmd);
		if (zRet == 0) return 0;
		if (pNear->pColset) {
			int *aiCol = pNear->pColset->aiCol;
			int nCol = pNear->pColset->nCol;
			if (nCol == 1) {
				zRet = fts5PrintfAppend(zRet, "-col %d ", aiCol[0]);
			}
			else {
				zRet = fts5PrintfAppend(zRet, "-col {%d", aiCol[0]);
				for (i = 1; i<pNear->pColset->nCol; i++) {
					zRet = fts5PrintfAppend(zRet, " %d", aiCol[i]);
				}
				zRet = fts5PrintfAppend(zRet, "} ");
			}
			if (zRet == 0) return 0;
		}

		if (pNear->nPhrase>1) {
			zRet = fts5PrintfAppend(zRet, "-near %d ", pNear->nNear);
			if (zRet == 0) return 0;
		}

		zRet = fts5PrintfAppend(zRet, "--");
		if (zRet == 0) return 0;

		for (i = 0; i<pNear->nPhrase; i++) {
			Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];

			zRet = fts5PrintfAppend(zRet, " {");
			for (iTerm = 0; zRet && iTerm<pPhrase->nTerm; iTerm++) {
				char *zTerm = pPhrase->aTerm[iTerm].zTerm;
				zRet = fts5PrintfAppend(zRet, "%s%s", iTerm == 0 ? "" : " ", zTerm);
				if (pPhrase->aTerm[iTerm].bPrefix) {
					zRet = fts5PrintfAppend(zRet, "*");
				}
			}

			if (zRet) zRet = fts5PrintfAppend(zRet, "}");
			if (zRet == 0) return 0;
		}

	}
	else {
		char const *zOp = 0;
		int i;
		switch (pExpr->eType) {
		case FTS5_AND: zOp = "AND"; break;
		case FTS5_NOT: zOp = "NOT"; break;
		default:
			assert(pExpr->eType == FTS5_OR);
			zOp = "OR";
			break;
		}

		zRet = sqlite3_mprintf("%s", zOp);
		for (i = 0; zRet && i<pExpr->nChild; i++) {
			char *z = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->apChild[i]);
			if (!z) {
				sqlite3_free(zRet);
				zRet = 0;
			}
			else {
				zRet = fts5PrintfAppend(zRet, " [%z]", z);
			}
		}
	}

	return zRet;
}

static char *fts5ExprPrint(Fts5Config *pConfig, Fts5ExprNode *pExpr) {
	char *zRet = 0;
	if (pExpr->eType == 0) {
		return sqlite3_mprintf("\"\"");
	}
	else
		if (pExpr->eType == FTS5_STRING || pExpr->eType == FTS5_TERM) {
			Fts5ExprNearset *pNear = pExpr->pNear;
			int i;
			int iTerm;

			if (pNear->pColset) {
				int iCol = pNear->pColset->aiCol[0];
				zRet = fts5PrintfAppend(zRet, "%s : ", pConfig->azCol[iCol]);
				if (zRet == 0) return 0;
			}

			if (pNear->nPhrase>1) {
				zRet = fts5PrintfAppend(zRet, "NEAR(");
				if (zRet == 0) return 0;
			}

			for (i = 0; i<pNear->nPhrase; i++) {
				Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
				if (i != 0) {
					zRet = fts5PrintfAppend(zRet, " ");
					if (zRet == 0) return 0;
				}
				for (iTerm = 0; iTerm<pPhrase->nTerm; iTerm++) {
					char *zTerm = fts5ExprTermPrint(&pPhrase->aTerm[iTerm]);
					if (zTerm) {
						zRet = fts5PrintfAppend(zRet, "%s%s", iTerm == 0 ? "" : " + ", zTerm);
						sqlite3_free(zTerm);
					}
					if (zTerm == 0 || zRet == 0) {
						sqlite3_free(zRet);
						return 0;
					}
				}
			}

			if (pNear->nPhrase>1) {
				zRet = fts5PrintfAppend(zRet, ", %d)", pNear->nNear);
				if (zRet == 0) return 0;
			}

		}
		else {
			char const *zOp = 0;
			int i;

			switch (pExpr->eType) {
			case FTS5_AND: zOp = " AND "; break;
			case FTS5_NOT: zOp = " NOT "; break;
			default:
				assert(pExpr->eType == FTS5_OR);
				zOp = " OR ";
				break;
			}

			for (i = 0; i<pExpr->nChild; i++) {
				char *z = fts5ExprPrint(pConfig, pExpr->apChild[i]);
				if (z == 0) {
					sqlite3_free(zRet);
					zRet = 0;
				}
				else {
					int e = pExpr->apChild[i]->eType;
					int b = (e != FTS5_STRING && e != FTS5_TERM && e != FTS5_EOF);
					zRet = fts5PrintfAppend(zRet, "%s%s%z%s",
						(i == 0 ? "" : zOp),
						(b ? "(" : ""), z, (b ? ")" : "")
					);
				}
				if (zRet == 0) break;
			}
		}

		return zRet;
}


static void fts5ExprFunction(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal,          
	int bTcl
) {
	Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);
	sqlite3 *db = sqlite3_context_db_handle(pCtx);
	const char *zExpr = 0;
	char *zErr = 0;
	Fts5Expr *pExpr = 0;
	int rc;
	int i;

	const char **azConfig;          
	const char *zNearsetCmd = "nearset";
	int nConfig;                    
	Fts5Config *pConfig = 0;
	int iArg = 1;

	if (nArg<1) {
		zErr = sqlite3_mprintf("wrong number of arguments to function %s",
			bTcl ? "fts5_expr_tcl" : "fts5_expr"
		);
		sqlite3_result_error(pCtx, zErr, -1);
		sqlite3_free(zErr);
		return;
	}

	if (bTcl && nArg>1) {
		zNearsetCmd = (const char*)sqlite3_value_text(apVal[1]);
		iArg = 2;
	}

	nConfig = 3 + (nArg - iArg);
	azConfig = (const char**)sqlite3_malloc(sizeof(char*) * nConfig);
	if (azConfig == 0) {
		sqlite3_result_error_nomem(pCtx);
		return;
	}
	azConfig[0] = 0;
	azConfig[1] = "main";
	azConfig[2] = "tbl";
	for (i = 3; iArg<nArg; iArg++) {
		azConfig[i++] = (const char*)sqlite3_value_text(apVal[iArg]);
	}

	zExpr = (const char*)sqlite3_value_text(apVal[0]);

	rc = sqlite3Fts5ConfigParse(pGlobal, db, nConfig, azConfig, &pConfig, &zErr);
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pExpr, &zErr);
	}
	if (rc == SQLITE_OK) {
		char *zText;
		if (pExpr->pRoot->xNext == 0) {
			zText = sqlite3_mprintf("");
		}
		else if (bTcl) {
			zText = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->pRoot);
		}
		else {
			zText = fts5ExprPrint(pConfig, pExpr->pRoot);
		}
		if (zText == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			sqlite3_result_text(pCtx, zText, -1, SQLITE_TRANSIENT);
			sqlite3_free(zText);
		}
	}

	if (rc != SQLITE_OK) {
		if (zErr) {
			sqlite3_result_error(pCtx, zErr, -1);
			sqlite3_free(zErr);
		}
		else {
			sqlite3_result_error_code(pCtx, rc);
		}
	}
	sqlite3_free((void *)azConfig);
	sqlite3Fts5ConfigFree(pConfig);
	sqlite3Fts5ExprFree(pExpr);
}

static void fts5ExprFunctionHr(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	fts5ExprFunction(pCtx, nArg, apVal, 0);
}
static void fts5ExprFunctionTcl(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	fts5ExprFunction(pCtx, nArg, apVal, 1);
}


static void fts5ExprIsAlnum(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	int iCode;
	if (nArg != 1) {
		sqlite3_result_error(pCtx,
			"wrong number of arguments to function fts5_isalnum", -1
		);
		return;
	}
	iCode = sqlite3_value_int(apVal[0]);
	sqlite3_result_int(pCtx, sqlite3Fts5UnicodeIsalnum(iCode));
}

static void fts5ExprFold(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	if (nArg != 1 && nArg != 2) {
		sqlite3_result_error(pCtx,
			"wrong number of arguments to function fts5_fold", -1
		);
	}
	else {
		int iCode;
		int bRemoveDiacritics = 0;
		iCode = sqlite3_value_int(apVal[0]);
		if (nArg == 2) bRemoveDiacritics = sqlite3_value_int(apVal[1]);
		sqlite3_result_int(pCtx, sqlite3Fts5UnicodeFold(iCode, bRemoveDiacritics));
	}
}


static int sqlite3Fts5ExprInit(Fts5Global *pGlobal, sqlite3 *db) {
	struct Fts5ExprFunc {
		const char *z;
		void(*x)(sqlite3_context*, int, sqlite3_value**);
	} aFunc[] = {
		{ "fts5_expr",     fts5ExprFunctionHr },
		{ "fts5_expr_tcl", fts5ExprFunctionTcl },
		{ "fts5_isalnum",  fts5ExprIsAlnum },
		{ "fts5_fold",     fts5ExprFold },
	};
	int i;
	int rc = SQLITE_OK;
	void *pCtx = (void*)pGlobal;

	for (i = 0; rc == SQLITE_OK && i<ArraySize(aFunc); i++) {
		struct Fts5ExprFunc *p = &aFunc[i];
		rc = sqlite3_create_function(db, p->z, -1, SQLITE_UTF8, pCtx, p->x, 0, 0);
	}

	
#ifndef NDEBUG
	(void)sqlite3Fts5ParserTrace;
#endif

	return rc;
}


static int sqlite3Fts5ExprPhraseCount(Fts5Expr *pExpr) {
	return (pExpr ? pExpr->nPhrase : 0);
}


static int sqlite3Fts5ExprPhraseSize(Fts5Expr *pExpr, int iPhrase) {
	if (iPhrase<0 || iPhrase >= pExpr->nPhrase) return 0;
	return pExpr->apExprPhrase[iPhrase]->nTerm;
}


static int sqlite3Fts5ExprPoslist(Fts5Expr *pExpr, int iPhrase, const u8 **pa) {
	int nRet;
	Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];
	Fts5ExprNode *pNode = pPhrase->pNode;
	if (pNode->bEof == 0 && pNode->iRowid == pExpr->pRoot->iRowid) {
		*pa = pPhrase->poslist.p;
		nRet = pPhrase->poslist.n;
	}
	else {
		*pa = 0;
		nRet = 0;
	}
	return nRet;
}

struct Fts5PoslistPopulator {
	Fts5PoslistWriter writer;
	int bOk;                        
	int bMiss;
};

static Fts5PoslistPopulator *sqlite3Fts5ExprClearPoslists(Fts5Expr *pExpr, int bLive) {
	Fts5PoslistPopulator *pRet;
	pRet = sqlite3_malloc(sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);
	if (pRet) {
		int i;
		memset(pRet, 0, sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);
		for (i = 0; i<pExpr->nPhrase; i++) {
			Fts5Buffer *pBuf = &pExpr->apExprPhrase[i]->poslist;
			Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;
			assert(pExpr->apExprPhrase[i]->nTerm == 1);
			if (bLive &&
				(pBuf->n == 0 || pNode->iRowid != pExpr->pRoot->iRowid || pNode->bEof)
				) {
				pRet[i].bMiss = 1;
			}
			else {
				pBuf->n = 0;
			}
		}
	}
	return pRet;
}

struct Fts5ExprCtx {
	Fts5Expr *pExpr;
	Fts5PoslistPopulator *aPopulator;
	i64 iOff;
};
typedef struct Fts5ExprCtx Fts5ExprCtx;


static int fts5ExprColsetTest(Fts5Colset *pColset, int iCol) {
	int i;
	for (i = 0; i<pColset->nCol; i++) {
		if (pColset->aiCol[i] == iCol) return 1;
	}
	return 0;
}

static int fts5ExprPopulatePoslistsCb(
	void *pCtx,                
	int tflags,                
	const char *pToken,        
	int nToken,                
	int iUnused1,              
	int iUnused2               
) {
	Fts5ExprCtx *p = (Fts5ExprCtx*)pCtx;
	Fts5Expr *pExpr = p->pExpr;
	int i;

	UNUSED_PARAM2(iUnused1, iUnused2);

	if (nToken>FTS5_MAX_TOKEN_SIZE) nToken = FTS5_MAX_TOKEN_SIZE;
	if ((tflags & FTS5_TOKEN_COLOCATED) == 0) p->iOff++;
	for (i = 0; i<pExpr->nPhrase; i++) {
		Fts5ExprTerm *pTerm;
		if (p->aPopulator[i].bOk == 0) continue;
		for (pTerm = &pExpr->apExprPhrase[i]->aTerm[0]; pTerm; pTerm = pTerm->pSynonym) {
			int nTerm = (int)strlen(pTerm->zTerm);
			if ((nTerm == nToken || (nTerm<nToken && pTerm->bPrefix))
				&& memcmp(pTerm->zTerm, pToken, nTerm) == 0
				) {
				int rc = sqlite3Fts5PoslistWriterAppend(
					&pExpr->apExprPhrase[i]->poslist, &p->aPopulator[i].writer, p->iOff
				);
				if (rc) return rc;
				break;
			}
		}
	}
	return SQLITE_OK;
}

static int sqlite3Fts5ExprPopulatePoslists(
	Fts5Config *pConfig,
	Fts5Expr *pExpr,
	Fts5PoslistPopulator *aPopulator,
	int iCol,
	const char *z, int n
) {
	int i;
	Fts5ExprCtx sCtx;
	sCtx.pExpr = pExpr;
	sCtx.aPopulator = aPopulator;
	sCtx.iOff = (((i64)iCol) << 32) - 1;

	for (i = 0; i<pExpr->nPhrase; i++) {
		Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;
		Fts5Colset *pColset = pNode->pNear->pColset;
		if ((pColset && 0 == fts5ExprColsetTest(pColset, iCol))
			|| aPopulator[i].bMiss
			) {
			aPopulator[i].bOk = 0;
		}
		else {
			aPopulator[i].bOk = 1;
		}
	}

	return sqlite3Fts5Tokenize(pConfig,
		FTS5_TOKENIZE_DOCUMENT, z, n, (void*)&sCtx, fts5ExprPopulatePoslistsCb
	);
}

static void fts5ExprClearPoslists(Fts5ExprNode *pNode) {
	if (pNode->eType == FTS5_TERM || pNode->eType == FTS5_STRING) {
		pNode->pNear->apPhrase[0]->poslist.n = 0;
	}
	else {
		int i;
		for (i = 0; i<pNode->nChild; i++) {
			fts5ExprClearPoslists(pNode->apChild[i]);
		}
	}
}

static int fts5ExprCheckPoslists(Fts5ExprNode *pNode, i64 iRowid) {
	pNode->iRowid = iRowid;
	pNode->bEof = 0;
	switch (pNode->eType) {
	case FTS5_TERM:
	case FTS5_STRING:
		return (pNode->pNear->apPhrase[0]->poslist.n>0);

	case FTS5_AND: {
		int i;
		for (i = 0; i<pNode->nChild; i++) {
			if (fts5ExprCheckPoslists(pNode->apChild[i], iRowid) == 0) {
				fts5ExprClearPoslists(pNode);
				return 0;
			}
		}
		break;
	}

	case FTS5_OR: {
		int i;
		int bRet = 0;
		for (i = 0; i<pNode->nChild; i++) {
			if (fts5ExprCheckPoslists(pNode->apChild[i], iRowid)) {
				bRet = 1;
			}
		}
		return bRet;
	}

	default: {
		assert(pNode->eType == FTS5_NOT);
		if (0 == fts5ExprCheckPoslists(pNode->apChild[0], iRowid)
			|| 0 != fts5ExprCheckPoslists(pNode->apChild[1], iRowid)
			) {
			fts5ExprClearPoslists(pNode);
			return 0;
		}
		break;
	}
	}
	return 1;
}

static void sqlite3Fts5ExprCheckPoslists(Fts5Expr *pExpr, i64 iRowid) {
	fts5ExprCheckPoslists(pExpr->pRoot, iRowid);
}


static int sqlite3Fts5ExprPhraseCollist(
	Fts5Expr *pExpr,
	int iPhrase,
	const u8 **ppCollist,
	int *pnCollist
) {
	Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];
	Fts5ExprNode *pNode = pPhrase->pNode;
	int rc = SQLITE_OK;

	assert(iPhrase >= 0 && iPhrase<pExpr->nPhrase);
	assert(pExpr->pConfig->eDetail == FTS5_DETAIL_COLUMNS);

	if (pNode->bEof == 0
		&& pNode->iRowid == pExpr->pRoot->iRowid
		&& pPhrase->poslist.n>0
		) {
		Fts5ExprTerm *pTerm = &pPhrase->aTerm[0];
		if (pTerm->pSynonym) {
			Fts5Buffer *pBuf = (Fts5Buffer*)&pTerm->pSynonym[1];
			rc = fts5ExprSynonymList(
				pTerm, pNode->iRowid, pBuf, (u8**)ppCollist, pnCollist
			);
		}
		else {
			*ppCollist = pPhrase->aTerm[0].pIter->pData;
			*pnCollist = pPhrase->aTerm[0].pIter->nData;
		}
	}
	else {
		*ppCollist = 0;
		*pnCollist = 0;
	}

	return rc;
}








typedef struct Fts5HashEntry Fts5HashEntry;




struct Fts5Hash {
	int eDetail;                    
	int *pnByte;                    
	int nEntry;                     
	int nSlot;                      
	Fts5HashEntry *pScan;           
	Fts5HashEntry **aSlot;          
};


struct Fts5HashEntry {
	Fts5HashEntry *pHashNext;       
	Fts5HashEntry *pScanNext;       

	int nAlloc;                     
	int iSzPoslist;                 
	int nData;                      
	int nKey;                       
	u8 bDel;                        
	u8 bContent;                    
	i16 iCol;                       
	int iPos;                       
	i64 iRowid;                     
	char zKey[8];                   
};


#define FTS5_HASHENTRYSIZE (sizeof(Fts5HashEntry)-8)




static int sqlite3Fts5HashNew(Fts5Config *pConfig, Fts5Hash **ppNew, int *pnByte) {
	int rc = SQLITE_OK;
	Fts5Hash *pNew;

	*ppNew = pNew = (Fts5Hash*)sqlite3_malloc(sizeof(Fts5Hash));
	if (pNew == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		int nByte;
		memset(pNew, 0, sizeof(Fts5Hash));
		pNew->pnByte = pnByte;
		pNew->eDetail = pConfig->eDetail;

		pNew->nSlot = 1024;
		nByte = sizeof(Fts5HashEntry*) * pNew->nSlot;
		pNew->aSlot = (Fts5HashEntry**)sqlite3_malloc(nByte);
		if (pNew->aSlot == 0) {
			sqlite3_free(pNew);
			*ppNew = 0;
			rc = SQLITE_NOMEM;
		}
		else {
			memset(pNew->aSlot, 0, nByte);
		}
	}
	return rc;
}


static void sqlite3Fts5HashFree(Fts5Hash *pHash) {
	if (pHash) {
		sqlite3Fts5HashClear(pHash);
		sqlite3_free(pHash->aSlot);
		sqlite3_free(pHash);
	}
}


static void sqlite3Fts5HashClear(Fts5Hash *pHash) {
	int i;
	for (i = 0; i<pHash->nSlot; i++) {
		Fts5HashEntry *pNext;
		Fts5HashEntry *pSlot;
		for (pSlot = pHash->aSlot[i]; pSlot; pSlot = pNext) {
			pNext = pSlot->pHashNext;
			sqlite3_free(pSlot);
		}
	}
	memset(pHash->aSlot, 0, pHash->nSlot * sizeof(Fts5HashEntry*));
	pHash->nEntry = 0;
}

static unsigned int fts5HashKey(int nSlot, const u8 *p, int n) {
	int i;
	unsigned int h = 13;
	for (i = n - 1; i >= 0; i--) {
		h = (h << 3) ^ h ^ p[i];
	}
	return (h % nSlot);
}

static unsigned int fts5HashKey2(int nSlot, u8 b, const u8 *p, int n) {
	int i;
	unsigned int h = 13;
	for (i = n - 1; i >= 0; i--) {
		h = (h << 3) ^ h ^ p[i];
	}
	h = (h << 3) ^ h ^ b;
	return (h % nSlot);
}


static int fts5HashResize(Fts5Hash *pHash) {
	int nNew = pHash->nSlot * 2;
	int i;
	Fts5HashEntry **apNew;
	Fts5HashEntry **apOld = pHash->aSlot;

	apNew = (Fts5HashEntry**)sqlite3_malloc(nNew * sizeof(Fts5HashEntry*));
	if (!apNew) return SQLITE_NOMEM;
	memset(apNew, 0, nNew * sizeof(Fts5HashEntry*));

	for (i = 0; i<pHash->nSlot; i++) {
		while (apOld[i]) {
			int iHash;
			Fts5HashEntry *p = apOld[i];
			apOld[i] = p->pHashNext;
			iHash = fts5HashKey(nNew, (u8*)p->zKey, (int)strlen(p->zKey));
			p->pHashNext = apNew[iHash];
			apNew[iHash] = p;
		}
	}

	sqlite3_free(apOld);
	pHash->nSlot = nNew;
	pHash->aSlot = apNew;
	return SQLITE_OK;
}

static void fts5HashAddPoslistSize(Fts5Hash *pHash, Fts5HashEntry *p) {
	if (p->iSzPoslist) {
		u8 *pPtr = (u8*)p;
		if (pHash->eDetail == FTS5_DETAIL_NONE) {
			assert(p->nData == p->iSzPoslist);
			if (p->bDel) {
				pPtr[p->nData++] = 0x00;
				if (p->bContent) {
					pPtr[p->nData++] = 0x00;
				}
			}
		}
		else {
			int nSz = (p->nData - p->iSzPoslist - 1);       
			int nPos = nSz * 2 + p->bDel;                     

			assert(p->bDel == 0 || p->bDel == 1);
			if (nPos <= 127) {
				pPtr[p->iSzPoslist] = (u8)nPos;
			}
			else {
				int nByte = sqlite3Fts5GetVarintLen((u32)nPos);
				memmove(&pPtr[p->iSzPoslist + nByte], &pPtr[p->iSzPoslist + 1], nSz);
				sqlite3Fts5PutVarint(&pPtr[p->iSzPoslist], nPos);
				p->nData += (nByte - 1);
			}
		}

		p->iSzPoslist = 0;
		p->bDel = 0;
		p->bContent = 0;
	}
}


static int sqlite3Fts5HashWrite(
	Fts5Hash *pHash,
	i64 iRowid,                     
	int iCol,                       
	int iPos,                       
	char bByte,                     
	const char *pToken, int nToken  
) {
	unsigned int iHash;
	Fts5HashEntry *p;
	u8 *pPtr;
	int nIncr = 0;                  
	int bNew;                       

	bNew = (pHash->eDetail == FTS5_DETAIL_FULL);

	
	iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);
	for (p = pHash->aSlot[iHash]; p; p = p->pHashNext) {
		if (p->zKey[0] == bByte
			&& p->nKey == nToken
			&& memcmp(&p->zKey[1], pToken, nToken) == 0
			) {
			break;
		}
	}

	
	if (p == 0) {
		
		int nByte = FTS5_HASHENTRYSIZE + (nToken + 1) + 1 + 64;
		if (nByte<128) nByte = 128;

		
		if ((pHash->nEntry * 2) >= pHash->nSlot) {
			int rc = fts5HashResize(pHash);
			if (rc != SQLITE_OK) return rc;
			iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);
		}

		
		p = (Fts5HashEntry*)sqlite3_malloc(nByte);
		if (!p) return SQLITE_NOMEM;
		memset(p, 0, FTS5_HASHENTRYSIZE);
		p->nAlloc = nByte;
		p->zKey[0] = bByte;
		memcpy(&p->zKey[1], pToken, nToken);
		assert(iHash == fts5HashKey(pHash->nSlot, (u8*)p->zKey, nToken + 1));
		p->nKey = nToken;
		p->zKey[nToken + 1] = '\0';
		p->nData = nToken + 1 + 1 + FTS5_HASHENTRYSIZE;
		p->pHashNext = pHash->aSlot[iHash];
		pHash->aSlot[iHash] = p;
		pHash->nEntry++;

		
		p->nData += sqlite3Fts5PutVarint(&((u8*)p)[p->nData], iRowid);
		p->iRowid = iRowid;

		p->iSzPoslist = p->nData;
		if (pHash->eDetail != FTS5_DETAIL_NONE) {
			p->nData += 1;
			p->iCol = (pHash->eDetail == FTS5_DETAIL_FULL ? 0 : -1);
		}

		nIncr += p->nData;
	}
	else {

		
		if ((p->nAlloc - p->nData) < (9 + 4 + 1 + 3 + 5)) {
			int nNew = p->nAlloc * 2;
			Fts5HashEntry *pNew;
			Fts5HashEntry **pp;
			pNew = (Fts5HashEntry*)sqlite3_realloc(p, nNew);
			if (pNew == 0) return SQLITE_NOMEM;
			pNew->nAlloc = nNew;
			for (pp = &pHash->aSlot[iHash]; *pp != p; pp = &(*pp)->pHashNext);
			*pp = pNew;
			p = pNew;
		}
		nIncr -= p->nData;
	}
	assert((p->nAlloc - p->nData) >= (9 + 4 + 1 + 3 + 5));

	pPtr = (u8*)p;

	
	if (iRowid != p->iRowid) {
		fts5HashAddPoslistSize(pHash, p);
		p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iRowid - p->iRowid);
		p->iRowid = iRowid;
		bNew = 1;
		p->iSzPoslist = p->nData;
		if (pHash->eDetail != FTS5_DETAIL_NONE) {
			p->nData += 1;
			p->iCol = (pHash->eDetail == FTS5_DETAIL_FULL ? 0 : -1);
			p->iPos = 0;
		}
	}

	if (iCol >= 0) {
		if (pHash->eDetail == FTS5_DETAIL_NONE) {
			p->bContent = 1;
		}
		else {
			
			assert(iCol >= p->iCol);
			if (iCol != p->iCol) {
				if (pHash->eDetail == FTS5_DETAIL_FULL) {
					pPtr[p->nData++] = 0x01;
					p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iCol);
					p->iCol = (i16)iCol;
					p->iPos = 0;
				}
				else {
					bNew = 1;
					p->iCol = (i16)(iPos = iCol);
				}
			}

			
			if (bNew) {
				p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iPos - p->iPos + 2);
				p->iPos = iPos;
			}
		}
	}
	else {
		
		p->bDel = 1;
	}

	nIncr += p->nData;
	*pHash->pnByte += nIncr;
	return SQLITE_OK;
}



static Fts5HashEntry *fts5HashEntryMerge(
	Fts5HashEntry *pLeft,
	Fts5HashEntry *pRight
) {
	Fts5HashEntry *p1 = pLeft;
	Fts5HashEntry *p2 = pRight;
	Fts5HashEntry *pRet = 0;
	Fts5HashEntry **ppOut = &pRet;

	while (p1 || p2) {
		if (p1 == 0) {
			*ppOut = p2;
			p2 = 0;
		}
		else if (p2 == 0) {
			*ppOut = p1;
			p1 = 0;
		}
		else {
			int i = 0;
			while (p1->zKey[i] == p2->zKey[i]) i++;

			if (((u8)p1->zKey[i])>((u8)p2->zKey[i])) {
				
				*ppOut = p2;
				ppOut = &p2->pScanNext;
				p2 = p2->pScanNext;
			}
			else {
				
				*ppOut = p1;
				ppOut = &p1->pScanNext;
				p1 = p1->pScanNext;
			}
			*ppOut = 0;
		}
	}

	return pRet;
}


static int fts5HashEntrySort(
	Fts5Hash *pHash,
	const char *pTerm, int nTerm,   
	Fts5HashEntry **ppSorted
) {
	const int nMergeSlot = 32;
	Fts5HashEntry **ap;
	Fts5HashEntry *pList;
	int iSlot;
	int i;

	*ppSorted = 0;
	ap = sqlite3_malloc(sizeof(Fts5HashEntry*) * nMergeSlot);
	if (!ap) return SQLITE_NOMEM;
	memset(ap, 0, sizeof(Fts5HashEntry*) * nMergeSlot);

	for (iSlot = 0; iSlot<pHash->nSlot; iSlot++) {
		Fts5HashEntry *pIter;
		for (pIter = pHash->aSlot[iSlot]; pIter; pIter = pIter->pHashNext) {
			if (pTerm == 0 || 0 == memcmp(pIter->zKey, pTerm, nTerm)) {
				Fts5HashEntry *pEntry = pIter;
				pEntry->pScanNext = 0;
				for (i = 0; ap[i]; i++) {
					pEntry = fts5HashEntryMerge(pEntry, ap[i]);
					ap[i] = 0;
				}
				ap[i] = pEntry;
			}
		}
	}

	pList = 0;
	for (i = 0; i<nMergeSlot; i++) {
		pList = fts5HashEntryMerge(pList, ap[i]);
	}

	pHash->nEntry = 0;
	sqlite3_free(ap);
	*ppSorted = pList;
	return SQLITE_OK;
}


static int sqlite3Fts5HashQuery(
	Fts5Hash *pHash,                
	const char *pTerm, int nTerm,   
	const u8 **ppDoclist,           
	int *pnDoclist                  
) {
	unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);
	Fts5HashEntry *p;

	for (p = pHash->aSlot[iHash]; p; p = p->pHashNext) {
		if (memcmp(p->zKey, pTerm, nTerm) == 0 && p->zKey[nTerm] == 0) break;
	}

	if (p) {
		fts5HashAddPoslistSize(pHash, p);
		*ppDoclist = (const u8*)&p->zKey[nTerm + 1];
		*pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
	}
	else {
		*ppDoclist = 0;
		*pnDoclist = 0;
	}

	return SQLITE_OK;
}

static int sqlite3Fts5HashScanInit(
	Fts5Hash *p,                    
	const char *pTerm, int nTerm    
) {
	return fts5HashEntrySort(p, pTerm, nTerm, &p->pScan);
}

static void sqlite3Fts5HashScanNext(Fts5Hash *p) {
	assert(!sqlite3Fts5HashScanEof(p));
	p->pScan = p->pScan->pScanNext;
}

static int sqlite3Fts5HashScanEof(Fts5Hash *p) {
	return (p->pScan == 0);
}

static void sqlite3Fts5HashScanEntry(
	Fts5Hash *pHash,
	const char **pzTerm,            
	const u8 **ppDoclist,           
	int *pnDoclist                  
) {
	Fts5HashEntry *p;
	if ((p = pHash->pScan)) {
		int nTerm = (int)strlen(p->zKey);
		fts5HashAddPoslistSize(pHash, p);
		*pzTerm = p->zKey;
		*ppDoclist = (const u8*)&p->zKey[nTerm + 1];
		*pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
	}
	else {
		*pzTerm = 0;
		*ppDoclist = 0;
		*pnDoclist = 0;
	}
}










#define FTS5_OPT_WORK_UNIT  1000  
#define FTS5_WORK_UNIT      64    

#define FTS5_MIN_DLIDX_SIZE 4     

#define FTS5_MAIN_PREFIX '0'

#if FTS5_MAX_PREFIX_INDEXES > 31
# error "FTS5_MAX_PREFIX_INDEXES is too large"
#endif




#define FTS5_AVERAGES_ROWID     1    
#define FTS5_STRUCTURE_ROWID   10    


#define FTS5_DATA_ID_B     16     
#define FTS5_DATA_DLI_B     1     
#define FTS5_DATA_HEIGHT_B  5     
#define FTS5_DATA_PAGE_B   31     

#define fts5_dri(segid, dlidx, height, pgno) (                                 \
 ((i64)(segid)  << (FTS5_DATA_PAGE_B+FTS5_DATA_HEIGHT_B+FTS5_DATA_DLI_B)) +    \
 ((i64)(dlidx)  << (FTS5_DATA_PAGE_B + FTS5_DATA_HEIGHT_B)) +                  \
 ((i64)(height) << (FTS5_DATA_PAGE_B)) +                                       \
 ((i64)(pgno))                                                                 \
)

#define FTS5_SEGMENT_ROWID(segid, pgno)       fts5_dri(segid, 0, 0, pgno)
#define FTS5_DLIDX_ROWID(segid, height, pgno) fts5_dri(segid, 1, height, pgno)


#define FTS5_MAX_SEGMENT 2000

#ifdef SQLITE_DEBUG
static int sqlite3Fts5Corrupt() { return SQLITE_CORRUPT_VTAB; }
#endif



#define FTS5_DATA_ZERO_PADDING 8
#define FTS5_DATA_PADDING 20

typedef struct Fts5Data Fts5Data;
typedef struct Fts5DlidxIter Fts5DlidxIter;
typedef struct Fts5DlidxLvl Fts5DlidxLvl;
typedef struct Fts5DlidxWriter Fts5DlidxWriter;
typedef struct Fts5Iter Fts5Iter;
typedef struct Fts5PageWriter Fts5PageWriter;
typedef struct Fts5SegIter Fts5SegIter;
typedef struct Fts5DoclistIter Fts5DoclistIter;
typedef struct Fts5SegWriter Fts5SegWriter;
typedef struct Fts5Structure Fts5Structure;
typedef struct Fts5StructureLevel Fts5StructureLevel;
typedef struct Fts5StructureSegment Fts5StructureSegment;

struct Fts5Data {
	u8 *p;                          
	int nn;                         
	int szLeaf;                     
};


struct Fts5Index {
	Fts5Config *pConfig;            
	char *zDataTbl;                 
	int nWorkUnit;                  

									
	Fts5Hash *pHash;                
	int nPendingData;               
	i64 iWriteRowid;                
	int bDelete;                    

									
	int rc;                         

									
	sqlite3_blob *pReader;          
	sqlite3_stmt *pWriter;          
	sqlite3_stmt *pDeleter;         
	sqlite3_stmt *pIdxWriter;       
	sqlite3_stmt *pIdxDeleter;      
	sqlite3_stmt *pIdxSelect;
	int nRead;                      

	sqlite3_stmt *pDataVersion;
	i64 iStructVersion;             
	Fts5Structure *pStruct;         
};

struct Fts5DoclistIter {
	u8 *aEof;                       

									
	i64 iRowid;
	u8 *aPoslist;
	int nPoslist;
	int nSize;
};


struct Fts5StructureSegment {
	int iSegid;                     
	int pgnoFirst;                  
	int pgnoLast;                   
};
struct Fts5StructureLevel {
	int nMerge;                     
	int nSeg;                       
	Fts5StructureSegment *aSeg;     
};
struct Fts5Structure {
	int nRef;                       
	u64 nWriteCounter;              
	int nSegment;                   
	int nLevel;                     
	Fts5StructureLevel aLevel[1];   
};


struct Fts5PageWriter {
	int pgno;                       
	int iPrevPgidx;                 
	Fts5Buffer buf;                 
	Fts5Buffer pgidx;               
	Fts5Buffer term;                
};
struct Fts5DlidxWriter {
	int pgno;                       
	int bPrevValid;                 
	i64 iPrev;                      
	Fts5Buffer buf;                 
};
struct Fts5SegWriter {
	int iSegid;                     
	Fts5PageWriter writer;          
	i64 iPrevRowid;                 
	u8 bFirstRowidInDoclist;        
	u8 bFirstRowidInPage;           
									
	u8 bFirstTermInPage;            
	int nLeafWritten;               
	int nEmpty;                     

	int nDlidx;                     
	Fts5DlidxWriter *aDlidx;        

									
	Fts5Buffer btterm;              
	int iBtPage;                    
};

typedef struct Fts5CResult Fts5CResult;
struct Fts5CResult {
	u16 iFirst;                     
	u8 bTermEq;                     
};


struct Fts5SegIter {
	Fts5StructureSegment *pSeg;     
	int flags;                      
	int iLeafPgno;                  
	Fts5Data *pLeaf;                
	Fts5Data *pNextLeaf;            
	int iLeafOffset;                

									
	void(*xNext)(Fts5Index*, Fts5SegIter*, int*);

	
	int iTermLeafPgno;
	int iTermLeafOffset;

	int iPgidxOff;                  
	int iEndofDoclist;

	
	int iRowidOffset;               
	int nRowidOffset;               
	int *aRowidOffset;              

	Fts5DlidxIter *pDlidx;          

									
	Fts5Buffer term;                
	i64 iRowid;                     
	int nPos;                       
	u8 bDel;                        
};


#define ASSERT_SZLEAF_OK(x) assert( \
    (x)->szLeaf==(x)->nn || (x)->szLeaf==fts5GetU16(&(x)->p[2]) \
)

#define FTS5_SEGITER_ONETERM 0x01
#define FTS5_SEGITER_REVERSE 0x02


#define fts5LeafIsTermless(x) ((x)->szLeaf >= (x)->nn)

#define fts5LeafTermOff(x, i) (fts5GetU16(&(x)->p[(x)->szLeaf + (i)*2]))

#define fts5LeafFirstRowidOff(x) (fts5GetU16((x)->p))


struct Fts5Iter {
	Fts5IndexIter base;             

	Fts5Index *pIndex;              
	Fts5Structure *pStruct;         
	Fts5Buffer poslist;             
	Fts5Colset *pColset;            

									
	void(*xSetOutputs)(Fts5Iter*, Fts5SegIter*);

	int nSeg;                       
	int bRev;                       
	u8 bSkipEmpty;                  

	i64 iSwitchRowid;               
	Fts5CResult *aFirst;            
	Fts5SegIter aSeg[1];            
};



struct Fts5DlidxLvl {
	Fts5Data *pData;              
	int iOff;                     
	int bEof;                     
	int iFirstOff;                

								  
	int iLeafPgno;                
	i64 iRowid;                   
};
struct Fts5DlidxIter {
	int nLvl;
	int iSegid;
	Fts5DlidxLvl aLvl[1];
};

static void fts5PutU16(u8 *aOut, u16 iVal) {
	aOut[0] = (iVal >> 8);
	aOut[1] = (iVal & 0xFF);
}

static u16 fts5GetU16(const u8 *aIn) {
	return ((u16)aIn[0] << 8) + aIn[1];
}


static void *fts5IdxMalloc(Fts5Index *p, int nByte) {
	return sqlite3Fts5MallocZero(&p->rc, nByte);
}


#ifdef SQLITE_DEBUG
static int fts5BufferCompareBlob(
	Fts5Buffer *pLeft,              
	const u8 *pRight, int nRight    
) {
	int nCmp = MIN(pLeft->n, nRight);
	int res = memcmp(pLeft->p, pRight, nCmp);
	return (res == 0 ? (pLeft->n - nRight) : res);
}
#endif


static int fts5BufferCompare(Fts5Buffer *pLeft, Fts5Buffer *pRight) {
	int nCmp = MIN(pLeft->n, pRight->n);
	int res = memcmp(pLeft->p, pRight->p, nCmp);
	return (res == 0 ? (pLeft->n - pRight->n) : res);
}

static int fts5LeafFirstTermOff(Fts5Data *pLeaf) {
	int ret;
	fts5GetVarint32(&pLeaf->p[pLeaf->szLeaf], ret);
	return ret;
}


static void fts5CloseReader(Fts5Index *p) {
	if (p->pReader) {
		sqlite3_blob *pReader = p->pReader;
		p->pReader = 0;
		sqlite3_blob_close(pReader);
	}
}



static Fts5Data *fts5DataRead(Fts5Index *p, i64 iRowid) {
	Fts5Data *pRet = 0;
	if (p->rc == SQLITE_OK) {
		int rc = SQLITE_OK;

		if (p->pReader) {
			
			sqlite3_blob *pBlob = p->pReader;
			p->pReader = 0;
			rc = sqlite3_blob_reopen(pBlob, iRowid);
			assert(p->pReader == 0);
			p->pReader = pBlob;
			if (rc != SQLITE_OK) {
				fts5CloseReader(p);
			}
			if (rc == SQLITE_ABORT) rc = SQLITE_OK;
		}

		
		if (p->pReader == 0 && rc == SQLITE_OK) {
			Fts5Config *pConfig = p->pConfig;
			rc = sqlite3_blob_open(pConfig->db,
				pConfig->zDb, p->zDataTbl, "block", iRowid, 0, &p->pReader
			);
		}

		
		if (rc == SQLITE_ERROR) rc = FTS5_CORRUPT;

		if (rc == SQLITE_OK) {
			u8 *aOut = 0;               
			int nByte = sqlite3_blob_bytes(p->pReader);
			int nAlloc = sizeof(Fts5Data) + nByte + FTS5_DATA_PADDING;
			pRet = (Fts5Data*)sqlite3_malloc(nAlloc);
			if (pRet) {
				pRet->nn = nByte;
				aOut = pRet->p = (u8*)&pRet[1];
			}
			else {
				rc = SQLITE_NOMEM;
			}

			if (rc == SQLITE_OK) {
				rc = sqlite3_blob_read(p->pReader, aOut, nByte, 0);
			}
			if (rc != SQLITE_OK) {
				sqlite3_free(pRet);
				pRet = 0;
			}
			else {
				
				pRet->szLeaf = fts5GetU16(&pRet->p[2]);
			}
		}
		p->rc = rc;
		p->nRead++;
	}

	assert((pRet == 0) == (p->rc != SQLITE_OK));
	return pRet;
}


static void fts5DataRelease(Fts5Data *pData) {
	sqlite3_free(pData);
}

static Fts5Data *fts5LeafRead(Fts5Index *p, i64 iRowid) {
	Fts5Data *pRet = fts5DataRead(p, iRowid);
	if (pRet) {
		if (pRet->szLeaf>pRet->nn) {
			p->rc = FTS5_CORRUPT;
			fts5DataRelease(pRet);
			pRet = 0;
		}
	}
	return pRet;
}

static int fts5IndexPrepareStmt(
	Fts5Index *p,
	sqlite3_stmt **ppStmt,
	char *zSql
) {
	if (p->rc == SQLITE_OK) {
		if (zSql) {
			p->rc = sqlite3_prepare_v2(p->pConfig->db, zSql, -1, ppStmt, 0);
		}
		else {
			p->rc = SQLITE_NOMEM;
		}
	}
	sqlite3_free(zSql);
	return p->rc;
}



static void fts5DataWrite(Fts5Index *p, i64 iRowid, const u8 *pData, int nData) {
	if (p->rc != SQLITE_OK) return;

	if (p->pWriter == 0) {
		Fts5Config *pConfig = p->pConfig;
		fts5IndexPrepareStmt(p, &p->pWriter, sqlite3_mprintf(
			"REPLACE INTO '%q'.'%q_data'(id, block) VALUES(?,?)",
			pConfig->zDb, pConfig->zName
		));
		if (p->rc) return;
	}

	sqlite3_bind_int64(p->pWriter, 1, iRowid);
	sqlite3_bind_blob(p->pWriter, 2, pData, nData, SQLITE_STATIC);
	sqlite3_step(p->pWriter);
	p->rc = sqlite3_reset(p->pWriter);
}


static void fts5DataDelete(Fts5Index *p, i64 iFirst, i64 iLast) {
	if (p->rc != SQLITE_OK) return;

	if (p->pDeleter == 0) {
		int rc;
		Fts5Config *pConfig = p->pConfig;
		char *zSql = sqlite3_mprintf(
			"DELETE FROM '%q'.'%q_data' WHERE id>=? AND id<=?",
			pConfig->zDb, pConfig->zName
		);
		if (zSql == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p->pDeleter, 0);
			sqlite3_free(zSql);
		}
		if (rc != SQLITE_OK) {
			p->rc = rc;
			return;
		}
	}

	sqlite3_bind_int64(p->pDeleter, 1, iFirst);
	sqlite3_bind_int64(p->pDeleter, 2, iLast);
	sqlite3_step(p->pDeleter);
	p->rc = sqlite3_reset(p->pDeleter);
}


static void fts5DataRemoveSegment(Fts5Index *p, int iSegid) {
	i64 iFirst = FTS5_SEGMENT_ROWID(iSegid, 0);
	i64 iLast = FTS5_SEGMENT_ROWID(iSegid + 1, 0) - 1;
	fts5DataDelete(p, iFirst, iLast);
	if (p->pIdxDeleter == 0) {
		Fts5Config *pConfig = p->pConfig;
		fts5IndexPrepareStmt(p, &p->pIdxDeleter, sqlite3_mprintf(
			"DELETE FROM '%q'.'%q_idx' WHERE segid=?",
			pConfig->zDb, pConfig->zName
		));
	}
	if (p->rc == SQLITE_OK) {
		sqlite3_bind_int(p->pIdxDeleter, 1, iSegid);
		sqlite3_step(p->pIdxDeleter);
		p->rc = sqlite3_reset(p->pIdxDeleter);
	}
}


static void fts5StructureRelease(Fts5Structure *pStruct) {
	if (pStruct && 0 >= (--pStruct->nRef)) {
		int i;
		assert(pStruct->nRef == 0);
		for (i = 0; i<pStruct->nLevel; i++) {
			sqlite3_free(pStruct->aLevel[i].aSeg);
		}
		sqlite3_free(pStruct);
	}
}

static void fts5StructureRef(Fts5Structure *pStruct) {
	pStruct->nRef++;
}


static int fts5StructureDecode(
	const u8 *pData,                
	int nData,                      
	int *piCookie,                  
	Fts5Structure **ppOut           
) {
	int rc = SQLITE_OK;
	int i = 0;
	int iLvl;
	int nLevel = 0;
	int nSegment = 0;
	int nByte;                      
	Fts5Structure *pRet = 0;        

									
	if (piCookie) *piCookie = sqlite3Fts5Get32(pData);
	i = 4;

	
	i += fts5GetVarint32(&pData[i], nLevel);
	i += fts5GetVarint32(&pData[i], nSegment);
	nByte = (
		sizeof(Fts5Structure) +                    
		sizeof(Fts5StructureLevel) * (nLevel - 1)    
		);
	pRet = (Fts5Structure*)sqlite3Fts5MallocZero(&rc, nByte);

	if (pRet) {
		pRet->nRef = 1;
		pRet->nLevel = nLevel;
		pRet->nSegment = nSegment;
		i += sqlite3Fts5GetVarint(&pData[i], &pRet->nWriteCounter);

		for (iLvl = 0; rc == SQLITE_OK && iLvl<nLevel; iLvl++) {
			Fts5StructureLevel *pLvl = &pRet->aLevel[iLvl];
			int nTotal = 0;
			int iSeg;

			if (i >= nData) {
				rc = FTS5_CORRUPT;
			}
			else {
				i += fts5GetVarint32(&pData[i], pLvl->nMerge);
				i += fts5GetVarint32(&pData[i], nTotal);
				assert(nTotal >= pLvl->nMerge);
				pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&rc,
					nTotal * sizeof(Fts5StructureSegment)
				);
			}

			if (rc == SQLITE_OK) {
				pLvl->nSeg = nTotal;
				for (iSeg = 0; iSeg<nTotal; iSeg++) {
					if (i >= nData) {
						rc = FTS5_CORRUPT;
						break;
					}
					i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].iSegid);
					i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].pgnoFirst);
					i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].pgnoLast);
				}
			}
		}
		if (rc != SQLITE_OK) {
			fts5StructureRelease(pRet);
			pRet = 0;
		}
	}

	*ppOut = pRet;
	return rc;
}


static void fts5StructureAddLevel(int *pRc, Fts5Structure **ppStruct) {
	if (*pRc == SQLITE_OK) {
		Fts5Structure *pStruct = *ppStruct;
		int nLevel = pStruct->nLevel;
		int nByte = (
			sizeof(Fts5Structure) +                  
			sizeof(Fts5StructureLevel) * (nLevel + 1)  
			);

		pStruct = sqlite3_realloc(pStruct, nByte);
		if (pStruct) {
			memset(&pStruct->aLevel[nLevel], 0, sizeof(Fts5StructureLevel));
			pStruct->nLevel++;
			*ppStruct = pStruct;
		}
		else {
			*pRc = SQLITE_NOMEM;
		}
	}
}


static void fts5StructureExtendLevel(
	int *pRc,
	Fts5Structure *pStruct,
	int iLvl,
	int nExtra,
	int bInsert
) {
	if (*pRc == SQLITE_OK) {
		Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
		Fts5StructureSegment *aNew;
		int nByte;

		nByte = (pLvl->nSeg + nExtra) * sizeof(Fts5StructureSegment);
		aNew = sqlite3_realloc(pLvl->aSeg, nByte);
		if (aNew) {
			if (bInsert == 0) {
				memset(&aNew[pLvl->nSeg], 0, sizeof(Fts5StructureSegment) * nExtra);
			}
			else {
				int nMove = pLvl->nSeg * sizeof(Fts5StructureSegment);
				memmove(&aNew[nExtra], aNew, nMove);
				memset(aNew, 0, sizeof(Fts5StructureSegment) * nExtra);
			}
			pLvl->aSeg = aNew;
		}
		else {
			*pRc = SQLITE_NOMEM;
		}
	}
}

static Fts5Structure *fts5StructureReadUncached(Fts5Index *p) {
	Fts5Structure *pRet = 0;
	Fts5Config *pConfig = p->pConfig;
	int iCookie;                    
	Fts5Data *pData;

	pData = fts5DataRead(p, FTS5_STRUCTURE_ROWID);
	if (p->rc == SQLITE_OK) {
		
		memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);
		p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);
		if (p->rc == SQLITE_OK && pConfig->iCookie != iCookie) {
			p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);
		}
		fts5DataRelease(pData);
		if (p->rc != SQLITE_OK) {
			fts5StructureRelease(pRet);
			pRet = 0;
		}
	}

	return pRet;
}

static i64 fts5IndexDataVersion(Fts5Index *p) {
	i64 iVersion = 0;

	if (p->rc == SQLITE_OK) {
		if (p->pDataVersion == 0) {
			p->rc = fts5IndexPrepareStmt(p, &p->pDataVersion,
				sqlite3_mprintf("PRAGMA %Q.data_version", p->pConfig->zDb)
			);
			if (p->rc) return 0;
		}

		if (SQLITE_ROW == sqlite3_step(p->pDataVersion)) {
			iVersion = sqlite3_column_int64(p->pDataVersion, 0);
		}
		p->rc = sqlite3_reset(p->pDataVersion);
	}

	return iVersion;
}


static Fts5Structure *fts5StructureRead(Fts5Index *p) {

	if (p->pStruct == 0) {
		p->iStructVersion = fts5IndexDataVersion(p);
		if (p->rc == SQLITE_OK) {
			p->pStruct = fts5StructureReadUncached(p);
		}
	}

#if 0
	else {
		Fts5Structure *pTest = fts5StructureReadUncached(p);
		if (pTest) {
			int i, j;
			assert_nc(p->pStruct->nSegment == pTest->nSegment);
			assert_nc(p->pStruct->nLevel == pTest->nLevel);
			for (i = 0; i<pTest->nLevel; i++) {
				assert_nc(p->pStruct->aLevel[i].nMerge == pTest->aLevel[i].nMerge);
				assert_nc(p->pStruct->aLevel[i].nSeg == pTest->aLevel[i].nSeg);
				for (j = 0; j<pTest->aLevel[i].nSeg; j++) {
					Fts5StructureSegment *p1 = &pTest->aLevel[i].aSeg[j];
					Fts5StructureSegment *p2 = &p->pStruct->aLevel[i].aSeg[j];
					assert_nc(p1->iSegid == p2->iSegid);
					assert_nc(p1->pgnoFirst == p2->pgnoFirst);
					assert_nc(p1->pgnoLast == p2->pgnoLast);
				}
			}
			fts5StructureRelease(pTest);
		}
	}
#endif

	if (p->rc != SQLITE_OK) return 0;
	assert(p->iStructVersion != 0);
	assert(p->pStruct != 0);
	fts5StructureRef(p->pStruct);
	return p->pStruct;
}

static void fts5StructureInvalidate(Fts5Index *p) {
	if (p->pStruct) {
		fts5StructureRelease(p->pStruct);
		p->pStruct = 0;
	}
}


#ifdef SQLITE_DEBUG
static int fts5StructureCountSegments(Fts5Structure *pStruct) {
	int nSegment = 0;               
	if (pStruct) {
		int iLvl;                     
		for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
			nSegment += pStruct->aLevel[iLvl].nSeg;
		}
	}

	return nSegment;
}
#endif

#define fts5BufferSafeAppendBlob(pBuf, pBlob, nBlob) {     \
  assert( (pBuf)->nSpace>=((pBuf)->n+nBlob) );             \
  memcpy(&(pBuf)->p[(pBuf)->n], pBlob, nBlob);             \
  (pBuf)->n += nBlob;                                      \
}

#define fts5BufferSafeAppendVarint(pBuf, iVal) {                \
  (pBuf)->n += sqlite3Fts5PutVarint(&(pBuf)->p[(pBuf)->n], (iVal));  \
  assert( (pBuf)->nSpace>=(pBuf)->n );                          \
}



static void fts5StructureWrite(Fts5Index *p, Fts5Structure *pStruct) {
	if (p->rc == SQLITE_OK) {
		Fts5Buffer buf;               
		int iLvl;                     
		int iCookie;                  

		assert(pStruct->nSegment == fts5StructureCountSegments(pStruct));
		memset(&buf, 0, sizeof(Fts5Buffer));

		
		iCookie = p->pConfig->iCookie;
		if (iCookie<0) iCookie = 0;

		if (0 == sqlite3Fts5BufferSize(&p->rc, &buf, 4 + 9 + 9 + 9)) {
			sqlite3Fts5Put32(buf.p, iCookie);
			buf.n = 4;
			fts5BufferSafeAppendVarint(&buf, pStruct->nLevel);
			fts5BufferSafeAppendVarint(&buf, pStruct->nSegment);
			fts5BufferSafeAppendVarint(&buf, (i64)pStruct->nWriteCounter);
		}

		for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
			int iSeg;                     
			Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
			fts5BufferAppendVarint(&p->rc, &buf, pLvl->nMerge);
			fts5BufferAppendVarint(&p->rc, &buf, pLvl->nSeg);
			assert(pLvl->nMerge <= pLvl->nSeg);

			for (iSeg = 0; iSeg<pLvl->nSeg; iSeg++) {
				fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].iSegid);
				fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoFirst);
				fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoLast);
			}
		}

		fts5DataWrite(p, FTS5_STRUCTURE_ROWID, buf.p, buf.n);
		fts5BufferFree(&buf);
	}
}

#if 0
static void fts5DebugStructure(int*, Fts5Buffer*, Fts5Structure*);
static void fts5PrintStructure(const char *zCaption, Fts5Structure *pStruct) {
	int rc = SQLITE_OK;
	Fts5Buffer buf;
	memset(&buf, 0, sizeof(buf));
	fts5DebugStructure(&rc, &buf, pStruct);
	fprintf(stdout, "%s: %s\n", zCaption, buf.p);
	fflush(stdout);
	fts5BufferFree(&buf);
}
#else
# define fts5PrintStructure(x,y)
#endif

static int fts5SegmentSize(Fts5StructureSegment *pSeg) {
	return 1 + pSeg->pgnoLast - pSeg->pgnoFirst;
}


static void fts5StructurePromoteTo(
	Fts5Index *p,
	int iPromote,
	int szPromote,
	Fts5Structure *pStruct
) {
	int il, is;
	Fts5StructureLevel *pOut = &pStruct->aLevel[iPromote];

	if (pOut->nMerge == 0) {
		for (il = iPromote + 1; il<pStruct->nLevel; il++) {
			Fts5StructureLevel *pLvl = &pStruct->aLevel[il];
			if (pLvl->nMerge) return;
			for (is = pLvl->nSeg - 1; is >= 0; is--) {
				int sz = fts5SegmentSize(&pLvl->aSeg[is]);
				if (sz>szPromote) return;
				fts5StructureExtendLevel(&p->rc, pStruct, iPromote, 1, 1);
				if (p->rc) return;
				memcpy(pOut->aSeg, &pLvl->aSeg[is], sizeof(Fts5StructureSegment));
				pOut->nSeg++;
				pLvl->nSeg--;
			}
		}
	}
}


static void fts5StructurePromote(
	Fts5Index *p,                   
	int iLvl,                       
	Fts5Structure *pStruct          
) {
	if (p->rc == SQLITE_OK) {
		int iTst;
		int iPromote = -1;
		int szPromote = 0;            
		Fts5StructureSegment *pSeg;   
		int szSeg;                    
		int nSeg = pStruct->aLevel[iLvl].nSeg;

		if (nSeg == 0) return;
		pSeg = &pStruct->aLevel[iLvl].aSeg[pStruct->aLevel[iLvl].nSeg - 1];
		szSeg = (1 + pSeg->pgnoLast - pSeg->pgnoFirst);

		
		for (iTst = iLvl - 1; iTst >= 0 && pStruct->aLevel[iTst].nSeg == 0; iTst--);
		if (iTst >= 0) {
			int i;
			int szMax = 0;
			Fts5StructureLevel *pTst = &pStruct->aLevel[iTst];
			assert(pTst->nMerge == 0);
			for (i = 0; i<pTst->nSeg; i++) {
				int sz = pTst->aSeg[i].pgnoLast - pTst->aSeg[i].pgnoFirst + 1;
				if (sz>szMax) szMax = sz;
			}
			if (szMax >= szSeg) {
				
				iPromote = iTst;
				szPromote = szMax;
			}
		}

		
		if (iPromote<0) {
			iPromote = iLvl;
			szPromote = szSeg;
		}
		fts5StructurePromoteTo(p, iPromote, szPromote, pStruct);
	}
}



static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl) {
	Fts5Data *pData = pLvl->pData;

	if (pLvl->iOff == 0) {
		assert(pLvl->bEof == 0);
		pLvl->iOff = 1;
		pLvl->iOff += fts5GetVarint32(&pData->p[1], pLvl->iLeafPgno);
		pLvl->iOff += fts5GetVarint(&pData->p[pLvl->iOff], (u64*)&pLvl->iRowid);
		pLvl->iFirstOff = pLvl->iOff;
	}
	else {
		int iOff;
		for (iOff = pLvl->iOff; iOff<pData->nn; iOff++) {
			if (pData->p[iOff]) break;
		}

		if (iOff<pData->nn) {
			i64 iVal;
			pLvl->iLeafPgno += (iOff - pLvl->iOff) + 1;
			iOff += fts5GetVarint(&pData->p[iOff], (u64*)&iVal);
			pLvl->iRowid += iVal;
			pLvl->iOff = iOff;
		}
		else {
			pLvl->bEof = 1;
		}
	}

	return pLvl->bEof;
}


static int fts5DlidxIterNextR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl) {
	Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];

	assert(iLvl<pIter->nLvl);
	if (fts5DlidxLvlNext(pLvl)) {
		if ((iLvl + 1) < pIter->nLvl) {
			fts5DlidxIterNextR(p, pIter, iLvl + 1);
			if (pLvl[1].bEof == 0) {
				fts5DataRelease(pLvl->pData);
				memset(pLvl, 0, sizeof(Fts5DlidxLvl));
				pLvl->pData = fts5DataRead(p,
					FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
				);
				if (pLvl->pData) fts5DlidxLvlNext(pLvl);
			}
		}
	}

	return pIter->aLvl[0].bEof;
}
static int fts5DlidxIterNext(Fts5Index *p, Fts5DlidxIter *pIter) {
	return fts5DlidxIterNextR(p, pIter, 0);
}


static int fts5DlidxIterFirst(Fts5DlidxIter *pIter) {
	int i;
	for (i = 0; i<pIter->nLvl; i++) {
		fts5DlidxLvlNext(&pIter->aLvl[i]);
	}
	return pIter->aLvl[0].bEof;
}


static int fts5DlidxIterEof(Fts5Index *p, Fts5DlidxIter *pIter) {
	return p->rc != SQLITE_OK || pIter->aLvl[0].bEof;
}

static void fts5DlidxIterLast(Fts5Index *p, Fts5DlidxIter *pIter) {
	int i;

	
	for (i = pIter->nLvl - 1; p->rc == SQLITE_OK && i >= 0; i--) {
		Fts5DlidxLvl *pLvl = &pIter->aLvl[i];
		while (fts5DlidxLvlNext(pLvl) == 0);
		pLvl->bEof = 0;

		if (i>0) {
			Fts5DlidxLvl *pChild = &pLvl[-1];
			fts5DataRelease(pChild->pData);
			memset(pChild, 0, sizeof(Fts5DlidxLvl));
			pChild->pData = fts5DataRead(p,
				FTS5_DLIDX_ROWID(pIter->iSegid, i - 1, pLvl->iLeafPgno)
			);
		}
	}
}


static int fts5DlidxLvlPrev(Fts5DlidxLvl *pLvl) {
	int iOff = pLvl->iOff;

	assert(pLvl->bEof == 0);
	if (iOff <= pLvl->iFirstOff) {
		pLvl->bEof = 1;
	}
	else {
		u8 *a = pLvl->pData->p;
		i64 iVal;
		int iLimit;
		int ii;
		int nZero = 0;

		
		iLimit = (iOff>9 ? iOff - 9 : 0);
		for (iOff--; iOff>iLimit; iOff--) {
			if ((a[iOff - 1] & 0x80) == 0) break;
		}

		fts5GetVarint(&a[iOff], (u64*)&iVal);
		pLvl->iRowid -= iVal;
		pLvl->iLeafPgno--;

		
		for (ii = iOff - 1; ii >= pLvl->iFirstOff && a[ii] == 0x00; ii--) {
			nZero++;
		}
		if (ii >= pLvl->iFirstOff && (a[ii] & 0x80)) {
			
			int bZero = 0;              
			if ((ii - 8) >= pLvl->iFirstOff) {
				int j;
				for (j = 1; j <= 8 && (a[ii - j] & 0x80); j++);
				bZero = (j>8);
			}
			if (bZero == 0) nZero--;
		}
		pLvl->iLeafPgno -= nZero;
		pLvl->iOff = iOff - nZero;
	}

	return pLvl->bEof;
}

static int fts5DlidxIterPrevR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl) {
	Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];

	assert(iLvl<pIter->nLvl);
	if (fts5DlidxLvlPrev(pLvl)) {
		if ((iLvl + 1) < pIter->nLvl) {
			fts5DlidxIterPrevR(p, pIter, iLvl + 1);
			if (pLvl[1].bEof == 0) {
				fts5DataRelease(pLvl->pData);
				memset(pLvl, 0, sizeof(Fts5DlidxLvl));
				pLvl->pData = fts5DataRead(p,
					FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
				);
				if (pLvl->pData) {
					while (fts5DlidxLvlNext(pLvl) == 0);
					pLvl->bEof = 0;
				}
			}
		}
	}

	return pIter->aLvl[0].bEof;
}
static int fts5DlidxIterPrev(Fts5Index *p, Fts5DlidxIter *pIter) {
	return fts5DlidxIterPrevR(p, pIter, 0);
}


static void fts5DlidxIterFree(Fts5DlidxIter *pIter) {
	if (pIter) {
		int i;
		for (i = 0; i<pIter->nLvl; i++) {
			fts5DataRelease(pIter->aLvl[i].pData);
		}
		sqlite3_free(pIter);
	}
}

static Fts5DlidxIter *fts5DlidxIterInit(
	Fts5Index *p,                   
	int bRev,                       
	int iSegid,                     
	int iLeafPg                     
) {
	Fts5DlidxIter *pIter = 0;
	int i;
	int bDone = 0;

	for (i = 0; p->rc == SQLITE_OK && bDone == 0; i++) {
		int nByte = sizeof(Fts5DlidxIter) + i * sizeof(Fts5DlidxLvl);
		Fts5DlidxIter *pNew;

		pNew = (Fts5DlidxIter*)sqlite3_realloc(pIter, nByte);
		if (pNew == 0) {
			p->rc = SQLITE_NOMEM;
		}
		else {
			i64 iRowid = FTS5_DLIDX_ROWID(iSegid, i, iLeafPg);
			Fts5DlidxLvl *pLvl = &pNew->aLvl[i];
			pIter = pNew;
			memset(pLvl, 0, sizeof(Fts5DlidxLvl));
			pLvl->pData = fts5DataRead(p, iRowid);
			if (pLvl->pData && (pLvl->pData->p[0] & 0x0001) == 0) {
				bDone = 1;
			}
			pIter->nLvl = i + 1;
		}
	}

	if (p->rc == SQLITE_OK) {
		pIter->iSegid = iSegid;
		if (bRev == 0) {
			fts5DlidxIterFirst(pIter);
		}
		else {
			fts5DlidxIterLast(p, pIter);
		}
	}

	if (p->rc != SQLITE_OK) {
		fts5DlidxIterFree(pIter);
		pIter = 0;
	}

	return pIter;
}

static i64 fts5DlidxIterRowid(Fts5DlidxIter *pIter) {
	return pIter->aLvl[0].iRowid;
}
static int fts5DlidxIterPgno(Fts5DlidxIter *pIter) {
	return pIter->aLvl[0].iLeafPgno;
}


static void fts5SegIterNextPage(
	Fts5Index *p,                   
	Fts5SegIter *pIter              
) {
	Fts5Data *pLeaf;
	Fts5StructureSegment *pSeg = pIter->pSeg;
	fts5DataRelease(pIter->pLeaf);
	pIter->iLeafPgno++;
	if (pIter->pNextLeaf) {
		pIter->pLeaf = pIter->pNextLeaf;
		pIter->pNextLeaf = 0;
	}
	else if (pIter->iLeafPgno <= pSeg->pgnoLast) {
		pIter->pLeaf = fts5LeafRead(p,
			FTS5_SEGMENT_ROWID(pSeg->iSegid, pIter->iLeafPgno)
		);
	}
	else {
		pIter->pLeaf = 0;
	}
	pLeaf = pIter->pLeaf;

	if (pLeaf) {
		pIter->iPgidxOff = pLeaf->szLeaf;
		if (fts5LeafIsTermless(pLeaf)) {
			pIter->iEndofDoclist = pLeaf->nn + 1;
		}
		else {
			pIter->iPgidxOff += fts5GetVarint32(&pLeaf->p[pIter->iPgidxOff],
				pIter->iEndofDoclist
			);
		}
	}
}


static int fts5GetPoslistSize(const u8 *p, int *pnSz, int *pbDel) {
	int nSz;
	int n = 0;
	fts5FastGetVarint32(p, n, nSz);
	assert_nc(nSz >= 0);
	*pnSz = nSz / 2;
	*pbDel = nSz & 0x0001;
	return n;
}


static void fts5SegIterLoadNPos(Fts5Index *p, Fts5SegIter *pIter) {
	if (p->rc == SQLITE_OK) {
		int iOff = pIter->iLeafOffset;  
		ASSERT_SZLEAF_OK(pIter->pLeaf);
		if (p->pConfig->eDetail == FTS5_DETAIL_NONE) {
			int iEod = MIN(pIter->iEndofDoclist, pIter->pLeaf->szLeaf);
			pIter->bDel = 0;
			pIter->nPos = 1;
			if (iOff<iEod && pIter->pLeaf->p[iOff] == 0) {
				pIter->bDel = 1;
				iOff++;
				if (iOff<iEod && pIter->pLeaf->p[iOff] == 0) {
					pIter->nPos = 1;
					iOff++;
				}
				else {
					pIter->nPos = 0;
				}
			}
		}
		else {
			int nSz;
			fts5FastGetVarint32(pIter->pLeaf->p, iOff, nSz);
			pIter->bDel = (nSz & 0x0001);
			pIter->nPos = nSz >> 1;
			assert_nc(pIter->nPos >= 0);
		}
		pIter->iLeafOffset = iOff;
	}
}

static void fts5SegIterLoadRowid(Fts5Index *p, Fts5SegIter *pIter) {
	u8 *a = pIter->pLeaf->p;        
	int iOff = pIter->iLeafOffset;

	ASSERT_SZLEAF_OK(pIter->pLeaf);
	if (iOff >= pIter->pLeaf->szLeaf) {
		fts5SegIterNextPage(p, pIter);
		if (pIter->pLeaf == 0) {
			if (p->rc == SQLITE_OK) p->rc = FTS5_CORRUPT;
			return;
		}
		iOff = 4;
		a = pIter->pLeaf->p;
	}
	iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
	pIter->iLeafOffset = iOff;
}


static void fts5SegIterLoadTerm(Fts5Index *p, Fts5SegIter *pIter, int nKeep) {
	u8 *a = pIter->pLeaf->p;        
	int iOff = pIter->iLeafOffset;  
	int nNew;                       

	iOff += fts5GetVarint32(&a[iOff], nNew);
	if (iOff + nNew>pIter->pLeaf->nn) {
		p->rc = FTS5_CORRUPT;
		return;
	}
	pIter->term.n = nKeep;
	fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);
	iOff += nNew;
	pIter->iTermLeafOffset = iOff;
	pIter->iTermLeafPgno = pIter->iLeafPgno;
	pIter->iLeafOffset = iOff;

	if (pIter->iPgidxOff >= pIter->pLeaf->nn) {
		pIter->iEndofDoclist = pIter->pLeaf->nn + 1;
	}
	else {
		int nExtra;
		pIter->iPgidxOff += fts5GetVarint32(&a[pIter->iPgidxOff], nExtra);
		pIter->iEndofDoclist += nExtra;
	}

	fts5SegIterLoadRowid(p, pIter);
}

static void fts5SegIterNext(Fts5Index*, Fts5SegIter*, int*);
static void fts5SegIterNext_Reverse(Fts5Index*, Fts5SegIter*, int*);
static void fts5SegIterNext_None(Fts5Index*, Fts5SegIter*, int*);

static void fts5SegIterSetNext(Fts5Index *p, Fts5SegIter *pIter) {
	if (pIter->flags & FTS5_SEGITER_REVERSE) {
		pIter->xNext = fts5SegIterNext_Reverse;
	}
	else if (p->pConfig->eDetail == FTS5_DETAIL_NONE) {
		pIter->xNext = fts5SegIterNext_None;
	}
	else {
		pIter->xNext = fts5SegIterNext;
	}
}


static void fts5SegIterInit(
	Fts5Index *p,                   
	Fts5StructureSegment *pSeg,     
	Fts5SegIter *pIter              
) {
	if (pSeg->pgnoFirst == 0) {
		
		assert(pIter->pLeaf == 0);
		return;
	}

	if (p->rc == SQLITE_OK) {
		memset(pIter, 0, sizeof(*pIter));
		fts5SegIterSetNext(p, pIter);
		pIter->pSeg = pSeg;
		pIter->iLeafPgno = pSeg->pgnoFirst - 1;
		fts5SegIterNextPage(p, pIter);
	}

	if (p->rc == SQLITE_OK) {
		pIter->iLeafOffset = 4;
		assert_nc(pIter->pLeaf->nn>4);
		assert(fts5LeafFirstTermOff(pIter->pLeaf) == 4);
		pIter->iPgidxOff = pIter->pLeaf->szLeaf + 1;
		fts5SegIterLoadTerm(p, pIter, 0);
		fts5SegIterLoadNPos(p, pIter);
	}
}


static void fts5SegIterReverseInitPage(Fts5Index *p, Fts5SegIter *pIter) {
	int eDetail = p->pConfig->eDetail;
	int n = pIter->pLeaf->szLeaf;
	int i = pIter->iLeafOffset;
	u8 *a = pIter->pLeaf->p;
	int iRowidOffset = 0;

	if (n>pIter->iEndofDoclist) {
		n = pIter->iEndofDoclist;
	}

	ASSERT_SZLEAF_OK(pIter->pLeaf);
	while (1) {
		i64 iDelta = 0;

		if (eDetail == FTS5_DETAIL_NONE) {
			
			if (i<n && a[i] == 0) {
				i++;
				if (i<n && a[i] == 0) i++;
			}
		}
		else {
			int nPos;
			int bDummy;
			i += fts5GetPoslistSize(&a[i], &nPos, &bDummy);
			i += nPos;
		}
		if (i >= n) break;
		i += fts5GetVarint(&a[i], (u64*)&iDelta);
		pIter->iRowid += iDelta;

		
		if (iRowidOffset >= pIter->nRowidOffset) {
			int nNew = pIter->nRowidOffset + 8;
			int *aNew = (int*)sqlite3_realloc(pIter->aRowidOffset, nNew * sizeof(int));
			if (aNew == 0) {
				p->rc = SQLITE_NOMEM;
				break;
			}
			pIter->aRowidOffset = aNew;
			pIter->nRowidOffset = nNew;
		}

		pIter->aRowidOffset[iRowidOffset++] = pIter->iLeafOffset;
		pIter->iLeafOffset = i;
	}
	pIter->iRowidOffset = iRowidOffset;
	fts5SegIterLoadNPos(p, pIter);
}


static void fts5SegIterReverseNewPage(Fts5Index *p, Fts5SegIter *pIter) {
	assert(pIter->flags & FTS5_SEGITER_REVERSE);
	assert(pIter->flags & FTS5_SEGITER_ONETERM);

	fts5DataRelease(pIter->pLeaf);
	pIter->pLeaf = 0;
	while (p->rc == SQLITE_OK && pIter->iLeafPgno>pIter->iTermLeafPgno) {
		Fts5Data *pNew;
		pIter->iLeafPgno--;
		pNew = fts5DataRead(p, FTS5_SEGMENT_ROWID(
			pIter->pSeg->iSegid, pIter->iLeafPgno
		));
		if (pNew) {
			
			if (pIter->iLeafPgno == pIter->iTermLeafPgno) {
				assert(pIter->pLeaf == 0);
				if (pIter->iTermLeafOffset<pNew->szLeaf) {
					pIter->pLeaf = pNew;
					pIter->iLeafOffset = pIter->iTermLeafOffset;
				}
			}
			else {
				int iRowidOff;
				iRowidOff = fts5LeafFirstRowidOff(pNew);
				if (iRowidOff) {
					pIter->pLeaf = pNew;
					pIter->iLeafOffset = iRowidOff;
				}
			}

			if (pIter->pLeaf) {
				u8 *a = &pIter->pLeaf->p[pIter->iLeafOffset];
				pIter->iLeafOffset += fts5GetVarint(a, (u64*)&pIter->iRowid);
				break;
			}
			else {
				fts5DataRelease(pNew);
			}
		}
	}

	if (pIter->pLeaf) {
		pIter->iEndofDoclist = pIter->pLeaf->nn + 1;
		fts5SegIterReverseInitPage(p, pIter);
	}
}


static int fts5MultiIterIsEmpty(Fts5Index *p, Fts5Iter *pIter) {
	Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
	return (p->rc == SQLITE_OK && pSeg->pLeaf && pSeg->nPos == 0);
}


static void fts5SegIterNext_Reverse(
	Fts5Index *p,                   
	Fts5SegIter *pIter,             
	int *pbUnused                   
) {
	assert(pIter->flags & FTS5_SEGITER_REVERSE);
	assert(pIter->pNextLeaf == 0);
	UNUSED_PARAM(pbUnused);

	if (pIter->iRowidOffset>0) {
		u8 *a = pIter->pLeaf->p;
		int iOff;
		i64 iDelta;

		pIter->iRowidOffset--;
		pIter->iLeafOffset = pIter->aRowidOffset[pIter->iRowidOffset];
		fts5SegIterLoadNPos(p, pIter);
		iOff = pIter->iLeafOffset;
		if (p->pConfig->eDetail != FTS5_DETAIL_NONE) {
			iOff += pIter->nPos;
		}
		fts5GetVarint(&a[iOff], (u64*)&iDelta);
		pIter->iRowid -= iDelta;
	}
	else {
		fts5SegIterReverseNewPage(p, pIter);
	}
}


static void fts5SegIterNext_None(
	Fts5Index *p,                   
	Fts5SegIter *pIter,             
	int *pbNewTerm                  
) {
	int iOff;

	assert(p->rc == SQLITE_OK);
	assert((pIter->flags & FTS5_SEGITER_REVERSE) == 0);
	assert(p->pConfig->eDetail == FTS5_DETAIL_NONE);

	ASSERT_SZLEAF_OK(pIter->pLeaf);
	iOff = pIter->iLeafOffset;

	
	if (pIter->pSeg && iOff >= pIter->pLeaf->szLeaf) {
		fts5SegIterNextPage(p, pIter);
		if (p->rc || pIter->pLeaf == 0) return;
		pIter->iRowid = 0;
		iOff = 4;
	}

	if (iOff<pIter->iEndofDoclist) {
		
		i64 iDelta;
		iOff += sqlite3Fts5GetVarint(&pIter->pLeaf->p[iOff], (u64*)&iDelta);
		pIter->iLeafOffset = iOff;
		pIter->iRowid += iDelta;
	}
	else if ((pIter->flags & FTS5_SEGITER_ONETERM) == 0) {
		if (pIter->pSeg) {
			int nKeep = 0;
			if (iOff != fts5LeafFirstTermOff(pIter->pLeaf)) {
				iOff += fts5GetVarint32(&pIter->pLeaf->p[iOff], nKeep);
			}
			pIter->iLeafOffset = iOff;
			fts5SegIterLoadTerm(p, pIter, nKeep);
		}
		else {
			const u8 *pList = 0;
			const char *zTerm = 0;
			int nList;
			sqlite3Fts5HashScanNext(p->pHash);
			sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);
			if (pList == 0) goto next_none_eof;
			pIter->pLeaf->p = (u8*)pList;
			pIter->pLeaf->nn = nList;
			pIter->pLeaf->szLeaf = nList;
			pIter->iEndofDoclist = nList;
			sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm), (u8*)zTerm);
			pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
		}

		if (pbNewTerm) *pbNewTerm = 1;
	}
	else {
		goto next_none_eof;
	}

	fts5SegIterLoadNPos(p, pIter);

	return;
next_none_eof:
	fts5DataRelease(pIter->pLeaf);
	pIter->pLeaf = 0;
}



static void fts5SegIterNext(
	Fts5Index *p,                   
	Fts5SegIter *pIter,             
	int *pbNewTerm                  
) {
	Fts5Data *pLeaf = pIter->pLeaf;
	int iOff;
	int bNewTerm = 0;
	int nKeep = 0;
	u8 *a;
	int n;

	assert(pbNewTerm == 0 || *pbNewTerm == 0);
	assert(p->pConfig->eDetail != FTS5_DETAIL_NONE);

	
	a = pLeaf->p;
	n = pLeaf->szLeaf;

	ASSERT_SZLEAF_OK(pLeaf);
	iOff = pIter->iLeafOffset + pIter->nPos;

	if (iOff<n) {
		
		assert_nc(iOff <= pIter->iEndofDoclist);
		if (iOff >= pIter->iEndofDoclist) {
			bNewTerm = 1;
			if (iOff != fts5LeafFirstTermOff(pLeaf)) {
				iOff += fts5GetVarint32(&a[iOff], nKeep);
			}
		}
		else {
			u64 iDelta;
			iOff += sqlite3Fts5GetVarint(&a[iOff], &iDelta);
			pIter->iRowid += iDelta;
			assert_nc(iDelta>0);
		}
		pIter->iLeafOffset = iOff;

	}
	else if (pIter->pSeg == 0) {
		const u8 *pList = 0;
		const char *zTerm = 0;
		int nList = 0;
		assert((pIter->flags & FTS5_SEGITER_ONETERM) || pbNewTerm);
		if (0 == (pIter->flags & FTS5_SEGITER_ONETERM)) {
			sqlite3Fts5HashScanNext(p->pHash);
			sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);
		}
		if (pList == 0) {
			fts5DataRelease(pIter->pLeaf);
			pIter->pLeaf = 0;
		}
		else {
			pIter->pLeaf->p = (u8*)pList;
			pIter->pLeaf->nn = nList;
			pIter->pLeaf->szLeaf = nList;
			pIter->iEndofDoclist = nList + 1;
			sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm),
				(u8*)zTerm);
			pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
			*pbNewTerm = 1;
		}
	}
	else {
		iOff = 0;
		
		while (iOff == 0) {
			fts5SegIterNextPage(p, pIter);
			pLeaf = pIter->pLeaf;
			if (pLeaf == 0) break;
			ASSERT_SZLEAF_OK(pLeaf);
			if ((iOff = fts5LeafFirstRowidOff(pLeaf)) && iOff<pLeaf->szLeaf) {
				iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (u64*)&pIter->iRowid);
				pIter->iLeafOffset = iOff;

				if (pLeaf->nn>pLeaf->szLeaf) {
					pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
						&pLeaf->p[pLeaf->szLeaf], pIter->iEndofDoclist
					);
				}
			}
			else if (pLeaf->nn>pLeaf->szLeaf) {
				pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
					&pLeaf->p[pLeaf->szLeaf], iOff
				);
				pIter->iLeafOffset = iOff;
				pIter->iEndofDoclist = iOff;
				bNewTerm = 1;
			}
			assert_nc(iOff<pLeaf->szLeaf);
			if (iOff>pLeaf->szLeaf) {
				p->rc = FTS5_CORRUPT;
				return;
			}
		}
	}

	
	if (pIter->pLeaf) {
		if (bNewTerm) {
			if (pIter->flags & FTS5_SEGITER_ONETERM) {
				fts5DataRelease(pIter->pLeaf);
				pIter->pLeaf = 0;
			}
			else {
				fts5SegIterLoadTerm(p, pIter, nKeep);
				fts5SegIterLoadNPos(p, pIter);
				if (pbNewTerm) *pbNewTerm = 1;
			}
		}
		else {
			
			int nSz;
			assert(p->rc == SQLITE_OK);
			fts5FastGetVarint32(pIter->pLeaf->p, pIter->iLeafOffset, nSz);
			pIter->bDel = (nSz & 0x0001);
			pIter->nPos = nSz >> 1;
			assert_nc(pIter->nPos >= 0);
		}
	}
}

#define SWAPVAL(T, a, b) { T tmp; tmp=a; a=b; b=tmp; }

#define fts5IndexSkipVarint(a, iOff) {            \
  int iEnd = iOff+9;                              \
  while( (a[iOff++] & 0x80) && iOff<iEnd );       \
}


static void fts5SegIterReverse(Fts5Index *p, Fts5SegIter *pIter) {
	Fts5DlidxIter *pDlidx = pIter->pDlidx;
	Fts5Data *pLast = 0;
	int pgnoLast = 0;

	if (pDlidx) {
		int iSegid = pIter->pSeg->iSegid;
		pgnoLast = fts5DlidxIterPgno(pDlidx);
		pLast = fts5DataRead(p, FTS5_SEGMENT_ROWID(iSegid, pgnoLast));
	}
	else {
		Fts5Data *pLeaf = pIter->pLeaf;         

												
		int iPoslist;
		if (pIter->iTermLeafPgno == pIter->iLeafPgno) {
			iPoslist = pIter->iTermLeafOffset;
		}
		else {
			iPoslist = 4;
		}
		fts5IndexSkipVarint(pLeaf->p, iPoslist);
		pIter->iLeafOffset = iPoslist;

		
		if (pIter->iEndofDoclist >= pLeaf->szLeaf) {
			int pgno;
			Fts5StructureSegment *pSeg = pIter->pSeg;

			
			for (pgno = pIter->iLeafPgno + 1; !p->rc && pgno <= pSeg->pgnoLast; pgno++) {
				i64 iAbs = FTS5_SEGMENT_ROWID(pSeg->iSegid, pgno);
				Fts5Data *pNew = fts5DataRead(p, iAbs);
				if (pNew) {
					int iRowid, bTermless;
					iRowid = fts5LeafFirstRowidOff(pNew);
					bTermless = fts5LeafIsTermless(pNew);
					if (iRowid) {
						SWAPVAL(Fts5Data*, pNew, pLast);
						pgnoLast = pgno;
					}
					fts5DataRelease(pNew);
					if (bTermless == 0) break;
				}
			}
		}
	}

	
	if (pLast) {
		int iOff;
		fts5DataRelease(pIter->pLeaf);
		pIter->pLeaf = pLast;
		pIter->iLeafPgno = pgnoLast;
		iOff = fts5LeafFirstRowidOff(pLast);
		iOff += fts5GetVarint(&pLast->p[iOff], (u64*)&pIter->iRowid);
		pIter->iLeafOffset = iOff;

		if (fts5LeafIsTermless(pLast)) {
			pIter->iEndofDoclist = pLast->nn + 1;
		}
		else {
			pIter->iEndofDoclist = fts5LeafFirstTermOff(pLast);
		}

	}

	fts5SegIterReverseInitPage(p, pIter);
}


static void fts5SegIterLoadDlidx(Fts5Index *p, Fts5SegIter *pIter) {
	int iSeg = pIter->pSeg->iSegid;
	int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
	Fts5Data *pLeaf = pIter->pLeaf; 

	assert(pIter->flags & FTS5_SEGITER_ONETERM);
	assert(pIter->pDlidx == 0);

	
	if (pIter->iTermLeafPgno == pIter->iLeafPgno
		&& pIter->iEndofDoclist<pLeaf->szLeaf
		) {
		return;
	}

	pIter->pDlidx = fts5DlidxIterInit(p, bRev, iSeg, pIter->iTermLeafPgno);
}


static void fts5LeafSeek(
	Fts5Index *p,                   
	int bGe,                        
	Fts5SegIter *pIter,             
	const u8 *pTerm, int nTerm      
) {
	int iOff;
	const u8 *a = pIter->pLeaf->p;
	int szLeaf = pIter->pLeaf->szLeaf;
	int n = pIter->pLeaf->nn;

	int nMatch = 0;
	int nKeep = 0;
	int nNew = 0;
	int iTermOff;
	int iPgidx;                     
	int bEndOfPage = 0;

	assert(p->rc == SQLITE_OK);

	iPgidx = szLeaf;
	iPgidx += fts5GetVarint32(&a[iPgidx], iTermOff);
	iOff = iTermOff;
	if (iOff>n) {
		p->rc = FTS5_CORRUPT;
		return;
	}

	while (1) {

		
		fts5FastGetVarint32(a, iOff, nNew);
		if (nKeep<nMatch) {
			goto search_failed;
		}

		assert(nKeep >= nMatch);
		if (nKeep == nMatch) {
			int nCmp;
			int i;
			nCmp = MIN(nNew, nTerm - nMatch);
			for (i = 0; i<nCmp; i++) {
				if (a[iOff + i] != pTerm[nMatch + i]) break;
			}
			nMatch += i;

			if (nTerm == nMatch) {
				if (i == nNew) {
					goto search_success;
				}
				else {
					goto search_failed;
				}
			}
			else if (i<nNew && a[iOff + i]>pTerm[nMatch]) {
				goto search_failed;
			}
		}

		if (iPgidx >= n) {
			bEndOfPage = 1;
			break;
		}

		iPgidx += fts5GetVarint32(&a[iPgidx], nKeep);
		iTermOff += nKeep;
		iOff = iTermOff;

		if (iOff >= n) {
			p->rc = FTS5_CORRUPT;
			return;
		}

		
		fts5FastGetVarint32(a, iOff, nKeep);
	}

search_failed:
	if (bGe == 0) {
		fts5DataRelease(pIter->pLeaf);
		pIter->pLeaf = 0;
		return;
	}
	else if (bEndOfPage) {
		do {
			fts5SegIterNextPage(p, pIter);
			if (pIter->pLeaf == 0) return;
			a = pIter->pLeaf->p;
			if (fts5LeafIsTermless(pIter->pLeaf) == 0) {
				iPgidx = pIter->pLeaf->szLeaf;
				iPgidx += fts5GetVarint32(&pIter->pLeaf->p[iPgidx], iOff);
				if (iOff<4 || iOff >= pIter->pLeaf->szLeaf) {
					p->rc = FTS5_CORRUPT;
				}
				else {
					nKeep = 0;
					iTermOff = iOff;
					n = pIter->pLeaf->nn;
					iOff += fts5GetVarint32(&a[iOff], nNew);
					break;
				}
			}
		} while (1);
	}

search_success:

	pIter->iLeafOffset = iOff + nNew;
	pIter->iTermLeafOffset = pIter->iLeafOffset;
	pIter->iTermLeafPgno = pIter->iLeafPgno;

	fts5BufferSet(&p->rc, &pIter->term, nKeep, pTerm);
	fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);

	if (iPgidx >= n) {
		pIter->iEndofDoclist = pIter->pLeaf->nn + 1;
	}
	else {
		int nExtra;
		iPgidx += fts5GetVarint32(&a[iPgidx], nExtra);
		pIter->iEndofDoclist = iTermOff + nExtra;
	}
	pIter->iPgidxOff = iPgidx;

	fts5SegIterLoadRowid(p, pIter);
	fts5SegIterLoadNPos(p, pIter);
}

static sqlite3_stmt *fts5IdxSelectStmt(Fts5Index *p) {
	if (p->pIdxSelect == 0) {
		Fts5Config *pConfig = p->pConfig;
		fts5IndexPrepareStmt(p, &p->pIdxSelect, sqlite3_mprintf(
			"SELECT pgno FROM '%q'.'%q_idx' WHERE "
			"segid=? AND term<=? ORDER BY term DESC LIMIT 1",
			pConfig->zDb, pConfig->zName
		));
	}
	return p->pIdxSelect;
}


static void fts5SegIterSeekInit(
	Fts5Index *p,                   
	const u8 *pTerm, int nTerm,     
	int flags,                      
	Fts5StructureSegment *pSeg,     
	Fts5SegIter *pIter              
) {
	int iPg = 1;
	int bGe = (flags & FTS5INDEX_QUERY_SCAN);
	int bDlidx = 0;                 
	sqlite3_stmt *pIdxSelect = 0;

	assert(bGe == 0 || (flags & FTS5INDEX_QUERY_DESC) == 0);
	assert(pTerm && nTerm);
	memset(pIter, 0, sizeof(*pIter));
	pIter->pSeg = pSeg;

	
	pIdxSelect = fts5IdxSelectStmt(p);
	if (p->rc) return;
	sqlite3_bind_int(pIdxSelect, 1, pSeg->iSegid);
	sqlite3_bind_blob(pIdxSelect, 2, pTerm, nTerm, SQLITE_STATIC);
	if (SQLITE_ROW == sqlite3_step(pIdxSelect)) {
		i64 val = sqlite3_column_int(pIdxSelect, 0);
		iPg = (int)(val >> 1);
		bDlidx = (val & 0x0001);
	}
	p->rc = sqlite3_reset(pIdxSelect);

	if (iPg<pSeg->pgnoFirst) {
		iPg = pSeg->pgnoFirst;
		bDlidx = 0;
	}

	pIter->iLeafPgno = iPg - 1;
	fts5SegIterNextPage(p, pIter);

	if (pIter->pLeaf) {
		fts5LeafSeek(p, bGe, pIter, pTerm, nTerm);
	}

	if (p->rc == SQLITE_OK && bGe == 0) {
		pIter->flags |= FTS5_SEGITER_ONETERM;
		if (pIter->pLeaf) {
			if (flags & FTS5INDEX_QUERY_DESC) {
				pIter->flags |= FTS5_SEGITER_REVERSE;
			}
			if (bDlidx) {
				fts5SegIterLoadDlidx(p, pIter);
			}
			if (flags & FTS5INDEX_QUERY_DESC) {
				fts5SegIterReverse(p, pIter);
			}
		}
	}

	fts5SegIterSetNext(p, pIter);

	
	assert(p->rc != SQLITE_OK                                          
		|| pIter->pLeaf == 0                                               
		|| fts5BufferCompareBlob(&pIter->term, pTerm, nTerm) == 0          
		|| (bGe && fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)>0)  
	);
}


static void fts5SegIterHashInit(
	Fts5Index *p,                   
	const u8 *pTerm, int nTerm,     
	int flags,                      
	Fts5SegIter *pIter              
) {
	const u8 *pList = 0;
	int nList = 0;
	const u8 *z = 0;
	int n = 0;

	assert(p->pHash);
	assert(p->rc == SQLITE_OK);

	if (pTerm == 0 || (flags & FTS5INDEX_QUERY_SCAN)) {
		p->rc = sqlite3Fts5HashScanInit(p->pHash, (const char*)pTerm, nTerm);
		sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);
		n = (z ? (int)strlen((const char*)z) : 0);
	}
	else {
		pIter->flags |= FTS5_SEGITER_ONETERM;
		sqlite3Fts5HashQuery(p->pHash, (const char*)pTerm, nTerm, &pList, &nList);
		z = pTerm;
		n = nTerm;
	}

	if (pList) {
		Fts5Data *pLeaf;
		sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);
		pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));
		if (pLeaf == 0) return;
		pLeaf->p = (u8*)pList;
		pLeaf->nn = pLeaf->szLeaf = nList;
		pIter->pLeaf = pLeaf;
		pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);
		pIter->iEndofDoclist = pLeaf->nn;

		if (flags & FTS5INDEX_QUERY_DESC) {
			pIter->flags |= FTS5_SEGITER_REVERSE;
			fts5SegIterReverseInitPage(p, pIter);
		}
		else {
			fts5SegIterLoadNPos(p, pIter);
		}
	}

	fts5SegIterSetNext(p, pIter);
}


static void fts5SegIterClear(Fts5SegIter *pIter) {
	fts5BufferFree(&pIter->term);
	fts5DataRelease(pIter->pLeaf);
	fts5DataRelease(pIter->pNextLeaf);
	fts5DlidxIterFree(pIter->pDlidx);
	sqlite3_free(pIter->aRowidOffset);
	memset(pIter, 0, sizeof(Fts5SegIter));
}

#ifdef SQLITE_DEBUG


static void fts5AssertComparisonResult(
	Fts5Iter *pIter,
	Fts5SegIter *p1,
	Fts5SegIter *p2,
	Fts5CResult *pRes
) {
	int i1 = p1 - pIter->aSeg;
	int i2 = p2 - pIter->aSeg;

	if (p1->pLeaf || p2->pLeaf) {
		if (p1->pLeaf == 0) {
			assert(pRes->iFirst == i2);
		}
		else if (p2->pLeaf == 0) {
			assert(pRes->iFirst == i1);
		}
		else {
			int nMin = MIN(p1->term.n, p2->term.n);
			int res = memcmp(p1->term.p, p2->term.p, nMin);
			if (res == 0) res = p1->term.n - p2->term.n;

			if (res == 0) {
				assert(pRes->bTermEq == 1);
				assert(p1->iRowid != p2->iRowid);
				res = ((p1->iRowid > p2->iRowid) == pIter->bRev) ? -1 : 1;
			}
			else {
				assert(pRes->bTermEq == 0);
			}

			if (res<0) {
				assert(pRes->iFirst == i1);
			}
			else {
				assert(pRes->iFirst == i2);
			}
		}
	}
}


static void fts5AssertMultiIterSetup(Fts5Index *p, Fts5Iter *pIter) {
	if (p->rc == SQLITE_OK) {
		Fts5SegIter *pFirst = &pIter->aSeg[pIter->aFirst[1].iFirst];
		int i;

		assert((pFirst->pLeaf == 0) == pIter->base.bEof);

		
		for (i = 0; i<pIter->nSeg; i++) {
			Fts5SegIter *p1 = &pIter->aSeg[i];
			assert(p1 == pFirst
				|| p1->pLeaf == 0
				|| fts5BufferCompare(&pFirst->term, &p1->term)
				|| p1->iRowid == pIter->iSwitchRowid
				|| (p1->iRowid<pIter->iSwitchRowid) == pIter->bRev
			);
		}

		for (i = 0; i<pIter->nSeg; i += 2) {
			Fts5SegIter *p1 = &pIter->aSeg[i];
			Fts5SegIter *p2 = &pIter->aSeg[i + 1];
			Fts5CResult *pRes = &pIter->aFirst[(pIter->nSeg + i) / 2];
			fts5AssertComparisonResult(pIter, p1, p2, pRes);
		}

		for (i = 1; i<(pIter->nSeg / 2); i += 2) {
			Fts5SegIter *p1 = &pIter->aSeg[pIter->aFirst[i * 2].iFirst];
			Fts5SegIter *p2 = &pIter->aSeg[pIter->aFirst[i * 2 + 1].iFirst];
			Fts5CResult *pRes = &pIter->aFirst[i];
			fts5AssertComparisonResult(pIter, p1, p2, pRes);
		}
	}
}
#else
# define fts5AssertMultiIterSetup(x,y)
#endif


static int fts5MultiIterDoCompare(Fts5Iter *pIter, int iOut) {
	int i1;                         
	int i2;                         
	int iRes;
	Fts5SegIter *p1;                
	Fts5SegIter *p2;                
	Fts5CResult *pRes = &pIter->aFirst[iOut];

	assert(iOut<pIter->nSeg && iOut>0);
	assert(pIter->bRev == 0 || pIter->bRev == 1);

	if (iOut >= (pIter->nSeg / 2)) {
		i1 = (iOut - pIter->nSeg / 2) * 2;
		i2 = i1 + 1;
	}
	else {
		i1 = pIter->aFirst[iOut * 2].iFirst;
		i2 = pIter->aFirst[iOut * 2 + 1].iFirst;
	}
	p1 = &pIter->aSeg[i1];
	p2 = &pIter->aSeg[i2];

	pRes->bTermEq = 0;
	if (p1->pLeaf == 0) {           
		iRes = i2;
	}
	else if (p2->pLeaf == 0) {     
		iRes = i1;
	}
	else {
		int res = fts5BufferCompare(&p1->term, &p2->term);
		if (res == 0) {
			assert(i2>i1);
			assert(i2 != 0);
			pRes->bTermEq = 1;
			if (p1->iRowid == p2->iRowid) {
				p1->bDel = p2->bDel;
				return i2;
			}
			res = ((p1->iRowid > p2->iRowid) == pIter->bRev) ? -1 : +1;
		}
		assert(res != 0);
		if (res<0) {
			iRes = i1;
		}
		else {
			iRes = i2;
		}
	}

	pRes->iFirst = (u16)iRes;
	return 0;
}


static void fts5SegIterGotoPage(
	Fts5Index *p,                   
	Fts5SegIter *pIter,             
	int iLeafPgno
) {
	assert(iLeafPgno>pIter->iLeafPgno);

	if (iLeafPgno>pIter->pSeg->pgnoLast) {
		p->rc = FTS5_CORRUPT;
	}
	else {
		fts5DataRelease(pIter->pNextLeaf);
		pIter->pNextLeaf = 0;
		pIter->iLeafPgno = iLeafPgno - 1;
		fts5SegIterNextPage(p, pIter);
		assert(p->rc != SQLITE_OK || pIter->iLeafPgno == iLeafPgno);

		if (p->rc == SQLITE_OK) {
			int iOff;
			u8 *a = pIter->pLeaf->p;
			int n = pIter->pLeaf->szLeaf;

			iOff = fts5LeafFirstRowidOff(pIter->pLeaf);
			if (iOff<4 || iOff >= n) {
				p->rc = FTS5_CORRUPT;
			}
			else {
				iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
				pIter->iLeafOffset = iOff;
				fts5SegIterLoadNPos(p, pIter);
			}
		}
	}
}


static void fts5SegIterNextFrom(
	Fts5Index *p,                   
	Fts5SegIter *pIter,             
	i64 iMatch                      
) {
	int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
	Fts5DlidxIter *pDlidx = pIter->pDlidx;
	int iLeafPgno = pIter->iLeafPgno;
	int bMove = 1;

	assert(pIter->flags & FTS5_SEGITER_ONETERM);
	assert(pIter->pDlidx);
	assert(pIter->pLeaf);

	if (bRev == 0) {
		while (!fts5DlidxIterEof(p, pDlidx) && iMatch>fts5DlidxIterRowid(pDlidx)) {
			iLeafPgno = fts5DlidxIterPgno(pDlidx);
			fts5DlidxIterNext(p, pDlidx);
		}
		assert_nc(iLeafPgno >= pIter->iLeafPgno || p->rc);
		if (iLeafPgno>pIter->iLeafPgno) {
			fts5SegIterGotoPage(p, pIter, iLeafPgno);
			bMove = 0;
		}
	}
	else {
		assert(pIter->pNextLeaf == 0);
		assert(iMatch<pIter->iRowid);
		while (!fts5DlidxIterEof(p, pDlidx) && iMatch<fts5DlidxIterRowid(pDlidx)) {
			fts5DlidxIterPrev(p, pDlidx);
		}
		iLeafPgno = fts5DlidxIterPgno(pDlidx);

		assert(fts5DlidxIterEof(p, pDlidx) || iLeafPgno <= pIter->iLeafPgno);

		if (iLeafPgno<pIter->iLeafPgno) {
			pIter->iLeafPgno = iLeafPgno + 1;
			fts5SegIterReverseNewPage(p, pIter);
			bMove = 0;
		}
	}

	do {
		if (bMove && p->rc == SQLITE_OK) pIter->xNext(p, pIter, 0);
		if (pIter->pLeaf == 0) break;
		if (bRev == 0 && pIter->iRowid >= iMatch) break;
		if (bRev != 0 && pIter->iRowid <= iMatch) break;
		bMove = 1;
	} while (p->rc == SQLITE_OK);
}



static void fts5MultiIterFree(Fts5Iter *pIter) {
	if (pIter) {
		int i;
		for (i = 0; i<pIter->nSeg; i++) {
			fts5SegIterClear(&pIter->aSeg[i]);
		}
		fts5StructureRelease(pIter->pStruct);
		fts5BufferFree(&pIter->poslist);
		sqlite3_free(pIter);
	}
}

static void fts5MultiIterAdvanced(
	Fts5Index *p,                   
	Fts5Iter *pIter,                
	int iChanged,                   
	int iMinset                     
) {
	int i;
	for (i = (pIter->nSeg + iChanged) / 2; i >= iMinset && p->rc == SQLITE_OK; i = i / 2) {
		int iEq;
		if ((iEq = fts5MultiIterDoCompare(pIter, i))) {
			Fts5SegIter *pSeg = &pIter->aSeg[iEq];
			assert(p->rc == SQLITE_OK);
			pSeg->xNext(p, pSeg, 0);
			i = pIter->nSeg + iEq;
		}
	}
}


static int fts5MultiIterAdvanceRowid(
	Fts5Iter *pIter,                
	int iChanged,                   
	Fts5SegIter **ppFirst
) {
	Fts5SegIter *pNew = &pIter->aSeg[iChanged];

	if (pNew->iRowid == pIter->iSwitchRowid
		|| (pNew->iRowid<pIter->iSwitchRowid) == pIter->bRev
		) {
		int i;
		Fts5SegIter *pOther = &pIter->aSeg[iChanged ^ 0x0001];
		pIter->iSwitchRowid = pIter->bRev ? SMALLEST_INT64 : LARGEST_INT64;
		for (i = (pIter->nSeg + iChanged) / 2; 1; i = i / 2) {
			Fts5CResult *pRes = &pIter->aFirst[i];

			assert(pNew->pLeaf);
			assert(pRes->bTermEq == 0 || pOther->pLeaf);

			if (pRes->bTermEq) {
				if (pNew->iRowid == pOther->iRowid) {
					return 1;
				}
				else if ((pOther->iRowid>pNew->iRowid) == pIter->bRev) {
					pIter->iSwitchRowid = pOther->iRowid;
					pNew = pOther;
				}
				else if ((pOther->iRowid>pIter->iSwitchRowid) == pIter->bRev) {
					pIter->iSwitchRowid = pOther->iRowid;
				}
			}
			pRes->iFirst = (u16)(pNew - pIter->aSeg);
			if (i == 1) break;

			pOther = &pIter->aSeg[pIter->aFirst[i ^ 0x0001].iFirst];
		}
	}

	*ppFirst = pNew;
	return 0;
}


static void fts5MultiIterSetEof(Fts5Iter *pIter) {
	Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
	pIter->base.bEof = pSeg->pLeaf == 0;
	pIter->iSwitchRowid = pSeg->iRowid;
}


static void fts5MultiIterNext(
	Fts5Index *p,
	Fts5Iter *pIter,
	int bFrom,                      
	i64 iFrom                       
) {
	int bUseFrom = bFrom;
	assert(pIter->base.bEof == 0);
	while (p->rc == SQLITE_OK) {
		int iFirst = pIter->aFirst[1].iFirst;
		int bNewTerm = 0;
		Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
		assert(p->rc == SQLITE_OK);
		if (bUseFrom && pSeg->pDlidx) {
			fts5SegIterNextFrom(p, pSeg, iFrom);
		}
		else {
			pSeg->xNext(p, pSeg, &bNewTerm);
		}

		if (pSeg->pLeaf == 0 || bNewTerm
			|| fts5MultiIterAdvanceRowid(pIter, iFirst, &pSeg)
			) {
			fts5MultiIterAdvanced(p, pIter, iFirst, 1);
			fts5MultiIterSetEof(pIter);
			pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
			if (pSeg->pLeaf == 0) return;
		}

		fts5AssertMultiIterSetup(p, pIter);
		assert(pSeg == &pIter->aSeg[pIter->aFirst[1].iFirst] && pSeg->pLeaf);
		if (pIter->bSkipEmpty == 0 || pSeg->nPos) {
			pIter->xSetOutputs(pIter, pSeg);
			return;
		}
		bUseFrom = 0;
	}
}

static void fts5MultiIterNext2(
	Fts5Index *p,
	Fts5Iter *pIter,
	int *pbNewTerm                  
) {
	assert(pIter->bSkipEmpty);
	if (p->rc == SQLITE_OK) {
		do {
			int iFirst = pIter->aFirst[1].iFirst;
			Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
			int bNewTerm = 0;

			assert(p->rc == SQLITE_OK);
			pSeg->xNext(p, pSeg, &bNewTerm);
			if (pSeg->pLeaf == 0 || bNewTerm
				|| fts5MultiIterAdvanceRowid(pIter, iFirst, &pSeg)
				) {
				fts5MultiIterAdvanced(p, pIter, iFirst, 1);
				fts5MultiIterSetEof(pIter);
				*pbNewTerm = 1;
			}
			else {
				*pbNewTerm = 0;
			}
			fts5AssertMultiIterSetup(p, pIter);

		} while (fts5MultiIterIsEmpty(p, pIter));
	}
}

static void fts5IterSetOutputs_Noop(Fts5Iter *pUnused1, Fts5SegIter *pUnused2) {
	UNUSED_PARAM2(pUnused1, pUnused2);
}

static Fts5Iter *fts5MultiIterAlloc(
	Fts5Index *p,                   
	int nSeg
) {
	Fts5Iter *pNew;
	int nSlot;                      

	for (nSlot = 2; nSlot<nSeg; nSlot = nSlot * 2);
	pNew = fts5IdxMalloc(p,
		sizeof(Fts5Iter) +                  
		sizeof(Fts5SegIter) * (nSlot - 1) +   
		sizeof(Fts5CResult) * nSlot         
	);
	if (pNew) {
		pNew->nSeg = nSlot;
		pNew->aFirst = (Fts5CResult*)&pNew->aSeg[nSlot];
		pNew->pIndex = p;
		pNew->xSetOutputs = fts5IterSetOutputs_Noop;
	}
	return pNew;
}

static void fts5PoslistCallback(
	Fts5Index *pUnused,
	void *pContext,
	const u8 *pChunk, int nChunk
) {
	UNUSED_PARAM(pUnused);
	assert_nc(nChunk >= 0);
	if (nChunk>0) {
		fts5BufferSafeAppendBlob((Fts5Buffer*)pContext, pChunk, nChunk);
	}
}

typedef struct PoslistCallbackCtx PoslistCallbackCtx;
struct PoslistCallbackCtx {
	Fts5Buffer *pBuf;               
	Fts5Colset *pColset;            
	int eState;                     
};

typedef struct PoslistOffsetsCtx PoslistOffsetsCtx;
struct PoslistOffsetsCtx {
	Fts5Buffer *pBuf;               
	Fts5Colset *pColset;            
	int iRead;
	int iWrite;
};


static int fts5IndexColsetTest(Fts5Colset *pColset, int iCol) {
	int i;
	for (i = 0; i<pColset->nCol; i++) {
		if (pColset->aiCol[i] == iCol) return 1;
	}
	return 0;
}

static void fts5PoslistOffsetsCallback(
	Fts5Index *pUnused,
	void *pContext,
	const u8 *pChunk, int nChunk
) {
	PoslistOffsetsCtx *pCtx = (PoslistOffsetsCtx*)pContext;
	UNUSED_PARAM(pUnused);
	assert_nc(nChunk >= 0);
	if (nChunk>0) {
		int i = 0;
		while (i<nChunk) {
			int iVal;
			i += fts5GetVarint32(&pChunk[i], iVal);
			iVal += pCtx->iRead - 2;
			pCtx->iRead = iVal;
			if (fts5IndexColsetTest(pCtx->pColset, iVal)) {
				fts5BufferSafeAppendVarint(pCtx->pBuf, iVal + 2 - pCtx->iWrite);
				pCtx->iWrite = iVal;
			}
		}
	}
}

static void fts5PoslistFilterCallback(
	Fts5Index *pUnused,
	void *pContext,
	const u8 *pChunk, int nChunk
) {
	PoslistCallbackCtx *pCtx = (PoslistCallbackCtx*)pContext;
	UNUSED_PARAM(pUnused);
	assert_nc(nChunk >= 0);
	if (nChunk>0) {
		
		int i = 0;
		int iStart = 0;

		if (pCtx->eState == 2) {
			int iCol;
			fts5FastGetVarint32(pChunk, i, iCol);
			if (fts5IndexColsetTest(pCtx->pColset, iCol)) {
				pCtx->eState = 1;
				fts5BufferSafeAppendVarint(pCtx->pBuf, 1);
			}
			else {
				pCtx->eState = 0;
			}
		}

		do {
			while (i<nChunk && pChunk[i] != 0x01) {
				while (pChunk[i] & 0x80) i++;
				i++;
			}
			if (pCtx->eState) {
				fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i - iStart);
			}
			if (i<nChunk) {
				int iCol;
				iStart = i;
				i++;
				if (i >= nChunk) {
					pCtx->eState = 2;
				}
				else {
					fts5FastGetVarint32(pChunk, i, iCol);
					pCtx->eState = fts5IndexColsetTest(pCtx->pColset, iCol);
					if (pCtx->eState) {
						fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i - iStart);
						iStart = i;
					}
				}
			}
		} while (i<nChunk);
	}
}

static void fts5ChunkIterate(
	Fts5Index *p,                   
	Fts5SegIter *pSeg,              
	void *pCtx,                     
	void(*xChunk)(Fts5Index*, void*, const u8*, int)
) {
	int nRem = pSeg->nPos;          
	Fts5Data *pData = 0;
	u8 *pChunk = &pSeg->pLeaf->p[pSeg->iLeafOffset];
	int nChunk = MIN(nRem, pSeg->pLeaf->szLeaf - pSeg->iLeafOffset);
	int pgno = pSeg->iLeafPgno;
	int pgnoSave = 0;

	
	assert(p->pConfig->eDetail != FTS5_DETAIL_NONE);

	if ((pSeg->flags & FTS5_SEGITER_REVERSE) == 0) {
		pgnoSave = pgno + 1;
	}

	while (1) {
		xChunk(p, pCtx, pChunk, nChunk);
		nRem -= nChunk;
		fts5DataRelease(pData);
		if (nRem <= 0) {
			break;
		}
		else {
			pgno++;
			pData = fts5DataRead(p, FTS5_SEGMENT_ROWID(pSeg->pSeg->iSegid, pgno));
			if (pData == 0) break;
			pChunk = &pData->p[4];
			nChunk = MIN(nRem, pData->szLeaf - 4);
			if (pgno == pgnoSave) {
				assert(pSeg->pNextLeaf == 0);
				pSeg->pNextLeaf = pData;
				pData = 0;
			}
		}
	}
}


static void fts5SegiterPoslist(
	Fts5Index *p,
	Fts5SegIter *pSeg,
	Fts5Colset *pColset,
	Fts5Buffer *pBuf
) {
	if (0 == fts5BufferGrow(&p->rc, pBuf, pSeg->nPos)) {
		if (pColset == 0) {
			fts5ChunkIterate(p, pSeg, (void*)pBuf, fts5PoslistCallback);
		}
		else {
			if (p->pConfig->eDetail == FTS5_DETAIL_FULL) {
				PoslistCallbackCtx sCtx;
				sCtx.pBuf = pBuf;
				sCtx.pColset = pColset;
				sCtx.eState = fts5IndexColsetTest(pColset, 0);
				assert(sCtx.eState == 0 || sCtx.eState == 1);
				fts5ChunkIterate(p, pSeg, (void*)&sCtx, fts5PoslistFilterCallback);
			}
			else {
				PoslistOffsetsCtx sCtx;
				memset(&sCtx, 0, sizeof(sCtx));
				sCtx.pBuf = pBuf;
				sCtx.pColset = pColset;
				fts5ChunkIterate(p, pSeg, (void*)&sCtx, fts5PoslistOffsetsCallback);
			}
		}
	}
}


static int fts5IndexExtractCol(
	const u8 **pa,                  
	int n,                          
	int iCol                        
) {
	int iCurrent = 0;               
	const u8 *p = *pa;
	const u8 *pEnd = &p[n];         

	while (iCol>iCurrent) {
		
		while (*p != 0x01) {
			while (*p++ & 0x80);
			if (p >= pEnd) return 0;
		}
		*pa = p++;
		iCurrent = *p++;
		if (iCurrent & 0x80) {
			p--;
			p += fts5GetVarint32(p, iCurrent);
		}
	}
	if (iCol != iCurrent) return 0;

	
	while (p<pEnd && *p != 0x01) {
		while (*p++ & 0x80);
	}

	return p - (*pa);
}

static int fts5IndexExtractColset(
	Fts5Colset *pColset,            
	const u8 *pPos, int nPos,       
	Fts5Buffer *pBuf                
) {
	int rc = SQLITE_OK;
	int i;

	fts5BufferZero(pBuf);
	for (i = 0; i<pColset->nCol; i++) {
		const u8 *pSub = pPos;
		int nSub = fts5IndexExtractCol(&pSub, nPos, pColset->aiCol[i]);
		if (nSub) {
			fts5BufferAppendBlob(&rc, pBuf, nSub, pSub);
		}
	}
	return rc;
}


static void fts5IterSetOutputs_None(Fts5Iter *pIter, Fts5SegIter *pSeg) {
	assert(pIter->pIndex->pConfig->eDetail == FTS5_DETAIL_NONE);
	pIter->base.iRowid = pSeg->iRowid;
	pIter->base.nData = pSeg->nPos;
}


static void fts5IterSetOutputs_Nocolset(Fts5Iter *pIter, Fts5SegIter *pSeg) {
	pIter->base.iRowid = pSeg->iRowid;
	pIter->base.nData = pSeg->nPos;

	assert(pIter->pIndex->pConfig->eDetail != FTS5_DETAIL_NONE);
	assert(pIter->pColset == 0);

	if (pSeg->iLeafOffset + pSeg->nPos <= pSeg->pLeaf->szLeaf) {
		
		pIter->base.pData = &pSeg->pLeaf->p[pSeg->iLeafOffset];
	}
	else {
		
		fts5BufferZero(&pIter->poslist);
		fts5SegiterPoslist(pIter->pIndex, pSeg, 0, &pIter->poslist);
		pIter->base.pData = pIter->poslist.p;
	}
}


static void fts5IterSetOutputs_ZeroColset(Fts5Iter *pIter, Fts5SegIter *pSeg) {
	UNUSED_PARAM(pSeg);
	pIter->base.nData = 0;
}


static void fts5IterSetOutputs_Col(Fts5Iter *pIter, Fts5SegIter *pSeg) {
	fts5BufferZero(&pIter->poslist);
	fts5SegiterPoslist(pIter->pIndex, pSeg, pIter->pColset, &pIter->poslist);
	pIter->base.iRowid = pSeg->iRowid;
	pIter->base.pData = pIter->poslist.p;
	pIter->base.nData = pIter->poslist.n;
}


static void fts5IterSetOutputs_Col100(Fts5Iter *pIter, Fts5SegIter *pSeg) {

	assert(pIter->pIndex->pConfig->eDetail == FTS5_DETAIL_COLUMNS);
	assert(pIter->pColset);

	if (pSeg->iLeafOffset + pSeg->nPos>pSeg->pLeaf->szLeaf) {
		fts5IterSetOutputs_Col(pIter, pSeg);
	}
	else {
		u8 *a = (u8*)&pSeg->pLeaf->p[pSeg->iLeafOffset];
		u8 *pEnd = (u8*)&a[pSeg->nPos];
		int iPrev = 0;
		int *aiCol = pIter->pColset->aiCol;
		int *aiColEnd = &aiCol[pIter->pColset->nCol];

		u8 *aOut = pIter->poslist.p;
		int iPrevOut = 0;

		pIter->base.iRowid = pSeg->iRowid;

		while (a<pEnd) {
			iPrev += (int)a++[0] - 2;
			while (*aiCol<iPrev) {
				aiCol++;
				if (aiCol == aiColEnd) goto setoutputs_col_out;
			}
			if (*aiCol == iPrev) {
				*aOut++ = (u8)((iPrev - iPrevOut) + 2);
				iPrevOut = iPrev;
			}
		}

	setoutputs_col_out:
		pIter->base.pData = pIter->poslist.p;
		pIter->base.nData = aOut - pIter->poslist.p;
	}
}


static void fts5IterSetOutputs_Full(Fts5Iter *pIter, Fts5SegIter *pSeg) {
	Fts5Colset *pColset = pIter->pColset;
	pIter->base.iRowid = pSeg->iRowid;

	assert(pIter->pIndex->pConfig->eDetail == FTS5_DETAIL_FULL);
	assert(pColset);

	if (pSeg->iLeafOffset + pSeg->nPos <= pSeg->pLeaf->szLeaf) {
		
		const u8 *a = &pSeg->pLeaf->p[pSeg->iLeafOffset];
		if (pColset->nCol == 1) {
			pIter->base.nData = fts5IndexExtractCol(&a, pSeg->nPos, pColset->aiCol[0]);
			pIter->base.pData = a;
		}
		else {
			fts5BufferZero(&pIter->poslist);
			fts5IndexExtractColset(pColset, a, pSeg->nPos, &pIter->poslist);
			pIter->base.pData = pIter->poslist.p;
			pIter->base.nData = pIter->poslist.n;
		}
	}
	else {
		
		fts5BufferZero(&pIter->poslist);
		fts5SegiterPoslist(pIter->pIndex, pSeg, pColset, &pIter->poslist);
		pIter->base.pData = pIter->poslist.p;
		pIter->base.nData = pIter->poslist.n;
	}
}

static void fts5IterSetOutputCb(int *pRc, Fts5Iter *pIter) {
	if (*pRc == SQLITE_OK) {
		Fts5Config *pConfig = pIter->pIndex->pConfig;
		if (pConfig->eDetail == FTS5_DETAIL_NONE) {
			pIter->xSetOutputs = fts5IterSetOutputs_None;
		}

		else if (pIter->pColset == 0) {
			pIter->xSetOutputs = fts5IterSetOutputs_Nocolset;
		}

		else if (pIter->pColset->nCol == 0) {
			pIter->xSetOutputs = fts5IterSetOutputs_ZeroColset;
		}

		else if (pConfig->eDetail == FTS5_DETAIL_FULL) {
			pIter->xSetOutputs = fts5IterSetOutputs_Full;
		}

		else {
			assert(pConfig->eDetail == FTS5_DETAIL_COLUMNS);
			if (pConfig->nCol <= 100) {
				pIter->xSetOutputs = fts5IterSetOutputs_Col100;
				sqlite3Fts5BufferSize(pRc, &pIter->poslist, pConfig->nCol);
			}
			else {
				pIter->xSetOutputs = fts5IterSetOutputs_Col;
			}
		}
	}
}



static void fts5MultiIterNew(
	Fts5Index *p,                   
	Fts5Structure *pStruct,         
	int flags,                      
	Fts5Colset *pColset,            
	const u8 *pTerm, int nTerm,     
	int iLevel,                     
	int nSegment,                   
	Fts5Iter **ppOut                
) {
	int nSeg = 0;                   
	int iIter = 0;                  
	int iSeg;                       
	Fts5StructureLevel *pLvl;
	Fts5Iter *pNew;

	assert((pTerm == 0 && nTerm == 0) || iLevel<0);

	
	if (p->rc == SQLITE_OK) {
		if (iLevel<0) {
			assert(pStruct->nSegment == fts5StructureCountSegments(pStruct));
			nSeg = pStruct->nSegment;
			nSeg += (p->pHash ? 1 : 0);
		}
		else {
			nSeg = MIN(pStruct->aLevel[iLevel].nSeg, nSegment);
		}
	}
	*ppOut = pNew = fts5MultiIterAlloc(p, nSeg);
	if (pNew == 0) return;
	pNew->bRev = (0 != (flags & FTS5INDEX_QUERY_DESC));
	pNew->bSkipEmpty = (0 != (flags & FTS5INDEX_QUERY_SKIPEMPTY));
	pNew->pStruct = pStruct;
	pNew->pColset = pColset;
	fts5StructureRef(pStruct);
	if ((flags & FTS5INDEX_QUERY_NOOUTPUT) == 0) {
		fts5IterSetOutputCb(&p->rc, pNew);
	}

	
	if (p->rc == SQLITE_OK) {
		if (iLevel<0) {
			Fts5StructureLevel *pEnd = &pStruct->aLevel[pStruct->nLevel];
			if (p->pHash) {
				
				Fts5SegIter *pIter = &pNew->aSeg[iIter++];
				fts5SegIterHashInit(p, pTerm, nTerm, flags, pIter);
			}
			for (pLvl = &pStruct->aLevel[0]; pLvl<pEnd; pLvl++) {
				for (iSeg = pLvl->nSeg - 1; iSeg >= 0; iSeg--) {
					Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];
					Fts5SegIter *pIter = &pNew->aSeg[iIter++];
					if (pTerm == 0) {
						fts5SegIterInit(p, pSeg, pIter);
					}
					else {
						fts5SegIterSeekInit(p, pTerm, nTerm, flags, pSeg, pIter);
					}
				}
			}
		}
		else {
			pLvl = &pStruct->aLevel[iLevel];
			for (iSeg = nSeg - 1; iSeg >= 0; iSeg--) {
				fts5SegIterInit(p, &pLvl->aSeg[iSeg], &pNew->aSeg[iIter++]);
			}
		}
		assert(iIter == nSeg);
	}

	
	if (p->rc == SQLITE_OK) {
		for (iIter = pNew->nSeg - 1; iIter>0; iIter--) {
			int iEq;
			if ((iEq = fts5MultiIterDoCompare(pNew, iIter))) {
				Fts5SegIter *pSeg = &pNew->aSeg[iEq];
				if (p->rc == SQLITE_OK) pSeg->xNext(p, pSeg, 0);
				fts5MultiIterAdvanced(p, pNew, iEq, iIter);
			}
		}
		fts5MultiIterSetEof(pNew);
		fts5AssertMultiIterSetup(p, pNew);

		if (pNew->bSkipEmpty && fts5MultiIterIsEmpty(p, pNew)) {
			fts5MultiIterNext(p, pNew, 0, 0);
		}
		else if (pNew->base.bEof == 0) {
			Fts5SegIter *pSeg = &pNew->aSeg[pNew->aFirst[1].iFirst];
			pNew->xSetOutputs(pNew, pSeg);
		}

	}
	else {
		fts5MultiIterFree(pNew);
		*ppOut = 0;
	}
}


static void fts5MultiIterNew2(
	Fts5Index *p,                   
	Fts5Data *pData,                
	int bDesc,                      
	Fts5Iter **ppOut                
) {
	Fts5Iter *pNew;
	pNew = fts5MultiIterAlloc(p, 2);
	if (pNew) {
		Fts5SegIter *pIter = &pNew->aSeg[1];

		pIter->flags = FTS5_SEGITER_ONETERM;
		if (pData->szLeaf>0) {
			pIter->pLeaf = pData;
			pIter->iLeafOffset = fts5GetVarint(pData->p, (u64*)&pIter->iRowid);
			pIter->iEndofDoclist = pData->nn;
			pNew->aFirst[1].iFirst = 1;
			if (bDesc) {
				pNew->bRev = 1;
				pIter->flags |= FTS5_SEGITER_REVERSE;
				fts5SegIterReverseInitPage(p, pIter);
			}
			else {
				fts5SegIterLoadNPos(p, pIter);
			}
			pData = 0;
		}
		else {
			pNew->base.bEof = 1;
		}
		fts5SegIterSetNext(p, pIter);

		*ppOut = pNew;
	}

	fts5DataRelease(pData);
}


static int fts5MultiIterEof(Fts5Index *p, Fts5Iter *pIter) {
	assert(p->rc
		|| (pIter->aSeg[pIter->aFirst[1].iFirst].pLeaf == 0) == pIter->base.bEof
	);
	return (p->rc || pIter->base.bEof);
}


static i64 fts5MultiIterRowid(Fts5Iter *pIter) {
	assert(pIter->aSeg[pIter->aFirst[1].iFirst].pLeaf);
	return pIter->aSeg[pIter->aFirst[1].iFirst].iRowid;
}


static void fts5MultiIterNextFrom(
	Fts5Index *p,
	Fts5Iter *pIter,
	i64 iMatch
) {
	while (1) {
		i64 iRowid;
		fts5MultiIterNext(p, pIter, 1, iMatch);
		if (fts5MultiIterEof(p, pIter)) break;
		iRowid = fts5MultiIterRowid(pIter);
		if (pIter->bRev == 0 && iRowid >= iMatch) break;
		if (pIter->bRev != 0 && iRowid <= iMatch) break;
	}
}


static const u8 *fts5MultiIterTerm(Fts5Iter *pIter, int *pn) {
	Fts5SegIter *p = &pIter->aSeg[pIter->aFirst[1].iFirst];
	*pn = p->term.n;
	return p->term.p;
}


static int fts5AllocateSegid(Fts5Index *p, Fts5Structure *pStruct) {
	int iSegid = 0;

	if (p->rc == SQLITE_OK) {
		if (pStruct->nSegment >= FTS5_MAX_SEGMENT) {
			p->rc = SQLITE_FULL;
		}
		else {
			
			u32 aUsed[(FTS5_MAX_SEGMENT + 31) / 32];
			int iLvl, iSeg;
			int i;
			u32 mask;
			memset(aUsed, 0, sizeof(aUsed));
			for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
				for (iSeg = 0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++) {
					int iId = pStruct->aLevel[iLvl].aSeg[iSeg].iSegid;
					if (iId <= FTS5_MAX_SEGMENT) {
						aUsed[(iId - 1) / 32] |= 1 << ((iId - 1) % 32);
					}
				}
			}

			for (i = 0; aUsed[i] == 0xFFFFFFFF; i++);
			mask = aUsed[i];
			for (iSegid = 0; mask & (1 << iSegid); iSegid++);
			iSegid += 1 + i * 32;

#ifdef SQLITE_DEBUG
			for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
				for (iSeg = 0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++) {
					assert(iSegid != pStruct->aLevel[iLvl].aSeg[iSeg].iSegid);
				}
			}
			assert(iSegid>0 && iSegid <= FTS5_MAX_SEGMENT);

			{
				sqlite3_stmt *pIdxSelect = fts5IdxSelectStmt(p);
				if (p->rc == SQLITE_OK) {
					u8 aBlob[2] = { 0xff, 0xff };
					sqlite3_bind_int(pIdxSelect, 1, iSegid);
					sqlite3_bind_blob(pIdxSelect, 2, aBlob, 2, SQLITE_STATIC);
					assert(sqlite3_step(pIdxSelect) != SQLITE_ROW);
					p->rc = sqlite3_reset(pIdxSelect);
				}
			}
#endif
		}
	}

	return iSegid;
}


static void fts5IndexDiscardData(Fts5Index *p) {
	assert(p->pHash || p->nPendingData == 0);
	if (p->pHash) {
		sqlite3Fts5HashClear(p->pHash);
		p->nPendingData = 0;
	}
}


static int fts5PrefixCompress(int nOld, const u8 *pOld, const u8 *pNew) {
	int i;
	for (i = 0; i<nOld; i++) {
		if (pOld[i] != pNew[i]) break;
	}
	return i;
}

static void fts5WriteDlidxClear(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	int bFlush                      
) {
	int i;
	assert(bFlush == 0 || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n>0));
	for (i = 0; i<pWriter->nDlidx; i++) {
		Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];
		if (pDlidx->buf.n == 0) break;
		if (bFlush) {
			assert(pDlidx->pgno != 0);
			fts5DataWrite(p,
				FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
				pDlidx->buf.p, pDlidx->buf.n
			);
		}
		sqlite3Fts5BufferZero(&pDlidx->buf);
		pDlidx->bPrevValid = 0;
	}
}


static int fts5WriteDlidxGrow(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	int nLvl
) {
	if (p->rc == SQLITE_OK && nLvl >= pWriter->nDlidx) {
		Fts5DlidxWriter *aDlidx = (Fts5DlidxWriter*)sqlite3_realloc(
			pWriter->aDlidx, sizeof(Fts5DlidxWriter) * nLvl
		);
		if (aDlidx == 0) {
			p->rc = SQLITE_NOMEM;
		}
		else {
			int nByte = sizeof(Fts5DlidxWriter) * (nLvl - pWriter->nDlidx);
			memset(&aDlidx[pWriter->nDlidx], 0, nByte);
			pWriter->aDlidx = aDlidx;
			pWriter->nDlidx = nLvl;
		}
	}
	return p->rc;
}


static int fts5WriteFlushDlidx(Fts5Index *p, Fts5SegWriter *pWriter) {
	int bFlag = 0;

	
	if (pWriter->aDlidx[0].buf.n>0 && pWriter->nEmpty >= FTS5_MIN_DLIDX_SIZE) {
		bFlag = 1;
	}
	fts5WriteDlidxClear(p, pWriter, bFlag);
	pWriter->nEmpty = 0;
	return bFlag;
}


static void fts5WriteFlushBtree(Fts5Index *p, Fts5SegWriter *pWriter) {
	int bFlag;

	assert(pWriter->iBtPage || pWriter->nEmpty == 0);
	if (pWriter->iBtPage == 0) return;
	bFlag = fts5WriteFlushDlidx(p, pWriter);

	if (p->rc == SQLITE_OK) {
		const char *z = (pWriter->btterm.n>0 ? (const char*)pWriter->btterm.p : "");
		
		
		sqlite3_bind_blob(p->pIdxWriter, 2, z, pWriter->btterm.n, SQLITE_STATIC);
		sqlite3_bind_int64(p->pIdxWriter, 3, bFlag + ((i64)pWriter->iBtPage << 1));
		sqlite3_step(p->pIdxWriter);
		p->rc = sqlite3_reset(p->pIdxWriter);
	}
	pWriter->iBtPage = 0;
}


static void fts5WriteBtreeTerm(
	Fts5Index *p,                   
	Fts5SegWriter *pWriter,         
	int nTerm, const u8 *pTerm      
) {
	fts5WriteFlushBtree(p, pWriter);
	fts5BufferSet(&p->rc, &pWriter->btterm, nTerm, pTerm);
	pWriter->iBtPage = pWriter->writer.pgno;
}


static void fts5WriteBtreeNoTerm(
	Fts5Index *p,                   
	Fts5SegWriter *pWriter          
) {
	
	if (pWriter->bFirstRowidInPage && pWriter->aDlidx[0].buf.n>0) {
		Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[0];
		assert(pDlidx->bPrevValid);
		sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, 0);
	}

	
	pWriter->nEmpty++;
}

static i64 fts5DlidxExtractFirstRowid(Fts5Buffer *pBuf) {
	i64 iRowid;
	int iOff;

	iOff = 1 + fts5GetVarint(&pBuf->p[1], (u64*)&iRowid);
	fts5GetVarint(&pBuf->p[iOff], (u64*)&iRowid);
	return iRowid;
}


static void fts5WriteDlidxAppend(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	i64 iRowid
) {
	int i;
	int bDone = 0;

	for (i = 0; p->rc == SQLITE_OK && bDone == 0; i++) {
		i64 iVal;
		Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];

		if (pDlidx->buf.n >= p->pConfig->pgsz) {
			
			pDlidx->buf.p[0] = 0x01;    
			fts5DataWrite(p,
				FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
				pDlidx->buf.p, pDlidx->buf.n
			);
			fts5WriteDlidxGrow(p, pWriter, i + 2);
			pDlidx = &pWriter->aDlidx[i];
			if (p->rc == SQLITE_OK && pDlidx[1].buf.n == 0) {
				i64 iFirst = fts5DlidxExtractFirstRowid(&pDlidx->buf);

				
				pDlidx[1].pgno = pDlidx->pgno;
				sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, 0);
				sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, pDlidx->pgno);
				sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, iFirst);
				pDlidx[1].bPrevValid = 1;
				pDlidx[1].iPrev = iFirst;
			}

			sqlite3Fts5BufferZero(&pDlidx->buf);
			pDlidx->bPrevValid = 0;
			pDlidx->pgno++;
		}
		else {
			bDone = 1;
		}

		if (pDlidx->bPrevValid) {
			iVal = iRowid - pDlidx->iPrev;
		}
		else {
			i64 iPgno = (i == 0 ? pWriter->writer.pgno : pDlidx[-1].pgno);
			assert(pDlidx->buf.n == 0);
			sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, !bDone);
			sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iPgno);
			iVal = iRowid;
		}

		sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iVal);
		pDlidx->bPrevValid = 1;
		pDlidx->iPrev = iRowid;
	}
}

static void fts5WriteFlushLeaf(Fts5Index *p, Fts5SegWriter *pWriter) {
	static const u8 zero[] = { 0x00, 0x00, 0x00, 0x00 };
	Fts5PageWriter *pPage = &pWriter->writer;
	i64 iRowid;

	static int nCall = 0;
	nCall++;

	assert((pPage->pgidx.n == 0) == (pWriter->bFirstTermInPage));

	
	assert(0 == fts5GetU16(&pPage->buf.p[2]));
	fts5PutU16(&pPage->buf.p[2], (u16)pPage->buf.n);

	if (pWriter->bFirstTermInPage) {
		
		assert(pPage->pgidx.n == 0);
		fts5WriteBtreeNoTerm(p, pWriter);
	}
	else {
		
		fts5BufferAppendBlob(&p->rc, &pPage->buf, pPage->pgidx.n, pPage->pgidx.p);
	}

	
	iRowid = FTS5_SEGMENT_ROWID(pWriter->iSegid, pPage->pgno);
	fts5DataWrite(p, iRowid, pPage->buf.p, pPage->buf.n);

	
	fts5BufferZero(&pPage->buf);
	fts5BufferZero(&pPage->pgidx);
	fts5BufferAppendBlob(&p->rc, &pPage->buf, 4, zero);
	pPage->iPrevPgidx = 0;
	pPage->pgno++;

	
	pWriter->nLeafWritten++;

	
	pWriter->bFirstTermInPage = 1;
	pWriter->bFirstRowidInPage = 1;
}


static void fts5WriteAppendTerm(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	int nTerm, const u8 *pTerm
) {
	int nPrefix;                    
	Fts5PageWriter *pPage = &pWriter->writer;
	Fts5Buffer *pPgidx = &pWriter->writer.pgidx;

	assert(p->rc == SQLITE_OK);
	assert(pPage->buf.n >= 4);
	assert(pPage->buf.n>4 || pWriter->bFirstTermInPage);

	
	if ((pPage->buf.n + pPgidx->n + nTerm + 2) >= p->pConfig->pgsz) {
		if (pPage->buf.n>4) {
			fts5WriteFlushLeaf(p, pWriter);
		}
		fts5BufferGrow(&p->rc, &pPage->buf, nTerm + FTS5_DATA_PADDING);
	}

	
	pPgidx->n += sqlite3Fts5PutVarint(
		&pPgidx->p[pPgidx->n], pPage->buf.n - pPage->iPrevPgidx
	);
	pPage->iPrevPgidx = pPage->buf.n;
#if 0
	fts5PutU16(&pPgidx->p[pPgidx->n], pPage->buf.n);
	pPgidx->n += 2;
#endif

	if (pWriter->bFirstTermInPage) {
		nPrefix = 0;
		if (pPage->pgno != 1) {
			
			int n = nTerm;
			if (pPage->term.n) {
				n = 1 + fts5PrefixCompress(pPage->term.n, pPage->term.p, pTerm);
			}
			fts5WriteBtreeTerm(p, pWriter, n, pTerm);
			pPage = &pWriter->writer;
		}
	}
	else {
		nPrefix = fts5PrefixCompress(pPage->term.n, pPage->term.p, pTerm);
		fts5BufferAppendVarint(&p->rc, &pPage->buf, nPrefix);
	}

	
	fts5BufferAppendVarint(&p->rc, &pPage->buf, nTerm - nPrefix);
	fts5BufferAppendBlob(&p->rc, &pPage->buf, nTerm - nPrefix, &pTerm[nPrefix]);

	
	fts5BufferSet(&p->rc, &pPage->term, nTerm, pTerm);
	pWriter->bFirstTermInPage = 0;

	pWriter->bFirstRowidInPage = 0;
	pWriter->bFirstRowidInDoclist = 1;

	assert(p->rc || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n == 0));
	pWriter->aDlidx[0].pgno = pPage->pgno;
}


static void fts5WriteAppendRowid(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	i64 iRowid
) {
	if (p->rc == SQLITE_OK) {
		Fts5PageWriter *pPage = &pWriter->writer;

		if ((pPage->buf.n + pPage->pgidx.n) >= p->pConfig->pgsz) {
			fts5WriteFlushLeaf(p, pWriter);
		}

		
		if (pWriter->bFirstRowidInPage) {
			fts5PutU16(pPage->buf.p, (u16)pPage->buf.n);
			fts5WriteDlidxAppend(p, pWriter, iRowid);
		}

		
		if (pWriter->bFirstRowidInDoclist || pWriter->bFirstRowidInPage) {
			fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid);
		}
		else {
			assert(p->rc || iRowid>pWriter->iPrevRowid);
			fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid - pWriter->iPrevRowid);
		}
		pWriter->iPrevRowid = iRowid;
		pWriter->bFirstRowidInDoclist = 0;
		pWriter->bFirstRowidInPage = 0;
	}
}

static void fts5WriteAppendPoslistData(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	const u8 *aData,
	int nData
) {
	Fts5PageWriter *pPage = &pWriter->writer;
	const u8 *a = aData;
	int n = nData;

	assert(p->pConfig->pgsz>0);
	while (p->rc == SQLITE_OK
		&& (pPage->buf.n + pPage->pgidx.n + n) >= p->pConfig->pgsz
		) {
		int nReq = p->pConfig->pgsz - pPage->buf.n - pPage->pgidx.n;
		int nCopy = 0;
		while (nCopy<nReq) {
			i64 dummy;
			nCopy += fts5GetVarint(&a[nCopy], (u64*)&dummy);
		}
		fts5BufferAppendBlob(&p->rc, &pPage->buf, nCopy, a);
		a += nCopy;
		n -= nCopy;
		fts5WriteFlushLeaf(p, pWriter);
	}
	if (n>0) {
		fts5BufferAppendBlob(&p->rc, &pPage->buf, n, a);
	}
}


static void fts5WriteFinish(
	Fts5Index *p,
	Fts5SegWriter *pWriter,         
	int *pnLeaf                     
) {
	int i;
	Fts5PageWriter *pLeaf = &pWriter->writer;
	if (p->rc == SQLITE_OK) {
		assert(pLeaf->pgno >= 1);
		if (pLeaf->buf.n>4) {
			fts5WriteFlushLeaf(p, pWriter);
		}
		*pnLeaf = pLeaf->pgno - 1;
		if (pLeaf->pgno>1) {
			fts5WriteFlushBtree(p, pWriter);
		}
	}
	fts5BufferFree(&pLeaf->term);
	fts5BufferFree(&pLeaf->buf);
	fts5BufferFree(&pLeaf->pgidx);
	fts5BufferFree(&pWriter->btterm);

	for (i = 0; i<pWriter->nDlidx; i++) {
		sqlite3Fts5BufferFree(&pWriter->aDlidx[i].buf);
	}
	sqlite3_free(pWriter->aDlidx);
}

static void fts5WriteInit(
	Fts5Index *p,
	Fts5SegWriter *pWriter,
	int iSegid
) {
	const int nBuffer = p->pConfig->pgsz + FTS5_DATA_PADDING;

	memset(pWriter, 0, sizeof(Fts5SegWriter));
	pWriter->iSegid = iSegid;

	fts5WriteDlidxGrow(p, pWriter, 1);
	pWriter->writer.pgno = 1;
	pWriter->bFirstTermInPage = 1;
	pWriter->iBtPage = 1;

	assert(pWriter->writer.buf.n == 0);
	assert(pWriter->writer.pgidx.n == 0);

	
	sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.pgidx, nBuffer);
	sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.buf, nBuffer);

	if (p->pIdxWriter == 0) {
		Fts5Config *pConfig = p->pConfig;
		fts5IndexPrepareStmt(p, &p->pIdxWriter, sqlite3_mprintf(
			"INSERT INTO '%q'.'%q_idx'(segid,term,pgno) VALUES(?,?,?)",
			pConfig->zDb, pConfig->zName
		));
	}

	if (p->rc == SQLITE_OK) {
		
		memset(pWriter->writer.buf.p, 0, 4);
		pWriter->writer.buf.n = 4;

		
		sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid);
	}
}


static void fts5TrimSegments(Fts5Index *p, Fts5Iter *pIter) {
	int i;
	Fts5Buffer buf;
	memset(&buf, 0, sizeof(Fts5Buffer));
	for (i = 0; i<pIter->nSeg; i++) {
		Fts5SegIter *pSeg = &pIter->aSeg[i];
		if (pSeg->pSeg == 0) {
			
		}
		else if (pSeg->pLeaf == 0) {
			
			pSeg->pSeg->pgnoLast = 0;
			pSeg->pSeg->pgnoFirst = 0;
		}
		else {
			int iOff = pSeg->iTermLeafOffset;     
			i64 iLeafRowid;
			Fts5Data *pData;
			int iId = pSeg->pSeg->iSegid;
			u8 aHdr[4] = { 0x00, 0x00, 0x00, 0x00 };

			iLeafRowid = FTS5_SEGMENT_ROWID(iId, pSeg->iTermLeafPgno);
			pData = fts5DataRead(p, iLeafRowid);
			if (pData) {
				fts5BufferZero(&buf);
				fts5BufferGrow(&p->rc, &buf, pData->nn);
				fts5BufferAppendBlob(&p->rc, &buf, sizeof(aHdr), aHdr);
				fts5BufferAppendVarint(&p->rc, &buf, pSeg->term.n);
				fts5BufferAppendBlob(&p->rc, &buf, pSeg->term.n, pSeg->term.p);
				fts5BufferAppendBlob(&p->rc, &buf, pData->szLeaf - iOff, &pData->p[iOff]);
				if (p->rc == SQLITE_OK) {
					
					fts5PutU16(&buf.p[2], (u16)buf.n);
				}

				
				fts5BufferAppendVarint(&p->rc, &buf, 4);
				if (pSeg->iLeafPgno == pSeg->iTermLeafPgno
					&& pSeg->iEndofDoclist<pData->szLeaf
					) {
					int nDiff = pData->szLeaf - pSeg->iEndofDoclist;
					fts5BufferAppendVarint(&p->rc, &buf, buf.n - 1 - nDiff - 4);
					fts5BufferAppendBlob(&p->rc, &buf,
						pData->nn - pSeg->iPgidxOff, &pData->p[pSeg->iPgidxOff]
					);
				}

				fts5DataRelease(pData);
				pSeg->pSeg->pgnoFirst = pSeg->iTermLeafPgno;
				fts5DataDelete(p, FTS5_SEGMENT_ROWID(iId, 1), iLeafRowid);
				fts5DataWrite(p, iLeafRowid, buf.p, buf.n);
			}
		}
	}
	fts5BufferFree(&buf);
}

static void fts5MergeChunkCallback(
	Fts5Index *p,
	void *pCtx,
	const u8 *pChunk, int nChunk
) {
	Fts5SegWriter *pWriter = (Fts5SegWriter*)pCtx;
	fts5WriteAppendPoslistData(p, pWriter, pChunk, nChunk);
}


static void fts5IndexMergeLevel(
	Fts5Index *p,                   
	Fts5Structure **ppStruct,       
	int iLvl,                       
	int *pnRem                      
) {
	Fts5Structure *pStruct = *ppStruct;
	Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
	Fts5StructureLevel *pLvlOut;
	Fts5Iter *pIter = 0;       
	int nRem = pnRem ? *pnRem : 0;  
	int nInput;                     
	Fts5SegWriter writer;           
	Fts5StructureSegment *pSeg;     
	Fts5Buffer term;
	int bOldest;                    
	int eDetail = p->pConfig->eDetail;
	const int flags = FTS5INDEX_QUERY_NOOUTPUT;

	assert(iLvl<pStruct->nLevel);
	assert(pLvl->nMerge <= pLvl->nSeg);

	memset(&writer, 0, sizeof(Fts5SegWriter));
	memset(&term, 0, sizeof(Fts5Buffer));
	if (pLvl->nMerge) {
		pLvlOut = &pStruct->aLevel[iLvl + 1];
		assert(pLvlOut->nSeg>0);
		nInput = pLvl->nMerge;
		pSeg = &pLvlOut->aSeg[pLvlOut->nSeg - 1];

		fts5WriteInit(p, &writer, pSeg->iSegid);
		writer.writer.pgno = pSeg->pgnoLast + 1;
		writer.iBtPage = 0;
	}
	else {
		int iSegid = fts5AllocateSegid(p, pStruct);

		
		if (iLvl == pStruct->nLevel - 1) {
			fts5StructureAddLevel(&p->rc, ppStruct);
			pStruct = *ppStruct;
		}
		fts5StructureExtendLevel(&p->rc, pStruct, iLvl + 1, 1, 0);
		if (p->rc) return;
		pLvl = &pStruct->aLevel[iLvl];
		pLvlOut = &pStruct->aLevel[iLvl + 1];

		fts5WriteInit(p, &writer, iSegid);

		
		pSeg = &pLvlOut->aSeg[pLvlOut->nSeg];
		pLvlOut->nSeg++;
		pSeg->pgnoFirst = 1;
		pSeg->iSegid = iSegid;
		pStruct->nSegment++;

		
		nInput = pLvl->nSeg;
	}
	bOldest = (pLvlOut->nSeg == 1 && pStruct->nLevel == iLvl + 2);

	assert(iLvl >= 0);
	for (fts5MultiIterNew(p, pStruct, flags, 0, 0, 0, iLvl, nInput, &pIter);
		fts5MultiIterEof(p, pIter) == 0;
		fts5MultiIterNext(p, pIter, 0, 0)
		) {
		Fts5SegIter *pSegIter = &pIter->aSeg[pIter->aFirst[1].iFirst];
		int nPos;                     
		int nTerm;
		const u8 *pTerm;

		
		if (pSegIter->nPos == 0 && (bOldest || pSegIter->bDel == 0)) continue;

		pTerm = fts5MultiIterTerm(pIter, &nTerm);
		if (nTerm != term.n || memcmp(pTerm, term.p, nTerm)) {
			if (pnRem && writer.nLeafWritten>nRem) {
				break;
			}

			
			fts5WriteAppendTerm(p, &writer, nTerm, pTerm);
			fts5BufferSet(&p->rc, &term, nTerm, pTerm);
		}

		
		
		fts5WriteAppendRowid(p, &writer, fts5MultiIterRowid(pIter));

		if (eDetail == FTS5_DETAIL_NONE) {
			if (pSegIter->bDel) {
				fts5BufferAppendVarint(&p->rc, &writer.writer.buf, 0);
				if (pSegIter->nPos>0) {
					fts5BufferAppendVarint(&p->rc, &writer.writer.buf, 0);
				}
			}
		}
		else {
			
			nPos = pSegIter->nPos * 2 + pSegIter->bDel;
			fts5BufferAppendVarint(&p->rc, &writer.writer.buf, nPos);
			fts5ChunkIterate(p, pSegIter, (void*)&writer, fts5MergeChunkCallback);
		}
	}

	
	fts5WriteFinish(p, &writer, &pSeg->pgnoLast);

	if (fts5MultiIterEof(p, pIter)) {
		int i;

		
		for (i = 0; i<nInput; i++) {
			fts5DataRemoveSegment(p, pLvl->aSeg[i].iSegid);
		}

		
		if (pLvl->nSeg != nInput) {
			int nMove = (pLvl->nSeg - nInput) * sizeof(Fts5StructureSegment);
			memmove(pLvl->aSeg, &pLvl->aSeg[nInput], nMove);
		}
		pStruct->nSegment -= nInput;
		pLvl->nSeg -= nInput;
		pLvl->nMerge = 0;
		if (pSeg->pgnoLast == 0) {
			pLvlOut->nSeg--;
			pStruct->nSegment--;
		}
	}
	else {
		assert(pSeg->pgnoLast>0);
		fts5TrimSegments(p, pIter);
		pLvl->nMerge = nInput;
	}

	fts5MultiIterFree(pIter);
	fts5BufferFree(&term);
	if (pnRem) *pnRem -= writer.nLeafWritten;
}


static int fts5IndexMerge(
	Fts5Index *p,                   
	Fts5Structure **ppStruct,       
	int nPg,                        
	int nMin                        
) {
	int nRem = nPg;
	int bRet = 0;
	Fts5Structure *pStruct = *ppStruct;
	while (nRem>0 && p->rc == SQLITE_OK) {
		int iLvl;                   
		int iBestLvl = 0;           
		int nBest = 0;              

									
		assert(pStruct->nLevel>0);
		for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
			Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
			if (pLvl->nMerge) {
				if (pLvl->nMerge>nBest) {
					iBestLvl = iLvl;
					nBest = pLvl->nMerge;
				}
				break;
			}
			if (pLvl->nSeg>nBest) {
				nBest = pLvl->nSeg;
				iBestLvl = iLvl;
			}
		}

		
#ifdef SQLITE_DEBUG
		for (iLvl = 0; nBest == 0 && iLvl<pStruct->nLevel; iLvl++) {
			assert(pStruct->aLevel[iLvl].nSeg == 0);
		}
#endif

		if (nBest<nMin && pStruct->aLevel[iBestLvl].nMerge == 0) {
			break;
		}
		bRet = 1;
		fts5IndexMergeLevel(p, &pStruct, iBestLvl, &nRem);
		if (p->rc == SQLITE_OK && pStruct->aLevel[iBestLvl].nMerge == 0) {
			fts5StructurePromote(p, iBestLvl + 1, pStruct);
		}
	}
	*ppStruct = pStruct;
	return bRet;
}


static void fts5IndexAutomerge(
	Fts5Index *p,                   
	Fts5Structure **ppStruct,       
	int nLeaf                       
) {
	if (p->rc == SQLITE_OK && p->pConfig->nAutomerge>0) {
		Fts5Structure *pStruct = *ppStruct;
		u64 nWrite;                   
		int nWork;                    
		int nRem;                     

									  
		nWrite = pStruct->nWriteCounter;
		nWork = (int)(((nWrite + nLeaf) / p->nWorkUnit) - (nWrite / p->nWorkUnit));
		pStruct->nWriteCounter += nLeaf;
		nRem = (int)(p->nWorkUnit * nWork * pStruct->nLevel);

		fts5IndexMerge(p, ppStruct, nRem, p->pConfig->nAutomerge);
	}
}

static void fts5IndexCrisismerge(
	Fts5Index *p,                   
	Fts5Structure **ppStruct        
) {
	const int nCrisis = p->pConfig->nCrisisMerge;
	Fts5Structure *pStruct = *ppStruct;
	int iLvl = 0;

	assert(p->rc != SQLITE_OK || pStruct->nLevel>0);
	while (p->rc == SQLITE_OK && pStruct->aLevel[iLvl].nSeg >= nCrisis) {
		fts5IndexMergeLevel(p, &pStruct, iLvl, 0);
		assert(p->rc != SQLITE_OK || pStruct->nLevel>(iLvl + 1));
		fts5StructurePromote(p, iLvl + 1, pStruct);
		iLvl++;
	}
	*ppStruct = pStruct;
}

static int fts5IndexReturn(Fts5Index *p) {
	int rc = p->rc;
	p->rc = SQLITE_OK;
	return rc;
}

typedef struct Fts5FlushCtx Fts5FlushCtx;
struct Fts5FlushCtx {
	Fts5Index *pIdx;
	Fts5SegWriter writer;
};


static int fts5PoslistPrefix(const u8 *aBuf, int nMax) {
	int ret;
	u32 dummy;
	ret = fts5GetVarint32(aBuf, dummy);
	if (ret<nMax) {
		while (1) {
			int i = fts5GetVarint32(&aBuf[ret], dummy);
			if ((ret + i) > nMax) break;
			ret += i;
		}
	}
	return ret;
}


static void fts5FlushOneHash(Fts5Index *p) {
	Fts5Hash *pHash = p->pHash;
	Fts5Structure *pStruct;
	int iSegid;
	int pgnoLast = 0;                 

									  
	pStruct = fts5StructureRead(p);
	iSegid = fts5AllocateSegid(p, pStruct);
	fts5StructureInvalidate(p);

	if (iSegid) {
		const int pgsz = p->pConfig->pgsz;
		int eDetail = p->pConfig->eDetail;
		Fts5StructureSegment *pSeg;   
		Fts5Buffer *pBuf;             
		Fts5Buffer *pPgidx;           

		Fts5SegWriter writer;
		fts5WriteInit(p, &writer, iSegid);

		pBuf = &writer.writer.buf;
		pPgidx = &writer.writer.pgidx;

		
		assert(p->rc || pBuf->nSpace >= (pgsz + FTS5_DATA_PADDING));
		assert(p->rc || pPgidx->nSpace >= (pgsz + FTS5_DATA_PADDING));

		
		if (p->rc == SQLITE_OK) {
			p->rc = sqlite3Fts5HashScanInit(pHash, 0, 0);
		}
		while (p->rc == SQLITE_OK && 0 == sqlite3Fts5HashScanEof(pHash)) {
			const char *zTerm;          
			const u8 *pDoclist;         
			int nDoclist;               

										
			sqlite3Fts5HashScanEntry(pHash, &zTerm, &pDoclist, &nDoclist);
			fts5WriteAppendTerm(p, &writer, (int)strlen(zTerm), (const u8*)zTerm);

			assert(writer.bFirstRowidInPage == 0);
			if (pgsz >= (pBuf->n + pPgidx->n + nDoclist + 1)) {
				
				fts5BufferSafeAppendBlob(pBuf, pDoclist, nDoclist);
			}
			else {
				i64 iRowid = 0;
				i64 iDelta = 0;
				int iOff = 0;

				
				while (p->rc == SQLITE_OK && iOff<nDoclist) {
					iOff += fts5GetVarint(&pDoclist[iOff], (u64*)&iDelta);
					iRowid += iDelta;

					if (writer.bFirstRowidInPage) {
						fts5PutU16(&pBuf->p[0], (u16)pBuf->n);   
						pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowid);
						writer.bFirstRowidInPage = 0;
						fts5WriteDlidxAppend(p, &writer, iRowid);
					}
					else {
						pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iDelta);
					}
					assert(pBuf->n <= pBuf->nSpace);

					if (eDetail == FTS5_DETAIL_NONE) {
						if (iOff<nDoclist && pDoclist[iOff] == 0) {
							pBuf->p[pBuf->n++] = 0;
							iOff++;
							if (iOff<nDoclist && pDoclist[iOff] == 0) {
								pBuf->p[pBuf->n++] = 0;
								iOff++;
							}
						}
						if ((pBuf->n + pPgidx->n) >= pgsz) {
							fts5WriteFlushLeaf(p, &writer);
						}
					}
					else {
						int bDummy;
						int nPos;
						int nCopy = fts5GetPoslistSize(&pDoclist[iOff], &nPos, &bDummy);
						nCopy += nPos;
						if ((pBuf->n + pPgidx->n + nCopy) <= pgsz) {
							
							fts5BufferSafeAppendBlob(pBuf, &pDoclist[iOff], nCopy);
						}
						else {
							
							const u8 *pPoslist = &pDoclist[iOff];
							int iPos = 0;
							while (p->rc == SQLITE_OK) {
								int nSpace = pgsz - pBuf->n - pPgidx->n;
								int n = 0;
								if ((nCopy - iPos) <= nSpace) {
									n = nCopy - iPos;
								}
								else {
									n = fts5PoslistPrefix(&pPoslist[iPos], nSpace);
								}
								assert(n>0);
								fts5BufferSafeAppendBlob(pBuf, &pPoslist[iPos], n);
								iPos += n;
								if ((pBuf->n + pPgidx->n) >= pgsz) {
									fts5WriteFlushLeaf(p, &writer);
								}
								if (iPos >= nCopy) break;
							}
						}
						iOff += nCopy;
					}
				}
			}

			
			
			assert(pBuf->n <= pBuf->nSpace);
			sqlite3Fts5HashScanNext(pHash);
		}
		sqlite3Fts5HashClear(pHash);
		fts5WriteFinish(p, &writer, &pgnoLast);

		
		if (pStruct->nLevel == 0) {
			fts5StructureAddLevel(&p->rc, &pStruct);
		}
		fts5StructureExtendLevel(&p->rc, pStruct, 0, 1, 0);
		if (p->rc == SQLITE_OK) {
			pSeg = &pStruct->aLevel[0].aSeg[pStruct->aLevel[0].nSeg++];
			pSeg->iSegid = iSegid;
			pSeg->pgnoFirst = 1;
			pSeg->pgnoLast = pgnoLast;
			pStruct->nSegment++;
		}
		fts5StructurePromote(p, 0, pStruct);
	}

	fts5IndexAutomerge(p, &pStruct, pgnoLast);
	fts5IndexCrisismerge(p, &pStruct);
	fts5StructureWrite(p, pStruct);
	fts5StructureRelease(pStruct);
}


static void fts5IndexFlush(Fts5Index *p) {
	
	if (p->nPendingData) {
		assert(p->pHash);
		p->nPendingData = 0;
		fts5FlushOneHash(p);
	}
}

static Fts5Structure *fts5IndexOptimizeStruct(
	Fts5Index *p,
	Fts5Structure *pStruct
) {
	Fts5Structure *pNew = 0;
	int nByte = sizeof(Fts5Structure);
	int nSeg = pStruct->nSegment;
	int i;

	
	if (nSeg<2) return 0;
	for (i = 0; i<pStruct->nLevel; i++) {
		int nThis = pStruct->aLevel[i].nSeg;
		if (nThis == nSeg || (nThis == nSeg - 1 && pStruct->aLevel[i].nMerge == nThis)) {
			fts5StructureRef(pStruct);
			return pStruct;
		}
		assert(pStruct->aLevel[i].nMerge <= nThis);
	}

	nByte += (pStruct->nLevel + 1) * sizeof(Fts5StructureLevel);
	pNew = (Fts5Structure*)sqlite3Fts5MallocZero(&p->rc, nByte);

	if (pNew) {
		Fts5StructureLevel *pLvl;
		nByte = nSeg * sizeof(Fts5StructureSegment);
		pNew->nLevel = pStruct->nLevel + 1;
		pNew->nRef = 1;
		pNew->nWriteCounter = pStruct->nWriteCounter;
		pLvl = &pNew->aLevel[pStruct->nLevel];
		pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&p->rc, nByte);
		if (pLvl->aSeg) {
			int iLvl, iSeg;
			int iSegOut = 0;
			
			for (iLvl = pStruct->nLevel - 1; iLvl >= 0; iLvl--) {
				for (iSeg = 0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++) {
					pLvl->aSeg[iSegOut] = pStruct->aLevel[iLvl].aSeg[iSeg];
					iSegOut++;
				}
			}
			pNew->nSegment = pLvl->nSeg = nSeg;
		}
		else {
			sqlite3_free(pNew);
			pNew = 0;
		}
	}

	return pNew;
}

static int sqlite3Fts5IndexOptimize(Fts5Index *p) {
	Fts5Structure *pStruct;
	Fts5Structure *pNew = 0;

	assert(p->rc == SQLITE_OK);
	fts5IndexFlush(p);
	pStruct = fts5StructureRead(p);
	fts5StructureInvalidate(p);

	if (pStruct) {
		pNew = fts5IndexOptimizeStruct(p, pStruct);
	}
	fts5StructureRelease(pStruct);

	assert(pNew == 0 || pNew->nSegment>0);
	if (pNew) {
		int iLvl;
		for (iLvl = 0; pNew->aLevel[iLvl].nSeg == 0; iLvl++) {}
		while (p->rc == SQLITE_OK && pNew->aLevel[iLvl].nSeg>0) {
			int nRem = FTS5_OPT_WORK_UNIT;
			fts5IndexMergeLevel(p, &pNew, iLvl, &nRem);
		}

		fts5StructureWrite(p, pNew);
		fts5StructureRelease(pNew);
	}

	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge) {
	Fts5Structure *pStruct = fts5StructureRead(p);
	if (pStruct) {
		int nMin = p->pConfig->nUsermerge;
		fts5StructureInvalidate(p);
		if (nMerge<0) {
			Fts5Structure *pNew = fts5IndexOptimizeStruct(p, pStruct);
			fts5StructureRelease(pStruct);
			pStruct = pNew;
			nMin = 2;
			nMerge = nMerge*-1;
		}
		if (pStruct && pStruct->nLevel) {
			if (fts5IndexMerge(p, &pStruct, nMerge, nMin)) {
				fts5StructureWrite(p, pStruct);
			}
		}
		fts5StructureRelease(pStruct);
	}
	return fts5IndexReturn(p);
}

static void fts5AppendRowid(
	Fts5Index *p,
	i64 iDelta,
	Fts5Iter *pUnused,
	Fts5Buffer *pBuf
) {
	UNUSED_PARAM(pUnused);
	fts5BufferAppendVarint(&p->rc, pBuf, iDelta);
}

static void fts5AppendPoslist(
	Fts5Index *p,
	i64 iDelta,
	Fts5Iter *pMulti,
	Fts5Buffer *pBuf
) {
	int nData = pMulti->base.nData;
	assert(nData>0);
	if (p->rc == SQLITE_OK && 0 == fts5BufferGrow(&p->rc, pBuf, nData + 9 + 9)) {
		fts5BufferSafeAppendVarint(pBuf, iDelta);
		fts5BufferSafeAppendVarint(pBuf, nData * 2);
		fts5BufferSafeAppendBlob(pBuf, pMulti->base.pData, nData);
	}
}


static void fts5DoclistIterNext(Fts5DoclistIter *pIter) {
	u8 *p = pIter->aPoslist + pIter->nSize + pIter->nPoslist;

	assert(pIter->aPoslist);
	if (p >= pIter->aEof) {
		pIter->aPoslist = 0;
	}
	else {
		i64 iDelta;

		p += fts5GetVarint(p, (u64*)&iDelta);
		pIter->iRowid += iDelta;

		
		if (p[0] & 0x80) {
			int nPos;
			pIter->nSize = fts5GetVarint32(p, nPos);
			pIter->nPoslist = (nPos >> 1);
		}
		else {
			pIter->nPoslist = ((int)(p[0])) >> 1;
			pIter->nSize = 1;
		}

		pIter->aPoslist = p;
	}
}

static void fts5DoclistIterInit(
	Fts5Buffer *pBuf,
	Fts5DoclistIter *pIter
) {
	memset(pIter, 0, sizeof(*pIter));
	pIter->aPoslist = pBuf->p;
	pIter->aEof = &pBuf->p[pBuf->n];
	fts5DoclistIterNext(pIter);
}

#if 0

static void fts5MergeAppendDocid(
	Fts5Buffer *pBuf,               
	i64 *piLastRowid,               
	i64 iRowid                      
) {
	assert(pBuf->n != 0 || (*piLastRowid) == 0);
	fts5BufferSafeAppendVarint(pBuf, iRowid - *piLastRowid);
	*piLastRowid = iRowid;
}
#endif

#define fts5MergeAppendDocid(pBuf, iLastRowid, iRowid) {       \
  assert( (pBuf)->n!=0 || (iLastRowid)==0 );                   \
  fts5BufferSafeAppendVarint((pBuf), (iRowid) - (iLastRowid)); \
  (iLastRowid) = (iRowid);                                     \
}


static void fts5BufferSwap(Fts5Buffer *p1, Fts5Buffer *p2) {
	Fts5Buffer tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

static void fts5NextRowid(Fts5Buffer *pBuf, int *piOff, i64 *piRowid) {
	int i = *piOff;
	if (i >= pBuf->n) {
		*piOff = -1;
	}
	else {
		u64 iVal;
		*piOff = i + sqlite3Fts5GetVarint(&pBuf->p[i], &iVal);
		*piRowid += iVal;
	}
}


static void fts5MergeRowidLists(
	Fts5Index *p,                   
	Fts5Buffer *p1,                 
	Fts5Buffer *p2                  
) {
	int i1 = 0;
	int i2 = 0;
	i64 iRowid1 = 0;
	i64 iRowid2 = 0;
	i64 iOut = 0;

	Fts5Buffer out;
	memset(&out, 0, sizeof(out));
	sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n);
	if (p->rc) return;

	fts5NextRowid(p1, &i1, &iRowid1);
	fts5NextRowid(p2, &i2, &iRowid2);
	while (i1 >= 0 || i2 >= 0) {
		if (i1 >= 0 && (i2<0 || iRowid1<iRowid2)) {
			assert(iOut == 0 || iRowid1>iOut);
			fts5BufferSafeAppendVarint(&out, iRowid1 - iOut);
			iOut = iRowid1;
			fts5NextRowid(p1, &i1, &iRowid1);
		}
		else {
			assert(iOut == 0 || iRowid2>iOut);
			fts5BufferSafeAppendVarint(&out, iRowid2 - iOut);
			iOut = iRowid2;
			if (i1 >= 0 && iRowid1 == iRowid2) {
				fts5NextRowid(p1, &i1, &iRowid1);
			}
			fts5NextRowid(p2, &i2, &iRowid2);
		}
	}

	fts5BufferSwap(&out, p1);
	fts5BufferFree(&out);
}


static void fts5MergePrefixLists(
	Fts5Index *p,                   
	Fts5Buffer *p1,                 
	Fts5Buffer *p2                  
) {
	if (p2->n) {
		i64 iLastRowid = 0;
		Fts5DoclistIter i1;
		Fts5DoclistIter i2;
		Fts5Buffer out = { 0, 0, 0 };
		Fts5Buffer tmp = { 0, 0, 0 };

		if (sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n)) return;
		fts5DoclistIterInit(p1, &i1);
		fts5DoclistIterInit(p2, &i2);

		while (1) {
			if (i1.iRowid<i2.iRowid) {
				
				fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);
				fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.nPoslist + i1.nSize);
				fts5DoclistIterNext(&i1);
				if (i1.aPoslist == 0) break;
			}
			else if (i2.iRowid != i1.iRowid) {
				
				fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
				fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.nPoslist + i2.nSize);
				fts5DoclistIterNext(&i2);
				if (i2.aPoslist == 0) break;
			}
			else {
				
				i64 iPos1 = 0;
				i64 iPos2 = 0;
				int iOff1 = 0;
				int iOff2 = 0;
				u8 *a1 = &i1.aPoslist[i1.nSize];
				u8 *a2 = &i2.aPoslist[i2.nSize];

				i64 iPrev = 0;
				Fts5PoslistWriter writer;
				memset(&writer, 0, sizeof(writer));

				fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
				fts5BufferZero(&tmp);
				sqlite3Fts5BufferSize(&p->rc, &tmp, i1.nPoslist + i2.nPoslist);
				if (p->rc) break;

				sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
				sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
				assert(iPos1 >= 0 && iPos2 >= 0);

				if (iPos1<iPos2) {
					sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
					sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
				}
				else {
					sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);
					sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
				}

				if (iPos1 >= 0 && iPos2 >= 0) {
					while (1) {
						if (iPos1<iPos2) {
							if (iPos1 != iPrev) {
								sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
							}
							sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
							if (iPos1<0) break;
						}
						else {
							assert(iPos2 != iPrev);
							sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);
							sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
							if (iPos2<0) break;
						}
					}
				}

				if (iPos1 >= 0) {
					if (iPos1 != iPrev) {
						sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
					}
					fts5BufferSafeAppendBlob(&tmp, &a1[iOff1], i1.nPoslist - iOff1);
				}
				else {
					assert(iPos2 >= 0 && iPos2 != iPrev);
					sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);
					fts5BufferSafeAppendBlob(&tmp, &a2[iOff2], i2.nPoslist - iOff2);
				}

				
				fts5BufferSafeAppendVarint(&out, tmp.n * 2);
				fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);
				fts5DoclistIterNext(&i1);
				fts5DoclistIterNext(&i2);
				if (i1.aPoslist == 0 || i2.aPoslist == 0) break;
			}
		}

		if (i1.aPoslist) {
			fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);
			fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.aEof - i1.aPoslist);
		}
		else if (i2.aPoslist) {
			fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
			fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.aEof - i2.aPoslist);
		}

		fts5BufferSet(&p->rc, p1, out.n, out.p);
		fts5BufferFree(&tmp);
		fts5BufferFree(&out);
	}
}

static void fts5SetupPrefixIter(
	Fts5Index *p,                   
	int bDesc,                      
	const u8 *pToken,               
	int nToken,                     
	Fts5Colset *pColset,            
	Fts5Iter **ppIter          
) {
	Fts5Structure *pStruct;
	Fts5Buffer *aBuf;
	const int nBuf = 32;

	void(*xMerge)(Fts5Index*, Fts5Buffer*, Fts5Buffer*);
	void(*xAppend)(Fts5Index*, i64, Fts5Iter*, Fts5Buffer*);
	if (p->pConfig->eDetail == FTS5_DETAIL_NONE) {
		xMerge = fts5MergeRowidLists;
		xAppend = fts5AppendRowid;
	}
	else {
		xMerge = fts5MergePrefixLists;
		xAppend = fts5AppendPoslist;
	}

	aBuf = (Fts5Buffer*)fts5IdxMalloc(p, sizeof(Fts5Buffer)*nBuf);
	pStruct = fts5StructureRead(p);

	if (aBuf && pStruct) {
		const int flags = FTS5INDEX_QUERY_SCAN
			| FTS5INDEX_QUERY_SKIPEMPTY
			| FTS5INDEX_QUERY_NOOUTPUT;
		int i;
		i64 iLastRowid = 0;
		Fts5Iter *p1 = 0;     
		Fts5Data *pData;
		Fts5Buffer doclist;
		int bNewTerm = 1;

		memset(&doclist, 0, sizeof(doclist));
		fts5MultiIterNew(p, pStruct, flags, pColset, pToken, nToken, -1, 0, &p1);
		fts5IterSetOutputCb(&p->rc, p1);
		for ( ;
			fts5MultiIterEof(p, p1) == 0;
			fts5MultiIterNext2(p, p1, &bNewTerm)
			) {
			Fts5SegIter *pSeg = &p1->aSeg[p1->aFirst[1].iFirst];
			int nTerm = pSeg->term.n;
			const u8 *pTerm = pSeg->term.p;
			p1->xSetOutputs(p1, pSeg);

			assert_nc(memcmp(pToken, pTerm, MIN(nToken, nTerm)) <= 0);
			if (bNewTerm) {
				if (nTerm<nToken || memcmp(pToken, pTerm, nToken)) break;
			}

			if (p1->base.nData == 0) continue;

			if (p1->base.iRowid <= iLastRowid && doclist.n>0) {
				for (i = 0; p->rc == SQLITE_OK && doclist.n; i++) {
					assert(i<nBuf);
					if (aBuf[i].n == 0) {
						fts5BufferSwap(&doclist, &aBuf[i]);
						fts5BufferZero(&doclist);
					}
					else {
						xMerge(p, &doclist, &aBuf[i]);
						fts5BufferZero(&aBuf[i]);
					}
				}
				iLastRowid = 0;
			}

			xAppend(p, p1->base.iRowid - iLastRowid, p1, &doclist);
			iLastRowid = p1->base.iRowid;
		}

		for (i = 0; i<nBuf; i++) {
			if (p->rc == SQLITE_OK) {
				xMerge(p, &doclist, &aBuf[i]);
			}
			fts5BufferFree(&aBuf[i]);
		}
		fts5MultiIterFree(p1);

		pData = fts5IdxMalloc(p, sizeof(Fts5Data) + doclist.n);
		if (pData) {
			pData->p = (u8*)&pData[1];
			pData->nn = pData->szLeaf = doclist.n;
			memcpy(pData->p, doclist.p, doclist.n);
			fts5MultiIterNew2(p, pData, bDesc, ppIter);
		}
		fts5BufferFree(&doclist);
	}

	fts5StructureRelease(pStruct);
	sqlite3_free(aBuf);
}



static int sqlite3Fts5IndexBeginWrite(Fts5Index *p, int bDelete, i64 iRowid) {
	assert(p->rc == SQLITE_OK);

	
	if (p->pHash == 0) {
		p->rc = sqlite3Fts5HashNew(p->pConfig, &p->pHash, &p->nPendingData);
	}

	
	if (iRowid<p->iWriteRowid
		|| (iRowid == p->iWriteRowid && p->bDelete == 0)
		|| (p->nPendingData > p->pConfig->nHashSize)
		) {
		fts5IndexFlush(p);
	}

	p->iWriteRowid = iRowid;
	p->bDelete = bDelete;
	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit) {
	assert(p->rc == SQLITE_OK);
	fts5IndexFlush(p);
	if (bCommit) fts5CloseReader(p);
	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexRollback(Fts5Index *p) {
	fts5CloseReader(p);
	fts5IndexDiscardData(p);
	fts5StructureInvalidate(p);
	
	return SQLITE_OK;
}


static int sqlite3Fts5IndexReinit(Fts5Index *p) {
	Fts5Structure s;
	fts5StructureInvalidate(p);
	memset(&s, 0, sizeof(Fts5Structure));
	fts5DataWrite(p, FTS5_AVERAGES_ROWID, (const u8*)"", 0);
	fts5StructureWrite(p, &s);
	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexOpen(
	Fts5Config *pConfig,
	int bCreate,
	Fts5Index **pp,
	char **pzErr
) {
	int rc = SQLITE_OK;
	Fts5Index *p;                   

	*pp = p = (Fts5Index*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Index));
	if (rc == SQLITE_OK) {
		p->pConfig = pConfig;
		p->nWorkUnit = FTS5_WORK_UNIT;
		p->zDataTbl = sqlite3Fts5Mprintf(&rc, "%s_data", pConfig->zName);
		if (p->zDataTbl && bCreate) {
			rc = sqlite3Fts5CreateTable(
				pConfig, "data", "id INTEGER PRIMARY KEY, block BLOB", 0, pzErr
			);
			if (rc == SQLITE_OK) {
				rc = sqlite3Fts5CreateTable(pConfig, "idx",
					"segid, term, pgno, PRIMARY KEY(segid, term)",
					1, pzErr
				);
			}
			if (rc == SQLITE_OK) {
				rc = sqlite3Fts5IndexReinit(p);
			}
		}
	}

	assert(rc != SQLITE_OK || p->rc == SQLITE_OK);
	if (rc) {
		sqlite3Fts5IndexClose(p);
		*pp = 0;
	}
	return rc;
}


static int sqlite3Fts5IndexClose(Fts5Index *p) {
	int rc = SQLITE_OK;
	if (p) {
		assert(p->pReader == 0);
		fts5StructureInvalidate(p);
		sqlite3_finalize(p->pWriter);
		sqlite3_finalize(p->pDeleter);
		sqlite3_finalize(p->pIdxWriter);
		sqlite3_finalize(p->pIdxDeleter);
		sqlite3_finalize(p->pIdxSelect);
		sqlite3_finalize(p->pDataVersion);
		sqlite3Fts5HashFree(p->pHash);
		sqlite3_free(p->zDataTbl);
		sqlite3_free(p);
	}
	return rc;
}


static int sqlite3Fts5IndexCharlenToBytelen(
	const char *p,
	int nByte,
	int nChar
) {
	int n = 0;
	int i;
	for (i = 0; i<nChar; i++) {
		if (n >= nByte) return 0;      
		if ((unsigned char)p[n++] >= 0xc0) {
			while ((p[n] & 0xc0) == 0x80) n++;
		}
	}
	return n;
}


static int fts5IndexCharlen(const char *pIn, int nIn) {
	int nChar = 0;
	int i = 0;
	while (i<nIn) {
		if ((unsigned char)pIn[i++] >= 0xc0) {
			while (i<nIn && (pIn[i] & 0xc0) == 0x80) i++;
		}
		nChar++;
	}
	return nChar;
}


static int sqlite3Fts5IndexWrite(
	Fts5Index *p,                   
	int iCol,                       
	int iPos,                       
	const char *pToken, int nToken  
) {
	int i;                          
	int rc = SQLITE_OK;             
	Fts5Config *pConfig = p->pConfig;

	assert(p->rc == SQLITE_OK);
	assert((iCol<0) == p->bDelete);

	
	rc = sqlite3Fts5HashWrite(
		p->pHash, p->iWriteRowid, iCol, iPos, FTS5_MAIN_PREFIX, pToken, nToken
	);

	for (i = 0; i<pConfig->nPrefix && rc == SQLITE_OK; i++) {
		const int nChar = pConfig->aPrefix[i];
		int nByte = sqlite3Fts5IndexCharlenToBytelen(pToken, nToken, nChar);
		if (nByte) {
			rc = sqlite3Fts5HashWrite(p->pHash,
				p->iWriteRowid, iCol, iPos, (char)(FTS5_MAIN_PREFIX + i + 1), pToken,
				nByte
			);
		}
	}

	return rc;
}


static int sqlite3Fts5IndexQuery(
	Fts5Index *p,                   
	const char *pToken, int nToken, 
	int flags,                      
	Fts5Colset *pColset,            
	Fts5IndexIter **ppIter          
) {
	Fts5Config *pConfig = p->pConfig;
	Fts5Iter *pRet = 0;
	Fts5Buffer buf = { 0, 0, 0 };

	
	assert((flags & FTS5INDEX_QUERY_SCAN) == 0 || flags == FTS5INDEX_QUERY_SCAN);

	if (sqlite3Fts5BufferSize(&p->rc, &buf, nToken + 1) == 0) {
		int iIdx = 0;                 
		memcpy(&buf.p[1], pToken, nToken);

		
#ifdef SQLITE_DEBUG
		if (pConfig->bPrefixIndex == 0 || (flags & FTS5INDEX_QUERY_TEST_NOIDX)) {
			assert(flags & FTS5INDEX_QUERY_PREFIX);
			iIdx = 1 + pConfig->nPrefix;
		}
		else
#endif
			if (flags & FTS5INDEX_QUERY_PREFIX) {
				int nChar = fts5IndexCharlen(pToken, nToken);
				for (iIdx = 1; iIdx <= pConfig->nPrefix; iIdx++) {
					if (pConfig->aPrefix[iIdx - 1] == nChar) break;
				}
			}

		if (iIdx <= pConfig->nPrefix) {
			
			Fts5Structure *pStruct = fts5StructureRead(p);
			buf.p[0] = (u8)(FTS5_MAIN_PREFIX + iIdx);
			if (pStruct) {
				fts5MultiIterNew(p, pStruct, flags | FTS5INDEX_QUERY_SKIPEMPTY,
					pColset, buf.p, nToken + 1, -1, 0, &pRet
				);
				fts5StructureRelease(pStruct);
			}
		}
		else {
			
			int bDesc = (flags & FTS5INDEX_QUERY_DESC) != 0;
			buf.p[0] = FTS5_MAIN_PREFIX;
			fts5SetupPrefixIter(p, bDesc, buf.p, nToken + 1, pColset, &pRet);
			assert(p->rc != SQLITE_OK || pRet->pColset == 0);
			fts5IterSetOutputCb(&p->rc, pRet);
			if (p->rc == SQLITE_OK) {
				Fts5SegIter *pSeg = &pRet->aSeg[pRet->aFirst[1].iFirst];
				if (pSeg->pLeaf) pRet->xSetOutputs(pRet, pSeg);
			}
		}

		if (p->rc) {
			sqlite3Fts5IterClose(&pRet->base);
			pRet = 0;
			fts5CloseReader(p);
		}

		*ppIter = &pRet->base;
		sqlite3Fts5BufferFree(&buf);
	}
	return fts5IndexReturn(p);
}



static int sqlite3Fts5IterNext(Fts5IndexIter *pIndexIter) {
	Fts5Iter *pIter = (Fts5Iter*)pIndexIter;
	assert(pIter->pIndex->rc == SQLITE_OK);
	fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);
	return fts5IndexReturn(pIter->pIndex);
}


static int sqlite3Fts5IterNextScan(Fts5IndexIter *pIndexIter) {
	Fts5Iter *pIter = (Fts5Iter*)pIndexIter;
	Fts5Index *p = pIter->pIndex;

	assert(pIter->pIndex->rc == SQLITE_OK);

	fts5MultiIterNext(p, pIter, 0, 0);
	if (p->rc == SQLITE_OK) {
		Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
		if (pSeg->pLeaf && pSeg->term.p[0] != FTS5_MAIN_PREFIX) {
			fts5DataRelease(pSeg->pLeaf);
			pSeg->pLeaf = 0;
			pIter->base.bEof = 1;
		}
	}

	return fts5IndexReturn(pIter->pIndex);
}


static int sqlite3Fts5IterNextFrom(Fts5IndexIter *pIndexIter, i64 iMatch) {
	Fts5Iter *pIter = (Fts5Iter*)pIndexIter;
	fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);
	return fts5IndexReturn(pIter->pIndex);
}


static const char *sqlite3Fts5IterTerm(Fts5IndexIter *pIndexIter, int *pn) {
	int n;
	const char *z = (const char*)fts5MultiIterTerm((Fts5Iter*)pIndexIter, &n);
	*pn = n - 1;
	return &z[1];
}


static void sqlite3Fts5IterClose(Fts5IndexIter *pIndexIter) {
	if (pIndexIter) {
		Fts5Iter *pIter = (Fts5Iter*)pIndexIter;
		Fts5Index *pIndex = pIter->pIndex;
		fts5MultiIterFree(pIter);
		fts5CloseReader(pIndex);
	}
}


static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize) {
	int nCol = p->pConfig->nCol;
	Fts5Data *pData;

	*pnRow = 0;
	memset(anSize, 0, sizeof(i64) * nCol);
	pData = fts5DataRead(p, FTS5_AVERAGES_ROWID);
	if (p->rc == SQLITE_OK && pData->nn) {
		int i = 0;
		int iCol;
		i += fts5GetVarint(&pData->p[i], (u64*)pnRow);
		for (iCol = 0; i<pData->nn && iCol<nCol; iCol++) {
			i += fts5GetVarint(&pData->p[i], (u64*)&anSize[iCol]);
		}
	}

	fts5DataRelease(pData);
	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8 *pData, int nData) {
	assert(p->rc == SQLITE_OK);
	fts5DataWrite(p, FTS5_AVERAGES_ROWID, pData, nData);
	return fts5IndexReturn(p);
}


static int sqlite3Fts5IndexReads(Fts5Index *p) {
	return p->nRead;
}


static int sqlite3Fts5IndexSetCookie(Fts5Index *p, int iNew) {
	int rc;                              
	Fts5Config *pConfig = p->pConfig;    
	u8 aCookie[4];                       
	sqlite3_blob *pBlob = 0;

	assert(p->rc == SQLITE_OK);
	sqlite3Fts5Put32(aCookie, iNew);

	rc = sqlite3_blob_open(pConfig->db, pConfig->zDb, p->zDataTbl,
		"block", FTS5_STRUCTURE_ROWID, 1, &pBlob
	);
	if (rc == SQLITE_OK) {
		sqlite3_blob_write(pBlob, aCookie, 4, 0);
		rc = sqlite3_blob_close(pBlob);
	}

	return rc;
}

static int sqlite3Fts5IndexLoadConfig(Fts5Index *p) {
	Fts5Structure *pStruct;
	pStruct = fts5StructureRead(p);
	fts5StructureRelease(pStruct);
	return fts5IndexReturn(p);
}





static u64 sqlite3Fts5IndexEntryCksum(
	i64 iRowid,
	int iCol,
	int iPos,
	int iIdx,
	const char *pTerm,
	int nTerm
) {
	int i;
	u64 ret = iRowid;
	ret += (ret << 3) + iCol;
	ret += (ret << 3) + iPos;
	if (iIdx >= 0) ret += (ret << 3) + (FTS5_MAIN_PREFIX + iIdx);
	for (i = 0; i<nTerm; i++) ret += (ret << 3) + pTerm[i];
	return ret;
}

#ifdef SQLITE_DEBUG

static void fts5TestDlidxReverse(
	Fts5Index *p,
	int iSegid,                     
	int iLeaf                       
) {
	Fts5DlidxIter *pDlidx = 0;
	u64 cksum1 = 13;
	u64 cksum2 = 13;

	for (pDlidx = fts5DlidxIterInit(p, 0, iSegid, iLeaf);
		fts5DlidxIterEof(p, pDlidx) == 0;
		fts5DlidxIterNext(p, pDlidx)
		) {
		i64 iRowid = fts5DlidxIterRowid(pDlidx);
		int pgno = fts5DlidxIterPgno(pDlidx);
		assert(pgno>iLeaf);
		cksum1 += iRowid + ((i64)pgno << 32);
	}
	fts5DlidxIterFree(pDlidx);
	pDlidx = 0;

	for (pDlidx = fts5DlidxIterInit(p, 1, iSegid, iLeaf);
		fts5DlidxIterEof(p, pDlidx) == 0;
		fts5DlidxIterPrev(p, pDlidx)
		) {
		i64 iRowid = fts5DlidxIterRowid(pDlidx);
		int pgno = fts5DlidxIterPgno(pDlidx);
		assert(fts5DlidxIterPgno(pDlidx)>iLeaf);
		cksum2 += iRowid + ((i64)pgno << 32);
	}
	fts5DlidxIterFree(pDlidx);
	pDlidx = 0;

	if (p->rc == SQLITE_OK && cksum1 != cksum2) p->rc = FTS5_CORRUPT;
}

static int fts5QueryCksum(
	Fts5Index *p,                   
	int iIdx,
	const char *z,                  
	int n,                          
	int flags,                      
	u64 *pCksum                     
) {
	int eDetail = p->pConfig->eDetail;
	u64 cksum = *pCksum;
	Fts5IndexIter *pIter = 0;
	int rc = sqlite3Fts5IndexQuery(p, z, n, flags, 0, &pIter);

	while (rc == SQLITE_OK && 0 == sqlite3Fts5IterEof(pIter)) {
		i64 rowid = pIter->iRowid;

		if (eDetail == FTS5_DETAIL_NONE) {
			cksum ^= sqlite3Fts5IndexEntryCksum(rowid, 0, 0, iIdx, z, n);
		}
		else {
			Fts5PoslistReader sReader;
			for (sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &sReader);
				sReader.bEof == 0;
				sqlite3Fts5PoslistReaderNext(&sReader)
				) {
				int iCol = FTS5_POS2COLUMN(sReader.iPos);
				int iOff = FTS5_POS2OFFSET(sReader.iPos);
				cksum ^= sqlite3Fts5IndexEntryCksum(rowid, iCol, iOff, iIdx, z, n);
			}
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts5IterNext(pIter);
		}
	}
	sqlite3Fts5IterClose(pIter);

	*pCksum = cksum;
	return rc;
}



static void fts5TestTerm(
	Fts5Index *p,
	Fts5Buffer *pPrev,              
	const char *z, int n,           
	u64 expected,
	u64 *pCksum
) {
	int rc = p->rc;
	if (pPrev->n == 0) {
		fts5BufferSet(&rc, pPrev, n, (const u8*)z);
	}
	else
		if (rc == SQLITE_OK && (pPrev->n != n || memcmp(pPrev->p, z, n))) {
			u64 cksum3 = *pCksum;
			const char *zTerm = (const char*)&pPrev->p[1];  
			int nTerm = pPrev->n - 1;            
			int iIdx = (pPrev->p[0] - FTS5_MAIN_PREFIX);
			int flags = (iIdx == 0 ? 0 : FTS5INDEX_QUERY_PREFIX);
			u64 ck1 = 0;
			u64 ck2 = 0;

			
			rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, flags, &ck1);
			if (rc == SQLITE_OK) {
				int f = flags | FTS5INDEX_QUERY_DESC;
				rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
			}
			if (rc == SQLITE_OK && ck1 != ck2) rc = FTS5_CORRUPT;

			
			if (p->nPendingData == 0) {
				if (iIdx>0 && rc == SQLITE_OK) {
					int f = flags | FTS5INDEX_QUERY_TEST_NOIDX;
					ck2 = 0;
					rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
					if (rc == SQLITE_OK && ck1 != ck2) rc = FTS5_CORRUPT;
				}
				if (iIdx>0 && rc == SQLITE_OK) {
					int f = flags | FTS5INDEX_QUERY_TEST_NOIDX | FTS5INDEX_QUERY_DESC;
					ck2 = 0;
					rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
					if (rc == SQLITE_OK && ck1 != ck2) rc = FTS5_CORRUPT;
				}
			}

			cksum3 ^= ck1;
			fts5BufferSet(&rc, pPrev, n, (const u8*)z);

			if (rc == SQLITE_OK && cksum3 != expected) {
				rc = FTS5_CORRUPT;
			}
			*pCksum = cksum3;
		}
	p->rc = rc;
}

#else
# define fts5TestDlidxReverse(x,y,z)
# define fts5TestTerm(u,v,w,x,y,z)
#endif


static void fts5IndexIntegrityCheckEmpty(
	Fts5Index *p,
	Fts5StructureSegment *pSeg,     
	int iFirst,
	int iNoRowid,
	int iLast
) {
	int i;

	
	for (i = iFirst; p->rc == SQLITE_OK && i <= iLast; i++) {
		Fts5Data *pLeaf = fts5DataRead(p, FTS5_SEGMENT_ROWID(pSeg->iSegid, i));
		if (pLeaf) {
			if (!fts5LeafIsTermless(pLeaf)) p->rc = FTS5_CORRUPT;
			if (i >= iNoRowid && 0 != fts5LeafFirstRowidOff(pLeaf)) p->rc = FTS5_CORRUPT;
		}
		fts5DataRelease(pLeaf);
	}
}

static void fts5IntegrityCheckPgidx(Fts5Index *p, Fts5Data *pLeaf) {
	int iTermOff = 0;
	int ii;

	Fts5Buffer buf1 = { 0,0,0 };
	Fts5Buffer buf2 = { 0,0,0 };

	ii = pLeaf->szLeaf;
	while (ii<pLeaf->nn && p->rc == SQLITE_OK) {
		int res;
		int iOff;
		int nIncr;

		ii += fts5GetVarint32(&pLeaf->p[ii], nIncr);
		iTermOff += nIncr;
		iOff = iTermOff;

		if (iOff >= pLeaf->szLeaf) {
			p->rc = FTS5_CORRUPT;
		}
		else if (iTermOff == nIncr) {
			int nByte;
			iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);
			if ((iOff + nByte)>pLeaf->szLeaf) {
				p->rc = FTS5_CORRUPT;
			}
			else {
				fts5BufferSet(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);
			}
		}
		else {
			int nKeep, nByte;
			iOff += fts5GetVarint32(&pLeaf->p[iOff], nKeep);
			iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);
			if (nKeep>buf1.n || (iOff + nByte)>pLeaf->szLeaf) {
				p->rc = FTS5_CORRUPT;
			}
			else {
				buf1.n = nKeep;
				fts5BufferAppendBlob(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);
			}

			if (p->rc == SQLITE_OK) {
				res = fts5BufferCompare(&buf1, &buf2);
				if (res <= 0) p->rc = FTS5_CORRUPT;
			}
		}
		fts5BufferSet(&p->rc, &buf2, buf1.n, buf1.p);
	}

	fts5BufferFree(&buf1);
	fts5BufferFree(&buf2);
}

static void fts5IndexIntegrityCheckSegment(
	Fts5Index *p,                   
	Fts5StructureSegment *pSeg      
) {
	Fts5Config *pConfig = p->pConfig;
	sqlite3_stmt *pStmt = 0;
	int rc2;
	int iIdxPrevLeaf = pSeg->pgnoFirst - 1;
	int iDlidxPrevLeaf = pSeg->pgnoLast;

	if (pSeg->pgnoFirst == 0) return;

	fts5IndexPrepareStmt(p, &pStmt, sqlite3_mprintf(
		"SELECT segid, term, (pgno>>1), (pgno&1) FROM %Q.'%q_idx' WHERE segid=%d",
		pConfig->zDb, pConfig->zName, pSeg->iSegid
	));

	
	while (p->rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pStmt)) {
		i64 iRow;                     
		Fts5Data *pLeaf;              

		int nIdxTerm = sqlite3_column_bytes(pStmt, 1);
		const char *zIdxTerm = (const char*)sqlite3_column_text(pStmt, 1);
		int iIdxLeaf = sqlite3_column_int(pStmt, 2);
		int bIdxDlidx = sqlite3_column_int(pStmt, 3);

		
		if (iIdxLeaf<pSeg->pgnoFirst) continue;
		iRow = FTS5_SEGMENT_ROWID(pSeg->iSegid, iIdxLeaf);
		pLeaf = fts5DataRead(p, iRow);
		if (pLeaf == 0) break;

		
		if (pLeaf->nn <= pLeaf->szLeaf) {
			p->rc = FTS5_CORRUPT;
		}
		else {
			int iOff;                   
			int iRowidOff;              
			int nTerm;                  
			int res;                    

			iOff = fts5LeafFirstTermOff(pLeaf);
			iRowidOff = fts5LeafFirstRowidOff(pLeaf);
			if (iRowidOff >= iOff) {
				p->rc = FTS5_CORRUPT;
			}
			else {
				iOff += fts5GetVarint32(&pLeaf->p[iOff], nTerm);
				res = memcmp(&pLeaf->p[iOff], zIdxTerm, MIN(nTerm, nIdxTerm));
				if (res == 0) res = nTerm - nIdxTerm;
				if (res<0) p->rc = FTS5_CORRUPT;
			}

			fts5IntegrityCheckPgidx(p, pLeaf);
		}
		fts5DataRelease(pLeaf);
		if (p->rc) break;

		
		fts5IndexIntegrityCheckEmpty(
			p, pSeg, iIdxPrevLeaf + 1, iDlidxPrevLeaf + 1, iIdxLeaf - 1
		);
		if (p->rc) break;

		
		if (bIdxDlidx) {
			Fts5DlidxIter *pDlidx = 0;  
			int iPrevLeaf = iIdxLeaf;
			int iSegid = pSeg->iSegid;
			int iPg = 0;
			i64 iKey;

			for (pDlidx = fts5DlidxIterInit(p, 0, iSegid, iIdxLeaf);
				fts5DlidxIterEof(p, pDlidx) == 0;
				fts5DlidxIterNext(p, pDlidx)
				) {

				
				for (iPg = iPrevLeaf + 1; iPg<fts5DlidxIterPgno(pDlidx); iPg++) {
					iKey = FTS5_SEGMENT_ROWID(iSegid, iPg);
					pLeaf = fts5DataRead(p, iKey);
					if (pLeaf) {
						if (fts5LeafFirstRowidOff(pLeaf) != 0) p->rc = FTS5_CORRUPT;
						fts5DataRelease(pLeaf);
					}
				}
				iPrevLeaf = fts5DlidxIterPgno(pDlidx);

				
				iKey = FTS5_SEGMENT_ROWID(iSegid, iPrevLeaf);
				pLeaf = fts5DataRead(p, iKey);
				if (pLeaf) {
					i64 iRowid;
					int iRowidOff = fts5LeafFirstRowidOff(pLeaf);
					ASSERT_SZLEAF_OK(pLeaf);
					if (iRowidOff >= pLeaf->szLeaf) {
						p->rc = FTS5_CORRUPT;
					}
					else {
						fts5GetVarint(&pLeaf->p[iRowidOff], (u64*)&iRowid);
						if (iRowid != fts5DlidxIterRowid(pDlidx)) p->rc = FTS5_CORRUPT;
					}
					fts5DataRelease(pLeaf);
				}
			}

			iDlidxPrevLeaf = iPg;
			fts5DlidxIterFree(pDlidx);
			fts5TestDlidxReverse(p, iSegid, iIdxLeaf);
		}
		else {
			iDlidxPrevLeaf = pSeg->pgnoLast;
			
		}

		iIdxPrevLeaf = iIdxLeaf;
	}

	rc2 = sqlite3_finalize(pStmt);
	if (p->rc == SQLITE_OK) p->rc = rc2;

	
#if 0
	if (p->rc == SQLITE_OK && iter.iLeaf != pSeg->pgnoLast) {
		p->rc = FTS5_CORRUPT;
	}
#endif
}



static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum) {
	int eDetail = p->pConfig->eDetail;
	u64 cksum2 = 0;                 
	Fts5Buffer poslist = { 0,0,0 };   
	Fts5Iter *pIter;                
	Fts5Structure *pStruct;         

#ifdef SQLITE_DEBUG
									
	u64 cksum3 = 0;                 
	Fts5Buffer term = { 0,0,0 };      
#endif
	const int flags = FTS5INDEX_QUERY_NOOUTPUT;

	
	pStruct = fts5StructureRead(p);

	
	if (pStruct) {
		int iLvl, iSeg;
		for (iLvl = 0; iLvl<pStruct->nLevel; iLvl++) {
			for (iSeg = 0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++) {
				Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];
				fts5IndexIntegrityCheckSegment(p, pSeg);
			}
		}
	}

	
	for (fts5MultiIterNew(p, pStruct, flags, 0, 0, 0, -1, 0, &pIter);
		fts5MultiIterEof(p, pIter) == 0;
		fts5MultiIterNext(p, pIter, 0, 0)
		) {
		int n;                      
		i64 iPos = 0;               
		int iOff = 0;               
		i64 iRowid = fts5MultiIterRowid(pIter);
		char *z = (char*)fts5MultiIterTerm(pIter, &n);

		
		fts5TestTerm(p, &term, z, n, cksum2, &cksum3);

		if (eDetail == FTS5_DETAIL_NONE) {
			if (0 == fts5MultiIterIsEmpty(p, pIter)) {
				cksum2 ^= sqlite3Fts5IndexEntryCksum(iRowid, 0, 0, -1, z, n);
			}
		}
		else {
			poslist.n = 0;
			fts5SegiterPoslist(p, &pIter->aSeg[pIter->aFirst[1].iFirst], 0, &poslist);
			while (0 == sqlite3Fts5PoslistNext64(poslist.p, poslist.n, &iOff, &iPos)) {
				int iCol = FTS5_POS2COLUMN(iPos);
				int iTokOff = FTS5_POS2OFFSET(iPos);
				cksum2 ^= sqlite3Fts5IndexEntryCksum(iRowid, iCol, iTokOff, -1, z, n);
			}
		}
	}
	fts5TestTerm(p, &term, 0, 0, cksum2, &cksum3);

	fts5MultiIterFree(pIter);
	if (p->rc == SQLITE_OK && cksum != cksum2) p->rc = FTS5_CORRUPT;

	fts5StructureRelease(pStruct);
#ifdef SQLITE_DEBUG
	fts5BufferFree(&term);
#endif
	fts5BufferFree(&poslist);
	return fts5IndexReturn(p);
}




static void fts5DecodeRowid(
	i64 iRowid,                     
	int *piSegid,                   
	int *pbDlidx,                   
	int *piHeight,                  
	int *piPgno                     
) {
	*piPgno = (int)(iRowid & (((i64)1 << FTS5_DATA_PAGE_B) - 1));
	iRowid >>= FTS5_DATA_PAGE_B;

	*piHeight = (int)(iRowid & (((i64)1 << FTS5_DATA_HEIGHT_B) - 1));
	iRowid >>= FTS5_DATA_HEIGHT_B;

	*pbDlidx = (int)(iRowid & 0x0001);
	iRowid >>= FTS5_DATA_DLI_B;

	*piSegid = (int)(iRowid & (((i64)1 << FTS5_DATA_ID_B) - 1));
}

static void fts5DebugRowid(int *pRc, Fts5Buffer *pBuf, i64 iKey) {
	int iSegid, iHeight, iPgno, bDlidx;       
	fts5DecodeRowid(iKey, &iSegid, &bDlidx, &iHeight, &iPgno);

	if (iSegid == 0) {
		if (iKey == FTS5_AVERAGES_ROWID) {
			sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{averages} ");
		}
		else {
			sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{structure}");
		}
	}
	else {
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{%ssegid=%d h=%d pgno=%d}",
			bDlidx ? "dlidx " : "", iSegid, iHeight, iPgno
		);
	}
}

static void fts5DebugStructure(
	int *pRc,                       
	Fts5Buffer *pBuf,
	Fts5Structure *p
) {
	int iLvl, iSeg;                 

	for (iLvl = 0; iLvl<p->nLevel; iLvl++) {
		Fts5StructureLevel *pLvl = &p->aLevel[iLvl];
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf,
			" {lvl=%d nMerge=%d nSeg=%d", iLvl, pLvl->nMerge, pLvl->nSeg
		);
		for (iSeg = 0; iSeg<pLvl->nSeg; iSeg++) {
			Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];
			sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " {id=%d leaves=%d..%d}",
				pSeg->iSegid, pSeg->pgnoFirst, pSeg->pgnoLast
			);
		}
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "}");
	}
}


static void fts5DecodeStructure(
	int *pRc,                       
	Fts5Buffer *pBuf,
	const u8 *pBlob, int nBlob
) {
	int rc;                         
	Fts5Structure *p = 0;           

	rc = fts5StructureDecode(pBlob, nBlob, 0, &p);
	if (rc != SQLITE_OK) {
		*pRc = rc;
		return;
	}

	fts5DebugStructure(pRc, pBuf, p);
	fts5StructureRelease(p);
}


static void fts5DecodeAverages(
	int *pRc,                       
	Fts5Buffer *pBuf,
	const u8 *pBlob, int nBlob
) {
	int i = 0;
	const char *zSpace = "";

	while (i<nBlob) {
		u64 iVal;
		i += sqlite3Fts5GetVarint(&pBlob[i], &iVal);
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "%s%d", zSpace, (int)iVal);
		zSpace = " ";
	}
}


static int fts5DecodePoslist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n) {
	int iOff = 0;
	while (iOff<n) {
		int iVal;
		iOff += fts5GetVarint32(&a[iOff], iVal);
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " %d", iVal);
	}
	return iOff;
}


static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n) {
	i64 iDocid = 0;
	int iOff = 0;

	if (n>0) {
		iOff = sqlite3Fts5GetVarint(a, (u64*)&iDocid);
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
	}
	while (iOff<n) {
		int nPos;
		int bDel;
		iOff += fts5GetPoslistSize(&a[iOff], &nPos, &bDel);
		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " nPos=%d%s", nPos, bDel ? "*" : "");
		iOff += fts5DecodePoslist(pRc, pBuf, &a[iOff], MIN(n - iOff, nPos));
		if (iOff<n) {
			i64 iDelta;
			iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&iDelta);
			iDocid += iDelta;
			sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
		}
	}

	return iOff;
}


static void fts5DecodeRowidList(
	int *pRc,                       
	Fts5Buffer *pBuf,               
	const u8 *pData, int nData      
) {
	int i = 0;
	i64 iRowid = 0;

	while (i<nData) {
		const char *zApp = "";
		u64 iVal;
		i += sqlite3Fts5GetVarint(&pData[i], &iVal);
		iRowid += iVal;

		if (i<nData && pData[i] == 0x00) {
			i++;
			if (i<nData && pData[i] == 0x00) {
				i++;
				zApp = "+";
			}
			else {
				zApp = "*";
			}
		}

		sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " %lld%s", iRowid, zApp);
	}
}


static void fts5DecodeFunction(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	i64 iRowid;                     
	int iSegid, iHeight, iPgno, bDlidx;
	const u8 *aBlob; int n;         
	u8 *a = 0;
	Fts5Buffer s;                   
	int rc = SQLITE_OK;             
	int nSpace = 0;
	int eDetailNone = (sqlite3_user_data(pCtx) != 0);

	assert(nArg == 2);
	UNUSED_PARAM(nArg);
	memset(&s, 0, sizeof(Fts5Buffer));
	iRowid = sqlite3_value_int64(apVal[0]);

	
	n = sqlite3_value_bytes(apVal[1]);
	aBlob = sqlite3_value_blob(apVal[1]);
	nSpace = n + FTS5_DATA_ZERO_PADDING;
	a = (u8*)sqlite3Fts5MallocZero(&rc, nSpace);
	if (a == 0) goto decode_out;
	memcpy(a, aBlob, n);


	fts5DecodeRowid(iRowid, &iSegid, &bDlidx, &iHeight, &iPgno);

	fts5DebugRowid(&rc, &s, iRowid);
	if (bDlidx) {
		Fts5Data dlidx;
		Fts5DlidxLvl lvl;

		dlidx.p = a;
		dlidx.nn = n;

		memset(&lvl, 0, sizeof(Fts5DlidxLvl));
		lvl.pData = &dlidx;
		lvl.iLeafPgno = iPgno;

		for (fts5DlidxLvlNext(&lvl); lvl.bEof == 0; fts5DlidxLvlNext(&lvl)) {
			sqlite3Fts5BufferAppendPrintf(&rc, &s,
				" %d(%lld)", lvl.iLeafPgno, lvl.iRowid
			);
		}
	}
	else if (iSegid == 0) {
		if (iRowid == FTS5_AVERAGES_ROWID) {
			fts5DecodeAverages(&rc, &s, a, n);
		}
		else {
			fts5DecodeStructure(&rc, &s, a, n);
		}
	}
	else if (eDetailNone) {
		Fts5Buffer term;              
		int szLeaf;
		int iPgidxOff = szLeaf = fts5GetU16(&a[2]);
		int iTermOff;
		int nKeep = 0;
		int iOff;

		memset(&term, 0, sizeof(Fts5Buffer));

		
		if (szLeaf<n) {
			iPgidxOff += fts5GetVarint32(&a[iPgidxOff], iTermOff);
		}
		else {
			iTermOff = szLeaf;
		}
		fts5DecodeRowidList(&rc, &s, &a[4], iTermOff - 4);

		iOff = iTermOff;
		while (iOff<szLeaf) {
			int nAppend;

			
			iOff += fts5GetVarint32(&a[iOff], nAppend);
			term.n = nKeep;
			fts5BufferAppendBlob(&rc, &term, nAppend, &a[iOff]);
			sqlite3Fts5BufferAppendPrintf(
				&rc, &s, " term=%.*s", term.n, (const char*)term.p
			);
			iOff += nAppend;

			
			if (iPgidxOff<n) {
				int nIncr;
				iPgidxOff += fts5GetVarint32(&a[iPgidxOff], nIncr);
				iTermOff += nIncr;
			}
			else {
				iTermOff = szLeaf;
			}

			fts5DecodeRowidList(&rc, &s, &a[iOff], iTermOff - iOff);
			iOff = iTermOff;
			if (iOff<szLeaf) {
				iOff += fts5GetVarint32(&a[iOff], nKeep);
			}
		}

		fts5BufferFree(&term);
	}
	else {
		Fts5Buffer term;              
		int szLeaf;                   
		int iPgidxOff;
		int iPgidxPrev = 0;           
		int iTermOff = 0;
		int iRowidOff = 0;
		int iOff;
		int nDoclist;

		memset(&term, 0, sizeof(Fts5Buffer));

		if (n<4) {
			sqlite3Fts5BufferSet(&rc, &s, 7, (const u8*)"corrupt");
			goto decode_out;
		}
		else {
			iRowidOff = fts5GetU16(&a[0]);
			iPgidxOff = szLeaf = fts5GetU16(&a[2]);
			if (iPgidxOff<n) {
				fts5GetVarint32(&a[iPgidxOff], iTermOff);
			}
		}

		
		if (iRowidOff != 0) {
			iOff = iRowidOff;
		}
		else if (iTermOff != 0) {
			iOff = iTermOff;
		}
		else {
			iOff = szLeaf;
		}
		fts5DecodePoslist(&rc, &s, &a[4], iOff - 4);

		
		nDoclist = (iTermOff ? iTermOff : szLeaf) - iOff;
		fts5DecodeDoclist(&rc, &s, &a[iOff], nDoclist);

		while (iPgidxOff<n) {
			int bFirst = (iPgidxOff == szLeaf);     
			int nByte;                            
			int iEnd;

			iPgidxOff += fts5GetVarint32(&a[iPgidxOff], nByte);
			iPgidxPrev += nByte;
			iOff = iPgidxPrev;

			if (iPgidxOff<n) {
				fts5GetVarint32(&a[iPgidxOff], nByte);
				iEnd = iPgidxPrev + nByte;
			}
			else {
				iEnd = szLeaf;
			}

			if (bFirst == 0) {
				iOff += fts5GetVarint32(&a[iOff], nByte);
				term.n = nByte;
			}
			iOff += fts5GetVarint32(&a[iOff], nByte);
			fts5BufferAppendBlob(&rc, &term, nByte, &a[iOff]);
			iOff += nByte;

			sqlite3Fts5BufferAppendPrintf(
				&rc, &s, " term=%.*s", term.n, (const char*)term.p
			);
			iOff += fts5DecodeDoclist(&rc, &s, &a[iOff], iEnd - iOff);
		}

		fts5BufferFree(&term);
	}

decode_out:
	sqlite3_free(a);
	if (rc == SQLITE_OK) {
		sqlite3_result_text(pCtx, (const char*)s.p, s.n, SQLITE_TRANSIENT);
	}
	else {
		sqlite3_result_error_code(pCtx, rc);
	}
	fts5BufferFree(&s);
}


static void fts5RowidFunction(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apVal           
) {
	const char *zArg;
	if (nArg == 0) {
		sqlite3_result_error(pCtx, "should be: fts5_rowid(subject, ....)", -1);
	}
	else {
		zArg = (const char*)sqlite3_value_text(apVal[0]);
		if (0 == sqlite3_stricmp(zArg, "segment")) {
			i64 iRowid;
			int segid, pgno;
			if (nArg != 3) {
				sqlite3_result_error(pCtx,
					"should be: fts5_rowid('segment', segid, pgno))", -1
				);
			}
			else {
				segid = sqlite3_value_int(apVal[1]);
				pgno = sqlite3_value_int(apVal[2]);
				iRowid = FTS5_SEGMENT_ROWID(segid, pgno);
				sqlite3_result_int64(pCtx, iRowid);
			}
		}
		else {
			sqlite3_result_error(pCtx,
				"first arg to fts5_rowid() must be 'segment'", -1
			);
		}
	}
}


static int sqlite3Fts5IndexInit(sqlite3 *db) {
	int rc = sqlite3_create_function(
		db, "fts5_decode", 2, SQLITE_UTF8, 0, fts5DecodeFunction, 0, 0
	);

	if (rc == SQLITE_OK) {
		rc = sqlite3_create_function(
			db, "fts5_decode_none", 2,
			SQLITE_UTF8, (void*)db, fts5DecodeFunction, 0, 0
		);
	}

	if (rc == SQLITE_OK) {
		rc = sqlite3_create_function(
			db, "fts5_rowid", -1, SQLITE_UTF8, 0, fts5RowidFunction, 0, 0
		);
	}
	return rc;
}


static int sqlite3Fts5IndexReset(Fts5Index *p) {
	assert(p->pStruct == 0 || p->iStructVersion != 0);
	if (fts5IndexDataVersion(p) != p->iStructVersion) {
		fts5StructureInvalidate(p);
	}
	return fts5IndexReturn(p);
}







SQLITE_API int sqlite3_fts5_may_be_corrupt = 1;


typedef struct Fts5Auxdata Fts5Auxdata;
typedef struct Fts5Auxiliary Fts5Auxiliary;
typedef struct Fts5Cursor Fts5Cursor;
typedef struct Fts5Sorter Fts5Sorter;
typedef struct Fts5Table Fts5Table;
typedef struct Fts5TokenizerModule Fts5TokenizerModule;


struct Fts5TransactionState {
	int eState;                     
	int iSavepoint;                 
};


struct Fts5Global {
	fts5_api api;                   
	sqlite3 *db;                    
	i64 iNextId;                    
	Fts5Auxiliary *pAux;            
	Fts5TokenizerModule *pTok;      
	Fts5TokenizerModule *pDfltTok;  
	Fts5Cursor *pCsr;               
};


struct Fts5Auxiliary {
	Fts5Global *pGlobal;            
	char *zFunc;                    
	void *pUserData;                
	fts5_extension_function xFunc;  
	void(*xDestroy)(void*);        
	Fts5Auxiliary *pNext;           
};


struct Fts5TokenizerModule {
	char *zName;                    
	void *pUserData;                
	fts5_tokenizer x;               
	void(*xDestroy)(void*);        
	Fts5TokenizerModule *pNext;     
};


struct Fts5Table {
	sqlite3_vtab base;              
	Fts5Config *pConfig;            
	Fts5Index *pIndex;              
	Fts5Storage *pStorage;          
	Fts5Global *pGlobal;            
	Fts5Cursor *pSortCsr;           
#ifdef SQLITE_DEBUG
	struct Fts5TransactionState ts;
#endif
};

struct Fts5MatchPhrase {
	Fts5Buffer *pPoslist;           
	int nTerm;                      
};


struct Fts5Sorter {
	sqlite3_stmt *pStmt;
	i64 iRowid;                     
	const u8 *aPoslist;             
	int nIdx;                       
	int aIdx[1];                    
};



struct Fts5Cursor {
	sqlite3_vtab_cursor base;       
	Fts5Cursor *pNext;              
	int *aColumnSize;               
	i64 iCsrId;                     

									
	int ePlan;                      
	int bDesc;                      
	i64 iFirstRowid;                
	i64 iLastRowid;                 
	sqlite3_stmt *pStmt;            
	Fts5Expr *pExpr;                
	Fts5Sorter *pSorter;            
	int csrflags;                   
	i64 iSpecial;                   

									
	char *zRank;                    
	char *zRankArgs;                
	Fts5Auxiliary *pRank;           
	int nRankArg;                   
	sqlite3_value **apRankArg;      
	sqlite3_stmt *pRankArgStmt;     

									
	Fts5Auxiliary *pAux;            
	Fts5Auxdata *pAuxdata;          

									
	Fts5PoslistReader *aInstIter;   
	int nInstAlloc;                 
	int nInstCount;                 
	int *aInst;                     
};


#define FTS5_BI_MATCH        0x0001         
#define FTS5_BI_RANK         0x0002         
#define FTS5_BI_ROWID_EQ     0x0004         
#define FTS5_BI_ROWID_LE     0x0008         
#define FTS5_BI_ROWID_GE     0x0010         

#define FTS5_BI_ORDER_RANK   0x0020
#define FTS5_BI_ORDER_ROWID  0x0040
#define FTS5_BI_ORDER_DESC   0x0080


#define FTS5CSR_EOF               0x01
#define FTS5CSR_REQUIRE_CONTENT   0x02
#define FTS5CSR_REQUIRE_DOCSIZE   0x04
#define FTS5CSR_REQUIRE_INST      0x08
#define FTS5CSR_FREE_ZRANK        0x10
#define FTS5CSR_REQUIRE_RESEEK    0x20
#define FTS5CSR_REQUIRE_POSLIST   0x40

#define BitFlagAllTest(x,y) (((x) & (y))==(y))
#define BitFlagTest(x,y)    (((x) & (y))!=0)



#define CsrFlagSet(pCsr, flag)   ((pCsr)->csrflags |= (flag))
#define CsrFlagClear(pCsr, flag) ((pCsr)->csrflags &= ~(flag))
#define CsrFlagTest(pCsr, flag)  ((pCsr)->csrflags & (flag))

struct Fts5Auxdata {
	Fts5Auxiliary *pAux;            
	void *pPtr;                     
	void(*xDelete)(void*);          
	Fts5Auxdata *pNext;             
};

#ifdef SQLITE_DEBUG
#define FTS5_BEGIN      1
#define FTS5_SYNC       2
#define FTS5_COMMIT     3
#define FTS5_ROLLBACK   4
#define FTS5_SAVEPOINT  5
#define FTS5_RELEASE    6
#define FTS5_ROLLBACKTO 7
static void fts5CheckTransactionState(Fts5Table *p, int op, int iSavepoint) {
	switch (op) {
	case FTS5_BEGIN:
		assert(p->ts.eState == 0);
		p->ts.eState = 1;
		p->ts.iSavepoint = -1;
		break;

	case FTS5_SYNC:
		assert(p->ts.eState == 1);
		p->ts.eState = 2;
		break;

	case FTS5_COMMIT:
		assert(p->ts.eState == 2);
		p->ts.eState = 0;
		break;

	case FTS5_ROLLBACK:
		assert(p->ts.eState == 1 || p->ts.eState == 2 || p->ts.eState == 0);
		p->ts.eState = 0;
		break;

	case FTS5_SAVEPOINT:
		assert(p->ts.eState == 1);
		assert(iSavepoint >= 0);
		assert(iSavepoint>p->ts.iSavepoint);
		p->ts.iSavepoint = iSavepoint;
		break;

	case FTS5_RELEASE:
		assert(p->ts.eState == 1);
		assert(iSavepoint >= 0);
		assert(iSavepoint <= p->ts.iSavepoint);
		p->ts.iSavepoint = iSavepoint - 1;
		break;

	case FTS5_ROLLBACKTO:
		assert(p->ts.eState == 1);
		assert(iSavepoint >= 0);
		assert(iSavepoint <= p->ts.iSavepoint);
		p->ts.iSavepoint = iSavepoint;
		break;
	}
}
#else
# define fts5CheckTransactionState(x,y,z)
#endif


static int fts5IsContentless(Fts5Table *pTab) {
	return pTab->pConfig->eContent == FTS5_CONTENT_NONE;
}


static void fts5FreeVtab(Fts5Table *pTab) {
	if (pTab) {
		sqlite3Fts5IndexClose(pTab->pIndex);
		sqlite3Fts5StorageClose(pTab->pStorage);
		sqlite3Fts5ConfigFree(pTab->pConfig);
		sqlite3_free(pTab);
	}
}


static int fts5DisconnectMethod(sqlite3_vtab *pVtab) {
	fts5FreeVtab((Fts5Table*)pVtab);
	return SQLITE_OK;
}


static int fts5DestroyMethod(sqlite3_vtab *pVtab) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	int rc = sqlite3Fts5DropAll(pTab->pConfig);
	if (rc == SQLITE_OK) {
		fts5FreeVtab((Fts5Table*)pVtab);
	}
	return rc;
}


static int fts5InitVtab(
	int bCreate,                    
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVTab,          
	char **pzErr                    
) {
	Fts5Global *pGlobal = (Fts5Global*)pAux;
	const char **azConfig = (const char**)argv;
	int rc = SQLITE_OK;             
	Fts5Config *pConfig = 0;        
	Fts5Table *pTab = 0;            

									
	pTab = (Fts5Table*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Table));
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5ConfigParse(pGlobal, db, argc, azConfig, &pConfig, pzErr);
		assert((rc == SQLITE_OK && *pzErr == 0) || pConfig == 0);
	}
	if (rc == SQLITE_OK) {
		pTab->pConfig = pConfig;
		pTab->pGlobal = pGlobal;
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexOpen(pConfig, bCreate, &pTab->pIndex, pzErr);
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5StorageOpen(
			pConfig, pTab->pIndex, bCreate, &pTab->pStorage, pzErr
		);
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5ConfigDeclareVtab(pConfig);
	}

	
	if (rc == SQLITE_OK) {
		assert(pConfig->pzErrmsg == 0);
		pConfig->pzErrmsg = pzErr;
		rc = sqlite3Fts5IndexLoadConfig(pTab->pIndex);
		sqlite3Fts5IndexRollback(pTab->pIndex);
		pConfig->pzErrmsg = 0;
	}

	if (rc != SQLITE_OK) {
		fts5FreeVtab(pTab);
		pTab = 0;
	}
	else if (bCreate) {
		fts5CheckTransactionState(pTab, FTS5_BEGIN, 0);
	}
	*ppVTab = (sqlite3_vtab*)pTab;
	return rc;
}


static int fts5ConnectMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts5InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);
}
static int fts5CreateMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts5InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);
}


#define FTS5_PLAN_MATCH          1       
#define FTS5_PLAN_SOURCE         2       
#define FTS5_PLAN_SPECIAL        3       
#define FTS5_PLAN_SORTED_MATCH   4       
#define FTS5_PLAN_SCAN           5       
#define FTS5_PLAN_ROWID          6       


static void fts5SetUniqueFlag(sqlite3_index_info *pIdxInfo) {
#if SQLITE_VERSION_NUMBER>=3008012
#ifndef SQLITE_CORE
	if (sqlite3_libversion_number() >= 3008012)
#endif
	{
		pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;
	}
#endif
}


static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo) {
	Fts5Table *pTab = (Fts5Table*)pVTab;
	Fts5Config *pConfig = pTab->pConfig;
	int idxFlags = 0;               
	int bHasMatch;
	int iNext;
	int i;

	struct Constraint {
		int op;                       
		int fts5op;                   
		int iCol;                     
		int omit;                     
		int iConsIndex;               
	} aConstraint[] = {
		{ SQLITE_INDEX_CONSTRAINT_MATCH | SQLITE_INDEX_CONSTRAINT_EQ,
		FTS5_BI_MATCH,    1, 1, -1 },
		{ SQLITE_INDEX_CONSTRAINT_MATCH | SQLITE_INDEX_CONSTRAINT_EQ,
		FTS5_BI_RANK,     2, 1, -1 },
		{ SQLITE_INDEX_CONSTRAINT_EQ,    FTS5_BI_ROWID_EQ, 0, 0, -1 },
		{ SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_LE,
		FTS5_BI_ROWID_LE, 0, 0, -1 },
		{ SQLITE_INDEX_CONSTRAINT_GT | SQLITE_INDEX_CONSTRAINT_GE,
		FTS5_BI_ROWID_GE, 0, 0, -1 },
	};

	int aColMap[3];
	aColMap[0] = -1;
	aColMap[1] = pConfig->nCol;
	aColMap[2] = pConfig->nCol + 1;

	
	for (i = 0; i<pInfo->nConstraint; i++) {
		struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
		int j;
		for (j = 0; j<ArraySize(aConstraint); j++) {
			struct Constraint *pC = &aConstraint[j];
			if (p->iColumn == aColMap[pC->iCol] && p->op & pC->op) {
				if (p->usable) {
					pC->iConsIndex = i;
					idxFlags |= pC->fts5op;
				}
				else if (j == 0) {
					
					pInfo->estimatedCost = 1e50;
					return SQLITE_OK;
				}
			}
		}
	}

	
	if (pInfo->nOrderBy == 1) {
		int iSort = pInfo->aOrderBy[0].iColumn;
		if (iSort == (pConfig->nCol + 1) && BitFlagTest(idxFlags, FTS5_BI_MATCH)) {
			idxFlags |= FTS5_BI_ORDER_RANK;
		}
		else if (iSort == -1) {
			idxFlags |= FTS5_BI_ORDER_ROWID;
		}
		if (BitFlagTest(idxFlags, FTS5_BI_ORDER_RANK | FTS5_BI_ORDER_ROWID)) {
			pInfo->orderByConsumed = 1;
			if (pInfo->aOrderBy[0].desc) {
				idxFlags |= FTS5_BI_ORDER_DESC;
			}
		}
	}

	
	bHasMatch = BitFlagTest(idxFlags, FTS5_BI_MATCH);
	if (BitFlagTest(idxFlags, FTS5_BI_ROWID_EQ)) {
		pInfo->estimatedCost = bHasMatch ? 100.0 : 10.0;
		if (bHasMatch == 0) fts5SetUniqueFlag(pInfo);
	}
	else if (BitFlagAllTest(idxFlags, FTS5_BI_ROWID_LE | FTS5_BI_ROWID_GE)) {
		pInfo->estimatedCost = bHasMatch ? 500.0 : 250000.0;
	}
	else if (BitFlagTest(idxFlags, FTS5_BI_ROWID_LE | FTS5_BI_ROWID_GE)) {
		pInfo->estimatedCost = bHasMatch ? 750.0 : 750000.0;
	}
	else {
		pInfo->estimatedCost = bHasMatch ? 1000.0 : 1000000.0;
	}

	
	iNext = 1;
	for (i = 0; i<ArraySize(aConstraint); i++) {
		struct Constraint *pC = &aConstraint[i];
		if (pC->iConsIndex >= 0) {
			pInfo->aConstraintUsage[pC->iConsIndex].argvIndex = iNext++;
			pInfo->aConstraintUsage[pC->iConsIndex].omit = (unsigned char)pC->omit;
		}
	}

	pInfo->idxNum = idxFlags;
	return SQLITE_OK;
}

static int fts5NewTransaction(Fts5Table *pTab) {
	Fts5Cursor *pCsr;
	for (pCsr = pTab->pGlobal->pCsr; pCsr; pCsr = pCsr->pNext) {
		if (pCsr->base.pVtab == (sqlite3_vtab*)pTab) return SQLITE_OK;
	}
	return sqlite3Fts5StorageReset(pTab->pStorage);
}


static int fts5OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr) {
	Fts5Table *pTab = (Fts5Table*)pVTab;
	Fts5Config *pConfig = pTab->pConfig;
	Fts5Cursor *pCsr = 0;           
	int nByte;                      
	int rc;                         

	rc = fts5NewTransaction(pTab);
	if (rc == SQLITE_OK) {
		nByte = sizeof(Fts5Cursor) + pConfig->nCol * sizeof(int);
		pCsr = (Fts5Cursor*)sqlite3_malloc(nByte);
		if (pCsr) {
			Fts5Global *pGlobal = pTab->pGlobal;
			memset(pCsr, 0, nByte);
			pCsr->aColumnSize = (int*)&pCsr[1];
			pCsr->pNext = pGlobal->pCsr;
			pGlobal->pCsr = pCsr;
			pCsr->iCsrId = ++pGlobal->iNextId;
		}
		else {
			rc = SQLITE_NOMEM;
		}
	}
	*ppCsr = (sqlite3_vtab_cursor*)pCsr;
	return rc;
}

static int fts5StmtType(Fts5Cursor *pCsr) {
	if (pCsr->ePlan == FTS5_PLAN_SCAN) {
		return (pCsr->bDesc) ? FTS5_STMT_SCAN_DESC : FTS5_STMT_SCAN_ASC;
	}
	return FTS5_STMT_LOOKUP;
}


static void fts5CsrNewrow(Fts5Cursor *pCsr) {
	CsrFlagSet(pCsr,
		FTS5CSR_REQUIRE_CONTENT
		| FTS5CSR_REQUIRE_DOCSIZE
		| FTS5CSR_REQUIRE_INST
		| FTS5CSR_REQUIRE_POSLIST
	);
}

static void fts5FreeCursorComponents(Fts5Cursor *pCsr) {
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	Fts5Auxdata *pData;
	Fts5Auxdata *pNext;

	sqlite3_free(pCsr->aInstIter);
	sqlite3_free(pCsr->aInst);
	if (pCsr->pStmt) {
		int eStmt = fts5StmtType(pCsr);
		sqlite3Fts5StorageStmtRelease(pTab->pStorage, eStmt, pCsr->pStmt);
	}
	if (pCsr->pSorter) {
		Fts5Sorter *pSorter = pCsr->pSorter;
		sqlite3_finalize(pSorter->pStmt);
		sqlite3_free(pSorter);
	}

	if (pCsr->ePlan != FTS5_PLAN_SOURCE) {
		sqlite3Fts5ExprFree(pCsr->pExpr);
	}

	for (pData = pCsr->pAuxdata; pData; pData = pNext) {
		pNext = pData->pNext;
		if (pData->xDelete) pData->xDelete(pData->pPtr);
		sqlite3_free(pData);
	}

	sqlite3_finalize(pCsr->pRankArgStmt);
	sqlite3_free(pCsr->apRankArg);

	if (CsrFlagTest(pCsr, FTS5CSR_FREE_ZRANK)) {
		sqlite3_free(pCsr->zRank);
		sqlite3_free(pCsr->zRankArgs);
	}

	memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));
}



static int fts5CloseMethod(sqlite3_vtab_cursor *pCursor) {
	if (pCursor) {
		Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
		Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
		Fts5Cursor **pp;

		fts5FreeCursorComponents(pCsr);
		
		for (pp = &pTab->pGlobal->pCsr; (*pp) != pCsr; pp = &(*pp)->pNext);
		*pp = pCsr->pNext;

		sqlite3_free(pCsr);
	}
	return SQLITE_OK;
}

static int fts5SorterNext(Fts5Cursor *pCsr) {
	Fts5Sorter *pSorter = pCsr->pSorter;
	int rc;

	rc = sqlite3_step(pSorter->pStmt);
	if (rc == SQLITE_DONE) {
		rc = SQLITE_OK;
		CsrFlagSet(pCsr, FTS5CSR_EOF);
	}
	else if (rc == SQLITE_ROW) {
		const u8 *a;
		const u8 *aBlob;
		int nBlob;
		int i;
		int iOff = 0;
		rc = SQLITE_OK;

		pSorter->iRowid = sqlite3_column_int64(pSorter->pStmt, 0);
		nBlob = sqlite3_column_bytes(pSorter->pStmt, 1);
		aBlob = a = sqlite3_column_blob(pSorter->pStmt, 1);

		
		if (nBlob>0) {
			for (i = 0; i<(pSorter->nIdx - 1); i++) {
				int iVal;
				a += fts5GetVarint32(a, iVal);
				iOff += iVal;
				pSorter->aIdx[i] = iOff;
			}
			pSorter->aIdx[i] = &aBlob[nBlob] - a;
			pSorter->aPoslist = a;
		}

		fts5CsrNewrow(pCsr);
	}

	return rc;
}



static void fts5TripCursors(Fts5Table *pTab) {
	Fts5Cursor *pCsr;
	for (pCsr = pTab->pGlobal->pCsr; pCsr; pCsr = pCsr->pNext) {
		if (pCsr->ePlan == FTS5_PLAN_MATCH
			&& pCsr->base.pVtab == (sqlite3_vtab*)pTab
			) {
			CsrFlagSet(pCsr, FTS5CSR_REQUIRE_RESEEK);
		}
	}
}


static int fts5CursorReseek(Fts5Cursor *pCsr, int *pbSkip) {
	int rc = SQLITE_OK;
	assert(*pbSkip == 0);
	if (CsrFlagTest(pCsr, FTS5CSR_REQUIRE_RESEEK)) {
		Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
		int bDesc = pCsr->bDesc;
		i64 iRowid = sqlite3Fts5ExprRowid(pCsr->pExpr);

		rc = sqlite3Fts5ExprFirst(pCsr->pExpr, pTab->pIndex, iRowid, bDesc);
		if (rc == SQLITE_OK &&  iRowid != sqlite3Fts5ExprRowid(pCsr->pExpr)) {
			*pbSkip = 1;
		}

		CsrFlagClear(pCsr, FTS5CSR_REQUIRE_RESEEK);
		fts5CsrNewrow(pCsr);
		if (sqlite3Fts5ExprEof(pCsr->pExpr)) {
			CsrFlagSet(pCsr, FTS5CSR_EOF);
			*pbSkip = 1;
		}
	}
	return rc;
}



static int fts5NextMethod(sqlite3_vtab_cursor *pCursor) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
	int rc;

	assert((pCsr->ePlan<3) ==
		(pCsr->ePlan == FTS5_PLAN_MATCH || pCsr->ePlan == FTS5_PLAN_SOURCE)
	);
	assert(!CsrFlagTest(pCsr, FTS5CSR_EOF));

	if (pCsr->ePlan<3) {
		int bSkip = 0;
		if ((rc = fts5CursorReseek(pCsr, &bSkip)) || bSkip) return rc;
		rc = sqlite3Fts5ExprNext(pCsr->pExpr, pCsr->iLastRowid);
		CsrFlagSet(pCsr, sqlite3Fts5ExprEof(pCsr->pExpr));
		fts5CsrNewrow(pCsr);
	}
	else {
		switch (pCsr->ePlan) {
		case FTS5_PLAN_SPECIAL: {
			CsrFlagSet(pCsr, FTS5CSR_EOF);
			rc = SQLITE_OK;
			break;
		}

		case FTS5_PLAN_SORTED_MATCH: {
			rc = fts5SorterNext(pCsr);
			break;
		}

		default:
			rc = sqlite3_step(pCsr->pStmt);
			if (rc != SQLITE_ROW) {
				CsrFlagSet(pCsr, FTS5CSR_EOF);
				rc = sqlite3_reset(pCsr->pStmt);
			}
			else {
				rc = SQLITE_OK;
			}
			break;
		}
	}

	return rc;
}


static int fts5PrepareStatement(
	sqlite3_stmt **ppStmt,
	Fts5Config *pConfig,
	const char *zFmt,
	...
) {
	sqlite3_stmt *pRet = 0;
	int rc;
	char *zSql;
	va_list ap;

	va_start(ap, zFmt);
	zSql = sqlite3_vmprintf(zFmt, ap);
	if (zSql == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pRet, 0);
		if (rc != SQLITE_OK) {
			*pConfig->pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(pConfig->db));
		}
		sqlite3_free(zSql);
	}

	va_end(ap);
	*ppStmt = pRet;
	return rc;
}

static int fts5CursorFirstSorted(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc) {
	Fts5Config *pConfig = pTab->pConfig;
	Fts5Sorter *pSorter;
	int nPhrase;
	int nByte;
	int rc;
	const char *zRank = pCsr->zRank;
	const char *zRankArgs = pCsr->zRankArgs;

	nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
	nByte = sizeof(Fts5Sorter) + sizeof(int) * (nPhrase - 1);
	pSorter = (Fts5Sorter*)sqlite3_malloc(nByte);
	if (pSorter == 0) return SQLITE_NOMEM;
	memset(pSorter, 0, nByte);
	pSorter->nIdx = nPhrase;

	
	rc = fts5PrepareStatement(&pSorter->pStmt, pConfig,
		"SELECT rowid, rank FROM %Q.%Q ORDER BY %s(%s%s%s) %s",
		pConfig->zDb, pConfig->zName, zRank, pConfig->zName,
		(zRankArgs ? ", " : ""),
		(zRankArgs ? zRankArgs : ""),
		bDesc ? "DESC" : "ASC"
	);

	pCsr->pSorter = pSorter;
	if (rc == SQLITE_OK) {
		assert(pTab->pSortCsr == 0);
		pTab->pSortCsr = pCsr;
		rc = fts5SorterNext(pCsr);
		pTab->pSortCsr = 0;
	}

	if (rc != SQLITE_OK) {
		sqlite3_finalize(pSorter->pStmt);
		sqlite3_free(pSorter);
		pCsr->pSorter = 0;
	}

	return rc;
}

static int fts5CursorFirst(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc) {
	int rc;
	Fts5Expr *pExpr = pCsr->pExpr;
	rc = sqlite3Fts5ExprFirst(pExpr, pTab->pIndex, pCsr->iFirstRowid, bDesc);
	if (sqlite3Fts5ExprEof(pExpr)) {
		CsrFlagSet(pCsr, FTS5CSR_EOF);
	}
	fts5CsrNewrow(pCsr);
	return rc;
}


static int fts5SpecialMatch(
	Fts5Table *pTab,
	Fts5Cursor *pCsr,
	const char *zQuery
) {
	int rc = SQLITE_OK;             
	const char *z = zQuery;         
	int n;                          

	while (z[0] == ' ') z++;
	for (n = 0; z[n] && z[n] != ' '; n++);

	assert(pTab->base.zErrMsg == 0);
	pCsr->ePlan = FTS5_PLAN_SPECIAL;

	if (0 == sqlite3_strnicmp("reads", z, n)) {
		pCsr->iSpecial = sqlite3Fts5IndexReads(pTab->pIndex);
	}
	else if (0 == sqlite3_strnicmp("id", z, n)) {
		pCsr->iSpecial = pCsr->iCsrId;
	}
	else {
		
		pTab->base.zErrMsg = sqlite3_mprintf("unknown special query: %.*s", n, z);
		rc = SQLITE_ERROR;
	}

	return rc;
}


static Fts5Auxiliary *fts5FindAuxiliary(Fts5Table *pTab, const char *zName) {
	Fts5Auxiliary *pAux;

	for (pAux = pTab->pGlobal->pAux; pAux; pAux = pAux->pNext) {
		if (sqlite3_stricmp(zName, pAux->zFunc) == 0) return pAux;
	}

	
	return 0;
}


static int fts5FindRankFunction(Fts5Cursor *pCsr) {
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	Fts5Config *pConfig = pTab->pConfig;
	int rc = SQLITE_OK;
	Fts5Auxiliary *pAux = 0;
	const char *zRank = pCsr->zRank;
	const char *zRankArgs = pCsr->zRankArgs;

	if (zRankArgs) {
		char *zSql = sqlite3Fts5Mprintf(&rc, "SELECT %s", zRankArgs);
		if (zSql) {
			sqlite3_stmt *pStmt = 0;
			rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pStmt, 0);
			sqlite3_free(zSql);
			assert(rc == SQLITE_OK || pCsr->pRankArgStmt == 0);
			if (rc == SQLITE_OK) {
				if (SQLITE_ROW == sqlite3_step(pStmt)) {
					int nByte;
					pCsr->nRankArg = sqlite3_column_count(pStmt);
					nByte = sizeof(sqlite3_value*)*pCsr->nRankArg;
					pCsr->apRankArg = (sqlite3_value**)sqlite3Fts5MallocZero(&rc, nByte);
					if (rc == SQLITE_OK) {
						int i;
						for (i = 0; i<pCsr->nRankArg; i++) {
							pCsr->apRankArg[i] = sqlite3_column_value(pStmt, i);
						}
					}
					pCsr->pRankArgStmt = pStmt;
				}
				else {
					rc = sqlite3_finalize(pStmt);
					assert(rc != SQLITE_OK);
				}
			}
		}
	}

	if (rc == SQLITE_OK) {
		pAux = fts5FindAuxiliary(pTab, zRank);
		if (pAux == 0) {
			assert(pTab->base.zErrMsg == 0);
			pTab->base.zErrMsg = sqlite3_mprintf("no such function: %s", zRank);
			rc = SQLITE_ERROR;
		}
	}

	pCsr->pRank = pAux;
	return rc;
}


static int fts5CursorParseRank(
	Fts5Config *pConfig,
	Fts5Cursor *pCsr,
	sqlite3_value *pRank
) {
	int rc = SQLITE_OK;
	if (pRank) {
		const char *z = (const char*)sqlite3_value_text(pRank);
		char *zRank = 0;
		char *zRankArgs = 0;

		if (z == 0) {
			if (sqlite3_value_type(pRank) == SQLITE_NULL) rc = SQLITE_ERROR;
		}
		else {
			rc = sqlite3Fts5ConfigParseRank(z, &zRank, &zRankArgs);
		}
		if (rc == SQLITE_OK) {
			pCsr->zRank = zRank;
			pCsr->zRankArgs = zRankArgs;
			CsrFlagSet(pCsr, FTS5CSR_FREE_ZRANK);
		}
		else if (rc == SQLITE_ERROR) {
			pCsr->base.pVtab->zErrMsg = sqlite3_mprintf(
				"parse error in rank function: %s", z
			);
		}
	}
	else {
		if (pConfig->zRank) {
			pCsr->zRank = (char*)pConfig->zRank;
			pCsr->zRankArgs = (char*)pConfig->zRankArgs;
		}
		else {
			pCsr->zRank = (char*)FTS5_DEFAULT_RANK;
			pCsr->zRankArgs = 0;
		}
	}
	return rc;
}

static i64 fts5GetRowidLimit(sqlite3_value *pVal, i64 iDefault) {
	if (pVal) {
		int eType = sqlite3_value_numeric_type(pVal);
		if (eType == SQLITE_INTEGER) {
			return sqlite3_value_int64(pVal);
		}
	}
	return iDefault;
}


static int fts5FilterMethod(
	sqlite3_vtab_cursor *pCursor,   
	int idxNum,                     
	const char *zUnused,            
	int nVal,                       
	sqlite3_value **apVal           
) {
	Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
	Fts5Config *pConfig = pTab->pConfig;
	Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
	int rc = SQLITE_OK;             
	int iVal = 0;                   
	int bDesc;                      
	int bOrderByRank;               
	sqlite3_value *pMatch = 0;      
	sqlite3_value *pRank = 0;       
	sqlite3_value *pRowidEq = 0;    
	sqlite3_value *pRowidLe = 0;    
	sqlite3_value *pRowidGe = 0;    
	char **pzErrmsg = pConfig->pzErrmsg;

	UNUSED_PARAM(zUnused);
	UNUSED_PARAM(nVal);

	if (pCsr->ePlan) {
		fts5FreeCursorComponents(pCsr);
		memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));
	}

	assert(pCsr->pStmt == 0);
	assert(pCsr->pExpr == 0);
	assert(pCsr->csrflags == 0);
	assert(pCsr->pRank == 0);
	assert(pCsr->zRank == 0);
	assert(pCsr->zRankArgs == 0);

	assert(pzErrmsg == 0 || pzErrmsg == &pTab->base.zErrMsg);
	pConfig->pzErrmsg = &pTab->base.zErrMsg;

	
	if (BitFlagTest(idxNum, FTS5_BI_MATCH)) pMatch = apVal[iVal++];
	if (BitFlagTest(idxNum, FTS5_BI_RANK)) pRank = apVal[iVal++];
	if (BitFlagTest(idxNum, FTS5_BI_ROWID_EQ)) pRowidEq = apVal[iVal++];
	if (BitFlagTest(idxNum, FTS5_BI_ROWID_LE)) pRowidLe = apVal[iVal++];
	if (BitFlagTest(idxNum, FTS5_BI_ROWID_GE)) pRowidGe = apVal[iVal++];
	assert(iVal == nVal);
	bOrderByRank = ((idxNum & FTS5_BI_ORDER_RANK) ? 1 : 0);
	pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);

	
	if (pRowidEq) {
		pRowidLe = pRowidGe = pRowidEq;
	}
	if (bDesc) {
		pCsr->iFirstRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
		pCsr->iLastRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
	}
	else {
		pCsr->iLastRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
		pCsr->iFirstRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
	}

	if (pTab->pSortCsr) {
		
		assert(pRowidEq == 0 && pRowidLe == 0 && pRowidGe == 0 && pRank == 0);
		assert(nVal == 0 && pMatch == 0 && bOrderByRank == 0 && bDesc == 0);
		assert(pCsr->iLastRowid == LARGEST_INT64);
		assert(pCsr->iFirstRowid == SMALLEST_INT64);
		pCsr->ePlan = FTS5_PLAN_SOURCE;
		pCsr->pExpr = pTab->pSortCsr->pExpr;
		rc = fts5CursorFirst(pTab, pCsr, bDesc);
	}
	else if (pMatch) {
		const char *zExpr = (const char*)sqlite3_value_text(apVal[0]);
		if (zExpr == 0) zExpr = "";

		rc = fts5CursorParseRank(pConfig, pCsr, pRank);
		if (rc == SQLITE_OK) {
			if (zExpr[0] == '*') {
				
				rc = fts5SpecialMatch(pTab, pCsr, &zExpr[1]);
			}
			else {
				char **pzErr = &pTab->base.zErrMsg;
				rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pCsr->pExpr, pzErr);
				if (rc == SQLITE_OK) {
					if (bOrderByRank) {
						pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
						rc = fts5CursorFirstSorted(pTab, pCsr, bDesc);
					}
					else {
						pCsr->ePlan = FTS5_PLAN_MATCH;
						rc = fts5CursorFirst(pTab, pCsr, bDesc);
					}
				}
			}
		}
	}
	else if (pConfig->zContent == 0) {
		*pConfig->pzErrmsg = sqlite3_mprintf(
			"%s: table does not support scanning", pConfig->zName
		);
		rc = SQLITE_ERROR;
	}
	else {
		
		pCsr->ePlan = (pRowidEq ? FTS5_PLAN_ROWID : FTS5_PLAN_SCAN);
		rc = sqlite3Fts5StorageStmt(
			pTab->pStorage, fts5StmtType(pCsr), &pCsr->pStmt, &pTab->base.zErrMsg
		);
		if (rc == SQLITE_OK) {
			if (pCsr->ePlan == FTS5_PLAN_ROWID) {
				sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);
			}
			else {
				sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iFirstRowid);
				sqlite3_bind_int64(pCsr->pStmt, 2, pCsr->iLastRowid);
			}
			rc = fts5NextMethod(pCursor);
		}
	}

	pConfig->pzErrmsg = pzErrmsg;
	return rc;
}


static int fts5EofMethod(sqlite3_vtab_cursor *pCursor) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
	return (CsrFlagTest(pCsr, FTS5CSR_EOF) ? 1 : 0);
}


static i64 fts5CursorRowid(Fts5Cursor *pCsr) {
	assert(pCsr->ePlan == FTS5_PLAN_MATCH
		|| pCsr->ePlan == FTS5_PLAN_SORTED_MATCH
		|| pCsr->ePlan == FTS5_PLAN_SOURCE
	);
	if (pCsr->pSorter) {
		return pCsr->pSorter->iRowid;
	}
	else {
		return sqlite3Fts5ExprRowid(pCsr->pExpr);
	}
}


static int fts5RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
	int ePlan = pCsr->ePlan;

	assert(CsrFlagTest(pCsr, FTS5CSR_EOF) == 0);
	switch (ePlan) {
	case FTS5_PLAN_SPECIAL:
		*pRowid = 0;
		break;

	case FTS5_PLAN_SOURCE:
	case FTS5_PLAN_MATCH:
	case FTS5_PLAN_SORTED_MATCH:
		*pRowid = fts5CursorRowid(pCsr);
		break;

	default:
		*pRowid = sqlite3_column_int64(pCsr->pStmt, 0);
		break;
	}

	return SQLITE_OK;
}


static int fts5SeekCursor(Fts5Cursor *pCsr, int bErrormsg) {
	int rc = SQLITE_OK;

	
	if (pCsr->pStmt == 0) {
		Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
		int eStmt = fts5StmtType(pCsr);
		rc = sqlite3Fts5StorageStmt(
			pTab->pStorage, eStmt, &pCsr->pStmt, (bErrormsg ? &pTab->base.zErrMsg : 0)
		);
		assert(rc != SQLITE_OK || pTab->base.zErrMsg == 0);
		assert(CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT));
	}

	if (rc == SQLITE_OK && CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT)) {
		assert(pCsr->pExpr);
		sqlite3_reset(pCsr->pStmt);
		sqlite3_bind_int64(pCsr->pStmt, 1, fts5CursorRowid(pCsr));
		rc = sqlite3_step(pCsr->pStmt);
		if (rc == SQLITE_ROW) {
			rc = SQLITE_OK;
			CsrFlagClear(pCsr, FTS5CSR_REQUIRE_CONTENT);
		}
		else {
			rc = sqlite3_reset(pCsr->pStmt);
			if (rc == SQLITE_OK) {
				rc = FTS5_CORRUPT;
			}
		}
	}
	return rc;
}

static void fts5SetVtabError(Fts5Table *p, const char *zFormat, ...) {
	va_list ap;                     
	va_start(ap, zFormat);
	assert(p->base.zErrMsg == 0);
	p->base.zErrMsg = sqlite3_vmprintf(zFormat, ap);
	va_end(ap);
}


static int fts5SpecialInsert(
	Fts5Table *pTab,                
	const char *zCmd,               
	sqlite3_value *pVal             
) {
	Fts5Config *pConfig = pTab->pConfig;
	int rc = SQLITE_OK;
	int bError = 0;

	if (0 == sqlite3_stricmp("delete-all", zCmd)) {
		if (pConfig->eContent == FTS5_CONTENT_NORMAL) {
			fts5SetVtabError(pTab,
				"'delete-all' may only be used with a "
				"contentless or external content fts5 table"
			);
			rc = SQLITE_ERROR;
		}
		else {
			rc = sqlite3Fts5StorageDeleteAll(pTab->pStorage);
		}
	}
	else if (0 == sqlite3_stricmp("rebuild", zCmd)) {
		if (pConfig->eContent == FTS5_CONTENT_NONE) {
			fts5SetVtabError(pTab,
				"'rebuild' may not be used with a contentless fts5 table"
			);
			rc = SQLITE_ERROR;
		}
		else {
			rc = sqlite3Fts5StorageRebuild(pTab->pStorage);
		}
	}
	else if (0 == sqlite3_stricmp("optimize", zCmd)) {
		rc = sqlite3Fts5StorageOptimize(pTab->pStorage);
	}
	else if (0 == sqlite3_stricmp("merge", zCmd)) {
		int nMerge = sqlite3_value_int(pVal);
		rc = sqlite3Fts5StorageMerge(pTab->pStorage, nMerge);
	}
	else if (0 == sqlite3_stricmp("integrity-check", zCmd)) {
		rc = sqlite3Fts5StorageIntegrity(pTab->pStorage);
#ifdef SQLITE_DEBUG
	}
	else if (0 == sqlite3_stricmp("prefix-index", zCmd)) {
		pConfig->bPrefixIndex = sqlite3_value_int(pVal);
#endif
	}
	else {
		rc = sqlite3Fts5IndexLoadConfig(pTab->pIndex);
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts5ConfigSetValue(pTab->pConfig, zCmd, pVal, &bError);
		}
		if (rc == SQLITE_OK) {
			if (bError) {
				rc = SQLITE_ERROR;
			}
			else {
				rc = sqlite3Fts5StorageConfigValue(pTab->pStorage, zCmd, pVal, 0);
			}
		}
	}
	return rc;
}

static int fts5SpecialDelete(
	Fts5Table *pTab,
	sqlite3_value **apVal
) {
	int rc = SQLITE_OK;
	int eType1 = sqlite3_value_type(apVal[1]);
	if (eType1 == SQLITE_INTEGER) {
		sqlite3_int64 iDel = sqlite3_value_int64(apVal[1]);
		rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, &apVal[2]);
	}
	return rc;
}

static void fts5StorageInsert(
	int *pRc,
	Fts5Table *pTab,
	sqlite3_value **apVal,
	i64 *piRowid
) {
	int rc = *pRc;
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, piRowid);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal, *piRowid);
	}
	*pRc = rc;
}


static int fts5UpdateMethod(
	sqlite3_vtab *pVtab,            
	int nArg,                       
	sqlite3_value **apVal,          
	sqlite_int64 *pRowid            
) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	Fts5Config *pConfig = pTab->pConfig;
	int eType0;                     
	int rc = SQLITE_OK;             

									
	assert(pTab->ts.eState == 1);

	assert(pVtab->zErrMsg == 0);
	assert(nArg == 1 || nArg == (2 + pConfig->nCol + 2));
	assert(nArg == 1
		|| sqlite3_value_type(apVal[1]) == SQLITE_INTEGER
		|| sqlite3_value_type(apVal[1]) == SQLITE_NULL
	);
	assert(pTab->pConfig->pzErrmsg == 0);
	pTab->pConfig->pzErrmsg = &pTab->base.zErrMsg;

	
	fts5TripCursors(pTab);

	eType0 = sqlite3_value_type(apVal[0]);
	if (eType0 == SQLITE_NULL
		&& sqlite3_value_type(apVal[2 + pConfig->nCol]) != SQLITE_NULL
		) {
		
		const char *z = (const char*)sqlite3_value_text(apVal[2 + pConfig->nCol]);
		if (pConfig->eContent != FTS5_CONTENT_NORMAL
			&& 0 == sqlite3_stricmp("delete", z)
			) {
			rc = fts5SpecialDelete(pTab, apVal);
		}
		else {
			rc = fts5SpecialInsert(pTab, z, apVal[2 + pConfig->nCol + 1]);
		}
	}
	else {
		
		int eConflict = SQLITE_ABORT;
		if (pConfig->eContent == FTS5_CONTENT_NORMAL) {
			eConflict = sqlite3_vtab_on_conflict(pConfig->db);
		}

		assert(eType0 == SQLITE_INTEGER || eType0 == SQLITE_NULL);
		assert(nArg != 1 || eType0 == SQLITE_INTEGER);

		
		if (eType0 == SQLITE_INTEGER && fts5IsContentless(pTab)) {
			pTab->base.zErrMsg = sqlite3_mprintf(
				"cannot %s contentless fts5 table: %s",
				(nArg>1 ? "UPDATE" : "DELETE from"), pConfig->zName
			);
			rc = SQLITE_ERROR;
		}

		
		else if (nArg == 1) {
			i64 iDel = sqlite3_value_int64(apVal[0]);  
			rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, 0);
		}

		
		else if (eType0 != SQLITE_INTEGER) {
			
			if (eConflict == SQLITE_REPLACE
				&& sqlite3_value_type(apVal[1]) == SQLITE_INTEGER
				) {
				i64 iNew = sqlite3_value_int64(apVal[1]);  
				rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);
			}
			fts5StorageInsert(&rc, pTab, apVal, pRowid);
		}

		
		else {
			i64 iOld = sqlite3_value_int64(apVal[0]);  
			i64 iNew = sqlite3_value_int64(apVal[1]);  
			if (iOld != iNew) {
				if (eConflict == SQLITE_REPLACE) {
					rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);
					if (rc == SQLITE_OK) {
						rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);
					}
					fts5StorageInsert(&rc, pTab, apVal, pRowid);
				}
				else {
					rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, pRowid);
					if (rc == SQLITE_OK) {
						rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);
					}
					if (rc == SQLITE_OK) {
						rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal, *pRowid);
					}
				}
			}
			else {
				rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);
				fts5StorageInsert(&rc, pTab, apVal, pRowid);
			}
		}
	}

	pTab->pConfig->pzErrmsg = 0;
	return rc;
}


static int fts5SyncMethod(sqlite3_vtab *pVtab) {
	int rc;
	Fts5Table *pTab = (Fts5Table*)pVtab;
	fts5CheckTransactionState(pTab, FTS5_SYNC, 0);
	pTab->pConfig->pzErrmsg = &pTab->base.zErrMsg;
	fts5TripCursors(pTab);
	rc = sqlite3Fts5StorageSync(pTab->pStorage, 1);
	pTab->pConfig->pzErrmsg = 0;
	return rc;
}


static int fts5BeginMethod(sqlite3_vtab *pVtab) {
	fts5CheckTransactionState((Fts5Table*)pVtab, FTS5_BEGIN, 0);
	fts5NewTransaction((Fts5Table*)pVtab);
	return SQLITE_OK;
}


static int fts5CommitMethod(sqlite3_vtab *pVtab) {
	UNUSED_PARAM(pVtab);  
	fts5CheckTransactionState((Fts5Table*)pVtab, FTS5_COMMIT, 0);
	return SQLITE_OK;
}


static int fts5RollbackMethod(sqlite3_vtab *pVtab) {
	int rc;
	Fts5Table *pTab = (Fts5Table*)pVtab;
	fts5CheckTransactionState(pTab, FTS5_ROLLBACK, 0);
	rc = sqlite3Fts5StorageRollback(pTab->pStorage);
	return rc;
}

static int fts5CsrPoslist(Fts5Cursor*, int, const u8**, int*);

static void *fts5ApiUserData(Fts5Context *pCtx) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	return pCsr->pAux->pUserData;
}

static int fts5ApiColumnCount(Fts5Context *pCtx) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	return ((Fts5Table*)(pCsr->base.pVtab))->pConfig->nCol;
}

static int fts5ApiColumnTotalSize(
	Fts5Context *pCtx,
	int iCol,
	sqlite3_int64 *pnToken
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	return sqlite3Fts5StorageSize(pTab->pStorage, iCol, pnToken);
}

static int fts5ApiRowCount(Fts5Context *pCtx, i64 *pnRow) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	return sqlite3Fts5StorageRowCount(pTab->pStorage, pnRow);
}

static int fts5ApiTokenize(
	Fts5Context *pCtx,
	const char *pText, int nText,
	void *pUserData,
	int(*xToken)(void*, int, const char*, int, int, int)
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	return sqlite3Fts5Tokenize(
		pTab->pConfig, FTS5_TOKENIZE_AUX, pText, nText, pUserData, xToken
	);
}

static int fts5ApiPhraseCount(Fts5Context *pCtx) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	return sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
}

static int fts5ApiPhraseSize(Fts5Context *pCtx, int iPhrase) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	return sqlite3Fts5ExprPhraseSize(pCsr->pExpr, iPhrase);
}

static int fts5ApiColumnText(
	Fts5Context *pCtx,
	int iCol,
	const char **pz,
	int *pn
) {
	int rc = SQLITE_OK;
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	if (fts5IsContentless((Fts5Table*)(pCsr->base.pVtab))) {
		*pz = 0;
		*pn = 0;
	}
	else {
		rc = fts5SeekCursor(pCsr, 0);
		if (rc == SQLITE_OK) {
			*pz = (const char*)sqlite3_column_text(pCsr->pStmt, iCol + 1);
			*pn = sqlite3_column_bytes(pCsr->pStmt, iCol + 1);
		}
	}
	return rc;
}

static int fts5CsrPoslist(
	Fts5Cursor *pCsr,
	int iPhrase,
	const u8 **pa,
	int *pn
) {
	Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;
	int rc = SQLITE_OK;
	int bLive = (pCsr->pSorter == 0);

	if (CsrFlagTest(pCsr, FTS5CSR_REQUIRE_POSLIST)) {

		if (pConfig->eDetail != FTS5_DETAIL_FULL) {
			Fts5PoslistPopulator *aPopulator;
			int i;
			aPopulator = sqlite3Fts5ExprClearPoslists(pCsr->pExpr, bLive);
			if (aPopulator == 0) rc = SQLITE_NOMEM;
			for (i = 0; i<pConfig->nCol && rc == SQLITE_OK; i++) {
				int n; const char *z;
				rc = fts5ApiColumnText((Fts5Context*)pCsr, i, &z, &n);
				if (rc == SQLITE_OK) {
					rc = sqlite3Fts5ExprPopulatePoslists(
						pConfig, pCsr->pExpr, aPopulator, i, z, n
					);
				}
			}
			sqlite3_free(aPopulator);

			if (pCsr->pSorter) {
				sqlite3Fts5ExprCheckPoslists(pCsr->pExpr, pCsr->pSorter->iRowid);
			}
		}
		CsrFlagClear(pCsr, FTS5CSR_REQUIRE_POSLIST);
	}

	if (pCsr->pSorter && pConfig->eDetail == FTS5_DETAIL_FULL) {
		Fts5Sorter *pSorter = pCsr->pSorter;
		int i1 = (iPhrase == 0 ? 0 : pSorter->aIdx[iPhrase - 1]);
		*pn = pSorter->aIdx[iPhrase] - i1;
		*pa = &pSorter->aPoslist[i1];
	}
	else {
		*pn = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);
	}

	return rc;
}


static int fts5CacheInstArray(Fts5Cursor *pCsr) {
	int rc = SQLITE_OK;
	Fts5PoslistReader *aIter;       
	int nIter;                      

	nIter = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
	if (pCsr->aInstIter == 0) {
		int nByte = sizeof(Fts5PoslistReader) * nIter;
		pCsr->aInstIter = (Fts5PoslistReader*)sqlite3Fts5MallocZero(&rc, nByte);
	}
	aIter = pCsr->aInstIter;

	if (aIter) {
		int nInst = 0;                
		int i;

		
		for (i = 0; i<nIter && rc == SQLITE_OK; i++) {
			const u8 *a;
			int n;
			rc = fts5CsrPoslist(pCsr, i, &a, &n);
			if (rc == SQLITE_OK) {
				sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);
			}
		}

		if (rc == SQLITE_OK) {
			while (1) {
				int *aInst;
				int iBest = -1;
				for (i = 0; i<nIter; i++) {
					if ((aIter[i].bEof == 0)
						&& (iBest<0 || aIter[i].iPos<aIter[iBest].iPos)
						) {
						iBest = i;
					}
				}
				if (iBest<0) break;

				nInst++;
				if (nInst >= pCsr->nInstAlloc) {
					pCsr->nInstAlloc = pCsr->nInstAlloc ? pCsr->nInstAlloc * 2 : 32;
					aInst = (int*)sqlite3_realloc(
						pCsr->aInst, pCsr->nInstAlloc * sizeof(int) * 3
					);
					if (aInst) {
						pCsr->aInst = aInst;
					}
					else {
						rc = SQLITE_NOMEM;
						break;
					}
				}

				aInst = &pCsr->aInst[3 * (nInst - 1)];
				aInst[0] = iBest;
				aInst[1] = FTS5_POS2COLUMN(aIter[iBest].iPos);
				aInst[2] = FTS5_POS2OFFSET(aIter[iBest].iPos);
				sqlite3Fts5PoslistReaderNext(&aIter[iBest]);
			}
		}

		pCsr->nInstCount = nInst;
		CsrFlagClear(pCsr, FTS5CSR_REQUIRE_INST);
	}
	return rc;
}

static int fts5ApiInstCount(Fts5Context *pCtx, int *pnInst) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	int rc = SQLITE_OK;
	if (CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST) == 0
		|| SQLITE_OK == (rc = fts5CacheInstArray(pCsr))) {
		*pnInst = pCsr->nInstCount;
	}
	return rc;
}

static int fts5ApiInst(
	Fts5Context *pCtx,
	int iIdx,
	int *piPhrase,
	int *piCol,
	int *piOff
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	int rc = SQLITE_OK;
	if (CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST) == 0
		|| SQLITE_OK == (rc = fts5CacheInstArray(pCsr))
		) {
		if (iIdx<0 || iIdx >= pCsr->nInstCount) {
			rc = SQLITE_RANGE;
#if 0
		}
		else if (fts5IsOffsetless((Fts5Table*)pCsr->base.pVtab)) {
			*piPhrase = pCsr->aInst[iIdx * 3];
			*piCol = pCsr->aInst[iIdx * 3 + 2];
			*piOff = -1;
#endif
		}
		else {
			*piPhrase = pCsr->aInst[iIdx * 3];
			*piCol = pCsr->aInst[iIdx * 3 + 1];
			*piOff = pCsr->aInst[iIdx * 3 + 2];
		}
	}
	return rc;
}

static sqlite3_int64 fts5ApiRowid(Fts5Context *pCtx) {
	return fts5CursorRowid((Fts5Cursor*)pCtx);
}

static int fts5ColumnSizeCb(
	void *pContext,                 
	int tflags,
	const char *pUnused,            
	int nUnused,                    
	int iUnused1,                   
	int iUnused2                    
) {
	int *pCnt = (int*)pContext;
	UNUSED_PARAM2(pUnused, nUnused);
	UNUSED_PARAM2(iUnused1, iUnused2);
	if ((tflags & FTS5_TOKEN_COLOCATED) == 0) {
		(*pCnt)++;
	}
	return SQLITE_OK;
}

static int fts5ApiColumnSize(Fts5Context *pCtx, int iCol, int *pnToken) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	Fts5Config *pConfig = pTab->pConfig;
	int rc = SQLITE_OK;

	if (CsrFlagTest(pCsr, FTS5CSR_REQUIRE_DOCSIZE)) {
		if (pConfig->bColumnsize) {
			i64 iRowid = fts5CursorRowid(pCsr);
			rc = sqlite3Fts5StorageDocsize(pTab->pStorage, iRowid, pCsr->aColumnSize);
		}
		else if (pConfig->zContent == 0) {
			int i;
			for (i = 0; i<pConfig->nCol; i++) {
				if (pConfig->abUnindexed[i] == 0) {
					pCsr->aColumnSize[i] = -1;
				}
			}
		}
		else {
			int i;
			for (i = 0; rc == SQLITE_OK && i<pConfig->nCol; i++) {
				if (pConfig->abUnindexed[i] == 0) {
					const char *z; int n;
					void *p = (void*)(&pCsr->aColumnSize[i]);
					pCsr->aColumnSize[i] = 0;
					rc = fts5ApiColumnText(pCtx, i, &z, &n);
					if (rc == SQLITE_OK) {
						rc = sqlite3Fts5Tokenize(
							pConfig, FTS5_TOKENIZE_AUX, z, n, p, fts5ColumnSizeCb
						);
					}
				}
			}
		}
		CsrFlagClear(pCsr, FTS5CSR_REQUIRE_DOCSIZE);
	}
	if (iCol<0) {
		int i;
		*pnToken = 0;
		for (i = 0; i<pConfig->nCol; i++) {
			*pnToken += pCsr->aColumnSize[i];
		}
	}
	else if (iCol<pConfig->nCol) {
		*pnToken = pCsr->aColumnSize[iCol];
	}
	else {
		*pnToken = 0;
		rc = SQLITE_RANGE;
	}
	return rc;
}


static int fts5ApiSetAuxdata(
	Fts5Context *pCtx,              
	void *pPtr,                     
	void(*xDelete)(void*)           
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Auxdata *pData;

	
	for (pData = pCsr->pAuxdata; pData; pData = pData->pNext) {
		if (pData->pAux == pCsr->pAux) break;
	}

	if (pData) {
		if (pData->xDelete) {
			pData->xDelete(pData->pPtr);
		}
	}
	else {
		int rc = SQLITE_OK;
		pData = (Fts5Auxdata*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Auxdata));
		if (pData == 0) {
			if (xDelete) xDelete(pPtr);
			return rc;
		}
		pData->pAux = pCsr->pAux;
		pData->pNext = pCsr->pAuxdata;
		pCsr->pAuxdata = pData;
	}

	pData->xDelete = xDelete;
	pData->pPtr = pPtr;
	return SQLITE_OK;
}

static void *fts5ApiGetAuxdata(Fts5Context *pCtx, int bClear) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Auxdata *pData;
	void *pRet = 0;

	for (pData = pCsr->pAuxdata; pData; pData = pData->pNext) {
		if (pData->pAux == pCsr->pAux) break;
	}

	if (pData) {
		pRet = pData->pPtr;
		if (bClear) {
			pData->pPtr = 0;
			pData->xDelete = 0;
		}
	}

	return pRet;
}

static void fts5ApiPhraseNext(
	Fts5Context *pUnused,
	Fts5PhraseIter *pIter,
	int *piCol, int *piOff
) {
	UNUSED_PARAM(pUnused);
	if (pIter->a >= pIter->b) {
		*piCol = -1;
		*piOff = -1;
	}
	else {
		int iVal;
		pIter->a += fts5GetVarint32(pIter->a, iVal);
		if (iVal == 1) {
			pIter->a += fts5GetVarint32(pIter->a, iVal);
			*piCol = iVal;
			*piOff = 0;
			pIter->a += fts5GetVarint32(pIter->a, iVal);
		}
		*piOff += (iVal - 2);
	}
}

static int fts5ApiPhraseFirst(
	Fts5Context *pCtx,
	int iPhrase,
	Fts5PhraseIter *pIter,
	int *piCol, int *piOff
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	int n;
	int rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);
	if (rc == SQLITE_OK) {
		pIter->b = &pIter->a[n];
		*piCol = 0;
		*piOff = 0;
		fts5ApiPhraseNext(pCtx, pIter, piCol, piOff);
	}
	return rc;
}

static void fts5ApiPhraseNextColumn(
	Fts5Context *pCtx,
	Fts5PhraseIter *pIter,
	int *piCol
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;

	if (pConfig->eDetail == FTS5_DETAIL_COLUMNS) {
		if (pIter->a >= pIter->b) {
			*piCol = -1;
		}
		else {
			int iIncr;
			pIter->a += fts5GetVarint32(&pIter->a[0], iIncr);
			*piCol += (iIncr - 2);
		}
	}
	else {
		while (1) {
			int dummy;
			if (pIter->a >= pIter->b) {
				*piCol = -1;
				return;
			}
			if (pIter->a[0] == 0x01) break;
			pIter->a += fts5GetVarint32(pIter->a, dummy);
		}
		pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);
	}
}

static int fts5ApiPhraseFirstColumn(
	Fts5Context *pCtx,
	int iPhrase,
	Fts5PhraseIter *pIter,
	int *piCol
) {
	int rc = SQLITE_OK;
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;

	if (pConfig->eDetail == FTS5_DETAIL_COLUMNS) {
		Fts5Sorter *pSorter = pCsr->pSorter;
		int n;
		if (pSorter) {
			int i1 = (iPhrase == 0 ? 0 : pSorter->aIdx[iPhrase - 1]);
			n = pSorter->aIdx[iPhrase] - i1;
			pIter->a = &pSorter->aPoslist[i1];
		}
		else {
			rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, iPhrase, &pIter->a, &n);
		}
		if (rc == SQLITE_OK) {
			pIter->b = &pIter->a[n];
			*piCol = 0;
			fts5ApiPhraseNextColumn(pCtx, pIter, piCol);
		}
	}
	else {
		int n;
		rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);
		if (rc == SQLITE_OK) {
			pIter->b = &pIter->a[n];
			if (n <= 0) {
				*piCol = -1;
			}
			else if (pIter->a[0] == 0x01) {
				pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);
			}
			else {
				*piCol = 0;
			}
		}
	}

	return rc;
}


static int fts5ApiQueryPhrase(Fts5Context*, int, void*,
	int(*)(const Fts5ExtensionApi*, Fts5Context*, void*)
);

static const Fts5ExtensionApi sFts5Api = {
	2,                            
	fts5ApiUserData,
	fts5ApiColumnCount,
	fts5ApiRowCount,
	fts5ApiColumnTotalSize,
	fts5ApiTokenize,
	fts5ApiPhraseCount,
	fts5ApiPhraseSize,
	fts5ApiInstCount,
	fts5ApiInst,
	fts5ApiRowid,
	fts5ApiColumnText,
	fts5ApiColumnSize,
	fts5ApiQueryPhrase,
	fts5ApiSetAuxdata,
	fts5ApiGetAuxdata,
	fts5ApiPhraseFirst,
	fts5ApiPhraseNext,
	fts5ApiPhraseFirstColumn,
	fts5ApiPhraseNextColumn,
};


static int fts5ApiQueryPhrase(
	Fts5Context *pCtx,
	int iPhrase,
	void *pUserData,
	int(*xCallback)(const Fts5ExtensionApi*, Fts5Context*, void*)
) {
	Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
	Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
	int rc;
	Fts5Cursor *pNew = 0;

	rc = fts5OpenMethod(pCsr->base.pVtab, (sqlite3_vtab_cursor**)&pNew);
	if (rc == SQLITE_OK) {
		pNew->ePlan = FTS5_PLAN_MATCH;
		pNew->iFirstRowid = SMALLEST_INT64;
		pNew->iLastRowid = LARGEST_INT64;
		pNew->base.pVtab = (sqlite3_vtab*)pTab;
		rc = sqlite3Fts5ExprClonePhrase(pCsr->pExpr, iPhrase, &pNew->pExpr);
	}

	if (rc == SQLITE_OK) {
		for (rc = fts5CursorFirst(pTab, pNew, 0);
			rc == SQLITE_OK && CsrFlagTest(pNew, FTS5CSR_EOF) == 0;
			rc = fts5NextMethod((sqlite3_vtab_cursor*)pNew)
			) {
			rc = xCallback(&sFts5Api, (Fts5Context*)pNew, pUserData);
			if (rc != SQLITE_OK) {
				if (rc == SQLITE_DONE) rc = SQLITE_OK;
				break;
			}
		}
	}

	fts5CloseMethod((sqlite3_vtab_cursor*)pNew);
	return rc;
}

static void fts5ApiInvoke(
	Fts5Auxiliary *pAux,
	Fts5Cursor *pCsr,
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {
	assert(pCsr->pAux == 0);
	pCsr->pAux = pAux;
	pAux->xFunc(&sFts5Api, (Fts5Context*)pCsr, context, argc, argv);
	pCsr->pAux = 0;
}

static Fts5Cursor *fts5CursorFromCsrid(Fts5Global *pGlobal, i64 iCsrId) {
	Fts5Cursor *pCsr;
	for (pCsr = pGlobal->pCsr; pCsr; pCsr = pCsr->pNext) {
		if (pCsr->iCsrId == iCsrId) break;
	}
	return pCsr;
}

static void fts5ApiCallback(
	sqlite3_context *context,
	int argc,
	sqlite3_value **argv
) {

	Fts5Auxiliary *pAux;
	Fts5Cursor *pCsr;
	i64 iCsrId;

	assert(argc >= 1);
	pAux = (Fts5Auxiliary*)sqlite3_user_data(context);
	iCsrId = sqlite3_value_int64(argv[0]);

	pCsr = fts5CursorFromCsrid(pAux->pGlobal, iCsrId);
	if (pCsr == 0) {
		char *zErr = sqlite3_mprintf("no such cursor: %lld", iCsrId);
		sqlite3_result_error(context, zErr, -1);
		sqlite3_free(zErr);
	}
	else {
		fts5ApiInvoke(pAux, pCsr, context, argc - 1, &argv[1]);
	}
}



static Fts5Index *sqlite3Fts5IndexFromCsrid(
	Fts5Global *pGlobal,            
	i64 iCsrId,                     
	Fts5Config **ppConfig           
) {
	Fts5Cursor *pCsr;
	Fts5Table *pTab;

	pCsr = fts5CursorFromCsrid(pGlobal, iCsrId);
	pTab = (Fts5Table*)pCsr->base.pVtab;
	*ppConfig = pTab->pConfig;

	return pTab->pIndex;
}


static int fts5PoslistBlob(sqlite3_context *pCtx, Fts5Cursor *pCsr) {
	int i;
	int rc = SQLITE_OK;
	int nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
	Fts5Buffer val;

	memset(&val, 0, sizeof(Fts5Buffer));
	switch (((Fts5Table*)(pCsr->base.pVtab))->pConfig->eDetail) {
	case FTS5_DETAIL_FULL:

		
		for (i = 0; i<(nPhrase - 1); i++) {
			const u8 *dummy;
			int nByte = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &dummy);
			sqlite3Fts5BufferAppendVarint(&rc, &val, nByte);
		}

		
		for (i = 0; i<nPhrase; i++) {
			const u8 *pPoslist;
			int nPoslist;
			nPoslist = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &pPoslist);
			sqlite3Fts5BufferAppendBlob(&rc, &val, nPoslist, pPoslist);
		}
		break;

	case FTS5_DETAIL_COLUMNS:

		
		for (i = 0; rc == SQLITE_OK && i<(nPhrase - 1); i++) {
			const u8 *dummy;
			int nByte;
			rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &dummy, &nByte);
			sqlite3Fts5BufferAppendVarint(&rc, &val, nByte);
		}

		
		for (i = 0; rc == SQLITE_OK && i<nPhrase; i++) {
			const u8 *pPoslist;
			int nPoslist;
			rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &pPoslist, &nPoslist);
			sqlite3Fts5BufferAppendBlob(&rc, &val, nPoslist, pPoslist);
		}
		break;

	default:
		break;
	}

	sqlite3_result_blob(pCtx, val.p, val.n, sqlite3_free);
	return rc;
}


static int fts5ColumnMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite3_context *pCtx,          
	int iCol                        
) {
	Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
	Fts5Config *pConfig = pTab->pConfig;
	Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
	int rc = SQLITE_OK;

	assert(CsrFlagTest(pCsr, FTS5CSR_EOF) == 0);

	if (pCsr->ePlan == FTS5_PLAN_SPECIAL) {
		if (iCol == pConfig->nCol) {
			sqlite3_result_int64(pCtx, pCsr->iSpecial);
		}
	}
	else

		if (iCol == pConfig->nCol) {
			
			sqlite3_result_int64(pCtx, pCsr->iCsrId);
		}
		else if (iCol == pConfig->nCol + 1) {

			
			if (pCsr->ePlan == FTS5_PLAN_SOURCE) {
				fts5PoslistBlob(pCtx, pCsr);
			}
			else if (
				pCsr->ePlan == FTS5_PLAN_MATCH
				|| pCsr->ePlan == FTS5_PLAN_SORTED_MATCH
				) {
				if (pCsr->pRank || SQLITE_OK == (rc = fts5FindRankFunction(pCsr))) {
					fts5ApiInvoke(pCsr->pRank, pCsr, pCtx, pCsr->nRankArg, pCsr->apRankArg);
				}
			}
		}
		else if (!fts5IsContentless(pTab)) {
			rc = fts5SeekCursor(pCsr, 1);
			if (rc == SQLITE_OK) {
				sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol + 1));
			}
		}
		return rc;
}



static int fts5FindFunctionMethod(
	sqlite3_vtab *pVtab,            
	int nUnused,                    
	const char *zName,              
	void(**pxFunc)(sqlite3_context*, int, sqlite3_value**), 
	void **ppArg                    
) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	Fts5Auxiliary *pAux;

	UNUSED_PARAM(nUnused);
	pAux = fts5FindAuxiliary(pTab, zName);
	if (pAux) {
		*pxFunc = fts5ApiCallback;
		*ppArg = (void*)pAux;
		return 1;
	}

	
	return 0;
}


static int fts5RenameMethod(
	sqlite3_vtab *pVtab,            
	const char *zName               
) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	return sqlite3Fts5StorageRename(pTab->pStorage, zName);
}


static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	UNUSED_PARAM(iSavepoint);  
	fts5CheckTransactionState(pTab, FTS5_SAVEPOINT, iSavepoint);
	fts5TripCursors(pTab);
	return sqlite3Fts5StorageSync(pTab->pStorage, 0);
}


static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	UNUSED_PARAM(iSavepoint);  
	fts5CheckTransactionState(pTab, FTS5_RELEASE, iSavepoint);
	fts5TripCursors(pTab);
	return sqlite3Fts5StorageSync(pTab->pStorage, 0);
}


static int fts5RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint) {
	Fts5Table *pTab = (Fts5Table*)pVtab;
	UNUSED_PARAM(iSavepoint);  
	fts5CheckTransactionState(pTab, FTS5_ROLLBACKTO, iSavepoint);
	fts5TripCursors(pTab);
	return sqlite3Fts5StorageRollback(pTab->pStorage);
}


static int fts5CreateAux(
	fts5_api *pApi,                 
	const char *zName,              
	void *pUserData,                
	fts5_extension_function xFunc,  
	void(*xDestroy)(void*)          
) {
	Fts5Global *pGlobal = (Fts5Global*)pApi;
	int rc = sqlite3_overload_function(pGlobal->db, zName, -1);
	if (rc == SQLITE_OK) {
		Fts5Auxiliary *pAux;
		int nName;                      
		int nByte;                      

		nName = (int)strlen(zName) + 1;
		nByte = sizeof(Fts5Auxiliary) + nName;
		pAux = (Fts5Auxiliary*)sqlite3_malloc(nByte);
		if (pAux) {
			memset(pAux, 0, nByte);
			pAux->zFunc = (char*)&pAux[1];
			memcpy(pAux->zFunc, zName, nName);
			pAux->pGlobal = pGlobal;
			pAux->pUserData = pUserData;
			pAux->xFunc = xFunc;
			pAux->xDestroy = xDestroy;
			pAux->pNext = pGlobal->pAux;
			pGlobal->pAux = pAux;
		}
		else {
			rc = SQLITE_NOMEM;
		}
	}

	return rc;
}


static int fts5CreateTokenizer(
	fts5_api *pApi,                 
	const char *zName,              
	void *pUserData,                
	fts5_tokenizer *pTokenizer,     
	void(*xDestroy)(void*)          
) {
	Fts5Global *pGlobal = (Fts5Global*)pApi;
	Fts5TokenizerModule *pNew;
	int nName;                      
	int nByte;                      
	int rc = SQLITE_OK;

	nName = (int)strlen(zName) + 1;
	nByte = sizeof(Fts5TokenizerModule) + nName;
	pNew = (Fts5TokenizerModule*)sqlite3_malloc(nByte);
	if (pNew) {
		memset(pNew, 0, nByte);
		pNew->zName = (char*)&pNew[1];
		memcpy(pNew->zName, zName, nName);
		pNew->pUserData = pUserData;
		pNew->x = *pTokenizer;
		pNew->xDestroy = xDestroy;
		pNew->pNext = pGlobal->pTok;
		pGlobal->pTok = pNew;
		if (pNew->pNext == 0) {
			pGlobal->pDfltTok = pNew;
		}
	}
	else {
		rc = SQLITE_NOMEM;
	}

	return rc;
}

static Fts5TokenizerModule *fts5LocateTokenizer(
	Fts5Global *pGlobal,
	const char *zName
) {
	Fts5TokenizerModule *pMod = 0;

	if (zName == 0) {
		pMod = pGlobal->pDfltTok;
	}
	else {
		for (pMod = pGlobal->pTok; pMod; pMod = pMod->pNext) {
			if (sqlite3_stricmp(zName, pMod->zName) == 0) break;
		}
	}

	return pMod;
}


static int fts5FindTokenizer(
	fts5_api *pApi,                 
	const char *zName,              
	void **ppUserData,
	fts5_tokenizer *pTokenizer      
) {
	int rc = SQLITE_OK;
	Fts5TokenizerModule *pMod;

	pMod = fts5LocateTokenizer((Fts5Global*)pApi, zName);
	if (pMod) {
		*pTokenizer = pMod->x;
		*ppUserData = pMod->pUserData;
	}
	else {
		memset(pTokenizer, 0, sizeof(fts5_tokenizer));
		rc = SQLITE_ERROR;
	}

	return rc;
}

static int sqlite3Fts5GetTokenizer(
	Fts5Global *pGlobal,
	const char **azArg,
	int nArg,
	Fts5Tokenizer **ppTok,
	fts5_tokenizer **ppTokApi,
	char **pzErr
) {
	Fts5TokenizerModule *pMod;
	int rc = SQLITE_OK;

	pMod = fts5LocateTokenizer(pGlobal, nArg == 0 ? 0 : azArg[0]);
	if (pMod == 0) {
		assert(nArg>0);
		rc = SQLITE_ERROR;
		*pzErr = sqlite3_mprintf("no such tokenizer: %s", azArg[0]);
	}
	else {
		rc = pMod->x.xCreate(pMod->pUserData, &azArg[1], (nArg ? nArg - 1 : 0), ppTok);
		*ppTokApi = &pMod->x;
		if (rc != SQLITE_OK && pzErr) {
			*pzErr = sqlite3_mprintf("error in tokenizer constructor");
		}
	}

	if (rc != SQLITE_OK) {
		*ppTokApi = 0;
		*ppTok = 0;
	}

	return rc;
}

static void fts5ModuleDestroy(void *pCtx) {
	Fts5TokenizerModule *pTok, *pNextTok;
	Fts5Auxiliary *pAux, *pNextAux;
	Fts5Global *pGlobal = (Fts5Global*)pCtx;

	for (pAux = pGlobal->pAux; pAux; pAux = pNextAux) {
		pNextAux = pAux->pNext;
		if (pAux->xDestroy) pAux->xDestroy(pAux->pUserData);
		sqlite3_free(pAux);
	}

	for (pTok = pGlobal->pTok; pTok; pTok = pNextTok) {
		pNextTok = pTok->pNext;
		if (pTok->xDestroy) pTok->xDestroy(pTok->pUserData);
		sqlite3_free(pTok);
	}

	sqlite3_free(pGlobal);
}

static void fts5Fts5Func(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apUnused        
) {
	Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);
	char buf[8];
	UNUSED_PARAM2(nArg, apUnused);
	assert(nArg == 0);
	assert(sizeof(buf) >= sizeof(pGlobal));
	memcpy(buf, (void*)&pGlobal, sizeof(pGlobal));
	sqlite3_result_blob(pCtx, buf, sizeof(pGlobal), SQLITE_TRANSIENT);
}


static void fts5SourceIdFunc(
	sqlite3_context *pCtx,          
	int nArg,                       
	sqlite3_value **apUnused        
) {
	assert(nArg == 0);
	UNUSED_PARAM2(nArg, apUnused);
	sqlite3_result_text(pCtx, "fts5: 2016-11-28 19:13:37 bbd85d235f7037c6a033a9690534391ffeacecc8", -1, SQLITE_TRANSIENT);
}

static int fts5Init(sqlite3 *db) {
	static const sqlite3_module fts5Mod = {
		 2,
		 fts5CreateMethod,
		 fts5ConnectMethod,
		 fts5BestIndexMethod,
		 fts5DisconnectMethod,
		 fts5DestroyMethod,
		 fts5OpenMethod,
		 fts5CloseMethod,
		 fts5FilterMethod,
		 fts5NextMethod,
		 fts5EofMethod,
		 fts5ColumnMethod,
		 fts5RowidMethod,
		 fts5UpdateMethod,
		 fts5BeginMethod,
		 fts5SyncMethod,
		 fts5CommitMethod,
		 fts5RollbackMethod,
		 fts5FindFunctionMethod,
		 fts5RenameMethod,
		 fts5SavepointMethod,
		 fts5ReleaseMethod,
		 fts5RollbackToMethod,
	};

	int rc;
	Fts5Global *pGlobal = 0;

	pGlobal = (Fts5Global*)sqlite3_malloc(sizeof(Fts5Global));
	if (pGlobal == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		void *p = (void*)pGlobal;
		memset(pGlobal, 0, sizeof(Fts5Global));
		pGlobal->db = db;
		pGlobal->api.iVersion = 2;
		pGlobal->api.xCreateFunction = fts5CreateAux;
		pGlobal->api.xCreateTokenizer = fts5CreateTokenizer;
		pGlobal->api.xFindTokenizer = fts5FindTokenizer;
		rc = sqlite3_create_module_v2(db, "fts5", &fts5Mod, p, fts5ModuleDestroy);
		if (rc == SQLITE_OK) rc = sqlite3Fts5IndexInit(db);
		if (rc == SQLITE_OK) rc = sqlite3Fts5ExprInit(pGlobal, db);
		if (rc == SQLITE_OK) rc = sqlite3Fts5AuxInit(&pGlobal->api);
		if (rc == SQLITE_OK) rc = sqlite3Fts5TokenizerInit(&pGlobal->api);
		if (rc == SQLITE_OK) rc = sqlite3Fts5VocabInit(pGlobal, db);
		if (rc == SQLITE_OK) {
			rc = sqlite3_create_function(
				db, "fts5", 0, SQLITE_UTF8, p, fts5Fts5Func, 0, 0
			);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3_create_function(
				db, "fts5_source_id", 0, SQLITE_UTF8, p, fts5SourceIdFunc, 0, 0
			);
		}
	}

	
#ifdef SQLITE_FTS5_ENABLE_TEST_MI
	if (rc == SQLITE_OK) {
		extern int sqlite3Fts5TestRegisterMatchinfo(sqlite3*);
		rc = sqlite3Fts5TestRegisterMatchinfo(db);
	}
#endif

	return rc;
}


#ifndef SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi);
	(void)pzErrMsg;  
	return fts5Init(db);
}

#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts5_init(
	sqlite3 *db,
	char **pzErrMsg,
	const sqlite3_api_routines *pApi
) {
	SQLITE_EXTENSION_INIT2(pApi);
	(void)pzErrMsg;  
	return fts5Init(db);
}
#else
SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3 *db) {
	return fts5Init(db);
}
#endif







struct Fts5Storage {
	Fts5Config *pConfig;
	Fts5Index *pIndex;
	int bTotalsValid;               
	i64 nTotalRow;                  
	i64 *aTotalSize;                
	sqlite3_stmt *aStmt[11];
};


#if FTS5_STMT_SCAN_ASC!=0 
# error "FTS5_STMT_SCAN_ASC mismatch" 
#endif
#if FTS5_STMT_SCAN_DESC!=1 
# error "FTS5_STMT_SCAN_DESC mismatch" 
#endif
#if FTS5_STMT_LOOKUP!=2
# error "FTS5_STMT_LOOKUP mismatch" 
#endif

#define FTS5_STMT_INSERT_CONTENT  3
#define FTS5_STMT_REPLACE_CONTENT 4
#define FTS5_STMT_DELETE_CONTENT  5
#define FTS5_STMT_REPLACE_DOCSIZE  6
#define FTS5_STMT_DELETE_DOCSIZE  7
#define FTS5_STMT_LOOKUP_DOCSIZE  8
#define FTS5_STMT_REPLACE_CONFIG 9
#define FTS5_STMT_SCAN 10


static int fts5StorageGetStmt(
	Fts5Storage *p,                 
	int eStmt,                      
	sqlite3_stmt **ppStmt,          
	char **pzErrMsg                 
) {
	int rc = SQLITE_OK;

	
	assert(p->pConfig->bColumnsize || (
		eStmt != FTS5_STMT_REPLACE_DOCSIZE
		&& eStmt != FTS5_STMT_DELETE_DOCSIZE
		&& eStmt != FTS5_STMT_LOOKUP_DOCSIZE
		));

	assert(eStmt >= 0 && eStmt<ArraySize(p->aStmt));
	if (p->aStmt[eStmt] == 0) {
		const char *azStmt[] = {
			"SELECT %s FROM %s T WHERE T.%Q >= ? AND T.%Q <= ? ORDER BY T.%Q ASC",
			"SELECT %s FROM %s T WHERE T.%Q <= ? AND T.%Q >= ? ORDER BY T.%Q DESC",
			"SELECT %s FROM %s T WHERE T.%Q=?",               

			"INSERT INTO %Q.'%q_content' VALUES(%s)",         
			"REPLACE INTO %Q.'%q_content' VALUES(%s)",        
			"DELETE FROM %Q.'%q_content' WHERE id=?",         
			"REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",       
			"DELETE FROM %Q.'%q_docsize' WHERE id=?",         

			"SELECT sz FROM %Q.'%q_docsize' WHERE id=?",      

			"REPLACE INTO %Q.'%q_config' VALUES(?,?)",        
			"SELECT %s FROM %s AS T",                         
		};
		Fts5Config *pC = p->pConfig;
		char *zSql = 0;

		switch (eStmt) {
		case FTS5_STMT_SCAN:
			zSql = sqlite3_mprintf(azStmt[eStmt],
				pC->zContentExprlist, pC->zContent
			);
			break;

		case FTS5_STMT_SCAN_ASC:
		case FTS5_STMT_SCAN_DESC:
			zSql = sqlite3_mprintf(azStmt[eStmt], pC->zContentExprlist,
				pC->zContent, pC->zContentRowid, pC->zContentRowid,
				pC->zContentRowid
			);
			break;

		case FTS5_STMT_LOOKUP:
			zSql = sqlite3_mprintf(azStmt[eStmt],
				pC->zContentExprlist, pC->zContent, pC->zContentRowid
			);
			break;

		case FTS5_STMT_INSERT_CONTENT:
		case FTS5_STMT_REPLACE_CONTENT: {
			int nCol = pC->nCol + 1;
			char *zBind;
			int i;

			zBind = sqlite3_malloc(1 + nCol * 2);
			if (zBind) {
				for (i = 0; i<nCol; i++) {
					zBind[i * 2] = '?';
					zBind[i * 2 + 1] = ',';
				}
				zBind[i * 2 - 1] = '\0';
				zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName, zBind);
				sqlite3_free(zBind);
			}
			break;
		}

		default:
			zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName);
			break;
		}

		if (zSql == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			rc = sqlite3_prepare_v2(pC->db, zSql, -1, &p->aStmt[eStmt], 0);
			sqlite3_free(zSql);
			if (rc != SQLITE_OK && pzErrMsg) {
				*pzErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pC->db));
			}
		}
	}

	*ppStmt = p->aStmt[eStmt];
	sqlite3_reset(*ppStmt);
	return rc;
}


static int fts5ExecPrintf(
	sqlite3 *db,
	char **pzErr,
	const char *zFormat,
	...
) {
	int rc;
	va_list ap;                     
	char *zSql;

	va_start(ap, zFormat);
	zSql = sqlite3_vmprintf(zFormat, ap);

	if (zSql == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		rc = sqlite3_exec(db, zSql, 0, 0, pzErr);
		sqlite3_free(zSql);
	}

	va_end(ap);
	return rc;
}


static int sqlite3Fts5DropAll(Fts5Config *pConfig) {
	int rc = fts5ExecPrintf(pConfig->db, 0,
		"DROP TABLE IF EXISTS %Q.'%q_data';"
		"DROP TABLE IF EXISTS %Q.'%q_idx';"
		"DROP TABLE IF EXISTS %Q.'%q_config';",
		pConfig->zDb, pConfig->zName,
		pConfig->zDb, pConfig->zName,
		pConfig->zDb, pConfig->zName
	);
	if (rc == SQLITE_OK && pConfig->bColumnsize) {
		rc = fts5ExecPrintf(pConfig->db, 0,
			"DROP TABLE IF EXISTS %Q.'%q_docsize';",
			pConfig->zDb, pConfig->zName
		);
	}
	if (rc == SQLITE_OK && pConfig->eContent == FTS5_CONTENT_NORMAL) {
		rc = fts5ExecPrintf(pConfig->db, 0,
			"DROP TABLE IF EXISTS %Q.'%q_content';",
			pConfig->zDb, pConfig->zName
		);
	}
	return rc;
}

static void fts5StorageRenameOne(
	Fts5Config *pConfig,            
	int *pRc,                       
	const char *zTail,              
	const char *zName               
) {
	if (*pRc == SQLITE_OK) {
		*pRc = fts5ExecPrintf(pConfig->db, 0,
			"ALTER TABLE %Q.'%q_%s' RENAME TO '%q_%s';",
			pConfig->zDb, pConfig->zName, zTail, zName, zTail
		);
	}
}

static int sqlite3Fts5StorageRename(Fts5Storage *pStorage, const char *zName) {
	Fts5Config *pConfig = pStorage->pConfig;
	int rc = sqlite3Fts5StorageSync(pStorage, 1);

	fts5StorageRenameOne(pConfig, &rc, "data", zName);
	fts5StorageRenameOne(pConfig, &rc, "idx", zName);
	fts5StorageRenameOne(pConfig, &rc, "config", zName);
	if (pConfig->bColumnsize) {
		fts5StorageRenameOne(pConfig, &rc, "docsize", zName);
	}
	if (pConfig->eContent == FTS5_CONTENT_NORMAL) {
		fts5StorageRenameOne(pConfig, &rc, "content", zName);
	}
	return rc;
}


static int sqlite3Fts5CreateTable(
	Fts5Config *pConfig,            
	const char *zPost,              
	const char *zDefn,              
	int bWithout,                   
	char **pzErr                    
) {
	int rc;
	char *zErr = 0;

	rc = fts5ExecPrintf(pConfig->db, &zErr, "CREATE TABLE %Q.'%q_%q'(%s)%s",
		pConfig->zDb, pConfig->zName, zPost, zDefn,
#ifndef SQLITE_FTS5_NO_WITHOUT_ROWID
		bWithout ? " WITHOUT ROWID" :
#endif
		""
	);
	if (zErr) {
		*pzErr = sqlite3_mprintf(
			"fts5: error creating shadow table %q_%s: %s",
			pConfig->zName, zPost, zErr
		);
		sqlite3_free(zErr);
	}

	return rc;
}


static int sqlite3Fts5StorageOpen(
	Fts5Config *pConfig,
	Fts5Index *pIndex,
	int bCreate,
	Fts5Storage **pp,
	char **pzErr                    
) {
	int rc = SQLITE_OK;
	Fts5Storage *p;                 
	int nByte;                      

	nByte = sizeof(Fts5Storage)               
		+ pConfig->nCol * sizeof(i64);      
	*pp = p = (Fts5Storage*)sqlite3_malloc(nByte);
	if (!p) return SQLITE_NOMEM;

	memset(p, 0, nByte);
	p->aTotalSize = (i64*)&p[1];
	p->pConfig = pConfig;
	p->pIndex = pIndex;

	if (bCreate) {
		if (pConfig->eContent == FTS5_CONTENT_NORMAL) {
			int nDefn = 32 + pConfig->nCol * 10;
			char *zDefn = sqlite3_malloc(32 + pConfig->nCol * 10);
			if (zDefn == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				int i;
				int iOff;
				sqlite3_snprintf(nDefn, zDefn, "id INTEGER PRIMARY KEY");
				iOff = (int)strlen(zDefn);
				for (i = 0; i<pConfig->nCol; i++) {
					sqlite3_snprintf(nDefn - iOff, &zDefn[iOff], ", c%d", i);
					iOff += (int)strlen(&zDefn[iOff]);
				}
				rc = sqlite3Fts5CreateTable(pConfig, "content", zDefn, 0, pzErr);
			}
			sqlite3_free(zDefn);
		}

		if (rc == SQLITE_OK && pConfig->bColumnsize) {
			rc = sqlite3Fts5CreateTable(
				pConfig, "docsize", "id INTEGER PRIMARY KEY, sz BLOB", 0, pzErr
			);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts5CreateTable(
				pConfig, "config", "k PRIMARY KEY, v", 1, pzErr
			);
		}
		if (rc == SQLITE_OK) {
			rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);
		}
	}

	if (rc) {
		sqlite3Fts5StorageClose(p);
		*pp = 0;
	}
	return rc;
}


static int sqlite3Fts5StorageClose(Fts5Storage *p) {
	int rc = SQLITE_OK;
	if (p) {
		int i;

		
		for (i = 0; i<ArraySize(p->aStmt); i++) {
			sqlite3_finalize(p->aStmt[i]);
		}

		sqlite3_free(p);
	}
	return rc;
}

typedef struct Fts5InsertCtx Fts5InsertCtx;
struct Fts5InsertCtx {
	Fts5Storage *pStorage;
	int iCol;
	int szCol;                      
};


static int fts5StorageInsertCallback(
	void *pContext,                 
	int tflags,
	const char *pToken,             
	int nToken,                     
	int iUnused1,                   
	int iUnused2                    
) {
	Fts5InsertCtx *pCtx = (Fts5InsertCtx*)pContext;
	Fts5Index *pIdx = pCtx->pStorage->pIndex;
	UNUSED_PARAM2(iUnused1, iUnused2);
	if (nToken>FTS5_MAX_TOKEN_SIZE) nToken = FTS5_MAX_TOKEN_SIZE;
	if ((tflags & FTS5_TOKEN_COLOCATED) == 0 || pCtx->szCol == 0) {
		pCtx->szCol++;
	}
	return sqlite3Fts5IndexWrite(pIdx, pCtx->iCol, pCtx->szCol - 1, pToken, nToken);
}


static int fts5StorageDeleteFromIndex(
	Fts5Storage *p,
	i64 iDel,
	sqlite3_value **apVal
) {
	Fts5Config *pConfig = p->pConfig;
	sqlite3_stmt *pSeek = 0;        
	int rc;                         
	int rc2;                        
	int iCol;
	Fts5InsertCtx ctx;

	if (apVal == 0) {
		rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP, &pSeek, 0);
		if (rc != SQLITE_OK) return rc;
		sqlite3_bind_int64(pSeek, 1, iDel);
		if (sqlite3_step(pSeek) != SQLITE_ROW) {
			return sqlite3_reset(pSeek);
		}
	}

	ctx.pStorage = p;
	ctx.iCol = -1;
	rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);
	for (iCol = 1; rc == SQLITE_OK && iCol <= pConfig->nCol; iCol++) {
		if (pConfig->abUnindexed[iCol - 1] == 0) {
			const char *zText;
			int nText;
			if (pSeek) {
				zText = (const char*)sqlite3_column_text(pSeek, iCol);
				nText = sqlite3_column_bytes(pSeek, iCol);
			}
			else {
				zText = (const char*)sqlite3_value_text(apVal[iCol - 1]);
				nText = sqlite3_value_bytes(apVal[iCol - 1]);
			}
			ctx.szCol = 0;
			rc = sqlite3Fts5Tokenize(pConfig, FTS5_TOKENIZE_DOCUMENT,
				zText, nText, (void*)&ctx, fts5StorageInsertCallback
			);
			p->aTotalSize[iCol - 1] -= (i64)ctx.szCol;
		}
	}
	p->nTotalRow--;

	rc2 = sqlite3_reset(pSeek);
	if (rc == SQLITE_OK) rc = rc2;
	return rc;
}



static int fts5StorageInsertDocsize(
	Fts5Storage *p,                 
	i64 iRowid,                     
	Fts5Buffer *pBuf                
) {
	int rc = SQLITE_OK;
	if (p->pConfig->bColumnsize) {
		sqlite3_stmt *pReplace = 0;
		rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pReplace, 1, iRowid);
			sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);
			sqlite3_step(pReplace);
			rc = sqlite3_reset(pReplace);
		}
	}
	return rc;
}


static int fts5StorageLoadTotals(Fts5Storage *p, int bCache) {
	int rc = SQLITE_OK;
	if (p->bTotalsValid == 0) {
		rc = sqlite3Fts5IndexGetAverages(p->pIndex, &p->nTotalRow, p->aTotalSize);
		p->bTotalsValid = bCache;
	}
	return rc;
}


static int fts5StorageSaveTotals(Fts5Storage *p) {
	int nCol = p->pConfig->nCol;
	int i;
	Fts5Buffer buf;
	int rc = SQLITE_OK;
	memset(&buf, 0, sizeof(buf));

	sqlite3Fts5BufferAppendVarint(&rc, &buf, p->nTotalRow);
	for (i = 0; i<nCol; i++) {
		sqlite3Fts5BufferAppendVarint(&rc, &buf, p->aTotalSize[i]);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexSetAverages(p->pIndex, buf.p, buf.n);
	}
	sqlite3_free(buf.p);

	return rc;
}


static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64 iDel, sqlite3_value **apVal) {
	Fts5Config *pConfig = p->pConfig;
	int rc;
	sqlite3_stmt *pDel = 0;

	assert(pConfig->eContent != FTS5_CONTENT_NORMAL || apVal == 0);
	rc = fts5StorageLoadTotals(p, 1);

	
	if (rc == SQLITE_OK) {
		rc = fts5StorageDeleteFromIndex(p, iDel, apVal);
	}

	
	if (rc == SQLITE_OK && pConfig->bColumnsize) {
		rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_DOCSIZE, &pDel, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pDel, 1, iDel);
			sqlite3_step(pDel);
			rc = sqlite3_reset(pDel);
		}
	}

	
	if (pConfig->eContent == FTS5_CONTENT_NORMAL) {
		if (rc == SQLITE_OK) {
			rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_CONTENT, &pDel, 0);
		}
		if (rc == SQLITE_OK) {
			sqlite3_bind_int64(pDel, 1, iDel);
			sqlite3_step(pDel);
			rc = sqlite3_reset(pDel);
		}
	}

	
	if (rc == SQLITE_OK) {
		rc = fts5StorageSaveTotals(p);
	}

	return rc;
}


static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p) {
	Fts5Config *pConfig = p->pConfig;
	int rc;

	
	rc = fts5ExecPrintf(pConfig->db, 0,
		"DELETE FROM %Q.'%q_data';"
		"DELETE FROM %Q.'%q_idx';",
		pConfig->zDb, pConfig->zName,
		pConfig->zDb, pConfig->zName
	);
	if (rc == SQLITE_OK && pConfig->bColumnsize) {
		rc = fts5ExecPrintf(pConfig->db, 0,
			"DELETE FROM %Q.'%q_docsize';",
			pConfig->zDb, pConfig->zName
		);
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexReinit(p->pIndex);
	}
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);
	}
	return rc;
}

static int sqlite3Fts5StorageRebuild(Fts5Storage *p) {
	Fts5Buffer buf = { 0,0,0 };
	Fts5Config *pConfig = p->pConfig;
	sqlite3_stmt *pScan = 0;
	Fts5InsertCtx ctx;
	int rc;

	memset(&ctx, 0, sizeof(Fts5InsertCtx));
	ctx.pStorage = p;
	rc = sqlite3Fts5StorageDeleteAll(p);
	if (rc == SQLITE_OK) {
		rc = fts5StorageLoadTotals(p, 1);
	}

	if (rc == SQLITE_OK) {
		rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);
	}

	while (rc == SQLITE_OK && SQLITE_ROW == sqlite3_step(pScan)) {
		i64 iRowid = sqlite3_column_int64(pScan, 0);

		sqlite3Fts5BufferZero(&buf);
		rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);
		for (ctx.iCol = 0; rc == SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++) {
			ctx.szCol = 0;
			if (pConfig->abUnindexed[ctx.iCol] == 0) {
				rc = sqlite3Fts5Tokenize(pConfig,
					FTS5_TOKENIZE_DOCUMENT,
					(const char*)sqlite3_column_text(pScan, ctx.iCol + 1),
					sqlite3_column_bytes(pScan, ctx.iCol + 1),
					(void*)&ctx,
					fts5StorageInsertCallback
				);
			}
			sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);
			p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;
		}
		p->nTotalRow++;

		if (rc == SQLITE_OK) {
			rc = fts5StorageInsertDocsize(p, iRowid, &buf);
		}
	}
	sqlite3_free(buf.p);

	
	if (rc == SQLITE_OK) {
		rc = fts5StorageSaveTotals(p);
	}
	return rc;
}

static int sqlite3Fts5StorageOptimize(Fts5Storage *p) {
	return sqlite3Fts5IndexOptimize(p->pIndex);
}

static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge) {
	return sqlite3Fts5IndexMerge(p->pIndex, nMerge);
}

static int sqlite3Fts5StorageReset(Fts5Storage *p) {
	return sqlite3Fts5IndexReset(p->pIndex);
}


static int fts5StorageNewRowid(Fts5Storage *p, i64 *piRowid) {
	int rc = SQLITE_MISMATCH;
	if (p->pConfig->bColumnsize) {
		sqlite3_stmt *pReplace = 0;
		rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);
		if (rc == SQLITE_OK) {
			sqlite3_bind_null(pReplace, 1);
			sqlite3_bind_null(pReplace, 2);
			sqlite3_step(pReplace);
			rc = sqlite3_reset(pReplace);
		}
		if (rc == SQLITE_OK) {
			*piRowid = sqlite3_last_insert_rowid(p->pConfig->db);
		}
	}
	return rc;
}


static int sqlite3Fts5StorageContentInsert(
	Fts5Storage *p,
	sqlite3_value **apVal,
	i64 *piRowid
) {
	Fts5Config *pConfig = p->pConfig;
	int rc = SQLITE_OK;

	
	if (pConfig->eContent != FTS5_CONTENT_NORMAL) {
		if (sqlite3_value_type(apVal[1]) == SQLITE_INTEGER) {
			*piRowid = sqlite3_value_int64(apVal[1]);
		}
		else {
			rc = fts5StorageNewRowid(p, piRowid);
		}
	}
	else {
		sqlite3_stmt *pInsert = 0;    
		int i;                        
		rc = fts5StorageGetStmt(p, FTS5_STMT_INSERT_CONTENT, &pInsert, 0);
		for (i = 1; rc == SQLITE_OK && i <= pConfig->nCol + 1; i++) {
			rc = sqlite3_bind_value(pInsert, i, apVal[i]);
		}
		if (rc == SQLITE_OK) {
			sqlite3_step(pInsert);
			rc = sqlite3_reset(pInsert);
		}
		*piRowid = sqlite3_last_insert_rowid(pConfig->db);
	}

	return rc;
}


static int sqlite3Fts5StorageIndexInsert(
	Fts5Storage *p,
	sqlite3_value **apVal,
	i64 iRowid
) {
	Fts5Config *pConfig = p->pConfig;
	int rc = SQLITE_OK;             
	Fts5InsertCtx ctx;              
	Fts5Buffer buf;                 

	memset(&buf, 0, sizeof(Fts5Buffer));
	ctx.pStorage = p;
	rc = fts5StorageLoadTotals(p, 1);

	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);
	}
	for (ctx.iCol = 0; rc == SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++) {
		ctx.szCol = 0;
		if (pConfig->abUnindexed[ctx.iCol] == 0) {
			rc = sqlite3Fts5Tokenize(pConfig,
				FTS5_TOKENIZE_DOCUMENT,
				(const char*)sqlite3_value_text(apVal[ctx.iCol + 2]),
				sqlite3_value_bytes(apVal[ctx.iCol + 2]),
				(void*)&ctx,
				fts5StorageInsertCallback
			);
		}
		sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);
		p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;
	}
	p->nTotalRow++;

	
	if (rc == SQLITE_OK) {
		rc = fts5StorageInsertDocsize(p, iRowid, &buf);
	}
	sqlite3_free(buf.p);

	
	if (rc == SQLITE_OK) {
		rc = fts5StorageSaveTotals(p);
	}

	return rc;
}

static int fts5StorageCount(Fts5Storage *p, const char *zSuffix, i64 *pnRow) {
	Fts5Config *pConfig = p->pConfig;
	char *zSql;
	int rc;

	zSql = sqlite3_mprintf("SELECT count(*) FROM %Q.'%q_%s'",
		pConfig->zDb, pConfig->zName, zSuffix
	);
	if (zSql == 0) {
		rc = SQLITE_NOMEM;
	}
	else {
		sqlite3_stmt *pCnt = 0;
		rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pCnt, 0);
		if (rc == SQLITE_OK) {
			if (SQLITE_ROW == sqlite3_step(pCnt)) {
				*pnRow = sqlite3_column_int64(pCnt, 0);
			}
			rc = sqlite3_finalize(pCnt);
		}
	}

	sqlite3_free(zSql);
	return rc;
}


typedef struct Fts5IntegrityCtx Fts5IntegrityCtx;
struct Fts5IntegrityCtx {
	i64 iRowid;
	int iCol;
	int szCol;
	u64 cksum;
	Fts5Termset *pTermset;
	Fts5Config *pConfig;
};



static int fts5StorageIntegrityCallback(
	void *pContext,                 
	int tflags,
	const char *pToken,             
	int nToken,                     
	int iUnused1,                   
	int iUnused2                    
) {
	Fts5IntegrityCtx *pCtx = (Fts5IntegrityCtx*)pContext;
	Fts5Termset *pTermset = pCtx->pTermset;
	int bPresent;
	int ii;
	int rc = SQLITE_OK;
	int iPos;
	int iCol;

	UNUSED_PARAM2(iUnused1, iUnused2);
	if (nToken>FTS5_MAX_TOKEN_SIZE) nToken = FTS5_MAX_TOKEN_SIZE;

	if ((tflags & FTS5_TOKEN_COLOCATED) == 0 || pCtx->szCol == 0) {
		pCtx->szCol++;
	}

	switch (pCtx->pConfig->eDetail) {
	case FTS5_DETAIL_FULL:
		iPos = pCtx->szCol - 1;
		iCol = pCtx->iCol;
		break;

	case FTS5_DETAIL_COLUMNS:
		iPos = pCtx->iCol;
		iCol = 0;
		break;

	default:
		assert(pCtx->pConfig->eDetail == FTS5_DETAIL_NONE);
		iPos = 0;
		iCol = 0;
		break;
	}

	rc = sqlite3Fts5TermsetAdd(pTermset, 0, pToken, nToken, &bPresent);
	if (rc == SQLITE_OK && bPresent == 0) {
		pCtx->cksum ^= sqlite3Fts5IndexEntryCksum(
			pCtx->iRowid, iCol, iPos, 0, pToken, nToken
		);
	}

	for (ii = 0; rc == SQLITE_OK && ii<pCtx->pConfig->nPrefix; ii++) {
		const int nChar = pCtx->pConfig->aPrefix[ii];
		int nByte = sqlite3Fts5IndexCharlenToBytelen(pToken, nToken, nChar);
		if (nByte) {
			rc = sqlite3Fts5TermsetAdd(pTermset, ii + 1, pToken, nByte, &bPresent);
			if (bPresent == 0) {
				pCtx->cksum ^= sqlite3Fts5IndexEntryCksum(
					pCtx->iRowid, iCol, iPos, ii + 1, pToken, nByte
				);
			}
		}
	}

	return rc;
}


static int sqlite3Fts5StorageIntegrity(Fts5Storage *p) {
	Fts5Config *pConfig = p->pConfig;
	int rc;                         
	int *aColSize;                  
	i64 *aTotalSize;                
	Fts5IntegrityCtx ctx;
	sqlite3_stmt *pScan;

	memset(&ctx, 0, sizeof(Fts5IntegrityCtx));
	ctx.pConfig = p->pConfig;
	aTotalSize = (i64*)sqlite3_malloc(pConfig->nCol * (sizeof(int) + sizeof(i64)));
	if (!aTotalSize) return SQLITE_NOMEM;
	aColSize = (int*)&aTotalSize[pConfig->nCol];
	memset(aTotalSize, 0, sizeof(i64) * pConfig->nCol);

	
	rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);
	if (rc == SQLITE_OK) {
		int rc2;
		while (SQLITE_ROW == sqlite3_step(pScan)) {
			int i;
			ctx.iRowid = sqlite3_column_int64(pScan, 0);
			ctx.szCol = 0;
			if (pConfig->bColumnsize) {
				rc = sqlite3Fts5StorageDocsize(p, ctx.iRowid, aColSize);
			}
			if (rc == SQLITE_OK && pConfig->eDetail == FTS5_DETAIL_NONE) {
				rc = sqlite3Fts5TermsetNew(&ctx.pTermset);
			}
			for (i = 0; rc == SQLITE_OK && i<pConfig->nCol; i++) {
				if (pConfig->abUnindexed[i]) continue;
				ctx.iCol = i;
				ctx.szCol = 0;
				if (pConfig->eDetail == FTS5_DETAIL_COLUMNS) {
					rc = sqlite3Fts5TermsetNew(&ctx.pTermset);
				}
				if (rc == SQLITE_OK) {
					rc = sqlite3Fts5Tokenize(pConfig,
						FTS5_TOKENIZE_DOCUMENT,
						(const char*)sqlite3_column_text(pScan, i + 1),
						sqlite3_column_bytes(pScan, i + 1),
						(void*)&ctx,
						fts5StorageIntegrityCallback
					);
				}
				if (rc == SQLITE_OK && pConfig->bColumnsize && ctx.szCol != aColSize[i]) {
					rc = FTS5_CORRUPT;
				}
				aTotalSize[i] += ctx.szCol;
				if (pConfig->eDetail == FTS5_DETAIL_COLUMNS) {
					sqlite3Fts5TermsetFree(ctx.pTermset);
					ctx.pTermset = 0;
				}
			}
			sqlite3Fts5TermsetFree(ctx.pTermset);
			ctx.pTermset = 0;

			if (rc != SQLITE_OK) break;
		}
		rc2 = sqlite3_reset(pScan);
		if (rc == SQLITE_OK) rc = rc2;
	}

	
	if (rc == SQLITE_OK) {
		int i;
		rc = fts5StorageLoadTotals(p, 0);
		for (i = 0; rc == SQLITE_OK && i<pConfig->nCol; i++) {
			if (p->aTotalSize[i] != aTotalSize[i]) rc = FTS5_CORRUPT;
		}
	}

	
	if (rc == SQLITE_OK && pConfig->eContent == FTS5_CONTENT_NORMAL) {
		i64 nRow = 0;
		rc = fts5StorageCount(p, "content", &nRow);
		if (rc == SQLITE_OK && nRow != p->nTotalRow) rc = FTS5_CORRUPT;
	}
	if (rc == SQLITE_OK && pConfig->bColumnsize) {
		i64 nRow = 0;
		rc = fts5StorageCount(p, "docsize", &nRow);
		if (rc == SQLITE_OK && nRow != p->nTotalRow) rc = FTS5_CORRUPT;
	}

	
	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexIntegrityCheck(p->pIndex, ctx.cksum);
	}

	sqlite3_free(aTotalSize);
	return rc;
}


static int sqlite3Fts5StorageStmt(
	Fts5Storage *p,
	int eStmt,
	sqlite3_stmt **pp,
	char **pzErrMsg
) {
	int rc;
	assert(eStmt == FTS5_STMT_SCAN_ASC
		|| eStmt == FTS5_STMT_SCAN_DESC
		|| eStmt == FTS5_STMT_LOOKUP
	);
	rc = fts5StorageGetStmt(p, eStmt, pp, pzErrMsg);
	if (rc == SQLITE_OK) {
		assert(p->aStmt[eStmt] == *pp);
		p->aStmt[eStmt] = 0;
	}
	return rc;
}


static void sqlite3Fts5StorageStmtRelease(
	Fts5Storage *p,
	int eStmt,
	sqlite3_stmt *pStmt
) {
	assert(eStmt == FTS5_STMT_SCAN_ASC
		|| eStmt == FTS5_STMT_SCAN_DESC
		|| eStmt == FTS5_STMT_LOOKUP
	);
	if (p->aStmt[eStmt] == 0) {
		sqlite3_reset(pStmt);
		p->aStmt[eStmt] = pStmt;
	}
	else {
		sqlite3_finalize(pStmt);
	}
}

static int fts5StorageDecodeSizeArray(
	int *aCol, int nCol,            
	const u8 *aBlob, int nBlob      
) {
	int i;
	int iOff = 0;
	for (i = 0; i<nCol; i++) {
		if (iOff >= nBlob) return 1;
		iOff += fts5GetVarint32(&aBlob[iOff], aCol[i]);
	}
	return (iOff != nBlob);
}


static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol) {
	int nCol = p->pConfig->nCol;    
	sqlite3_stmt *pLookup = 0;      
	int rc;                         

	assert(p->pConfig->bColumnsize);
	rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP_DOCSIZE, &pLookup, 0);
	if (rc == SQLITE_OK) {
		int bCorrupt = 1;
		sqlite3_bind_int64(pLookup, 1, iRowid);
		if (SQLITE_ROW == sqlite3_step(pLookup)) {
			const u8 *aBlob = sqlite3_column_blob(pLookup, 0);
			int nBlob = sqlite3_column_bytes(pLookup, 0);
			if (0 == fts5StorageDecodeSizeArray(aCol, nCol, aBlob, nBlob)) {
				bCorrupt = 0;
			}
		}
		rc = sqlite3_reset(pLookup);
		if (bCorrupt && rc == SQLITE_OK) {
			rc = FTS5_CORRUPT;
		}
	}

	return rc;
}

static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnToken) {
	int rc = fts5StorageLoadTotals(p, 0);
	if (rc == SQLITE_OK) {
		*pnToken = 0;
		if (iCol<0) {
			int i;
			for (i = 0; i<p->pConfig->nCol; i++) {
				*pnToken += p->aTotalSize[i];
			}
		}
		else if (iCol<p->pConfig->nCol) {
			*pnToken = p->aTotalSize[iCol];
		}
		else {
			rc = SQLITE_RANGE;
		}
	}
	return rc;
}

static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow) {
	int rc = fts5StorageLoadTotals(p, 0);
	if (rc == SQLITE_OK) {
		*pnRow = p->nTotalRow;
	}
	return rc;
}


static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit) {
	if (bCommit && p->bTotalsValid) {
		int rc = fts5StorageSaveTotals(p);
		p->bTotalsValid = 0;
		if (rc != SQLITE_OK) return rc;
	}
	return sqlite3Fts5IndexSync(p->pIndex, bCommit);
}

static int sqlite3Fts5StorageRollback(Fts5Storage *p) {
	p->bTotalsValid = 0;
	return sqlite3Fts5IndexRollback(p->pIndex);
}

static int sqlite3Fts5StorageConfigValue(
	Fts5Storage *p,
	const char *z,
	sqlite3_value *pVal,
	int iVal
) {
	sqlite3_stmt *pReplace = 0;
	int rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_CONFIG, &pReplace, 0);
	if (rc == SQLITE_OK) {
		sqlite3_bind_text(pReplace, 1, z, -1, SQLITE_STATIC);
		if (pVal) {
			sqlite3_bind_value(pReplace, 2, pVal);
		}
		else {
			sqlite3_bind_int(pReplace, 2, iVal);
		}
		sqlite3_step(pReplace);
		rc = sqlite3_reset(pReplace);
	}
	if (rc == SQLITE_OK && pVal) {
		int iNew = p->pConfig->iCookie + 1;
		rc = sqlite3Fts5IndexSetCookie(p->pIndex, iNew);
		if (rc == SQLITE_OK) {
			p->pConfig->iCookie = iNew;
		}
	}
	return rc;
}









static unsigned char aAsciiTokenChar[128] = {
	0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   
	0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   
	0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   
	1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 0, 0, 0, 0, 0, 0,   
	0, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
	1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 0, 0, 0, 0, 0,   
	0, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   
	1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 0, 0, 0, 0, 0,   
};

typedef struct AsciiTokenizer AsciiTokenizer;
struct AsciiTokenizer {
	unsigned char aTokenChar[128];
};

static void fts5AsciiAddExceptions(
	AsciiTokenizer *p,
	const char *zArg,
	int bTokenChars
) {
	int i;
	for (i = 0; zArg[i]; i++) {
		if ((zArg[i] & 0x80) == 0) {
			p->aTokenChar[(int)zArg[i]] = (unsigned char)bTokenChars;
		}
	}
}


static void fts5AsciiDelete(Fts5Tokenizer *p) {
	sqlite3_free(p);
}


static int fts5AsciiCreate(
	void *pUnused,
	const char **azArg, int nArg,
	Fts5Tokenizer **ppOut
) {
	int rc = SQLITE_OK;
	AsciiTokenizer *p = 0;
	UNUSED_PARAM(pUnused);
	if (nArg % 2) {
		rc = SQLITE_ERROR;
	}
	else {
		p = sqlite3_malloc(sizeof(AsciiTokenizer));
		if (p == 0) {
			rc = SQLITE_NOMEM;
		}
		else {
			int i;
			memset(p, 0, sizeof(AsciiTokenizer));
			memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));
			for (i = 0; rc == SQLITE_OK && i<nArg; i += 2) {
				const char *zArg = azArg[i + 1];
				if (0 == sqlite3_stricmp(azArg[i], "tokenchars")) {
					fts5AsciiAddExceptions(p, zArg, 1);
				}
				else
					if (0 == sqlite3_stricmp(azArg[i], "separators")) {
						fts5AsciiAddExceptions(p, zArg, 0);
					}
					else {
						rc = SQLITE_ERROR;
					}
			}
			if (rc != SQLITE_OK) {
				fts5AsciiDelete((Fts5Tokenizer*)p);
				p = 0;
			}
		}
	}

	*ppOut = (Fts5Tokenizer*)p;
	return rc;
}


static void asciiFold(char *aOut, const char *aIn, int nByte) {
	int i;
	for (i = 0; i<nByte; i++) {
		char c = aIn[i];
		if (c >= 'A' && c <= 'Z') c += 32;
		aOut[i] = c;
	}
}


static int fts5AsciiTokenize(
	Fts5Tokenizer *pTokenizer,
	void *pCtx,
	int iUnused,
	const char *pText, int nText,
	int(*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
) {
	AsciiTokenizer *p = (AsciiTokenizer*)pTokenizer;
	int rc = SQLITE_OK;
	int ie;
	int is = 0;

	char aFold[64];
	int nFold = sizeof(aFold);
	char *pFold = aFold;
	unsigned char *a = p->aTokenChar;

	UNUSED_PARAM(iUnused);

	while (is<nText && rc == SQLITE_OK) {
		int nByte;

		
		while (is<nText && ((pText[is] & 0x80) == 0 && a[(int)pText[is]] == 0)) {
			is++;
		}
		if (is == nText) break;

		
		ie = is + 1;
		while (ie<nText && ((pText[ie] & 0x80) || a[(int)pText[ie]])) {
			ie++;
		}

		
		nByte = ie - is;
		if (nByte>nFold) {
			if (pFold != aFold) sqlite3_free(pFold);
			pFold = sqlite3_malloc(nByte * 2);
			if (pFold == 0) {
				rc = SQLITE_NOMEM;
				break;
			}
			nFold = nByte * 2;
		}
		asciiFold(pFold, &pText[is], nByte);

		
		rc = xToken(pCtx, 0, pFold, nByte, is, ie);
		is = ie + 1;
	}

	if (pFold != aFold) sqlite3_free(pFold);
	if (rc == SQLITE_DONE) rc = SQLITE_OK;
	return rc;
}





#ifndef SQLITE_AMALGAMATION

static const unsigned char sqlite3Utf8Trans1[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};

#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }


#define WRITE_UTF8(zOut, c) {                          \
  if( c<0x00080 ){                                     \
    *zOut++ = (unsigned char)(c&0xFF);                 \
  }                                                    \
  else if( c<0x00800 ){                                \
    *zOut++ = 0xC0 + (unsigned char)((c>>6)&0x1F);     \
    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
  }                                                    \
  else if( c<0x10000 ){                                \
    *zOut++ = 0xE0 + (unsigned char)((c>>12)&0x0F);    \
    *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   \
    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
  }else{                                               \
    *zOut++ = 0xF0 + (unsigned char)((c>>18) & 0x07);  \
    *zOut++ = 0x80 + (unsigned char)((c>>12) & 0x3F);  \
    *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   \
    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
  }                                                    \
}

#endif 

typedef struct Unicode61Tokenizer Unicode61Tokenizer;
struct Unicode61Tokenizer {
	unsigned char aTokenChar[128];  
	char *aFold;                    
	int nFold;                      
	int bRemoveDiacritic;           
	int nException;
	int *aiException;
};

static int fts5UnicodeAddExceptions(
	Unicode61Tokenizer *p,          
	const char *z,                  
	int bTokenChars                 
) {
	int rc = SQLITE_OK;
	int n = (int)strlen(z);
	int *aNew;

	if (n>0) {
		aNew = (int*)sqlite3_realloc(p->aiException, (n + p->nException) * sizeof(int));
		if (aNew) {
			int nNew = p->nException;
			const unsigned char *zCsr = (const unsigned char*)z;
			const unsigned char *zTerm = (const unsigned char*)&z[n];
			while (zCsr<zTerm) {
				int iCode;
				int bToken;
				READ_UTF8(zCsr, zTerm, iCode);
				if (iCode<128) {
					p->aTokenChar[iCode] = (unsigned char)bTokenChars;
				}
				else {
					bToken = sqlite3Fts5UnicodeIsalnum(iCode);
					assert((bToken == 0 || bToken == 1));
					assert((bTokenChars == 0 || bTokenChars == 1));
					if (bToken != bTokenChars && sqlite3Fts5UnicodeIsdiacritic(iCode) == 0) {
						int i;
						for (i = 0; i<nNew; i++) {
							if (aNew[i]>iCode) break;
						}
						memmove(&aNew[i + 1], &aNew[i], (nNew - i) * sizeof(int));
						aNew[i] = iCode;
						nNew++;
					}
				}
			}
			p->aiException = aNew;
			p->nException = nNew;
		}
		else {
			rc = SQLITE_NOMEM;
		}
	}

	return rc;
}


static int fts5UnicodeIsException(Unicode61Tokenizer *p, int iCode) {
	if (p->nException>0) {
		int *a = p->aiException;
		int iLo = 0;
		int iHi = p->nException - 1;

		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			if (iCode == a[iTest]) {
				return 1;
			}
			else if (iCode>a[iTest]) {
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}
	}

	return 0;
}


static void fts5UnicodeDelete(Fts5Tokenizer *pTok) {
	if (pTok) {
		Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTok;
		sqlite3_free(p->aiException);
		sqlite3_free(p->aFold);
		sqlite3_free(p);
	}
	return;
}


static int fts5UnicodeCreate(
	void *pUnused,
	const char **azArg, int nArg,
	Fts5Tokenizer **ppOut
) {
	int rc = SQLITE_OK;             
	Unicode61Tokenizer *p = 0;      

	UNUSED_PARAM(pUnused);

	if (nArg % 2) {
		rc = SQLITE_ERROR;
	}
	else {
		p = (Unicode61Tokenizer*)sqlite3_malloc(sizeof(Unicode61Tokenizer));
		if (p) {
			int i;
			memset(p, 0, sizeof(Unicode61Tokenizer));
			memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));
			p->bRemoveDiacritic = 1;
			p->nFold = 64;
			p->aFold = sqlite3_malloc(p->nFold * sizeof(char));
			if (p->aFold == 0) {
				rc = SQLITE_NOMEM;
			}
			for (i = 0; rc == SQLITE_OK && i<nArg; i += 2) {
				const char *zArg = azArg[i + 1];
				if (0 == sqlite3_stricmp(azArg[i], "remove_diacritics")) {
					if ((zArg[0] != '0' && zArg[0] != '1') || zArg[1]) {
						rc = SQLITE_ERROR;
					}
					p->bRemoveDiacritic = (zArg[0] == '1');
				}
				else
					if (0 == sqlite3_stricmp(azArg[i], "tokenchars")) {
						rc = fts5UnicodeAddExceptions(p, zArg, 1);
					}
					else
						if (0 == sqlite3_stricmp(azArg[i], "separators")) {
							rc = fts5UnicodeAddExceptions(p, zArg, 0);
						}
						else {
							rc = SQLITE_ERROR;
						}
			}
		}
		else {
			rc = SQLITE_NOMEM;
		}
		if (rc != SQLITE_OK) {
			fts5UnicodeDelete((Fts5Tokenizer*)p);
			p = 0;
		}
		*ppOut = (Fts5Tokenizer*)p;
	}
	return rc;
}


static int fts5UnicodeIsAlnum(Unicode61Tokenizer *p, int iCode) {
	assert((sqlite3Fts5UnicodeIsalnum(iCode) & 0xFFFFFFFE) == 0);
	return sqlite3Fts5UnicodeIsalnum(iCode) ^ fts5UnicodeIsException(p, iCode);
}

static int fts5UnicodeTokenize(
	Fts5Tokenizer *pTokenizer,
	void *pCtx,
	int iUnused,
	const char *pText, int nText,
	int(*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
) {
	Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTokenizer;
	int rc = SQLITE_OK;
	unsigned char *a = p->aTokenChar;

	unsigned char *zTerm = (unsigned char*)&pText[nText];
	unsigned char *zCsr = (unsigned char *)pText;

	
	char *aFold = p->aFold;
	int nFold = p->nFold;
	const char *pEnd = &aFold[nFold - 6];

	UNUSED_PARAM(iUnused);

	
	while (rc == SQLITE_OK) {
		int iCode;                    
		char *zOut = aFold;
		int is;
		int ie;

		
		while (1) {
			if (zCsr >= zTerm) goto tokenize_done;
			if (*zCsr & 0x80) {
				
				is = zCsr - (unsigned char*)pText;
				READ_UTF8(zCsr, zTerm, iCode);
				if (fts5UnicodeIsAlnum(p, iCode)) {
					goto non_ascii_tokenchar;
				}
			}
			else {
				if (a[*zCsr]) {
					is = zCsr - (unsigned char*)pText;
					goto ascii_tokenchar;
				}
				zCsr++;
			}
		}

		
		while (zCsr<zTerm) {

			
			if (zOut>pEnd) {
				aFold = sqlite3_malloc(nFold * 2);
				if (aFold == 0) {
					rc = SQLITE_NOMEM;
					goto tokenize_done;
				}
				zOut = &aFold[zOut - p->aFold];
				memcpy(aFold, p->aFold, nFold);
				sqlite3_free(p->aFold);
				p->aFold = aFold;
				p->nFold = nFold = nFold * 2;
				pEnd = &aFold[nFold - 6];
			}

			if (*zCsr & 0x80) {
				
				READ_UTF8(zCsr, zTerm, iCode);
				if (fts5UnicodeIsAlnum(p, iCode) || sqlite3Fts5UnicodeIsdiacritic(iCode)) {
				non_ascii_tokenchar:
					iCode = sqlite3Fts5UnicodeFold(iCode, p->bRemoveDiacritic);
					if (iCode) WRITE_UTF8(zOut, iCode);
				}
				else {
					break;
				}
			}
			else if (a[*zCsr] == 0) {
				
				break;
			}
			else {
			ascii_tokenchar:
				if (*zCsr >= 'A' && *zCsr <= 'Z') {
					*zOut++ = *zCsr + 32;
				}
				else {
					*zOut++ = *zCsr;
				}
				zCsr++;
			}
			ie = zCsr - (unsigned char*)pText;
		}

		
		rc = xToken(pCtx, 0, aFold, zOut - aFold, is, ie);
	}

tokenize_done:
	if (rc == SQLITE_DONE) rc = SQLITE_OK;
	return rc;
}




#define FTS5_PORTER_MAX_TOKEN 64

typedef struct PorterTokenizer PorterTokenizer;
struct PorterTokenizer {
	fts5_tokenizer tokenizer;       
	Fts5Tokenizer *pTokenizer;      
	char aBuf[FTS5_PORTER_MAX_TOKEN + 64];
};


static void fts5PorterDelete(Fts5Tokenizer *pTok) {
	if (pTok) {
		PorterTokenizer *p = (PorterTokenizer*)pTok;
		if (p->pTokenizer) {
			p->tokenizer.xDelete(p->pTokenizer);
		}
		sqlite3_free(p);
	}
}


static int fts5PorterCreate(
	void *pCtx,
	const char **azArg, int nArg,
	Fts5Tokenizer **ppOut
) {
	fts5_api *pApi = (fts5_api*)pCtx;
	int rc = SQLITE_OK;
	PorterTokenizer *pRet;
	void *pUserdata = 0;
	const char *zBase = "unicode61";

	if (nArg>0) {
		zBase = azArg[0];
	}

	pRet = (PorterTokenizer*)sqlite3_malloc(sizeof(PorterTokenizer));
	if (pRet) {
		memset(pRet, 0, sizeof(PorterTokenizer));
		rc = pApi->xFindTokenizer(pApi, zBase, &pUserdata, &pRet->tokenizer);
	}
	else {
		rc = SQLITE_NOMEM;
	}
	if (rc == SQLITE_OK) {
		int nArg2 = (nArg>0 ? nArg - 1 : 0);
		const char **azArg2 = (nArg2 ? &azArg[1] : 0);
		rc = pRet->tokenizer.xCreate(pUserdata, azArg2, nArg2, &pRet->pTokenizer);
	}

	if (rc != SQLITE_OK) {
		fts5PorterDelete((Fts5Tokenizer*)pRet);
		pRet = 0;
	}
	*ppOut = (Fts5Tokenizer*)pRet;
	return rc;
}

typedef struct PorterContext PorterContext;
struct PorterContext {
	void *pCtx;
	int(*xToken)(void*, int, const char*, int, int, int);
	char *aBuf;
};

typedef struct PorterRule PorterRule;
struct PorterRule {
	const char *zSuffix;
	int nSuffix;
	int(*xCond)(char *zStem, int nStem);
	const char *zOutput;
	int nOutput;
};

#if 0
static int fts5PorterApply(char *aBuf, int *pnBuf, PorterRule *aRule) {
	int ret = -1;
	int nBuf = *pnBuf;
	PorterRule *p;

	for (p = aRule; p->zSuffix; p++) {
		assert(strlen(p->zSuffix) == p->nSuffix);
		assert(strlen(p->zOutput) == p->nOutput);
		if (nBuf<p->nSuffix) continue;
		if (0 == memcmp(&aBuf[nBuf - p->nSuffix], p->zSuffix, p->nSuffix)) break;
	}

	if (p->zSuffix) {
		int nStem = nBuf - p->nSuffix;
		if (p->xCond == 0 || p->xCond(aBuf, nStem)) {
			memcpy(&aBuf[nStem], p->zOutput, p->nOutput);
			*pnBuf = nStem + p->nOutput;
			ret = p - aRule;
		}
	}

	return ret;
}
#endif

static int fts5PorterIsVowel(char c, int bYIsVowel) {
	return (
		c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (bYIsVowel && c == 'y')
		);
}

static int fts5PorterGobbleVC(char *zStem, int nStem, int bPrevCons) {
	int i;
	int bCons = bPrevCons;

	
	for (i = 0; i<nStem; i++) {
		if (0 == (bCons = !fts5PorterIsVowel(zStem[i], bCons))) break;
	}

	
	for (i++; i<nStem; i++) {
		if ((bCons = !fts5PorterIsVowel(zStem[i], bCons))) return i + 1;
	}
	return 0;
}


static int fts5Porter_MGt0(char *zStem, int nStem) {
	return !!fts5PorterGobbleVC(zStem, nStem, 0);
}


static int fts5Porter_MGt1(char *zStem, int nStem) {
	int n;
	n = fts5PorterGobbleVC(zStem, nStem, 0);
	if (n && fts5PorterGobbleVC(&zStem[n], nStem - n, 1)) {
		return 1;
	}
	return 0;
}


static int fts5Porter_MEq1(char *zStem, int nStem) {
	int n;
	n = fts5PorterGobbleVC(zStem, nStem, 0);
	if (n && 0 == fts5PorterGobbleVC(&zStem[n], nStem - n, 1)) {
		return 1;
	}
	return 0;
}


static int fts5Porter_Ostar(char *zStem, int nStem) {
	if (zStem[nStem - 1] == 'w' || zStem[nStem - 1] == 'x' || zStem[nStem - 1] == 'y') {
		return 0;
	}
	else {
		int i;
		int mask = 0;
		int bCons = 0;
		for (i = 0; i<nStem; i++) {
			bCons = !fts5PorterIsVowel(zStem[i], bCons);
			assert(bCons == 0 || bCons == 1);
			mask = (mask << 1) + bCons;
		}
		return ((mask & 0x0007) == 0x0005);
	}
}


static int fts5Porter_MGt1_and_S_or_T(char *zStem, int nStem) {
	assert(nStem>0);
	return (zStem[nStem - 1] == 's' || zStem[nStem - 1] == 't')
		&& fts5Porter_MGt1(zStem, nStem);
}


static int fts5Porter_Vowel(char *zStem, int nStem) {
	int i;
	for (i = 0; i<nStem; i++) {
		if (fts5PorterIsVowel(zStem[i], i>0)) {
			return 1;
		}
	}
	return 0;
}




static int fts5PorterStep4(char *aBuf, int *pnBuf) {
	int ret = 0;
	int nBuf = *pnBuf;
	switch (aBuf[nBuf - 2]) {

	case 'a':
		if (nBuf>2 && 0 == memcmp("al", &aBuf[nBuf - 2], 2)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 2)) {
				*pnBuf = nBuf - 2;
			}
		}
		break;

	case 'c':
		if (nBuf>4 && 0 == memcmp("ance", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		else if (nBuf>4 && 0 == memcmp("ence", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		break;

	case 'e':
		if (nBuf>2 && 0 == memcmp("er", &aBuf[nBuf - 2], 2)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 2)) {
				*pnBuf = nBuf - 2;
			}
		}
		break;

	case 'i':
		if (nBuf>2 && 0 == memcmp("ic", &aBuf[nBuf - 2], 2)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 2)) {
				*pnBuf = nBuf - 2;
			}
		}
		break;

	case 'l':
		if (nBuf>4 && 0 == memcmp("able", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		else if (nBuf>4 && 0 == memcmp("ible", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		break;

	case 'n':
		if (nBuf>3 && 0 == memcmp("ant", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		else if (nBuf>5 && 0 == memcmp("ement", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 5)) {
				*pnBuf = nBuf - 5;
			}
		}
		else if (nBuf>4 && 0 == memcmp("ment", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		else if (nBuf>3 && 0 == memcmp("ent", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 'o':
		if (nBuf>3 && 0 == memcmp("ion", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1_and_S_or_T(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		else if (nBuf>2 && 0 == memcmp("ou", &aBuf[nBuf - 2], 2)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 2)) {
				*pnBuf = nBuf - 2;
			}
		}
		break;

	case 's':
		if (nBuf>3 && 0 == memcmp("ism", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 't':
		if (nBuf>3 && 0 == memcmp("ate", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		else if (nBuf>3 && 0 == memcmp("iti", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 'u':
		if (nBuf>3 && 0 == memcmp("ous", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 'v':
		if (nBuf>3 && 0 == memcmp("ive", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 'z':
		if (nBuf>3 && 0 == memcmp("ize", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt1(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	}
	return ret;
}


static int fts5PorterStep1B2(char *aBuf, int *pnBuf) {
	int ret = 0;
	int nBuf = *pnBuf;
	switch (aBuf[nBuf - 2]) {

	case 'a':
		if (nBuf>2 && 0 == memcmp("at", &aBuf[nBuf - 2], 2)) {
			memcpy(&aBuf[nBuf - 2], "ate", 3);
			*pnBuf = nBuf - 2 + 3;
			ret = 1;
		}
		break;

	case 'b':
		if (nBuf>2 && 0 == memcmp("bl", &aBuf[nBuf - 2], 2)) {
			memcpy(&aBuf[nBuf - 2], "ble", 3);
			*pnBuf = nBuf - 2 + 3;
			ret = 1;
		}
		break;

	case 'i':
		if (nBuf>2 && 0 == memcmp("iz", &aBuf[nBuf - 2], 2)) {
			memcpy(&aBuf[nBuf - 2], "ize", 3);
			*pnBuf = nBuf - 2 + 3;
			ret = 1;
		}
		break;

	}
	return ret;
}


static int fts5PorterStep2(char *aBuf, int *pnBuf) {
	int ret = 0;
	int nBuf = *pnBuf;
	switch (aBuf[nBuf - 2]) {

	case 'a':
		if (nBuf>7 && 0 == memcmp("ational", &aBuf[nBuf - 7], 7)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 7)) {
				memcpy(&aBuf[nBuf - 7], "ate", 3);
				*pnBuf = nBuf - 7 + 3;
			}
		}
		else if (nBuf>6 && 0 == memcmp("tional", &aBuf[nBuf - 6], 6)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 6)) {
				memcpy(&aBuf[nBuf - 6], "tion", 4);
				*pnBuf = nBuf - 6 + 4;
			}
		}
		break;

	case 'c':
		if (nBuf>4 && 0 == memcmp("enci", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "ence", 4);
				*pnBuf = nBuf - 4 + 4;
			}
		}
		else if (nBuf>4 && 0 == memcmp("anci", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "ance", 4);
				*pnBuf = nBuf - 4 + 4;
			}
		}
		break;

	case 'e':
		if (nBuf>4 && 0 == memcmp("izer", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "ize", 3);
				*pnBuf = nBuf - 4 + 3;
			}
		}
		break;

	case 'g':
		if (nBuf>4 && 0 == memcmp("logi", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "log", 3);
				*pnBuf = nBuf - 4 + 3;
			}
		}
		break;

	case 'l':
		if (nBuf>3 && 0 == memcmp("bli", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 3)) {
				memcpy(&aBuf[nBuf - 3], "ble", 3);
				*pnBuf = nBuf - 3 + 3;
			}
		}
		else if (nBuf>4 && 0 == memcmp("alli", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "al", 2);
				*pnBuf = nBuf - 4 + 2;
			}
		}
		else if (nBuf>5 && 0 == memcmp("entli", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ent", 3);
				*pnBuf = nBuf - 5 + 3;
			}
		}
		else if (nBuf>3 && 0 == memcmp("eli", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 3)) {
				memcpy(&aBuf[nBuf - 3], "e", 1);
				*pnBuf = nBuf - 3 + 1;
			}
		}
		else if (nBuf>5 && 0 == memcmp("ousli", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ous", 3);
				*pnBuf = nBuf - 5 + 3;
			}
		}
		break;

	case 'o':
		if (nBuf>7 && 0 == memcmp("ization", &aBuf[nBuf - 7], 7)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 7)) {
				memcpy(&aBuf[nBuf - 7], "ize", 3);
				*pnBuf = nBuf - 7 + 3;
			}
		}
		else if (nBuf>5 && 0 == memcmp("ation", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ate", 3);
				*pnBuf = nBuf - 5 + 3;
			}
		}
		else if (nBuf>4 && 0 == memcmp("ator", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "ate", 3);
				*pnBuf = nBuf - 4 + 3;
			}
		}
		break;

	case 's':
		if (nBuf>5 && 0 == memcmp("alism", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "al", 2);
				*pnBuf = nBuf - 5 + 2;
			}
		}
		else if (nBuf>7 && 0 == memcmp("iveness", &aBuf[nBuf - 7], 7)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 7)) {
				memcpy(&aBuf[nBuf - 7], "ive", 3);
				*pnBuf = nBuf - 7 + 3;
			}
		}
		else if (nBuf>7 && 0 == memcmp("fulness", &aBuf[nBuf - 7], 7)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 7)) {
				memcpy(&aBuf[nBuf - 7], "ful", 3);
				*pnBuf = nBuf - 7 + 3;
			}
		}
		else if (nBuf>7 && 0 == memcmp("ousness", &aBuf[nBuf - 7], 7)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 7)) {
				memcpy(&aBuf[nBuf - 7], "ous", 3);
				*pnBuf = nBuf - 7 + 3;
			}
		}
		break;

	case 't':
		if (nBuf>5 && 0 == memcmp("aliti", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "al", 2);
				*pnBuf = nBuf - 5 + 2;
			}
		}
		else if (nBuf>5 && 0 == memcmp("iviti", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ive", 3);
				*pnBuf = nBuf - 5 + 3;
			}
		}
		else if (nBuf>6 && 0 == memcmp("biliti", &aBuf[nBuf - 6], 6)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 6)) {
				memcpy(&aBuf[nBuf - 6], "ble", 3);
				*pnBuf = nBuf - 6 + 3;
			}
		}
		break;

	}
	return ret;
}


static int fts5PorterStep3(char *aBuf, int *pnBuf) {
	int ret = 0;
	int nBuf = *pnBuf;
	switch (aBuf[nBuf - 2]) {

	case 'a':
		if (nBuf>4 && 0 == memcmp("ical", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				memcpy(&aBuf[nBuf - 4], "ic", 2);
				*pnBuf = nBuf - 4 + 2;
			}
		}
		break;

	case 's':
		if (nBuf>4 && 0 == memcmp("ness", &aBuf[nBuf - 4], 4)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 4)) {
				*pnBuf = nBuf - 4;
			}
		}
		break;

	case 't':
		if (nBuf>5 && 0 == memcmp("icate", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ic", 2);
				*pnBuf = nBuf - 5 + 2;
			}
		}
		else if (nBuf>5 && 0 == memcmp("iciti", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "ic", 2);
				*pnBuf = nBuf - 5 + 2;
			}
		}
		break;

	case 'u':
		if (nBuf>3 && 0 == memcmp("ful", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
			}
		}
		break;

	case 'v':
		if (nBuf>5 && 0 == memcmp("ative", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				*pnBuf = nBuf - 5;
			}
		}
		break;

	case 'z':
		if (nBuf>5 && 0 == memcmp("alize", &aBuf[nBuf - 5], 5)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 5)) {
				memcpy(&aBuf[nBuf - 5], "al", 2);
				*pnBuf = nBuf - 5 + 2;
			}
		}
		break;

	}
	return ret;
}


static int fts5PorterStep1B(char *aBuf, int *pnBuf) {
	int ret = 0;
	int nBuf = *pnBuf;
	switch (aBuf[nBuf - 2]) {

	case 'e':
		if (nBuf>3 && 0 == memcmp("eed", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_MGt0(aBuf, nBuf - 3)) {
				memcpy(&aBuf[nBuf - 3], "ee", 2);
				*pnBuf = nBuf - 3 + 2;
			}
		}
		else if (nBuf>2 && 0 == memcmp("ed", &aBuf[nBuf - 2], 2)) {
			if (fts5Porter_Vowel(aBuf, nBuf - 2)) {
				*pnBuf = nBuf - 2;
				ret = 1;
			}
		}
		break;

	case 'n':
		if (nBuf>3 && 0 == memcmp("ing", &aBuf[nBuf - 3], 3)) {
			if (fts5Porter_Vowel(aBuf, nBuf - 3)) {
				*pnBuf = nBuf - 3;
				ret = 1;
			}
		}
		break;

	}
	return ret;
}



static void fts5PorterStep1A(char *aBuf, int *pnBuf) {
	int nBuf = *pnBuf;
	if (aBuf[nBuf - 1] == 's') {
		if (aBuf[nBuf - 2] == 'e') {
			if ((nBuf>4 && aBuf[nBuf - 4] == 's' && aBuf[nBuf - 3] == 's')
				|| (nBuf>3 && aBuf[nBuf - 3] == 'i')
				) {
				*pnBuf = nBuf - 2;
			}
			else {
				*pnBuf = nBuf - 1;
			}
		}
		else if (aBuf[nBuf - 2] != 's') {
			*pnBuf = nBuf - 1;
		}
	}
}

static int fts5PorterCb(
	void *pCtx,
	int tflags,
	const char *pToken,
	int nToken,
	int iStart,
	int iEnd
) {
	PorterContext *p = (PorterContext*)pCtx;

	char *aBuf;
	int nBuf;

	if (nToken>FTS5_PORTER_MAX_TOKEN || nToken<3) goto pass_through;
	aBuf = p->aBuf;
	nBuf = nToken;
	memcpy(aBuf, pToken, nBuf);

	
	fts5PorterStep1A(aBuf, &nBuf);
	if (fts5PorterStep1B(aBuf, &nBuf)) {
		if (fts5PorterStep1B2(aBuf, &nBuf) == 0) {
			char c = aBuf[nBuf - 1];
			if (fts5PorterIsVowel(c, 0) == 0
				&& c != 'l' && c != 's' && c != 'z' && c == aBuf[nBuf - 2]
				) {
				nBuf--;
			}
			else if (fts5Porter_MEq1(aBuf, nBuf) && fts5Porter_Ostar(aBuf, nBuf)) {
				aBuf[nBuf++] = 'e';
			}
		}
	}

	
	if (aBuf[nBuf - 1] == 'y' && fts5Porter_Vowel(aBuf, nBuf - 1)) {
		aBuf[nBuf - 1] = 'i';
	}

	
	fts5PorterStep2(aBuf, &nBuf);
	fts5PorterStep3(aBuf, &nBuf);
	fts5PorterStep4(aBuf, &nBuf);

	
	assert(nBuf>0);
	if (aBuf[nBuf - 1] == 'e') {
		if (fts5Porter_MGt1(aBuf, nBuf - 1)
			|| (fts5Porter_MEq1(aBuf, nBuf - 1) && !fts5Porter_Ostar(aBuf, nBuf - 1))
			) {
			nBuf--;
		}
	}

	
	if (nBuf>1 && aBuf[nBuf - 1] == 'l'
		&& aBuf[nBuf - 2] == 'l' && fts5Porter_MGt1(aBuf, nBuf - 1)
		) {
		nBuf--;
	}

	return p->xToken(p->pCtx, tflags, aBuf, nBuf, iStart, iEnd);

pass_through:
	return p->xToken(p->pCtx, tflags, pToken, nToken, iStart, iEnd);
}


static int fts5PorterTokenize(
	Fts5Tokenizer *pTokenizer,
	void *pCtx,
	int flags,
	const char *pText, int nText,
	int(*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
) {
	PorterTokenizer *p = (PorterTokenizer*)pTokenizer;
	PorterContext sCtx;
	sCtx.xToken = xToken;
	sCtx.pCtx = pCtx;
	sCtx.aBuf = p->aBuf;
	return p->tokenizer.xTokenize(
		p->pTokenizer, (void*)&sCtx, flags, pText, nText, fts5PorterCb
	);
}


static int sqlite3Fts5TokenizerInit(fts5_api *pApi) {
	struct BuiltinTokenizer {
		const char *zName;
		fts5_tokenizer x;
	} aBuiltin[] = {
		{ "unicode61",{ fts5UnicodeCreate, fts5UnicodeDelete, fts5UnicodeTokenize } },
		{ "ascii",{ fts5AsciiCreate, fts5AsciiDelete, fts5AsciiTokenize } },
		{ "porter",{ fts5PorterCreate, fts5PorterDelete, fts5PorterTokenize } },
	};

	int rc = SQLITE_OK;             
	int i;                          

	for (i = 0; rc == SQLITE_OK && i<ArraySize(aBuiltin); i++) {
		rc = pApi->xCreateTokenizer(pApi,
			aBuiltin[i].zName,
			(void*)pApi,
			&aBuiltin[i].x,
			0
		);
	}

	return rc;
}











static int sqlite3Fts5UnicodeIsalnum(int c) {
	
	static const unsigned int aEntry[] = {
		0x00000030, 0x0000E807, 0x00016C06, 0x0001EC2F, 0x0002AC07,
		0x0002D001, 0x0002D803, 0x0002EC01, 0x0002FC01, 0x00035C01,
		0x0003DC01, 0x000B0804, 0x000B480E, 0x000B9407, 0x000BB401,
		0x000BBC81, 0x000DD401, 0x000DF801, 0x000E1002, 0x000E1C01,
		0x000FD801, 0x00120808, 0x00156806, 0x00162402, 0x00163C01,
		0x00164437, 0x0017CC02, 0x00180005, 0x00181816, 0x00187802,
		0x00192C15, 0x0019A804, 0x0019C001, 0x001B5001, 0x001B580F,
		0x001B9C07, 0x001BF402, 0x001C000E, 0x001C3C01, 0x001C4401,
		0x001CC01B, 0x001E980B, 0x001FAC09, 0x001FD804, 0x00205804,
		0x00206C09, 0x00209403, 0x0020A405, 0x0020C00F, 0x00216403,
		0x00217801, 0x0023901B, 0x00240004, 0x0024E803, 0x0024F812,
		0x00254407, 0x00258804, 0x0025C001, 0x00260403, 0x0026F001,
		0x0026F807, 0x00271C02, 0x00272C03, 0x00275C01, 0x00278802,
		0x0027C802, 0x0027E802, 0x00280403, 0x0028F001, 0x0028F805,
		0x00291C02, 0x00292C03, 0x00294401, 0x0029C002, 0x0029D401,
		0x002A0403, 0x002AF001, 0x002AF808, 0x002B1C03, 0x002B2C03,
		0x002B8802, 0x002BC002, 0x002C0403, 0x002CF001, 0x002CF807,
		0x002D1C02, 0x002D2C03, 0x002D5802, 0x002D8802, 0x002DC001,
		0x002E0801, 0x002EF805, 0x002F1803, 0x002F2804, 0x002F5C01,
		0x002FCC08, 0x00300403, 0x0030F807, 0x00311803, 0x00312804,
		0x00315402, 0x00318802, 0x0031FC01, 0x00320802, 0x0032F001,
		0x0032F807, 0x00331803, 0x00332804, 0x00335402, 0x00338802,
		0x00340802, 0x0034F807, 0x00351803, 0x00352804, 0x00355C01,
		0x00358802, 0x0035E401, 0x00360802, 0x00372801, 0x00373C06,
		0x00375801, 0x00376008, 0x0037C803, 0x0038C401, 0x0038D007,
		0x0038FC01, 0x00391C09, 0x00396802, 0x003AC401, 0x003AD006,
		0x003AEC02, 0x003B2006, 0x003C041F, 0x003CD00C, 0x003DC417,
		0x003E340B, 0x003E6424, 0x003EF80F, 0x003F380D, 0x0040AC14,
		0x00412806, 0x00415804, 0x00417803, 0x00418803, 0x00419C07,
		0x0041C404, 0x0042080C, 0x00423C01, 0x00426806, 0x0043EC01,
		0x004D740C, 0x004E400A, 0x00500001, 0x0059B402, 0x005A0001,
		0x005A6C02, 0x005BAC03, 0x005C4803, 0x005CC805, 0x005D4802,
		0x005DC802, 0x005ED023, 0x005F6004, 0x005F7401, 0x0060000F,
		0x0062A401, 0x0064800C, 0x0064C00C, 0x00650001, 0x00651002,
		0x0066C011, 0x00672002, 0x00677822, 0x00685C05, 0x00687802,
		0x0069540A, 0x0069801D, 0x0069FC01, 0x006A8007, 0x006AA006,
		0x006C0005, 0x006CD011, 0x006D6823, 0x006E0003, 0x006E840D,
		0x006F980E, 0x006FF004, 0x00709014, 0x0070EC05, 0x0071F802,
		0x00730008, 0x00734019, 0x0073B401, 0x0073C803, 0x00770027,
		0x0077F004, 0x007EF401, 0x007EFC03, 0x007F3403, 0x007F7403,
		0x007FB403, 0x007FF402, 0x00800065, 0x0081A806, 0x0081E805,
		0x00822805, 0x0082801A, 0x00834021, 0x00840002, 0x00840C04,
		0x00842002, 0x00845001, 0x00845803, 0x00847806, 0x00849401,
		0x00849C01, 0x0084A401, 0x0084B801, 0x0084E802, 0x00850005,
		0x00852804, 0x00853C01, 0x00864264, 0x00900027, 0x0091000B,
		0x0092704E, 0x00940200, 0x009C0475, 0x009E53B9, 0x00AD400A,
		0x00B39406, 0x00B3BC03, 0x00B3E404, 0x00B3F802, 0x00B5C001,
		0x00B5FC01, 0x00B7804F, 0x00B8C00C, 0x00BA001A, 0x00BA6C59,
		0x00BC00D6, 0x00BFC00C, 0x00C00005, 0x00C02019, 0x00C0A807,
		0x00C0D802, 0x00C0F403, 0x00C26404, 0x00C28001, 0x00C3EC01,
		0x00C64002, 0x00C6580A, 0x00C70024, 0x00C8001F, 0x00C8A81E,
		0x00C94001, 0x00C98020, 0x00CA2827, 0x00CB003F, 0x00CC0100,
		0x01370040, 0x02924037, 0x0293F802, 0x02983403, 0x0299BC10,
		0x029A7C01, 0x029BC008, 0x029C0017, 0x029C8002, 0x029E2402,
		0x02A00801, 0x02A01801, 0x02A02C01, 0x02A08C09, 0x02A0D804,
		0x02A1D004, 0x02A20002, 0x02A2D011, 0x02A33802, 0x02A38012,
		0x02A3E003, 0x02A4980A, 0x02A51C0D, 0x02A57C01, 0x02A60004,
		0x02A6CC1B, 0x02A77802, 0x02A8A40E, 0x02A90C01, 0x02A93002,
		0x02A97004, 0x02A9DC03, 0x02A9EC01, 0x02AAC001, 0x02AAC803,
		0x02AADC02, 0x02AAF802, 0x02AB0401, 0x02AB7802, 0x02ABAC07,
		0x02ABD402, 0x02AF8C0B, 0x03600001, 0x036DFC02, 0x036FFC02,
		0x037FFC01, 0x03EC7801, 0x03ECA401, 0x03EEC810, 0x03F4F802,
		0x03F7F002, 0x03F8001A, 0x03F88007, 0x03F8C023, 0x03F95013,
		0x03F9A004, 0x03FBFC01, 0x03FC040F, 0x03FC6807, 0x03FCEC06,
		0x03FD6C0B, 0x03FF8007, 0x03FFA007, 0x03FFE405, 0x04040003,
		0x0404DC09, 0x0405E411, 0x0406400C, 0x0407402E, 0x040E7C01,
		0x040F4001, 0x04215C01, 0x04247C01, 0x0424FC01, 0x04280403,
		0x04281402, 0x04283004, 0x0428E003, 0x0428FC01, 0x04294009,
		0x0429FC01, 0x042CE407, 0x04400003, 0x0440E016, 0x04420003,
		0x0442C012, 0x04440003, 0x04449C0E, 0x04450004, 0x04460003,
		0x0446CC0E, 0x04471404, 0x045AAC0D, 0x0491C004, 0x05BD442E,
		0x05BE3C04, 0x074000F6, 0x07440027, 0x0744A4B5, 0x07480046,
		0x074C0057, 0x075B0401, 0x075B6C01, 0x075BEC01, 0x075C5401,
		0x075CD401, 0x075D3C01, 0x075DBC01, 0x075E2401, 0x075EA401,
		0x075F0C01, 0x07BBC002, 0x07C0002C, 0x07C0C064, 0x07C2800F,
		0x07C2C40E, 0x07C3040F, 0x07C3440F, 0x07C4401F, 0x07C4C03C,
		0x07C5C02B, 0x07C7981D, 0x07C8402B, 0x07C90009, 0x07C94002,
		0x07CC0021, 0x07CCC006, 0x07CCDC46, 0x07CE0014, 0x07CE8025,
		0x07CF1805, 0x07CF8011, 0x07D0003F, 0x07D10001, 0x07D108B6,
		0x07D3E404, 0x07D4003E, 0x07D50004, 0x07D54018, 0x07D7EC46,
		0x07D9140B, 0x07DA0046, 0x07DC0074, 0x38000401, 0x38008060,
		0x380400F0,
	};
	static const unsigned int aAscii[4] = {
		0xFFFFFFFF, 0xFC00FFFF, 0xF8000001, 0xF8000001,
	};

	if ((unsigned int)c<128) {
		return ((aAscii[c >> 5] & (1 << (c & 0x001F))) == 0);
	}
	else if ((unsigned int)c<(1 << 22)) {
		unsigned int key = (((unsigned int)c) << 10) | 0x000003FF;
		int iRes = 0;
		int iHi = sizeof(aEntry) / sizeof(aEntry[0]) - 1;
		int iLo = 0;
		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			if (key >= aEntry[iTest]) {
				iRes = iTest;
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}
		assert(aEntry[0]<key);
		assert(key >= aEntry[iRes]);
		return (((unsigned int)c) >= ((aEntry[iRes] >> 10) + (aEntry[iRes] & 0x3FF)));
	}
	return 1;
}



static int fts5_remove_diacritic(int c) {
	unsigned short aDia[] = {
		0,  1797,  1848,  1859,  1891,  1928,  1940,  1995,
		2024,  2040,  2060,  2110,  2168,  2206,  2264,  2286,
		2344,  2383,  2472,  2488,  2516,  2596,  2668,  2732,
		2782,  2842,  2894,  2954,  2984,  3000,  3028,  3336,
		3456,  3696,  3712,  3728,  3744,  3896,  3912,  3928,
		3968,  4008,  4040,  4106,  4138,  4170,  4202,  4234,
		4266,  4296,  4312,  4344,  4408,  4424,  4472,  4504,
		6148,  6198,  6264,  6280,  6360,  6429,  6505,  6529,
		61448, 61468, 61534, 61592, 61642, 61688, 61704, 61726,
		61784, 61800, 61836, 61880, 61914, 61948, 61998, 62122,
		62154, 62200, 62218, 62302, 62364, 62442, 62478, 62536,
		62554, 62584, 62604, 62640, 62648, 62656, 62664, 62730,
		62924, 63050, 63082, 63274, 63390,
	};
	char aChar[] = {
		'\0', 'a',  'c',  'e',  'i',  'n',  'o',  'u',  'y',  'y',  'a',  'c',
		'd',  'e',  'e',  'g',  'h',  'i',  'j',  'k',  'l',  'n',  'o',  'r',
		's',  't',  'u',  'u',  'w',  'y',  'z',  'o',  'u',  'a',  'i',  'o',
		'u',  'g',  'k',  'o',  'j',  'g',  'n',  'a',  'e',  'i',  'o',  'r',
		'u',  's',  't',  'h',  'a',  'e',  'o',  'y',  '\0', '\0', '\0', '\0',
		'\0', '\0', '\0', '\0', 'a',  'b',  'd',  'd',  'e',  'f',  'g',  'h',
		'h',  'i',  'k',  'l',  'l',  'm',  'n',  'p',  'r',  'r',  's',  't',
		'u',  'v',  'w',  'w',  'x',  'y',  'z',  'h',  't',  'w',  'y',  'a',
		'e',  'i',  'o',  'u',  'y',
	};

	unsigned int key = (((unsigned int)c) << 3) | 0x00000007;
	int iRes = 0;
	int iHi = sizeof(aDia) / sizeof(aDia[0]) - 1;
	int iLo = 0;
	while (iHi >= iLo) {
		int iTest = (iHi + iLo) / 2;
		if (key >= aDia[iTest]) {
			iRes = iTest;
			iLo = iTest + 1;
		}
		else {
			iHi = iTest - 1;
		}
	}
	assert(key >= aDia[iRes]);
	return ((c > (aDia[iRes] >> 3) + (aDia[iRes] & 0x07)) ? c : (int)aChar[iRes]);
}



static int sqlite3Fts5UnicodeIsdiacritic(int c) {
	unsigned int mask0 = 0x08029FDF;
	unsigned int mask1 = 0x000361F8;
	if (c<768 || c>817) return 0;
	return (c < 768 + 32) ?
		(mask0 & (1 << (c - 768))) :
		(mask1 & (1 << (c - 768 - 32)));
}



static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic) {
	
	static const struct TableEntry {
		unsigned short iCode;
		unsigned char flags;
		unsigned char nRange;
	} aEntry[] = {
		{ 65, 14, 26 },{ 181, 64, 1 },{ 192, 14, 23 },
		{ 216, 14, 7 },{ 256, 1, 48 },{ 306, 1, 6 },
		{ 313, 1, 16 },{ 330, 1, 46 },{ 376, 116, 1 },
		{ 377, 1, 6 },{ 383, 104, 1 },{ 385, 50, 1 },
		{ 386, 1, 4 },{ 390, 44, 1 },{ 391, 0, 1 },
		{ 393, 42, 2 },{ 395, 0, 1 },{ 398, 32, 1 },
		{ 399, 38, 1 },{ 400, 40, 1 },{ 401, 0, 1 },
		{ 403, 42, 1 },{ 404, 46, 1 },{ 406, 52, 1 },
		{ 407, 48, 1 },{ 408, 0, 1 },{ 412, 52, 1 },
		{ 413, 54, 1 },{ 415, 56, 1 },{ 416, 1, 6 },
		{ 422, 60, 1 },{ 423, 0, 1 },{ 425, 60, 1 },
		{ 428, 0, 1 },{ 430, 60, 1 },{ 431, 0, 1 },
		{ 433, 58, 2 },{ 435, 1, 4 },{ 439, 62, 1 },
		{ 440, 0, 1 },{ 444, 0, 1 },{ 452, 2, 1 },
		{ 453, 0, 1 },{ 455, 2, 1 },{ 456, 0, 1 },
		{ 458, 2, 1 },{ 459, 1, 18 },{ 478, 1, 18 },
		{ 497, 2, 1 },{ 498, 1, 4 },{ 502, 122, 1 },
		{ 503, 134, 1 },{ 504, 1, 40 },{ 544, 110, 1 },
		{ 546, 1, 18 },{ 570, 70, 1 },{ 571, 0, 1 },
		{ 573, 108, 1 },{ 574, 68, 1 },{ 577, 0, 1 },
		{ 579, 106, 1 },{ 580, 28, 1 },{ 581, 30, 1 },
		{ 582, 1, 10 },{ 837, 36, 1 },{ 880, 1, 4 },
		{ 886, 0, 1 },{ 902, 18, 1 },{ 904, 16, 3 },
		{ 908, 26, 1 },{ 910, 24, 2 },{ 913, 14, 17 },
		{ 931, 14, 9 },{ 962, 0, 1 },{ 975, 4, 1 },
		{ 976, 140, 1 },{ 977, 142, 1 },{ 981, 146, 1 },
		{ 982, 144, 1 },{ 984, 1, 24 },{ 1008, 136, 1 },
		{ 1009, 138, 1 },{ 1012, 130, 1 },{ 1013, 128, 1 },
		{ 1015, 0, 1 },{ 1017, 152, 1 },{ 1018, 0, 1 },
		{ 1021, 110, 3 },{ 1024, 34, 16 },{ 1040, 14, 32 },
		{ 1120, 1, 34 },{ 1162, 1, 54 },{ 1216, 6, 1 },
		{ 1217, 1, 14 },{ 1232, 1, 88 },{ 1329, 22, 38 },
		{ 4256, 66, 38 },{ 4295, 66, 1 },{ 4301, 66, 1 },
		{ 7680, 1, 150 },{ 7835, 132, 1 },{ 7838, 96, 1 },
		{ 7840, 1, 96 },{ 7944, 150, 8 },{ 7960, 150, 6 },
		{ 7976, 150, 8 },{ 7992, 150, 8 },{ 8008, 150, 6 },
		{ 8025, 151, 8 },{ 8040, 150, 8 },{ 8072, 150, 8 },
		{ 8088, 150, 8 },{ 8104, 150, 8 },{ 8120, 150, 2 },
		{ 8122, 126, 2 },{ 8124, 148, 1 },{ 8126, 100, 1 },
		{ 8136, 124, 4 },{ 8140, 148, 1 },{ 8152, 150, 2 },
		{ 8154, 120, 2 },{ 8168, 150, 2 },{ 8170, 118, 2 },
		{ 8172, 152, 1 },{ 8184, 112, 2 },{ 8186, 114, 2 },
		{ 8188, 148, 1 },{ 8486, 98, 1 },{ 8490, 92, 1 },
		{ 8491, 94, 1 },{ 8498, 12, 1 },{ 8544, 8, 16 },
		{ 8579, 0, 1 },{ 9398, 10, 26 },{ 11264, 22, 47 },
		{ 11360, 0, 1 },{ 11362, 88, 1 },{ 11363, 102, 1 },
		{ 11364, 90, 1 },{ 11367, 1, 6 },{ 11373, 84, 1 },
		{ 11374, 86, 1 },{ 11375, 80, 1 },{ 11376, 82, 1 },
		{ 11378, 0, 1 },{ 11381, 0, 1 },{ 11390, 78, 2 },
		{ 11392, 1, 100 },{ 11499, 1, 4 },{ 11506, 0, 1 },
		{ 42560, 1, 46 },{ 42624, 1, 24 },{ 42786, 1, 14 },
		{ 42802, 1, 62 },{ 42873, 1, 4 },{ 42877, 76, 1 },
		{ 42878, 1, 10 },{ 42891, 0, 1 },{ 42893, 74, 1 },
		{ 42896, 1, 4 },{ 42912, 1, 10 },{ 42922, 72, 1 },
		{ 65313, 14, 26 },
	};
	static const unsigned short aiOff[] = {
		1,     2,     8,     15,    16,    26,    28,    32,
		37,    38,    40,    48,    63,    64,    69,    71,
		79,    80,    116,   202,   203,   205,   206,   207,
		209,   210,   211,   213,   214,   217,   218,   219,
		775,   7264,  10792, 10795, 23228, 23256, 30204, 54721,
		54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274,
		57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406,
		65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462,
		65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511,
		65514, 65521, 65527, 65528, 65529,
	};

	int ret = c;

	assert(sizeof(unsigned short) == 2 && sizeof(unsigned char) == 1);

	if (c<128) {
		if (c >= 'A' && c <= 'Z') ret = c + ('a' - 'A');
	}
	else if (c<65536) {
		const struct TableEntry *p;
		int iHi = sizeof(aEntry) / sizeof(aEntry[0]) - 1;
		int iLo = 0;
		int iRes = -1;

		assert(c>aEntry[0].iCode);
		while (iHi >= iLo) {
			int iTest = (iHi + iLo) / 2;
			int cmp = (c - aEntry[iTest].iCode);
			if (cmp >= 0) {
				iRes = iTest;
				iLo = iTest + 1;
			}
			else {
				iHi = iTest - 1;
			}
		}

		assert(iRes >= 0 && c >= aEntry[iRes].iCode);
		p = &aEntry[iRes];
		if (c<(p->iCode + p->nRange) && 0 == (0x01 & p->flags & (p->iCode ^ c))) {
			ret = (c + (aiOff[p->flags >> 1])) & 0x0000FFFF;
			assert(ret>0);
		}

		if (bRemoveDiacritic) ret = fts5_remove_diacritic(ret);
	}

	else if (c >= 66560 && c<66600) {
		ret = c + 40;
	}

	return ret;
}







static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v) {
	u32 a, b;

	
	a = *p;
	
	if (!(a & 0x80))
	{
		
		*v = a;
		return 1;
	}

	
	p++;
	b = *p;
	
	if (!(b & 0x80))
	{
		
		a &= 0x7f;
		a = a << 7;
		*v = a | b;
		return 2;
	}

	
	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		
		a &= (0x7f << 14) | (0x7f);
		b &= 0x7f;
		b = b << 7;
		*v = a | b;
		return 3;
	}

	
	{
		u64 v64;
		u8 n;
		p -= 2;
		n = sqlite3Fts5GetVarint(p, &v64);
		*v = (u32)v64;
		assert(n>3 && n <= 9);
		return n;
	}
}



#define SLOT_2_0     0x001fc07f
#define SLOT_4_2_0   0xf01fc07f


static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v) {
	u32 a, b, s;

	a = *p;
	
	if (!(a & 0x80))
	{
		*v = a;
		return 1;
	}

	p++;
	b = *p;
	
	if (!(b & 0x80))
	{
		a &= 0x7f;
		a = a << 7;
		a |= b;
		*v = a;
		return 2;
	}

	
	assert(SLOT_2_0 == ((0x7f << 14) | (0x7f)));
	assert(SLOT_4_2_0 == ((0xfU << 28) | (0x7f << 14) | (0x7f)));

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		a &= SLOT_2_0;
		b &= 0x7f;
		b = b << 7;
		a |= b;
		*v = a;
		return 3;
	}

	
	a &= SLOT_2_0;
	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		b &= SLOT_2_0;
		
		
		a = a << 7;
		a |= b;
		*v = a;
		return 4;
	}

	
	
	
	
	
	b &= SLOT_2_0;
	s = a;
	

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		
		
		
		b = b << 7;
		a |= b;
		s = s >> 18;
		*v = ((u64)s) << 32 | a;
		return 5;
	}

	
	s = s << 7;
	s |= b;
	

	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		
		
		a &= SLOT_2_0;
		a = a << 7;
		a |= b;
		s = s >> 18;
		*v = ((u64)s) << 32 | a;
		return 6;
	}

	p++;
	a = a << 14;
	a |= *p;
	
	if (!(a & 0x80))
	{
		a &= SLOT_4_2_0;
		b &= SLOT_2_0;
		b = b << 7;
		a |= b;
		s = s >> 11;
		*v = ((u64)s) << 32 | a;
		return 7;
	}

	
	a &= SLOT_2_0;
	p++;
	b = b << 14;
	b |= *p;
	
	if (!(b & 0x80))
	{
		b &= SLOT_4_2_0;
		
		
		a = a << 7;
		a |= b;
		s = s >> 4;
		*v = ((u64)s) << 32 | a;
		return 8;
	}

	p++;
	a = a << 15;
	a |= *p;
	

	
	
	b &= SLOT_2_0;
	b = b << 8;
	a |= b;

	s = s << 4;
	b = p[-4];
	b &= 0x7f;
	b = b >> 3;
	s |= b;

	*v = ((u64)s) << 32 | a;

	return 9;
}



#ifdef SQLITE_NOINLINE
# define FTS5_NOINLINE SQLITE_NOINLINE
#else
# define FTS5_NOINLINE
#endif


static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v) {
	int i, j, n;
	u8 buf[10];
	if (v & (((u64)0xff000000) << 32)) {
		p[8] = (u8)v;
		v >>= 8;
		for (i = 7; i >= 0; i--) {
			p[i] = (u8)((v & 0x7f) | 0x80);
			v >>= 7;
		}
		return 9;
	}
	n = 0;
	do {
		buf[n++] = (u8)((v & 0x7f) | 0x80);
		v >>= 7;
	} while (v != 0);
	buf[0] &= 0x7f;
	assert(n <= 9);
	for (i = 0, j = n - 1; j >= 0; j--, i++) {
		p[i] = buf[j];
	}
	return n;
}

static int sqlite3Fts5PutVarint(unsigned char *p, u64 v) {
	if (v <= 0x7f) {
		p[0] = v & 0x7f;
		return 1;
	}
	if (v <= 0x3fff) {
		p[0] = ((v >> 7) & 0x7f) | 0x80;
		p[1] = v & 0x7f;
		return 2;
	}
	return fts5PutVarint64(p, v);
}


static int sqlite3Fts5GetVarintLen(u32 iVal) {
#if 0
	if (iVal<(1 << 7)) return 1;
#endif
	assert(iVal >= (1 << 7));
	if (iVal<(1 << 14)) return 2;
	if (iVal<(1 << 21)) return 3;
	if (iVal<(1 << 28)) return 4;
	return 5;
}








typedef struct Fts5VocabTable Fts5VocabTable;
typedef struct Fts5VocabCursor Fts5VocabCursor;

struct Fts5VocabTable {
	sqlite3_vtab base;
	char *zFts5Tbl;                 
	char *zFts5Db;                  
	sqlite3 *db;                    
	Fts5Global *pGlobal;            
	int eType;                      
};

struct Fts5VocabCursor {
	sqlite3_vtab_cursor base;
	sqlite3_stmt *pStmt;            
	Fts5Index *pIndex;              

	int bEof;                       
	Fts5IndexIter *pIter;           

	int nLeTerm;                    
	char *zLeTerm;                  

									
	Fts5Config *pConfig;            
	int iCol;
	i64 *aCnt;
	i64 *aDoc;

	
	i64 rowid;                      
	Fts5Buffer term;                
};

#define FTS5_VOCAB_COL    0
#define FTS5_VOCAB_ROW    1

#define FTS5_VOCAB_COL_SCHEMA  "term, col, doc, cnt"
#define FTS5_VOCAB_ROW_SCHEMA  "term, doc, cnt"


#define FTS5_VOCAB_TERM_EQ 0x01
#define FTS5_VOCAB_TERM_GE 0x02
#define FTS5_VOCAB_TERM_LE 0x04



static int fts5VocabTableType(const char *zType, char **pzErr, int *peType) {
	int rc = SQLITE_OK;
	char *zCopy = sqlite3Fts5Strndup(&rc, zType, -1);
	if (rc == SQLITE_OK) {
		sqlite3Fts5Dequote(zCopy);
		if (sqlite3_stricmp(zCopy, "col") == 0) {
			*peType = FTS5_VOCAB_COL;
		}
		else

			if (sqlite3_stricmp(zCopy, "row") == 0) {
				*peType = FTS5_VOCAB_ROW;
			}
			else
			{
				*pzErr = sqlite3_mprintf("fts5vocab: unknown table type: %Q", zCopy);
				rc = SQLITE_ERROR;
			}
		sqlite3_free(zCopy);
	}

	return rc;
}



static int fts5VocabDisconnectMethod(sqlite3_vtab *pVtab) {
	Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;
	sqlite3_free(pTab);
	return SQLITE_OK;
}


static int fts5VocabDestroyMethod(sqlite3_vtab *pVtab) {
	Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;
	sqlite3_free(pTab);
	return SQLITE_OK;
}


static int fts5VocabInitVtab(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVTab,          
	char **pzErr                    
) {
	const char *azSchema[] = {
		"CREATE TABlE vocab(" FTS5_VOCAB_COL_SCHEMA  ")",
		"CREATE TABlE vocab(" FTS5_VOCAB_ROW_SCHEMA  ")"
	};

	Fts5VocabTable *pRet = 0;
	int rc = SQLITE_OK;             
	int bDb;

	bDb = (argc == 6 && strlen(argv[1]) == 4 && memcmp("temp", argv[1], 4) == 0);

	if (argc != 5 && bDb == 0) {
		*pzErr = sqlite3_mprintf("wrong number of vtable arguments");
		rc = SQLITE_ERROR;
	}
	else {
		int nByte;                      
		const char *zDb = bDb ? argv[3] : argv[1];
		const char *zTab = bDb ? argv[4] : argv[3];
		const char *zType = bDb ? argv[5] : argv[4];
		int nDb = (int)strlen(zDb) + 1;
		int nTab = (int)strlen(zTab) + 1;
		int eType = 0;

		rc = fts5VocabTableType(zType, pzErr, &eType);
		if (rc == SQLITE_OK) {
			assert(eType >= 0 && eType<ArraySize(azSchema));
			rc = sqlite3_declare_vtab(db, azSchema[eType]);
		}

		nByte = sizeof(Fts5VocabTable) + nDb + nTab;
		pRet = sqlite3Fts5MallocZero(&rc, nByte);
		if (pRet) {
			pRet->pGlobal = (Fts5Global*)pAux;
			pRet->eType = eType;
			pRet->db = db;
			pRet->zFts5Tbl = (char*)&pRet[1];
			pRet->zFts5Db = &pRet->zFts5Tbl[nTab];
			memcpy(pRet->zFts5Tbl, zTab, nTab);
			memcpy(pRet->zFts5Db, zDb, nDb);
			sqlite3Fts5Dequote(pRet->zFts5Tbl);
			sqlite3Fts5Dequote(pRet->zFts5Db);
		}
	}

	*ppVTab = (sqlite3_vtab*)pRet;
	return rc;
}



static int fts5VocabConnectMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);
}
static int fts5VocabCreateMethod(
	sqlite3 *db,                    
	void *pAux,                     
	int argc,                       
	const char * const *argv,       
	sqlite3_vtab **ppVtab,          
	char **pzErr                    
) {
	return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);
}


static int fts5VocabBestIndexMethod(
	sqlite3_vtab *pUnused,
	sqlite3_index_info *pInfo
) {
	int i;
	int iTermEq = -1;
	int iTermGe = -1;
	int iTermLe = -1;
	int idxNum = 0;
	int nArg = 0;

	UNUSED_PARAM(pUnused);

	for (i = 0; i<pInfo->nConstraint; i++) {
		struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
		if (p->usable == 0) continue;
		if (p->iColumn == 0) {          
			if (p->op == SQLITE_INDEX_CONSTRAINT_EQ) iTermEq = i;
			if (p->op == SQLITE_INDEX_CONSTRAINT_LE) iTermLe = i;
			if (p->op == SQLITE_INDEX_CONSTRAINT_LT) iTermLe = i;
			if (p->op == SQLITE_INDEX_CONSTRAINT_GE) iTermGe = i;
			if (p->op == SQLITE_INDEX_CONSTRAINT_GT) iTermGe = i;
		}
	}

	if (iTermEq >= 0) {
		idxNum |= FTS5_VOCAB_TERM_EQ;
		pInfo->aConstraintUsage[iTermEq].argvIndex = ++nArg;
		pInfo->estimatedCost = 100;
	}
	else {
		pInfo->estimatedCost = 1000000;
		if (iTermGe >= 0) {
			idxNum |= FTS5_VOCAB_TERM_GE;
			pInfo->aConstraintUsage[iTermGe].argvIndex = ++nArg;
			pInfo->estimatedCost = pInfo->estimatedCost / 2;
		}
		if (iTermLe >= 0) {
			idxNum |= FTS5_VOCAB_TERM_LE;
			pInfo->aConstraintUsage[iTermLe].argvIndex = ++nArg;
			pInfo->estimatedCost = pInfo->estimatedCost / 2;
		}
	}

	
	if (pInfo->nOrderBy == 1
		&& pInfo->aOrderBy[0].iColumn == 0
		&& pInfo->aOrderBy[0].desc == 0
		) {
		pInfo->orderByConsumed = 1;
	}

	pInfo->idxNum = idxNum;
	return SQLITE_OK;
}


static int fts5VocabOpenMethod(
	sqlite3_vtab *pVTab,
	sqlite3_vtab_cursor **ppCsr
) {
	Fts5VocabTable *pTab = (Fts5VocabTable*)pVTab;
	Fts5Index *pIndex = 0;
	Fts5Config *pConfig = 0;
	Fts5VocabCursor *pCsr = 0;
	int rc = SQLITE_OK;
	sqlite3_stmt *pStmt = 0;
	char *zSql = 0;

	zSql = sqlite3Fts5Mprintf(&rc,
		"SELECT t.%Q FROM %Q.%Q AS t WHERE t.%Q MATCH '*id'",
		pTab->zFts5Tbl, pTab->zFts5Db, pTab->zFts5Tbl, pTab->zFts5Tbl
	);
	if (zSql) {
		rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);
	}
	sqlite3_free(zSql);
	assert(rc == SQLITE_OK || pStmt == 0);
	if (rc == SQLITE_ERROR) rc = SQLITE_OK;

	if (pStmt && sqlite3_step(pStmt) == SQLITE_ROW) {
		i64 iId = sqlite3_column_int64(pStmt, 0);
		pIndex = sqlite3Fts5IndexFromCsrid(pTab->pGlobal, iId, &pConfig);
	}

	if (rc == SQLITE_OK && pIndex == 0) {
		rc = sqlite3_finalize(pStmt);
		pStmt = 0;
		if (rc == SQLITE_OK) {
			pVTab->zErrMsg = sqlite3_mprintf(
				"no such fts5 table: %s.%s", pTab->zFts5Db, pTab->zFts5Tbl
			);
			rc = SQLITE_ERROR;
		}
	}

	if (rc == SQLITE_OK) {
		int nByte = pConfig->nCol * sizeof(i64) * 2 + sizeof(Fts5VocabCursor);
		pCsr = (Fts5VocabCursor*)sqlite3Fts5MallocZero(&rc, nByte);
	}

	if (pCsr) {
		pCsr->pIndex = pIndex;
		pCsr->pStmt = pStmt;
		pCsr->pConfig = pConfig;
		pCsr->aCnt = (i64*)&pCsr[1];
		pCsr->aDoc = &pCsr->aCnt[pConfig->nCol];
	}
	else {
		sqlite3_finalize(pStmt);
	}

	*ppCsr = (sqlite3_vtab_cursor*)pCsr;
	return rc;
}

static void fts5VocabResetCursor(Fts5VocabCursor *pCsr) {
	pCsr->rowid = 0;
	sqlite3Fts5IterClose(pCsr->pIter);
	pCsr->pIter = 0;
	sqlite3_free(pCsr->zLeTerm);
	pCsr->nLeTerm = -1;
	pCsr->zLeTerm = 0;
}


static int fts5VocabCloseMethod(sqlite3_vtab_cursor *pCursor) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	fts5VocabResetCursor(pCsr);
	sqlite3Fts5BufferFree(&pCsr->term);
	sqlite3_finalize(pCsr->pStmt);
	sqlite3_free(pCsr);
	return SQLITE_OK;
}



static int fts5VocabNextMethod(sqlite3_vtab_cursor *pCursor) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;
	int rc = SQLITE_OK;
	int nCol = pCsr->pConfig->nCol;

	pCsr->rowid++;

	if (pTab->eType == FTS5_VOCAB_COL) {
		for (pCsr->iCol++; pCsr->iCol<nCol; pCsr->iCol++) {
			if (pCsr->aDoc[pCsr->iCol]) break;
		}
	}

	if (pTab->eType == FTS5_VOCAB_ROW || pCsr->iCol >= nCol) {
		if (sqlite3Fts5IterEof(pCsr->pIter)) {
			pCsr->bEof = 1;
		}
		else {
			const char *zTerm;
			int nTerm;

			zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
			if (pCsr->nLeTerm >= 0) {
				int nCmp = MIN(nTerm, pCsr->nLeTerm);
				int bCmp = memcmp(pCsr->zLeTerm, zTerm, nCmp);
				if (bCmp<0 || (bCmp == 0 && pCsr->nLeTerm<nTerm)) {
					pCsr->bEof = 1;
					return SQLITE_OK;
				}
			}

			sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
			memset(pCsr->aCnt, 0, nCol * sizeof(i64));
			memset(pCsr->aDoc, 0, nCol * sizeof(i64));
			pCsr->iCol = 0;

			assert(pTab->eType == FTS5_VOCAB_COL || pTab->eType == FTS5_VOCAB_ROW);
			while (rc == SQLITE_OK) {
				const u8 *pPos; int nPos;   
				i64 iPos = 0;               
				int iOff = 0;               

				pPos = pCsr->pIter->pData;
				nPos = pCsr->pIter->nData;
				switch (pCsr->pConfig->eDetail) {
				case FTS5_DETAIL_FULL:
					pPos = pCsr->pIter->pData;
					nPos = pCsr->pIter->nData;
					if (pTab->eType == FTS5_VOCAB_ROW) {
						while (0 == sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos)) {
							pCsr->aCnt[0]++;
						}
						pCsr->aDoc[0]++;
					}
					else {
						int iCol = -1;
						while (0 == sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos)) {
							int ii = FTS5_POS2COLUMN(iPos);
							pCsr->aCnt[ii]++;
							if (iCol != ii) {
								if (ii >= nCol) {
									rc = FTS5_CORRUPT;
									break;
								}
								pCsr->aDoc[ii]++;
								iCol = ii;
							}
						}
					}
					break;

				case FTS5_DETAIL_COLUMNS:
					if (pTab->eType == FTS5_VOCAB_ROW) {
						pCsr->aDoc[0]++;
					}
					else {
						while (0 == sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos)) {
							assert_nc(iPos >= 0 && iPos<nCol);
							if (iPos >= nCol) {
								rc = FTS5_CORRUPT;
								break;
							}
							pCsr->aDoc[iPos]++;
						}
					}
					break;

				default:
					assert(pCsr->pConfig->eDetail == FTS5_DETAIL_NONE);
					pCsr->aDoc[0]++;
					break;
				}

				if (rc == SQLITE_OK) {
					rc = sqlite3Fts5IterNextScan(pCsr->pIter);
				}

				if (rc == SQLITE_OK) {
					zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
					if (nTerm != pCsr->term.n || memcmp(zTerm, pCsr->term.p, nTerm)) {
						break;
					}
					if (sqlite3Fts5IterEof(pCsr->pIter)) break;
				}
			}
		}
	}

	if (rc == SQLITE_OK && pCsr->bEof == 0 && pTab->eType == FTS5_VOCAB_COL) {
		while (pCsr->aDoc[pCsr->iCol] == 0) pCsr->iCol++;
		assert(pCsr->iCol<pCsr->pConfig->nCol);
	}
	return rc;
}


static int fts5VocabFilterMethod(
	sqlite3_vtab_cursor *pCursor,   
	int idxNum,                     
	const char *zUnused,            
	int nUnused,                    
	sqlite3_value **apVal           
) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	int rc = SQLITE_OK;

	int iVal = 0;
	int f = FTS5INDEX_QUERY_SCAN;
	const char *zTerm = 0;
	int nTerm = 0;

	sqlite3_value *pEq = 0;
	sqlite3_value *pGe = 0;
	sqlite3_value *pLe = 0;

	UNUSED_PARAM2(zUnused, nUnused);

	fts5VocabResetCursor(pCsr);
	if (idxNum & FTS5_VOCAB_TERM_EQ) pEq = apVal[iVal++];
	if (idxNum & FTS5_VOCAB_TERM_GE) pGe = apVal[iVal++];
	if (idxNum & FTS5_VOCAB_TERM_LE) pLe = apVal[iVal++];

	if (pEq) {
		zTerm = (const char *)sqlite3_value_text(pEq);
		nTerm = sqlite3_value_bytes(pEq);
		f = 0;
	}
	else {
		if (pGe) {
			zTerm = (const char *)sqlite3_value_text(pGe);
			nTerm = sqlite3_value_bytes(pGe);
		}
		if (pLe) {
			const char *zCopy = (const char *)sqlite3_value_text(pLe);
			pCsr->nLeTerm = sqlite3_value_bytes(pLe);
			pCsr->zLeTerm = sqlite3_malloc(pCsr->nLeTerm + 1);
			if (pCsr->zLeTerm == 0) {
				rc = SQLITE_NOMEM;
			}
			else {
				memcpy(pCsr->zLeTerm, zCopy, pCsr->nLeTerm + 1);
			}
		}
	}


	if (rc == SQLITE_OK) {
		rc = sqlite3Fts5IndexQuery(pCsr->pIndex, zTerm, nTerm, f, 0, &pCsr->pIter);
	}
	if (rc == SQLITE_OK) {
		rc = fts5VocabNextMethod(pCursor);
	}

	return rc;
}


static int fts5VocabEofMethod(sqlite3_vtab_cursor *pCursor) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	return pCsr->bEof;
}

static int fts5VocabColumnMethod(
	sqlite3_vtab_cursor *pCursor,   
	sqlite3_context *pCtx,          
	int iCol                        
) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	int eDetail = pCsr->pConfig->eDetail;
	int eType = ((Fts5VocabTable*)(pCursor->pVtab))->eType;
	i64 iVal = 0;

	if (iCol == 0) {
		sqlite3_result_text(
			pCtx, (const char*)pCsr->term.p, pCsr->term.n, SQLITE_TRANSIENT
		);
	}
	else if (eType == FTS5_VOCAB_COL) {
		assert(iCol == 1 || iCol == 2 || iCol == 3);
		if (iCol == 1) {
			if (eDetail != FTS5_DETAIL_NONE) {
				const char *z = pCsr->pConfig->azCol[pCsr->iCol];
				sqlite3_result_text(pCtx, z, -1, SQLITE_STATIC);
			}
		}
		else if (iCol == 2) {
			iVal = pCsr->aDoc[pCsr->iCol];
		}
		else {
			iVal = pCsr->aCnt[pCsr->iCol];
		}
	}
	else {
		assert(iCol == 1 || iCol == 2);
		if (iCol == 1) {
			iVal = pCsr->aDoc[0];
		}
		else {
			iVal = pCsr->aCnt[0];
		}
	}

	if (iVal>0) sqlite3_result_int64(pCtx, iVal);
	return SQLITE_OK;
}


static int fts5VocabRowidMethod(
	sqlite3_vtab_cursor *pCursor,
	sqlite_int64 *pRowid
) {
	Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
	*pRowid = pCsr->rowid;
	return SQLITE_OK;
}

static int sqlite3Fts5VocabInit(Fts5Global *pGlobal, sqlite3 *db) {
	static const sqlite3_module fts5Vocab = {
		 2,
		 fts5VocabCreateMethod,
		 fts5VocabConnectMethod,
		 fts5VocabBestIndexMethod,
		 fts5VocabDisconnectMethod,
		 fts5VocabDestroyMethod,
		 fts5VocabOpenMethod,
		 fts5VocabCloseMethod,
		 fts5VocabFilterMethod,
		 fts5VocabNextMethod,
		 fts5VocabEofMethod,
		 fts5VocabColumnMethod,
		 fts5VocabRowidMethod,
		 0,
		 0,
		 0,
		 0,
		 0,
		 0,
		 0,
		 0,
		 0,
		 0,
	};
	void *p = (void*)pGlobal;

	return sqlite3_create_module_v2(db, "fts5vocab", &fts5Vocab, p, 0);
}





#endif 


